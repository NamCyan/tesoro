{"id":161,"original_code":"protected final void addSequences(List<String> seqNames, Long seqDefaultValue, boolean ignoreFailure) throws SQLException{\n    \/\/ ToDo: rewrite function to use one SQL call per select\/insert for all items\n    for (String seqName: seqNames){\n      addSequence(seqName, seqDefaultValue, ignoreFailure);\n    }\n  }","code_wo_comment":"protected final void addSequences(List<String> seqNames, Long seqDefaultValue, boolean ignoreFailure) throws SQLException{\n   \n    for (String seqName: seqNames){\n      addSequence(seqName, seqDefaultValue, ignoreFailure);\n    }\n  }","cleancode":"protected final void addsequences(list<string> seqnames, long seqdefaultvalue, boolean ignorefailure) throws sqlexception{ for (string seqname: seqnames){ addsequence(seqname, seqdefaultvalue, ignorefailure); } }","repo":"shavi71\/ambari","label":[1,0,0,0]}
{"id":24756,"original_code":"public static void addChatMessageFixed(ICommandSender sender, IChatComponent message) {\n        if (sender == null || message == null) return;\n        if (sender instanceof EntityPlayerMP) {\n            if (((EntityPlayerMP)sender).playerNetServerHandler != null) {\n                sender.addChatMessage(message);\n            } else {\n                \/\/TODO Find a way to re-send the message.\n            }\n        } else {\n            sender.addChatMessage(message);\n        }\n    }","code_wo_comment":"public static void addChatMessageFixed(ICommandSender sender, IChatComponent message) {\n        if (sender == null || message == null) return;\n        if (sender instanceof EntityPlayerMP) {\n            if (((EntityPlayerMP)sender).playerNetServerHandler != null) {\n                sender.addChatMessage(message);\n            } else {\n               \n            }\n        } else {\n            sender.addChatMessage(message);\n        }\n    }","cleancode":"public static void addchatmessagefixed(icommandsender sender, ichatcomponent message) { if (sender == null || message == null) return; if (sender instanceof entityplayermp) { if (((entityplayermp)sender).playernetserverhandler != null) { sender.addchatmessage(message); } else { } } else { sender.addchatmessage(message); } }","repo":"repo-alt\/MyEssentials-Core","label":[0,1,0,0]}
{"id":33024,"original_code":"public Node addNode(String s) throws ItemExistsException, PathNotFoundException, VersionException, ConstraintViolationException, LockException, RepositoryException {\n        return null;\n    }","code_wo_comment":"public Node addNode(String s) throws ItemExistsException, PathNotFoundException, VersionException, ConstraintViolationException, LockException, RepositoryException {\n        return null;\n    }","cleancode":"public node addnode(string s) throws itemexistsexception, pathnotfoundexception, versionexception, constraintviolationexception, lockexception, repositoryexception { return null; }","repo":"sohaniwso2\/carbon-registry-1","label":[0,1,0,0]}
{"id":33065,"original_code":"private List<DataPoint> getIntersectedSetUsingQuadTree(List<DataPoint> dataset, Rectangle rect) {\n\t\tthrow new UnsupportedOperationException(\"Not Yet Implemented\");\n\t}","code_wo_comment":"private List<DataPoint> getIntersectedSetUsingQuadTree(List<DataPoint> dataset, Rectangle rect) {\n\t\tthrow new UnsupportedOperationException(\"Not Yet Implemented\");\n\t}","cleancode":"private list<datapoint> getintersectedsetusingquadtree(list<datapoint> dataset, rectangle rect) { throw new unsupportedoperationexception(\"not yet implemented\"); }","repo":"smozely\/QuadTree","label":[0,1,0,0]}
{"id":8490,"original_code":"private static String getSampleWithLineBreak(){\n        StringBuilder sb = new StringBuilder();\n        sb.append(\"[\");\n        for(int i = 1; i < 4; i++){\n            sb.append(getTypicalElement(i));\n            sb.append(\",\");\n        }\n        sb.append(\"{\\\"id\\\" : 4,\" +\n                \"\\\"author\\\" : \\\"With line\\\\n break\\\",\" + \/\/FIXME this line break is doubled - is this correct??\n                \"\\\"title\\\" : \\\"Book title 4\\\",\" +\n                \"\\\"publish_date\\\" : \\\"2010-05-26\\\"\" +\n                \"},\");\n        sb.append(getTypicalElement(5));\n        sb.append(\",\");\n        sb.append(getTypicalElement(6));\n        sb.append(\"]\");\n        return sb.toString();\n    }","code_wo_comment":"private static String getSampleWithLineBreak(){\n        StringBuilder sb = new StringBuilder();\n        sb.append(\"[\");\n        for(int i = 1; i < 4; i++){\n            sb.append(getTypicalElement(i));\n            sb.append(\",\");\n        }\n        sb.append(\"{\\\"id\\\" : 4,\" +\n                \"\\\"author\\\" : \\\"With line\\\\n break\\\",\" +\n                \"\\\"title\\\" : \\\"Book title 4\\\",\" +\n                \"\\\"publish_date\\\" : \\\"2010-05-26\\\"\" +\n                \"},\");\n        sb.append(getTypicalElement(5));\n        sb.append(\",\");\n        sb.append(getTypicalElement(6));\n        sb.append(\"]\");\n        return sb.toString();\n    }","cleancode":"private static string getsamplewithlinebreak(){ stringbuilder sb = new stringbuilder(); sb.append(\"[\"); for(int i = 1; i < 4; i++){ sb.append(gettypicalelement(i)); sb.append(\",\"); } sb.append(\"{\\\"id\\\" : 4,\" + \"\\\"author\\\" : \\\"with line\\\\n break\\\",\" + \"\\\"title\\\" : \\\"book title 4\\\",\" + \"\\\"publish_date\\\" : \\\"2010-05-26\\\"\" + \"},\"); sb.append(gettypicalelement(5)); sb.append(\",\"); sb.append(gettypicalelement(6)); sb.append(\"]\"); return sb.tostring(); }","repo":"sbalineni19\/OpenRefine","label":[0,0,1,0]}
{"id":24911,"original_code":"@ParameterizedTest\n    @MethodSource(\"data\") \/\/ bug in junit csvsource parsing - it does a trim, using a manual parsing as workaround\n    void parse(final String csv) {\n        final String[] parts = csv.split(\",\");\n        parse(parser, parts[0], parseInt(parts[1]), parseBoolean(parts[2]), null, parseInt(parts[3]));\n    }","code_wo_comment":"@ParameterizedTest\n    @MethodSource(\"data\")\n    void parse(final String csv) {\n        final String[] parts = csv.split(\",\");\n        parse(parser, parts[0], parseInt(parts[1]), parseBoolean(parts[2]), null, parseInt(parts[3]));\n    }","cleancode":"@parameterizedtest @methodsource(\"data\") void parse(final string csv) { final string[] parts = csv.split(\",\"); parse(parser, parts[0], parseint(parts[1]), parseboolean(parts[2]), null, parseint(parts[3])); }","repo":"rmannibucau\/access-log-stats","label":[0,0,1,0]}
{"id":380,"original_code":"@Override\n\t\tpublic boolean accept(File pathname)\n\t\t{\n\t\t\t\/\/ TODO: More checking here - actually parse out tile coord\n\t\t\treturn pathname.isFile() && pathname.getName().endsWith(\".tile\");\n\t\t}","code_wo_comment":"@Override\n\t\tpublic boolean accept(File pathname)\n\t\t{\n\t\t\n\t\t\treturn pathname.isFile() && pathname.getName().endsWith(\".tile\");\n\t\t}","cleancode":"@override public boolean accept(file pathname) { return pathname.isfile() && pathname.getname().endswith(\".tile\"); }","repo":"snuk182\/tectonicus","label":[0,1,0,0]}
{"id":386,"original_code":"public static <T> MetricStorage doubleAsynchronousAccumulator(\n      View view,\n      InstrumentDescriptor instrument,\n      Consumer<ObservableDoubleMeasurement> metricUpdater) {\n    final MetricDescriptor metricDescriptor = MetricDescriptor.create(view, instrument);\n    Aggregator<T> aggregator =\n        view.getAggregation().createAggregator(instrument, ExemplarFilter.neverSample());\n    final AsyncAccumulator<T> measurementAccumulator = new AsyncAccumulator<>(instrument);\n    if (Aggregator.empty() == aggregator) {\n      return empty();\n    }\n    final AttributesProcessor attributesProcessor = view.getAttributesProcessor();\n    \/\/ TODO: Find a way to grab the measurement JUST ONCE for all async metrics.\n    final ObservableDoubleMeasurement result =\n        new ObservableDoubleMeasurement() {\n          @Override\n          public void observe(double value, Attributes attributes) {\n            T accumulation =\n                aggregator.accumulateDoubleMeasurement(value, attributes, Context.current());\n            if (accumulation != null) {\n              measurementAccumulator.record(\n                  attributesProcessor.process(attributes, Context.current()), accumulation);\n            }\n          }\n          @Override\n          public void observe(double value) {\n            observe(value, Attributes.empty());\n          }\n        };\n    return new AsynchronousMetricStorage<>(\n        metricDescriptor, aggregator, measurementAccumulator, () -> metricUpdater.accept(result));\n  }","code_wo_comment":"public static <T> MetricStorage doubleAsynchronousAccumulator(\n      View view,\n      InstrumentDescriptor instrument,\n      Consumer<ObservableDoubleMeasurement> metricUpdater) {\n    final MetricDescriptor metricDescriptor = MetricDescriptor.create(view, instrument);\n    Aggregator<T> aggregator =\n        view.getAggregation().createAggregator(instrument, ExemplarFilter.neverSample());\n    final AsyncAccumulator<T> measurementAccumulator = new AsyncAccumulator<>(instrument);\n    if (Aggregator.empty() == aggregator) {\n      return empty();\n    }\n    final AttributesProcessor attributesProcessor = view.getAttributesProcessor();\n   \n    final ObservableDoubleMeasurement result =\n        new ObservableDoubleMeasurement() {\n          @Override\n          public void observe(double value, Attributes attributes) {\n            T accumulation =\n                aggregator.accumulateDoubleMeasurement(value, attributes, Context.current());\n            if (accumulation != null) {\n              measurementAccumulator.record(\n                  attributesProcessor.process(attributes, Context.current()), accumulation);\n            }\n          }\n          @Override\n          public void observe(double value) {\n            observe(value, Attributes.empty());\n          }\n        };\n    return new AsynchronousMetricStorage<>(\n        metricDescriptor, aggregator, measurementAccumulator, () -> metricUpdater.accept(result));\n  }","cleancode":"public static <t> metricstorage doubleasynchronousaccumulator( view view, instrumentdescriptor instrument, consumer<observabledoublemeasurement> metricupdater) { final metricdescriptor metricdescriptor = metricdescriptor.create(view, instrument); aggregator<t> aggregator = view.getaggregation().createaggregator(instrument, exemplarfilter.neversample()); final asyncaccumulator<t> measurementaccumulator = new asyncaccumulator<>(instrument); if (aggregator.empty() == aggregator) { return empty(); } final attributesprocessor attributesprocessor = view.getattributesprocessor(); final observabledoublemeasurement result = new observabledoublemeasurement() { @override public void observe(double value, attributes attributes) { t accumulation = aggregator.accumulatedoublemeasurement(value, attributes, context.current()); if (accumulation != null) { measurementaccumulator.record( attributesprocessor.process(attributes, context.current()), accumulation); } } @override public void observe(double value) { observe(value, attributes.empty()); } }; return new asynchronousmetricstorage<>( metricdescriptor, aggregator, measurementaccumulator, () -> metricupdater.accept(result)); }","repo":"svalaskevicius\/opentelemetry-java","label":[1,0,0,0]}
{"id":387,"original_code":"public static <T> MetricStorage longAsynchronousAccumulator(\n      View view,\n      InstrumentDescriptor instrument,\n      Consumer<ObservableLongMeasurement> metricUpdater) {\n    final MetricDescriptor metricDescriptor = MetricDescriptor.create(view, instrument);\n    Aggregator<T> aggregator =\n        view.getAggregation().createAggregator(instrument, ExemplarFilter.neverSample());\n    final AsyncAccumulator<T> measurementAccumulator = new AsyncAccumulator<>(instrument);\n    final AttributesProcessor attributesProcessor = view.getAttributesProcessor();\n    \/\/ TODO: Find a way to grab the measurement JUST ONCE for all async metrics.\n    final ObservableLongMeasurement result =\n        new ObservableLongMeasurement() {\n          @Override\n          public void observe(long value, Attributes attributes) {\n            T accumulation =\n                aggregator.accumulateLongMeasurement(value, attributes, Context.current());\n            if (accumulation != null) {\n              measurementAccumulator.record(\n                  attributesProcessor.process(attributes, Context.current()), accumulation);\n            }\n          }\n          @Override\n          public void observe(long value) {\n            observe(value, Attributes.empty());\n          }\n        };\n    return new AsynchronousMetricStorage<>(\n        metricDescriptor, aggregator, measurementAccumulator, () -> metricUpdater.accept(result));\n  }","code_wo_comment":"public static <T> MetricStorage longAsynchronousAccumulator(\n      View view,\n      InstrumentDescriptor instrument,\n      Consumer<ObservableLongMeasurement> metricUpdater) {\n    final MetricDescriptor metricDescriptor = MetricDescriptor.create(view, instrument);\n    Aggregator<T> aggregator =\n        view.getAggregation().createAggregator(instrument, ExemplarFilter.neverSample());\n    final AsyncAccumulator<T> measurementAccumulator = new AsyncAccumulator<>(instrument);\n    final AttributesProcessor attributesProcessor = view.getAttributesProcessor();\n   \n    final ObservableLongMeasurement result =\n        new ObservableLongMeasurement() {\n          @Override\n          public void observe(long value, Attributes attributes) {\n            T accumulation =\n                aggregator.accumulateLongMeasurement(value, attributes, Context.current());\n            if (accumulation != null) {\n              measurementAccumulator.record(\n                  attributesProcessor.process(attributes, Context.current()), accumulation);\n            }\n          }\n          @Override\n          public void observe(long value) {\n            observe(value, Attributes.empty());\n          }\n        };\n    return new AsynchronousMetricStorage<>(\n        metricDescriptor, aggregator, measurementAccumulator, () -> metricUpdater.accept(result));\n  }","cleancode":"public static <t> metricstorage longasynchronousaccumulator( view view, instrumentdescriptor instrument, consumer<observablelongmeasurement> metricupdater) { final metricdescriptor metricdescriptor = metricdescriptor.create(view, instrument); aggregator<t> aggregator = view.getaggregation().createaggregator(instrument, exemplarfilter.neversample()); final asyncaccumulator<t> measurementaccumulator = new asyncaccumulator<>(instrument); final attributesprocessor attributesprocessor = view.getattributesprocessor(); final observablelongmeasurement result = new observablelongmeasurement() { @override public void observe(long value, attributes attributes) { t accumulation = aggregator.accumulatelongmeasurement(value, attributes, context.current()); if (accumulation != null) { measurementaccumulator.record( attributesprocessor.process(attributes, context.current()), accumulation); } } @override public void observe(long value) { observe(value, attributes.empty()); } }; return new asynchronousmetricstorage<>( metricdescriptor, aggregator, measurementaccumulator, () -> metricupdater.accept(result)); }","repo":"svalaskevicius\/opentelemetry-java","label":[1,0,0,0]}
{"id":395,"original_code":"@Override\n    public Path getPath(URI uri) {\n        FileSystem fileSystem = getFileSystem(uri);\n        \/**\n         * TODO: set as a list. one s3FileSystem by region\n         *\/\n        return fileSystem.getPath(uri.getPath());\n    }","code_wo_comment":"@Override\n    public Path getPath(URI uri) {\n        FileSystem fileSystem = getFileSystem(uri);\n       \n        return fileSystem.getPath(uri.getPath());\n    }","cleancode":"@override public path getpath(uri uri) { filesystem filesystem = getfilesystem(uri); return filesystem.getpath(uri.getpath()); }","repo":"skashin\/Amazon-S3-FileSystem-NIO2","label":[1,1,0,0]}
{"id":24980,"original_code":"protected void runInContextInternal() {\n        if (s_logger.isInfoEnabled()) {\n            s_logger.info(\"starting usage job...\");\n        }\n        \/\/ how about we update the job exec time when the job starts???\n        long execTime = _jobExecTime.getTimeInMillis();\n        long now = System.currentTimeMillis() + 2000; \/\/ 2 second buffer since jobs can run a little early (though usually just by milliseconds)\n        if (execTime < now) {\n            \/\/ if exec time is in the past, calculate the next time the job will execute...if this is a one-off job that is a result\n            \/\/ of scheduleParse() then don't update the next exec time...\n            _jobExecTime.add(Calendar.MINUTE, _aggregationDuration);\n        }\n        UsageJobVO job = _usageJobDao.isOwner(_hostname, _pid);\n        if (job != null) {\n            \/\/ FIXME: we really need to do a better job of not missing any events...so we should some how\n            \/\/        keep track of the last time usage was run, then go from there...\n            \/\/ For executing the job, we treat hourly and daily as special time ranges, using the previous full hour or the previous\n            \/\/ full day.  Otherwise we just subtract off the aggregation range from the current time and use that as start date with\n            \/\/ current time as end date.\n            Calendar cal = Calendar.getInstance(_usageTimezone);\n            cal.setTime(new Date());\n            long startDate = 0;\n            long endDate = 0;\n            if (_aggregationDuration == DAILY_TIME) {\n                cal.roll(Calendar.DAY_OF_YEAR, false);\n                cal.set(Calendar.HOUR_OF_DAY, 0);\n                cal.set(Calendar.MINUTE, 0);\n                cal.set(Calendar.SECOND, 0);\n                cal.set(Calendar.MILLISECOND, 0);\n                startDate = cal.getTime().getTime();\n                cal.roll(Calendar.DAY_OF_YEAR, true);\n                cal.add(Calendar.MILLISECOND, -1);\n                endDate = cal.getTime().getTime();\n            } else if (_aggregationDuration == HOURLY_TIME) {\n                cal.roll(Calendar.HOUR_OF_DAY, false);\n                cal.set(Calendar.MINUTE, 0);\n                cal.set(Calendar.SECOND, 0);\n                cal.set(Calendar.MILLISECOND, 0);\n                startDate = cal.getTime().getTime();\n                cal.roll(Calendar.HOUR_OF_DAY, true);\n                cal.add(Calendar.MILLISECOND, -1);\n                endDate = cal.getTime().getTime();\n            } else {\n                endDate = cal.getTime().getTime(); \/\/ current time\n                cal.add(Calendar.MINUTE, -1 * _aggregationDuration);\n                startDate = cal.getTime().getTime();\n            }\n            parse(job, startDate, endDate);\n            if (_runQuota){\n                try {\n                    _quotaManager.calculateQuotaUsage();\n                }\n                catch (Exception e){\n                    s_logger.error(\"Exception received while calculating quota\", e);\n                }\n                try {\n                    _quotaStatement.sendStatement();\n                } catch (Exception e) {\n                    s_logger.error(\"Exception received while sending statements\", e);\n                }\n                try {\n                    _alertManager.checkAndSendQuotaAlertEmails();\n                } catch (Exception e) {\n                    s_logger.error(\"Exception received while sending alerts\", e);\n                }\n            }\n        } else {\n            if (s_logger.isDebugEnabled()) {\n                s_logger.debug(\"Not owner of usage job, skipping...\");\n            }\n        }\n        if (s_logger.isInfoEnabled()) {\n            s_logger.info(\"usage job complete\");\n        }\n    }","code_wo_comment":"protected void runInContextInternal() {\n        if (s_logger.isInfoEnabled()) {\n            s_logger.info(\"starting usage job...\");\n        }\n       \n        long execTime = _jobExecTime.getTimeInMillis();\n        long now = System.currentTimeMillis() + 2000;\n        if (execTime < now) {\n           \n           \n            _jobExecTime.add(Calendar.MINUTE, _aggregationDuration);\n        }\n        UsageJobVO job = _usageJobDao.isOwner(_hostname, _pid);\n        if (job != null) {\n           \n           \n           \n           \n           \n            Calendar cal = Calendar.getInstance(_usageTimezone);\n            cal.setTime(new Date());\n            long startDate = 0;\n            long endDate = 0;\n            if (_aggregationDuration == DAILY_TIME) {\n                cal.roll(Calendar.DAY_OF_YEAR, false);\n                cal.set(Calendar.HOUR_OF_DAY, 0);\n                cal.set(Calendar.MINUTE, 0);\n                cal.set(Calendar.SECOND, 0);\n                cal.set(Calendar.MILLISECOND, 0);\n                startDate = cal.getTime().getTime();\n                cal.roll(Calendar.DAY_OF_YEAR, true);\n                cal.add(Calendar.MILLISECOND, -1);\n                endDate = cal.getTime().getTime();\n            } else if (_aggregationDuration == HOURLY_TIME) {\n                cal.roll(Calendar.HOUR_OF_DAY, false);\n                cal.set(Calendar.MINUTE, 0);\n                cal.set(Calendar.SECOND, 0);\n                cal.set(Calendar.MILLISECOND, 0);\n                startDate = cal.getTime().getTime();\n                cal.roll(Calendar.HOUR_OF_DAY, true);\n                cal.add(Calendar.MILLISECOND, -1);\n                endDate = cal.getTime().getTime();\n            } else {\n                endDate = cal.getTime().getTime();\n                cal.add(Calendar.MINUTE, -1 * _aggregationDuration);\n                startDate = cal.getTime().getTime();\n            }\n            parse(job, startDate, endDate);\n            if (_runQuota){\n                try {\n                    _quotaManager.calculateQuotaUsage();\n                }\n                catch (Exception e){\n                    s_logger.error(\"Exception received while calculating quota\", e);\n                }\n                try {\n                    _quotaStatement.sendStatement();\n                } catch (Exception e) {\n                    s_logger.error(\"Exception received while sending statements\", e);\n                }\n                try {\n                    _alertManager.checkAndSendQuotaAlertEmails();\n                } catch (Exception e) {\n                    s_logger.error(\"Exception received while sending alerts\", e);\n                }\n            }\n        } else {\n            if (s_logger.isDebugEnabled()) {\n                s_logger.debug(\"Not owner of usage job, skipping...\");\n            }\n        }\n        if (s_logger.isInfoEnabled()) {\n            s_logger.info(\"usage job complete\");\n        }\n    }","cleancode":"protected void runincontextinternal() { if (s_logger.isinfoenabled()) { s_logger.info(\"starting usage job...\"); } long exectime = _jobexectime.gettimeinmillis(); long now = system.currenttimemillis() + 2000; if (exectime < now) { _jobexectime.add(calendar.minute, _aggregationduration); } usagejobvo job = _usagejobdao.isowner(_hostname, _pid); if (job != null) { calendar cal = calendar.getinstance(_usagetimezone); cal.settime(new date()); long startdate = 0; long enddate = 0; if (_aggregationduration == daily_time) { cal.roll(calendar.day_of_year, false); cal.set(calendar.hour_of_day, 0); cal.set(calendar.minute, 0); cal.set(calendar.second, 0); cal.set(calendar.millisecond, 0); startdate = cal.gettime().gettime(); cal.roll(calendar.day_of_year, true); cal.add(calendar.millisecond, -1); enddate = cal.gettime().gettime(); } else if (_aggregationduration == hourly_time) { cal.roll(calendar.hour_of_day, false); cal.set(calendar.minute, 0); cal.set(calendar.second, 0); cal.set(calendar.millisecond, 0); startdate = cal.gettime().gettime(); cal.roll(calendar.hour_of_day, true); cal.add(calendar.millisecond, -1); enddate = cal.gettime().gettime(); } else { enddate = cal.gettime().gettime(); cal.add(calendar.minute, -1 * _aggregationduration); startdate = cal.gettime().gettime(); } parse(job, startdate, enddate); if (_runquota){ try { _quotamanager.calculatequotausage(); } catch (exception e){ s_logger.error(\"exception received while calculating quota\", e); } try { _quotastatement.sendstatement(); } catch (exception e) { s_logger.error(\"exception received while sending statements\", e); } try { _alertmanager.checkandsendquotaalertemails(); } catch (exception e) { s_logger.error(\"exception received while sending alerts\", e); } } } else { if (s_logger.isdebugenabled()) { s_logger.debug(\"not owner of usage job, skipping...\"); } } if (s_logger.isinfoenabled()) { s_logger.info(\"usage job complete\"); } }","repo":"serbaut\/cloudstack","label":[1,0,1,0]}
{"id":24981,"original_code":"@Override\n    public void parse(UsageJobVO job, long startDateMillis, long endDateMillis) {\n        \/\/ TODO: Shouldn't we also allow parsing by the type of usage?\n        boolean success = false;\n        long timeStart = System.currentTimeMillis();\n        try {\n            if ((endDateMillis == 0) || (endDateMillis > timeStart)) {\n                endDateMillis = timeStart;\n            }\n            long lastSuccess = _usageJobDao.getLastJobSuccessDateMillis();\n            if (lastSuccess != 0) {\n                startDateMillis = lastSuccess + 1; \/\/ 1 millisecond after\n            }\n            if (startDateMillis >= endDateMillis) {\n                if (s_logger.isInfoEnabled()) {\n                    s_logger.info(\"not parsing usage records since start time mills (\" + startDateMillis + \") is on or after end time millis (\" + endDateMillis + \")\");\n                }\n                TransactionLegacy jobUpdateTxn = TransactionLegacy.open(TransactionLegacy.USAGE_DB);\n                try {\n                    jobUpdateTxn.start();\n                    \/\/ everything seemed to work...set endDate as the last success date\n                    _usageJobDao.updateJobSuccess(job.getId(), startDateMillis, endDateMillis, System.currentTimeMillis() - timeStart, success);\n                    \/\/ create a new job if this is a recurring job\n                    if (job.getJobType() == UsageJobVO.JOB_TYPE_RECURRING) {\n                        _usageJobDao.createNewJob(_hostname, _pid, UsageJobVO.JOB_TYPE_RECURRING);\n                    }\n                    jobUpdateTxn.commit();\n                } finally {\n                    jobUpdateTxn.close();\n                }\n                return;\n            }\n            Date startDate = new Date(startDateMillis);\n            Date endDate = new Date(endDateMillis);\n            if (s_logger.isInfoEnabled()) {\n                s_logger.info(\"Parsing usage records between \" + startDate + \" and \" + endDate);\n            }\n            List<AccountVO> accounts = null;\n            List<UserStatisticsVO> userStats = null;\n            Map<String, UsageNetworkVO> networkStats = null;\n            List<VmDiskStatisticsVO> vmDiskStats = null;\n            Map<String, UsageVmDiskVO> vmDiskUsages = null;\n            TransactionLegacy userTxn = TransactionLegacy.open(TransactionLegacy.CLOUD_DB);\n            try {\n                Long limit = Long.valueOf(500);\n                Long offset = Long.valueOf(0);\n                Long lastAccountId = _usageDao.getLastAccountId();\n                if (lastAccountId == null) {\n                    lastAccountId = Long.valueOf(0);\n                }\n                do {\n                    Filter filter = new Filter(AccountVO.class, \"id\", true, offset, limit);\n                    accounts = _accountDao.findActiveAccounts(lastAccountId, filter);\n                    if ((accounts != null) && !accounts.isEmpty()) {\n                        \/\/ now update the accounts in the cloud_usage db\n                        _usageDao.updateAccounts(accounts);\n                    }\n                    offset = new Long(offset.longValue() + limit.longValue());\n                } while ((accounts != null) && !accounts.isEmpty());\n                \/\/ reset offset\n                offset = Long.valueOf(0);\n                do {\n                    Filter filter = new Filter(AccountVO.class, \"id\", true, offset, limit);\n                    accounts = _accountDao.findRecentlyDeletedAccounts(lastAccountId, startDate, filter);\n                    if ((accounts != null) && !accounts.isEmpty()) {\n                        \/\/ now update the accounts in the cloud_usage db\n                        _usageDao.updateAccounts(accounts);\n                    }\n                    offset = new Long(offset.longValue() + limit.longValue());\n                } while ((accounts != null) && !accounts.isEmpty());\n                \/\/ reset offset\n                offset = Long.valueOf(0);\n                do {\n                    Filter filter = new Filter(AccountVO.class, \"id\", true, offset, limit);\n                    accounts = _accountDao.findNewAccounts(lastAccountId, filter);\n                    if ((accounts != null) && !accounts.isEmpty()) {\n                        \/\/ now copy the accounts to cloud_usage db\n                        _usageDao.saveAccounts(accounts);\n                    }\n                    offset = new Long(offset.longValue() + limit.longValue());\n                } while ((accounts != null) && !accounts.isEmpty());\n                \/\/ reset offset\n                offset = Long.valueOf(0);\n                \/\/ get all the user stats to create usage records for the network usage\n                Long lastUserStatsId = _usageDao.getLastUserStatsId();\n                if (lastUserStatsId == null) {\n                    lastUserStatsId = Long.valueOf(0);\n                }\n                SearchCriteria<UserStatisticsVO> sc2 = _userStatsDao.createSearchCriteria();\n                sc2.addAnd(\"id\", SearchCriteria.Op.LTEQ, lastUserStatsId);\n                do {\n                    Filter filter = new Filter(UserStatisticsVO.class, \"id\", true, offset, limit);\n                    userStats = _userStatsDao.search(sc2, filter);\n                    if ((userStats != null) && !userStats.isEmpty()) {\n                        \/\/ now copy the accounts to cloud_usage db\n                        _usageDao.updateUserStats(userStats);\n                    }\n                    offset = new Long(offset.longValue() + limit.longValue());\n                } while ((userStats != null) && !userStats.isEmpty());\n                \/\/ reset offset\n                offset = Long.valueOf(0);\n                sc2 = _userStatsDao.createSearchCriteria();\n                sc2.addAnd(\"id\", SearchCriteria.Op.GT, lastUserStatsId);\n                do {\n                    Filter filter = new Filter(UserStatisticsVO.class, \"id\", true, offset, limit);\n                    userStats = _userStatsDao.search(sc2, filter);\n                    if ((userStats != null) && !userStats.isEmpty()) {\n                        \/\/ now copy the accounts to cloud_usage db\n                        _usageDao.saveUserStats(userStats);\n                    }\n                    offset = new Long(offset.longValue() + limit.longValue());\n                } while ((userStats != null) && !userStats.isEmpty());\n                \/\/ reset offset\n                offset = Long.valueOf(0);\n                \/\/ get all the vm network stats to create usage_VM_network records for the vm network usage\n                Long lastVmDiskStatsId = _usageDao.getLastVmDiskStatsId();\n                if (lastVmDiskStatsId == null) {\n                    lastVmDiskStatsId = Long.valueOf(0);\n                }\n                SearchCriteria<VmDiskStatisticsVO> sc4 = _vmDiskStatsDao.createSearchCriteria();\n                sc4.addAnd(\"id\", SearchCriteria.Op.LTEQ, lastVmDiskStatsId);\n                do {\n                    Filter filter = new Filter(VmDiskStatisticsVO.class, \"id\", true, offset, limit);\n                    vmDiskStats = _vmDiskStatsDao.search(sc4, filter);\n                    if ((vmDiskStats != null) && !vmDiskStats.isEmpty()) {\n                        \/\/ now copy the accounts to cloud_usage db\n                        _usageDao.updateVmDiskStats(vmDiskStats);\n                    }\n                    offset = new Long(offset.longValue() + limit.longValue());\n                } while ((vmDiskStats != null) && !vmDiskStats.isEmpty());\n                \/\/ reset offset\n                offset = Long.valueOf(0);\n                sc4 = _vmDiskStatsDao.createSearchCriteria();\n                sc4.addAnd(\"id\", SearchCriteria.Op.GT, lastVmDiskStatsId);\n                do {\n                    Filter filter = new Filter(VmDiskStatisticsVO.class, \"id\", true, offset, limit);\n                    vmDiskStats = _vmDiskStatsDao.search(sc4, filter);\n                    if ((vmDiskStats != null) && !vmDiskStats.isEmpty()) {\n                        \/\/ now copy the accounts to cloud_usage db\n                        _usageDao.saveVmDiskStats(vmDiskStats);\n                    }\n                    offset = new Long(offset.longValue() + limit.longValue());\n                } while ((vmDiskStats != null) && !vmDiskStats.isEmpty());\n            } finally {\n                userTxn.close();\n            }\n            \/\/ TODO:  Fetch a maximum number of events and process them before moving on to the next range of events\n            \/\/ - get a list of the latest events\n            \/\/ - insert the latest events into the usage.events table\n            List<UsageEventVO> events = _usageEventDao.getRecentEvents(new Date(endDateMillis));\n            TransactionLegacy usageTxn = TransactionLegacy.open(TransactionLegacy.USAGE_DB);\n            try {\n                usageTxn.start();\n                \/\/ make sure start date is before all of our un-processed events (the events are ordered oldest\n                \/\/ to newest, so just test against the first event)\n                if ((events != null) && (events.size() > 0)) {\n                    Date oldestEventDate = events.get(0).getCreateDate();\n                    if (oldestEventDate.getTime() < startDateMillis) {\n                        startDateMillis = oldestEventDate.getTime();\n                        startDate = new Date(startDateMillis);\n                    }\n                    \/\/ - loop over the list of events and create entries in the helper tables\n                    \/\/ - create the usage records using the parse methods below\n                    for (UsageEventVO event : events) {\n                        event.setProcessed(true);\n                        _usageEventDao.update(event.getId(), event);\n                        createHelperRecord(event);\n                    }\n                }\n                \/\/ TODO:  Fetch a maximum number of user stats and process them before moving on to the next range of user stats\n                \/\/ get user stats in order to compute network usage\n                networkStats = _usageNetworkDao.getRecentNetworkStats();\n                Calendar recentlyDeletedCal = Calendar.getInstance(_usageTimezone);\n                recentlyDeletedCal.setTimeInMillis(startDateMillis);\n                recentlyDeletedCal.add(Calendar.MINUTE, -1 * THREE_DAYS_IN_MINUTES);\n                Date recentlyDeletedDate = recentlyDeletedCal.getTime();\n                \/\/ Keep track of user stats for an account, across all of its public IPs\n                Map<String, UserStatisticsVO> aggregatedStats = new HashMap<String, UserStatisticsVO>();\n                int startIndex = 0;\n                do {\n                    userStats = _userStatsDao.listActiveAndRecentlyDeleted(recentlyDeletedDate, startIndex, 500);\n                    if (userStats != null) {\n                        for (UserStatisticsVO userStat : userStats) {\n                            if (userStat.getDeviceId() != null) {\n                                String hostKey = userStat.getDataCenterId() + \"-\" + userStat.getAccountId() + \"-Host-\" + userStat.getDeviceId();\n                                UserStatisticsVO hostAggregatedStat = aggregatedStats.get(hostKey);\n                                if (hostAggregatedStat == null) {\n                                    hostAggregatedStat =\n                                            new UserStatisticsVO(userStat.getAccountId(), userStat.getDataCenterId(), userStat.getPublicIpAddress(), userStat.getDeviceId(),\n                                                    userStat.getDeviceType(), userStat.getNetworkId());\n                                }\n                                hostAggregatedStat.setAggBytesSent(hostAggregatedStat.getAggBytesSent() + userStat.getAggBytesSent());\n                                hostAggregatedStat.setAggBytesReceived(hostAggregatedStat.getAggBytesReceived() + userStat.getAggBytesReceived());\n                                aggregatedStats.put(hostKey, hostAggregatedStat);\n                            }\n                        }\n                    }\n                    startIndex += 500;\n                } while ((userStats != null) && !userStats.isEmpty());\n                \/\/ loop over the user stats, create delta entries in the usage_network helper table\n                int numAcctsProcessed = 0;\n                usageNetworks.clear();\n                for (String key : aggregatedStats.keySet()) {\n                    UsageNetworkVO currentNetworkStats = null;\n                    if (networkStats != null) {\n                        currentNetworkStats = networkStats.get(key);\n                    }\n                    createNetworkHelperEntry(aggregatedStats.get(key), currentNetworkStats, endDateMillis);\n                    numAcctsProcessed++;\n                }\n                _usageNetworkDao.saveUsageNetworks(usageNetworks);\n                if (s_logger.isDebugEnabled()) {\n                    s_logger.debug(\"created network stats helper entries for \" + numAcctsProcessed + \" accts\");\n                }\n                \/\/ get vm disk stats in order to compute vm disk usage\n                vmDiskUsages = _usageVmDiskDao.getRecentVmDiskStats();\n                \/\/ Keep track of user stats for an account, across all of its public IPs\n                Map<String, VmDiskStatisticsVO> aggregatedDiskStats = new HashMap<String, VmDiskStatisticsVO>();\n                startIndex = 0;\n                do {\n                    vmDiskStats = _vmDiskStatsDao.listActiveAndRecentlyDeleted(recentlyDeletedDate, startIndex, 500);\n                    if (vmDiskUsages != null) {\n                        for (VmDiskStatisticsVO vmDiskStat : vmDiskStats) {\n                            if (vmDiskStat.getVmId() != null) {\n                                String hostKey =\n                                        vmDiskStat.getDataCenterId() + \"-\" + vmDiskStat.getAccountId() + \"-Vm-\" + vmDiskStat.getVmId() + \"-Disk-\" + vmDiskStat.getVolumeId();\n                                VmDiskStatisticsVO hostAggregatedStat = aggregatedDiskStats.get(hostKey);\n                                if (hostAggregatedStat == null) {\n                                    hostAggregatedStat =\n                                            new VmDiskStatisticsVO(vmDiskStat.getAccountId(), vmDiskStat.getDataCenterId(), vmDiskStat.getVmId(), vmDiskStat.getVolumeId());\n                                }\n                                hostAggregatedStat.setAggIORead(hostAggregatedStat.getAggIORead() + vmDiskStat.getAggIORead());\n                                hostAggregatedStat.setAggIOWrite(hostAggregatedStat.getAggIOWrite() + vmDiskStat.getAggIOWrite());\n                                hostAggregatedStat.setAggBytesRead(hostAggregatedStat.getAggBytesRead() + vmDiskStat.getAggBytesRead());\n                                hostAggregatedStat.setAggBytesWrite(hostAggregatedStat.getAggBytesWrite() + vmDiskStat.getAggBytesWrite());\n                                aggregatedDiskStats.put(hostKey, hostAggregatedStat);\n                            }\n                        }\n                    }\n                    startIndex += 500;\n                } while ((userStats != null) && !userStats.isEmpty());\n                \/\/ loop over the user stats, create delta entries in the usage_disk helper table\n                numAcctsProcessed = 0;\n                usageVmDisks.clear();\n                for (String key : aggregatedDiskStats.keySet()) {\n                    UsageVmDiskVO currentVmDiskStats = null;\n                    if (vmDiskStats != null) {\n                        currentVmDiskStats = vmDiskUsages.get(key);\n                    }\n                    createVmDiskHelperEntry(aggregatedDiskStats.get(key), currentVmDiskStats, endDateMillis);\n                    numAcctsProcessed++;\n                }\n                _usageVmDiskDao.saveUsageVmDisks(usageVmDisks);\n                if (s_logger.isDebugEnabled()) {\n                    s_logger.debug(\"created vm disk stats helper entries for \" + numAcctsProcessed + \" accts\");\n                }\n                \/\/ commit the helper records, then start a new transaction\n                usageTxn.commit();\n                usageTxn.start();\n                boolean parsed = false;\n                numAcctsProcessed = 0;\n                Date currentStartDate = startDate;\n                Date currentEndDate = endDate;\n                Date tempDate = endDate;\n                Calendar aggregateCal = Calendar.getInstance(_usageTimezone);\n                while ((tempDate.after(startDate)) && ((tempDate.getTime() - startDate.getTime()) > 60000)) {\n                    currentEndDate = tempDate;\n                    aggregateCal.setTime(tempDate);\n                    aggregateCal.add(Calendar.MINUTE, -_aggregationDuration);\n                    tempDate = aggregateCal.getTime();\n                }\n                while (!currentEndDate.after(endDate) || (currentEndDate.getTime() - endDate.getTime() < 60000)) {\n                    Long offset = Long.valueOf(0);\n                    Long limit = Long.valueOf(500);\n                    do {\n                        Filter filter = new Filter(AccountVO.class, \"id\", true, offset, limit);\n                        accounts = _accountDao.listAll(filter);\n                        if ((accounts != null) && !accounts.isEmpty()) {\n                            for (AccountVO account : accounts) {\n                                parsed = parseHelperTables(account, currentStartDate, currentEndDate);\n                                numAcctsProcessed++;\n                            }\n                        }\n                        offset = new Long(offset.longValue() + limit.longValue());\n                    } while ((accounts != null) && !accounts.isEmpty());\n                    if (s_logger.isDebugEnabled()) {\n                        s_logger.debug(\"processed VM\/Network Usage for \" + numAcctsProcessed + \" ACTIVE accts\");\n                    }\n                    numAcctsProcessed = 0;\n                    \/\/ reset offset\n                    offset = Long.valueOf(0);\n                    do {\n                        Filter filter = new Filter(AccountVO.class, \"id\", true, offset, limit);\n                        accounts = _accountDao.findRecentlyDeletedAccounts(null, recentlyDeletedDate, filter);\n                        if ((accounts != null) && !accounts.isEmpty()) {\n                            for (AccountVO account : accounts) {\n                                parsed = parseHelperTables(account, currentStartDate, currentEndDate);\n                                List<Long> publicTemplates = _usageDao.listPublicTemplatesByAccount(account.getId());\n                                for (Long templateId : publicTemplates) {\n                                    \/\/mark public templates owned by deleted accounts as deleted\n                                    List<UsageStorageVO> storageVOs = _usageStorageDao.listById(account.getId(), templateId, StorageTypes.TEMPLATE);\n                                    if (storageVOs.size() > 1) {\n                                        s_logger.warn(\"More that one usage entry for storage: \" + templateId + \" assigned to account: \" + account.getId() +\n                                                \"; marking them all as deleted...\");\n                                    }\n                                    for (UsageStorageVO storageVO : storageVOs) {\n                                        if (s_logger.isDebugEnabled()) {\n                                            s_logger.debug(\"deleting template: \" + storageVO.getId() + \" from account: \" + storageVO.getAccountId());\n                                        }\n                                        storageVO.setDeleted(account.getRemoved());\n                                        _usageStorageDao.update(storageVO);\n                                    }\n                                }\n                                numAcctsProcessed++;\n                            }\n                        }\n                        offset = new Long(offset.longValue() + limit.longValue());\n                    } while ((accounts != null) && !accounts.isEmpty());\n                    currentStartDate = new Date(currentEndDate.getTime() + 1);\n                    aggregateCal.setTime(currentEndDate);\n                    aggregateCal.add(Calendar.MINUTE, _aggregationDuration);\n                    currentEndDate = aggregateCal.getTime();\n                }\n                if (s_logger.isDebugEnabled()) {\n                    s_logger.debug(\"processed Usage for \" + numAcctsProcessed + \" RECENTLY DELETED accts\");\n                }\n                \/\/ FIXME: we don't break the above loop if something fails to parse, so it gets reset every account,\n                \/\/        do we want to break out of processing accounts and rollback if there are errors?\n                if (!parsed) {\n                    usageTxn.rollback();\n                } else {\n                    success = true;\n                }\n            } catch (Exception ex) {\n                s_logger.error(\"Exception in usage manager\", ex);\n                usageTxn.rollback();\n            } finally {\n                \/\/ everything seemed to work...set endDate as the last success date\n                _usageJobDao.updateJobSuccess(job.getId(), startDateMillis, endDateMillis, System.currentTimeMillis() - timeStart, success);\n                \/\/ create a new job if this is a recurring job\n                if (job.getJobType() == UsageJobVO.JOB_TYPE_RECURRING) {\n                    _usageJobDao.createNewJob(_hostname, _pid, UsageJobVO.JOB_TYPE_RECURRING);\n                }\n                usageTxn.commit();\n                usageTxn.close();\n                \/\/ switch back to CLOUD_DB\n                TransactionLegacy swap = TransactionLegacy.open(TransactionLegacy.CLOUD_DB);\n                if (!success) {\n                    _alertMgr.sendAlert(AlertManager.AlertType.ALERT_TYPE_USAGE_SERVER_RESULT, 0, new Long(0), \"Usage job failed. Job id: \" + job.getId(),\n                            \"Usage job failed. Job id: \" + job.getId());\n                } else {\n                    _alertMgr.clearAlert(AlertManager.AlertType.ALERT_TYPE_USAGE_SERVER_RESULT, 0, 0);\n                }\n                swap.close();\n            }\n        } catch (Exception e) {\n            s_logger.error(\"Usage Manager error\", e);\n        }\n    }","code_wo_comment":"@Override\n    public void parse(UsageJobVO job, long startDateMillis, long endDateMillis) {\n       \n        boolean success = false;\n        long timeStart = System.currentTimeMillis();\n        try {\n            if ((endDateMillis == 0) || (endDateMillis > timeStart)) {\n                endDateMillis = timeStart;\n            }\n            long lastSuccess = _usageJobDao.getLastJobSuccessDateMillis();\n            if (lastSuccess != 0) {\n                startDateMillis = lastSuccess + 1;\n            }\n            if (startDateMillis >= endDateMillis) {\n                if (s_logger.isInfoEnabled()) {\n                    s_logger.info(\"not parsing usage records since start time mills (\" + startDateMillis + \") is on or after end time millis (\" + endDateMillis + \")\");\n                }\n                TransactionLegacy jobUpdateTxn = TransactionLegacy.open(TransactionLegacy.USAGE_DB);\n                try {\n                    jobUpdateTxn.start();\n                   \n                    _usageJobDao.updateJobSuccess(job.getId(), startDateMillis, endDateMillis, System.currentTimeMillis() - timeStart, success);\n                   \n                    if (job.getJobType() == UsageJobVO.JOB_TYPE_RECURRING) {\n                        _usageJobDao.createNewJob(_hostname, _pid, UsageJobVO.JOB_TYPE_RECURRING);\n                    }\n                    jobUpdateTxn.commit();\n                } finally {\n                    jobUpdateTxn.close();\n                }\n                return;\n            }\n            Date startDate = new Date(startDateMillis);\n            Date endDate = new Date(endDateMillis);\n            if (s_logger.isInfoEnabled()) {\n                s_logger.info(\"Parsing usage records between \" + startDate + \" and \" + endDate);\n            }\n            List<AccountVO> accounts = null;\n            List<UserStatisticsVO> userStats = null;\n            Map<String, UsageNetworkVO> networkStats = null;\n            List<VmDiskStatisticsVO> vmDiskStats = null;\n            Map<String, UsageVmDiskVO> vmDiskUsages = null;\n            TransactionLegacy userTxn = TransactionLegacy.open(TransactionLegacy.CLOUD_DB);\n            try {\n                Long limit = Long.valueOf(500);\n                Long offset = Long.valueOf(0);\n                Long lastAccountId = _usageDao.getLastAccountId();\n                if (lastAccountId == null) {\n                    lastAccountId = Long.valueOf(0);\n                }\n                do {\n                    Filter filter = new Filter(AccountVO.class, \"id\", true, offset, limit);\n                    accounts = _accountDao.findActiveAccounts(lastAccountId, filter);\n                    if ((accounts != null) && !accounts.isEmpty()) {\n                       \n                        _usageDao.updateAccounts(accounts);\n                    }\n                    offset = new Long(offset.longValue() + limit.longValue());\n                } while ((accounts != null) && !accounts.isEmpty());\n               \n                offset = Long.valueOf(0);\n                do {\n                    Filter filter = new Filter(AccountVO.class, \"id\", true, offset, limit);\n                    accounts = _accountDao.findRecentlyDeletedAccounts(lastAccountId, startDate, filter);\n                    if ((accounts != null) && !accounts.isEmpty()) {\n                       \n                        _usageDao.updateAccounts(accounts);\n                    }\n                    offset = new Long(offset.longValue() + limit.longValue());\n                } while ((accounts != null) && !accounts.isEmpty());\n               \n                offset = Long.valueOf(0);\n                do {\n                    Filter filter = new Filter(AccountVO.class, \"id\", true, offset, limit);\n                    accounts = _accountDao.findNewAccounts(lastAccountId, filter);\n                    if ((accounts != null) && !accounts.isEmpty()) {\n                       \n                        _usageDao.saveAccounts(accounts);\n                    }\n                    offset = new Long(offset.longValue() + limit.longValue());\n                } while ((accounts != null) && !accounts.isEmpty());\n               \n                offset = Long.valueOf(0);\n               \n                Long lastUserStatsId = _usageDao.getLastUserStatsId();\n                if (lastUserStatsId == null) {\n                    lastUserStatsId = Long.valueOf(0);\n                }\n                SearchCriteria<UserStatisticsVO> sc2 = _userStatsDao.createSearchCriteria();\n                sc2.addAnd(\"id\", SearchCriteria.Op.LTEQ, lastUserStatsId);\n                do {\n                    Filter filter = new Filter(UserStatisticsVO.class, \"id\", true, offset, limit);\n                    userStats = _userStatsDao.search(sc2, filter);\n                    if ((userStats != null) && !userStats.isEmpty()) {\n                       \n                        _usageDao.updateUserStats(userStats);\n                    }\n                    offset = new Long(offset.longValue() + limit.longValue());\n                } while ((userStats != null) && !userStats.isEmpty());\n               \n                offset = Long.valueOf(0);\n                sc2 = _userStatsDao.createSearchCriteria();\n                sc2.addAnd(\"id\", SearchCriteria.Op.GT, lastUserStatsId);\n                do {\n                    Filter filter = new Filter(UserStatisticsVO.class, \"id\", true, offset, limit);\n                    userStats = _userStatsDao.search(sc2, filter);\n                    if ((userStats != null) && !userStats.isEmpty()) {\n                       \n                        _usageDao.saveUserStats(userStats);\n                    }\n                    offset = new Long(offset.longValue() + limit.longValue());\n                } while ((userStats != null) && !userStats.isEmpty());\n               \n                offset = Long.valueOf(0);\n               \n                Long lastVmDiskStatsId = _usageDao.getLastVmDiskStatsId();\n                if (lastVmDiskStatsId == null) {\n                    lastVmDiskStatsId = Long.valueOf(0);\n                }\n                SearchCriteria<VmDiskStatisticsVO> sc4 = _vmDiskStatsDao.createSearchCriteria();\n                sc4.addAnd(\"id\", SearchCriteria.Op.LTEQ, lastVmDiskStatsId);\n                do {\n                    Filter filter = new Filter(VmDiskStatisticsVO.class, \"id\", true, offset, limit);\n                    vmDiskStats = _vmDiskStatsDao.search(sc4, filter);\n                    if ((vmDiskStats != null) && !vmDiskStats.isEmpty()) {\n                       \n                        _usageDao.updateVmDiskStats(vmDiskStats);\n                    }\n                    offset = new Long(offset.longValue() + limit.longValue());\n                } while ((vmDiskStats != null) && !vmDiskStats.isEmpty());\n               \n                offset = Long.valueOf(0);\n                sc4 = _vmDiskStatsDao.createSearchCriteria();\n                sc4.addAnd(\"id\", SearchCriteria.Op.GT, lastVmDiskStatsId);\n                do {\n                    Filter filter = new Filter(VmDiskStatisticsVO.class, \"id\", true, offset, limit);\n                    vmDiskStats = _vmDiskStatsDao.search(sc4, filter);\n                    if ((vmDiskStats != null) && !vmDiskStats.isEmpty()) {\n                       \n                        _usageDao.saveVmDiskStats(vmDiskStats);\n                    }\n                    offset = new Long(offset.longValue() + limit.longValue());\n                } while ((vmDiskStats != null) && !vmDiskStats.isEmpty());\n            } finally {\n                userTxn.close();\n            }\n           \n           \n           \n            List<UsageEventVO> events = _usageEventDao.getRecentEvents(new Date(endDateMillis));\n            TransactionLegacy usageTxn = TransactionLegacy.open(TransactionLegacy.USAGE_DB);\n            try {\n                usageTxn.start();\n               \n               \n                if ((events != null) && (events.size() > 0)) {\n                    Date oldestEventDate = events.get(0).getCreateDate();\n                    if (oldestEventDate.getTime() < startDateMillis) {\n                        startDateMillis = oldestEventDate.getTime();\n                        startDate = new Date(startDateMillis);\n                    }\n                   \n                   \n                    for (UsageEventVO event : events) {\n                        event.setProcessed(true);\n                        _usageEventDao.update(event.getId(), event);\n                        createHelperRecord(event);\n                    }\n                }\n               \n               \n                networkStats = _usageNetworkDao.getRecentNetworkStats();\n                Calendar recentlyDeletedCal = Calendar.getInstance(_usageTimezone);\n                recentlyDeletedCal.setTimeInMillis(startDateMillis);\n                recentlyDeletedCal.add(Calendar.MINUTE, -1 * THREE_DAYS_IN_MINUTES);\n                Date recentlyDeletedDate = recentlyDeletedCal.getTime();\n               \n                Map<String, UserStatisticsVO> aggregatedStats = new HashMap<String, UserStatisticsVO>();\n                int startIndex = 0;\n                do {\n                    userStats = _userStatsDao.listActiveAndRecentlyDeleted(recentlyDeletedDate, startIndex, 500);\n                    if (userStats != null) {\n                        for (UserStatisticsVO userStat : userStats) {\n                            if (userStat.getDeviceId() != null) {\n                                String hostKey = userStat.getDataCenterId() + \"-\" + userStat.getAccountId() + \"-Host-\" + userStat.getDeviceId();\n                                UserStatisticsVO hostAggregatedStat = aggregatedStats.get(hostKey);\n                                if (hostAggregatedStat == null) {\n                                    hostAggregatedStat =\n                                            new UserStatisticsVO(userStat.getAccountId(), userStat.getDataCenterId(), userStat.getPublicIpAddress(), userStat.getDeviceId(),\n                                                    userStat.getDeviceType(), userStat.getNetworkId());\n                                }\n                                hostAggregatedStat.setAggBytesSent(hostAggregatedStat.getAggBytesSent() + userStat.getAggBytesSent());\n                                hostAggregatedStat.setAggBytesReceived(hostAggregatedStat.getAggBytesReceived() + userStat.getAggBytesReceived());\n                                aggregatedStats.put(hostKey, hostAggregatedStat);\n                            }\n                        }\n                    }\n                    startIndex += 500;\n                } while ((userStats != null) && !userStats.isEmpty());\n               \n                int numAcctsProcessed = 0;\n                usageNetworks.clear();\n                for (String key : aggregatedStats.keySet()) {\n                    UsageNetworkVO currentNetworkStats = null;\n                    if (networkStats != null) {\n                        currentNetworkStats = networkStats.get(key);\n                    }\n                    createNetworkHelperEntry(aggregatedStats.get(key), currentNetworkStats, endDateMillis);\n                    numAcctsProcessed++;\n                }\n                _usageNetworkDao.saveUsageNetworks(usageNetworks);\n                if (s_logger.isDebugEnabled()) {\n                    s_logger.debug(\"created network stats helper entries for \" + numAcctsProcessed + \" accts\");\n                }\n               \n                vmDiskUsages = _usageVmDiskDao.getRecentVmDiskStats();\n               \n                Map<String, VmDiskStatisticsVO> aggregatedDiskStats = new HashMap<String, VmDiskStatisticsVO>();\n                startIndex = 0;\n                do {\n                    vmDiskStats = _vmDiskStatsDao.listActiveAndRecentlyDeleted(recentlyDeletedDate, startIndex, 500);\n                    if (vmDiskUsages != null) {\n                        for (VmDiskStatisticsVO vmDiskStat : vmDiskStats) {\n                            if (vmDiskStat.getVmId() != null) {\n                                String hostKey =\n                                        vmDiskStat.getDataCenterId() + \"-\" + vmDiskStat.getAccountId() + \"-Vm-\" + vmDiskStat.getVmId() + \"-Disk-\" + vmDiskStat.getVolumeId();\n                                VmDiskStatisticsVO hostAggregatedStat = aggregatedDiskStats.get(hostKey);\n                                if (hostAggregatedStat == null) {\n                                    hostAggregatedStat =\n                                            new VmDiskStatisticsVO(vmDiskStat.getAccountId(), vmDiskStat.getDataCenterId(), vmDiskStat.getVmId(), vmDiskStat.getVolumeId());\n                                }\n                                hostAggregatedStat.setAggIORead(hostAggregatedStat.getAggIORead() + vmDiskStat.getAggIORead());\n                                hostAggregatedStat.setAggIOWrite(hostAggregatedStat.getAggIOWrite() + vmDiskStat.getAggIOWrite());\n                                hostAggregatedStat.setAggBytesRead(hostAggregatedStat.getAggBytesRead() + vmDiskStat.getAggBytesRead());\n                                hostAggregatedStat.setAggBytesWrite(hostAggregatedStat.getAggBytesWrite() + vmDiskStat.getAggBytesWrite());\n                                aggregatedDiskStats.put(hostKey, hostAggregatedStat);\n                            }\n                        }\n                    }\n                    startIndex += 500;\n                } while ((userStats != null) && !userStats.isEmpty());\n               \n                numAcctsProcessed = 0;\n                usageVmDisks.clear();\n                for (String key : aggregatedDiskStats.keySet()) {\n                    UsageVmDiskVO currentVmDiskStats = null;\n                    if (vmDiskStats != null) {\n                        currentVmDiskStats = vmDiskUsages.get(key);\n                    }\n                    createVmDiskHelperEntry(aggregatedDiskStats.get(key), currentVmDiskStats, endDateMillis);\n                    numAcctsProcessed++;\n                }\n                _usageVmDiskDao.saveUsageVmDisks(usageVmDisks);\n                if (s_logger.isDebugEnabled()) {\n                    s_logger.debug(\"created vm disk stats helper entries for \" + numAcctsProcessed + \" accts\");\n                }\n               \n                usageTxn.commit();\n                usageTxn.start();\n                boolean parsed = false;\n                numAcctsProcessed = 0;\n                Date currentStartDate = startDate;\n                Date currentEndDate = endDate;\n                Date tempDate = endDate;\n                Calendar aggregateCal = Calendar.getInstance(_usageTimezone);\n                while ((tempDate.after(startDate)) && ((tempDate.getTime() - startDate.getTime()) > 60000)) {\n                    currentEndDate = tempDate;\n                    aggregateCal.setTime(tempDate);\n                    aggregateCal.add(Calendar.MINUTE, -_aggregationDuration);\n                    tempDate = aggregateCal.getTime();\n                }\n                while (!currentEndDate.after(endDate) || (currentEndDate.getTime() - endDate.getTime() < 60000)) {\n                    Long offset = Long.valueOf(0);\n                    Long limit = Long.valueOf(500);\n                    do {\n                        Filter filter = new Filter(AccountVO.class, \"id\", true, offset, limit);\n                        accounts = _accountDao.listAll(filter);\n                        if ((accounts != null) && !accounts.isEmpty()) {\n                            for (AccountVO account : accounts) {\n                                parsed = parseHelperTables(account, currentStartDate, currentEndDate);\n                                numAcctsProcessed++;\n                            }\n                        }\n                        offset = new Long(offset.longValue() + limit.longValue());\n                    } while ((accounts != null) && !accounts.isEmpty());\n                    if (s_logger.isDebugEnabled()) {\n                        s_logger.debug(\"processed VM\/Network Usage for \" + numAcctsProcessed + \" ACTIVE accts\");\n                    }\n                    numAcctsProcessed = 0;\n                   \n                    offset = Long.valueOf(0);\n                    do {\n                        Filter filter = new Filter(AccountVO.class, \"id\", true, offset, limit);\n                        accounts = _accountDao.findRecentlyDeletedAccounts(null, recentlyDeletedDate, filter);\n                        if ((accounts != null) && !accounts.isEmpty()) {\n                            for (AccountVO account : accounts) {\n                                parsed = parseHelperTables(account, currentStartDate, currentEndDate);\n                                List<Long> publicTemplates = _usageDao.listPublicTemplatesByAccount(account.getId());\n                                for (Long templateId : publicTemplates) {\n                                   \n                                    List<UsageStorageVO> storageVOs = _usageStorageDao.listById(account.getId(), templateId, StorageTypes.TEMPLATE);\n                                    if (storageVOs.size() > 1) {\n                                        s_logger.warn(\"More that one usage entry for storage: \" + templateId + \" assigned to account: \" + account.getId() +\n                                                \"; marking them all as deleted...\");\n                                    }\n                                    for (UsageStorageVO storageVO : storageVOs) {\n                                        if (s_logger.isDebugEnabled()) {\n                                            s_logger.debug(\"deleting template: \" + storageVO.getId() + \" from account: \" + storageVO.getAccountId());\n                                        }\n                                        storageVO.setDeleted(account.getRemoved());\n                                        _usageStorageDao.update(storageVO);\n                                    }\n                                }\n                                numAcctsProcessed++;\n                            }\n                        }\n                        offset = new Long(offset.longValue() + limit.longValue());\n                    } while ((accounts != null) && !accounts.isEmpty());\n                    currentStartDate = new Date(currentEndDate.getTime() + 1);\n                    aggregateCal.setTime(currentEndDate);\n                    aggregateCal.add(Calendar.MINUTE, _aggregationDuration);\n                    currentEndDate = aggregateCal.getTime();\n                }\n                if (s_logger.isDebugEnabled()) {\n                    s_logger.debug(\"processed Usage for \" + numAcctsProcessed + \" RECENTLY DELETED accts\");\n                }\n               \n               \n                if (!parsed) {\n                    usageTxn.rollback();\n                } else {\n                    success = true;\n                }\n            } catch (Exception ex) {\n                s_logger.error(\"Exception in usage manager\", ex);\n                usageTxn.rollback();\n            } finally {\n               \n                _usageJobDao.updateJobSuccess(job.getId(), startDateMillis, endDateMillis, System.currentTimeMillis() - timeStart, success);\n               \n                if (job.getJobType() == UsageJobVO.JOB_TYPE_RECURRING) {\n                    _usageJobDao.createNewJob(_hostname, _pid, UsageJobVO.JOB_TYPE_RECURRING);\n                }\n                usageTxn.commit();\n                usageTxn.close();\n               \n                TransactionLegacy swap = TransactionLegacy.open(TransactionLegacy.CLOUD_DB);\n                if (!success) {\n                    _alertMgr.sendAlert(AlertManager.AlertType.ALERT_TYPE_USAGE_SERVER_RESULT, 0, new Long(0), \"Usage job failed. Job id: \" + job.getId(),\n                            \"Usage job failed. Job id: \" + job.getId());\n                } else {\n                    _alertMgr.clearAlert(AlertManager.AlertType.ALERT_TYPE_USAGE_SERVER_RESULT, 0, 0);\n                }\n                swap.close();\n            }\n        } catch (Exception e) {\n            s_logger.error(\"Usage Manager error\", e);\n        }\n    }","cleancode":"@override public void parse(usagejobvo job, long startdatemillis, long enddatemillis) { boolean success = false; long timestart = system.currenttimemillis(); try { if ((enddatemillis == 0) || (enddatemillis > timestart)) { enddatemillis = timestart; } long lastsuccess = _usagejobdao.getlastjobsuccessdatemillis(); if (lastsuccess != 0) { startdatemillis = lastsuccess + 1; } if (startdatemillis >= enddatemillis) { if (s_logger.isinfoenabled()) { s_logger.info(\"not parsing usage records since start time mills (\" + startdatemillis + \") is on or after end time millis (\" + enddatemillis + \")\"); } transactionlegacy jobupdatetxn = transactionlegacy.open(transactionlegacy.usage_db); try { jobupdatetxn.start(); _usagejobdao.updatejobsuccess(job.getid(), startdatemillis, enddatemillis, system.currenttimemillis() - timestart, success); if (job.getjobtype() == usagejobvo.job_type_recurring) { _usagejobdao.createnewjob(_hostname, _pid, usagejobvo.job_type_recurring); } jobupdatetxn.commit(); } finally { jobupdatetxn.close(); } return; } date startdate = new date(startdatemillis); date enddate = new date(enddatemillis); if (s_logger.isinfoenabled()) { s_logger.info(\"parsing usage records between \" + startdate + \" and \" + enddate); } list<accountvo> accounts = null; list<userstatisticsvo> userstats = null; map<string, usagenetworkvo> networkstats = null; list<vmdiskstatisticsvo> vmdiskstats = null; map<string, usagevmdiskvo> vmdiskusages = null; transactionlegacy usertxn = transactionlegacy.open(transactionlegacy.cloud_db); try { long limit = long.valueof(500); long offset = long.valueof(0); long lastaccountid = _usagedao.getlastaccountid(); if (lastaccountid == null) { lastaccountid = long.valueof(0); } do { filter filter = new filter(accountvo.class, \"id\", true, offset, limit); accounts = _accountdao.findactiveaccounts(lastaccountid, filter); if ((accounts != null) && !accounts.isempty()) { _usagedao.updateaccounts(accounts); } offset = new long(offset.longvalue() + limit.longvalue()); } while ((accounts != null) && !accounts.isempty()); offset = long.valueof(0); do { filter filter = new filter(accountvo.class, \"id\", true, offset, limit); accounts = _accountdao.findrecentlydeletedaccounts(lastaccountid, startdate, filter); if ((accounts != null) && !accounts.isempty()) { _usagedao.updateaccounts(accounts); } offset = new long(offset.longvalue() + limit.longvalue()); } while ((accounts != null) && !accounts.isempty()); offset = long.valueof(0); do { filter filter = new filter(accountvo.class, \"id\", true, offset, limit); accounts = _accountdao.findnewaccounts(lastaccountid, filter); if ((accounts != null) && !accounts.isempty()) { _usagedao.saveaccounts(accounts); } offset = new long(offset.longvalue() + limit.longvalue()); } while ((accounts != null) && !accounts.isempty()); offset = long.valueof(0); long lastuserstatsid = _usagedao.getlastuserstatsid(); if (lastuserstatsid == null) { lastuserstatsid = long.valueof(0); } searchcriteria<userstatisticsvo> sc2 = _userstatsdao.createsearchcriteria(); sc2.addand(\"id\", searchcriteria.op.lteq, lastuserstatsid); do { filter filter = new filter(userstatisticsvo.class, \"id\", true, offset, limit); userstats = _userstatsdao.search(sc2, filter); if ((userstats != null) && !userstats.isempty()) { _usagedao.updateuserstats(userstats); } offset = new long(offset.longvalue() + limit.longvalue()); } while ((userstats != null) && !userstats.isempty()); offset = long.valueof(0); sc2 = _userstatsdao.createsearchcriteria(); sc2.addand(\"id\", searchcriteria.op.gt, lastuserstatsid); do { filter filter = new filter(userstatisticsvo.class, \"id\", true, offset, limit); userstats = _userstatsdao.search(sc2, filter); if ((userstats != null) && !userstats.isempty()) { _usagedao.saveuserstats(userstats); } offset = new long(offset.longvalue() + limit.longvalue()); } while ((userstats != null) && !userstats.isempty()); offset = long.valueof(0); long lastvmdiskstatsid = _usagedao.getlastvmdiskstatsid(); if (lastvmdiskstatsid == null) { lastvmdiskstatsid = long.valueof(0); } searchcriteria<vmdiskstatisticsvo> sc4 = _vmdiskstatsdao.createsearchcriteria(); sc4.addand(\"id\", searchcriteria.op.lteq, lastvmdiskstatsid); do { filter filter = new filter(vmdiskstatisticsvo.class, \"id\", true, offset, limit); vmdiskstats = _vmdiskstatsdao.search(sc4, filter); if ((vmdiskstats != null) && !vmdiskstats.isempty()) { _usagedao.updatevmdiskstats(vmdiskstats); } offset = new long(offset.longvalue() + limit.longvalue()); } while ((vmdiskstats != null) && !vmdiskstats.isempty()); offset = long.valueof(0); sc4 = _vmdiskstatsdao.createsearchcriteria(); sc4.addand(\"id\", searchcriteria.op.gt, lastvmdiskstatsid); do { filter filter = new filter(vmdiskstatisticsvo.class, \"id\", true, offset, limit); vmdiskstats = _vmdiskstatsdao.search(sc4, filter); if ((vmdiskstats != null) && !vmdiskstats.isempty()) { _usagedao.savevmdiskstats(vmdiskstats); } offset = new long(offset.longvalue() + limit.longvalue()); } while ((vmdiskstats != null) && !vmdiskstats.isempty()); } finally { usertxn.close(); } list<usageeventvo> events = _usageeventdao.getrecentevents(new date(enddatemillis)); transactionlegacy usagetxn = transactionlegacy.open(transactionlegacy.usage_db); try { usagetxn.start(); if ((events != null) && (events.size() > 0)) { date oldesteventdate = events.get(0).getcreatedate(); if (oldesteventdate.gettime() < startdatemillis) { startdatemillis = oldesteventdate.gettime(); startdate = new date(startdatemillis); } for (usageeventvo event : events) { event.setprocessed(true); _usageeventdao.update(event.getid(), event); createhelperrecord(event); } } networkstats = _usagenetworkdao.getrecentnetworkstats(); calendar recentlydeletedcal = calendar.getinstance(_usagetimezone); recentlydeletedcal.settimeinmillis(startdatemillis); recentlydeletedcal.add(calendar.minute, -1 * three_days_in_minutes); date recentlydeleteddate = recentlydeletedcal.gettime(); map<string, userstatisticsvo> aggregatedstats = new hashmap<string, userstatisticsvo>(); int startindex = 0; do { userstats = _userstatsdao.listactiveandrecentlydeleted(recentlydeleteddate, startindex, 500); if (userstats != null) { for (userstatisticsvo userstat : userstats) { if (userstat.getdeviceid() != null) { string hostkey = userstat.getdatacenterid() + \"-\" + userstat.getaccountid() + \"-host-\" + userstat.getdeviceid(); userstatisticsvo hostaggregatedstat = aggregatedstats.get(hostkey); if (hostaggregatedstat == null) { hostaggregatedstat = new userstatisticsvo(userstat.getaccountid(), userstat.getdatacenterid(), userstat.getpublicipaddress(), userstat.getdeviceid(), userstat.getdevicetype(), userstat.getnetworkid()); } hostaggregatedstat.setaggbytessent(hostaggregatedstat.getaggbytessent() + userstat.getaggbytessent()); hostaggregatedstat.setaggbytesreceived(hostaggregatedstat.getaggbytesreceived() + userstat.getaggbytesreceived()); aggregatedstats.put(hostkey, hostaggregatedstat); } } } startindex += 500; } while ((userstats != null) && !userstats.isempty()); int numacctsprocessed = 0; usagenetworks.clear(); for (string key : aggregatedstats.keyset()) { usagenetworkvo currentnetworkstats = null; if (networkstats != null) { currentnetworkstats = networkstats.get(key); } createnetworkhelperentry(aggregatedstats.get(key), currentnetworkstats, enddatemillis); numacctsprocessed++; } _usagenetworkdao.saveusagenetworks(usagenetworks); if (s_logger.isdebugenabled()) { s_logger.debug(\"created network stats helper entries for \" + numacctsprocessed + \" accts\"); } vmdiskusages = _usagevmdiskdao.getrecentvmdiskstats(); map<string, vmdiskstatisticsvo> aggregateddiskstats = new hashmap<string, vmdiskstatisticsvo>(); startindex = 0; do { vmdiskstats = _vmdiskstatsdao.listactiveandrecentlydeleted(recentlydeleteddate, startindex, 500); if (vmdiskusages != null) { for (vmdiskstatisticsvo vmdiskstat : vmdiskstats) { if (vmdiskstat.getvmid() != null) { string hostkey = vmdiskstat.getdatacenterid() + \"-\" + vmdiskstat.getaccountid() + \"-vm-\" + vmdiskstat.getvmid() + \"-disk-\" + vmdiskstat.getvolumeid(); vmdiskstatisticsvo hostaggregatedstat = aggregateddiskstats.get(hostkey); if (hostaggregatedstat == null) { hostaggregatedstat = new vmdiskstatisticsvo(vmdiskstat.getaccountid(), vmdiskstat.getdatacenterid(), vmdiskstat.getvmid(), vmdiskstat.getvolumeid()); } hostaggregatedstat.setaggioread(hostaggregatedstat.getaggioread() + vmdiskstat.getaggioread()); hostaggregatedstat.setaggiowrite(hostaggregatedstat.getaggiowrite() + vmdiskstat.getaggiowrite()); hostaggregatedstat.setaggbytesread(hostaggregatedstat.getaggbytesread() + vmdiskstat.getaggbytesread()); hostaggregatedstat.setaggbyteswrite(hostaggregatedstat.getaggbyteswrite() + vmdiskstat.getaggbyteswrite()); aggregateddiskstats.put(hostkey, hostaggregatedstat); } } } startindex += 500; } while ((userstats != null) && !userstats.isempty()); numacctsprocessed = 0; usagevmdisks.clear(); for (string key : aggregateddiskstats.keyset()) { usagevmdiskvo currentvmdiskstats = null; if (vmdiskstats != null) { currentvmdiskstats = vmdiskusages.get(key); } createvmdiskhelperentry(aggregateddiskstats.get(key), currentvmdiskstats, enddatemillis); numacctsprocessed++; } _usagevmdiskdao.saveusagevmdisks(usagevmdisks); if (s_logger.isdebugenabled()) { s_logger.debug(\"created vm disk stats helper entries for \" + numacctsprocessed + \" accts\"); } usagetxn.commit(); usagetxn.start(); boolean parsed = false; numacctsprocessed = 0; date currentstartdate = startdate; date currentenddate = enddate; date tempdate = enddate; calendar aggregatecal = calendar.getinstance(_usagetimezone); while ((tempdate.after(startdate)) && ((tempdate.gettime() - startdate.gettime()) > 60000)) { currentenddate = tempdate; aggregatecal.settime(tempdate); aggregatecal.add(calendar.minute, -_aggregationduration); tempdate = aggregatecal.gettime(); } while (!currentenddate.after(enddate) || (currentenddate.gettime() - enddate.gettime() < 60000)) { long offset = long.valueof(0); long limit = long.valueof(500); do { filter filter = new filter(accountvo.class, \"id\", true, offset, limit); accounts = _accountdao.listall(filter); if ((accounts != null) && !accounts.isempty()) { for (accountvo account : accounts) { parsed = parsehelpertables(account, currentstartdate, currentenddate); numacctsprocessed++; } } offset = new long(offset.longvalue() + limit.longvalue()); } while ((accounts != null) && !accounts.isempty()); if (s_logger.isdebugenabled()) { s_logger.debug(\"processed vm\/network usage for \" + numacctsprocessed + \" active accts\"); } numacctsprocessed = 0; offset = long.valueof(0); do { filter filter = new filter(accountvo.class, \"id\", true, offset, limit); accounts = _accountdao.findrecentlydeletedaccounts(null, recentlydeleteddate, filter); if ((accounts != null) && !accounts.isempty()) { for (accountvo account : accounts) { parsed = parsehelpertables(account, currentstartdate, currentenddate); list<long> publictemplates = _usagedao.listpublictemplatesbyaccount(account.getid()); for (long templateid : publictemplates) { list<usagestoragevo> storagevos = _usagestoragedao.listbyid(account.getid(), templateid, storagetypes.template); if (storagevos.size() > 1) { s_logger.warn(\"more that one usage entry for storage: \" + templateid + \" assigned to account: \" + account.getid() + \"; marking them all as deleted...\"); } for (usagestoragevo storagevo : storagevos) { if (s_logger.isdebugenabled()) { s_logger.debug(\"deleting template: \" + storagevo.getid() + \" from account: \" + storagevo.getaccountid()); } storagevo.setdeleted(account.getremoved()); _usagestoragedao.update(storagevo); } } numacctsprocessed++; } } offset = new long(offset.longvalue() + limit.longvalue()); } while ((accounts != null) && !accounts.isempty()); currentstartdate = new date(currentenddate.gettime() + 1); aggregatecal.settime(currentenddate); aggregatecal.add(calendar.minute, _aggregationduration); currentenddate = aggregatecal.gettime(); } if (s_logger.isdebugenabled()) { s_logger.debug(\"processed usage for \" + numacctsprocessed + \" recently deleted accts\"); } if (!parsed) { usagetxn.rollback(); } else { success = true; } } catch (exception ex) { s_logger.error(\"exception in usage manager\", ex); usagetxn.rollback(); } finally { _usagejobdao.updatejobsuccess(job.getid(), startdatemillis, enddatemillis, system.currenttimemillis() - timestart, success); if (job.getjobtype() == usagejobvo.job_type_recurring) { _usagejobdao.createnewjob(_hostname, _pid, usagejobvo.job_type_recurring); } usagetxn.commit(); usagetxn.close(); transactionlegacy swap = transactionlegacy.open(transactionlegacy.cloud_db); if (!success) { _alertmgr.sendalert(alertmanager.alerttype.alert_type_usage_server_result, 0, new long(0), \"usage job failed. job id: \" + job.getid(), \"usage job failed. job id: \" + job.getid()); } else { _alertmgr.clearalert(alertmanager.alerttype.alert_type_usage_server_result, 0, 0); } swap.close(); } } catch (exception e) { s_logger.error(\"usage manager error\", e); } }","repo":"serbaut\/cloudstack","label":[1,1,0,0]}
{"id":33175,"original_code":"@SuppressWarnings(\"unchecked\")\n\tpublic static <T> T[] toArray(List<T> list){\n\t\treturn (T[]) list.toArray();\n\t}","code_wo_comment":"@SuppressWarnings(\"unchecked\")\n\tpublic static <T> T[] toArray(List<T> list){\n\t\treturn (T[]) list.toArray();\n\t}","cleancode":"@suppresswarnings(\"unchecked\") public static <t> t[] toarray(list<t> list){ return (t[]) list.toarray(); }","repo":"sisbell\/appia","label":[1,0,0,0]}
{"id":408,"original_code":"@SuppressWarnings(\"nls\")\n  @Override\n  protected FilterResult doFilterInternal(HttpServletRequest request, HttpServletResponse response)\n      throws ServletException, IOException {\n    response = new IgnoreContentWrapper(response);\n    response.addHeader(\"P3P\", \"CP=\\\"CAO PSA OUR\\\"\");\n    response.setHeader(\"X-Content-Type-Options\", \"nosniff\");\n    \/\/ Chrome sucks.\n    \/\/ http:\/\/dev.equella.com\/issues\/8025\n    \/\/ http:\/\/dev.equella.com\/issues\/5612\n    String ua = request.getHeader(\"User-Agent\");\n    if (ua != null && ua.contains(\"Chrome\")) {\n      response.addHeader(\"X-XSS-Protection\", \"0\");\n    } else {\n      response.setHeader(\"X-XSS-Protection\", \"1; mode=block\");\n    }\n    if (stsMaxAge != -1) {\n      response.setHeader(\n          \"Strict-Transport-Security\", \"max-age=\" + stsMaxAge + \"; includeSubDomains\");\n    }\n    return new FilterResult(response);\n  }","code_wo_comment":"@SuppressWarnings(\"nls\")\n  @Override\n  protected FilterResult doFilterInternal(HttpServletRequest request, HttpServletResponse response)\n      throws ServletException, IOException {\n    response = new IgnoreContentWrapper(response);\n    response.addHeader(\"P3P\", \"CP=\\\"CAO PSA OUR\\\"\");\n    response.setHeader(\"X-Content-Type-Options\", \"nosniff\");\n   \n   \n   \n    String ua = request.getHeader(\"User-Agent\");\n    if (ua != null && ua.contains(\"Chrome\")) {\n      response.addHeader(\"X-XSS-Protection\", \"0\");\n    } else {\n      response.setHeader(\"X-XSS-Protection\", \"1; mode=block\");\n    }\n    if (stsMaxAge != -1) {\n      response.setHeader(\n          \"Strict-Transport-Security\", \"max-age=\" + stsMaxAge + \"; includeSubDomains\");\n    }\n    return new FilterResult(response);\n  }","cleancode":"@suppresswarnings(\"nls\") @override protected filterresult dofilterinternal(httpservletrequest request, httpservletresponse response) throws servletexception, ioexception { response = new ignorecontentwrapper(response); response.addheader(\"p3p\", \"cp=\\\"cao psa our\\\"\"); response.setheader(\"x-content-type-options\", \"nosniff\"); string ua = request.getheader(\"user-agent\"); if (ua != null && ua.contains(\"chrome\")) { response.addheader(\"x-xss-protection\", \"0\"); } else { response.setheader(\"x-xss-protection\", \"1; mode=block\"); } if (stsmaxage != -1) { response.setheader( \"strict-transport-security\", \"max-age=\" + stsmaxage + \"; includesubdomains\"); } return new filterresult(response); }","repo":"rmathis\/openEQUELLA","label":[0,0,1,0]}
{"id":16797,"original_code":"public static Listener createListener(boolean ads,\n      io.envoyproxy.envoy.api.v2.core.ApiVersion rdsTransportVersion,\n      io.envoyproxy.envoy.api.v2.core.ApiVersion rdsResourceVersion, String listenerName,\n      int port, String routeName) {\n    ConfigSource.Builder configSourceBuilder = ConfigSource.newBuilder()\n        .setResourceApiVersion(rdsResourceVersion);\n    ConfigSource rdsSource = ads\n        ? configSourceBuilder\n        .setAds(AggregatedConfigSource.getDefaultInstance())\n        .build()\n        : configSourceBuilder\n            .setApiConfigSource(ApiConfigSource.newBuilder()\n                .setApiType(ApiType.GRPC)\n                .setTransportApiVersion(rdsTransportVersion)\n                .addGrpcServices(GrpcService.newBuilder()\n                    .setEnvoyGrpc(EnvoyGrpc.newBuilder()\n                        .setClusterName(XDS_CLUSTER))))\n            .build();\n    HttpConnectionManager manager = HttpConnectionManager.newBuilder()\n        .setCodecType(CodecType.AUTO)\n        .setStatPrefix(\"http\")\n        .setRds(Rds.newBuilder()\n            .setConfigSource(rdsSource)\n            .setRouteConfigName(routeName))\n        .addHttpFilters(HttpFilter.newBuilder()\n            .setName(Resources.FILTER_ENVOY_ROUTER))\n        .build();\n    return Listener.newBuilder()\n        .setName(listenerName)\n        .setAddress(Address.newBuilder()\n            .setSocketAddress(SocketAddress.newBuilder()\n                .setAddress(ANY_ADDRESS)\n                .setPortValue(port)\n                .setProtocol(Protocol.TCP)))\n        .addFilterChains(FilterChain.newBuilder()\n            .addFilters(Filter.newBuilder()\n                .setName(Resources.FILTER_HTTP_CONNECTION_MANAGER)\n                .setTypedConfig(Any.pack(manager))))\n        .build();\n  }","code_wo_comment":"public static Listener createListener(boolean ads,\n      io.envoyproxy.envoy.api.v2.core.ApiVersion rdsTransportVersion,\n      io.envoyproxy.envoy.api.v2.core.ApiVersion rdsResourceVersion, String listenerName,\n      int port, String routeName) {\n    ConfigSource.Builder configSourceBuilder = ConfigSource.newBuilder()\n        .setResourceApiVersion(rdsResourceVersion);\n    ConfigSource rdsSource = ads\n        ? configSourceBuilder\n        .setAds(AggregatedConfigSource.getDefaultInstance())\n        .build()\n        : configSourceBuilder\n            .setApiConfigSource(ApiConfigSource.newBuilder()\n                .setApiType(ApiType.GRPC)\n                .setTransportApiVersion(rdsTransportVersion)\n                .addGrpcServices(GrpcService.newBuilder()\n                    .setEnvoyGrpc(EnvoyGrpc.newBuilder()\n                        .setClusterName(XDS_CLUSTER))))\n            .build();\n    HttpConnectionManager manager = HttpConnectionManager.newBuilder()\n        .setCodecType(CodecType.AUTO)\n        .setStatPrefix(\"http\")\n        .setRds(Rds.newBuilder()\n            .setConfigSource(rdsSource)\n            .setRouteConfigName(routeName))\n        .addHttpFilters(HttpFilter.newBuilder()\n            .setName(Resources.FILTER_ENVOY_ROUTER))\n        .build();\n    return Listener.newBuilder()\n        .setName(listenerName)\n        .setAddress(Address.newBuilder()\n            .setSocketAddress(SocketAddress.newBuilder()\n                .setAddress(ANY_ADDRESS)\n                .setPortValue(port)\n                .setProtocol(Protocol.TCP)))\n        .addFilterChains(FilterChain.newBuilder()\n            .addFilters(Filter.newBuilder()\n                .setName(Resources.FILTER_HTTP_CONNECTION_MANAGER)\n                .setTypedConfig(Any.pack(manager))))\n        .build();\n  }","cleancode":"public static listener createlistener(boolean ads, io.envoyproxy.envoy.api.v2.core.apiversion rdstransportversion, io.envoyproxy.envoy.api.v2.core.apiversion rdsresourceversion, string listenername, int port, string routename) { configsource.builder configsourcebuilder = configsource.newbuilder() .setresourceapiversion(rdsresourceversion); configsource rdssource = ads ? configsourcebuilder .setads(aggregatedconfigsource.getdefaultinstance()) .build() : configsourcebuilder .setapiconfigsource(apiconfigsource.newbuilder() .setapitype(apitype.grpc) .settransportapiversion(rdstransportversion) .addgrpcservices(grpcservice.newbuilder() .setenvoygrpc(envoygrpc.newbuilder() .setclustername(xds_cluster)))) .build(); httpconnectionmanager manager = httpconnectionmanager.newbuilder() .setcodectype(codectype.auto) .setstatprefix(\"http\") .setrds(rds.newbuilder() .setconfigsource(rdssource) .setrouteconfigname(routename)) .addhttpfilters(httpfilter.newbuilder() .setname(resources.filter_envoy_router)) .build(); return listener.newbuilder() .setname(listenername) .setaddress(address.newbuilder() .setsocketaddress(socketaddress.newbuilder() .setaddress(any_address) .setportvalue(port) .setprotocol(protocol.tcp))) .addfilterchains(filterchain.newbuilder() .addfilters(filter.newbuilder() .setname(resources.filter_http_connection_manager) .settypedconfig(any.pack(manager)))) .build(); }","repo":"smtilden\/java-control-plane","label":[0,0,0,0]}
{"id":24996,"original_code":"@Override\n    public void performInitialization(Object model) {\n        setFieldBindingObjectPath(getBindingInfo().getBindingObjectPath());\n        super.performInitialization(model);\n        if (bindingInfo != null) {\n            bindingInfo.setDefaults(ViewLifecycle.getActiveLifecycle().getView(), getPropertyName());\n        }\n        \/\/ TODO: set object path for prototypes equal to the tree group object path?\n    }","code_wo_comment":"@Override\n    public void performInitialization(Object model) {\n        setFieldBindingObjectPath(getBindingInfo().getBindingObjectPath());\n        super.performInitialization(model);\n        if (bindingInfo != null) {\n            bindingInfo.setDefaults(ViewLifecycle.getActiveLifecycle().getView(), getPropertyName());\n        }\n       \n    }","cleancode":"@override public void performinitialization(object model) { setfieldbindingobjectpath(getbindinginfo().getbindingobjectpath()); super.performinitialization(model); if (bindinginfo != null) { bindinginfo.setdefaults(viewlifecycle.getactivelifecycle().getview(), getpropertyname()); } }","repo":"ricepanda\/rice","label":[0,1,0,0]}
{"id":25027,"original_code":"@Override\n    public Map<String, String> getOptionList(String id) {\n        \/\/ TODO: Return genre map\n        return super.getOptionList(id);\n    }","code_wo_comment":"@Override\n    public Map<String, String> getOptionList(String id) {\n       \n        return super.getOptionList(id);\n    }","cleancode":"@override public map<string, string> getoptionlist(string id) { return super.getoptionlist(id); }","repo":"stuckless\/sagetv-phoenix-core","label":[0,1,0,0]}
{"id":16873,"original_code":"private List<InferenceInOutSequence> getInputOutputAssets() throws IOException {\n        \/\/ TODO: Caching, don't read inputs for every inference\n        List<InferenceInOutSequence> inOutList =\n                getInputOutputAssets(mContext, mInputOutputAssets, mInputOutputDatasets);\n        Boolean lastGolden = null;\n        for (InferenceInOutSequence sequence : inOutList) {\n            mHasGoldenOutputs = sequence.hasGoldenOutput();\n            if (lastGolden == null) {\n                lastGolden = mHasGoldenOutputs;\n            } else {\n                if (lastGolden != mHasGoldenOutputs) {\n                    throw new IllegalArgumentException(\n                            \"Some inputs for \" + mModelName + \" have outputs while some don't.\");\n                }\n            }\n        }\n        return inOutList;\n    }","code_wo_comment":"private List<InferenceInOutSequence> getInputOutputAssets() throws IOException {\n       \n        List<InferenceInOutSequence> inOutList =\n                getInputOutputAssets(mContext, mInputOutputAssets, mInputOutputDatasets);\n        Boolean lastGolden = null;\n        for (InferenceInOutSequence sequence : inOutList) {\n            mHasGoldenOutputs = sequence.hasGoldenOutput();\n            if (lastGolden == null) {\n                lastGolden = mHasGoldenOutputs;\n            } else {\n                if (lastGolden != mHasGoldenOutputs) {\n                    throw new IllegalArgumentException(\n                            \"Some inputs for \" + mModelName + \" have outputs while some don't.\");\n                }\n            }\n        }\n        return inOutList;\n    }","cleancode":"private list<inferenceinoutsequence> getinputoutputassets() throws ioexception { list<inferenceinoutsequence> inoutlist = getinputoutputassets(mcontext, minputoutputassets, minputoutputdatasets); boolean lastgolden = null; for (inferenceinoutsequence sequence : inoutlist) { mhasgoldenoutputs = sequence.hasgoldenoutput(); if (lastgolden == null) { lastgolden = mhasgoldenoutputs; } else { if (lastgolden != mhasgoldenoutputs) { throw new illegalargumentexception( \"some inputs for \" + mmodelname + \" have outputs while some don't.\"); } } } return inoutlist; }","repo":"riscv-android-src\/platform-test-mlts-benchmark","label":[0,1,0,0]}
{"id":16874,"original_code":"public static List<InferenceInOutSequence> getInputOutputAssets(Context context,\n            InferenceInOutSequence.FromAssets[] inputOutputAssets,\n            InferenceInOutSequence.FromDataset[] inputOutputDatasets) throws IOException {\n        \/\/ TODO: Caching, don't read inputs for every inference\n        List<InferenceInOutSequence> inOutList = new ArrayList<>();\n        if (inputOutputAssets != null) {\n            for (InferenceInOutSequence.FromAssets ioAsset : inputOutputAssets) {\n                inOutList.add(ioAsset.readAssets(context.getAssets()));\n            }\n        }\n        if (inputOutputDatasets != null) {\n            for (InferenceInOutSequence.FromDataset dataset : inputOutputDatasets) {\n                inOutList.addAll(dataset.readDataset(context.getAssets(), context.getCacheDir()));\n            }\n        }\n        return inOutList;\n    }","code_wo_comment":"public static List<InferenceInOutSequence> getInputOutputAssets(Context context,\n            InferenceInOutSequence.FromAssets[] inputOutputAssets,\n            InferenceInOutSequence.FromDataset[] inputOutputDatasets) throws IOException {\n       \n        List<InferenceInOutSequence> inOutList = new ArrayList<>();\n        if (inputOutputAssets != null) {\n            for (InferenceInOutSequence.FromAssets ioAsset : inputOutputAssets) {\n                inOutList.add(ioAsset.readAssets(context.getAssets()));\n            }\n        }\n        if (inputOutputDatasets != null) {\n            for (InferenceInOutSequence.FromDataset dataset : inputOutputDatasets) {\n                inOutList.addAll(dataset.readDataset(context.getAssets(), context.getCacheDir()));\n            }\n        }\n        return inOutList;\n    }","cleancode":"public static list<inferenceinoutsequence> getinputoutputassets(context context, inferenceinoutsequence.fromassets[] inputoutputassets, inferenceinoutsequence.fromdataset[] inputoutputdatasets) throws ioexception { list<inferenceinoutsequence> inoutlist = new arraylist<>(); if (inputoutputassets != null) { for (inferenceinoutsequence.fromassets ioasset : inputoutputassets) { inoutlist.add(ioasset.readassets(context.getassets())); } } if (inputoutputdatasets != null) { for (inferenceinoutsequence.fromdataset dataset : inputoutputdatasets) { inoutlist.addall(dataset.readdataset(context.getassets(), context.getcachedir())); } } return inoutlist; }","repo":"riscv-android-src\/platform-test-mlts-benchmark","label":[0,1,0,0]}
{"id":33261,"original_code":"@Test\n\tpublic void testJMeterJtlFileWithTransactionsAndTransactionsBug() throws Exception {\n\t\tString[] runArgs = {\n\t\t\t\"--report.dir\",\n\t\t\ttemporaryFolder.getRoot().getPath(),\n\t\t\t\"jmeter\",\n\t\t\t\"--report-logline-type\",\n\t\t\t\"transaction\",\n\t\t\t\"-gt\",\n\t\t\t\"-gh\",\n\t\t\t\"-gr\",\n\t\t\t\"-gp\",\n\t\t\t\"-group-by-http-status\",\n\t\t\t\"src\/test\/resources\/jmeter\/result_with_url_and_sample_transaction_lines_with_bug.jtl\"\n\t\t};\n\t\tString result = LogRaterRunTestUtil.getOutputFromLogRater(runArgs);\n\t\tSystem.out.printf(\"[%s]%n\", result);\n\t\t\/\/ sampler samples (e.g. http request)\n\t\tassertFalse(\"Contains 1 GET Jaw Kat\", result.contains(\"GET Jaw Kat,200,1\"));\n\t\tassertFalse(\"Contains 1 GET Jaw Yaw\", result.contains(\"GET Jaw Yaw,200,1\"));\n\t\t\/\/ transaction controller samples\n\t\tassertTrue(\"Contains 1 cog\", result.contains(\"cog,200,1\"));\n\t\tassertTrue(\"Contains 1 som\", result.contains(\"som,200,1\"));\n\t\t\/\/ buggy transaction controller samples, are classified as transactions because URL column is available\n\t\tassertTrue(\"Contains 3 ane transactions\", result.contains(\"ane,204,3\"));\n\t\tassertTrue(\"The files contain 5 lines of which 0 failure lines.\", result.contains(\"total-counter-success-total,5,0\"));\n\t}","code_wo_comment":"@Test\n\tpublic void testJMeterJtlFileWithTransactionsAndTransactionsBug() throws Exception {\n\t\tString[] runArgs = {\n\t\t\t\"--report.dir\",\n\t\t\ttemporaryFolder.getRoot().getPath(),\n\t\t\t\"jmeter\",\n\t\t\t\"--report-logline-type\",\n\t\t\t\"transaction\",\n\t\t\t\"-gt\",\n\t\t\t\"-gh\",\n\t\t\t\"-gr\",\n\t\t\t\"-gp\",\n\t\t\t\"-group-by-http-status\",\n\t\t\t\"src\/test\/resources\/jmeter\/result_with_url_and_sample_transaction_lines_with_bug.jtl\"\n\t\t};\n\t\tString result = LogRaterRunTestUtil.getOutputFromLogRater(runArgs);\n\t\tSystem.out.printf(\"[%s]%n\", result);\n\t\n\t\tassertFalse(\"Contains 1 GET Jaw Kat\", result.contains(\"GET Jaw Kat,200,1\"));\n\t\tassertFalse(\"Contains 1 GET Jaw Yaw\", result.contains(\"GET Jaw Yaw,200,1\"));\n\t\n\t\tassertTrue(\"Contains 1 cog\", result.contains(\"cog,200,1\"));\n\t\tassertTrue(\"Contains 1 som\", result.contains(\"som,200,1\"));\n\t\n\t\tassertTrue(\"Contains 3 ane transactions\", result.contains(\"ane,204,3\"));\n\t\tassertTrue(\"The files contain 5 lines of which 0 failure lines.\", result.contains(\"total-counter-success-total,5,0\"));\n\t}","cleancode":"@test public void testjmeterjtlfilewithtransactionsandtransactionsbug() throws exception { string[] runargs = { \"--report.dir\", temporaryfolder.getroot().getpath(), \"jmeter\", \"--report-logline-type\", \"transaction\", \"-gt\", \"-gh\", \"-gr\", \"-gp\", \"-group-by-http-status\", \"src\/test\/resources\/jmeter\/result_with_url_and_sample_transaction_lines_with_bug.jtl\" }; string result = lograterruntestutil.getoutputfromlograter(runargs); system.out.printf(\"[%s]%n\", result); assertfalse(\"contains 1 get jaw kat\", result.contains(\"get jaw kat,200,1\")); assertfalse(\"contains 1 get jaw yaw\", result.contains(\"get jaw yaw,200,1\")); asserttrue(\"contains 1 cog\", result.contains(\"cog,200,1\")); asserttrue(\"contains 1 som\", result.contains(\"som,200,1\")); asserttrue(\"contains 3 ane transactions\", result.contains(\"ane,204,3\")); asserttrue(\"the files contain 5 lines of which 0 failure lines.\", result.contains(\"total-counter-success-total,5,0\")); }","repo":"stokpop\/lograter","label":[0,0,0,0]}
{"id":33268,"original_code":"@Override\n    public CustomProfile extractUserProfile(User user) throws InvalidDefinitionException {\n        \/\/ fetch custom attributes\n        List<UserAttributes> userAttributes = user.getAttributes().stream()\n                .filter(ua -> !ua.getIdentifier().startsWith(\"aac.\"))\n                .collect(Collectors.toList());\n        \/\/ fetch identities\n        Collection<UserIdentity> identities = user.getIdentities();\n        if (identities.isEmpty()) {\n            return extract(userAttributes);\n        }\n        \/\/ TODO decide how to merge identities into a single profile\n        \/\/ for now get first identity, should be last logged in\n        UserIdentity id = identities.iterator().next();\n        CustomProfile profile = extract(mergeAttributes(userAttributes, id.getAttributes()));\n        return profile;\n    }","code_wo_comment":"@Override\n    public CustomProfile extractUserProfile(User user) throws InvalidDefinitionException {\n       \n        List<UserAttributes> userAttributes = user.getAttributes().stream()\n                .filter(ua -> !ua.getIdentifier().startsWith(\"aac.\"))\n                .collect(Collectors.toList());\n       \n        Collection<UserIdentity> identities = user.getIdentities();\n        if (identities.isEmpty()) {\n            return extract(userAttributes);\n        }\n       \n       \n        UserIdentity id = identities.iterator().next();\n        CustomProfile profile = extract(mergeAttributes(userAttributes, id.getAttributes()));\n        return profile;\n    }","cleancode":"@override public customprofile extractuserprofile(user user) throws invaliddefinitionexception { list<userattributes> userattributes = user.getattributes().stream() .filter(ua -> !ua.getidentifier().startswith(\"aac.\")) .collect(collectors.tolist()); collection<useridentity> identities = user.getidentities(); if (identities.isempty()) { return extract(userattributes); } useridentity id = identities.iterator().next(); customprofile profile = extract(mergeattributes(userattributes, id.getattributes())); return profile; }","repo":"smartcommunitylab\/AAC","label":[1,0,0,0]}
{"id":16896,"original_code":"public TypeUse getTypeUse(XSSimpleType owner) {\n            if(typeUse!=null)\n                return typeUse;\n            JCodeModel cm = getCodeModel();\n            JDefinedClass a;\n            try {\n                a = cm._class(adapter);\n                a.hide();   \/\/ we assume this is given by the user\n                a._extends(cm.ref(XmlAdapter.class).narrow(String.class).narrow(\n                        cm.ref(type)));\n            } catch (JClassAlreadyExistsException e) {\n                a = e.getExistingClass();\n            }\n            \/\/ TODO: it's not correct to say that it adapts from String,\n            \/\/ but OTOH I don't think we can compute that.\n            typeUse = TypeUseFactory.adapt(\n                    CBuiltinLeafInfo.STRING,\n                    new CAdapter(a));\n            return typeUse;\n        }","code_wo_comment":"public TypeUse getTypeUse(XSSimpleType owner) {\n            if(typeUse!=null)\n                return typeUse;\n            JCodeModel cm = getCodeModel();\n            JDefinedClass a;\n            try {\n                a = cm._class(adapter);\n                a.hide();  \n                a._extends(cm.ref(XmlAdapter.class).narrow(String.class).narrow(\n                        cm.ref(type)));\n            } catch (JClassAlreadyExistsException e) {\n                a = e.getExistingClass();\n            }\n           \n           \n            typeUse = TypeUseFactory.adapt(\n                    CBuiltinLeafInfo.STRING,\n                    new CAdapter(a));\n            return typeUse;\n        }","cleancode":"public typeuse gettypeuse(xssimpletype owner) { if(typeuse!=null) return typeuse; jcodemodel cm = getcodemodel(); jdefinedclass a; try { a = cm._class(adapter); a.hide(); a._extends(cm.ref(xmladapter.class).narrow(string.class).narrow( cm.ref(type))); } catch (jclassalreadyexistsexception e) { a = e.getexistingclass(); } typeuse = typeusefactory.adapt( cbuiltinleafinfo.string, new cadapter(a)); return typeuse; }","repo":"renshuaibing-aaron\/jdk1.8-source-analysis","label":[1,0,0,0]}
{"id":8710,"original_code":"public EntityIdentifier[] searchForGroups(\n            final String query,\n            final SearchMethod method,\n            @SuppressWarnings(\"unchecked\") final Class leaftype) {\n        \/\/ only search for groups\n        if (leaftype != IPerson.class) {\n            return new EntityIdentifier[] {};\n        }\n        if (LOGGER.isDebugEnabled()) {\n            LOGGER.debug(\"Searching Grouper for groups matching query: \" + query);\n        }\n        \/\/ result groups.\n        List<EntityIdentifier> groups = new ArrayList<EntityIdentifier>();\n        try {\n            \/\/ TODO: searches need to be performed against the group display\n            \/\/ name rather than the group key\n            GcFindGroups groupSearch = new GcFindGroups();\n            WsQueryFilter filter = new WsQueryFilter();\n            \/\/ is this an exact search or fuzzy\n            if ((method == SearchMethod.DISCRETE_CI) || (method == SearchMethod.DISCRETE)) {\n                filter.setQueryFilterType(\"FIND_BY_GROUP_NAME_EXACT\");\n            } else {\n                filter.setQueryFilterType(\"FIND_BY_GROUP_NAME_APPROXIMATE\");\n            }\n            filter.setGroupName(query);\n            groupSearch.assignQueryFilter(filter);\n            WsFindGroupsResults results = groupSearch.execute();\n            if (results != null && results.getGroupResults() != null) {\n                for (WsGroup g : results.getGroupResults()) {\n                    if (validKey(g.getName())) {\n                        if (LOGGER.isTraceEnabled()) {\n                            LOGGER.trace(\"Retrieved group: \" + g.getName());\n                        }\n                        groups.add(new EntityIdentifier(g.getName(), IEntityGroup.class));\n                    }\n                }\n            }\n            if (LOGGER.isDebugEnabled()) {\n                LOGGER.debug(\"Returning \" + groups.size() + \" results for query \" + query);\n            }\n            return groups.toArray(new EntityIdentifier[groups.size()]);\n        } catch (Exception e) {\n            LOGGER.warn(\n                    \"Exception while attempting to retrieve \"\n                            + \"search results for query \"\n                            + query\n                            + \" and entity type \"\n                            + leaftype.getCanonicalName()\n                            + \" : \"\n                            + e.getMessage());\n            return new EntityIdentifier[] {};\n        }\n    }","code_wo_comment":"public EntityIdentifier[] searchForGroups(\n            final String query,\n            final SearchMethod method,\n            @SuppressWarnings(\"unchecked\") final Class leaftype) {\n       \n        if (leaftype != IPerson.class) {\n            return new EntityIdentifier[] {};\n        }\n        if (LOGGER.isDebugEnabled()) {\n            LOGGER.debug(\"Searching Grouper for groups matching query: \" + query);\n        }\n       \n        List<EntityIdentifier> groups = new ArrayList<EntityIdentifier>();\n        try {\n           \n           \n            GcFindGroups groupSearch = new GcFindGroups();\n            WsQueryFilter filter = new WsQueryFilter();\n           \n            if ((method == SearchMethod.DISCRETE_CI) || (method == SearchMethod.DISCRETE)) {\n                filter.setQueryFilterType(\"FIND_BY_GROUP_NAME_EXACT\");\n            } else {\n                filter.setQueryFilterType(\"FIND_BY_GROUP_NAME_APPROXIMATE\");\n            }\n            filter.setGroupName(query);\n            groupSearch.assignQueryFilter(filter);\n            WsFindGroupsResults results = groupSearch.execute();\n            if (results != null && results.getGroupResults() != null) {\n                for (WsGroup g : results.getGroupResults()) {\n                    if (validKey(g.getName())) {\n                        if (LOGGER.isTraceEnabled()) {\n                            LOGGER.trace(\"Retrieved group: \" + g.getName());\n                        }\n                        groups.add(new EntityIdentifier(g.getName(), IEntityGroup.class));\n                    }\n                }\n            }\n            if (LOGGER.isDebugEnabled()) {\n                LOGGER.debug(\"Returning \" + groups.size() + \" results for query \" + query);\n            }\n            return groups.toArray(new EntityIdentifier[groups.size()]);\n        } catch (Exception e) {\n            LOGGER.warn(\n                    \"Exception while attempting to retrieve \"\n                            + \"search results for query \"\n                            + query\n                            + \" and entity type \"\n                            + leaftype.getCanonicalName()\n                            + \" : \"\n                            + e.getMessage());\n            return new EntityIdentifier[] {};\n        }\n    }","cleancode":"public entityidentifier[] searchforgroups( final string query, final searchmethod method, @suppresswarnings(\"unchecked\") final class leaftype) { if (leaftype != iperson.class) { return new entityidentifier[] {}; } if (logger.isdebugenabled()) { logger.debug(\"searching grouper for groups matching query: \" + query); } list<entityidentifier> groups = new arraylist<entityidentifier>(); try { gcfindgroups groupsearch = new gcfindgroups(); wsqueryfilter filter = new wsqueryfilter(); if ((method == searchmethod.discrete_ci) || (method == searchmethod.discrete)) { filter.setqueryfiltertype(\"find_by_group_name_exact\"); } else { filter.setqueryfiltertype(\"find_by_group_name_approximate\"); } filter.setgroupname(query); groupsearch.assignqueryfilter(filter); wsfindgroupsresults results = groupsearch.execute(); if (results != null && results.getgroupresults() != null) { for (wsgroup g : results.getgroupresults()) { if (validkey(g.getname())) { if (logger.istraceenabled()) { logger.trace(\"retrieved group: \" + g.getname()); } groups.add(new entityidentifier(g.getname(), ientitygroup.class)); } } } if (logger.isdebugenabled()) { logger.debug(\"returning \" + groups.size() + \" results for query \" + query); } return groups.toarray(new entityidentifier[groups.size()]); } catch (exception e) { logger.warn( \"exception while attempting to retrieve \" + \"search results for query \" + query + \" and entity type \" + leaftype.getcanonicalname() + \" : \" + e.getmessage()); return new entityidentifier[] {}; } }","repo":"shreeshreee\/Uport","label":[1,0,0,0]}
{"id":33289,"original_code":"@Override\n  public void run(RunNotifier runNotifier) {\n    runNotifier.fireTestRunStarted(topLevelDesc);\n    for (SelfTest selfTest : selfTests) {\n      for (SelfTestCase selfTestCase : selfTest.getSelfTestCases()) {\n        Description currentDesc = createTestCaseDescription(selfTestCase);\n        runNotifier.fireTestStarted(currentDesc);\n        try {\n          selfTest.runTest(selfTestCase);\n        } catch (IllegalAccessException | IllegalArgumentException | InvocationTargetException\n            | AssertionError e) {\n          runNotifier.fireTestFailure(new Failure(currentDesc, e));\n        }\n        runNotifier.fireTestFinished(currentDesc);\n      }\n    }\n    \/\/ TODO: Fill in the Result instance appropriately.\n    runNotifier.fireTestRunFinished(new Result());\n  }","code_wo_comment":"@Override\n  public void run(RunNotifier runNotifier) {\n    runNotifier.fireTestRunStarted(topLevelDesc);\n    for (SelfTest selfTest : selfTests) {\n      for (SelfTestCase selfTestCase : selfTest.getSelfTestCases()) {\n        Description currentDesc = createTestCaseDescription(selfTestCase);\n        runNotifier.fireTestStarted(currentDesc);\n        try {\n          selfTest.runTest(selfTestCase);\n        } catch (IllegalAccessException | IllegalArgumentException | InvocationTargetException\n            | AssertionError e) {\n          runNotifier.fireTestFailure(new Failure(currentDesc, e));\n        }\n        runNotifier.fireTestFinished(currentDesc);\n      }\n    }\n   \n    runNotifier.fireTestRunFinished(new Result());\n  }","cleancode":"@override public void run(runnotifier runnotifier) { runnotifier.firetestrunstarted(topleveldesc); for (selftest selftest : selftests) { for (selftestcase selftestcase : selftest.getselftestcases()) { description currentdesc = createtestcasedescription(selftestcase); runnotifier.fireteststarted(currentdesc); try { selftest.runtest(selftestcase); } catch (illegalaccessexception | illegalargumentexception | invocationtargetexception | assertionerror e) { runnotifier.firetestfailure(new failure(currentdesc, e)); } runnotifier.firetestfinished(currentdesc); } } runnotifier.firetestrunfinished(new result()); }","repo":"scottmcmaster\/blogcode","label":[0,1,0,0]}
{"id":8757,"original_code":"@Override\n        public void notifyChildrenChanged(final RemoteUserInfo remoteUserInfo,\n                final String parentId, final Bundle options) {\n            \/\/ TODO(Post-P): Need a way to notify to a specific browser in framework.\n            notifyChildrenChangedForCompat(remoteUserInfo, parentId, options);\n        }","code_wo_comment":"@Override\n        public void notifyChildrenChanged(final RemoteUserInfo remoteUserInfo,\n                final String parentId, final Bundle options) {\n           \n            notifyChildrenChangedForCompat(remoteUserInfo, parentId, options);\n        }","cleancode":"@override public void notifychildrenchanged(final remoteuserinfo remoteuserinfo, final string parentid, final bundle options) { notifychildrenchangedforcompat(remoteuserinfo, parentid, options); }","repo":"svasilinets\/androidx","label":[1,0,0,0]}
{"id":25273,"original_code":"@Override\n\tpublic IASTTranslationUnit getTranslationUnit(IFile fileToParse) throws UnsupportedDialectException {\n    \t\/\/TODO - At this time, we purely delegate blindly\n    \t\/\/In the future, we may need to delegate based upon context provided\n        return defaultService.getTranslationUnit(fileToParse);\n    }","code_wo_comment":"@Override\n\tpublic IASTTranslationUnit getTranslationUnit(IFile fileToParse) throws UnsupportedDialectException {\n    \n    \n        return defaultService.getTranslationUnit(fileToParse);\n    }","cleancode":"@override public iasttranslationunit gettranslationunit(ifile filetoparse) throws unsupporteddialectexception { return defaultservice.gettranslationunit(filetoparse); }","repo":"seemoo-lab\/polypyus_pdom","label":[0,1,0,0]}
{"id":25274,"original_code":"@Override\n\tpublic IASTTranslationUnit getTranslationUnit(IFile fileToParse, ICodeReaderFactory fileCreator) throws UnsupportedDialectException {\n    \t\/\/TODO - At this time, we purely delegate blindly\n    \t\/\/In the future, we may need to delegate based upon context provided\n    \treturn defaultService.getTranslationUnit(fileToParse, fileCreator );\n    }","code_wo_comment":"@Override\n\tpublic IASTTranslationUnit getTranslationUnit(IFile fileToParse, ICodeReaderFactory fileCreator) throws UnsupportedDialectException {\n    \n    \n    \treturn defaultService.getTranslationUnit(fileToParse, fileCreator );\n    }","cleancode":"@override public iasttranslationunit gettranslationunit(ifile filetoparse, icodereaderfactory filecreator) throws unsupporteddialectexception { return defaultservice.gettranslationunit(filetoparse, filecreator ); }","repo":"seemoo-lab\/polypyus_pdom","label":[0,1,0,0]}
{"id":25275,"original_code":"@Override\n\tpublic IASTTranslationUnit getTranslationUnit(IFile fileToParse, ICodeReaderFactory fileCreator, IParserConfiguration configuration) throws UnsupportedDialectException {\n    \t\/\/TODO - At this time, we purely delegate blindly\n    \t\/\/In the future, we may need to delegate based upon context provided\n        return defaultService.getTranslationUnit(fileToParse, fileCreator, configuration );\n    }","code_wo_comment":"@Override\n\tpublic IASTTranslationUnit getTranslationUnit(IFile fileToParse, ICodeReaderFactory fileCreator, IParserConfiguration configuration) throws UnsupportedDialectException {\n    \n    \n        return defaultService.getTranslationUnit(fileToParse, fileCreator, configuration );\n    }","cleancode":"@override public iasttranslationunit gettranslationunit(ifile filetoparse, icodereaderfactory filecreator, iparserconfiguration configuration) throws unsupporteddialectexception { return defaultservice.gettranslationunit(filetoparse, filecreator, configuration ); }","repo":"seemoo-lab\/polypyus_pdom","label":[0,1,0,0]}
{"id":25276,"original_code":"@Override\n\tpublic IASTCompletionNode getCompletionNode(IFile fileToParse, int offset,\n            ICodeReaderFactory fileCreator) throws UnsupportedDialectException {\n        \/\/TODO - At this time, we purely delegate blindly\n        \/\/In the future, we may need to delegate based upon context provided\n        return defaultService.getCompletionNode(fileToParse, offset, fileCreator);\n    }","code_wo_comment":"@Override\n\tpublic IASTCompletionNode getCompletionNode(IFile fileToParse, int offset,\n            ICodeReaderFactory fileCreator) throws UnsupportedDialectException {\n       \n       \n        return defaultService.getCompletionNode(fileToParse, offset, fileCreator);\n    }","cleancode":"@override public iastcompletionnode getcompletionnode(ifile filetoparse, int offset, icodereaderfactory filecreator) throws unsupporteddialectexception { return defaultservice.getcompletionnode(filetoparse, offset, filecreator); }","repo":"seemoo-lab\/polypyus_pdom","label":[0,1,0,0]}
{"id":25277,"original_code":"@Override\n\tpublic IASTCompletionNode getCompletionNode(IStorage fileToParse, IProject project, int offset,\n            ICodeReaderFactory fileCreator) throws UnsupportedDialectException {\n        \/\/TODO - At this time, we purely delegate blindly\n        \/\/In the future, we may need to delegate based upon context provided\n        return defaultService.getCompletionNode(fileToParse, project, offset, fileCreator);\n    }","code_wo_comment":"@Override\n\tpublic IASTCompletionNode getCompletionNode(IStorage fileToParse, IProject project, int offset,\n            ICodeReaderFactory fileCreator) throws UnsupportedDialectException {\n       \n       \n        return defaultService.getCompletionNode(fileToParse, project, offset, fileCreator);\n    }","cleancode":"@override public iastcompletionnode getcompletionnode(istorage filetoparse, iproject project, int offset, icodereaderfactory filecreator) throws unsupporteddialectexception { return defaultservice.getcompletionnode(filetoparse, project, offset, filecreator); }","repo":"seemoo-lab\/polypyus_pdom","label":[0,1,0,0]}
{"id":17091,"original_code":"@Override\n  public List<SpawnResult> writeOutputToFile(\n      AbstractAction action,\n      ActionExecutionContext actionExecutionContext,\n      DeterministicWriter deterministicWriter,\n      boolean makeExecutable, boolean isRemotable)\n      throws ExecException {\n    Path outputPath =\n        actionExecutionContext.getInputPath(Iterables.getOnlyElement(action.getOutputs()));\n    \/\/ TODO(ulfjack): Consider acquiring local resources here before trying to write the file.\n    try (AutoProfiler p =\n        AutoProfiler.logged(\n            \"running write for action \" + action.prettyPrint(),\n            logger,\n            \/*minTimeForLoggingInMilliseconds=*\/ 100)) {\n      try {\n        try (OutputStream out = new BufferedOutputStream(outputPath.getOutputStream())) {\n          deterministicWriter.writeOutputFile(out);\n        }\n        if (makeExecutable) {\n          outputPath.setExecutable(true);\n        }\n      } catch (IOException e) {\n        throw new EnvironmentalExecException(\"IOException during file write\", e);\n      }\n    }\n    return ImmutableList.of();\n  }","code_wo_comment":"@Override\n  public List<SpawnResult> writeOutputToFile(\n      AbstractAction action,\n      ActionExecutionContext actionExecutionContext,\n      DeterministicWriter deterministicWriter,\n      boolean makeExecutable, boolean isRemotable)\n      throws ExecException {\n    Path outputPath =\n        actionExecutionContext.getInputPath(Iterables.getOnlyElement(action.getOutputs()));\n   \n    try (AutoProfiler p =\n        AutoProfiler.logged(\n            \"running write for action \" + action.prettyPrint(),\n            logger,\n            100)) {\n      try {\n        try (OutputStream out = new BufferedOutputStream(outputPath.getOutputStream())) {\n          deterministicWriter.writeOutputFile(out);\n        }\n        if (makeExecutable) {\n          outputPath.setExecutable(true);\n        }\n      } catch (IOException e) {\n        throw new EnvironmentalExecException(\"IOException during file write\", e);\n      }\n    }\n    return ImmutableList.of();\n  }","cleancode":"@override public list<spawnresult> writeoutputtofile( abstractaction action, actionexecutioncontext actionexecutioncontext, deterministicwriter deterministicwriter, boolean makeexecutable, boolean isremotable) throws execexception { path outputpath = actionexecutioncontext.getinputpath(iterables.getonlyelement(action.getoutputs())); try (autoprofiler p = autoprofiler.logged( \"running write for action \" + action.prettyprint(), logger, 100)) { try { try (outputstream out = new bufferedoutputstream(outputpath.getoutputstream())) { deterministicwriter.writeoutputfile(out); } if (makeexecutable) { outputpath.setexecutable(true); } } catch (ioexception e) { throw new environmentalexecexception(\"ioexception during file write\", e); } } return immutablelist.of(); }","repo":"sevki\/bazel","label":[0,1,0,0]}
{"id":733,"original_code":"public static void stopTimerQueue() {\n    singleton.stop();\n    singleton.queue = new PriorityQueue();\n  }","code_wo_comment":"public static void stopTimerQueue() {\n    singleton.stop();\n    singleton.queue = new PriorityQueue();\n  }","cleancode":"public static void stoptimerqueue() { singleton.stop(); singleton.queue = new priorityqueue(); }","repo":"rondinelisaad\/lockss-daemon","label":[0,0,1,0]}
{"id":25316,"original_code":"@Deprecated \/\/ caused issues https:\/\/github.com\/holgerbrandl\/r4intellij\/issues\/79\n    private static ArrayList<String> getInstallationFromPaths(@NotNull final String scriptName, @NotNull final String[] paths) {\n        final ArrayList<String> result = new ArrayList<String>();\n        for (String path : paths) {\n            \/\/ does not work in tests\n            final VirtualFile rootVDir = LocalFileSystem.getInstance().findFileByPath(path);\n            if (rootVDir != null) {\n\/\/                final VirtualFile rScript = rootVDir.findFileByRelativePath(\"bin\/\" + scriptName);\n                final File rScript = findScript(scriptName, path);\n                if (rScript != null) {\n                    result.add(FileUtil.toSystemDependentName(rScript.getPath()));\n                }\n            }\n        }\n        return result;\n    }","code_wo_comment":"@Deprecated     private static ArrayList<String> getInstallationFromPaths(@NotNull final String scriptName, @NotNull final String[] paths) {\n        final ArrayList<String> result = new ArrayList<String>();\n        for (String path : paths) {\n           \n            final VirtualFile rootVDir = LocalFileSystem.getInstance().findFileByPath(path);\n            if (rootVDir != null) {\n                final File rScript = findScript(scriptName, path);\n                if (rScript != null) {\n                    result.add(FileUtil.toSystemDependentName(rScript.getPath()));\n                }\n            }\n        }\n        return result;\n    }","cleancode":"@deprecated private static arraylist<string> getinstallationfrompaths(@notnull final string scriptname, @notnull final string[] paths) { final arraylist<string> result = new arraylist<string>(); for (string path : paths) { final virtualfile rootvdir = localfilesystem.getinstance().findfilebypath(path); if (rootvdir != null) { final file rscript = findscript(scriptname, path); if (rscript != null) { result.add(fileutil.tosystemdependentname(rscript.getpath())); } } } return result; }","repo":"rillig\/r4intellij","label":[0,0,1,0]}
{"id":784,"original_code":"@Test\n\t@Ignore \/\/Fix or deprecate fromExecutor, this test might randomly hang on CI\n\tpublic void rejectedExecutionExceptionOnErrorSignalExecutor()\n\t\t\tthrows InterruptedException {\n\t\tException exception = new IllegalStateException();\n\t\tfinal AtomicReference<Throwable> throwableInOnOperatorError =\n\t\t\t\tnew AtomicReference<>();\n\t\tfinal AtomicReference<Object> dataInOnOperatorError = new AtomicReference<>();\n\t\ttry {\n\t\t\tCountDownLatch hookLatch = new CountDownLatch(2);\n\t\t\tHooks.onOperatorError((t, d) -> {\n\t\t\t\tthrowableInOnOperatorError.set(t);\n\t\t\t\tdataInOnOperatorError.set(d);\n\t\t\t\thookLatch.countDown();\n\t\t\t\treturn t;\n\t\t\t});\n\t\t\tExecutorService executor = newCachedThreadPool();\n\t\t\tCountDownLatch latch = new CountDownLatch(1);\n\t\t\tAssertSubscriber<Integer> assertSubscriber = new AssertSubscriber<>();\n\t\t\tFlux.range(0, 5)\n\t\t\t    .publishOn(fromExecutorService(executor))\n\t\t\t    .doOnNext(s -> {\n\t\t\t\t    try {\n\t\t\t\t\t    latch.await();\n\t\t\t\t    }\n\t\t\t\t    catch (InterruptedException e) {\n\t\t\t\t\t    throw Exceptions.propagate(exception);\n\t\t\t\t    }\n\t\t\t    })\n\t\t\t    .publishOn(fromExecutor(executor))\n\t\t\t    .subscribe(assertSubscriber);\n\t\t\texecutor.shutdownNow();\n\t\t\tassertSubscriber.assertNoValues()\n\t\t\t                .assertNoError()\n\t\t\t                .assertNotComplete();\n\t\t\thookLatch.await();\n\t\t\tassertThat(throwableInOnOperatorError.get()).isInstanceOf(RejectedExecutionException.class);\n\t\t\tassertThat(throwableInOnOperatorError.get().getSuppressed()[0]).isSameAs(exception);\n\t\t}\n\t\tfinally {\n\t\t\tHooks.resetOnOperatorError();\n\t\t}\n\t}","code_wo_comment":"@Test\n\t@Ignore\n\tpublic void rejectedExecutionExceptionOnErrorSignalExecutor()\n\t\t\tthrows InterruptedException {\n\t\tException exception = new IllegalStateException();\n\t\tfinal AtomicReference<Throwable> throwableInOnOperatorError =\n\t\t\t\tnew AtomicReference<>();\n\t\tfinal AtomicReference<Object> dataInOnOperatorError = new AtomicReference<>();\n\t\ttry {\n\t\t\tCountDownLatch hookLatch = new CountDownLatch(2);\n\t\t\tHooks.onOperatorError((t, d) -> {\n\t\t\t\tthrowableInOnOperatorError.set(t);\n\t\t\t\tdataInOnOperatorError.set(d);\n\t\t\t\thookLatch.countDown();\n\t\t\t\treturn t;\n\t\t\t});\n\t\t\tExecutorService executor = newCachedThreadPool();\n\t\t\tCountDownLatch latch = new CountDownLatch(1);\n\t\t\tAssertSubscriber<Integer> assertSubscriber = new AssertSubscriber<>();\n\t\t\tFlux.range(0, 5)\n\t\t\t    .publishOn(fromExecutorService(executor))\n\t\t\t    .doOnNext(s -> {\n\t\t\t\t    try {\n\t\t\t\t\t    latch.await();\n\t\t\t\t    }\n\t\t\t\t    catch (InterruptedException e) {\n\t\t\t\t\t    throw Exceptions.propagate(exception);\n\t\t\t\t    }\n\t\t\t    })\n\t\t\t    .publishOn(fromExecutor(executor))\n\t\t\t    .subscribe(assertSubscriber);\n\t\t\texecutor.shutdownNow();\n\t\t\tassertSubscriber.assertNoValues()\n\t\t\t                .assertNoError()\n\t\t\t                .assertNotComplete();\n\t\t\thookLatch.await();\n\t\t\tassertThat(throwableInOnOperatorError.get()).isInstanceOf(RejectedExecutionException.class);\n\t\t\tassertThat(throwableInOnOperatorError.get().getSuppressed()[0]).isSameAs(exception);\n\t\t}\n\t\tfinally {\n\t\t\tHooks.resetOnOperatorError();\n\t\t}\n\t}","cleancode":"@test @ignore public void rejectedexecutionexceptiononerrorsignalexecutor() throws interruptedexception { exception exception = new illegalstateexception(); final atomicreference<throwable> throwableinonoperatorerror = new atomicreference<>(); final atomicreference<object> datainonoperatorerror = new atomicreference<>(); try { countdownlatch hooklatch = new countdownlatch(2); hooks.onoperatorerror((t, d) -> { throwableinonoperatorerror.set(t); datainonoperatorerror.set(d); hooklatch.countdown(); return t; }); executorservice executor = newcachedthreadpool(); countdownlatch latch = new countdownlatch(1); assertsubscriber<integer> assertsubscriber = new assertsubscriber<>(); flux.range(0, 5) .publishon(fromexecutorservice(executor)) .doonnext(s -> { try { latch.await(); } catch (interruptedexception e) { throw exceptions.propagate(exception); } }) .publishon(fromexecutor(executor)) .subscribe(assertsubscriber); executor.shutdownnow(); assertsubscriber.assertnovalues() .assertnoerror() .assertnotcomplete(); hooklatch.await(); assertthat(throwableinonoperatorerror.get()).isinstanceof(rejectedexecutionexception.class); assertthat(throwableinonoperatorerror.get().getsuppressed()[0]).issameas(exception); } finally { hooks.resetonoperatorerror(); } }","repo":"steppedreckoner\/reactor-core","label":[0,0,0,1]}
{"id":25367,"original_code":"void stopSolver() {\n        if (solverFuture != null) {\n            \/\/ TODO what happens if solver hasn't started yet (solve() is called asynchronously)\n            solver.terminateEarly();\n            \/\/ make sure solver has terminated and propagate exceptions\n            try {\n                solverFuture.get();\n                solverFuture = null;\n            } catch (InterruptedException e) {\n                Thread.currentThread().interrupt();\n                throw new RuntimeException(\"Failed to stop solver\", e);\n            } catch (ExecutionException e) {\n                throw new RuntimeException(\"Failed to stop solver\", e);\n            }\n        }\n    }","code_wo_comment":"void stopSolver() {\n        if (solverFuture != null) {\n           \n            solver.terminateEarly();\n           \n            try {\n                solverFuture.get();\n                solverFuture = null;\n            } catch (InterruptedException e) {\n                Thread.currentThread().interrupt();\n                throw new RuntimeException(\"Failed to stop solver\", e);\n            } catch (ExecutionException e) {\n                throw new RuntimeException(\"Failed to stop solver\", e);\n            }\n        }\n    }","cleancode":"void stopsolver() { if (solverfuture != null) { solver.terminateearly(); try { solverfuture.get(); solverfuture = null; } catch (interruptedexception e) { thread.currentthread().interrupt(); throw new runtimeexception(\"failed to stop solver\", e); } catch (executionexception e) { throw new runtimeexception(\"failed to stop solver\", e); } } }","repo":"rsynek-bot-account\/optaweb-vehicle-routing","label":[1,0,0,0]}
{"id":813,"original_code":"@Override\n  public boolean asyncCheckpoint(long fileId) throws AlluxioTException {\n    return false;\n  }","code_wo_comment":"@Override\n  public boolean asyncCheckpoint(long fileId) throws AlluxioTException {\n    return false;\n  }","cleancode":"@override public boolean asynccheckpoint(long fileid) throws alluxiotexception { return false; }","repo":"shaneknapp\/tachyon","label":[1,0,0,0]}
{"id":825,"original_code":"private Instance marshall(ServiceInstance serviceInstance) {\n\t\tString hostname = serviceInstance.getHost();\n\t\tString cluster = getClusterName(serviceInstance);\n\t\tBoolean status = Boolean.TRUE; \/\/TODO: where to get?\n\t\tif (hostname != null && cluster != null && status != null) {\n\t\t\tInstance instance = new Instance(hostname, cluster, status);\n\t\t\t\/\/ TODO: reimplement when metadata is in commons\n\t\t\t\/\/ add metadata\n\t\t\t\/*Map<String, String> metadata = instanceInfo.getMetadata();\n\t\t\tif (metadata != null) {\n\t\t\t\tinstance.getAttributes().putAll(metadata);\n\t\t\t}*\/\n\t\t\t\/\/ add ports\n\t\t\tinstance.getAttributes().put(\"port\", String.valueOf(serviceInstance.getPort()));\n\t\t\tboolean securePortEnabled = serviceInstance.isSecure();\n\t\t\tif (securePortEnabled) {\n\t\t\t\tinstance.getAttributes().put(\"securePort\", String.valueOf(serviceInstance.getPort()));\n\t\t\t}\n\t\t\treturn instance;\n\t\t}\n\t\telse {\n\t\t\treturn null;\n\t\t}\n\t}","code_wo_comment":"private Instance marshall(ServiceInstance serviceInstance) {\n\t\tString hostname = serviceInstance.getHost();\n\t\tString cluster = getClusterName(serviceInstance);\n\t\tBoolean status = Boolean.TRUE;\n\t\tif (hostname != null && cluster != null && status != null) {\n\t\t\tInstance instance = new Instance(hostname, cluster, status);\n\t\t\n\t\t\n\t\t\n\t\t\n\t\t\tinstance.getAttributes().put(\"port\", String.valueOf(serviceInstance.getPort()));\n\t\t\tboolean securePortEnabled = serviceInstance.isSecure();\n\t\t\tif (securePortEnabled) {\n\t\t\t\tinstance.getAttributes().put(\"securePort\", String.valueOf(serviceInstance.getPort()));\n\t\t\t}\n\t\t\treturn instance;\n\t\t}\n\t\telse {\n\t\t\treturn null;\n\t\t}\n\t}","cleancode":"private instance marshall(serviceinstance serviceinstance) { string hostname = serviceinstance.gethost(); string cluster = getclustername(serviceinstance); boolean status = boolean.true; if (hostname != null && cluster != null && status != null) { instance instance = new instance(hostname, cluster, status); instance.getattributes().put(\"port\", string.valueof(serviceinstance.getport())); boolean secureportenabled = serviceinstance.issecure(); if (secureportenabled) { instance.getattributes().put(\"secureport\", string.valueof(serviceinstance.getport())); } return instance; } else { return null; } }","repo":"royclarkson\/spring-cloud-netflix","label":[1,1,0,0]}
{"id":17289,"original_code":"@PostConstruct\n    public void setup(){\n        \/\/Do not use getClass() here... a typical weld issue...\n        endpointUrl=appConfiguration.getBaseEndpoint() + ServiceProviderConfigWS.class.getAnnotation(Path.class).value();\n    }","code_wo_comment":"@PostConstruct\n    public void setup(){\n       \n        endpointUrl=appConfiguration.getBaseEndpoint() + ServiceProviderConfigWS.class.getAnnotation(Path.class).value();\n    }","cleancode":"@postconstruct public void setup(){ endpointurl=appconfiguration.getbaseendpoint() + serviceproviderconfigws.class.getannotation(path.class).value(); }","repo":"shoebkhan09\/oxTrust","label":[0,0,1,0]}
{"id":25484,"original_code":"@Test public void testUserDefinedAggregateFunctionImplementsInterface() {\n    final String empDept = JdbcTest.EmpDeptTableFactory.class.getName();\n    final String mySum3 = Smalls.MySum3.class.getName();\n    final String model = \"{\\n\"\n        + \"  version: '1.0',\\n\"\n        + \"   schemas: [\\n\"\n        + \"     {\\n\"\n        + \"       name: 'adhoc',\\n\"\n        + \"       tables: [\\n\"\n        + \"         {\\n\"\n        + \"           name: 'EMPLOYEES',\\n\"\n        + \"           type: 'custom',\\n\"\n        + \"           factory: '\" + empDept + \"',\\n\"\n        + \"           operand: {'foo': true, 'bar': 345}\\n\"\n        + \"         }\\n\"\n        + \"       ],\\n\"\n        + \"       functions: [\\n\"\n        + \"         {\\n\"\n        + \"           name: 'MY_SUM3',\\n\"\n        + \"           className: '\" + mySum3 + \"'\\n\"\n        + \"         }\\n\"\n        + \"       ]\\n\"\n        + \"     }\\n\"\n        + \"   ]\\n\"\n        + \"}\";\n    final CalciteAssert.AssertThat with = CalciteAssert.model(model)\n        .withDefaultSchema(\"adhoc\");\n    with.query(\"select my_sum3(\\\"deptno\\\") as p from EMPLOYEES\\n\")\n        .returns(\"P=50\\n\");\n    with.withDefaultSchema(null)\n        .query(\"select \\\"adhoc\\\".my_sum3(\\\"deptno\\\") as p\\n\"\n            + \"from \\\"adhoc\\\".EMPLOYEES\\n\")\n        .returns(\"P=50\\n\");\n    with.query(\"select my_sum3(\\\"empid\\\"), \\\"deptno\\\" as p from EMPLOYEES\\n\")\n        .throws_(\"Expression 'deptno' is not being grouped\");\n    with.query(\"select my_sum3(\\\"deptno\\\") as p from EMPLOYEES\\n\")\n        .returns(\"P=50\\n\");\n    with.query(\"select my_sum3(\\\"name\\\") as p from EMPLOYEES\\n\")\n        .throws_(\"No match found for function signature MY_SUM3(<CHARACTER>)\");\n    with.query(\"select my_sum3(\\\"deptno\\\", 1) as p from EMPLOYEES\\n\")\n        .throws_(\"No match found for function signature \"\n            + \"MY_SUM3(<NUMERIC>, <NUMERIC>)\");\n    with.query(\"select my_sum3() as p from EMPLOYEES\\n\")\n        .throws_(\"No match found for function signature MY_SUM3()\");\n    with.query(\"select \\\"deptno\\\", my_sum3(\\\"deptno\\\") as p from EMPLOYEES\\n\"\n        + \"group by \\\"deptno\\\"\")\n        .returnsUnordered(\"deptno=20; P=20\",\n            \"deptno=10; P=30\");\n  }","code_wo_comment":"@Test public void testUserDefinedAggregateFunctionImplementsInterface() {\n    final String empDept = JdbcTest.EmpDeptTableFactory.class.getName();\n    final String mySum3 = Smalls.MySum3.class.getName();\n    final String model = \"{\\n\"\n        + \"  version: '1.0',\\n\"\n        + \"   schemas: [\\n\"\n        + \"     {\\n\"\n        + \"       name: 'adhoc',\\n\"\n        + \"       tables: [\\n\"\n        + \"         {\\n\"\n        + \"           name: 'EMPLOYEES',\\n\"\n        + \"           type: 'custom',\\n\"\n        + \"           factory: '\" + empDept + \"',\\n\"\n        + \"           operand: {'foo': true, 'bar': 345}\\n\"\n        + \"         }\\n\"\n        + \"       ],\\n\"\n        + \"       functions: [\\n\"\n        + \"         {\\n\"\n        + \"           name: 'MY_SUM3',\\n\"\n        + \"           className: '\" + mySum3 + \"'\\n\"\n        + \"         }\\n\"\n        + \"       ]\\n\"\n        + \"     }\\n\"\n        + \"   ]\\n\"\n        + \"}\";\n    final CalciteAssert.AssertThat with = CalciteAssert.model(model)\n        .withDefaultSchema(\"adhoc\");\n    with.query(\"select my_sum3(\\\"deptno\\\") as p from EMPLOYEES\\n\")\n        .returns(\"P=50\\n\");\n    with.withDefaultSchema(null)\n        .query(\"select \\\"adhoc\\\".my_sum3(\\\"deptno\\\") as p\\n\"\n            + \"from \\\"adhoc\\\".EMPLOYEES\\n\")\n        .returns(\"P=50\\n\");\n    with.query(\"select my_sum3(\\\"empid\\\"), \\\"deptno\\\" as p from EMPLOYEES\\n\")\n        .throws_(\"Expression 'deptno' is not being grouped\");\n    with.query(\"select my_sum3(\\\"deptno\\\") as p from EMPLOYEES\\n\")\n        .returns(\"P=50\\n\");\n    with.query(\"select my_sum3(\\\"name\\\") as p from EMPLOYEES\\n\")\n        .throws_(\"No match found for function signature MY_SUM3(<CHARACTER>)\");\n    with.query(\"select my_sum3(\\\"deptno\\\", 1) as p from EMPLOYEES\\n\")\n        .throws_(\"No match found for function signature \"\n            + \"MY_SUM3(<NUMERIC>, <NUMERIC>)\");\n    with.query(\"select my_sum3() as p from EMPLOYEES\\n\")\n        .throws_(\"No match found for function signature MY_SUM3()\");\n    with.query(\"select \\\"deptno\\\", my_sum3(\\\"deptno\\\") as p from EMPLOYEES\\n\"\n        + \"group by \\\"deptno\\\"\")\n        .returnsUnordered(\"deptno=20; P=20\",\n            \"deptno=10; P=30\");\n  }","cleancode":"@test public void testuserdefinedaggregatefunctionimplementsinterface() { final string empdept = jdbctest.empdepttablefactory.class.getname(); final string mysum3 = smalls.mysum3.class.getname(); final string model = \"{\\n\" + \" version: '1.0',\\n\" + \" schemas: [\\n\" + \" {\\n\" + \" name: 'adhoc',\\n\" + \" tables: [\\n\" + \" {\\n\" + \" name: 'employees',\\n\" + \" type: 'custom',\\n\" + \" factory: '\" + empdept + \"',\\n\" + \" operand: {'foo': true, 'bar': 345}\\n\" + \" }\\n\" + \" ],\\n\" + \" functions: [\\n\" + \" {\\n\" + \" name: 'my_sum3',\\n\" + \" classname: '\" + mysum3 + \"'\\n\" + \" }\\n\" + \" ]\\n\" + \" }\\n\" + \" ]\\n\" + \"}\"; final calciteassert.assertthat with = calciteassert.model(model) .withdefaultschema(\"adhoc\"); with.query(\"select my_sum3(\\\"deptno\\\") as p from employees\\n\") .returns(\"p=50\\n\"); with.withdefaultschema(null) .query(\"select \\\"adhoc\\\".my_sum3(\\\"deptno\\\") as p\\n\" + \"from \\\"adhoc\\\".employees\\n\") .returns(\"p=50\\n\"); with.query(\"select my_sum3(\\\"empid\\\"), \\\"deptno\\\" as p from employees\\n\") .throws_(\"expression 'deptno' is not being grouped\"); with.query(\"select my_sum3(\\\"deptno\\\") as p from employees\\n\") .returns(\"p=50\\n\"); with.query(\"select my_sum3(\\\"name\\\") as p from employees\\n\") .throws_(\"no match found for function signature my_sum3(<character>)\"); with.query(\"select my_sum3(\\\"deptno\\\", 1) as p from employees\\n\") .throws_(\"no match found for function signature \" + \"my_sum3(<numeric>, <numeric>)\"); with.query(\"select my_sum3() as p from employees\\n\") .throws_(\"no match found for function signature my_sum3()\"); with.query(\"select \\\"deptno\\\", my_sum3(\\\"deptno\\\") as p from employees\\n\" + \"group by \\\"deptno\\\"\") .returnsunordered(\"deptno=20; p=20\", \"deptno=10; p=30\"); }","repo":"sarasara100\/Quicksql","label":[0,0,0,1]}
{"id":25500,"original_code":"@Override\n    public void generateNormalAppearance()\n    {\n        PDAnnotationInk ink = (PDAnnotationInk) getAnnotation();\n        PDColor color = ink.getColor();\n        if (color == null || color.getComponents().length == 0)\n        {\n            return;\n        }\n        \/\/ PDF spec does not mention \/Border for ink annotations, but it is used if \/BS is not available\n        AnnotationBorder ab = AnnotationBorder.getAnnotationBorder(ink, ink.getBorderStyle());\n        if (Float.compare(ab.width, 0) == 0)\n        {\n            return;\n        }\n        \/\/ Adjust rectangle even if not empty\n        \/\/ file from PDF.js issue 13447\n        \/\/TODO in a class structure this should be overridable\n        float minX = Float.MAX_VALUE;\n        float minY = Float.MAX_VALUE;\n        float maxX = Float.MIN_VALUE;\n        float maxY = Float.MIN_VALUE;\n        for (float[] pathArray : ink.getInkList())\n        {\n            int nPoints = pathArray.length \/ 2;\n            for (int i = 0; i < nPoints; ++i)\n            {\n                float x = pathArray[i * 2];\n                float y = pathArray[i * 2 + 1];\n                minX = Math.min(minX, x);\n                minY = Math.min(minY, y);\n                maxX = Math.max(maxX, x);\n                maxY = Math.max(maxY, y);\n            }\n        }\n        PDRectangle rect = ink.getRectangle();\n        rect.setLowerLeftX(Math.min(minX - ab.width * 2, rect.getLowerLeftX()));\n        rect.setLowerLeftY(Math.min(minY - ab.width * 2, rect.getLowerLeftY()));\n        rect.setUpperRightX(Math.max(maxX + ab.width * 2, rect.getUpperRightX()));\n        rect.setUpperRightY(Math.max(maxY + ab.width * 2, rect.getUpperRightY()));\n        ink.setRectangle(rect);\n        try (PDAppearanceContentStream cs = getNormalAppearanceAsContentStream())\n        {\n            setOpacity(cs, ink.getConstantOpacity());\n            cs.setStrokingColor(color);\n            if (ab.dashArray != null)\n            {\n                cs.setLineDashPattern(ab.dashArray, 0);\n            }\n            cs.setLineWidth(ab.width);\n            for (float[] pathArray : ink.getInkList())\n            {\n                int nPoints = pathArray.length \/ 2;\n                \/\/ \"When drawn, the points shall be connected by straight lines or curves \n                \/\/ in an implementation-dependent way\" - we do lines.\n                for (int i = 0; i < nPoints; ++i)\n                {\n                    float x = pathArray[i * 2];\n                    float y = pathArray[i * 2 + 1];\n                    if (i == 0)\n                    {\n                        cs.moveTo(x, y);\n                    }\n                    else\n                    {\n                        cs.lineTo(x, y);\n                    }\n                }\n                cs.stroke();\n            }\n        }\n        catch (IOException ex)\n        {\n            LOG.error(ex);\n        }\n    }","code_wo_comment":"@Override\n    public void generateNormalAppearance()\n    {\n        PDAnnotationInk ink = (PDAnnotationInk) getAnnotation();\n        PDColor color = ink.getColor();\n        if (color == null || color.getComponents().length == 0)\n        {\n            return;\n        }\n       \n        AnnotationBorder ab = AnnotationBorder.getAnnotationBorder(ink, ink.getBorderStyle());\n        if (Float.compare(ab.width, 0) == 0)\n        {\n            return;\n        }\n       \n       \n       \n        float minX = Float.MAX_VALUE;\n        float minY = Float.MAX_VALUE;\n        float maxX = Float.MIN_VALUE;\n        float maxY = Float.MIN_VALUE;\n        for (float[] pathArray : ink.getInkList())\n        {\n            int nPoints = pathArray.length \/ 2;\n            for (int i = 0; i < nPoints; ++i)\n            {\n                float x = pathArray[i * 2];\n                float y = pathArray[i * 2 + 1];\n                minX = Math.min(minX, x);\n                minY = Math.min(minY, y);\n                maxX = Math.max(maxX, x);\n                maxY = Math.max(maxY, y);\n            }\n        }\n        PDRectangle rect = ink.getRectangle();\n        rect.setLowerLeftX(Math.min(minX - ab.width * 2, rect.getLowerLeftX()));\n        rect.setLowerLeftY(Math.min(minY - ab.width * 2, rect.getLowerLeftY()));\n        rect.setUpperRightX(Math.max(maxX + ab.width * 2, rect.getUpperRightX()));\n        rect.setUpperRightY(Math.max(maxY + ab.width * 2, rect.getUpperRightY()));\n        ink.setRectangle(rect);\n        try (PDAppearanceContentStream cs = getNormalAppearanceAsContentStream())\n        {\n            setOpacity(cs, ink.getConstantOpacity());\n            cs.setStrokingColor(color);\n            if (ab.dashArray != null)\n            {\n                cs.setLineDashPattern(ab.dashArray, 0);\n            }\n            cs.setLineWidth(ab.width);\n            for (float[] pathArray : ink.getInkList())\n            {\n                int nPoints = pathArray.length \/ 2;\n               \n               \n                for (int i = 0; i < nPoints; ++i)\n                {\n                    float x = pathArray[i * 2];\n                    float y = pathArray[i * 2 + 1];\n                    if (i == 0)\n                    {\n                        cs.moveTo(x, y);\n                    }\n                    else\n                    {\n                        cs.lineTo(x, y);\n                    }\n                }\n                cs.stroke();\n            }\n        }\n        catch (IOException ex)\n        {\n            LOG.error(ex);\n        }\n    }","cleancode":"@override public void generatenormalappearance() { pdannotationink ink = (pdannotationink) getannotation(); pdcolor color = ink.getcolor(); if (color == null || color.getcomponents().length == 0) { return; } annotationborder ab = annotationborder.getannotationborder(ink, ink.getborderstyle()); if (float.compare(ab.width, 0) == 0) { return; } float minx = float.max_value; float miny = float.max_value; float maxx = float.min_value; float maxy = float.min_value; for (float[] patharray : ink.getinklist()) { int npoints = patharray.length \/ 2; for (int i = 0; i < npoints; ++i) { float x = patharray[i * 2]; float y = patharray[i * 2 + 1]; minx = math.min(minx, x); miny = math.min(miny, y); maxx = math.max(maxx, x); maxy = math.max(maxy, y); } } pdrectangle rect = ink.getrectangle(); rect.setlowerleftx(math.min(minx - ab.width * 2, rect.getlowerleftx())); rect.setlowerlefty(math.min(miny - ab.width * 2, rect.getlowerlefty())); rect.setupperrightx(math.max(maxx + ab.width * 2, rect.getupperrightx())); rect.setupperrighty(math.max(maxy + ab.width * 2, rect.getupperrighty())); ink.setrectangle(rect); try (pdappearancecontentstream cs = getnormalappearanceascontentstream()) { setopacity(cs, ink.getconstantopacity()); cs.setstrokingcolor(color); if (ab.dasharray != null) { cs.setlinedashpattern(ab.dasharray, 0); } cs.setlinewidth(ab.width); for (float[] patharray : ink.getinklist()) { int npoints = patharray.length \/ 2; for (int i = 0; i < npoints; ++i) { float x = patharray[i * 2]; float y = patharray[i * 2 + 1]; if (i == 0) { cs.moveto(x, y); } else { cs.lineto(x, y); } } cs.stroke(); } } catch (ioexception ex) { log.error(ex); } }","repo":"steven-g\/pdfbox","label":[1,0,0,0]}
{"id":987,"original_code":"private OuterJoinPushDownResult processLimitedOuterJoin(RowExpression inheritedPredicate, RowExpression outerEffectivePredicate, RowExpression innerEffectivePredicate, RowExpression joinPredicate, Collection<VariableReferenceExpression> outerVariables)\n        {\n            checkArgument(Iterables.all(VariablesExtractor.extractUnique(outerEffectivePredicate), in(outerVariables)), \"outerEffectivePredicate must only contain variables from outerVariables\");\n            checkArgument(Iterables.all(VariablesExtractor.extractUnique(innerEffectivePredicate), not(in(outerVariables))), \"innerEffectivePredicate must not contain variables from outerVariables\");\n            ImmutableList.Builder<RowExpression> outerPushdownConjuncts = ImmutableList.builder();\n            ImmutableList.Builder<RowExpression> innerPushdownConjuncts = ImmutableList.builder();\n            ImmutableList.Builder<RowExpression> postJoinConjuncts = ImmutableList.builder();\n            ImmutableList.Builder<RowExpression> joinConjuncts = ImmutableList.builder();\n            \/\/ Strip out non-deterministic conjuncts\n            postJoinConjuncts.addAll(filter(extractConjuncts(inheritedPredicate), not(determinismEvaluator::isDeterministic)));\n            inheritedPredicate = logicalRowExpressions.filterDeterministicConjuncts(inheritedPredicate);\n            outerEffectivePredicate = logicalRowExpressions.filterDeterministicConjuncts(outerEffectivePredicate);\n            innerEffectivePredicate = logicalRowExpressions.filterDeterministicConjuncts(innerEffectivePredicate);\n            joinConjuncts.addAll(filter(extractConjuncts(joinPredicate), not(determinismEvaluator::isDeterministic)));\n            joinPredicate = logicalRowExpressions.filterDeterministicConjuncts(joinPredicate);\n            \/\/ Generate equality inferences\n            EqualityInference inheritedInference = createEqualityInference(inheritedPredicate);\n            EqualityInference outerInference = createEqualityInference(inheritedPredicate, outerEffectivePredicate);\n            EqualityInference.EqualityPartition equalityPartition = inheritedInference.generateEqualitiesPartitionedBy(in(outerVariables));\n            RowExpression outerOnlyInheritedEqualities = logicalRowExpressions.combineConjuncts(equalityPartition.getScopeEqualities());\n            EqualityInference potentialNullSymbolInference = createEqualityInference(outerOnlyInheritedEqualities, outerEffectivePredicate, innerEffectivePredicate, joinPredicate);\n            \/\/ See if we can push inherited predicates down\n            for (RowExpression conjunct : nonInferableConjuncts(inheritedPredicate)) {\n                RowExpression outerRewritten = outerInference.rewriteExpression(conjunct, in(outerVariables));\n                if (outerRewritten != null) {\n                    outerPushdownConjuncts.add(outerRewritten);\n                    \/\/ A conjunct can only be pushed down into an inner side if it can be rewritten in terms of the outer side\n                    RowExpression innerRewritten = potentialNullSymbolInference.rewriteExpression(outerRewritten, not(in(outerVariables)));\n                    if (innerRewritten != null) {\n                        innerPushdownConjuncts.add(innerRewritten);\n                    }\n                }\n                else {\n                    postJoinConjuncts.add(conjunct);\n                }\n            }\n            \/\/ Add the equalities from the inferences back in\n            outerPushdownConjuncts.addAll(equalityPartition.getScopeEqualities());\n            postJoinConjuncts.addAll(equalityPartition.getScopeComplementEqualities());\n            postJoinConjuncts.addAll(equalityPartition.getScopeStraddlingEqualities());\n            \/\/ See if we can push down any outer effective predicates to the inner side\n            for (RowExpression conjunct : nonInferableConjuncts(outerEffectivePredicate)) {\n                RowExpression rewritten = potentialNullSymbolInference.rewriteExpression(conjunct, not(in(outerVariables)));\n                if (rewritten != null) {\n                    innerPushdownConjuncts.add(rewritten);\n                }\n            }\n            \/\/ See if we can push down join predicates to the inner side\n            for (RowExpression conjunct : nonInferableConjuncts(joinPredicate)) {\n                RowExpression innerRewritten = potentialNullSymbolInference.rewriteExpression(conjunct, not(in(outerVariables)));\n                if (innerRewritten != null) {\n                    innerPushdownConjuncts.add(innerRewritten);\n                }\n                else {\n                    joinConjuncts.add(conjunct);\n                }\n            }\n            \/\/ Push outer and join equalities into the inner side. For example:\n            \/\/ SELECT * FROM nation LEFT OUTER JOIN region ON nation.regionkey = region.regionkey and nation.name = region.name WHERE nation.name = 'blah'\n            EqualityInference potentialNullSymbolInferenceWithoutInnerInferred = createEqualityInference(outerOnlyInheritedEqualities, outerEffectivePredicate, joinPredicate);\n            innerPushdownConjuncts.addAll(potentialNullSymbolInferenceWithoutInnerInferred.generateEqualitiesPartitionedBy(not(in(outerVariables))).getScopeEqualities());\n            \/\/ TODO: we can further improve simplifying the equalities by considering other relationships from the outer side\n            EqualityInference.EqualityPartition joinEqualityPartition = createEqualityInference(joinPredicate).generateEqualitiesPartitionedBy(not(in(outerVariables)));\n            innerPushdownConjuncts.addAll(joinEqualityPartition.getScopeEqualities());\n            joinConjuncts.addAll(joinEqualityPartition.getScopeComplementEqualities())\n                    .addAll(joinEqualityPartition.getScopeStraddlingEqualities());\n            return new OuterJoinPushDownResult(logicalRowExpressions.combineConjuncts(outerPushdownConjuncts.build()),\n                    logicalRowExpressions.combineConjuncts(innerPushdownConjuncts.build()),\n                    logicalRowExpressions.combineConjuncts(joinConjuncts.build()),\n                    logicalRowExpressions.combineConjuncts(postJoinConjuncts.build()));\n        }","code_wo_comment":"private OuterJoinPushDownResult processLimitedOuterJoin(RowExpression inheritedPredicate, RowExpression outerEffectivePredicate, RowExpression innerEffectivePredicate, RowExpression joinPredicate, Collection<VariableReferenceExpression> outerVariables)\n        {\n            checkArgument(Iterables.all(VariablesExtractor.extractUnique(outerEffectivePredicate), in(outerVariables)), \"outerEffectivePredicate must only contain variables from outerVariables\");\n            checkArgument(Iterables.all(VariablesExtractor.extractUnique(innerEffectivePredicate), not(in(outerVariables))), \"innerEffectivePredicate must not contain variables from outerVariables\");\n            ImmutableList.Builder<RowExpression> outerPushdownConjuncts = ImmutableList.builder();\n            ImmutableList.Builder<RowExpression> innerPushdownConjuncts = ImmutableList.builder();\n            ImmutableList.Builder<RowExpression> postJoinConjuncts = ImmutableList.builder();\n            ImmutableList.Builder<RowExpression> joinConjuncts = ImmutableList.builder();\n           \n            postJoinConjuncts.addAll(filter(extractConjuncts(inheritedPredicate), not(determinismEvaluator::isDeterministic)));\n            inheritedPredicate = logicalRowExpressions.filterDeterministicConjuncts(inheritedPredicate);\n            outerEffectivePredicate = logicalRowExpressions.filterDeterministicConjuncts(outerEffectivePredicate);\n            innerEffectivePredicate = logicalRowExpressions.filterDeterministicConjuncts(innerEffectivePredicate);\n            joinConjuncts.addAll(filter(extractConjuncts(joinPredicate), not(determinismEvaluator::isDeterministic)));\n            joinPredicate = logicalRowExpressions.filterDeterministicConjuncts(joinPredicate);\n           \n            EqualityInference inheritedInference = createEqualityInference(inheritedPredicate);\n            EqualityInference outerInference = createEqualityInference(inheritedPredicate, outerEffectivePredicate);\n            EqualityInference.EqualityPartition equalityPartition = inheritedInference.generateEqualitiesPartitionedBy(in(outerVariables));\n            RowExpression outerOnlyInheritedEqualities = logicalRowExpressions.combineConjuncts(equalityPartition.getScopeEqualities());\n            EqualityInference potentialNullSymbolInference = createEqualityInference(outerOnlyInheritedEqualities, outerEffectivePredicate, innerEffectivePredicate, joinPredicate);\n           \n            for (RowExpression conjunct : nonInferableConjuncts(inheritedPredicate)) {\n                RowExpression outerRewritten = outerInference.rewriteExpression(conjunct, in(outerVariables));\n                if (outerRewritten != null) {\n                    outerPushdownConjuncts.add(outerRewritten);\n                   \n                    RowExpression innerRewritten = potentialNullSymbolInference.rewriteExpression(outerRewritten, not(in(outerVariables)));\n                    if (innerRewritten != null) {\n                        innerPushdownConjuncts.add(innerRewritten);\n                    }\n                }\n                else {\n                    postJoinConjuncts.add(conjunct);\n                }\n            }\n           \n            outerPushdownConjuncts.addAll(equalityPartition.getScopeEqualities());\n            postJoinConjuncts.addAll(equalityPartition.getScopeComplementEqualities());\n            postJoinConjuncts.addAll(equalityPartition.getScopeStraddlingEqualities());\n           \n            for (RowExpression conjunct : nonInferableConjuncts(outerEffectivePredicate)) {\n                RowExpression rewritten = potentialNullSymbolInference.rewriteExpression(conjunct, not(in(outerVariables)));\n                if (rewritten != null) {\n                    innerPushdownConjuncts.add(rewritten);\n                }\n            }\n           \n            for (RowExpression conjunct : nonInferableConjuncts(joinPredicate)) {\n                RowExpression innerRewritten = potentialNullSymbolInference.rewriteExpression(conjunct, not(in(outerVariables)));\n                if (innerRewritten != null) {\n                    innerPushdownConjuncts.add(innerRewritten);\n                }\n                else {\n                    joinConjuncts.add(conjunct);\n                }\n            }\n           \n           \n            EqualityInference potentialNullSymbolInferenceWithoutInnerInferred = createEqualityInference(outerOnlyInheritedEqualities, outerEffectivePredicate, joinPredicate);\n            innerPushdownConjuncts.addAll(potentialNullSymbolInferenceWithoutInnerInferred.generateEqualitiesPartitionedBy(not(in(outerVariables))).getScopeEqualities());\n           \n            EqualityInference.EqualityPartition joinEqualityPartition = createEqualityInference(joinPredicate).generateEqualitiesPartitionedBy(not(in(outerVariables)));\n            innerPushdownConjuncts.addAll(joinEqualityPartition.getScopeEqualities());\n            joinConjuncts.addAll(joinEqualityPartition.getScopeComplementEqualities())\n                    .addAll(joinEqualityPartition.getScopeStraddlingEqualities());\n            return new OuterJoinPushDownResult(logicalRowExpressions.combineConjuncts(outerPushdownConjuncts.build()),\n                    logicalRowExpressions.combineConjuncts(innerPushdownConjuncts.build()),\n                    logicalRowExpressions.combineConjuncts(joinConjuncts.build()),\n                    logicalRowExpressions.combineConjuncts(postJoinConjuncts.build()));\n        }","cleancode":"private outerjoinpushdownresult processlimitedouterjoin(rowexpression inheritedpredicate, rowexpression outereffectivepredicate, rowexpression innereffectivepredicate, rowexpression joinpredicate, collection<variablereferenceexpression> outervariables) { checkargument(iterables.all(variablesextractor.extractunique(outereffectivepredicate), in(outervariables)), \"outereffectivepredicate must only contain variables from outervariables\"); checkargument(iterables.all(variablesextractor.extractunique(innereffectivepredicate), not(in(outervariables))), \"innereffectivepredicate must not contain variables from outervariables\"); immutablelist.builder<rowexpression> outerpushdownconjuncts = immutablelist.builder(); immutablelist.builder<rowexpression> innerpushdownconjuncts = immutablelist.builder(); immutablelist.builder<rowexpression> postjoinconjuncts = immutablelist.builder(); immutablelist.builder<rowexpression> joinconjuncts = immutablelist.builder(); postjoinconjuncts.addall(filter(extractconjuncts(inheritedpredicate), not(determinismevaluator::isdeterministic))); inheritedpredicate = logicalrowexpressions.filterdeterministicconjuncts(inheritedpredicate); outereffectivepredicate = logicalrowexpressions.filterdeterministicconjuncts(outereffectivepredicate); innereffectivepredicate = logicalrowexpressions.filterdeterministicconjuncts(innereffectivepredicate); joinconjuncts.addall(filter(extractconjuncts(joinpredicate), not(determinismevaluator::isdeterministic))); joinpredicate = logicalrowexpressions.filterdeterministicconjuncts(joinpredicate); equalityinference inheritedinference = createequalityinference(inheritedpredicate); equalityinference outerinference = createequalityinference(inheritedpredicate, outereffectivepredicate); equalityinference.equalitypartition equalitypartition = inheritedinference.generateequalitiespartitionedby(in(outervariables)); rowexpression outeronlyinheritedequalities = logicalrowexpressions.combineconjuncts(equalitypartition.getscopeequalities()); equalityinference potentialnullsymbolinference = createequalityinference(outeronlyinheritedequalities, outereffectivepredicate, innereffectivepredicate, joinpredicate); for (rowexpression conjunct : noninferableconjuncts(inheritedpredicate)) { rowexpression outerrewritten = outerinference.rewriteexpression(conjunct, in(outervariables)); if (outerrewritten != null) { outerpushdownconjuncts.add(outerrewritten); rowexpression innerrewritten = potentialnullsymbolinference.rewriteexpression(outerrewritten, not(in(outervariables))); if (innerrewritten != null) { innerpushdownconjuncts.add(innerrewritten); } } else { postjoinconjuncts.add(conjunct); } } outerpushdownconjuncts.addall(equalitypartition.getscopeequalities()); postjoinconjuncts.addall(equalitypartition.getscopecomplementequalities()); postjoinconjuncts.addall(equalitypartition.getscopestraddlingequalities()); for (rowexpression conjunct : noninferableconjuncts(outereffectivepredicate)) { rowexpression rewritten = potentialnullsymbolinference.rewriteexpression(conjunct, not(in(outervariables))); if (rewritten != null) { innerpushdownconjuncts.add(rewritten); } } for (rowexpression conjunct : noninferableconjuncts(joinpredicate)) { rowexpression innerrewritten = potentialnullsymbolinference.rewriteexpression(conjunct, not(in(outervariables))); if (innerrewritten != null) { innerpushdownconjuncts.add(innerrewritten); } else { joinconjuncts.add(conjunct); } } equalityinference potentialnullsymbolinferencewithoutinnerinferred = createequalityinference(outeronlyinheritedequalities, outereffectivepredicate, joinpredicate); innerpushdownconjuncts.addall(potentialnullsymbolinferencewithoutinnerinferred.generateequalitiespartitionedby(not(in(outervariables))).getscopeequalities()); equalityinference.equalitypartition joinequalitypartition = createequalityinference(joinpredicate).generateequalitiespartitionedby(not(in(outervariables))); innerpushdownconjuncts.addall(joinequalitypartition.getscopeequalities()); joinconjuncts.addall(joinequalitypartition.getscopecomplementequalities()) .addall(joinequalitypartition.getscopestraddlingequalities()); return new outerjoinpushdownresult(logicalrowexpressions.combineconjuncts(outerpushdownconjuncts.build()), logicalrowexpressions.combineconjuncts(innerpushdownconjuncts.build()), logicalrowexpressions.combineconjuncts(joinconjuncts.build()), logicalrowexpressions.combineconjuncts(postjoinconjuncts.build())); }","repo":"shrinidhijoshi\/presto","label":[1,0,0,0]}
{"id":17401,"original_code":"public static SqlTypeName zetaSqlTypeToCalciteType(TypeKind zetaSqlType) {\n    switch (zetaSqlType) {\n      case TYPE_INT64:\n        return SqlTypeName.BIGINT;\n      case TYPE_NUMERIC:\n        return SqlTypeName.DECIMAL;\n      case TYPE_DOUBLE:\n        return SqlTypeName.DOUBLE;\n      case TYPE_STRING:\n        return SqlTypeName.VARCHAR;\n      case TYPE_TIMESTAMP:\n        return SqlTypeName.TIMESTAMP;\n      case TYPE_BOOL:\n        return SqlTypeName.BOOLEAN;\n      case TYPE_BYTES:\n        return SqlTypeName.VARBINARY;\n        \/\/ TODO[BEAM-9179] Add conversion code for ARRAY and ROW types\n      default:\n        throw new IllegalArgumentException(\"Unsupported ZetaSQL type: \" + zetaSqlType.name());\n    }\n  }","code_wo_comment":"public static SqlTypeName zetaSqlTypeToCalciteType(TypeKind zetaSqlType) {\n    switch (zetaSqlType) {\n      case TYPE_INT64:\n        return SqlTypeName.BIGINT;\n      case TYPE_NUMERIC:\n        return SqlTypeName.DECIMAL;\n      case TYPE_DOUBLE:\n        return SqlTypeName.DOUBLE;\n      case TYPE_STRING:\n        return SqlTypeName.VARCHAR;\n      case TYPE_TIMESTAMP:\n        return SqlTypeName.TIMESTAMP;\n      case TYPE_BOOL:\n        return SqlTypeName.BOOLEAN;\n      case TYPE_BYTES:\n        return SqlTypeName.VARBINARY;\n       \n      default:\n        throw new IllegalArgumentException(\"Unsupported ZetaSQL type: \" + zetaSqlType.name());\n    }\n  }","cleancode":"public static sqltypename zetasqltypetocalcitetype(typekind zetasqltype) { switch (zetasqltype) { case type_int64: return sqltypename.bigint; case type_numeric: return sqltypename.decimal; case type_double: return sqltypename.double; case type_string: return sqltypename.varchar; case type_timestamp: return sqltypename.timestamp; case type_bool: return sqltypename.boolean; case type_bytes: return sqltypename.varbinary; default: throw new illegalargumentexception(\"unsupported zetasql type: \" + zetasqltype.name()); } }","repo":"stephenoken\/beam","label":[0,1,0,0]}
{"id":33808,"original_code":"private boolean checkPermission(Cluster cluster, boolean readOnly) {\n    for (GrantedAuthority grantedAuthority : securityHelper.getCurrentAuthorities()) {\n      if (grantedAuthority instanceof AmbariGrantedAuthority) {\n        AmbariGrantedAuthority authority       = (AmbariGrantedAuthority) grantedAuthority;\n        PrivilegeEntity        privilegeEntity = authority.getPrivilegeEntity();\n        Integer                permissionId    = privilegeEntity.getPermission().getId();\n        \/\/ admin has full access\n        if (permissionId.equals(PermissionEntity.AMBARI_ADMINISTRATOR_PERMISSION)) {\n          return true;\n        }\n        if (cluster != null) {\n          if (cluster.checkPermission(privilegeEntity, readOnly)) {\n            return true;\n          }\n        }\n      }\n    }\n    \/\/ TODO : should we log this?\n    return false;\n  }","code_wo_comment":"private boolean checkPermission(Cluster cluster, boolean readOnly) {\n    for (GrantedAuthority grantedAuthority : securityHelper.getCurrentAuthorities()) {\n      if (grantedAuthority instanceof AmbariGrantedAuthority) {\n        AmbariGrantedAuthority authority       = (AmbariGrantedAuthority) grantedAuthority;\n        PrivilegeEntity        privilegeEntity = authority.getPrivilegeEntity();\n        Integer                permissionId    = privilegeEntity.getPermission().getId();\n       \n        if (permissionId.equals(PermissionEntity.AMBARI_ADMINISTRATOR_PERMISSION)) {\n          return true;\n        }\n        if (cluster != null) {\n          if (cluster.checkPermission(privilegeEntity, readOnly)) {\n            return true;\n          }\n        }\n      }\n    }\n   \n    return false;\n  }","cleancode":"private boolean checkpermission(cluster cluster, boolean readonly) { for (grantedauthority grantedauthority : securityhelper.getcurrentauthorities()) { if (grantedauthority instanceof ambarigrantedauthority) { ambarigrantedauthority authority = (ambarigrantedauthority) grantedauthority; privilegeentity privilegeentity = authority.getprivilegeentity(); integer permissionid = privilegeentity.getpermission().getid(); if (permissionid.equals(permissionentity.ambari_administrator_permission)) { return true; } if (cluster != null) { if (cluster.checkpermission(privilegeentity, readonly)) { return true; } } } } return false; }","repo":"runningt\/ambari","label":[1,0,0,0]}
{"id":1051,"original_code":"@Override\n    public ShuffleDataModel.KValueTypeId getKValueTypeId() {\n       int val = ngetKValueTypeId(this.pointerToStore);\n       if (val==ShuffleDataModel.KValueTypeId.Int.state){\n           return ShuffleDataModel.KValueTypeId.Int;\n       }\n       else if (val == ShuffleDataModel.KValueTypeId.Long.state){\n            return ShuffleDataModel.KValueTypeId.Long;\n       }\n       else if (val == ShuffleDataModel.KValueTypeId.Float.state){\n           return ShuffleDataModel.KValueTypeId.Float;\n       }\n       else if (val == ShuffleDataModel.KValueTypeId.Double.state){\n           return ShuffleDataModel.KValueTypeId.Double;\n       }\n       else if (val == ShuffleDataModel.KValueTypeId.String.state){\n           return ShuffleDataModel.KValueTypeId.String;\n       }\n       else if (val == ShuffleDataModel.KValueTypeId.ByteArray.state){\n           return ShuffleDataModel.KValueTypeId.ByteArray;\n       }\n       else if (val ==  ShuffleDataModel.KValueTypeId.Object.state){\n           return ShuffleDataModel.KValueTypeId.Object;\n       }\n       else if (val == ShuffleDataModel.KValueTypeId.Unknown.state) {\n           throw new RuntimeException(\"Unknown key value type encountered\");\n       }\n       else {\n    \t   throw new RuntimeException(\"unsupported key value type encountered\");\n       }\n    }","code_wo_comment":"@Override\n    public ShuffleDataModel.KValueTypeId getKValueTypeId() {\n       int val = ngetKValueTypeId(this.pointerToStore);\n       if (val==ShuffleDataModel.KValueTypeId.Int.state){\n           return ShuffleDataModel.KValueTypeId.Int;\n       }\n       else if (val == ShuffleDataModel.KValueTypeId.Long.state){\n            return ShuffleDataModel.KValueTypeId.Long;\n       }\n       else if (val == ShuffleDataModel.KValueTypeId.Float.state){\n           return ShuffleDataModel.KValueTypeId.Float;\n       }\n       else if (val == ShuffleDataModel.KValueTypeId.Double.state){\n           return ShuffleDataModel.KValueTypeId.Double;\n       }\n       else if (val == ShuffleDataModel.KValueTypeId.String.state){\n           return ShuffleDataModel.KValueTypeId.String;\n       }\n       else if (val == ShuffleDataModel.KValueTypeId.ByteArray.state){\n           return ShuffleDataModel.KValueTypeId.ByteArray;\n       }\n       else if (val ==  ShuffleDataModel.KValueTypeId.Object.state){\n           return ShuffleDataModel.KValueTypeId.Object;\n       }\n       else if (val == ShuffleDataModel.KValueTypeId.Unknown.state) {\n           throw new RuntimeException(\"Unknown key value type encountered\");\n       }\n       else {\n    \t   throw new RuntimeException(\"unsupported key value type encountered\");\n       }\n    }","cleancode":"@override public shuffledatamodel.kvaluetypeid getkvaluetypeid() { int val = ngetkvaluetypeid(this.pointertostore); if (val==shuffledatamodel.kvaluetypeid.int.state){ return shuffledatamodel.kvaluetypeid.int; } else if (val == shuffledatamodel.kvaluetypeid.long.state){ return shuffledatamodel.kvaluetypeid.long; } else if (val == shuffledatamodel.kvaluetypeid.float.state){ return shuffledatamodel.kvaluetypeid.float; } else if (val == shuffledatamodel.kvaluetypeid.double.state){ return shuffledatamodel.kvaluetypeid.double; } else if (val == shuffledatamodel.kvaluetypeid.string.state){ return shuffledatamodel.kvaluetypeid.string; } else if (val == shuffledatamodel.kvaluetypeid.bytearray.state){ return shuffledatamodel.kvaluetypeid.bytearray; } else if (val == shuffledatamodel.kvaluetypeid.object.state){ return shuffledatamodel.kvaluetypeid.object; } else if (val == shuffledatamodel.kvaluetypeid.unknown.state) { throw new runtimeexception(\"unknown key value type encountered\"); } else { throw new runtimeexception(\"unsupported key value type encountered\"); } }","repo":"sparkle-plugin\/sparkle","label":[1,0,0,0]}
{"id":9251,"original_code":"public Optional<ClassName> copierClassFor(MemberModel memberModel) {\n        if (canCopyReference(memberModel)) {\n            return Optional.empty();\n        }\n        if (canUseStandardCopier(memberModel)) {\n            return Optional.of(ClassName.get(StandardMemberCopier.class));\n        }\n        \/\/ FIXME: Ugly hack, but some services (Health) have shapes with names\n        \/\/ that differ only in the casing of the first letter, and generating\n        \/\/ classes for them breaks on case insensitive filesystems...\n        String shapeName = memberModel.getC2jShape();\n        if (shapeName.substring(0, 1).toLowerCase(Locale.ENGLISH).equals(shapeName.substring(0, 1))) {\n            shapeName = \"_\" + shapeName;\n        }\n        return Optional.of(poetExtensions.getModelClass(shapeName + \"Copier\"));\n    }","code_wo_comment":"public Optional<ClassName> copierClassFor(MemberModel memberModel) {\n        if (canCopyReference(memberModel)) {\n            return Optional.empty();\n        }\n        if (canUseStandardCopier(memberModel)) {\n            return Optional.of(ClassName.get(StandardMemberCopier.class));\n        }\n       \n       \n       \n        String shapeName = memberModel.getC2jShape();\n        if (shapeName.substring(0, 1).toLowerCase(Locale.ENGLISH).equals(shapeName.substring(0, 1))) {\n            shapeName = \"_\" + shapeName;\n        }\n        return Optional.of(poetExtensions.getModelClass(shapeName + \"Copier\"));\n    }","cleancode":"public optional<classname> copierclassfor(membermodel membermodel) { if (cancopyreference(membermodel)) { return optional.empty(); } if (canusestandardcopier(membermodel)) { return optional.of(classname.get(standardmembercopier.class)); } string shapename = membermodel.getc2jshape(); if (shapename.substring(0, 1).tolowercase(locale.english).equals(shapename.substring(0, 1))) { shapename = \"_\" + shapename; } return optional.of(poetextensions.getmodelclass(shapename + \"copier\")); }","repo":"slachiewicz\/aws-sdk-java-v2","label":[1,0,0,0]}
{"id":1396,"original_code":"private synchronized void fillCostMapWithGeometries() {\n        if (mGeometryList.isEmpty()) {\n            Log.wtf(TAG, \"Empty geometries list\");\n            setValid(false);\n            return;\n        }\n        \/\/ Get the grid boundaries to determine the size of the cost map.\n        double[][] positions = findGeometriesBoundaries();\n        if (positions == null) {\n            Log.wtf(TAG, \"Could not find grid boundaries\");\n            setValid(false);\n            return;\n        }\n        \/\/ Create the grid.\n        makeGrid(positions, MIN_COST);\n        for (Geometry g : mGeometryList) {\n            int size = g.mPolygon.getSize();\n            List<Transform> points = g.mPolygon.getPoints();\n            \/\/ DiscretizedVertices contain only X and Y.\n            int[][] discretizedVertices = new int[size][2];\n            for (int i = 0; i < size; i++) {\n                double[] pointPosition = points.get(i).getPosition();\n                discretizedVertices[i][0] = (int) Math.floor(pointPosition[0] \/ getResolution());\n                discretizedVertices[i][1] = (int) Math.floor(pointPosition[1] \/ getResolution());\n            }\n            \/\/ TODO mCost is not used, function below sets polygon regions to OBSTACLE_COST.\n            drawPolygonOnGrid(discretizedVertices);\n        }\n    }","code_wo_comment":"private synchronized void fillCostMapWithGeometries() {\n        if (mGeometryList.isEmpty()) {\n            Log.wtf(TAG, \"Empty geometries list\");\n            setValid(false);\n            return;\n        }\n       \n        double[][] positions = findGeometriesBoundaries();\n        if (positions == null) {\n            Log.wtf(TAG, \"Could not find grid boundaries\");\n            setValid(false);\n            return;\n        }\n       \n        makeGrid(positions, MIN_COST);\n        for (Geometry g : mGeometryList) {\n            int size = g.mPolygon.getSize();\n            List<Transform> points = g.mPolygon.getPoints();\n           \n            int[][] discretizedVertices = new int[size][2];\n            for (int i = 0; i < size; i++) {\n                double[] pointPosition = points.get(i).getPosition();\n                discretizedVertices[i][0] = (int) Math.floor(pointPosition[0] \/ getResolution());\n                discretizedVertices[i][1] = (int) Math.floor(pointPosition[1] \/ getResolution());\n            }\n           \n            drawPolygonOnGrid(discretizedVertices);\n        }\n    }","cleancode":"private synchronized void fillcostmapwithgeometries() { if (mgeometrylist.isempty()) { log.wtf(tag, \"empty geometries list\"); setvalid(false); return; } double[][] positions = findgeometriesboundaries(); if (positions == null) { log.wtf(tag, \"could not find grid boundaries\"); setvalid(false); return; } makegrid(positions, min_cost); for (geometry g : mgeometrylist) { int size = g.mpolygon.getsize(); list<transform> points = g.mpolygon.getpoints(); int[][] discretizedvertices = new int[size][2]; for (int i = 0; i < size; i++) { double[] pointposition = points.get(i).getposition(); discretizedvertices[i][0] = (int) math.floor(pointposition[0] \/ getresolution()); discretizedvertices[i][1] = (int) math.floor(pointposition[1] \/ getresolution()); } drawpolygonongrid(discretizedvertices); } }","repo":"rhickman\/cellbots3","label":[1,0,0,0]}
{"id":1397,"original_code":"private synchronized double[][] findGeometriesBoundaries() {\n        if (mGeometryList.isEmpty()) {\n            Log.wtf(TAG, \"Empty geometries list\");\n            return null;\n        }\n        double minX = Double.MAX_VALUE;\n        double maxX = -Double.MAX_VALUE;\n        double minY = Double.MAX_VALUE;\n        double maxY = -Double.MAX_VALUE;\n        for (Geometry g : mGeometryList) {\n            int size = g.mPolygon.getSize();\n            List<Transform> points = g.mPolygon.getPoints();\n            for (int i = 0; i < size; i++) {\n                double[] pointPosition = points.get(i).getPosition();\n                minX = Math.min(minX, pointPosition[0]);\n                maxX = Math.max(maxX, pointPosition[0]);\n                minY = Math.min(minY, pointPosition[1]);\n                maxY = Math.max(maxY, pointPosition[1]);\n            }\n        }\n        return new double[][]{{minX - mRobotRadius, minY - mRobotRadius},\n                              {maxX + mRobotRadius, maxY + mRobotRadius}};\n    }","code_wo_comment":"private synchronized double[][] findGeometriesBoundaries() {\n        if (mGeometryList.isEmpty()) {\n            Log.wtf(TAG, \"Empty geometries list\");\n            return null;\n        }\n        double minX = Double.MAX_VALUE;\n        double maxX = -Double.MAX_VALUE;\n        double minY = Double.MAX_VALUE;\n        double maxY = -Double.MAX_VALUE;\n        for (Geometry g : mGeometryList) {\n            int size = g.mPolygon.getSize();\n            List<Transform> points = g.mPolygon.getPoints();\n            for (int i = 0; i < size; i++) {\n                double[] pointPosition = points.get(i).getPosition();\n                minX = Math.min(minX, pointPosition[0]);\n                maxX = Math.max(maxX, pointPosition[0]);\n                minY = Math.min(minY, pointPosition[1]);\n                maxY = Math.max(maxY, pointPosition[1]);\n            }\n        }\n        return new double[][]{{minX - mRobotRadius, minY - mRobotRadius},\n                              {maxX + mRobotRadius, maxY + mRobotRadius}};\n    }","cleancode":"private synchronized double[][] findgeometriesboundaries() { if (mgeometrylist.isempty()) { log.wtf(tag, \"empty geometries list\"); return null; } double minx = double.max_value; double maxx = -double.max_value; double miny = double.max_value; double maxy = -double.max_value; for (geometry g : mgeometrylist) { int size = g.mpolygon.getsize(); list<transform> points = g.mpolygon.getpoints(); for (int i = 0; i < size; i++) { double[] pointposition = points.get(i).getposition(); minx = math.min(minx, pointposition[0]); maxx = math.max(maxx, pointposition[0]); miny = math.min(miny, pointposition[1]); maxy = math.max(maxy, pointposition[1]); } } return new double[][]{{minx - mrobotradius, miny - mrobotradius}, {maxx + mrobotradius, maxy + mrobotradius}}; }","repo":"rhickman\/cellbots3","label":[1,0,0,0]}
{"id":34326,"original_code":"public String exportAll(String filename) throws IOException {\n    \/\/ currently only support python - maybe in future we'll support js too\n    String python = LangUtils.toPython();\n    Files.write(Paths.get(filename), python.toString().getBytes());\n    info(\"saved %s to %s\", getName(), filename);\n    return python;\n  }","code_wo_comment":"public String exportAll(String filename) throws IOException {\n   \n    String python = LangUtils.toPython();\n    Files.write(Paths.get(filename), python.toString().getBytes());\n    info(\"saved %s to %s\", getName(), filename);\n    return python;\n  }","cleancode":"public string exportall(string filename) throws ioexception { string python = langutils.topython(); files.write(paths.get(filename), python.tostring().getbytes()); info(\"saved %s to %s\", getname(), filename); return python; }","repo":"srayner\/myrobotlab","label":[1,0,0,0]}
{"id":26189,"original_code":"private void addButtonActionPerformed(java.awt.event.ActionEvent evt) {\/\/GEN-FIRST:event_addButtonActionPerformed\n        try {\n            \/\/ TODO add your handling code here:\n            try {\n                clip.stop();\n            }\n            catch(Exception e) {\n            }\n            try {\n                Class.forName(\"oracle.jdbc.driver.OracleDriver\");\n            } catch (ClassNotFoundException ex) {\n                Logger.getLogger(AdminView.class.getName()).log(Level.SEVERE, null, ex);\n            }\n            \/\/step2 create  the connection object\n            Connection con=DriverManager.getConnection(\n                    \"jdbc:oracle:thin:@localhost:1521:newdatabase\",\"system\",\"not12345\");\n            \/\/step3 create the statement object\n            Statement stmt=con.createStatement();\n            \/\/step4 execute query\n            ResultSet rs=stmt.executeQuery(\"select * from album\");\n            ArrayList<String> albumList = new ArrayList<String>();\n            HashMap<String, String> albumID = new HashMap<>();\n            while(rs.next()) {\n                albumList.add((rs.getString(2)));\n                albumID.put(rs.getString(2), rs.getString(1));\n            }\n            \/\/step4 execute query\n            rs=stmt.executeQuery(\"select * from artist\");\n            ArrayList<String> artistList = new ArrayList<String>();\n            HashMap<String, String> artistID = new HashMap<>();\n            while(rs.next()) {\n                artistList.add((rs.getString(2)));\n                artistID.put(rs.getString(2), rs.getString(1));\n            }\n            \/\/step5 close the connection object\n            con.close();\n            \/\/ TODO add your handling code here:\n\/\/            JTextField id = new JTextField();\n            JTextField name = new JTextField();\n            JTextField genre = new JTextField();\n            JTextField song_num = new JTextField();\n            JComboBox<String> albums = new JComboBox<String>(albumList.toArray(new String[0]));\n            JList artists = new JList(artistList.toArray(new String[0]));\n            artists.setSelectionMode(\n            ListSelectionModel.MULTIPLE_INTERVAL_SELECTION);\n            int[] select = {19, 20, 22};\n            Object[] input = {\n\/\/                \"Id : \", id,\n                \"Name : \", name,\n                \"Genre :\", genre,\n                \"Artist :\", artists,\n                \"Song Number in Album :\", song_num,\n                \"Album :\", albums,\n            };\n            int option = JOptionPane.showConfirmDialog(this, input, \"Enter Song details\", JOptionPane.OK_CANCEL_OPTION);\n            if(option == JOptionPane.OK_OPTION) {\n                JFileChooser jfc = new JFileChooser();\n\t\tint returnValue = jfc.showOpenDialog(null);\n\t\t\/\/ int returnValue = jfc.showSaveDialog(null);\n                String filePath = null;\n\t\tif (returnValue == JFileChooser.APPROVE_OPTION) {\n                    File selectedFile = jfc.getSelectedFile();\n                    System.out.println(selectedFile.getAbsolutePath());\n                    filePath = selectedFile.getAbsolutePath();\n                }\n                 try{  \n                    File f=new File(filePath);  \n                    Class.forName(\"oracle.jdbc.driver.OracleDriver\");  \n                    con = DriverManager.getConnection(\n                             \"jdbc:oracle:thin:@localhost:1521:newdatabase\",\"system\",\"not12345\");\n                    PreparedStatement ps = con.prepareStatement (\"insert into song values(?, ?, ?, ?, ?, ?, ?)\");\n                    ps.setString(1, null);  \n                    ps.setString(2, name.getText());\n                    ps.setString(3, albumID.get(albums.getSelectedItem().toString()));\n                    ps.setString(4, genre.getText());\n                    ps.setInt(5, 0);\n                    ps.setInt(6, Integer.parseInt(song_num.getText()));\n                    System.out.println(\"\"+f.length());\n                    ps.setBytes(7, readFile(filePath));\n                    ps.executeUpdate();\n                    ps.close();\n                    PreparedStatement ps1 = con.prepareStatement (\"select id from song where name=? and album_id=?\");\n                    ps1.setString(1, name.getText());  \n                    ps1.setString(2, albumID.get(albums.getSelectedItem().toString()));\n                    \/\/step4 execute query\n                    ResultSet rs1=ps1.executeQuery();\n                    String id = \"\";\n                    while(rs1.next()) {\n                        id = rs1.getString(1);\n                    }\n                    ps1.close();\n                    for(Object a:artists.getSelectedValuesList()) {\n                        ps = con.prepareCall (\"{call addsongartist(?, ?)}\");\n                        ps.setString(1, id);  \n                        ps.setString(2, artistID.get(a.toString()));\n                        ps.executeUpdate();\n                        ps.close();\n                    }\n                    con.close();  \n                } catch (Exception e) {e.printStackTrace();}  \n                this.updateTable();\n                JOptionPane.showMessageDialog(this, \"Success!\\n\");\n            }\n        } catch (Exception e) {\n            JOptionPane.showMessageDialog(this, \"Error!\\n\"+e.getMessage());\n        }\n    }","code_wo_comment":"private void addButtonActionPerformed(java.awt.event.ActionEvent evt) {        try {\n           \n            try {\n                clip.stop();\n            }\n            catch(Exception e) {\n            }\n            try {\n                Class.forName(\"oracle.jdbc.driver.OracleDriver\");\n            } catch (ClassNotFoundException ex) {\n                Logger.getLogger(AdminView.class.getName()).log(Level.SEVERE, null, ex);\n            }\n           \n            Connection con=DriverManager.getConnection(\n                    \"jdbc:oracle:thin:@localhost:1521:newdatabase\",\"system\",\"not12345\");\n           \n            Statement stmt=con.createStatement();\n           \n            ResultSet rs=stmt.executeQuery(\"select * from album\");\n            ArrayList<String> albumList = new ArrayList<String>();\n            HashMap<String, String> albumID = new HashMap<>();\n            while(rs.next()) {\n                albumList.add((rs.getString(2)));\n                albumID.put(rs.getString(2), rs.getString(1));\n            }\n           \n            rs=stmt.executeQuery(\"select * from artist\");\n            ArrayList<String> artistList = new ArrayList<String>();\n            HashMap<String, String> artistID = new HashMap<>();\n            while(rs.next()) {\n                artistList.add((rs.getString(2)));\n                artistID.put(rs.getString(2), rs.getString(1));\n            }\n           \n            con.close();\n           \n            JTextField name = new JTextField();\n            JTextField genre = new JTextField();\n            JTextField song_num = new JTextField();\n            JComboBox<String> albums = new JComboBox<String>(albumList.toArray(new String[0]));\n            JList artists = new JList(artistList.toArray(new String[0]));\n            artists.setSelectionMode(\n            ListSelectionModel.MULTIPLE_INTERVAL_SELECTION);\n            int[] select = {19, 20, 22};\n            Object[] input = {\n                \"Name : \", name,\n                \"Genre :\", genre,\n                \"Artist :\", artists,\n                \"Song Number in Album :\", song_num,\n                \"Album :\", albums,\n            };\n            int option = JOptionPane.showConfirmDialog(this, input, \"Enter Song details\", JOptionPane.OK_CANCEL_OPTION);\n            if(option == JOptionPane.OK_OPTION) {\n                JFileChooser jfc = new JFileChooser();\n\t\tint returnValue = jfc.showOpenDialog(null);\n\t\n                String filePath = null;\n\t\tif (returnValue == JFileChooser.APPROVE_OPTION) {\n                    File selectedFile = jfc.getSelectedFile();\n                    System.out.println(selectedFile.getAbsolutePath());\n                    filePath = selectedFile.getAbsolutePath();\n                }\n                 try{  \n                    File f=new File(filePath);  \n                    Class.forName(\"oracle.jdbc.driver.OracleDriver\");  \n                    con = DriverManager.getConnection(\n                             \"jdbc:oracle:thin:@localhost:1521:newdatabase\",\"system\",\"not12345\");\n                    PreparedStatement ps = con.prepareStatement (\"insert into song values(?, ?, ?, ?, ?, ?, ?)\");\n                    ps.setString(1, null);  \n                    ps.setString(2, name.getText());\n                    ps.setString(3, albumID.get(albums.getSelectedItem().toString()));\n                    ps.setString(4, genre.getText());\n                    ps.setInt(5, 0);\n                    ps.setInt(6, Integer.parseInt(song_num.getText()));\n                    System.out.println(\"\"+f.length());\n                    ps.setBytes(7, readFile(filePath));\n                    ps.executeUpdate();\n                    ps.close();\n                    PreparedStatement ps1 = con.prepareStatement (\"select id from song where name=? and album_id=?\");\n                    ps1.setString(1, name.getText());  \n                    ps1.setString(2, albumID.get(albums.getSelectedItem().toString()));\n                   \n                    ResultSet rs1=ps1.executeQuery();\n                    String id = \"\";\n                    while(rs1.next()) {\n                        id = rs1.getString(1);\n                    }\n                    ps1.close();\n                    for(Object a:artists.getSelectedValuesList()) {\n                        ps = con.prepareCall (\"{call addsongartist(?, ?)}\");\n                        ps.setString(1, id);  \n                        ps.setString(2, artistID.get(a.toString()));\n                        ps.executeUpdate();\n                        ps.close();\n                    }\n                    con.close();  \n                } catch (Exception e) {e.printStackTrace();}  \n                this.updateTable();\n                JOptionPane.showMessageDialog(this, \"Success!\\n\");\n            }\n        } catch (Exception e) {\n            JOptionPane.showMessageDialog(this, \"Error!\\n\"+e.getMessage());\n        }\n    }","cleancode":"private void addbuttonactionperformed(java.awt.event.actionevent evt) { try { try { clip.stop(); } catch(exception e) { } try { class.forname(\"oracle.jdbc.driver.oracledriver\"); } catch (classnotfoundexception ex) { logger.getlogger(adminview.class.getname()).log(level.severe, null, ex); } connection con=drivermanager.getconnection( \"jdbc:oracle:thin:@localhost:1521:newdatabase\",\"system\",\"not12345\"); statement stmt=con.createstatement(); resultset rs=stmt.executequery(\"select * from album\"); arraylist<string> albumlist = new arraylist<string>(); hashmap<string, string> albumid = new hashmap<>(); while(rs.next()) { albumlist.add((rs.getstring(2))); albumid.put(rs.getstring(2), rs.getstring(1)); } rs=stmt.executequery(\"select * from artist\"); arraylist<string> artistlist = new arraylist<string>(); hashmap<string, string> artistid = new hashmap<>(); while(rs.next()) { artistlist.add((rs.getstring(2))); artistid.put(rs.getstring(2), rs.getstring(1)); } con.close(); jtextfield name = new jtextfield(); jtextfield genre = new jtextfield(); jtextfield song_num = new jtextfield(); jcombobox<string> albums = new jcombobox<string>(albumlist.toarray(new string[0])); jlist artists = new jlist(artistlist.toarray(new string[0])); artists.setselectionmode( listselectionmodel.multiple_interval_selection); int[] select = {19, 20, 22}; object[] input = { \"name : \", name, \"genre :\", genre, \"artist :\", artists, \"song number in album :\", song_num, \"album :\", albums, }; int option = joptionpane.showconfirmdialog(this, input, \"enter song details\", joptionpane.ok_cancel_option); if(option == joptionpane.ok_option) { jfilechooser jfc = new jfilechooser(); int returnvalue = jfc.showopendialog(null); string filepath = null; if (returnvalue == jfilechooser.approve_option) { file selectedfile = jfc.getselectedfile(); system.out.println(selectedfile.getabsolutepath()); filepath = selectedfile.getabsolutepath(); } try{ file f=new file(filepath); class.forname(\"oracle.jdbc.driver.oracledriver\"); con = drivermanager.getconnection( \"jdbc:oracle:thin:@localhost:1521:newdatabase\",\"system\",\"not12345\"); preparedstatement ps = con.preparestatement (\"insert into song values(?, ?, ?, ?, ?, ?, ?)\"); ps.setstring(1, null); ps.setstring(2, name.gettext()); ps.setstring(3, albumid.get(albums.getselecteditem().tostring())); ps.setstring(4, genre.gettext()); ps.setint(5, 0); ps.setint(6, integer.parseint(song_num.gettext())); system.out.println(\"\"+f.length()); ps.setbytes(7, readfile(filepath)); ps.executeupdate(); ps.close(); preparedstatement ps1 = con.preparestatement (\"select id from song where name=? and album_id=?\"); ps1.setstring(1, name.gettext()); ps1.setstring(2, albumid.get(albums.getselecteditem().tostring())); resultset rs1=ps1.executequery(); string id = \"\"; while(rs1.next()) { id = rs1.getstring(1); } ps1.close(); for(object a:artists.getselectedvalueslist()) { ps = con.preparecall (\"{call addsongartist(?, ?)}\"); ps.setstring(1, id); ps.setstring(2, artistid.get(a.tostring())); ps.executeupdate(); ps.close(); } con.close(); } catch (exception e) {e.printstacktrace();} this.updatetable(); joptionpane.showmessagedialog(this, \"success!\\n\"); } } catch (exception e) { joptionpane.showmessagedialog(this, \"error!\\n\"+e.getmessage()); } }","repo":"shivamkumar78\/Music_Application","label":[0,1,0,0]}
{"id":26190,"original_code":"private void addArtistActionPerformed(java.awt.event.ActionEvent evt) {\/\/GEN-FIRST:event_addArtistActionPerformed\n        \/\/ TODO add your handling code here:\n        try {\n            \/\/ TODO add your handling code here:\n            searchText.setText(\"\");\n            try {\n                Class.forName(\"oracle.jdbc.driver.OracleDriver\");\n            } catch (ClassNotFoundException ex) {\n                Logger.getLogger(AdminView.class.getName()).log(Level.SEVERE, null, ex);\n            }\n            \/\/ TODO add your handling code here:\n\/\/            JTextField id = new JTextField();\n            JTextField name = new JTextField();\n            JTextField about = new JTextField();\n            Object[] input = {\n\/\/                \"Id : \", id,\n                \"Name : \", name,\n                \"About : \", about,\n            };\n            int option = JOptionPane.showConfirmDialog(this, input, \"Enter Artist details\", JOptionPane.OK_CANCEL_OPTION);\n            if(option == JOptionPane.OK_OPTION) {\n                 try{  \n                    Class.forName(\"oracle.jdbc.driver.OracleDriver\");  \n                     Connection con = DriverManager.getConnection(\n                             \"jdbc:oracle:thin:@localhost:1521:newdatabase\",\"system\",\"not12345\");\n                    CallableStatement ps = con.prepareCall (\"{call addartist(?, ?, ?)}\");\n                    ps.setString(1,null);  \n                    ps.setString(2, name.getText());\n                    ps.setString(3, about.getText());\n                    ps.executeUpdate();\n                    ps.close();\n                    con.close();  \n                } catch (Exception e) {e.printStackTrace();}  \n                JOptionPane.showMessageDialog(this, \"Success!\\n\");\n            }\n        } catch (Exception e) {\n            JOptionPane.showMessageDialog(this, \"Error!\\n\"+e.getMessage());\n        }\n    }","code_wo_comment":"private void addArtistActionPerformed(java.awt.event.ActionEvent evt) {       \n        try {\n           \n            searchText.setText(\"\");\n            try {\n                Class.forName(\"oracle.jdbc.driver.OracleDriver\");\n            } catch (ClassNotFoundException ex) {\n                Logger.getLogger(AdminView.class.getName()).log(Level.SEVERE, null, ex);\n            }\n           \n            JTextField name = new JTextField();\n            JTextField about = new JTextField();\n            Object[] input = {\n                \"Name : \", name,\n                \"About : \", about,\n            };\n            int option = JOptionPane.showConfirmDialog(this, input, \"Enter Artist details\", JOptionPane.OK_CANCEL_OPTION);\n            if(option == JOptionPane.OK_OPTION) {\n                 try{  \n                    Class.forName(\"oracle.jdbc.driver.OracleDriver\");  \n                     Connection con = DriverManager.getConnection(\n                             \"jdbc:oracle:thin:@localhost:1521:newdatabase\",\"system\",\"not12345\");\n                    CallableStatement ps = con.prepareCall (\"{call addartist(?, ?, ?)}\");\n                    ps.setString(1,null);  \n                    ps.setString(2, name.getText());\n                    ps.setString(3, about.getText());\n                    ps.executeUpdate();\n                    ps.close();\n                    con.close();  \n                } catch (Exception e) {e.printStackTrace();}  \n                JOptionPane.showMessageDialog(this, \"Success!\\n\");\n            }\n        } catch (Exception e) {\n            JOptionPane.showMessageDialog(this, \"Error!\\n\"+e.getMessage());\n        }\n    }","cleancode":"private void addartistactionperformed(java.awt.event.actionevent evt) { try { searchtext.settext(\"\"); try { class.forname(\"oracle.jdbc.driver.oracledriver\"); } catch (classnotfoundexception ex) { logger.getlogger(adminview.class.getname()).log(level.severe, null, ex); } jtextfield name = new jtextfield(); jtextfield about = new jtextfield(); object[] input = { \"name : \", name, \"about : \", about, }; int option = joptionpane.showconfirmdialog(this, input, \"enter artist details\", joptionpane.ok_cancel_option); if(option == joptionpane.ok_option) { try{ class.forname(\"oracle.jdbc.driver.oracledriver\"); connection con = drivermanager.getconnection( \"jdbc:oracle:thin:@localhost:1521:newdatabase\",\"system\",\"not12345\"); callablestatement ps = con.preparecall (\"{call addartist(?, ?, ?)}\"); ps.setstring(1,null); ps.setstring(2, name.gettext()); ps.setstring(3, about.gettext()); ps.executeupdate(); ps.close(); con.close(); } catch (exception e) {e.printstacktrace();} joptionpane.showmessagedialog(this, \"success!\\n\"); } } catch (exception e) { joptionpane.showmessagedialog(this, \"error!\\n\"+e.getmessage()); } }","repo":"shivamkumar78\/Music_Application","label":[0,1,0,0]}
{"id":26191,"original_code":"private void addAlbumActionPerformed(java.awt.event.ActionEvent evt) {\/\/GEN-FIRST:event_addAlbumActionPerformed\n        \/\/ TODO add your handling code here:\n        try {\n            \/\/ TODO add your handling code here:\n            try {\n                Class.forName(\"oracle.jdbc.driver.OracleDriver\");\n            } catch (ClassNotFoundException ex) {\n                Logger.getLogger(AdminView.class.getName()).log(Level.SEVERE, null, ex);\n            }\n            \/\/ TODO add your handling code here:\n\/\/            JTextField id = new JTextField();\n            JTextField name = new JTextField();\n            Object[] input = {\n\/\/                \"Id : \", id,\n                \"Name : \", name,\n            };\n            int option = JOptionPane.showConfirmDialog(this, input, \"Enter Album details\", JOptionPane.OK_CANCEL_OPTION);\n            if(option == JOptionPane.OK_OPTION) {\n                 try{  \n                    Class.forName(\"oracle.jdbc.driver.OracleDriver\");  \n                    Connection con = DriverManager.getConnection(\n                             \"jdbc:oracle:thin:@localhost:1521:newdatabase\",\"system\",\"not12345\");\n                    CallableStatement ps = con.prepareCall (\"{call addalbum(?, ?)}\");\n                    ps.setString(1, null);  \n                    ps.setString(2, name.getText());\n                    ps.executeUpdate();\n                    ps.close();\n                    con.close();  \n                } catch (Exception e) {e.printStackTrace();}  \n                JOptionPane.showMessageDialog(this, \"Success!\\n\");\n            }\n        } catch (Exception e) {\n            JOptionPane.showMessageDialog(this, \"Error!\\n\"+e.getMessage());\n        }\n    }","code_wo_comment":"private void addAlbumActionPerformed(java.awt.event.ActionEvent evt) {       \n        try {\n           \n            try {\n                Class.forName(\"oracle.jdbc.driver.OracleDriver\");\n            } catch (ClassNotFoundException ex) {\n                Logger.getLogger(AdminView.class.getName()).log(Level.SEVERE, null, ex);\n            }\n           \n            JTextField name = new JTextField();\n            Object[] input = {\n                \"Name : \", name,\n            };\n            int option = JOptionPane.showConfirmDialog(this, input, \"Enter Album details\", JOptionPane.OK_CANCEL_OPTION);\n            if(option == JOptionPane.OK_OPTION) {\n                 try{  \n                    Class.forName(\"oracle.jdbc.driver.OracleDriver\");  \n                    Connection con = DriverManager.getConnection(\n                             \"jdbc:oracle:thin:@localhost:1521:newdatabase\",\"system\",\"not12345\");\n                    CallableStatement ps = con.prepareCall (\"{call addalbum(?, ?)}\");\n                    ps.setString(1, null);  \n                    ps.setString(2, name.getText());\n                    ps.executeUpdate();\n                    ps.close();\n                    con.close();  \n                } catch (Exception e) {e.printStackTrace();}  \n                JOptionPane.showMessageDialog(this, \"Success!\\n\");\n            }\n        } catch (Exception e) {\n            JOptionPane.showMessageDialog(this, \"Error!\\n\"+e.getMessage());\n        }\n    }","cleancode":"private void addalbumactionperformed(java.awt.event.actionevent evt) { try { try { class.forname(\"oracle.jdbc.driver.oracledriver\"); } catch (classnotfoundexception ex) { logger.getlogger(adminview.class.getname()).log(level.severe, null, ex); } jtextfield name = new jtextfield(); object[] input = { \"name : \", name, }; int option = joptionpane.showconfirmdialog(this, input, \"enter album details\", joptionpane.ok_cancel_option); if(option == joptionpane.ok_option) { try{ class.forname(\"oracle.jdbc.driver.oracledriver\"); connection con = drivermanager.getconnection( \"jdbc:oracle:thin:@localhost:1521:newdatabase\",\"system\",\"not12345\"); callablestatement ps = con.preparecall (\"{call addalbum(?, ?)}\"); ps.setstring(1, null); ps.setstring(2, name.gettext()); ps.executeupdate(); ps.close(); con.close(); } catch (exception e) {e.printstacktrace();} joptionpane.showmessagedialog(this, \"success!\\n\"); } } catch (exception e) { joptionpane.showmessagedialog(this, \"error!\\n\"+e.getmessage()); } }","repo":"shivamkumar78\/Music_Application","label":[0,1,0,0]}
{"id":26243,"original_code":"public RunResult run(RunDecision runDecision) throws DetectUserFriendlyException, InterruptedException, IntegrationException {\n        \/\/TODO: Better way for run manager to get dependencies so he can be tested. (And better ways of creating his objects)\n        final DetectConfiguration detectConfiguration = detectContext.getBean(DetectConfiguration.class);\n        final DetectConfigurationFactory detectConfigurationFactory = detectContext.getBean(DetectConfigurationFactory.class);\n        final DirectoryManager directoryManager = detectContext.getBean(DirectoryManager.class);\n        final EventSystem eventSystem = detectContext.getBean(EventSystem.class);\n        final CodeLocationNameManager codeLocationNameManager = detectContext.getBean(CodeLocationNameManager.class);\n        final BdioCodeLocationCreator bdioCodeLocationCreator = detectContext.getBean(BdioCodeLocationCreator.class);\n        final ConnectionManager connectionManager = detectContext.getBean(ConnectionManager.class);\n        final DetectInfo detectInfo = detectContext.getBean(DetectInfo.class);\n        final RunResult runResult = new RunResult();\n        final RunOptions runOptions = detectConfigurationFactory.createRunOptions();\n        final DetectToolFilter detectToolFilter = runOptions.getDetectToolFilter();\n        if (runDecision.willRunBlackduck()) {\n            logger.info(\"Black Duck tools will run.\");\n            final ConnectivityManager connectivityManager = detectContext.getBean(ConnectivityManager.class);\n            if (connectivityManager.getPhoneHomeManager().isPresent()) {\n                connectivityManager.getPhoneHomeManager().get().startPhoneHome();\n            }\n            DetectorEnvironment detectorEnvironment = new DetectorEnvironment(directoryManager.getSourceDirectory(), Collections.emptySet(), 0, null, false);\n            DetectorFactory detectorFactory = detectContext.getBean(DetectorFactory.class);\n            logger.info(ReportConstants.RUN_SEPARATOR);\n            if (detectToolFilter.shouldInclude(DetectTool.DOCKER)) {\n                logger.info(\"Will include the docker tool.\");\n                ToolRunner toolRunner = new ToolRunner(eventSystem, detectorFactory.createDockerDetector(detectorEnvironment));\n                toolRunner.run(runResult);\n                logger.info(\"Docker actions finished.\");\n            } else {\n                logger.info(\"Docker tool will not be run.\");\n            }\n            logger.info(ReportConstants.RUN_SEPARATOR);\n            if (detectToolFilter.shouldInclude(DetectTool.BAZEL)) {\n                logger.info(\"Will include the bazel tool.\");\n                ToolRunner toolRunner = new ToolRunner(eventSystem, detectorFactory.createBazelDetector(detectorEnvironment));\n                toolRunner.run(runResult);\n                logger.info(\"Bazel actions finished.\");\n            } else {\n                logger.info(\"Bazel tool will not be run.\");\n            }\n            logger.info(ReportConstants.RUN_SEPARATOR);\n            if (detectToolFilter.shouldInclude(DetectTool.DETECTOR)) {\n                logger.info(\"Will include the detector tool.\");\n                final String projectBomTool = detectConfiguration.getProperty(DetectProperty.DETECT_PROJECT_DETECTOR, PropertyAuthority.None);\n                final SearchOptions searchOptions = detectConfigurationFactory.createSearchOptions(directoryManager.getSourceDirectory());\n                final DetectorTool detectorTool = new DetectorTool(detectContext);\n                final DetectorToolResult detectorToolResult = detectorTool.performDetectors(searchOptions, projectBomTool);\n                runResult.addToolNameVersionIfPresent(DetectTool.DETECTOR, detectorToolResult.bomToolProjectNameVersion);\n                runResult.addDetectCodeLocations(detectorToolResult.bomToolCodeLocations);\n                runResult.addApplicableDetectors(detectorToolResult.applicableDetectorTypes);\n                if (detectorToolResult.failedDetectorTypes.size() > 0) {\n                    eventSystem.publishEvent(Event.ExitCode, new ExitCodeRequest(ExitCodeType.FAILURE_DETECTOR, \"A detector failed.\"));\n                }\n                logger.info(\"Detector actions finished.\");\n            } else {\n                logger.info(\"Detector tool will not be run.\");\n            }\n            logger.info(ReportConstants.RUN_SEPARATOR);\n            logger.info(\"Completed code location tools.\");\n            logger.info(\"Determining project info.\");\n            final ProjectNameVersionOptions projectNameVersionOptions = detectConfigurationFactory.createProjectNameVersionOptions(directoryManager.getSourceDirectory().getName());\n            final ProjectNameVersionDecider projectNameVersionDecider = new ProjectNameVersionDecider(projectNameVersionOptions);\n            final NameVersion projectNameVersion = projectNameVersionDecider.decideProjectNameVersion(runOptions.getPreferredTools(), runResult.getDetectToolProjectInfo());\n            logger.info(\"Project name: \" + projectNameVersion.getName());\n            logger.info(\"Project version: \" + projectNameVersion.getVersion());\n            Optional<ProjectVersionWrapper> projectVersionWrapper = Optional.empty();\n            if (connectivityManager.isDetectOnline() && connectivityManager.getBlackDuckServicesFactory().isPresent()) {\n                final BlackDuckServicesFactory blackDuckServicesFactory = connectivityManager.getBlackDuckServicesFactory().get();\n                logger.info(\"Getting or creating project.\");\n                final DetectProjectServiceOptions options = detectConfigurationFactory.createDetectProjectServiceOptions();\n                final DetectProjectMappingService detectProjectMappingService = new DetectProjectMappingService(blackDuckServicesFactory.createBlackDuckService());\n                final DetectProjectService detectProjectService = new DetectProjectService(blackDuckServicesFactory, options, detectProjectMappingService);\n                projectVersionWrapper = Optional.of(detectProjectService.createOrUpdateHubProject(projectNameVersion, options.getApplicationId()));\n                if (projectVersionWrapper.isPresent() && runOptions.shouldUnmapCodeLocations()) {\n                    logger.info(\"Unmapping code locations.\");\n                    final DetectCodeLocationUnmapService detectCodeLocationUnmapService = new DetectCodeLocationUnmapService(blackDuckServicesFactory.createBlackDuckService(), blackDuckServicesFactory.createCodeLocationService());\n                    detectCodeLocationUnmapService.unmapCodeLocations(projectVersionWrapper.get().getProjectVersionView());\n                } else {\n                    logger.debug(\"Will not unmap code locations: Project view was not present, or should not unmap code locations.\");\n                }\n            } else {\n                logger.debug(\"Detect is not online, and will not create the project.\");\n            }\n            logger.info(\"Completed project and version actions.\");\n            logger.info(\"Processing Detect Code Locations.\");\n            final CodeLocationWaitData codeLocationWaitData = new CodeLocationWaitData();\n            final BdioManager bdioManager = new BdioManager(detectInfo, new SimpleBdioFactory(), new IntegrationEscapeUtil(), codeLocationNameManager, detectConfiguration, bdioCodeLocationCreator, directoryManager, eventSystem);\n            final BdioResult bdioResult = bdioManager.createBdioFiles(runOptions.getAggregateName(), projectNameVersion, runResult.getDetectCodeLocations());\n            if (bdioResult.getUploadTargets().size() > 0) {\n                logger.info(\"Created \" + bdioResult.getUploadTargets().size() + \" BDIO files.\");\n                bdioResult.getUploadTargets().forEach(it -> eventSystem.publishEvent(Event.OutputFileOfInterest, it.getUploadFile()));\n                if (connectivityManager.isDetectOnline() && connectivityManager.getBlackDuckServicesFactory().isPresent()) {\n                    logger.info(\"Uploading BDIO files.\");\n                    final BlackDuckServicesFactory blackDuckServicesFactory = connectivityManager.getBlackDuckServicesFactory().get();\n                    final DetectBdioUploadService detectBdioUploadService = new DetectBdioUploadService(detectConfiguration, blackDuckServicesFactory.createBdioUploadService(), eventSystem);\n                    final CodeLocationCreationData<UploadBatchOutput> uploadBatchOutputCodeLocationCreationData = detectBdioUploadService.uploadBdioFiles(bdioResult.getUploadTargets());\n                    codeLocationWaitData.setFromBdioCodeLocationCreationData(uploadBatchOutputCodeLocationCreationData);\n                }\n            } else {\n                logger.debug(\"Did not create any BDIO files.\");\n            }\n            logger.info(\"Completed Detect Code Location processing.\");\n            logger.info(ReportConstants.RUN_SEPARATOR);\n            if (detectToolFilter.shouldInclude(DetectTool.SIGNATURE_SCAN)) {\n                logger.info(\"Will include the signature scanner tool.\");\n                final BlackDuckSignatureScannerOptions blackDuckSignatureScannerOptions = detectConfigurationFactory.createBlackDuckSignatureScannerOptions();\n                final BlackDuckSignatureScannerTool blackDuckSignatureScannerTool = new BlackDuckSignatureScannerTool(blackDuckSignatureScannerOptions, detectContext);\n                final SignatureScannerToolResult signatureScannerToolResult = blackDuckSignatureScannerTool.runScanTool(projectNameVersion, runResult.getDockerTar());\n                if (signatureScannerToolResult.getResult() == Result.SUCCESS && signatureScannerToolResult.getCreationData().isPresent()) {\n                    codeLocationWaitData.setFromSignatureScannerCodeLocationCreationData(signatureScannerToolResult.getCreationData().get());\n                }\n                logger.info(\"Signature scanner actions finished.\");\n            } else {\n                logger.info(\"Signature scan tool will not be run.\");\n            }\n            logger.info(ReportConstants.RUN_SEPARATOR);\n            if (detectToolFilter.shouldInclude(DetectTool.BINARY_SCAN)) {\n                logger.info(\"Will include the binary scanner tool.\");\n                if (connectivityManager.isDetectOnline() && connectivityManager.getBlackDuckServicesFactory().isPresent()) {\n                    final BlackDuckServicesFactory blackDuckServicesFactory = connectivityManager.getBlackDuckServicesFactory().get();\n                    final BlackDuckBinaryScannerTool blackDuckBinaryScanner = new BlackDuckBinaryScannerTool(eventSystem, codeLocationNameManager, detectConfiguration, blackDuckServicesFactory);\n                    BinaryScanToolResult result = blackDuckBinaryScanner.performBinaryScanActions(projectNameVersion);\n                    if (result.isSuccessful()) {\n                        codeLocationWaitData.setFromBinaryScan(result.getNotificationTaskRange(), result.getCodeLocationNames());\n                    }\n                }\n                logger.info(\"Binary scanner actions finished.\");\n            } else {\n                logger.info(\"Binary scan tool will not be run.\");\n            }\n            logger.info(ReportConstants.RUN_SEPARATOR);\n            if (projectVersionWrapper.isPresent() && connectivityManager.isDetectOnline() && connectivityManager.getBlackDuckServicesFactory().isPresent()) {\n                final BlackDuckServicesFactory blackDuckServicesFactory = connectivityManager.getBlackDuckServicesFactory().get();\n                logger.info(\"Will perform Black Duck post actions.\");\n                final BlackduckReportOptions blackduckReportOptions = detectConfigurationFactory.createReportOptions();\n                final PolicyCheckOptions policyCheckOptions = detectConfigurationFactory.createPolicyCheckOptions();\n                final long timeoutInSeconds = detectConfigurationFactory.getTimeoutInSeconds();\n                final BlackduckPostActions blackduckPostActions = new BlackduckPostActions(blackDuckServicesFactory, eventSystem);\n                blackduckPostActions.perform(blackduckReportOptions, policyCheckOptions, codeLocationWaitData, projectVersionWrapper.get(), timeoutInSeconds);\n                final boolean hasAtLeastOneBdio = !bdioResult.getUploadTargets().isEmpty();\n                final boolean shouldHaveScanned = detectToolFilter.shouldInclude(DetectTool.SIGNATURE_SCAN);\n                if (hasAtLeastOneBdio || shouldHaveScanned) {\n                    final Optional<String> componentsLink = projectVersionWrapper.get().getProjectVersionView().getFirstLink(ProjectVersionView.COMPONENTS_LINK);\n                    if (componentsLink.isPresent()) {\n                        logger.info(String.format(\"To see your results, follow the URL: %s\", componentsLink.get()));\n                    }\n                }\n                logger.info(\"Black Duck actions have finished.\");\n            } else {\n                logger.debug(\"Will not perform post actions: Detect is not online.\");\n            }\n        } else {\n            logger.info(\"Black Duck tools will NOT be run.\");\n        }\n        if (runDecision.willRunPolaris()) {\n            logger.info(ReportConstants.RUN_SEPARATOR);\n            if (detectToolFilter.shouldInclude(DetectTool.POLARIS)) {\n                logger.info(\"Will include the Polaris tool.\");\n                final PolarisTool polarisTool = new PolarisTool(eventSystem, directoryManager, new ExecutableRunner(), connectionManager, detectConfiguration);\n                polarisTool.runPolaris(new Slf4jIntLogger(logger), directoryManager.getSourceDirectory());\n                logger.info(\"Polaris actions finished.\");\n            } else {\n                logger.info(\"Polaris CLI tool will not be run.\");\n            }\n        } else {\n            logger.info(\"Polaris tools will NOT be run.\");\n        }\n        logger.info(\"All tools have finished.\");\n        logger.info(ReportConstants.RUN_SEPARATOR);\n        return runResult;\n    }","code_wo_comment":"public RunResult run(RunDecision runDecision) throws DetectUserFriendlyException, InterruptedException, IntegrationException {\n       \n        final DetectConfiguration detectConfiguration = detectContext.getBean(DetectConfiguration.class);\n        final DetectConfigurationFactory detectConfigurationFactory = detectContext.getBean(DetectConfigurationFactory.class);\n        final DirectoryManager directoryManager = detectContext.getBean(DirectoryManager.class);\n        final EventSystem eventSystem = detectContext.getBean(EventSystem.class);\n        final CodeLocationNameManager codeLocationNameManager = detectContext.getBean(CodeLocationNameManager.class);\n        final BdioCodeLocationCreator bdioCodeLocationCreator = detectContext.getBean(BdioCodeLocationCreator.class);\n        final ConnectionManager connectionManager = detectContext.getBean(ConnectionManager.class);\n        final DetectInfo detectInfo = detectContext.getBean(DetectInfo.class);\n        final RunResult runResult = new RunResult();\n        final RunOptions runOptions = detectConfigurationFactory.createRunOptions();\n        final DetectToolFilter detectToolFilter = runOptions.getDetectToolFilter();\n        if (runDecision.willRunBlackduck()) {\n            logger.info(\"Black Duck tools will run.\");\n            final ConnectivityManager connectivityManager = detectContext.getBean(ConnectivityManager.class);\n            if (connectivityManager.getPhoneHomeManager().isPresent()) {\n                connectivityManager.getPhoneHomeManager().get().startPhoneHome();\n            }\n            DetectorEnvironment detectorEnvironment = new DetectorEnvironment(directoryManager.getSourceDirectory(), Collections.emptySet(), 0, null, false);\n            DetectorFactory detectorFactory = detectContext.getBean(DetectorFactory.class);\n            logger.info(ReportConstants.RUN_SEPARATOR);\n            if (detectToolFilter.shouldInclude(DetectTool.DOCKER)) {\n                logger.info(\"Will include the docker tool.\");\n                ToolRunner toolRunner = new ToolRunner(eventSystem, detectorFactory.createDockerDetector(detectorEnvironment));\n                toolRunner.run(runResult);\n                logger.info(\"Docker actions finished.\");\n            } else {\n                logger.info(\"Docker tool will not be run.\");\n            }\n            logger.info(ReportConstants.RUN_SEPARATOR);\n            if (detectToolFilter.shouldInclude(DetectTool.BAZEL)) {\n                logger.info(\"Will include the bazel tool.\");\n                ToolRunner toolRunner = new ToolRunner(eventSystem, detectorFactory.createBazelDetector(detectorEnvironment));\n                toolRunner.run(runResult);\n                logger.info(\"Bazel actions finished.\");\n            } else {\n                logger.info(\"Bazel tool will not be run.\");\n            }\n            logger.info(ReportConstants.RUN_SEPARATOR);\n            if (detectToolFilter.shouldInclude(DetectTool.DETECTOR)) {\n                logger.info(\"Will include the detector tool.\");\n                final String projectBomTool = detectConfiguration.getProperty(DetectProperty.DETECT_PROJECT_DETECTOR, PropertyAuthority.None);\n                final SearchOptions searchOptions = detectConfigurationFactory.createSearchOptions(directoryManager.getSourceDirectory());\n                final DetectorTool detectorTool = new DetectorTool(detectContext);\n                final DetectorToolResult detectorToolResult = detectorTool.performDetectors(searchOptions, projectBomTool);\n                runResult.addToolNameVersionIfPresent(DetectTool.DETECTOR, detectorToolResult.bomToolProjectNameVersion);\n                runResult.addDetectCodeLocations(detectorToolResult.bomToolCodeLocations);\n                runResult.addApplicableDetectors(detectorToolResult.applicableDetectorTypes);\n                if (detectorToolResult.failedDetectorTypes.size() > 0) {\n                    eventSystem.publishEvent(Event.ExitCode, new ExitCodeRequest(ExitCodeType.FAILURE_DETECTOR, \"A detector failed.\"));\n                }\n                logger.info(\"Detector actions finished.\");\n            } else {\n                logger.info(\"Detector tool will not be run.\");\n            }\n            logger.info(ReportConstants.RUN_SEPARATOR);\n            logger.info(\"Completed code location tools.\");\n            logger.info(\"Determining project info.\");\n            final ProjectNameVersionOptions projectNameVersionOptions = detectConfigurationFactory.createProjectNameVersionOptions(directoryManager.getSourceDirectory().getName());\n            final ProjectNameVersionDecider projectNameVersionDecider = new ProjectNameVersionDecider(projectNameVersionOptions);\n            final NameVersion projectNameVersion = projectNameVersionDecider.decideProjectNameVersion(runOptions.getPreferredTools(), runResult.getDetectToolProjectInfo());\n            logger.info(\"Project name: \" + projectNameVersion.getName());\n            logger.info(\"Project version: \" + projectNameVersion.getVersion());\n            Optional<ProjectVersionWrapper> projectVersionWrapper = Optional.empty();\n            if (connectivityManager.isDetectOnline() && connectivityManager.getBlackDuckServicesFactory().isPresent()) {\n                final BlackDuckServicesFactory blackDuckServicesFactory = connectivityManager.getBlackDuckServicesFactory().get();\n                logger.info(\"Getting or creating project.\");\n                final DetectProjectServiceOptions options = detectConfigurationFactory.createDetectProjectServiceOptions();\n                final DetectProjectMappingService detectProjectMappingService = new DetectProjectMappingService(blackDuckServicesFactory.createBlackDuckService());\n                final DetectProjectService detectProjectService = new DetectProjectService(blackDuckServicesFactory, options, detectProjectMappingService);\n                projectVersionWrapper = Optional.of(detectProjectService.createOrUpdateHubProject(projectNameVersion, options.getApplicationId()));\n                if (projectVersionWrapper.isPresent() && runOptions.shouldUnmapCodeLocations()) {\n                    logger.info(\"Unmapping code locations.\");\n                    final DetectCodeLocationUnmapService detectCodeLocationUnmapService = new DetectCodeLocationUnmapService(blackDuckServicesFactory.createBlackDuckService(), blackDuckServicesFactory.createCodeLocationService());\n                    detectCodeLocationUnmapService.unmapCodeLocations(projectVersionWrapper.get().getProjectVersionView());\n                } else {\n                    logger.debug(\"Will not unmap code locations: Project view was not present, or should not unmap code locations.\");\n                }\n            } else {\n                logger.debug(\"Detect is not online, and will not create the project.\");\n            }\n            logger.info(\"Completed project and version actions.\");\n            logger.info(\"Processing Detect Code Locations.\");\n            final CodeLocationWaitData codeLocationWaitData = new CodeLocationWaitData();\n            final BdioManager bdioManager = new BdioManager(detectInfo, new SimpleBdioFactory(), new IntegrationEscapeUtil(), codeLocationNameManager, detectConfiguration, bdioCodeLocationCreator, directoryManager, eventSystem);\n            final BdioResult bdioResult = bdioManager.createBdioFiles(runOptions.getAggregateName(), projectNameVersion, runResult.getDetectCodeLocations());\n            if (bdioResult.getUploadTargets().size() > 0) {\n                logger.info(\"Created \" + bdioResult.getUploadTargets().size() + \" BDIO files.\");\n                bdioResult.getUploadTargets().forEach(it -> eventSystem.publishEvent(Event.OutputFileOfInterest, it.getUploadFile()));\n                if (connectivityManager.isDetectOnline() && connectivityManager.getBlackDuckServicesFactory().isPresent()) {\n                    logger.info(\"Uploading BDIO files.\");\n                    final BlackDuckServicesFactory blackDuckServicesFactory = connectivityManager.getBlackDuckServicesFactory().get();\n                    final DetectBdioUploadService detectBdioUploadService = new DetectBdioUploadService(detectConfiguration, blackDuckServicesFactory.createBdioUploadService(), eventSystem);\n                    final CodeLocationCreationData<UploadBatchOutput> uploadBatchOutputCodeLocationCreationData = detectBdioUploadService.uploadBdioFiles(bdioResult.getUploadTargets());\n                    codeLocationWaitData.setFromBdioCodeLocationCreationData(uploadBatchOutputCodeLocationCreationData);\n                }\n            } else {\n                logger.debug(\"Did not create any BDIO files.\");\n            }\n            logger.info(\"Completed Detect Code Location processing.\");\n            logger.info(ReportConstants.RUN_SEPARATOR);\n            if (detectToolFilter.shouldInclude(DetectTool.SIGNATURE_SCAN)) {\n                logger.info(\"Will include the signature scanner tool.\");\n                final BlackDuckSignatureScannerOptions blackDuckSignatureScannerOptions = detectConfigurationFactory.createBlackDuckSignatureScannerOptions();\n                final BlackDuckSignatureScannerTool blackDuckSignatureScannerTool = new BlackDuckSignatureScannerTool(blackDuckSignatureScannerOptions, detectContext);\n                final SignatureScannerToolResult signatureScannerToolResult = blackDuckSignatureScannerTool.runScanTool(projectNameVersion, runResult.getDockerTar());\n                if (signatureScannerToolResult.getResult() == Result.SUCCESS && signatureScannerToolResult.getCreationData().isPresent()) {\n                    codeLocationWaitData.setFromSignatureScannerCodeLocationCreationData(signatureScannerToolResult.getCreationData().get());\n                }\n                logger.info(\"Signature scanner actions finished.\");\n            } else {\n                logger.info(\"Signature scan tool will not be run.\");\n            }\n            logger.info(ReportConstants.RUN_SEPARATOR);\n            if (detectToolFilter.shouldInclude(DetectTool.BINARY_SCAN)) {\n                logger.info(\"Will include the binary scanner tool.\");\n                if (connectivityManager.isDetectOnline() && connectivityManager.getBlackDuckServicesFactory().isPresent()) {\n                    final BlackDuckServicesFactory blackDuckServicesFactory = connectivityManager.getBlackDuckServicesFactory().get();\n                    final BlackDuckBinaryScannerTool blackDuckBinaryScanner = new BlackDuckBinaryScannerTool(eventSystem, codeLocationNameManager, detectConfiguration, blackDuckServicesFactory);\n                    BinaryScanToolResult result = blackDuckBinaryScanner.performBinaryScanActions(projectNameVersion);\n                    if (result.isSuccessful()) {\n                        codeLocationWaitData.setFromBinaryScan(result.getNotificationTaskRange(), result.getCodeLocationNames());\n                    }\n                }\n                logger.info(\"Binary scanner actions finished.\");\n            } else {\n                logger.info(\"Binary scan tool will not be run.\");\n            }\n            logger.info(ReportConstants.RUN_SEPARATOR);\n            if (projectVersionWrapper.isPresent() && connectivityManager.isDetectOnline() && connectivityManager.getBlackDuckServicesFactory().isPresent()) {\n                final BlackDuckServicesFactory blackDuckServicesFactory = connectivityManager.getBlackDuckServicesFactory().get();\n                logger.info(\"Will perform Black Duck post actions.\");\n                final BlackduckReportOptions blackduckReportOptions = detectConfigurationFactory.createReportOptions();\n                final PolicyCheckOptions policyCheckOptions = detectConfigurationFactory.createPolicyCheckOptions();\n                final long timeoutInSeconds = detectConfigurationFactory.getTimeoutInSeconds();\n                final BlackduckPostActions blackduckPostActions = new BlackduckPostActions(blackDuckServicesFactory, eventSystem);\n                blackduckPostActions.perform(blackduckReportOptions, policyCheckOptions, codeLocationWaitData, projectVersionWrapper.get(), timeoutInSeconds);\n                final boolean hasAtLeastOneBdio = !bdioResult.getUploadTargets().isEmpty();\n                final boolean shouldHaveScanned = detectToolFilter.shouldInclude(DetectTool.SIGNATURE_SCAN);\n                if (hasAtLeastOneBdio || shouldHaveScanned) {\n                    final Optional<String> componentsLink = projectVersionWrapper.get().getProjectVersionView().getFirstLink(ProjectVersionView.COMPONENTS_LINK);\n                    if (componentsLink.isPresent()) {\n                        logger.info(String.format(\"To see your results, follow the URL: %s\", componentsLink.get()));\n                    }\n                }\n                logger.info(\"Black Duck actions have finished.\");\n            } else {\n                logger.debug(\"Will not perform post actions: Detect is not online.\");\n            }\n        } else {\n            logger.info(\"Black Duck tools will NOT be run.\");\n        }\n        if (runDecision.willRunPolaris()) {\n            logger.info(ReportConstants.RUN_SEPARATOR);\n            if (detectToolFilter.shouldInclude(DetectTool.POLARIS)) {\n                logger.info(\"Will include the Polaris tool.\");\n                final PolarisTool polarisTool = new PolarisTool(eventSystem, directoryManager, new ExecutableRunner(), connectionManager, detectConfiguration);\n                polarisTool.runPolaris(new Slf4jIntLogger(logger), directoryManager.getSourceDirectory());\n                logger.info(\"Polaris actions finished.\");\n            } else {\n                logger.info(\"Polaris CLI tool will not be run.\");\n            }\n        } else {\n            logger.info(\"Polaris tools will NOT be run.\");\n        }\n        logger.info(\"All tools have finished.\");\n        logger.info(ReportConstants.RUN_SEPARATOR);\n        return runResult;\n    }","cleancode":"public runresult run(rundecision rundecision) throws detectuserfriendlyexception, interruptedexception, integrationexception { final detectconfiguration detectconfiguration = detectcontext.getbean(detectconfiguration.class); final detectconfigurationfactory detectconfigurationfactory = detectcontext.getbean(detectconfigurationfactory.class); final directorymanager directorymanager = detectcontext.getbean(directorymanager.class); final eventsystem eventsystem = detectcontext.getbean(eventsystem.class); final codelocationnamemanager codelocationnamemanager = detectcontext.getbean(codelocationnamemanager.class); final bdiocodelocationcreator bdiocodelocationcreator = detectcontext.getbean(bdiocodelocationcreator.class); final connectionmanager connectionmanager = detectcontext.getbean(connectionmanager.class); final detectinfo detectinfo = detectcontext.getbean(detectinfo.class); final runresult runresult = new runresult(); final runoptions runoptions = detectconfigurationfactory.createrunoptions(); final detecttoolfilter detecttoolfilter = runoptions.getdetecttoolfilter(); if (rundecision.willrunblackduck()) { logger.info(\"black duck tools will run.\"); final connectivitymanager connectivitymanager = detectcontext.getbean(connectivitymanager.class); if (connectivitymanager.getphonehomemanager().ispresent()) { connectivitymanager.getphonehomemanager().get().startphonehome(); } detectorenvironment detectorenvironment = new detectorenvironment(directorymanager.getsourcedirectory(), collections.emptyset(), 0, null, false); detectorfactory detectorfactory = detectcontext.getbean(detectorfactory.class); logger.info(reportconstants.run_separator); if (detecttoolfilter.shouldinclude(detecttool.docker)) { logger.info(\"will include the docker tool.\"); toolrunner toolrunner = new toolrunner(eventsystem, detectorfactory.createdockerdetector(detectorenvironment)); toolrunner.run(runresult); logger.info(\"docker actions finished.\"); } else { logger.info(\"docker tool will not be run.\"); } logger.info(reportconstants.run_separator); if (detecttoolfilter.shouldinclude(detecttool.bazel)) { logger.info(\"will include the bazel tool.\"); toolrunner toolrunner = new toolrunner(eventsystem, detectorfactory.createbazeldetector(detectorenvironment)); toolrunner.run(runresult); logger.info(\"bazel actions finished.\"); } else { logger.info(\"bazel tool will not be run.\"); } logger.info(reportconstants.run_separator); if (detecttoolfilter.shouldinclude(detecttool.detector)) { logger.info(\"will include the detector tool.\"); final string projectbomtool = detectconfiguration.getproperty(detectproperty.detect_project_detector, propertyauthority.none); final searchoptions searchoptions = detectconfigurationfactory.createsearchoptions(directorymanager.getsourcedirectory()); final detectortool detectortool = new detectortool(detectcontext); final detectortoolresult detectortoolresult = detectortool.performdetectors(searchoptions, projectbomtool); runresult.addtoolnameversionifpresent(detecttool.detector, detectortoolresult.bomtoolprojectnameversion); runresult.adddetectcodelocations(detectortoolresult.bomtoolcodelocations); runresult.addapplicabledetectors(detectortoolresult.applicabledetectortypes); if (detectortoolresult.faileddetectortypes.size() > 0) { eventsystem.publishevent(event.exitcode, new exitcoderequest(exitcodetype.failure_detector, \"a detector failed.\")); } logger.info(\"detector actions finished.\"); } else { logger.info(\"detector tool will not be run.\"); } logger.info(reportconstants.run_separator); logger.info(\"completed code location tools.\"); logger.info(\"determining project info.\"); final projectnameversionoptions projectnameversionoptions = detectconfigurationfactory.createprojectnameversionoptions(directorymanager.getsourcedirectory().getname()); final projectnameversiondecider projectnameversiondecider = new projectnameversiondecider(projectnameversionoptions); final nameversion projectnameversion = projectnameversiondecider.decideprojectnameversion(runoptions.getpreferredtools(), runresult.getdetecttoolprojectinfo()); logger.info(\"project name: \" + projectnameversion.getname()); logger.info(\"project version: \" + projectnameversion.getversion()); optional<projectversionwrapper> projectversionwrapper = optional.empty(); if (connectivitymanager.isdetectonline() && connectivitymanager.getblackduckservicesfactory().ispresent()) { final blackduckservicesfactory blackduckservicesfactory = connectivitymanager.getblackduckservicesfactory().get(); logger.info(\"getting or creating project.\"); final detectprojectserviceoptions options = detectconfigurationfactory.createdetectprojectserviceoptions(); final detectprojectmappingservice detectprojectmappingservice = new detectprojectmappingservice(blackduckservicesfactory.createblackduckservice()); final detectprojectservice detectprojectservice = new detectprojectservice(blackduckservicesfactory, options, detectprojectmappingservice); projectversionwrapper = optional.of(detectprojectservice.createorupdatehubproject(projectnameversion, options.getapplicationid())); if (projectversionwrapper.ispresent() && runoptions.shouldunmapcodelocations()) { logger.info(\"unmapping code locations.\"); final detectcodelocationunmapservice detectcodelocationunmapservice = new detectcodelocationunmapservice(blackduckservicesfactory.createblackduckservice(), blackduckservicesfactory.createcodelocationservice()); detectcodelocationunmapservice.unmapcodelocations(projectversionwrapper.get().getprojectversionview()); } else { logger.debug(\"will not unmap code locations: project view was not present, or should not unmap code locations.\"); } } else { logger.debug(\"detect is not online, and will not create the project.\"); } logger.info(\"completed project and version actions.\"); logger.info(\"processing detect code locations.\"); final codelocationwaitdata codelocationwaitdata = new codelocationwaitdata(); final bdiomanager bdiomanager = new bdiomanager(detectinfo, new simplebdiofactory(), new integrationescapeutil(), codelocationnamemanager, detectconfiguration, bdiocodelocationcreator, directorymanager, eventsystem); final bdioresult bdioresult = bdiomanager.createbdiofiles(runoptions.getaggregatename(), projectnameversion, runresult.getdetectcodelocations()); if (bdioresult.getuploadtargets().size() > 0) { logger.info(\"created \" + bdioresult.getuploadtargets().size() + \" bdio files.\"); bdioresult.getuploadtargets().foreach(it -> eventsystem.publishevent(event.outputfileofinterest, it.getuploadfile())); if (connectivitymanager.isdetectonline() && connectivitymanager.getblackduckservicesfactory().ispresent()) { logger.info(\"uploading bdio files.\"); final blackduckservicesfactory blackduckservicesfactory = connectivitymanager.getblackduckservicesfactory().get(); final detectbdiouploadservice detectbdiouploadservice = new detectbdiouploadservice(detectconfiguration, blackduckservicesfactory.createbdiouploadservice(), eventsystem); final codelocationcreationdata<uploadbatchoutput> uploadbatchoutputcodelocationcreationdata = detectbdiouploadservice.uploadbdiofiles(bdioresult.getuploadtargets()); codelocationwaitdata.setfrombdiocodelocationcreationdata(uploadbatchoutputcodelocationcreationdata); } } else { logger.debug(\"did not create any bdio files.\"); } logger.info(\"completed detect code location processing.\"); logger.info(reportconstants.run_separator); if (detecttoolfilter.shouldinclude(detecttool.signature_scan)) { logger.info(\"will include the signature scanner tool.\"); final blackducksignaturescanneroptions blackducksignaturescanneroptions = detectconfigurationfactory.createblackducksignaturescanneroptions(); final blackducksignaturescannertool blackducksignaturescannertool = new blackducksignaturescannertool(blackducksignaturescanneroptions, detectcontext); final signaturescannertoolresult signaturescannertoolresult = blackducksignaturescannertool.runscantool(projectnameversion, runresult.getdockertar()); if (signaturescannertoolresult.getresult() == result.success && signaturescannertoolresult.getcreationdata().ispresent()) { codelocationwaitdata.setfromsignaturescannercodelocationcreationdata(signaturescannertoolresult.getcreationdata().get()); } logger.info(\"signature scanner actions finished.\"); } else { logger.info(\"signature scan tool will not be run.\"); } logger.info(reportconstants.run_separator); if (detecttoolfilter.shouldinclude(detecttool.binary_scan)) { logger.info(\"will include the binary scanner tool.\"); if (connectivitymanager.isdetectonline() && connectivitymanager.getblackduckservicesfactory().ispresent()) { final blackduckservicesfactory blackduckservicesfactory = connectivitymanager.getblackduckservicesfactory().get(); final blackduckbinaryscannertool blackduckbinaryscanner = new blackduckbinaryscannertool(eventsystem, codelocationnamemanager, detectconfiguration, blackduckservicesfactory); binaryscantoolresult result = blackduckbinaryscanner.performbinaryscanactions(projectnameversion); if (result.issuccessful()) { codelocationwaitdata.setfrombinaryscan(result.getnotificationtaskrange(), result.getcodelocationnames()); } } logger.info(\"binary scanner actions finished.\"); } else { logger.info(\"binary scan tool will not be run.\"); } logger.info(reportconstants.run_separator); if (projectversionwrapper.ispresent() && connectivitymanager.isdetectonline() && connectivitymanager.getblackduckservicesfactory().ispresent()) { final blackduckservicesfactory blackduckservicesfactory = connectivitymanager.getblackduckservicesfactory().get(); logger.info(\"will perform black duck post actions.\"); final blackduckreportoptions blackduckreportoptions = detectconfigurationfactory.createreportoptions(); final policycheckoptions policycheckoptions = detectconfigurationfactory.createpolicycheckoptions(); final long timeoutinseconds = detectconfigurationfactory.gettimeoutinseconds(); final blackduckpostactions blackduckpostactions = new blackduckpostactions(blackduckservicesfactory, eventsystem); blackduckpostactions.perform(blackduckreportoptions, policycheckoptions, codelocationwaitdata, projectversionwrapper.get(), timeoutinseconds); final boolean hasatleastonebdio = !bdioresult.getuploadtargets().isempty(); final boolean shouldhavescanned = detecttoolfilter.shouldinclude(detecttool.signature_scan); if (hasatleastonebdio || shouldhavescanned) { final optional<string> componentslink = projectversionwrapper.get().getprojectversionview().getfirstlink(projectversionview.components_link); if (componentslink.ispresent()) { logger.info(string.format(\"to see your results, follow the url: %s\", componentslink.get())); } } logger.info(\"black duck actions have finished.\"); } else { logger.debug(\"will not perform post actions: detect is not online.\"); } } else { logger.info(\"black duck tools will not be run.\"); } if (rundecision.willrunpolaris()) { logger.info(reportconstants.run_separator); if (detecttoolfilter.shouldinclude(detecttool.polaris)) { logger.info(\"will include the polaris tool.\"); final polaristool polaristool = new polaristool(eventsystem, directorymanager, new executablerunner(), connectionmanager, detectconfiguration); polaristool.runpolaris(new slf4jintlogger(logger), directorymanager.getsourcedirectory()); logger.info(\"polaris actions finished.\"); } else { logger.info(\"polaris cli tool will not be run.\"); } } else { logger.info(\"polaris tools will not be run.\"); } logger.info(\"all tools have finished.\"); logger.info(reportconstants.run_separator); return runresult; }","repo":"selaliadobor-wt\/synopsys-detect","label":[1,0,0,0]}
{"id":18139,"original_code":"public float getBending_damping() throws IOException\n\t{\n\t\tif ((__io__pointersize == 8)) {\n\t\t\treturn __io__block.readFloat(__io__address + 160);\n\t\t} else {\n\t\t\treturn __io__block.readFloat(__io__address + 156);\n\t\t}\n\t}","code_wo_comment":"public float getBending_damping() throws IOException\n\t{\n\t\tif ((__io__pointersize == 8)) {\n\t\t\treturn __io__block.readFloat(__io__address + 160);\n\t\t} else {\n\t\t\treturn __io__block.readFloat(__io__address + 156);\n\t\t}\n\t}","cleancode":"public float getbending_damping() throws ioexception { if ((__io__pointersize == 8)) { return __io__block.readfloat(__io__address + 160); } else { return __io__block.readfloat(__io__address + 156); } }","repo":"sirivus\/studioonline","label":[1,0,0,0]}
{"id":18140,"original_code":"public void setBending_damping(float bending_damping) throws IOException\n\t{\n\t\tif ((__io__pointersize == 8)) {\n\t\t\t__io__block.writeFloat(__io__address + 160, bending_damping);\n\t\t} else {\n\t\t\t__io__block.writeFloat(__io__address + 156, bending_damping);\n\t\t}\n\t}","code_wo_comment":"public void setBending_damping(float bending_damping) throws IOException\n\t{\n\t\tif ((__io__pointersize == 8)) {\n\t\t\t__io__block.writeFloat(__io__address + 160, bending_damping);\n\t\t} else {\n\t\t\t__io__block.writeFloat(__io__address + 156, bending_damping);\n\t\t}\n\t}","cleancode":"public void setbending_damping(float bending_damping) throws ioexception { if ((__io__pointersize == 8)) { __io__block.writefloat(__io__address + 160, bending_damping); } else { __io__block.writefloat(__io__address + 156, bending_damping); } }","repo":"sirivus\/studioonline","label":[1,0,0,0]}
{"id":18263,"original_code":"public static <T> VectorModel minimize(LossDefinition<T> lossDefinition,\n                                           Collection<Observation<T>> observations,\n                                           int dimensionality,\n                                           double learningRate,\n                                           int numRepetitions,\n                                           double minStepSize) {\n        final Random random = new Random();\n        \/\/ Repeat the optimization multiple times and keep the best model.\n        VectorModel bestModel = null;\n        double bestLoss = Double.NaN;\n        for (int repetition = 0; repetition < numRepetitions; repetition++) {\n            logger.info(\"Performing repetition {}\/{}.\", repetition + 1, numRepetitions);\n            \/\/ Generate an initial model.\n            final double[] parameters = new double[dimensionality];\n            for (int dimension = 0; dimension < parameters.length; dimension++) {\n                parameters[dimension] = random.nextGaussian() * 10; \/\/ TODO: It might be important to allow a meaningful customization of the initial weights.\n            }\n            final VectorModel model = new VectorModel(parameters);\n            \/\/ Repeatedly go against the gradient until convergence.\n            double stepSize;\n            double lastLoss = Double.NaN;\n            long nextLogMillis = System.currentTimeMillis() + 30_000L;\n            long round = 1L;\n            do {\n                \/\/ Calculate the gradient of the current model.\n                final double[] gradient = lossDefinition.calculateGradient(model, observations);\n                \/\/ Update the model and calculate the width of the update step.\n                for (int i = 0; i < gradient.length; i++) {\n                    gradient[i] *= -learningRate;\n                }\n                model.add(gradient);\n                stepSize = calculateEuclidianDistance(gradient);\n                \/\/ Adapt the learning rate (Bold Driver):\n                \/\/ If we we are getting better, increase the learning rate by 5%. Otherwise, decrease it by 50%.\n                double loss = lossDefinition.calculateLoss(model, observations);\n                if (!Double.isNaN(lastLoss)) {\n                    if (lastLoss >= loss) learningRate *= 1.05;\n                    else learningRate *= .5;\n                }\n                lastLoss = loss;\n                if (System.currentTimeMillis() >= nextLogMillis) {\n                    logger.info(\"Current loss after {} rounds: {}\", round, loss);\n                    nextLogMillis += 30_000L;\n                }\n                round++;\n            } while (stepSize > minStepSize);\n            \/\/ Update the best model.\n            double loss = lossDefinition.calculateLoss(model, observations);\n            logger.info(\"Final loss after {} rounds: {}\", round, loss);\n            if (bestModel == null || bestLoss < loss) {\n                bestModel = model;\n                bestLoss = loss;\n            }\n        }\n        return bestModel;\n    }","code_wo_comment":"public static <T> VectorModel minimize(LossDefinition<T> lossDefinition,\n                                           Collection<Observation<T>> observations,\n                                           int dimensionality,\n                                           double learningRate,\n                                           int numRepetitions,\n                                           double minStepSize) {\n        final Random random = new Random();\n       \n        VectorModel bestModel = null;\n        double bestLoss = Double.NaN;\n        for (int repetition = 0; repetition < numRepetitions; repetition++) {\n            logger.info(\"Performing repetition {}\/{}.\", repetition + 1, numRepetitions);\n           \n            final double[] parameters = new double[dimensionality];\n            for (int dimension = 0; dimension < parameters.length; dimension++) {\n                parameters[dimension] = random.nextGaussian() * 10;\n            }\n            final VectorModel model = new VectorModel(parameters);\n           \n            double stepSize;\n            double lastLoss = Double.NaN;\n            long nextLogMillis = System.currentTimeMillis() + 30_000L;\n            long round = 1L;\n            do {\n               \n                final double[] gradient = lossDefinition.calculateGradient(model, observations);\n               \n                for (int i = 0; i < gradient.length; i++) {\n                    gradient[i] *= -learningRate;\n                }\n                model.add(gradient);\n                stepSize = calculateEuclidianDistance(gradient);\n               \n               \n                double loss = lossDefinition.calculateLoss(model, observations);\n                if (!Double.isNaN(lastLoss)) {\n                    if (lastLoss >= loss) learningRate *= 1.05;\n                    else learningRate *= .5;\n                }\n                lastLoss = loss;\n                if (System.currentTimeMillis() >= nextLogMillis) {\n                    logger.info(\"Current loss after {} rounds: {}\", round, loss);\n                    nextLogMillis += 30_000L;\n                }\n                round++;\n            } while (stepSize > minStepSize);\n           \n            double loss = lossDefinition.calculateLoss(model, observations);\n            logger.info(\"Final loss after {} rounds: {}\", round, loss);\n            if (bestModel == null || bestLoss < loss) {\n                bestModel = model;\n                bestLoss = loss;\n            }\n        }\n        return bestModel;\n    }","cleancode":"public static <t> vectormodel minimize(lossdefinition<t> lossdefinition, collection<observation<t>> observations, int dimensionality, double learningrate, int numrepetitions, double minstepsize) { final random random = new random(); vectormodel bestmodel = null; double bestloss = double.nan; for (int repetition = 0; repetition < numrepetitions; repetition++) { logger.info(\"performing repetition {}\/{}.\", repetition + 1, numrepetitions); final double[] parameters = new double[dimensionality]; for (int dimension = 0; dimension < parameters.length; dimension++) { parameters[dimension] = random.nextgaussian() * 10; } final vectormodel model = new vectormodel(parameters); double stepsize; double lastloss = double.nan; long nextlogmillis = system.currenttimemillis() + 30_000l; long round = 1l; do { final double[] gradient = lossdefinition.calculategradient(model, observations); for (int i = 0; i < gradient.length; i++) { gradient[i] *= -learningrate; } model.add(gradient); stepsize = calculateeuclidiandistance(gradient); double loss = lossdefinition.calculateloss(model, observations); if (!double.isnan(lastloss)) { if (lastloss >= loss) learningrate *= 1.05; else learningrate *= .5; } lastloss = loss; if (system.currenttimemillis() >= nextlogmillis) { logger.info(\"current loss after {} rounds: {}\", round, loss); nextlogmillis += 30_000l; } round++; } while (stepsize > minstepsize); double loss = lossdefinition.calculateloss(model, observations); logger.info(\"final loss after {} rounds: {}\", round, loss); if (bestmodel == null || bestloss < loss) { bestmodel = model; bestloss = loss; } } return bestmodel; }","repo":"stratosphere\/metadata-store","label":[1,0,0,0]}
{"id":18305,"original_code":"public Session getSession(String sessionId) {\n\t\t\/\/ TODO lock sessions to prevent fetching an expired session?\n\t\tSession session = sessions.get(sessionId);\n\t\tif (session == null) {\n\t\t\tString msg = String.format(\"Session: %s does not exist.\", sessionId);\n\t\t\tLOG.error(msg);\n\t\t\tthrow new SqlGatewayException(msg);\n\t\t}\n\t\tsession.touch();\n\t\treturn session;\n\t}","code_wo_comment":"public Session getSession(String sessionId) {\n\t\n\t\tSession session = sessions.get(sessionId);\n\t\tif (session == null) {\n\t\t\tString msg = String.format(\"Session: %s does not exist.\", sessionId);\n\t\t\tLOG.error(msg);\n\t\t\tthrow new SqlGatewayException(msg);\n\t\t}\n\t\tsession.touch();\n\t\treturn session;\n\t}","cleancode":"public session getsession(string sessionid) { session session = sessions.get(sessionid); if (session == null) { string msg = string.format(\"session: %s does not exist.\", sessionid); log.error(msg); throw new sqlgatewayexception(msg); } session.touch(); return session; }","repo":"romainr\/flink-sql-gateway","label":[0,1,0,0]}
{"id":34775,"original_code":"public void sendHandshakeRecord(TlsHandshakeMessage handshakeMessage) {\n        TlsPlaintextRecord record = new TlsPlaintextRecord(TlsConstants.HANDSHAKE, version);\n        TlsHandshakeFragment fragment = new HandshakeFragment(handshakeMessage);\n        record.setFragment(fragment);\n        byte[] encoded = record.encode();\n        ByteBuffer buffer = ByteBuffer.wrap(encoded);\n        connectionManager.write(buffer, new CompletionHandler<Integer, ConnectionManager>() {\n            @Override\n            public void completed(Integer result, ConnectionManager attachment) {\n                \/\/ Nothing to do here\n            }\n            @Override\n            public void failed(Throwable exc, ConnectionManager attachment) {\n                \/\/ TODO handle sending errors back to handshake engine. Callback?\n                connectionManager.close();\n            }\n        });\n    }","code_wo_comment":"public void sendHandshakeRecord(TlsHandshakeMessage handshakeMessage) {\n        TlsPlaintextRecord record = new TlsPlaintextRecord(TlsConstants.HANDSHAKE, version);\n        TlsHandshakeFragment fragment = new HandshakeFragment(handshakeMessage);\n        record.setFragment(fragment);\n        byte[] encoded = record.encode();\n        ByteBuffer buffer = ByteBuffer.wrap(encoded);\n        connectionManager.write(buffer, new CompletionHandler<Integer, ConnectionManager>() {\n            @Override\n            public void completed(Integer result, ConnectionManager attachment) {\n               \n            }\n            @Override\n            public void failed(Throwable exc, ConnectionManager attachment) {\n               \n                connectionManager.close();\n            }\n        });\n    }","cleancode":"public void sendhandshakerecord(tlshandshakemessage handshakemessage) { tlsplaintextrecord record = new tlsplaintextrecord(tlsconstants.handshake, version); tlshandshakefragment fragment = new handshakefragment(handshakemessage); record.setfragment(fragment); byte[] encoded = record.encode(); bytebuffer buffer = bytebuffer.wrap(encoded); connectionmanager.write(buffer, new completionhandler<integer, connectionmanager>() { @override public void completed(integer result, connectionmanager attachment) { } @override public void failed(throwable exc, connectionmanager attachment) { connectionmanager.close(); } }); }","repo":"swbrenneis\/secomm-tls-java","label":[0,1,0,0]}
{"id":34776,"original_code":"public void sendAlertRecord(AlertFragment alertFragment) {\n        TlsPlaintextRecord record = new TlsPlaintextRecord(TlsConstants.ALERT, version);\n        record.setFragment(alertFragment);\n        byte[] encoded = record.encode();\n        ByteBuffer buffer = ByteBuffer.wrap(encoded);\n        connectionManager.write(buffer, new CompletionHandler<Integer, ConnectionManager>() {\n            @Override\n            public void completed(Integer result, ConnectionManager attachment) {\n            }\n            @Override\n            public void failed(Throwable exc, ConnectionManager attachment) {\n                \/\/ TODO handle sending errors back to handshake engine. Callback?\n                connectionManager.close();\n            }\n        });\n    }","code_wo_comment":"public void sendAlertRecord(AlertFragment alertFragment) {\n        TlsPlaintextRecord record = new TlsPlaintextRecord(TlsConstants.ALERT, version);\n        record.setFragment(alertFragment);\n        byte[] encoded = record.encode();\n        ByteBuffer buffer = ByteBuffer.wrap(encoded);\n        connectionManager.write(buffer, new CompletionHandler<Integer, ConnectionManager>() {\n            @Override\n            public void completed(Integer result, ConnectionManager attachment) {\n            }\n            @Override\n            public void failed(Throwable exc, ConnectionManager attachment) {\n               \n                connectionManager.close();\n            }\n        });\n    }","cleancode":"public void sendalertrecord(alertfragment alertfragment) { tlsplaintextrecord record = new tlsplaintextrecord(tlsconstants.alert, version); record.setfragment(alertfragment); byte[] encoded = record.encode(); bytebuffer buffer = bytebuffer.wrap(encoded); connectionmanager.write(buffer, new completionhandler<integer, connectionmanager>() { @override public void completed(integer result, connectionmanager attachment) { } @override public void failed(throwable exc, connectionmanager attachment) { connectionmanager.close(); } }); }","repo":"swbrenneis\/secomm-tls-java","label":[0,1,0,0]}
{"id":2041,"original_code":"public String getPrimaryKeyColumn(String tableName) {\n\t\t\/\/ FIXME: Currently working for PostgreSQL only\n\t\tif (this.dbSystem.equals(\"POSTGRESQL\")) {\n\t\t\tString sqlPrimaryKey = \"SELECT a.attname FROM pg_index i JOIN pg_attribute a ON a.attrelid = i.indrelid AND a.attnum = ANY(i.indkey) WHERE i.indrelid = '\" + tableName + \"'::regclass AND i.indisprimary;\";\n\t\t\treturn (String) findSingletonValue(sqlPrimaryKey);\n\t\t}\n\t\telse   \/\/ TODO: Handle other JDBC sources\n\t\t\treturn null;\n\t}","code_wo_comment":"public String getPrimaryKeyColumn(String tableName) {\n\t\n\t\tif (this.dbSystem.equals(\"POSTGRESQL\")) {\n\t\t\tString sqlPrimaryKey = \"SELECT a.attname FROM pg_index i JOIN pg_attribute a ON a.attrelid = i.indrelid AND a.attnum = ANY(i.indkey) WHERE i.indrelid = '\" + tableName + \"'::regclass AND i.indisprimary;\";\n\t\t\treturn (String) findSingletonValue(sqlPrimaryKey);\n\t\t}\n\t\telse  \n\t\t\treturn null;\n\t}","cleancode":"public string getprimarykeycolumn(string tablename) { if (this.dbsystem.equals(\"postgresql\")) { string sqlprimarykey = \"select a.attname from pg_index i join pg_attribute a on a.attrelid = i.indrelid and a.attnum = any(i.indkey) where i.indrelid = '\" + tablename + \"'::regclass and i.indisprimary;\"; return (string) findsingletonvalue(sqlprimarykey); } else return null; }","repo":"smartdatalake\/simsearch","label":[1,1,0,0]}
{"id":18449,"original_code":"public static BufferedImage getPDFPageImage(File pdfFile, int pageNumber) throws Exception {\n        PDDocument document = null;\n        BufferedImage pageImage = null;\n        try {\n            document = PDDocument.load(pdfFile);\n            if (document.isEncrypted()) {\n                throw new Exception(\"Cannot read an encrypted PDF file.\");\n            }\n            \/\/ TODO: what is this code for?\n            \/*\n            PDPageTree pages = document.getPages();\n            PDPage page = pages.get(pageNumber - 1);\n            if (page.getContents() != null) {\n                PDResources resources = page.getResources();\n                Iterable<COSName> names = resources.getXObjectNames();\n                for (COSName name : names) {\n                    PDXObject xobj = resources.getXObject(name);\n                    if (xobj instanceof PDImageXObject) {\n                        PDImageXObject ximage = (PDImageXObject) xobj;\n                        BufferedImage bi = ximage.getImage();\n                        if (bi.getType() <= 0) {\n                            BufferedImage bi2 = new BufferedImage(bi.getWidth(), bi.getHeight(),\n                                BufferedImage.TYPE_INT_RGB);\n                            bi2.getGraphics().drawImage(bi, 0, 0, null);\n                            return bi2;\n                        }\n                        return bi;\n                    }\n                }\n            }\n            *\/\n            PDFRenderer pdfRenderer = new PDFRenderer(document);\n            pageImage = pdfRenderer.renderImageWithDPI(pageNumber - 1, 400);\n        } catch (Exception e) {\n            if (document != null) {\n                document.close();\n            }\n            throw e;\n        }\n        if (document != null) {\n            document.close();\n        }\n        return pageImage;\n    }","code_wo_comment":"public static BufferedImage getPDFPageImage(File pdfFile, int pageNumber) throws Exception {\n        PDDocument document = null;\n        BufferedImage pageImage = null;\n        try {\n            document = PDDocument.load(pdfFile);\n            if (document.isEncrypted()) {\n                throw new Exception(\"Cannot read an encrypted PDF file.\");\n            }\n           \n           \n            PDFRenderer pdfRenderer = new PDFRenderer(document);\n            pageImage = pdfRenderer.renderImageWithDPI(pageNumber - 1, 400);\n        } catch (Exception e) {\n            if (document != null) {\n                document.close();\n            }\n            throw e;\n        }\n        if (document != null) {\n            document.close();\n        }\n        return pageImage;\n    }","cleancode":"public static bufferedimage getpdfpageimage(file pdffile, int pagenumber) throws exception { pddocument document = null; bufferedimage pageimage = null; try { document = pddocument.load(pdffile); if (document.isencrypted()) { throw new exception(\"cannot read an encrypted pdf file.\"); } pdfrenderer pdfrenderer = new pdfrenderer(document); pageimage = pdfrenderer.renderimagewithdpi(pagenumber - 1, 400); } catch (exception e) { if (document != null) { document.close(); } throw e; } if (document != null) { document.close(); } return pageimage; }","repo":"rquast\/formreturn","label":[0,0,0,0]}
{"id":10298,"original_code":"@Override\n  public void close() {\n    \/\/ Stop the thread.\n    interrupt();\n    \/\/ After the interrupt, the run() method will stop Tun2Socks, and then complete.\n    \/\/ We need to wait until that is finished before closing the TUN device.\n    try {\n      join();\n    } catch (InterruptedException e) {\n      \/\/ This is weird: the calling thread has _also_ been interrupted.\n      LogWrapper.report(e);\n    }\n    try {\n      tunFd.close();\n    } catch (IOException e) {\n      LogWrapper.report(e);\n    }\n  }","code_wo_comment":"@Override\n  public void close() {\n   \n    interrupt();\n   \n   \n    try {\n      join();\n    } catch (InterruptedException e) {\n     \n      LogWrapper.report(e);\n    }\n    try {\n      tunFd.close();\n    } catch (IOException e) {\n      LogWrapper.report(e);\n    }\n  }","cleancode":"@override public void close() { interrupt(); try { join(); } catch (interruptedexception e) { logwrapper.report(e); } try { tunfd.close(); } catch (ioexception e) { logwrapper.report(e); } }","repo":"superhero75\/Intra","label":[0,0,1,0]}
{"id":10520,"original_code":"@Override\n    public Builder setPath(Path absolutePath, Path ideallyRelative) throws IOException {\n      \/\/ TODO(plamenko): this check should not be necessary, but otherwise some tests fail due to\n      \/\/ FileHashLoader throwing NoSuchFileException which doesn't get correctly propagated.\n      if (inputSizeLimit != Long.MAX_VALUE) {\n        sizeLimiter.add(fileHashLoader.getSize(absolutePath));\n      }\n      super.setPath(absolutePath, ideallyRelative);\n      return this;\n    }","code_wo_comment":"@Override\n    public Builder setPath(Path absolutePath, Path ideallyRelative) throws IOException {\n     \n     \n      if (inputSizeLimit != Long.MAX_VALUE) {\n        sizeLimiter.add(fileHashLoader.getSize(absolutePath));\n      }\n      super.setPath(absolutePath, ideallyRelative);\n      return this;\n    }","cleancode":"@override public builder setpath(path absolutepath, path ideallyrelative) throws ioexception { if (inputsizelimit != long.max_value) { sizelimiter.add(filehashloader.getsize(absolutepath)); } super.setpath(absolutepath, ideallyrelative); return this; }","repo":"stefb965\/buck","label":[0,0,1,0]}
{"id":18792,"original_code":"@Test\n  public void testallocateContainerDistributesAllocation() throws Exception {\n    \/* This is a lame test, we should really be testing something like\n    z-score or make sure that we don't have 3sigma kind of events. Too lazy\n    to write all that code. This test very lamely tests if we have more than\n    5 separate nodes  from the list of 10 datanodes that got allocated a\n    container.\n     *\/\n    Set<UUID> pipelineList = new TreeSet<>();\n    for (int x = 0; x < 30; x++) {\n      ContainerInfo containerInfo = containerManager.allocateContainer(\n          replicationType, replicationFactor, OzoneConsts.OZONE);\n      Assert.assertNotNull(containerInfo);\n      Assert.assertNotNull(containerInfo.getPipelineID());\n      pipelineList.add(pipelineManager.getPipeline(\n          containerInfo.getPipelineID()).getFirstNode()\n          .getUuid());\n    }\n    Assert.assertTrue(pipelineList.size() >= 1);\n  }","code_wo_comment":"@Test\n  public void testallocateContainerDistributesAllocation() throws Exception {\n   \n    Set<UUID> pipelineList = new TreeSet<>();\n    for (int x = 0; x < 30; x++) {\n      ContainerInfo containerInfo = containerManager.allocateContainer(\n          replicationType, replicationFactor, OzoneConsts.OZONE);\n      Assert.assertNotNull(containerInfo);\n      Assert.assertNotNull(containerInfo.getPipelineID());\n      pipelineList.add(pipelineManager.getPipeline(\n          containerInfo.getPipelineID()).getFirstNode()\n          .getUuid());\n    }\n    Assert.assertTrue(pipelineList.size() >= 1);\n  }","cleancode":"@test public void testallocatecontainerdistributesallocation() throws exception { set<uuid> pipelinelist = new treeset<>(); for (int x = 0; x < 30; x++) { containerinfo containerinfo = containermanager.allocatecontainer( replicationtype, replicationfactor, ozoneconsts.ozone); assert.assertnotnull(containerinfo); assert.assertnotnull(containerinfo.getpipelineid()); pipelinelist.add(pipelinemanager.getpipeline( containerinfo.getpipelineid()).getfirstnode() .getuuid()); } assert.asserttrue(pipelinelist.size() >= 1); }","repo":"smengcl\/hadoop-ozone","label":[1,0,0,0]}
{"id":10608,"original_code":"@BeforeClass\n    public static void createInput() throws IOException {\n        \/\/ TODO: set up your sample input object here.\n        input = null;\n    }","code_wo_comment":"@BeforeClass\n    public static void createInput() throws IOException {\n       \n        input = null;\n    }","cleancode":"@beforeclass public static void createinput() throws ioexception { input = null; }","repo":"rt-di\/usageserver","label":[0,1,0,0]}
{"id":18984,"original_code":"private void newNoMatchStopsRadioButtonActionPerformed(java.awt.event.ActionEvent evt) {\/\/GEN-FIRST:event_newNoMatchStopsRadioButtonActionPerformed\n        \/\/ TODO change text on button to add\n        updateStopCategory(gtfsUploadNoConflict, 0);\n        dontuploadAllBtn.setEnabled(true);\n    }","code_wo_comment":"private void newNoMatchStopsRadioButtonActionPerformed(java.awt.event.ActionEvent evt) {       \n        updateStopCategory(gtfsUploadNoConflict, 0);\n        dontuploadAllBtn.setEnabled(true);\n    }","cleancode":"private void newnomatchstopsradiobuttonactionperformed(java.awt.event.actionevent evt) { updatestopcategory(gtfsuploadnoconflict, 0); dontuploadallbtn.setenabled(true); }","repo":"reubot\/gtfs-osm-sync","label":[0,1,0,0]}
{"id":19409,"original_code":"private static int offsetToLine(String text, int offset) {\n    return offsetToLine(text, 0, offset);\n  }","code_wo_comment":"private static int offsetToLine(String text, int offset) {\n    return offsetToLine(text, 0, offset);\n  }","cleancode":"private static int offsettoline(string text, int offset) { return offsettoline(text, 0, offset); }","repo":"sylviawan\/oop_assignment1","label":[1,0,0,0]}
{"id":19410,"original_code":"private static int offsetToLine(String text, int start, int offset) {\n    int line = 0;\n    while (offset >= start) {\n      offset = text.lastIndexOf('\\n', offset-1);\n      line++;\n    }\n    return line - 1;\n  }","code_wo_comment":"private static int offsetToLine(String text, int start, int offset) {\n    int line = 0;\n    while (offset >= start) {\n      offset = text.lastIndexOf('\\n', offset-1);\n      line++;\n    }\n    return line - 1;\n  }","cleancode":"private static int offsettoline(string text, int start, int offset) { int line = 0; while (offset >= start) { offset = text.lastindexof('\\n', offset-1); line++; } return line - 1; }","repo":"sylviawan\/oop_assignment1","label":[1,0,0,0]}
{"id":19420,"original_code":"@Test(dataProvider = \"collectionsAndVersion\")\n   public void testIteration(CollectionOp op, ProtocolVersion version) throws IOException {\n      Map<String, String> dataIn = new HashMap<>();\n      dataIn.put(\"aKey\", \"aValue\");\n      dataIn.put(\"bKey\", \"bValue\");\n      RemoteCache<Object, Object> cacheToUse;\n      RemoteCacheManager temporaryManager;\n      if (version != ProtocolVersion.DEFAULT_PROTOCOL_VERSION) {\n         String servers = HotRodClientTestingUtil.getServersString(hotrodServers);\n         org.infinispan.client.hotrod.configuration.ConfigurationBuilder clientBuilder =\n               new org.infinispan.client.hotrod.configuration.ConfigurationBuilder();\n         \/\/ Set the version on the manager to connect with\n         clientBuilder.version(version);\n         clientBuilder.addServers(servers);\n         temporaryManager = new RemoteCacheManager(clientBuilder.build());\n         cacheToUse = temporaryManager.getCache();\n      } else {\n         temporaryManager = null;\n         cacheToUse = remoteCache;\n      }\n      try {\n         \/\/ putAll doesn't work in older versions (so we use new client) - that is a different issue completely\n         remoteCache.putAll(dataIn);\n         CloseableIteratorCollection<?> collection = op.function.apply(cacheToUse);\n         \/\/ If we don't support it we should get an exception\n         if (version.compareTo(op.minimumVersionForIteration()) < 0) {\n            Exceptions.expectException(UnsupportedOperationException.class, () -> {\n               try (CloseableIterator<?> iter = collection.iterator()) {\n               }\n            });\n         } else {\n            try (CloseableIterator<?> iter = collection.iterator()) {\n               assertTrue(iter.hasNext());\n               assertNotNull(iter.next());\n               assertTrue(iter.hasNext());\n            }\n         }\n      } finally {\n         if (temporaryManager != null) {\n            temporaryManager.close();\n         }\n      }\n   }","code_wo_comment":"@Test(dataProvider = \"collectionsAndVersion\")\n   public void testIteration(CollectionOp op, ProtocolVersion version) throws IOException {\n      Map<String, String> dataIn = new HashMap<>();\n      dataIn.put(\"aKey\", \"aValue\");\n      dataIn.put(\"bKey\", \"bValue\");\n      RemoteCache<Object, Object> cacheToUse;\n      RemoteCacheManager temporaryManager;\n      if (version != ProtocolVersion.DEFAULT_PROTOCOL_VERSION) {\n         String servers = HotRodClientTestingUtil.getServersString(hotrodServers);\n         org.infinispan.client.hotrod.configuration.ConfigurationBuilder clientBuilder =\n               new org.infinispan.client.hotrod.configuration.ConfigurationBuilder();\n        \n         clientBuilder.version(version);\n         clientBuilder.addServers(servers);\n         temporaryManager = new RemoteCacheManager(clientBuilder.build());\n         cacheToUse = temporaryManager.getCache();\n      } else {\n         temporaryManager = null;\n         cacheToUse = remoteCache;\n      }\n      try {\n        \n         remoteCache.putAll(dataIn);\n         CloseableIteratorCollection<?> collection = op.function.apply(cacheToUse);\n        \n         if (version.compareTo(op.minimumVersionForIteration()) < 0) {\n            Exceptions.expectException(UnsupportedOperationException.class, () -> {\n               try (CloseableIterator<?> iter = collection.iterator()) {\n               }\n            });\n         } else {\n            try (CloseableIterator<?> iter = collection.iterator()) {\n               assertTrue(iter.hasNext());\n               assertNotNull(iter.next());\n               assertTrue(iter.hasNext());\n            }\n         }\n      } finally {\n         if (temporaryManager != null) {\n            temporaryManager.close();\n         }\n      }\n   }","cleancode":"@test(dataprovider = \"collectionsandversion\") public void testiteration(collectionop op, protocolversion version) throws ioexception { map<string, string> datain = new hashmap<>(); datain.put(\"akey\", \"avalue\"); datain.put(\"bkey\", \"bvalue\"); remotecache<object, object> cachetouse; remotecachemanager temporarymanager; if (version != protocolversion.default_protocol_version) { string servers = hotrodclienttestingutil.getserversstring(hotrodservers); org.infinispan.client.hotrod.configuration.configurationbuilder clientbuilder = new org.infinispan.client.hotrod.configuration.configurationbuilder(); clientbuilder.version(version); clientbuilder.addservers(servers); temporarymanager = new remotecachemanager(clientbuilder.build()); cachetouse = temporarymanager.getcache(); } else { temporarymanager = null; cachetouse = remotecache; } try { remotecache.putall(datain); closeableiteratorcollection<?> collection = op.function.apply(cachetouse); if (version.compareto(op.minimumversionforiteration()) < 0) { exceptions.expectexception(unsupportedoperationexception.class, () -> { try (closeableiterator<?> iter = collection.iterator()) { } }); } else { try (closeableiterator<?> iter = collection.iterator()) { asserttrue(iter.hasnext()); assertnotnull(iter.next()); asserttrue(iter.hasnext()); } } } finally { if (temporarymanager != null) { temporarymanager.close(); } } }","repo":"shawkins\/infinispan-1","label":[0,0,1,0]}
{"id":11310,"original_code":"public static int insertWMFromFile(String species,\n                                       String wmname,\n                                       String wmversion,\n                                       String wmtype,\n                                       String wmfile) throws SQLException, NotFoundException, UnknownRoleException, FileNotFoundException, ParseException, IOException {\n        WeightMatrix matrix;\n        System.err.println(\"name \" + wmname + \" version \" + wmversion + \" type \" + wmtype);\n        if (wmtype.matches(\".*TAMO.*\")) {\n            matrix = PWMParser.readTamoMatrix(wmfile);\n        } else if (wmtype.matches(\".*MEME.*\")) {\n            matrix = PWMParser.readMemeMatrix(wmfile);\n        } else if (wmtype.matches(\".*SEQ.*\")) { \n            matrix = PWMParser.readAlignedSequenceMatrix(wmfile);\n        } else if (wmtype.matches(\".*TRANSFAC.*\")) {\n          \/\/TODO add a method to read a single transfac matrix\n          matrix = PWMParser.readTRANSFACFreqMatrices(wmfile, wmversion).get(0);\n        } else if (wmtype.matches(\".*PRIORITY.*\")) {\n          matrix = PWMParser.parsePriorityBestOutput(wmfile);\n        } else if (wmtype.matches(\".*UniProbe.*\")) {\n            matrix = PWMParser.readUniProbeFile(wmfile);\n        } else if (wmtype.toUpperCase().matches(\".*GIMME.*\")) {\n            matrix = PWMParser.readGimmeMotifsMatrices(wmfile,wmversion,wmtype).get(0);\n        } else {\n            System.err.println(\"Didn't see a program I recognize in the type.  defaulting to reading TAMO format\");\n            matrix = PWMParser.readTamoMatrix(wmfile);\n        }\n        matrix.name = wmname;\n        matrix.version = wmversion;\n        matrix.type = wmtype;\n        matrix.speciesid = (new Species(species)).getDBID();\n        return insertMatrixIntoDB(matrix);\n    }","code_wo_comment":"public static int insertWMFromFile(String species,\n                                       String wmname,\n                                       String wmversion,\n                                       String wmtype,\n                                       String wmfile) throws SQLException, NotFoundException, UnknownRoleException, FileNotFoundException, ParseException, IOException {\n        WeightMatrix matrix;\n        System.err.println(\"name \" + wmname + \" version \" + wmversion + \" type \" + wmtype);\n        if (wmtype.matches(\".*TAMO.*\")) {\n            matrix = PWMParser.readTamoMatrix(wmfile);\n        } else if (wmtype.matches(\".*MEME.*\")) {\n            matrix = PWMParser.readMemeMatrix(wmfile);\n        } else if (wmtype.matches(\".*SEQ.*\")) { \n            matrix = PWMParser.readAlignedSequenceMatrix(wmfile);\n        } else if (wmtype.matches(\".*TRANSFAC.*\")) {\n         \n          matrix = PWMParser.readTRANSFACFreqMatrices(wmfile, wmversion).get(0);\n        } else if (wmtype.matches(\".*PRIORITY.*\")) {\n          matrix = PWMParser.parsePriorityBestOutput(wmfile);\n        } else if (wmtype.matches(\".*UniProbe.*\")) {\n            matrix = PWMParser.readUniProbeFile(wmfile);\n        } else if (wmtype.toUpperCase().matches(\".*GIMME.*\")) {\n            matrix = PWMParser.readGimmeMotifsMatrices(wmfile,wmversion,wmtype).get(0);\n        } else {\n            System.err.println(\"Didn't see a program I recognize in the type.  defaulting to reading TAMO format\");\n            matrix = PWMParser.readTamoMatrix(wmfile);\n        }\n        matrix.name = wmname;\n        matrix.version = wmversion;\n        matrix.type = wmtype;\n        matrix.speciesid = (new Species(species)).getDBID();\n        return insertMatrixIntoDB(matrix);\n    }","cleancode":"public static int insertwmfromfile(string species, string wmname, string wmversion, string wmtype, string wmfile) throws sqlexception, notfoundexception, unknownroleexception, filenotfoundexception, parseexception, ioexception { weightmatrix matrix; system.err.println(\"name \" + wmname + \" version \" + wmversion + \" type \" + wmtype); if (wmtype.matches(\".*tamo.*\")) { matrix = pwmparser.readtamomatrix(wmfile); } else if (wmtype.matches(\".*meme.*\")) { matrix = pwmparser.readmemematrix(wmfile); } else if (wmtype.matches(\".*seq.*\")) { matrix = pwmparser.readalignedsequencematrix(wmfile); } else if (wmtype.matches(\".*transfac.*\")) { matrix = pwmparser.readtransfacfreqmatrices(wmfile, wmversion).get(0); } else if (wmtype.matches(\".*priority.*\")) { matrix = pwmparser.parseprioritybestoutput(wmfile); } else if (wmtype.matches(\".*uniprobe.*\")) { matrix = pwmparser.readuniprobefile(wmfile); } else if (wmtype.touppercase().matches(\".*gimme.*\")) { matrix = pwmparser.readgimmemotifsmatrices(wmfile,wmversion,wmtype).get(0); } else { system.err.println(\"didn't see a program i recognize in the type. defaulting to reading tamo format\"); matrix = pwmparser.readtamomatrix(wmfile); } matrix.name = wmname; matrix.version = wmversion; matrix.type = wmtype; matrix.speciesid = (new species(species)).getdbid(); return insertmatrixintodb(matrix); }","repo":"seqcode\/seqcode-core","label":[0,1,0,0]}
{"id":11311,"original_code":"public static int insertWMFromFile(String species, String wmname, String wmversion, String wmtype, String wmfile, String bgFreq) \n  throws SQLException, NotFoundException, UnknownRoleException, FileNotFoundException, ParseException, IOException {\n    WeightMatrix matrix;\n    if (wmtype.matches(\".*TAMO.*\")) {\n      matrix = PWMParser.readTamoMatrix(wmfile);\n    } else if (wmtype.matches(\".*MEME.*\")) {\n      matrix = PWMParser.readMemeMatrix(wmfile);\n    } else if (wmtype.matches(\".*SEQ.*\")) { \n      matrix = PWMParser.readAlignedSequenceMatrix(wmfile);\n    } else if (wmtype.matches(\".*TRANSFAC.*\")) {\n      \/\/TODO add a method to read a single transfac matrix\n      matrix = PWMParser.readTRANSFACFreqMatrices(wmfile, wmversion).get(0);\n    } else if (wmtype.matches(\".*PRIORITY.*\")) {\n      matrix = PWMParser.parsePriorityBestOutput(wmfile);\n    } else if (wmtype.toUpperCase().matches(\".*GIMME.*\")) {\n        matrix = PWMParser.readGimmeMotifsMatrices(wmfile,wmversion,wmtype).get(0);\n    } else {\n      System.err.println(\"Didn't see a program I recognize in the type.  defaulting to reading TAMO format\");\n      matrix = PWMParser.readTamoMatrix(wmfile);\n    }\n    matrix.name = wmname;\n    matrix.version = wmversion;\n    matrix.type = wmtype;\n    matrix.speciesid = (new Species(species)).getDBID();\n    return insertMatrixIntoDB(matrix);\n }","code_wo_comment":"public static int insertWMFromFile(String species, String wmname, String wmversion, String wmtype, String wmfile, String bgFreq) \n  throws SQLException, NotFoundException, UnknownRoleException, FileNotFoundException, ParseException, IOException {\n    WeightMatrix matrix;\n    if (wmtype.matches(\".*TAMO.*\")) {\n      matrix = PWMParser.readTamoMatrix(wmfile);\n    } else if (wmtype.matches(\".*MEME.*\")) {\n      matrix = PWMParser.readMemeMatrix(wmfile);\n    } else if (wmtype.matches(\".*SEQ.*\")) { \n      matrix = PWMParser.readAlignedSequenceMatrix(wmfile);\n    } else if (wmtype.matches(\".*TRANSFAC.*\")) {\n     \n      matrix = PWMParser.readTRANSFACFreqMatrices(wmfile, wmversion).get(0);\n    } else if (wmtype.matches(\".*PRIORITY.*\")) {\n      matrix = PWMParser.parsePriorityBestOutput(wmfile);\n    } else if (wmtype.toUpperCase().matches(\".*GIMME.*\")) {\n        matrix = PWMParser.readGimmeMotifsMatrices(wmfile,wmversion,wmtype).get(0);\n    } else {\n      System.err.println(\"Didn't see a program I recognize in the type.  defaulting to reading TAMO format\");\n      matrix = PWMParser.readTamoMatrix(wmfile);\n    }\n    matrix.name = wmname;\n    matrix.version = wmversion;\n    matrix.type = wmtype;\n    matrix.speciesid = (new Species(species)).getDBID();\n    return insertMatrixIntoDB(matrix);\n }","cleancode":"public static int insertwmfromfile(string species, string wmname, string wmversion, string wmtype, string wmfile, string bgfreq) throws sqlexception, notfoundexception, unknownroleexception, filenotfoundexception, parseexception, ioexception { weightmatrix matrix; if (wmtype.matches(\".*tamo.*\")) { matrix = pwmparser.readtamomatrix(wmfile); } else if (wmtype.matches(\".*meme.*\")) { matrix = pwmparser.readmemematrix(wmfile); } else if (wmtype.matches(\".*seq.*\")) { matrix = pwmparser.readalignedsequencematrix(wmfile); } else if (wmtype.matches(\".*transfac.*\")) { matrix = pwmparser.readtransfacfreqmatrices(wmfile, wmversion).get(0); } else if (wmtype.matches(\".*priority.*\")) { matrix = pwmparser.parseprioritybestoutput(wmfile); } else if (wmtype.touppercase().matches(\".*gimme.*\")) { matrix = pwmparser.readgimmemotifsmatrices(wmfile,wmversion,wmtype).get(0); } else { system.err.println(\"didn't see a program i recognize in the type. defaulting to reading tamo format\"); matrix = pwmparser.readtamomatrix(wmfile); } matrix.name = wmname; matrix.version = wmversion; matrix.type = wmtype; matrix.speciesid = (new species(species)).getdbid(); return insertmatrixintodb(matrix); }","repo":"seqcode\/seqcode-core","label":[0,1,0,0]}
{"id":19634,"original_code":"@Override\n    public MergerToken createSetNotNullToDb(DbEntity entity, DbAttribute column) {\n        return new SetNotNullToDb(entity, column) {\n            @Override\n            public List<String> createSql(DbAdapter adapter) {\n                \/*\n                 * TODO: we generate this query as in ingres db documentation,\n                 * but unfortunately ingres don't support it\n                 *\/\n                StringBuilder sqlBuffer = new StringBuilder();\n                QuotingStrategy context = adapter.getQuotingStrategy();\n                sqlBuffer.append(\"ALTER TABLE \");\n                sqlBuffer.append(getEntity().getFullyQualifiedName());\n                sqlBuffer.append(\" ALTER COLUMN \");\n                sqlBuffer.append(context.quotedName(getColumn()));\n                sqlBuffer.append(\" \");\n                sqlBuffer.append(adapter.externalTypesForJdbcType(getColumn().getType())[0]);\n                if (adapter.typeSupportsLength(getColumn().getType()) && getColumn().getMaxLength() > 0) {\n                    sqlBuffer.append(\"(\");\n                    sqlBuffer.append(getColumn().getMaxLength());\n                    sqlBuffer.append(\")\");\n                }\n                sqlBuffer.append(\" NOT NULL\");\n                return Collections.singletonList(sqlBuffer.toString());\n            }\n        };\n    }","code_wo_comment":"@Override\n    public MergerToken createSetNotNullToDb(DbEntity entity, DbAttribute column) {\n        return new SetNotNullToDb(entity, column) {\n            @Override\n            public List<String> createSql(DbAdapter adapter) {\n               \n                StringBuilder sqlBuffer = new StringBuilder();\n                QuotingStrategy context = adapter.getQuotingStrategy();\n                sqlBuffer.append(\"ALTER TABLE \");\n                sqlBuffer.append(getEntity().getFullyQualifiedName());\n                sqlBuffer.append(\" ALTER COLUMN \");\n                sqlBuffer.append(context.quotedName(getColumn()));\n                sqlBuffer.append(\" \");\n                sqlBuffer.append(adapter.externalTypesForJdbcType(getColumn().getType())[0]);\n                if (adapter.typeSupportsLength(getColumn().getType()) && getColumn().getMaxLength() > 0) {\n                    sqlBuffer.append(\"(\");\n                    sqlBuffer.append(getColumn().getMaxLength());\n                    sqlBuffer.append(\")\");\n                }\n                sqlBuffer.append(\" NOT NULL\");\n                return Collections.singletonList(sqlBuffer.toString());\n            }\n        };\n    }","cleancode":"@override public mergertoken createsetnotnulltodb(dbentity entity, dbattribute column) { return new setnotnulltodb(entity, column) { @override public list<string> createsql(dbadapter adapter) { stringbuilder sqlbuffer = new stringbuilder(); quotingstrategy context = adapter.getquotingstrategy(); sqlbuffer.append(\"alter table \"); sqlbuffer.append(getentity().getfullyqualifiedname()); sqlbuffer.append(\" alter column \"); sqlbuffer.append(context.quotedname(getcolumn())); sqlbuffer.append(\" \"); sqlbuffer.append(adapter.externaltypesforjdbctype(getcolumn().gettype())[0]); if (adapter.typesupportslength(getcolumn().gettype()) && getcolumn().getmaxlength() > 0) { sqlbuffer.append(\"(\"); sqlbuffer.append(getcolumn().getmaxlength()); sqlbuffer.append(\")\"); } sqlbuffer.append(\" not null\"); return collections.singletonlist(sqlbuffer.tostring()); } }; }","repo":"rohankumardubey\/cayenne","label":[0,0,1,0]}
{"id":19696,"original_code":"public static CDI<Object> current()\n    {\n        if (INSTANCE == null)\n        {\n            INSTANCE = ServiceLoader.load(CDIProvider.class).iterator().next().getCDI();\n        }\n        return INSTANCE; \/\/X TODO implement!\n    }","code_wo_comment":"public static CDI<Object> current()\n    {\n        if (INSTANCE == null)\n        {\n            INSTANCE = ServiceLoader.load(CDIProvider.class).iterator().next().getCDI();\n        }\n        return INSTANCE;\n    }","cleancode":"public static cdi<object> current() { if (instance == null) { instance = serviceloader.load(cdiprovider.class).iterator().next().getcdi(); } return instance; }","repo":"salyh\/geronimo-specs","label":[0,1,0,0]}
{"id":19697,"original_code":"public static void setCDIProvider(CDIProvider provider)\n    {\n        \/\/X TODO implement!\n        if (provider == null)\n        {\n            INSTANCE = null;\n        }\n        else\n        {\n            INSTANCE = provider.getCDI();\n        }\n    }","code_wo_comment":"public static void setCDIProvider(CDIProvider provider)\n    {\n       \n        if (provider == null)\n        {\n            INSTANCE = null;\n        }\n        else\n        {\n            INSTANCE = provider.getCDI();\n        }\n    }","cleancode":"public static void setcdiprovider(cdiprovider provider) { if (provider == null) { instance = null; } else { instance = provider.getcdi(); } }","repo":"salyh\/geronimo-specs","label":[1,1,0,0]}
{"id":19886,"original_code":"@Override\n    @Committing\n    @PureWithSideEffects\n    @SuppressWarnings(\"UseSpecificCatch\")\n    public void run() {\n        try {\n            final @Nonnull String address = getSocket().getInetAddress().getHostAddress();\n            Log.debugging(\"Received a request from $.\", address);\n            final @Nonnull Time start = TimeBuilder.build();\n            @Nullable Encryption<Signature<Compression<Pack>>> encryptedMethod = null;\n            @Nullable Signature<Compression<Pack>> signedMethod = null;\n            @Nullable Method<?> method = null;\n            @Nullable Reply<?> reply = null;\n            try {\n                try {\n                    final @Nonnull Pack pack = Pack.loadFrom(getSocket());\n                    final @Nonnull Request request = pack.unpack(RequestConverter.INSTANCE, null);\n                    encryptedMethod = request.getEncryption();\n                    final @Nullable HostIdentifier recipient = encryptedMethod.getRecipient();\n                    if (recipient == null) { throw RequestExceptionBuilder.withCode(RequestErrorCode.RECIPIENT).withMessage(\"The recipient may not be null.\").build(); }\n                    final @Nonnull Host host = Host.of(recipient);\n                    signedMethod = encryptedMethod.getObject();\n                    final @Nonnull SemanticType type = signedMethod.getObject().getObject().getType();\n                    Log.debugging(\"Executing the method $ on host $.\", type.getAddress(), recipient);\n                    final @Nonnull InternalIdentifier subject;\n                    if (type.equals(OpenAccount.TYPE)) { subject = recipient; } else { subject = signedMethod.getSubject(); }\n                    final @Nonnull Account account = Account.with(host, subject.resolve());\n                    method = MethodIndex.get(signedMethod, account);\n                    reply = method.executeOnHost();\n                    Database.commit();\n                } catch (@Nonnull InternalException exception) {\n                    throw RequestExceptionBuilder.withCode(RequestErrorCode.INTERNAL).withMessage(\"An internal problem occurred.\").withCause(exception).build();\n                } catch (@Nonnull ExternalException exception) {\n                    throw RequestExceptionBuilder.withCode(RequestErrorCode.EXTERNAL).withMessage(\"An external problem occurred.\").withCause(exception).build();\n                }\n            } catch (@Nonnull RequestException exception) {\n                Database.rollback();\n                Log.warning(\"A request error occurred:\", exception);\n                reply = RequestExceptionReplyBuilder.withRequestException(exception.isDecoded() ? RequestExceptionBuilder.withCode(RequestErrorCode.REQUEST).withMessage(\"Another server responded with a request error.\").withCause(exception).build() : exception).build();\n            }\n            if (reply == null) { reply = EmptyReplyBuilder.build(); }\n            final @Nonnull Compression<Pack> compressedReply = CompressionBuilder.withObject(reply.pack()).build();\n            \/\/ The reply.pack() statement maps the semantic type of the reply converter, which results in a concurrent update if the client unpacks the response with the same database. The following commit prevents this. However, it is a suboptimal fix for this problem.\n            try { Database.commit(); } catch (@Nonnull DatabaseException exception) { Database.rollback(); }\n            final @Nonnull Signature<Compression<Pack>> signedReply;\n            if (encryptedMethod != null && signedMethod != null) {\n                signedReply = HostSignatureCreator.sign(compressedReply, CompressionConverterBuilder.withObjectConverter(PackConverter.INSTANCE).build()).about(signedMethod.getSubject()).as(encryptedMethod.getRecipient());\n            } else {\n                signedReply = SignatureBuilder.withObjectConverter(CompressionConverterBuilder.withObjectConverter(PackConverter.INSTANCE).build()).withObject(compressedReply).withSubject(HostIdentifier.DIGITALID).build();\n            }\n            final @Nonnull Encryption<Signature<Compression<Pack>>> encryptedReply;\n            if (encryptedMethod instanceof RequestEncryption) {\n                encryptedReply = ResponseEncryptionBuilder.withObject(signedReply).withSymmetricKey(((RequestEncryption) encryptedMethod).getSymmetricKey()).build();\n            } else {\n                encryptedReply = EncryptionBuilder.withObject(signedReply).build();\n            }\n            final @Nonnull Response response = ResponseBuilder.withEncryption(encryptedReply).build();\n            response.pack().storeTo(getSocket());\n            Log.information(method + \" from \" + address + \" handled in \" + start.ago().getValue() + \" ms.\");\n        } catch (@Nonnull NetworkException exception) {\n            Log.warning(\"Could not send a response.\", exception);\n        } catch (@Nonnull Throwable throwable) {\n            Log.warning(\"Something went wrong.\", throwable);\n        } finally {\n            try {\n                if (!getSocket().isClosed()) { getSocket().close(); }\n            } catch (@Nonnull IOException exception) {\n                Log.warning(\"Could not close the socket.\", exception);\n            }\n        }\n    }","code_wo_comment":"@Override\n    @Committing\n    @PureWithSideEffects\n    @SuppressWarnings(\"UseSpecificCatch\")\n    public void run() {\n        try {\n            final @Nonnull String address = getSocket().getInetAddress().getHostAddress();\n            Log.debugging(\"Received a request from $.\", address);\n            final @Nonnull Time start = TimeBuilder.build();\n            @Nullable Encryption<Signature<Compression<Pack>>> encryptedMethod = null;\n            @Nullable Signature<Compression<Pack>> signedMethod = null;\n            @Nullable Method<?> method = null;\n            @Nullable Reply<?> reply = null;\n            try {\n                try {\n                    final @Nonnull Pack pack = Pack.loadFrom(getSocket());\n                    final @Nonnull Request request = pack.unpack(RequestConverter.INSTANCE, null);\n                    encryptedMethod = request.getEncryption();\n                    final @Nullable HostIdentifier recipient = encryptedMethod.getRecipient();\n                    if (recipient == null) { throw RequestExceptionBuilder.withCode(RequestErrorCode.RECIPIENT).withMessage(\"The recipient may not be null.\").build(); }\n                    final @Nonnull Host host = Host.of(recipient);\n                    signedMethod = encryptedMethod.getObject();\n                    final @Nonnull SemanticType type = signedMethod.getObject().getObject().getType();\n                    Log.debugging(\"Executing the method $ on host $.\", type.getAddress(), recipient);\n                    final @Nonnull InternalIdentifier subject;\n                    if (type.equals(OpenAccount.TYPE)) { subject = recipient; } else { subject = signedMethod.getSubject(); }\n                    final @Nonnull Account account = Account.with(host, subject.resolve());\n                    method = MethodIndex.get(signedMethod, account);\n                    reply = method.executeOnHost();\n                    Database.commit();\n                } catch (@Nonnull InternalException exception) {\n                    throw RequestExceptionBuilder.withCode(RequestErrorCode.INTERNAL).withMessage(\"An internal problem occurred.\").withCause(exception).build();\n                } catch (@Nonnull ExternalException exception) {\n                    throw RequestExceptionBuilder.withCode(RequestErrorCode.EXTERNAL).withMessage(\"An external problem occurred.\").withCause(exception).build();\n                }\n            } catch (@Nonnull RequestException exception) {\n                Database.rollback();\n                Log.warning(\"A request error occurred:\", exception);\n                reply = RequestExceptionReplyBuilder.withRequestException(exception.isDecoded() ? RequestExceptionBuilder.withCode(RequestErrorCode.REQUEST).withMessage(\"Another server responded with a request error.\").withCause(exception).build() : exception).build();\n            }\n            if (reply == null) { reply = EmptyReplyBuilder.build(); }\n            final @Nonnull Compression<Pack> compressedReply = CompressionBuilder.withObject(reply.pack()).build();\n           \n            try { Database.commit(); } catch (@Nonnull DatabaseException exception) { Database.rollback(); }\n            final @Nonnull Signature<Compression<Pack>> signedReply;\n            if (encryptedMethod != null && signedMethod != null) {\n                signedReply = HostSignatureCreator.sign(compressedReply, CompressionConverterBuilder.withObjectConverter(PackConverter.INSTANCE).build()).about(signedMethod.getSubject()).as(encryptedMethod.getRecipient());\n            } else {\n                signedReply = SignatureBuilder.withObjectConverter(CompressionConverterBuilder.withObjectConverter(PackConverter.INSTANCE).build()).withObject(compressedReply).withSubject(HostIdentifier.DIGITALID).build();\n            }\n            final @Nonnull Encryption<Signature<Compression<Pack>>> encryptedReply;\n            if (encryptedMethod instanceof RequestEncryption) {\n                encryptedReply = ResponseEncryptionBuilder.withObject(signedReply).withSymmetricKey(((RequestEncryption) encryptedMethod).getSymmetricKey()).build();\n            } else {\n                encryptedReply = EncryptionBuilder.withObject(signedReply).build();\n            }\n            final @Nonnull Response response = ResponseBuilder.withEncryption(encryptedReply).build();\n            response.pack().storeTo(getSocket());\n            Log.information(method + \" from \" + address + \" handled in \" + start.ago().getValue() + \" ms.\");\n        } catch (@Nonnull NetworkException exception) {\n            Log.warning(\"Could not send a response.\", exception);\n        } catch (@Nonnull Throwable throwable) {\n            Log.warning(\"Something went wrong.\", throwable);\n        } finally {\n            try {\n                if (!getSocket().isClosed()) { getSocket().close(); }\n            } catch (@Nonnull IOException exception) {\n                Log.warning(\"Could not close the socket.\", exception);\n            }\n        }\n    }","cleancode":"@override @committing @purewithsideeffects @suppresswarnings(\"usespecificcatch\") public void run() { try { final @nonnull string address = getsocket().getinetaddress().gethostaddress(); log.debugging(\"received a request from $.\", address); final @nonnull time start = timebuilder.build(); @nullable encryption<signature<compression<pack>>> encryptedmethod = null; @nullable signature<compression<pack>> signedmethod = null; @nullable method<?> method = null; @nullable reply<?> reply = null; try { try { final @nonnull pack pack = pack.loadfrom(getsocket()); final @nonnull request request = pack.unpack(requestconverter.instance, null); encryptedmethod = request.getencryption(); final @nullable hostidentifier recipient = encryptedmethod.getrecipient(); if (recipient == null) { throw requestexceptionbuilder.withcode(requesterrorcode.recipient).withmessage(\"the recipient may not be null.\").build(); } final @nonnull host host = host.of(recipient); signedmethod = encryptedmethod.getobject(); final @nonnull semantictype type = signedmethod.getobject().getobject().gettype(); log.debugging(\"executing the method $ on host $.\", type.getaddress(), recipient); final @nonnull internalidentifier subject; if (type.equals(openaccount.type)) { subject = recipient; } else { subject = signedmethod.getsubject(); } final @nonnull account account = account.with(host, subject.resolve()); method = methodindex.get(signedmethod, account); reply = method.executeonhost(); database.commit(); } catch (@nonnull internalexception exception) { throw requestexceptionbuilder.withcode(requesterrorcode.internal).withmessage(\"an internal problem occurred.\").withcause(exception).build(); } catch (@nonnull externalexception exception) { throw requestexceptionbuilder.withcode(requesterrorcode.external).withmessage(\"an external problem occurred.\").withcause(exception).build(); } } catch (@nonnull requestexception exception) { database.rollback(); log.warning(\"a request error occurred:\", exception); reply = requestexceptionreplybuilder.withrequestexception(exception.isdecoded() ? requestexceptionbuilder.withcode(requesterrorcode.request).withmessage(\"another server responded with a request error.\").withcause(exception).build() : exception).build(); } if (reply == null) { reply = emptyreplybuilder.build(); } final @nonnull compression<pack> compressedreply = compressionbuilder.withobject(reply.pack()).build(); try { database.commit(); } catch (@nonnull databaseexception exception) { database.rollback(); } final @nonnull signature<compression<pack>> signedreply; if (encryptedmethod != null && signedmethod != null) { signedreply = hostsignaturecreator.sign(compressedreply, compressionconverterbuilder.withobjectconverter(packconverter.instance).build()).about(signedmethod.getsubject()).as(encryptedmethod.getrecipient()); } else { signedreply = signaturebuilder.withobjectconverter(compressionconverterbuilder.withobjectconverter(packconverter.instance).build()).withobject(compressedreply).withsubject(hostidentifier.digitalid).build(); } final @nonnull encryption<signature<compression<pack>>> encryptedreply; if (encryptedmethod instanceof requestencryption) { encryptedreply = responseencryptionbuilder.withobject(signedreply).withsymmetrickey(((requestencryption) encryptedmethod).getsymmetrickey()).build(); } else { encryptedreply = encryptionbuilder.withobject(signedreply).build(); } final @nonnull response response = responsebuilder.withencryption(encryptedreply).build(); response.pack().storeto(getsocket()); log.information(method + \" from \" + address + \" handled in \" + start.ago().getvalue() + \" ms.\"); } catch (@nonnull networkexception exception) { log.warning(\"could not send a response.\", exception); } catch (@nonnull throwable throwable) { log.warning(\"something went wrong.\", throwable); } finally { try { if (!getsocket().isclosed()) { getsocket().close(); } } catch (@nonnull ioexception exception) { log.warning(\"could not close the socket.\", exception); } } }","repo":"stephaniestroka\/digitalid-core","label":[1,0,0,0]}
{"id":3591,"original_code":"public static void popupManager(final View view, final SoundObject soundObject){\n        \/\/ Declare PopupMenu and assign it to the design created in longclick.xml\n        PopupMenu popup = new PopupMenu(view.getContext(), view);\n        popup.getMenuInflater().inflate(R.menu.longclick, popup.getMenu());\n        \/\/ Handle user clicks on the popupmenu\n        popup.setOnMenuItemClickListener(new PopupMenu.OnMenuItemClickListener() {\n            @Override\n            public boolean onMenuItemClick(MenuItem item) {\n                \/\/ Check if the user wants to share a sound or set a sound as system audio\n                if (item.getItemId() == R.id.action_send || item.getItemId() == R.id.action_ringtone){\n                    \/\/ Define a filename on the given information from the SoundObject AND add the .mp3 tag to it\n                    final String fileName = soundObject.getItemName() + \".mp3\";\n                    \/\/ Get the path to the users external storage\n                    File storage = Environment.getExternalStorageDirectory();\n                    \/\/ Define the directory path to the soundboard apps folder\n                    \/\/ Change my_soundboard to whatever you want as your folder but keep the slash\n                    \/\/ TODO: When changing the path be sure to also modify the path in filepaths.xml (res\/xml\/filepaths.xml)\n                    File directory = new File(storage.getAbsolutePath() + \"\/my_soundboard\/\");\n                    \/\/ Creates the directory if it doesn't exist\n                    \/\/ mkdirs() gives back a boolean. You can use it to do some processes as well but we don't really need it.\n                    directory.mkdirs();\n                    \/\/ Finally define the file by giving over the directory and the filename\n                    final File file = new File(directory, fileName);\n                    \/\/ Define an InputStream that will read the data from your sound-raw.mp3 file into a buffer\n                    InputStream in = view.getContext().getResources().openRawResource(soundObject.getItemID());\n                    try{\n                        \/\/ Log the name of the sound that is being saved\n                        Log.i(LOG_TAG, \"Saving sound \" + soundObject.getItemName());\n                        \/\/ Define an OutputStream\/FileOutputStream that will write the buffer data into the sound.mp3 on the external storage\n                        OutputStream out = new FileOutputStream(file);\n                        \/\/ Define a buffer of 1kb (you can make it a little bit bigger but 1kb will be adequate)\n                        byte[] buffer = new byte[1024];\n                        int len;\n                        \/\/ Write the data to the sound.mp3 file while reading it from the sound-raw.mp3\n                        \/\/ if (int) InputStream.read() returns -1 stream is at the end of file\n                        while ((len = in.read(buffer, 0, buffer.length)) != -1){\n                            out.write(buffer, 0 , len);\n                        }\n                        \/\/ Close both streams\n                        in.close();\n                        out.close();\n                    } catch (IOException e){\n                        \/\/ Log error if process failed\n                        Log.e(LOG_TAG, \"Failed to save file: \" + e.getMessage());\n                    }\n                    \/\/ Send a sound via WhatsApp or the like\n                    if (item.getItemId() == R.id.action_send){\n                        try{\n                            \/\/ Check if the users device Android version is 5.1 or higher\n                            \/\/ If it is you'll have to use FileProvider to get the sharing function to work properly\n                            if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.LOLLIPOP_MR1){\n                                final String AUTHORITY = view.getContext().getPackageName() + \".fileprovider\";\n                                Uri contentUri = FileProvider.getUriForFile(view.getContext(), AUTHORITY, file);\n                                final Intent shareIntent = new Intent(Intent.ACTION_SEND);\n                                final Intent intent = new Intent(Intent.ACTION_SEND);\n                                intent.putExtra(Intent.EXTRA_STREAM, contentUri);\n                                \/\/ Define the intent to be of type audio\/mp3\n                                intent.setType(\"audio\/mp3\");\n                                \/\/ Start a new chooser dialog where the user can choose an app to share the sound\n                                view.getContext().startActivity(Intent.createChooser(intent, \"Share sound via...\"));\n                            }\n                            else {\n                                final Intent intent = new Intent(Intent.ACTION_SEND);\n                                \/\/ Uri refers to a name or location\n                                \/\/ .parse() analyzes a given uri string and creates a Uri from it\n                                \/\/ Define a \"link\" (Uri) to the saved file\n                                Uri fileUri = Uri.parse(file.getAbsolutePath());\n                                intent.putExtra(Intent.EXTRA_STREAM, fileUri);\n                                \/\/ Define the intent to be of type audio\/mp3\n                                intent.setType(\"audio\/mp3\");\n                                \/\/ Start a new chooser dialog where the user can choose an app to share the sound\n                                view.getContext().startActivity(Intent.createChooser(intent, \"Share sound via...\"));\n                            }\n                        } catch (Exception e){\n                            \/\/ Log error if process failed\n                            Log.e(LOG_TAG, \"Failed to share sound: \" + e.getMessage());\n                        }\n                    }\n                    \/\/ Save as ringtone, alarm or notification\n\/\/                    if (item.getItemId() == R.id.action_ringtone) {\n\/\/\n\/\/                        \/\/ Create a little popup like dialog that gives the user the choice between the 3 types\n\/\/                        \/\/ THEME_HOLO_LIGHT was deprecated in API 23 but to support older APIs you should use it\n\/\/                        AlertDialog.Builder builder = new AlertDialog.Builder(view.getContext(), AlertDialog.THEME_HOLO_LIGHT);\n\/\/                        builder.setTitle(\"Save as...\");\n\/\/                        builder.setItems(new CharSequence[]{\"Ringtone\", \"Notification\", \"Alarm\"}, new DialogInterface.OnClickListener(){\n\/\/\n\/\/                            @Override\n\/\/                            public void onClick(DialogInterface dialog, int which){\n\/\/\n\/\/                                \/\/ Decide on the users choice which information will be send to a method that handles the settings for all kinds of system audio\n\/\/\/\/                                switch (which) {\n\/\/\/\/\n\/\/\/\/                                    \/\/ Ringtone\n\/\/\/\/                                    case 0:\n\/\/\/\/                                        changeSystemAudio(context, RingtoneManager.TYPE_RINGTONE, file);\n\/\/\/\/                                        break;\n\/\/\/\/                                    \/\/ Notification\n\/\/\/\/                                    case 1:\n\/\/\/\/                                        changeSystemAudio(context, RingtoneManager.TYPE_NOTIFICATION, file);\n\/\/\/\/                                        break;\n\/\/\/\/                                    \/\/ Alarmton\n\/\/\/\/                                    case 2:\n\/\/\/\/                                        changeSystemAudio(context, RingtoneManager.TYPE_ALARM, file);\n\/\/\/\/                                        break;\n\/\/\/\/                                    default:\n\/\/\/\/                                }\n\/\/                            }\n\/\/                        });\n\/\/                        builder.create();\n\/\/                        builder.show();\n\/\/                    }\n                }\n                \/\/ Add sound to favorites \/ Remove sound from favorites\n\/\/                if (item.getItemId() == R.id.action_favorite) {\n\/\/\n\/\/                    DatabaseHandler databaseHandler = DatabaseHandler\n\/\/                            .getInstance(context.getApplicationContext());\n\/\/\n\/\/                    \/\/ Identify the current activity\n\/\/                    if (context instanceof FavoriteActivity) {\n\/\/                        databaseHandler.removeFavorite(context, soundObject);\n\/\/                    } else {\n\/\/                        databaseHandler.addFavorite(soundObject);\n\/\/                    }\n\/\/                }\n                return true;\n            }\n        });\n        popup.show();\n    }","code_wo_comment":"public static void popupManager(final View view, final SoundObject soundObject){\n       \n        PopupMenu popup = new PopupMenu(view.getContext(), view);\n        popup.getMenuInflater().inflate(R.menu.longclick, popup.getMenu());\n       \n        popup.setOnMenuItemClickListener(new PopupMenu.OnMenuItemClickListener() {\n            @Override\n            public boolean onMenuItemClick(MenuItem item) {\n               \n                if (item.getItemId() == R.id.action_send || item.getItemId() == R.id.action_ringtone){\n                   \n                    final String fileName = soundObject.getItemName() + \".mp3\";\n                   \n                    File storage = Environment.getExternalStorageDirectory();\n                   \n                   \n                   \n                    File directory = new File(storage.getAbsolutePath() + \"\/my_soundboard\/\");\n                   \n                   \n                    directory.mkdirs();\n                   \n                    final File file = new File(directory, fileName);\n                   \n                    InputStream in = view.getContext().getResources().openRawResource(soundObject.getItemID());\n                    try{\n                       \n                        Log.i(LOG_TAG, \"Saving sound \" + soundObject.getItemName());\n                       \n                        OutputStream out = new FileOutputStream(file);\n                       \n                        byte[] buffer = new byte[1024];\n                        int len;\n                       \n                       \n                        while ((len = in.read(buffer, 0, buffer.length)) != -1){\n                            out.write(buffer, 0 , len);\n                        }\n                       \n                        in.close();\n                        out.close();\n                    } catch (IOException e){\n                       \n                        Log.e(LOG_TAG, \"Failed to save file: \" + e.getMessage());\n                    }\n                   \n                    if (item.getItemId() == R.id.action_send){\n                        try{\n                           \n                           \n                            if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.LOLLIPOP_MR1){\n                                final String AUTHORITY = view.getContext().getPackageName() + \".fileprovider\";\n                                Uri contentUri = FileProvider.getUriForFile(view.getContext(), AUTHORITY, file);\n                                final Intent shareIntent = new Intent(Intent.ACTION_SEND);\n                                final Intent intent = new Intent(Intent.ACTION_SEND);\n                                intent.putExtra(Intent.EXTRA_STREAM, contentUri);\n                               \n                                intent.setType(\"audio\/mp3\");\n                               \n                                view.getContext().startActivity(Intent.createChooser(intent, \"Share sound via...\"));\n                            }\n                            else {\n                                final Intent intent = new Intent(Intent.ACTION_SEND);\n                               \n                               \n                               \n                                Uri fileUri = Uri.parse(file.getAbsolutePath());\n                                intent.putExtra(Intent.EXTRA_STREAM, fileUri);\n                               \n                                intent.setType(\"audio\/mp3\");\n                               \n                                view.getContext().startActivity(Intent.createChooser(intent, \"Share sound via...\"));\n                            }\n                        } catch (Exception e){\n                           \n                            Log.e(LOG_TAG, \"Failed to share sound: \" + e.getMessage());\n                        }\n                    }\n                   \n                }\n               \n                return true;\n            }\n        });\n        popup.show();\n    }","cleancode":"public static void popupmanager(final view view, final soundobject soundobject){ popupmenu popup = new popupmenu(view.getcontext(), view); popup.getmenuinflater().inflate(r.menu.longclick, popup.getmenu()); popup.setonmenuitemclicklistener(new popupmenu.onmenuitemclicklistener() { @override public boolean onmenuitemclick(menuitem item) { if (item.getitemid() == r.id.action_send || item.getitemid() == r.id.action_ringtone){ final string filename = soundobject.getitemname() + \".mp3\"; file storage = environment.getexternalstoragedirectory(); file directory = new file(storage.getabsolutepath() + \"\/my_soundboard\/\"); directory.mkdirs(); final file file = new file(directory, filename); inputstream in = view.getcontext().getresources().openrawresource(soundobject.getitemid()); try{ log.i(log_tag, \"saving sound \" + soundobject.getitemname()); outputstream out = new fileoutputstream(file); byte[] buffer = new byte[1024]; int len; while ((len = in.read(buffer, 0, buffer.length)) != -1){ out.write(buffer, 0 , len); } in.close(); out.close(); } catch (ioexception e){ log.e(log_tag, \"failed to save file: \" + e.getmessage()); } if (item.getitemid() == r.id.action_send){ try{ if (build.version.sdk_int >= build.version_codes.lollipop_mr1){ final string authority = view.getcontext().getpackagename() + \".fileprovider\"; uri contenturi = fileprovider.geturiforfile(view.getcontext(), authority, file); final intent shareintent = new intent(intent.action_send); final intent intent = new intent(intent.action_send); intent.putextra(intent.extra_stream, contenturi); intent.settype(\"audio\/mp3\"); view.getcontext().startactivity(intent.createchooser(intent, \"share sound via...\")); } else { final intent intent = new intent(intent.action_send); uri fileuri = uri.parse(file.getabsolutepath()); intent.putextra(intent.extra_stream, fileuri); intent.settype(\"audio\/mp3\"); view.getcontext().startactivity(intent.createchooser(intent, \"share sound via...\")); } } catch (exception e){ log.e(log_tag, \"failed to share sound: \" + e.getmessage()); } } } return true; } }); popup.show(); }","repo":"scubedcombd\/Sacred_Games_Soundboard","label":[1,0,0,0]}
{"id":3789,"original_code":"private void addNoteAsFingerMarker(byte[] dat) {\n\t\tfinal int command = dat[0] & 0xf0;\n\t\tfinal int channel = dat[0] & 0x0f;\n\t\tint note = dat[1];\n\t\tfinal int velocity = dat[2];\n\t\t\/\/ if (type == NOTE_ON || type == NOTE_OFF) \n\t\tif ((command & 0x80) == 0x80) {\n\t\t\t\/\/ only show if channel switch is on\n\t\t\tif (GuitarChannel.isChannelEnabled(chanTog, channel)) {\n\t\t\t\tGuitarChannel guitarchannel = GuitarChannel.get(gchannels,\n\t\t\t\t\t\tchannel);\n\t\t\t\tif (command == NOTEON && velocity != 0) {\n\t\t\t\t\tprintMessage(dat);\n\t\t\t\t\tguitarchannel.noteOn(note);\n\t\t\t\t} else \/* if (command == NOTEOFF || velocity == 0) *\/{\n\t\t\t\t\tguitarchannel.noteOff(note);\n\t\t\t\t}\n\t\t\t}\n\t\t\t\/\/ update progress slider periodically\n\t\t\tif (noteCount % 30 == 0) {\n\t\t\t\t\/\/ need to figure out why this doesn't work\n\t\t\t\t\/\/ float percent = sequencer.getTickPosition() \/\n\t\t\t\t\/\/ sequence.getTickLength() * 100;\n\t\t\t\tGuitarView.getProgSlide().setValue(sequencer.getTickPosition());\n\t\t\t\t\/\/ GuitarView.getProgSlide().setValueLabel(String.format(\"%d\",\n\t\t\t\t\/\/ percent));\n\t\t\t\t\/\/ GuitarView.myTextarea.append(String.format(\"%d\", percent) +\n\t\t\t\t\/\/ \"\\n\");\n\t\t\t}\n\t\t\tnoteCount++;\n\t\t}\n\t}","code_wo_comment":"private void addNoteAsFingerMarker(byte[] dat) {\n\t\tfinal int command = dat[0] & 0xf0;\n\t\tfinal int channel = dat[0] & 0x0f;\n\t\tint note = dat[1];\n\t\tfinal int velocity = dat[2];\n\t\n\t\tif ((command & 0x80) == 0x80) {\n\t\t\n\t\t\tif (GuitarChannel.isChannelEnabled(chanTog, channel)) {\n\t\t\t\tGuitarChannel guitarchannel = GuitarChannel.get(gchannels,\n\t\t\t\t\t\tchannel);\n\t\t\t\tif (command == NOTEON && velocity != 0) {\n\t\t\t\t\tprintMessage(dat);\n\t\t\t\t\tguitarchannel.noteOn(note);\n\t\t\t\t} else{\n\t\t\t\t\tguitarchannel.noteOff(note);\n\t\t\t\t}\n\t\t\t}\n\t\t\n\t\t\tif (noteCount % 30 == 0) {\n\t\t\t\n\t\t\t\n\t\t\t\n\t\t\t\tGuitarView.getProgSlide().setValue(sequencer.getTickPosition());\n\t\t\t\n\t\t\t\n\t\t\t\n\t\t\t\n\t\t\t}\n\t\t\tnoteCount++;\n\t\t}\n\t}","cleancode":"private void addnoteasfingermarker(byte[] dat) { final int command = dat[0] & 0xf0; final int channel = dat[0] & 0x0f; int note = dat[1]; final int velocity = dat[2]; if ((command & 0x80) == 0x80) { if (guitarchannel.ischannelenabled(chantog, channel)) { guitarchannel guitarchannel = guitarchannel.get(gchannels, channel); if (command == noteon && velocity != 0) { printmessage(dat); guitarchannel.noteon(note); } else{ guitarchannel.noteoff(note); } } if (notecount % 30 == 0) { guitarview.getprogslide().setvalue(sequencer.gettickposition()); } notecount++; } }","repo":"rsampson\/GuitarView","label":[0,0,1,0]}
{"id":3880,"original_code":"@Test\n    public void shouldReturnExpectedResponseWhenGetRequestMadeOverSslWithTlsVersion_1_3() throws Exception {\n        \/\/ The following is a bad practice: conditionally running this test only if 'TLSv1.3' is supported by the JDK\n        if (new HashSet<>(asList(SslUtils.enabledProtocols())).contains(TLS_v1_3)) {\n            makeRequestAndAssert(buildHttpClient(TLS_v1_3));\n        } else {\n            assertThat(true).isTrue();\n        }\n    }","code_wo_comment":"@Test\n    public void shouldReturnExpectedResponseWhenGetRequestMadeOverSslWithTlsVersion_1_3() throws Exception {\n       \n        if (new HashSet<>(asList(SslUtils.enabledProtocols())).contains(TLS_v1_3)) {\n            makeRequestAndAssert(buildHttpClient(TLS_v1_3));\n        } else {\n            assertThat(true).isTrue();\n        }\n    }","cleancode":"@test public void shouldreturnexpectedresponsewhengetrequestmadeoversslwithtlsversion_1_3() throws exception { if (new hashset<>(aslist(sslutils.enabledprotocols())).contains(tls_v1_3)) { makerequestandassert(buildhttpclient(tls_v1_3)); } else { assertthat(true).istrue(); } }","repo":"rohankumardubey\/stubby4j","label":[0,0,0,1]}
{"id":12261,"original_code":"public void register() {\n        if (!isRegistered) {\n            VirtualFileManager.getInstance().addAsyncFileListener((@NotNull List<? extends VFileEvent> events) -> {\n                for (VFileEvent event : events) {\n                    if (event instanceof VFileDeleteEvent) {\n                        \/\/ TODO run configuration icon change\n                        System.out.println(\"deleted : \" + event.getFile());\n                    }\n                }\n                return null;\n            }, () -> {});\n            isRegistered = true;\n        }\n    }","code_wo_comment":"public void register() {\n        if (!isRegistered) {\n            VirtualFileManager.getInstance().addAsyncFileListener((@NotNull List<? extends VFileEvent> events) -> {\n                for (VFileEvent event : events) {\n                    if (event instanceof VFileDeleteEvent) {\n                       \n                        System.out.println(\"deleted : \" + event.getFile());\n                    }\n                }\n                return null;\n            }, () -> {});\n            isRegistered = true;\n        }\n    }","cleancode":"public void register() { if (!isregistered) { virtualfilemanager.getinstance().addasyncfilelistener((@notnull list<? extends vfileevent> events) -> { for (vfileevent event : events) { if (event instanceof vfiledeleteevent) { system.out.println(\"deleted : \" + event.getfile()); } } return null; }, () -> {}); isregistered = true; } }","repo":"soungminjoo\/httpflow-intellij-plugin","label":[0,1,0,0]}
{"id":20616,"original_code":"private void setBandInfo(DataChoice dataChoice, AddeImageInfo aii) {\n        BandInfo bi = (BandInfo) dataChoice.getId();\n        List<BandInfo> bandInfos =\n            (List<BandInfo>) getProperty(PROP_BANDINFO, (Object) null);\n        boolean hasBand = true;\n        \/\/If this data source has been changed after we have create a display \n        \/\/then the possibility exists that the bandinfo contained by the incoming\n        \/\/data choice might not be valid. If it isn't then default to the first \n        \/\/one in the list\n        if (bandInfos != null) {\n            hasBand = bandInfos.contains(bi);\n            if ( !hasBand) {\n                \/\/                                System.err.println(\"has band = \" + bandInfos.contains(bi));\n            }\n            if ( !hasBand && (bandInfos.size() > 0)) {\n                bi = bandInfos.get(0);\n            } else {\n                \/\/Not sure what to do here.\n            }\n        }\n        aii.setBand(\"\" + bi.getBandNumber());\n        aii.setUnit(bi.getPreferredUnit());\n    }","code_wo_comment":"private void setBandInfo(DataChoice dataChoice, AddeImageInfo aii) {\n        BandInfo bi = (BandInfo) dataChoice.getId();\n        List<BandInfo> bandInfos =\n            (List<BandInfo>) getProperty(PROP_BANDINFO, (Object) null);\n        boolean hasBand = true;\n       \n       \n       \n       \n        if (bandInfos != null) {\n            hasBand = bandInfos.contains(bi);\n            if ( !hasBand) {\n               \n            }\n            if ( !hasBand && (bandInfos.size() > 0)) {\n                bi = bandInfos.get(0);\n            } else {\n               \n            }\n        }\n        aii.setBand(\"\" + bi.getBandNumber());\n        aii.setUnit(bi.getPreferredUnit());\n    }","cleancode":"private void setbandinfo(datachoice datachoice, addeimageinfo aii) { bandinfo bi = (bandinfo) datachoice.getid(); list<bandinfo> bandinfos = (list<bandinfo>) getproperty(prop_bandinfo, (object) null); boolean hasband = true; if (bandinfos != null) { hasband = bandinfos.contains(bi); if ( !hasband) { } if ( !hasband && (bandinfos.size() > 0)) { bi = bandinfos.get(0); } else { } } aii.setband(\"\" + bi.getbandnumber()); aii.setunit(bi.getpreferredunit()); }","repo":"slclark\/IDV","label":[0,1,0,0]}
{"id":20666,"original_code":"public List<DijkstraNode> getNeighbors() {\n        \/\/ TODO\n        \/\/ Check if on edge of map - breaks if we're on the pixel right next\n        \/\/ to the edge.\n        List<DijkstraNode> neighborNodeList = new ArrayList<DijkstraNode>();\n        Coordinate currentCoordinate = this.getPosition();\n        int currentX = currentCoordinate.getX();\n        int currentY = currentCoordinate.getY();\n        \/\/ since we're on a grid, treat our graph as such and determine neighbors like that\n        Coordinate coordinateLeft = new Coordinate(currentX - 1, currentY);\n        Coordinate coordinateUpLeft = new Coordinate(currentX - 1, currentY + 1);\n        Coordinate coordinateUp = new Coordinate(currentX, currentY + 1);\n        Coordinate coordinateUpRight = new Coordinate(currentX + 1, currentY + 1);\n        Coordinate coordinateRight = new Coordinate(currentX + 1, currentY);\n        Coordinate coordinateDownRight = new Coordinate(currentX + 1, currentY - 1);\n        Coordinate coordinateDown = new Coordinate(currentX, currentY - 1);\n        Coordinate coordinateDownLeft = new Coordinate(currentX - 1, currentY - 1);\n        DijkstraNode nodeLeft = new DijkstraNode(coordinateLeft);\n        DijkstraNode nodeUpLeft = new DijkstraNode(coordinateUpLeft);\n        DijkstraNode nodeUp = new DijkstraNode(coordinateUp);\n        DijkstraNode nodeUpRight = new DijkstraNode(coordinateUpRight);\n        DijkstraNode nodeRight = new DijkstraNode(coordinateRight);\n        DijkstraNode nodeDownRight = new DijkstraNode(coordinateDownRight);\n        DijkstraNode nodeDown = new DijkstraNode(coordinateDown);\n        DijkstraNode nodeDownLeft = new DijkstraNode(coordinateDownLeft);\n        neighborNodeList.add(nodeLeft);\n        neighborNodeList.add(nodeUpLeft);\n        neighborNodeList.add(nodeUp);\n        neighborNodeList.add(nodeUpRight);\n        neighborNodeList.add(nodeRight);\n        neighborNodeList.add(nodeDownRight);\n        neighborNodeList.add(nodeDown);\n        neighborNodeList.add(nodeDownLeft);\n        return neighborNodeList;\n    }","code_wo_comment":"public List<DijkstraNode> getNeighbors() {\n       \n       \n       \n        List<DijkstraNode> neighborNodeList = new ArrayList<DijkstraNode>();\n        Coordinate currentCoordinate = this.getPosition();\n        int currentX = currentCoordinate.getX();\n        int currentY = currentCoordinate.getY();\n       \n        Coordinate coordinateLeft = new Coordinate(currentX - 1, currentY);\n        Coordinate coordinateUpLeft = new Coordinate(currentX - 1, currentY + 1);\n        Coordinate coordinateUp = new Coordinate(currentX, currentY + 1);\n        Coordinate coordinateUpRight = new Coordinate(currentX + 1, currentY + 1);\n        Coordinate coordinateRight = new Coordinate(currentX + 1, currentY);\n        Coordinate coordinateDownRight = new Coordinate(currentX + 1, currentY - 1);\n        Coordinate coordinateDown = new Coordinate(currentX, currentY - 1);\n        Coordinate coordinateDownLeft = new Coordinate(currentX - 1, currentY - 1);\n        DijkstraNode nodeLeft = new DijkstraNode(coordinateLeft);\n        DijkstraNode nodeUpLeft = new DijkstraNode(coordinateUpLeft);\n        DijkstraNode nodeUp = new DijkstraNode(coordinateUp);\n        DijkstraNode nodeUpRight = new DijkstraNode(coordinateUpRight);\n        DijkstraNode nodeRight = new DijkstraNode(coordinateRight);\n        DijkstraNode nodeDownRight = new DijkstraNode(coordinateDownRight);\n        DijkstraNode nodeDown = new DijkstraNode(coordinateDown);\n        DijkstraNode nodeDownLeft = new DijkstraNode(coordinateDownLeft);\n        neighborNodeList.add(nodeLeft);\n        neighborNodeList.add(nodeUpLeft);\n        neighborNodeList.add(nodeUp);\n        neighborNodeList.add(nodeUpRight);\n        neighborNodeList.add(nodeRight);\n        neighborNodeList.add(nodeDownRight);\n        neighborNodeList.add(nodeDown);\n        neighborNodeList.add(nodeDownLeft);\n        return neighborNodeList;\n    }","cleancode":"public list<dijkstranode> getneighbors() { list<dijkstranode> neighbornodelist = new arraylist<dijkstranode>(); coordinate currentcoordinate = this.getposition(); int currentx = currentcoordinate.getx(); int currenty = currentcoordinate.gety(); coordinate coordinateleft = new coordinate(currentx - 1, currenty); coordinate coordinateupleft = new coordinate(currentx - 1, currenty + 1); coordinate coordinateup = new coordinate(currentx, currenty + 1); coordinate coordinateupright = new coordinate(currentx + 1, currenty + 1); coordinate coordinateright = new coordinate(currentx + 1, currenty); coordinate coordinatedownright = new coordinate(currentx + 1, currenty - 1); coordinate coordinatedown = new coordinate(currentx, currenty - 1); coordinate coordinatedownleft = new coordinate(currentx - 1, currenty - 1); dijkstranode nodeleft = new dijkstranode(coordinateleft); dijkstranode nodeupleft = new dijkstranode(coordinateupleft); dijkstranode nodeup = new dijkstranode(coordinateup); dijkstranode nodeupright = new dijkstranode(coordinateupright); dijkstranode noderight = new dijkstranode(coordinateright); dijkstranode nodedownright = new dijkstranode(coordinatedownright); dijkstranode nodedown = new dijkstranode(coordinatedown); dijkstranode nodedownleft = new dijkstranode(coordinatedownleft); neighbornodelist.add(nodeleft); neighbornodelist.add(nodeupleft); neighbornodelist.add(nodeup); neighbornodelist.add(nodeupright); neighbornodelist.add(noderight); neighbornodelist.add(nodedownright); neighbornodelist.add(nodedown); neighbornodelist.add(nodedownleft); return neighbornodelist; }","repo":"sapols\/JPL-CUSeniorProjects","label":[0,1,0,0]}
{"id":12757,"original_code":"protected Entry getSpreadEntry(Request request, ServiceInput dpi,\n                                   Entry sample, String climstartYear,\n                                   String climendYear)\n            throws Exception {\n        Entry sprdEntry = null;\n        \/\/System.err.println(\"Creating spread\");\n        \/\/String statName = \"mean\";\n        String statName = \"ens01\";  \/\/ per Marty hoerling - just use the spread of one member\n        \/\/ Find the mean\n        List<Entry> mean = findStatisticEntry(request, sample, statName);\n        if ((mean == null) || mean.isEmpty()) {\n            \/\/System.err.println(\"Couldn't find \" + statName);\n            \/\/ TODO: Should we just exit if no mean?\n            sprdEntry = sample;\n        } else if (mean.size() > 1) {\n            System.err.println(\"found too many\");\n        } else {\n            sprdEntry = mean.get(0);\n            \/\/System.err.println(\"found mean: \" + sprdEntry);\n        }\n        \/\/sprdEntry = sample;\n        \/\/ Now make the spread from the mean\n        String stail =\n            getOutputHandler().getStorageManager().getFileTail(sprdEntry);\n        sprdEntry = makeStatistic(request, sprdEntry, dpi, stail, \"smegma\",\n                                  climstartYear, climendYear);\n        return sprdEntry;\n    }","code_wo_comment":"protected Entry getSpreadEntry(Request request, ServiceInput dpi,\n                                   Entry sample, String climstartYear,\n                                   String climendYear)\n            throws Exception {\n        Entry sprdEntry = null;\n       \n       \n        String statName = \"ens01\"; \n       \n        List<Entry> mean = findStatisticEntry(request, sample, statName);\n        if ((mean == null) || mean.isEmpty()) {\n           \n           \n            sprdEntry = sample;\n        } else if (mean.size() > 1) {\n            System.err.println(\"found too many\");\n        } else {\n            sprdEntry = mean.get(0);\n           \n        }\n       \n       \n        String stail =\n            getOutputHandler().getStorageManager().getFileTail(sprdEntry);\n        sprdEntry = makeStatistic(request, sprdEntry, dpi, stail, \"smegma\",\n                                  climstartYear, climendYear);\n        return sprdEntry;\n    }","cleancode":"protected entry getspreadentry(request request, serviceinput dpi, entry sample, string climstartyear, string climendyear) throws exception { entry sprdentry = null; string statname = \"ens01\"; list<entry> mean = findstatisticentry(request, sample, statname); if ((mean == null) || mean.isempty()) { sprdentry = sample; } else if (mean.size() > 1) { system.err.println(\"found too many\"); } else { sprdentry = mean.get(0); } string stail = getoutputhandler().getstoragemanager().getfiletail(sprdentry); sprdentry = makestatistic(request, sprdentry, dpi, stail, \"smegma\", climstartyear, climendyear); return sprdentry; }","repo":"suvarchal\/ramadda","label":[1,0,0,0]}
{"id":13239,"original_code":"private static void displayExceptionPrivate(JFrame aFrame, Throwable aE) {\n\t\tStringWriter tempStringWriter = new StringWriter();\n\t\tPrintWriter tempPrintWriter = new PrintWriter(tempStringWriter);\n\t\taE.printStackTrace(tempPrintWriter);\n\t\ttempPrintWriter.close();\n\t\tfinal JDialog tempDialog = new JDialog(aFrame, \"Error: \" + aE.getMessage());\n\t\ttempDialog.setModal(true);\n\t\tDimension tempScreen = Toolkit.getDefaultToolkit().getScreenSize();\n\t\ttempDialog.setSize(tempScreen.width \/ 2, tempScreen.height \/ 2);\n\t\ttempDialog.setLocation(tempScreen.width \/ 4, tempScreen.height \/ 4);\n\t\ttempDialog.getContentPane().setLayout(new BorderLayout());\n\t\tScrollPane tempScrollPane = new ScrollPane();\n\t\tJEditorPane tempEditorPane = new JEditorPane();\n\t\t\/\/ TODO Replace by Font.MONOSPACED with JDK 6\n\t\ttempEditorPane.setFont(new Font(\"Monospaced\", 0, aFrame.getFont().getSize()));\n\t\ttempEditorPane.setText(tempStringWriter.toString());\n\t\ttempScrollPane.add(tempEditorPane);\n\t\ttempDialog.getContentPane().add(tempScrollPane, BorderLayout.CENTER);\n\t\tAction tempActionListener = new AbstractAction(\"OK\") {\n\t\t\t@Override\n\t\t\tpublic void actionPerformed(ActionEvent aE) {\n\t\t\t\ttempDialog.dispose();\n\t\t\t}\n\t\t};\n\t\ttempDialog.getContentPane().add(createButtons(new Action[] { tempActionListener }), BorderLayout.SOUTH);\n\t\ttempDialog.setDefaultCloseOperation(JDialog.DISPOSE_ON_CLOSE);\n\t\ttempDialog.setVisible(true);\n\t}","code_wo_comment":"private static void displayExceptionPrivate(JFrame aFrame, Throwable aE) {\n\t\tStringWriter tempStringWriter = new StringWriter();\n\t\tPrintWriter tempPrintWriter = new PrintWriter(tempStringWriter);\n\t\taE.printStackTrace(tempPrintWriter);\n\t\ttempPrintWriter.close();\n\t\tfinal JDialog tempDialog = new JDialog(aFrame, \"Error: \" + aE.getMessage());\n\t\ttempDialog.setModal(true);\n\t\tDimension tempScreen = Toolkit.getDefaultToolkit().getScreenSize();\n\t\ttempDialog.setSize(tempScreen.width \/ 2, tempScreen.height \/ 2);\n\t\ttempDialog.setLocation(tempScreen.width \/ 4, tempScreen.height \/ 4);\n\t\ttempDialog.getContentPane().setLayout(new BorderLayout());\n\t\tScrollPane tempScrollPane = new ScrollPane();\n\t\tJEditorPane tempEditorPane = new JEditorPane();\n\t\n\t\ttempEditorPane.setFont(new Font(\"Monospaced\", 0, aFrame.getFont().getSize()));\n\t\ttempEditorPane.setText(tempStringWriter.toString());\n\t\ttempScrollPane.add(tempEditorPane);\n\t\ttempDialog.getContentPane().add(tempScrollPane, BorderLayout.CENTER);\n\t\tAction tempActionListener = new AbstractAction(\"OK\") {\n\t\t\t@Override\n\t\t\tpublic void actionPerformed(ActionEvent aE) {\n\t\t\t\ttempDialog.dispose();\n\t\t\t}\n\t\t};\n\t\ttempDialog.getContentPane().add(createButtons(new Action[] { tempActionListener }), BorderLayout.SOUTH);\n\t\ttempDialog.setDefaultCloseOperation(JDialog.DISPOSE_ON_CLOSE);\n\t\ttempDialog.setVisible(true);\n\t}","cleancode":"private static void displayexceptionprivate(jframe aframe, throwable ae) { stringwriter tempstringwriter = new stringwriter(); printwriter tempprintwriter = new printwriter(tempstringwriter); ae.printstacktrace(tempprintwriter); tempprintwriter.close(); final jdialog tempdialog = new jdialog(aframe, \"error: \" + ae.getmessage()); tempdialog.setmodal(true); dimension tempscreen = toolkit.getdefaulttoolkit().getscreensize(); tempdialog.setsize(tempscreen.width \/ 2, tempscreen.height \/ 2); tempdialog.setlocation(tempscreen.width \/ 4, tempscreen.height \/ 4); tempdialog.getcontentpane().setlayout(new borderlayout()); scrollpane tempscrollpane = new scrollpane(); jeditorpane tempeditorpane = new jeditorpane(); tempeditorpane.setfont(new font(\"monospaced\", 0, aframe.getfont().getsize())); tempeditorpane.settext(tempstringwriter.tostring()); tempscrollpane.add(tempeditorpane); tempdialog.getcontentpane().add(tempscrollpane, borderlayout.center); action tempactionlistener = new abstractaction(\"ok\") { @override public void actionperformed(actionevent ae) { tempdialog.dispose(); } }; tempdialog.getcontentpane().add(createbuttons(new action[] { tempactionlistener }), borderlayout.south); tempdialog.setdefaultcloseoperation(jdialog.dispose_on_close); tempdialog.setvisible(true); }","repo":"rscadrde\/projekt-task-capturing","label":[1,0,0,0]}
{"id":13240,"original_code":"private static void displayTextPrivate(JFrame aFrame, String aTitle, String aText, boolean aModalFlag, List<Action> anActions) {\n\t\tfinal JDialog tempDialog = new JDialog(aFrame, aTitle);\n\t\ttempDialog.setModal(aModalFlag);\n\t\tDimension tempScreen = Toolkit.getDefaultToolkit().getScreenSize();\n\t\ttempDialog.setSize(tempScreen.width * 4 \/ 10, tempScreen.height * 4 \/ 5);\n\t\ttempDialog.setLocation(tempScreen.width \/ 4, tempScreen.height \/ 10);\n\t\ttempDialog.getContentPane().setLayout(new BorderLayout());\n\t\tScrollPane tempScrollPane = new ScrollPane();\n\t\tJEditorPane tempEditorPane = new JEditorPane();\n\t\t\/\/ TODO Replace by Font.MONOSPACED with JDK 6\n\t\ttempEditorPane.setFont(new Font(\"Monospaced\", 0, aFrame.getFont().getSize()));\n\t\ttempEditorPane.setText(aText);\n\t\ttempScrollPane.add(tempEditorPane);\n\t\ttempDialog.getContentPane().add(tempScrollPane, BorderLayout.CENTER);\n\t\tAction tempActionListener = new AbstractAction(\"OK\") {\n\t\t\t@Override\n\t\t\tpublic void actionPerformed(ActionEvent aE) {\n\t\t\t\ttempDialog.dispose();\n\t\t\t}\n\t\t};\n\t\tList<Action> tempActions = new ArrayList<Action>();\n\t\ttempActions.add(tempActionListener);\n\t\tif (anActions != null) {\n\t\t\ttempActions.addAll(anActions);\n\t\t}\n\t\ttempDialog.getContentPane().add(createButtons(tempActions.toArray(new Action[tempActions.size()])), BorderLayout.SOUTH);\n\t\ttempDialog.setDefaultCloseOperation(JDialog.DISPOSE_ON_CLOSE);\n\t\ttempDialog.setAlwaysOnTop(false);\n\t\ttempDialog.setVisible(true);\n\t}","code_wo_comment":"private static void displayTextPrivate(JFrame aFrame, String aTitle, String aText, boolean aModalFlag, List<Action> anActions) {\n\t\tfinal JDialog tempDialog = new JDialog(aFrame, aTitle);\n\t\ttempDialog.setModal(aModalFlag);\n\t\tDimension tempScreen = Toolkit.getDefaultToolkit().getScreenSize();\n\t\ttempDialog.setSize(tempScreen.width * 4 \/ 10, tempScreen.height * 4 \/ 5);\n\t\ttempDialog.setLocation(tempScreen.width \/ 4, tempScreen.height \/ 10);\n\t\ttempDialog.getContentPane().setLayout(new BorderLayout());\n\t\tScrollPane tempScrollPane = new ScrollPane();\n\t\tJEditorPane tempEditorPane = new JEditorPane();\n\t\n\t\ttempEditorPane.setFont(new Font(\"Monospaced\", 0, aFrame.getFont().getSize()));\n\t\ttempEditorPane.setText(aText);\n\t\ttempScrollPane.add(tempEditorPane);\n\t\ttempDialog.getContentPane().add(tempScrollPane, BorderLayout.CENTER);\n\t\tAction tempActionListener = new AbstractAction(\"OK\") {\n\t\t\t@Override\n\t\t\tpublic void actionPerformed(ActionEvent aE) {\n\t\t\t\ttempDialog.dispose();\n\t\t\t}\n\t\t};\n\t\tList<Action> tempActions = new ArrayList<Action>();\n\t\ttempActions.add(tempActionListener);\n\t\tif (anActions != null) {\n\t\t\ttempActions.addAll(anActions);\n\t\t}\n\t\ttempDialog.getContentPane().add(createButtons(tempActions.toArray(new Action[tempActions.size()])), BorderLayout.SOUTH);\n\t\ttempDialog.setDefaultCloseOperation(JDialog.DISPOSE_ON_CLOSE);\n\t\ttempDialog.setAlwaysOnTop(false);\n\t\ttempDialog.setVisible(true);\n\t}","cleancode":"private static void displaytextprivate(jframe aframe, string atitle, string atext, boolean amodalflag, list<action> anactions) { final jdialog tempdialog = new jdialog(aframe, atitle); tempdialog.setmodal(amodalflag); dimension tempscreen = toolkit.getdefaulttoolkit().getscreensize(); tempdialog.setsize(tempscreen.width * 4 \/ 10, tempscreen.height * 4 \/ 5); tempdialog.setlocation(tempscreen.width \/ 4, tempscreen.height \/ 10); tempdialog.getcontentpane().setlayout(new borderlayout()); scrollpane tempscrollpane = new scrollpane(); jeditorpane tempeditorpane = new jeditorpane(); tempeditorpane.setfont(new font(\"monospaced\", 0, aframe.getfont().getsize())); tempeditorpane.settext(atext); tempscrollpane.add(tempeditorpane); tempdialog.getcontentpane().add(tempscrollpane, borderlayout.center); action tempactionlistener = new abstractaction(\"ok\") { @override public void actionperformed(actionevent ae) { tempdialog.dispose(); } }; list<action> tempactions = new arraylist<action>(); tempactions.add(tempactionlistener); if (anactions != null) { tempactions.addall(anactions); } tempdialog.getcontentpane().add(createbuttons(tempactions.toarray(new action[tempactions.size()])), borderlayout.south); tempdialog.setdefaultcloseoperation(jdialog.dispose_on_close); tempdialog.setalwaysontop(false); tempdialog.setvisible(true); }","repo":"rscadrde\/projekt-task-capturing","label":[1,0,0,0]}
{"id":21707,"original_code":"private synchronized Bitmap getBitmapFromEntryIfNeeded(String entryName, boolean recycle)\n  {\n    Bitmap bitmap = null;\n    ImageState status = imageState.get(entryName);\n    if (status == null || status.equals(ImageState.UNKNOWN))\n    {\n      ZipEntry entry = mZip.getEntry(entryName);\n      try\n      {\n        File file = extract(entry, entry.getName());\n        BitmapFactory.decodeFile(file.getPath(), bounds);\n        if (bounds.outWidth == -1)\n        {\n          \/\/ TODO: Error\n        }\n        int width = bounds.outWidth;\n        int height = bounds.outHeight;\n        boolean landscape = height > width;\n        int maxHeight = getMaxHeight(landscape);\n        int maxWidth = getMaxWidth(landscape);\n        boolean withinBounds = width <= maxWidth && height <= maxHeight;\n        if (withinBounds)\n        {\n          imageState.put(entryName, ImageState.ORIGINAL);\n        }\n        else\n        {\n          bitmap = resampleAndSave(entryName, width, height);\n        }\n      }\n      catch (Exception e)\n      {\n        e.printStackTrace();\n      }\n    }\n    if (bitmap != null && recycle)\n    {\n      bitmap.recycle();\n      return null;\n    }\n    else\n    {\n      return bitmap;\n    }\n  }","code_wo_comment":"private synchronized Bitmap getBitmapFromEntryIfNeeded(String entryName, boolean recycle)\n  {\n    Bitmap bitmap = null;\n    ImageState status = imageState.get(entryName);\n    if (status == null || status.equals(ImageState.UNKNOWN))\n    {\n      ZipEntry entry = mZip.getEntry(entryName);\n      try\n      {\n        File file = extract(entry, entry.getName());\n        BitmapFactory.decodeFile(file.getPath(), bounds);\n        if (bounds.outWidth == -1)\n        {\n         \n        }\n        int width = bounds.outWidth;\n        int height = bounds.outHeight;\n        boolean landscape = height > width;\n        int maxHeight = getMaxHeight(landscape);\n        int maxWidth = getMaxWidth(landscape);\n        boolean withinBounds = width <= maxWidth && height <= maxHeight;\n        if (withinBounds)\n        {\n          imageState.put(entryName, ImageState.ORIGINAL);\n        }\n        else\n        {\n          bitmap = resampleAndSave(entryName, width, height);\n        }\n      }\n      catch (Exception e)\n      {\n        e.printStackTrace();\n      }\n    }\n    if (bitmap != null && recycle)\n    {\n      bitmap.recycle();\n      return null;\n    }\n    else\n    {\n      return bitmap;\n    }\n  }","cleancode":"private synchronized bitmap getbitmapfromentryifneeded(string entryname, boolean recycle) { bitmap bitmap = null; imagestate status = imagestate.get(entryname); if (status == null || status.equals(imagestate.unknown)) { zipentry entry = mzip.getentry(entryname); try { file file = extract(entry, entry.getname()); bitmapfactory.decodefile(file.getpath(), bounds); if (bounds.outwidth == -1) { } int width = bounds.outwidth; int height = bounds.outheight; boolean landscape = height > width; int maxheight = getmaxheight(landscape); int maxwidth = getmaxwidth(landscape); boolean withinbounds = width <= maxwidth && height <= maxheight; if (withinbounds) { imagestate.put(entryname, imagestate.original); } else { bitmap = resampleandsave(entryname, width, height); } } catch (exception e) { e.printstacktrace(); } } if (bitmap != null && recycle) { bitmap.recycle(); return null; } else { return bitmap; } }","repo":"remco138\/ocrmangareaderforandroid","label":[0,0,1,0]}
{"id":13922,"original_code":"public void setSimpleTag() {\n    \/* TODO: clear previously-set field and avoid memory leak *\/\n    t = Tag.SIMPLE_TAG;\n  }","code_wo_comment":"public void setSimpleTag() {\n   \n    t = Tag.SIMPLE_TAG;\n  }","cleancode":"public void setsimpletag() { t = tag.simple_tag; }","repo":"syntakker\/atd","label":[0,1,0,0]}
{"id":22202,"original_code":"public EasySource getInnerText(char open, char close) {\n\t\tStringBuffer code = new StringBuffer();\n\t\tint brace_counter = 0;\n\t\twhile (true) {\n\t\t\tif (pos >= src.length) {\n\t\t\t\treturn null;\n\t\t\t}\n\t\t\tchar c = src[pos];\n\t\t\tif (c == open) { \/\/ TODO: what about open and close inside strings ?\n\t\t\t\tbrace_counter++;\n\t\t\t\t\/\/ code.appendInPlace(parse(rs, hook).src);\n\t\t\t\t\/\/ code.appendInPlace(close);\n\t\t\t}\n\t\t\tif (c == close) \/\/|| src[pos] == close)\n\t\t\t{\n\t\t\t\tif (brace_counter > 0)\n\t\t\t\t\tbrace_counter--;\n\t\t\t\telse {\n\t\t\t\t\tpos++;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tcode.append(c); \/\/ TODO: optimize\n\t\t\tpos++;\n\t\t}\n\t\treturn new EasySource(code.toString().toCharArray());\n\t}","code_wo_comment":"public EasySource getInnerText(char open, char close) {\n\t\tStringBuffer code = new StringBuffer();\n\t\tint brace_counter = 0;\n\t\twhile (true) {\n\t\t\tif (pos >= src.length) {\n\t\t\t\treturn null;\n\t\t\t}\n\t\t\tchar c = src[pos];\n\t\t\tif (c == open) {\n\t\t\t\tbrace_counter++;\n\t\t\t\n\t\t\t\n\t\t\t}\n\t\t\tif (c == close)\n\t\t\t{\n\t\t\t\tif (brace_counter > 0)\n\t\t\t\t\tbrace_counter--;\n\t\t\t\telse {\n\t\t\t\t\tpos++;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tcode.append(c);\n\t\t\tpos++;\n\t\t}\n\t\treturn new EasySource(code.toString().toCharArray());\n\t}","cleancode":"public easysource getinnertext(char open, char close) { stringbuffer code = new stringbuffer(); int brace_counter = 0; while (true) { if (pos >= src.length) { return null; } char c = src[pos]; if (c == open) { brace_counter++; } if (c == close) { if (brace_counter > 0) brace_counter--; else { pos++; break; } } code.append(c); pos++; } return new easysource(code.tostring().tochararray()); }","repo":"rhulha\/EasyLang","label":[1,0,0,0]}
{"id":14027,"original_code":"public void finalizeReports(String currentSessionId) {\n    \/\/ TODO: Need to implement procedure to skip finalizing the current session when this is\n    \/\/  called on app start, but keep the current session when called at crash time. Currently\n    \/\/  this only works when called at app start.\n    List<File> sessionDirectories = capAndGetOpenSessions(currentSessionId);\n    for (File sessionDirectory : sessionDirectories) {\n      final List<File> eventFiles =\n          getFilesInDirectory(\n              sessionDirectory, (f, name) -> name.startsWith(EVENT_FILE_NAME_PREFIX));\n      Collections.sort(eventFiles);\n      \/\/ TODO: Fix nulls\n      \/\/ Only process the session if it has associated events\n      if (!eventFiles.isEmpty()) {\n        final List<Event> events = new ArrayList<>();\n        boolean isHighPriorityReport = false;\n        for (File eventFile : eventFiles) {\n          final Event event = TRANSFORM.eventFromJson(readTextFile(eventFile));\n          isHighPriorityReport =\n              isHighPriorityReport || isHighPriorityEventFile(eventFile.getName());\n          events.add(event);\n        }\n        \/\/ FIXME: If we fail to parse the events, we'll need to bail.\n        String userId = null;\n        final File userFile = new File(sessionDirectory, USER_FILE_NAME);\n        if (userFile.exists()) {\n          userId = readTextFile(userFile);\n        }\n        CrashlyticsReport report =\n            TRANSFORM.reportFromJson(readTextFile(new File(sessionDirectory, REPORT_FILE_NAME)));\n        final String sessionId = report.getSession().getIdentifier();\n        if (userId != null) {\n          report = report.withUserId(userId);\n        }\n        final File outputDirectory =\n            prepareDirectory(isHighPriorityReport ? priorityReportsDirectory : reportsDirectory);\n        writeTextFile(\n            new File(outputDirectory, sessionId),\n            TRANSFORM.reportToJson(report.withEvents(ImmutableList.from(events))));\n      }\n      recursiveDelete(sessionDirectory);\n    }\n    capFinalizedReports();\n  }","code_wo_comment":"public void finalizeReports(String currentSessionId) {\n   \n   \n   \n    List<File> sessionDirectories = capAndGetOpenSessions(currentSessionId);\n    for (File sessionDirectory : sessionDirectories) {\n      final List<File> eventFiles =\n          getFilesInDirectory(\n              sessionDirectory, (f, name) -> name.startsWith(EVENT_FILE_NAME_PREFIX));\n      Collections.sort(eventFiles);\n     \n     \n      if (!eventFiles.isEmpty()) {\n        final List<Event> events = new ArrayList<>();\n        boolean isHighPriorityReport = false;\n        for (File eventFile : eventFiles) {\n          final Event event = TRANSFORM.eventFromJson(readTextFile(eventFile));\n          isHighPriorityReport =\n              isHighPriorityReport || isHighPriorityEventFile(eventFile.getName());\n          events.add(event);\n        }\n       \n        String userId = null;\n        final File userFile = new File(sessionDirectory, USER_FILE_NAME);\n        if (userFile.exists()) {\n          userId = readTextFile(userFile);\n        }\n        CrashlyticsReport report =\n            TRANSFORM.reportFromJson(readTextFile(new File(sessionDirectory, REPORT_FILE_NAME)));\n        final String sessionId = report.getSession().getIdentifier();\n        if (userId != null) {\n          report = report.withUserId(userId);\n        }\n        final File outputDirectory =\n            prepareDirectory(isHighPriorityReport ? priorityReportsDirectory : reportsDirectory);\n        writeTextFile(\n            new File(outputDirectory, sessionId),\n            TRANSFORM.reportToJson(report.withEvents(ImmutableList.from(events))));\n      }\n      recursiveDelete(sessionDirectory);\n    }\n    capFinalizedReports();\n  }","cleancode":"public void finalizereports(string currentsessionid) { list<file> sessiondirectories = capandgetopensessions(currentsessionid); for (file sessiondirectory : sessiondirectories) { final list<file> eventfiles = getfilesindirectory( sessiondirectory, (f, name) -> name.startswith(event_file_name_prefix)); collections.sort(eventfiles); if (!eventfiles.isempty()) { final list<event> events = new arraylist<>(); boolean ishighpriorityreport = false; for (file eventfile : eventfiles) { final event event = transform.eventfromjson(readtextfile(eventfile)); ishighpriorityreport = ishighpriorityreport || ishighpriorityeventfile(eventfile.getname()); events.add(event); } string userid = null; final file userfile = new file(sessiondirectory, user_file_name); if (userfile.exists()) { userid = readtextfile(userfile); } crashlyticsreport report = transform.reportfromjson(readtextfile(new file(sessiondirectory, report_file_name))); final string sessionid = report.getsession().getidentifier(); if (userid != null) { report = report.withuserid(userid); } final file outputdirectory = preparedirectory(ishighpriorityreport ? priorityreportsdirectory : reportsdirectory); writetextfile( new file(outputdirectory, sessionid), transform.reporttojson(report.withevents(immutablelist.from(events)))); } recursivedelete(sessiondirectory); } capfinalizedreports(); }","repo":"sevax88\/firebase-android-sdk","label":[0,1,1,0]}
{"id":30415,"original_code":"private Optional<List<Relation>> processDefaultRelation(final Relation relation,\n            final List<Long> parents)\n    {\n        final List<Relation> createdRelations = new ArrayList<>();\n        final List<RelationMember> members = new ArrayList<>();\n        boolean isModified = false;\n        for (final RelationMember member : relation.getMembers())\n        {\n            switch (member.getMemberType())\n            {\n                case Way:\n                    final List<Way> slicedWays = this.changeSet\n                            .getCreatedWays(member.getMemberId());\n                    if (slicedWays != null && !slicedWays.isEmpty())\n                    {\n                        isModified = true;\n                        slicedWays.forEach(way -> members\n                                .add(this.store.createRelationMember(member, way.getId())));\n                    }\n                    else\n                    {\n                        \/\/ Either the way is not sliced or way is outside of the supplied bound\n                        members.add(member);\n                    }\n                    break;\n                case Relation:\n                    parents.add(relation.getId());\n                    final Relation subRelation = this.store.getRelation(member.getMemberId());\n                    \/\/ Check if we have the sub-relation in the store\n                    if (subRelation == null)\n                    {\n                        \/\/ Put the member back into the relation. Missing members will be handled\n                        \/\/ on a case by case basis\n                        members.add(member);\n                        break;\n                    }\n                    final Optional<List<Relation>> slicedMembers;\n                    if (!parents.contains(subRelation.getId()))\n                    {\n                        slicedMembers = sliceRelation(subRelation, parents);\n                    }\n                    else\n                    {\n                        logger.error(\"Relation {} has a loop! Parent tree: {}\", subRelation.getId(),\n                                parents);\n                        slicedMembers = Optional.empty();\n                    }\n                    if (slicedMembers.isPresent())\n                    {\n                        isModified = true;\n                        slicedMembers.get().forEach(slicedRelation ->\n                        {\n                            members.add(this.store.createRelationMember(member,\n                                    slicedRelation.getId()));\n                        });\n                    }\n                    else\n                    {\n                        members.add(member);\n                    }\n                    break;\n                default:\n                    \/\/ Here we are not checking the bound, because we are assuming all data\n                    \/\/ outside of bound has already been filtered out and doesn't exist in the\n                    \/\/ PbfMemoryStore\n                    members.add(member);\n                    break;\n            }\n        }\n        if (isModified)\n        {\n            \/\/ Modified by way slicing or relation slicing\n            this.changeSet.addModifiedRelation(relation);\n        }\n        \/\/ Group entities by country\n        final Map<String, List<RelationMember>> countryEntityMap = members.stream()\n                .collect(Collectors.groupingBy(member ->\n                {\n                    final Entity entity = this.store.getEntity(member);\n                    if (Objects.isNull(entity))\n                    {\n                        return ISOCountryTag.COUNTRY_MISSING;\n                    }\n                    else\n                    {\n                        final Optional<Tag> countryCodeTag = entity.getTags().stream()\n                                .filter(tag -> tag.getKey().equals(ISOCountryTag.KEY)).findFirst();\n                        if (countryCodeTag.isPresent())\n                        {\n                            return countryCodeTag.get().getValue();\n                        }\n                        else\n                        {\n                            return ISOCountryTag.COUNTRY_MISSING;\n                        }\n                    }\n                }));\n        final List<RelationMember> memberWithoutCountry;\n        if (countryEntityMap.containsKey(ISOCountryTag.COUNTRY_MISSING))\n        {\n            memberWithoutCountry = countryEntityMap.remove(ISOCountryTag.COUNTRY_MISSING);\n        }\n        else\n        {\n            memberWithoutCountry = Collections.emptyList();\n        }\n        final int countryCount = countryEntityMap.size();\n        if (countryCount == 0)\n        {\n            relation.getTags().add(new Tag(ISOCountryTag.KEY, ISOCountryTag.COUNTRY_MISSING));\n            return Optional.empty();\n        }\n        else if (countryCount == 1)\n        {\n            \/\/ One country code found, assign it\n            relation.getTags()\n                    .add(new Tag(ISOCountryTag.KEY, countryEntityMap.keySet().iterator().next()));\n            return Optional.empty();\n        }\n        else\n        {\n            \/\/ Muliple country codes found, implies relation crosses countries. As a 2 dimensional\n            \/\/ feature, relation sliced should not have more than one piece for each country. For\n            \/\/ now, for features without a country code (nodes and feature not covered by any\n            \/\/ boundary), we put a copy for every sliced piece to ensure integrity.\n            RuntimeCounter.relationSliced();\n            this.changeSet.addDeletedRelation(relation);\n            final CountrySlicingIdentifierFactory relationIdFactory = new CountrySlicingIdentifierFactory(\n                    relation.getId());\n            countryEntityMap.entrySet().forEach(entry ->\n            {\n                final List<RelationMember> candidateMembers = new ArrayList<>();\n                candidateMembers.addAll(entry.getValue());\n                candidateMembers.addAll(memberWithoutCountry);\n                if (!candidateMembers.isEmpty())\n                {\n                    final Relation relationToAdd = this.store.createRelation(relation,\n                            relationIdFactory.nextIdentifier(), candidateMembers);\n                    \/\/ TODO Consider sharing CountryCode Tag objects\n                    relationToAdd.getTags().add(new Tag(ISOCountryTag.KEY, entry.getKey()));\n                    createdRelations.add(relationToAdd);\n                    this.changeSet.addCreatedRelation(relationToAdd);\n                }\n            });\n        }\n        return Optional.of(createdRelations);\n    }","code_wo_comment":"private Optional<List<Relation>> processDefaultRelation(final Relation relation,\n            final List<Long> parents)\n    {\n        final List<Relation> createdRelations = new ArrayList<>();\n        final List<RelationMember> members = new ArrayList<>();\n        boolean isModified = false;\n        for (final RelationMember member : relation.getMembers())\n        {\n            switch (member.getMemberType())\n            {\n                case Way:\n                    final List<Way> slicedWays = this.changeSet\n                            .getCreatedWays(member.getMemberId());\n                    if (slicedWays != null && !slicedWays.isEmpty())\n                    {\n                        isModified = true;\n                        slicedWays.forEach(way -> members\n                                .add(this.store.createRelationMember(member, way.getId())));\n                    }\n                    else\n                    {\n                       \n                        members.add(member);\n                    }\n                    break;\n                case Relation:\n                    parents.add(relation.getId());\n                    final Relation subRelation = this.store.getRelation(member.getMemberId());\n                   \n                    if (subRelation == null)\n                    {\n                       \n                       \n                        members.add(member);\n                        break;\n                    }\n                    final Optional<List<Relation>> slicedMembers;\n                    if (!parents.contains(subRelation.getId()))\n                    {\n                        slicedMembers = sliceRelation(subRelation, parents);\n                    }\n                    else\n                    {\n                        logger.error(\"Relation {} has a loop! Parent tree: {}\", subRelation.getId(),\n                                parents);\n                        slicedMembers = Optional.empty();\n                    }\n                    if (slicedMembers.isPresent())\n                    {\n                        isModified = true;\n                        slicedMembers.get().forEach(slicedRelation ->\n                        {\n                            members.add(this.store.createRelationMember(member,\n                                    slicedRelation.getId()));\n                        });\n                    }\n                    else\n                    {\n                        members.add(member);\n                    }\n                    break;\n                default:\n                   \n                   \n                   \n                    members.add(member);\n                    break;\n            }\n        }\n        if (isModified)\n        {\n           \n            this.changeSet.addModifiedRelation(relation);\n        }\n       \n        final Map<String, List<RelationMember>> countryEntityMap = members.stream()\n                .collect(Collectors.groupingBy(member ->\n                {\n                    final Entity entity = this.store.getEntity(member);\n                    if (Objects.isNull(entity))\n                    {\n                        return ISOCountryTag.COUNTRY_MISSING;\n                    }\n                    else\n                    {\n                        final Optional<Tag> countryCodeTag = entity.getTags().stream()\n                                .filter(tag -> tag.getKey().equals(ISOCountryTag.KEY)).findFirst();\n                        if (countryCodeTag.isPresent())\n                        {\n                            return countryCodeTag.get().getValue();\n                        }\n                        else\n                        {\n                            return ISOCountryTag.COUNTRY_MISSING;\n                        }\n                    }\n                }));\n        final List<RelationMember> memberWithoutCountry;\n        if (countryEntityMap.containsKey(ISOCountryTag.COUNTRY_MISSING))\n        {\n            memberWithoutCountry = countryEntityMap.remove(ISOCountryTag.COUNTRY_MISSING);\n        }\n        else\n        {\n            memberWithoutCountry = Collections.emptyList();\n        }\n        final int countryCount = countryEntityMap.size();\n        if (countryCount == 0)\n        {\n            relation.getTags().add(new Tag(ISOCountryTag.KEY, ISOCountryTag.COUNTRY_MISSING));\n            return Optional.empty();\n        }\n        else if (countryCount == 1)\n        {\n           \n            relation.getTags()\n                    .add(new Tag(ISOCountryTag.KEY, countryEntityMap.keySet().iterator().next()));\n            return Optional.empty();\n        }\n        else\n        {\n           \n           \n           \n           \n            RuntimeCounter.relationSliced();\n            this.changeSet.addDeletedRelation(relation);\n            final CountrySlicingIdentifierFactory relationIdFactory = new CountrySlicingIdentifierFactory(\n                    relation.getId());\n            countryEntityMap.entrySet().forEach(entry ->\n            {\n                final List<RelationMember> candidateMembers = new ArrayList<>();\n                candidateMembers.addAll(entry.getValue());\n                candidateMembers.addAll(memberWithoutCountry);\n                if (!candidateMembers.isEmpty())\n                {\n                    final Relation relationToAdd = this.store.createRelation(relation,\n                            relationIdFactory.nextIdentifier(), candidateMembers);\n                   \n                    relationToAdd.getTags().add(new Tag(ISOCountryTag.KEY, entry.getKey()));\n                    createdRelations.add(relationToAdd);\n                    this.changeSet.addCreatedRelation(relationToAdd);\n                }\n            });\n        }\n        return Optional.of(createdRelations);\n    }","cleancode":"private optional<list<relation>> processdefaultrelation(final relation relation, final list<long> parents) { final list<relation> createdrelations = new arraylist<>(); final list<relationmember> members = new arraylist<>(); boolean ismodified = false; for (final relationmember member : relation.getmembers()) { switch (member.getmembertype()) { case way: final list<way> slicedways = this.changeset .getcreatedways(member.getmemberid()); if (slicedways != null && !slicedways.isempty()) { ismodified = true; slicedways.foreach(way -> members .add(this.store.createrelationmember(member, way.getid()))); } else { members.add(member); } break; case relation: parents.add(relation.getid()); final relation subrelation = this.store.getrelation(member.getmemberid()); if (subrelation == null) { members.add(member); break; } final optional<list<relation>> slicedmembers; if (!parents.contains(subrelation.getid())) { slicedmembers = slicerelation(subrelation, parents); } else { logger.error(\"relation {} has a loop! parent tree: {}\", subrelation.getid(), parents); slicedmembers = optional.empty(); } if (slicedmembers.ispresent()) { ismodified = true; slicedmembers.get().foreach(slicedrelation -> { members.add(this.store.createrelationmember(member, slicedrelation.getid())); }); } else { members.add(member); } break; default: members.add(member); break; } } if (ismodified) { this.changeset.addmodifiedrelation(relation); } final map<string, list<relationmember>> countryentitymap = members.stream() .collect(collectors.groupingby(member -> { final entity entity = this.store.getentity(member); if (objects.isnull(entity)) { return isocountrytag.country_missing; } else { final optional<tag> countrycodetag = entity.gettags().stream() .filter(tag -> tag.getkey().equals(isocountrytag.key)).findfirst(); if (countrycodetag.ispresent()) { return countrycodetag.get().getvalue(); } else { return isocountrytag.country_missing; } } })); final list<relationmember> memberwithoutcountry; if (countryentitymap.containskey(isocountrytag.country_missing)) { memberwithoutcountry = countryentitymap.remove(isocountrytag.country_missing); } else { memberwithoutcountry = collections.emptylist(); } final int countrycount = countryentitymap.size(); if (countrycount == 0) { relation.gettags().add(new tag(isocountrytag.key, isocountrytag.country_missing)); return optional.empty(); } else if (countrycount == 1) { relation.gettags() .add(new tag(isocountrytag.key, countryentitymap.keyset().iterator().next())); return optional.empty(); } else { runtimecounter.relationsliced(); this.changeset.adddeletedrelation(relation); final countryslicingidentifierfactory relationidfactory = new countryslicingidentifierfactory( relation.getid()); countryentitymap.entryset().foreach(entry -> { final list<relationmember> candidatemembers = new arraylist<>(); candidatemembers.addall(entry.getvalue()); candidatemembers.addall(memberwithoutcountry); if (!candidatemembers.isempty()) { final relation relationtoadd = this.store.createrelation(relation, relationidfactory.nextidentifier(), candidatemembers); relationtoadd.gettags().add(new tag(isocountrytag.key, entry.getkey())); createdrelations.add(relationtoadd); this.changeset.addcreatedrelation(relationtoadd); } }); } return optional.of(createdrelations); }","repo":"savannahostrowski\/atlas","label":[1,0,0,0]}
{"id":14066,"original_code":"@JsonGetter(\"accessToken\")\n    public String getAccessToken ( ) { \n        return this.accessToken;\n    }","code_wo_comment":"@JsonGetter(\"accessToken\")\n    public String getAccessToken ( ) { \n        return this.accessToken;\n    }","cleancode":"@jsongetter(\"accesstoken\") public string getaccesstoken ( ) { return this.accesstoken; }","repo":"serkaneren78\/konkod-android-sdk","label":[0,0,0,0]}
{"id":14067,"original_code":"@JsonSetter(\"accessToken\")\n    public void setAccessToken (String value) { \n        this.accessToken = value;\n        notifyObservers(this.accessToken);\n    }","code_wo_comment":"@JsonSetter(\"accessToken\")\n    public void setAccessToken (String value) { \n        this.accessToken = value;\n        notifyObservers(this.accessToken);\n    }","cleancode":"@jsonsetter(\"accesstoken\") public void setaccesstoken (string value) { this.accesstoken = value; notifyobservers(this.accesstoken); }","repo":"serkaneren78\/konkod-android-sdk","label":[0,0,0,0]}
{"id":14068,"original_code":"@JsonGetter(\"tokeType\")\n    public String getTokeType ( ) { \n        return this.tokeType;\n    }","code_wo_comment":"@JsonGetter(\"tokeType\")\n    public String getTokeType ( ) { \n        return this.tokeType;\n    }","cleancode":"@jsongetter(\"toketype\") public string gettoketype ( ) { return this.toketype; }","repo":"serkaneren78\/konkod-android-sdk","label":[0,0,0,0]}
{"id":14069,"original_code":"@JsonSetter(\"tokeType\")\n    public void setTokeType (String value) { \n        this.tokeType = value;\n        notifyObservers(this.tokeType);\n    }","code_wo_comment":"@JsonSetter(\"tokeType\")\n    public void setTokeType (String value) { \n        this.tokeType = value;\n        notifyObservers(this.tokeType);\n    }","cleancode":"@jsonsetter(\"toketype\") public void settoketype (string value) { this.toketype = value; notifyobservers(this.toketype); }","repo":"serkaneren78\/konkod-android-sdk","label":[0,0,0,0]}
{"id":14070,"original_code":"@JsonGetter(\"expiresIn\")\n    public Long getExpiresIn ( ) { \n        return this.expiresIn;\n    }","code_wo_comment":"@JsonGetter(\"expiresIn\")\n    public Long getExpiresIn ( ) { \n        return this.expiresIn;\n    }","cleancode":"@jsongetter(\"expiresin\") public long getexpiresin ( ) { return this.expiresin; }","repo":"serkaneren78\/konkod-android-sdk","label":[0,0,0,0]}
{"id":14071,"original_code":"@JsonSetter(\"expiresIn\")\n    public void setExpiresIn (Long value) { \n        this.expiresIn = value;\n        notifyObservers(this.expiresIn);\n    }","code_wo_comment":"@JsonSetter(\"expiresIn\")\n    public void setExpiresIn (Long value) { \n        this.expiresIn = value;\n        notifyObservers(this.expiresIn);\n    }","cleancode":"@jsonsetter(\"expiresin\") public void setexpiresin (long value) { this.expiresin = value; notifyobservers(this.expiresin); }","repo":"serkaneren78\/konkod-android-sdk","label":[0,0,0,0]}
{"id":30633,"original_code":"public static SourceFileModule resolve(File rootDir, File dir, String target) throws IOException, JSONException {\n        \/\/ NOTE(Zhen): Ignore CoreModule for now to enable a more flexible semantic modeling\n        \/\/ if (NodejsRequiredCoreModule.isCoreModule(target)) return NodejsRequiredCoreModule.make(target);\n        if (target.startsWith(\".\/\") || target.startsWith(\"\/\") || target.startsWith(\"..\/\")) {\n            SourceFileModule module = loadAsFile(rootDir, new File(dir, target));\n            if (module != null) return module;\n            module = loadAsDirectory(rootDir, new File(dir, target));\n            if (module != null) return module;\n        }\n        \/\/ NOTE(Zhen): it is not very useful to throw exception...\n        return loadNodeModules(rootDir, dir, target);\n    }","code_wo_comment":"public static SourceFileModule resolve(File rootDir, File dir, String target) throws IOException, JSONException {\n       \n       \n        if (target.startsWith(\".\/\") || target.startsWith(\"\/\") || target.startsWith(\"..\/\")) {\n            SourceFileModule module = loadAsFile(rootDir, new File(dir, target));\n            if (module != null) return module;\n            module = loadAsDirectory(rootDir, new File(dir, target));\n            if (module != null) return module;\n        }\n       \n        return loadNodeModules(rootDir, dir, target);\n    }","cleancode":"public static sourcefilemodule resolve(file rootdir, file dir, string target) throws ioexception, jsonexception { if (target.startswith(\".\/\") || target.startswith(\"\/\") || target.startswith(\"..\/\")) { sourcefilemodule module = loadasfile(rootdir, new file(dir, target)); if (module != null) return module; module = loadasdirectory(rootdir, new file(dir, target)); if (module != null) return module; } return loadnodemodules(rootdir, dir, target); }","repo":"semantic-graph\/js2graph","label":[1,0,0,0]}
{"id":22463,"original_code":"private String prepareHeadersAndBodyForService(HttpServletRequest request, String method, String url,\n                                                   List<String> clientRequestHeaders, Interactor.Interaction interaction,\n                                                   String clientRequestContentType,\n                                                   InteractionManipulations interactionManipulations) throws IOException {\n        Enumeration<String> hdrs = request.getHeaderNames();\n        ServletInputStream is = request.getInputStream();\n        Object clientRequestBody = null;\n        \/\/if (is.available() > 0) {\n            if (isText(clientRequestContentType)) {\n                clientRequestBody = null;\n                String characterEncoding = request.getCharacterEncoding();\n                if (characterEncoding == null) {\n                    characterEncoding = \"utf-8\";\n                }\n                try (Scanner scanner = new Scanner(is, characterEncoding)) {\n                    if(scanner.hasNext()) {\n                        clientRequestBody = scanner.useDelimiter(\"\\\\A\").next();\n                    }\n                }\n                if (shouldHavePrettyPrintedTextBodies() && clientRequestBody != null) {\n                    clientRequestBody = prettifyDocOrNot((String) clientRequestBody);\n                }\n            } else if(is.available() > 0){\n                byte[] targetArray = new byte[is.available()];\n                is.read(targetArray);\n                clientRequestBody = targetArray;\n            }\n        \/\/}\n        while (hdrs.hasMoreElements()) {\n            \/\/ TODO - make this cater for multiple lines with the same name\n            String hdrName = hdrs.nextElement();\n            String hdrVal = request.getHeader(hdrName);\n            hdrVal = interactionManipulations.headerReplacement(hdrName, hdrVal);\n            final String fullHeader = (getLowerCaseHeaders() ? hdrName.toLowerCase() : hdrName) + \": \" + hdrVal;\n            clientRequestHeaders.add(fullHeader);\n            interactionManipulations.changeSingleHeaderForRequestToService(method, fullHeader, clientRequestHeaders);\n        }\n        interactionManipulations.changeAnyHeadersForRequestToService(clientRequestHeaders);\n        if (clientRequestBody instanceof String) {\n            clientRequestBody = interactionManipulations.changeBodyForRequestToService((String) clientRequestBody);\n        }\n        if (clientRequestBody == null) {\n            clientRequestBody = \"\";\n        }\n        interaction.noteClientRequestHeadersAndBody(clientRequestHeaders, clientRequestBody, clientRequestContentType);\n        return interactionManipulations.changeUrlForRequestToService(url);\n    }","code_wo_comment":"private String prepareHeadersAndBodyForService(HttpServletRequest request, String method, String url,\n                                                   List<String> clientRequestHeaders, Interactor.Interaction interaction,\n                                                   String clientRequestContentType,\n                                                   InteractionManipulations interactionManipulations) throws IOException {\n        Enumeration<String> hdrs = request.getHeaderNames();\n        ServletInputStream is = request.getInputStream();\n        Object clientRequestBody = null;\n       \n            if (isText(clientRequestContentType)) {\n                clientRequestBody = null;\n                String characterEncoding = request.getCharacterEncoding();\n                if (characterEncoding == null) {\n                    characterEncoding = \"utf-8\";\n                }\n                try (Scanner scanner = new Scanner(is, characterEncoding)) {\n                    if(scanner.hasNext()) {\n                        clientRequestBody = scanner.useDelimiter(\"\\\\A\").next();\n                    }\n                }\n                if (shouldHavePrettyPrintedTextBodies() && clientRequestBody != null) {\n                    clientRequestBody = prettifyDocOrNot((String) clientRequestBody);\n                }\n            } else if(is.available() > 0){\n                byte[] targetArray = new byte[is.available()];\n                is.read(targetArray);\n                clientRequestBody = targetArray;\n            }\n       \n        while (hdrs.hasMoreElements()) {\n           \n            String hdrName = hdrs.nextElement();\n            String hdrVal = request.getHeader(hdrName);\n            hdrVal = interactionManipulations.headerReplacement(hdrName, hdrVal);\n            final String fullHeader = (getLowerCaseHeaders() ? hdrName.toLowerCase() : hdrName) + \": \" + hdrVal;\n            clientRequestHeaders.add(fullHeader);\n            interactionManipulations.changeSingleHeaderForRequestToService(method, fullHeader, clientRequestHeaders);\n        }\n        interactionManipulations.changeAnyHeadersForRequestToService(clientRequestHeaders);\n        if (clientRequestBody instanceof String) {\n            clientRequestBody = interactionManipulations.changeBodyForRequestToService((String) clientRequestBody);\n        }\n        if (clientRequestBody == null) {\n            clientRequestBody = \"\";\n        }\n        interaction.noteClientRequestHeadersAndBody(clientRequestHeaders, clientRequestBody, clientRequestContentType);\n        return interactionManipulations.changeUrlForRequestToService(url);\n    }","cleancode":"private string prepareheadersandbodyforservice(httpservletrequest request, string method, string url, list<string> clientrequestheaders, interactor.interaction interaction, string clientrequestcontenttype, interactionmanipulations interactionmanipulations) throws ioexception { enumeration<string> hdrs = request.getheadernames(); servletinputstream is = request.getinputstream(); object clientrequestbody = null; if (istext(clientrequestcontenttype)) { clientrequestbody = null; string characterencoding = request.getcharacterencoding(); if (characterencoding == null) { characterencoding = \"utf-8\"; } try (scanner scanner = new scanner(is, characterencoding)) { if(scanner.hasnext()) { clientrequestbody = scanner.usedelimiter(\"\\\\a\").next(); } } if (shouldhaveprettyprintedtextbodies() && clientrequestbody != null) { clientrequestbody = prettifydocornot((string) clientrequestbody); } } else if(is.available() > 0){ byte[] targetarray = new byte[is.available()]; is.read(targetarray); clientrequestbody = targetarray; } while (hdrs.hasmoreelements()) { string hdrname = hdrs.nextelement(); string hdrval = request.getheader(hdrname); hdrval = interactionmanipulations.headerreplacement(hdrname, hdrval); final string fullheader = (getlowercaseheaders() ? hdrname.tolowercase() : hdrname) + \": \" + hdrval; clientrequestheaders.add(fullheader); interactionmanipulations.changesingleheaderforrequesttoservice(method, fullheader, clientrequestheaders); } interactionmanipulations.changeanyheadersforrequesttoservice(clientrequestheaders); if (clientrequestbody instanceof string) { clientrequestbody = interactionmanipulations.changebodyforrequesttoservice((string) clientrequestbody); } if (clientrequestbody == null) { clientrequestbody = \"\"; } interaction.noteclientrequestheadersandbody(clientrequestheaders, clientrequestbody, clientrequestcontenttype); return interactionmanipulations.changeurlforrequesttoservice(url); }","repo":"rogerfsg\/servirtium","label":[1,0,0,0]}
{"id":14278,"original_code":"private void doWelcome(Session session) {\n        if (! session.isInteractive()) {\n            return;\n        }\n        File confDir = getConfigDirectory();\n        File welcomeFile = new File(confDir, \".welcome\");\n        if (welcomeFile.exists()) {\n            return;\n        }\n        \/*\n         * Create the welcome file since we are going to welcome them!\n         *\/\n        try {\n            welcomeFile.createNewFile();\n        }\n        catch (IOException e) {\n            System.err.println(\"WARNING: Failed to create \" + welcomeFile \n                + \": \" + e.getMessage());\n            return;\n        }\n        \/*\n         * Here's a hack.  The \".welcome\" file is a recent change to jsqsh, and\n         * we don't want to do the whole welcome thing if an existing jsqsh user\n         * already has a ~\/.jsqsh but doesn't have a .welcome file in it. To avoid\n         * this, check to see if drivers.xml is older than the date at which this\n         * comment was written and don't do the setup activities.\n         *\/\n        File driversFile = new File(confDir, \"drivers.xml\");\n        if (driversFile.exists())\n        {\n            long lastModified = driversFile.lastModified();\n            \/*\n             * Directory was created prior to \"now\" (when I am typing this comment),\n             * so pretend the welcome was done\n             *\/\n            if (lastModified < 1392411017075L) {\n                return;\n            }\n        }\n        HelpTopic welcome = helpManager.getTopic(\"welcome\");\n        System.out.println(welcome.getHelp());\n        session.out.println();\n        session.out.println(\"You will now enter the jsqsh setup wizard.\");\n        try {\n            getConsole().readline(\"Hit enter to continue: \", false);\n            Command command = session.getCommandManager().getCommand(\"\\\\setup\");\n            command.execute(session, new String [] { });\n        }\n        catch (Exception e) {\n            \/* NOT SURE WHAT TO DO HERE *\/\n            e.printStackTrace();\n        }\n    }","code_wo_comment":"private void doWelcome(Session session) {\n        if (! session.isInteractive()) {\n            return;\n        }\n        File confDir = getConfigDirectory();\n        File welcomeFile = new File(confDir, \".welcome\");\n        if (welcomeFile.exists()) {\n            return;\n        }\n       \n        try {\n            welcomeFile.createNewFile();\n        }\n        catch (IOException e) {\n            System.err.println(\"WARNING: Failed to create \" + welcomeFile \n                + \": \" + e.getMessage());\n            return;\n        }\n       \n        File driversFile = new File(confDir, \"drivers.xml\");\n        if (driversFile.exists())\n        {\n            long lastModified = driversFile.lastModified();\n           \n            if (lastModified < 1392411017075L) {\n                return;\n            }\n        }\n        HelpTopic welcome = helpManager.getTopic(\"welcome\");\n        System.out.println(welcome.getHelp());\n        session.out.println();\n        session.out.println(\"You will now enter the jsqsh setup wizard.\");\n        try {\n            getConsole().readline(\"Hit enter to continue: \", false);\n            Command command = session.getCommandManager().getCommand(\"\\\\setup\");\n            command.execute(session, new String [] { });\n        }\n        catch (Exception e) {\n           \n            e.printStackTrace();\n        }\n    }","cleancode":"private void dowelcome(session session) { if (! session.isinteractive()) { return; } file confdir = getconfigdirectory(); file welcomefile = new file(confdir, \".welcome\"); if (welcomefile.exists()) { return; } try { welcomefile.createnewfile(); } catch (ioexception e) { system.err.println(\"warning: failed to create \" + welcomefile + \": \" + e.getmessage()); return; } file driversfile = new file(confdir, \"drivers.xml\"); if (driversfile.exists()) { long lastmodified = driversfile.lastmodified(); if (lastmodified < 1392411017075l) { return; } } helptopic welcome = helpmanager.gettopic(\"welcome\"); system.out.println(welcome.gethelp()); session.out.println(); session.out.println(\"you will now enter the jsqsh setup wizard.\"); try { getconsole().readline(\"hit enter to continue: \", false); command command = session.getcommandmanager().getcommand(\"\\\\setup\"); command.execute(session, new string [] { }); } catch (exception e) { e.printstacktrace(); } }","repo":"scottwakeling\/jsqsh","label":[1,0,0,0]}
{"id":14375,"original_code":"private void networkNameMouseClicked(java.awt.event.MouseEvent evt) {\/\/GEN-FIRST:event_networkNameMouseClicked\n        \/\/ TODO add your handling code here:\n    \/\/    jTextField1.setText(\"\");\n    }","code_wo_comment":"private void networkNameMouseClicked(java.awt.event.MouseEvent evt) {       \n   \n    }","cleancode":"private void networknamemouseclicked(java.awt.event.mouseevent evt) { }","repo":"rohit-khokle\/Medicare","label":[0,1,0,0]}
{"id":22631,"original_code":"public static ExchangeUnitAuxiliaryInputStatistics getAuxiliaryStatisticsWithVPra(KepProblemData<ExchangeUnit,DonorEdge> kepProblemData){\n\t\tAuxiliaryInputStatistics<ExchangeUnit,DonorEdge> regular = getAuxiliaryStatistics(kepProblemData);\n\t\tList<Donor> donors = new ArrayList<Donor>();\n\t\tList<Receiver> receivers = new ArrayList<Receiver>();\n\t\tfor(ExchangeUnit unit: kepProblemData.getGraph().getVertices()){\n\t\t\tfor(Donor donor: unit.getDonor()){\n\t\t\t\tdonors.add(donor);\n\t\t\t}\n\t\t\tif(!kepProblemData.getRootNodes().contains(unit)){\n\t\t\t\treceivers.add(unit.getReceiver());\n\t\t\t}\n\t\t}\t\t\n\t\tImmutableMap.Builder<Receiver,Double> builder = ImmutableMap.<Receiver,Double>builder();\n\t\tfor(Receiver receiver: receivers){\n\t\t\tint count = 0;\n\t\t\tfor(Donor donor: donors){\n\t\t\t\tif(!receiver.getTissueTypeSensitivity().isCompatible(donor.getTissueType())){\n\t\t\t\t\tcount++;\n\t\t\t\t}\n\t\t\t}\n\t\t\tbuilder.put(receiver, 100*count\/(double)donors.size());\n\t\t}\n\t\treturn new ExchangeUnitAuxiliaryInputStatistics(\n\t\t\t\tregular.getDonorPowerPostPreference(), \n\t\t\t\tregular.getReceiverPowerPostPreference(),\n\t\t\t\tbuilder.build()) ;\n\t}","code_wo_comment":"public static ExchangeUnitAuxiliaryInputStatistics getAuxiliaryStatisticsWithVPra(KepProblemData<ExchangeUnit,DonorEdge> kepProblemData){\n\t\tAuxiliaryInputStatistics<ExchangeUnit,DonorEdge> regular = getAuxiliaryStatistics(kepProblemData);\n\t\tList<Donor> donors = new ArrayList<Donor>();\n\t\tList<Receiver> receivers = new ArrayList<Receiver>();\n\t\tfor(ExchangeUnit unit: kepProblemData.getGraph().getVertices()){\n\t\t\tfor(Donor donor: unit.getDonor()){\n\t\t\t\tdonors.add(donor);\n\t\t\t}\n\t\t\tif(!kepProblemData.getRootNodes().contains(unit)){\n\t\t\t\treceivers.add(unit.getReceiver());\n\t\t\t}\n\t\t}\t\t\n\t\tImmutableMap.Builder<Receiver,Double> builder = ImmutableMap.<Receiver,Double>builder();\n\t\tfor(Receiver receiver: receivers){\n\t\t\tint count = 0;\n\t\t\tfor(Donor donor: donors){\n\t\t\t\tif(!receiver.getTissueTypeSensitivity().isCompatible(donor.getTissueType())){\n\t\t\t\t\tcount++;\n\t\t\t\t}\n\t\t\t}\n\t\t\tbuilder.put(receiver, 100*count\/(double)donors.size());\n\t\t}\n\t\treturn new ExchangeUnitAuxiliaryInputStatistics(\n\t\t\t\tregular.getDonorPowerPostPreference(), \n\t\t\t\tregular.getReceiverPowerPostPreference(),\n\t\t\t\tbuilder.build()) ;\n\t}","cleancode":"public static exchangeunitauxiliaryinputstatistics getauxiliarystatisticswithvpra(kepproblemdata<exchangeunit,donoredge> kepproblemdata){ auxiliaryinputstatistics<exchangeunit,donoredge> regular = getauxiliarystatistics(kepproblemdata); list<donor> donors = new arraylist<donor>(); list<receiver> receivers = new arraylist<receiver>(); for(exchangeunit unit: kepproblemdata.getgraph().getvertices()){ for(donor donor: unit.getdonor()){ donors.add(donor); } if(!kepproblemdata.getrootnodes().contains(unit)){ receivers.add(unit.getreceiver()); } } immutablemap.builder<receiver,double> builder = immutablemap.<receiver,double>builder(); for(receiver receiver: receivers){ int count = 0; for(donor donor: donors){ if(!receiver.gettissuetypesensitivity().iscompatible(donor.gettissuetype())){ count++; } } builder.put(receiver, 100*count\/(double)donors.size()); } return new exchangeunitauxiliaryinputstatistics( regular.getdonorpowerpostpreference(), regular.getreceiverpowerpostpreference(), builder.build()) ; }","repo":"rma350\/kidneyExchange","label":[1,0,0,0]}
{"id":14588,"original_code":"public void testSolve() {\n        RealMatrixImpl m = new RealMatrixImpl(testData);\n        RealMatrix mInv = new RealMatrixImpl(testDataInv);\n        \/\/ being a bit slothful here -- actually testing that X = A^-1 * B\n        assertClose(\"inverse-operate\",mInv.operate(testVector),\n            m.solve(testVector),normTolerance);\n        try {\n            m.solve(testVector2);\n            fail(\"expecting IllegalArgumentException\");\n        } catch (IllegalArgumentException ex) {\n            ;\n        }       \n        RealMatrix bs = new RealMatrixImpl(bigSingular);\n        try {\n            bs.solve(bs);\n            fail(\"Expecting InvalidMatrixException\");\n        } catch (InvalidMatrixException ex) {\n            ;\n        }\n        try {\n            m.solve(bs);\n            fail(\"Expecting IllegalArgumentException\");\n        } catch (IllegalArgumentException ex) {\n            ;\n        }\n        try {\n            new RealMatrixImpl(testData2).solve(bs);\n            fail(\"Expecting illegalArgumentException\");\n        } catch (IllegalArgumentException ex) {\n            ;\n        } \n        try {\n            (new RealMatrixImpl(testData2)).luDecompose();\n            fail(\"Expecting InvalidMatrixException\");\n        } catch (InvalidMatrixException ex) {\n            ;\n        }  \n    }","code_wo_comment":"public void testSolve() {\n        RealMatrixImpl m = new RealMatrixImpl(testData);\n        RealMatrix mInv = new RealMatrixImpl(testDataInv);\n       \n        assertClose(\"inverse-operate\",mInv.operate(testVector),\n            m.solve(testVector),normTolerance);\n        try {\n            m.solve(testVector2);\n            fail(\"expecting IllegalArgumentException\");\n        } catch (IllegalArgumentException ex) {\n            ;\n        }       \n        RealMatrix bs = new RealMatrixImpl(bigSingular);\n        try {\n            bs.solve(bs);\n            fail(\"Expecting InvalidMatrixException\");\n        } catch (InvalidMatrixException ex) {\n            ;\n        }\n        try {\n            m.solve(bs);\n            fail(\"Expecting IllegalArgumentException\");\n        } catch (IllegalArgumentException ex) {\n            ;\n        }\n        try {\n            new RealMatrixImpl(testData2).solve(bs);\n            fail(\"Expecting illegalArgumentException\");\n        } catch (IllegalArgumentException ex) {\n            ;\n        } \n        try {\n            (new RealMatrixImpl(testData2)).luDecompose();\n            fail(\"Expecting InvalidMatrixException\");\n        } catch (InvalidMatrixException ex) {\n            ;\n        }  \n    }","cleancode":"public void testsolve() { realmatriximpl m = new realmatriximpl(testdata); realmatrix minv = new realmatriximpl(testdatainv); assertclose(\"inverse-operate\",minv.operate(testvector), m.solve(testvector),normtolerance); try { m.solve(testvector2); fail(\"expecting illegalargumentexception\"); } catch (illegalargumentexception ex) { ; } realmatrix bs = new realmatriximpl(bigsingular); try { bs.solve(bs); fail(\"expecting invalidmatrixexception\"); } catch (invalidmatrixexception ex) { ; } try { m.solve(bs); fail(\"expecting illegalargumentexception\"); } catch (illegalargumentexception ex) { ; } try { new realmatriximpl(testdata2).solve(bs); fail(\"expecting illegalargumentexception\"); } catch (illegalargumentexception ex) { ; } try { (new realmatriximpl(testdata2)).ludecompose(); fail(\"expecting invalidmatrixexception\"); } catch (invalidmatrixexception ex) { ; } }","repo":"svenpopping\/acfl-replication-package","label":[1,0,0,0]}
{"id":31003,"original_code":"public static CompositeValue create(ICPPClassType classType, IASTNode point, int nestingLevel) {\n\t\tSet<ICPPClassType> recursionProtectionSet = fCreateInProgress.get();\n\t\tif (!recursionProtectionSet.add(classType)) {\n\t\t\treturn new CompositeValue(null, ICPPEvaluation.EMPTY_ARRAY);\n\t\t}\n\t\ttry {\n\t\t\tif (sDEBUG && nestingLevel > 0) {\n\t\t\t\tSystem.out.println(\"CompositeValue.create(\" + ASTTypeUtil.getType(classType) + \", \" + nestingLevel + \")\");  \/\/$NON-NLS-1$\/\/$NON-NLS-2$ \/\/$NON-NLS-3$\n\t\t\t\tSystem.out.flush();\n\t\t\t}\n\t\t\tActivationRecord record = new ActivationRecord();\n\t\t\tICPPEvaluation[] values = new ICPPEvaluation[ClassTypeHelper.getFields(classType, point).length];\n\t\t\t\/\/ Recursively create all the base class member variables.\n\t\t\tICPPBase[] bases = ClassTypeHelper.getBases(classType, point);\n\t\t\tfor (ICPPBase base : bases) {\n\t\t\t\tIBinding baseClass = base.getBaseClass();\n\t\t\t\tif (baseClass instanceof ICPPClassType) {\n\t\t\t\t\tICPPClassType baseClassType = (ICPPClassType) baseClass;\n\t\t\t\t\tICPPField[] baseFields = ClassTypeHelper.getDeclaredFields(baseClassType, point);\n\t\t\t\t\tIValue compValue = CompositeValue.create(baseClassType, point, nestingLevel + 1);\n\t\t\t\t\tfor (ICPPField baseField : baseFields) {\n\t\t\t\t\t\tint fieldPos = CPPASTFieldReference.getFieldPosition(baseField);\n\t\t\t\t\t\tif (fieldPos == -1) {\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t}\n\t\t\t\t\t\trecord.update(baseField, compValue.getSubValue(fieldPos));\n\t\t\t\t\t\t\/\/ TODO(nathanridge): This won't work with multiple inheritance, since 'fieldPos'\n\t\t\t\t\t\t\/\/ is a field position in the base class' hierarchy, while values[] expects\n\t\t\t\t\t\t\/\/ as index a field position in classType's hierarchy.\n\t\t\t\t\t\tvalues[fieldPos] = compValue.getSubValue(fieldPos);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tICPPField[] fields = ClassTypeHelper.getDeclaredFields(classType, point);\n\t\t\tfor (ICPPField field : fields) {\n\t\t\t\tif (field.isStatic())\n\t\t\t\t\tcontinue;\n\t\t\t\tfinal ICPPEvaluation value = EvalUtil.getVariableValue(field, record, point);\n\t\t\t\tint fieldPos = CPPASTFieldReference.getFieldPosition(field);\n\t\t\t\tif (fieldPos == -1) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\trecord.update(field, value);\n\t\t\t\tvalues[fieldPos] = value;\n\t\t\t}\n\t\t\treturn new CompositeValue(null, values);\n\t\t} finally {\n\t\t\trecursionProtectionSet.remove(classType);\n\t\t}\n\t}","code_wo_comment":"public static CompositeValue create(ICPPClassType classType, IASTNode point, int nestingLevel) {\n\t\tSet<ICPPClassType> recursionProtectionSet = fCreateInProgress.get();\n\t\tif (!recursionProtectionSet.add(classType)) {\n\t\t\treturn new CompositeValue(null, ICPPEvaluation.EMPTY_ARRAY);\n\t\t}\n\t\ttry {\n\t\t\tif (sDEBUG && nestingLevel > 0) {\n\t\t\t\tSystem.out.println(\"CompositeValue.create(\" + ASTTypeUtil.getType(classType) + \", \" + nestingLevel + \")\"); \n\t\t\t\tSystem.out.flush();\n\t\t\t}\n\t\t\tActivationRecord record = new ActivationRecord();\n\t\t\tICPPEvaluation[] values = new ICPPEvaluation[ClassTypeHelper.getFields(classType, point).length];\n\t\t\n\t\t\tICPPBase[] bases = ClassTypeHelper.getBases(classType, point);\n\t\t\tfor (ICPPBase base : bases) {\n\t\t\t\tIBinding baseClass = base.getBaseClass();\n\t\t\t\tif (baseClass instanceof ICPPClassType) {\n\t\t\t\t\tICPPClassType baseClassType = (ICPPClassType) baseClass;\n\t\t\t\t\tICPPField[] baseFields = ClassTypeHelper.getDeclaredFields(baseClassType, point);\n\t\t\t\t\tIValue compValue = CompositeValue.create(baseClassType, point, nestingLevel + 1);\n\t\t\t\t\tfor (ICPPField baseField : baseFields) {\n\t\t\t\t\t\tint fieldPos = CPPASTFieldReference.getFieldPosition(baseField);\n\t\t\t\t\t\tif (fieldPos == -1) {\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t}\n\t\t\t\t\t\trecord.update(baseField, compValue.getSubValue(fieldPos));\n\t\t\t\t\t\n\t\t\t\t\t\n\t\t\t\t\t\n\t\t\t\t\t\tvalues[fieldPos] = compValue.getSubValue(fieldPos);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tICPPField[] fields = ClassTypeHelper.getDeclaredFields(classType, point);\n\t\t\tfor (ICPPField field : fields) {\n\t\t\t\tif (field.isStatic())\n\t\t\t\t\tcontinue;\n\t\t\t\tfinal ICPPEvaluation value = EvalUtil.getVariableValue(field, record, point);\n\t\t\t\tint fieldPos = CPPASTFieldReference.getFieldPosition(field);\n\t\t\t\tif (fieldPos == -1) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\trecord.update(field, value);\n\t\t\t\tvalues[fieldPos] = value;\n\t\t\t}\n\t\t\treturn new CompositeValue(null, values);\n\t\t} finally {\n\t\t\trecursionProtectionSet.remove(classType);\n\t\t}\n\t}","cleancode":"public static compositevalue create(icppclasstype classtype, iastnode point, int nestinglevel) { set<icppclasstype> recursionprotectionset = fcreateinprogress.get(); if (!recursionprotectionset.add(classtype)) { return new compositevalue(null, icppevaluation.empty_array); } try { if (sdebug && nestinglevel > 0) { system.out.println(\"compositevalue.create(\" + asttypeutil.gettype(classtype) + \", \" + nestinglevel + \")\"); system.out.flush(); } activationrecord record = new activationrecord(); icppevaluation[] values = new icppevaluation[classtypehelper.getfields(classtype, point).length]; icppbase[] bases = classtypehelper.getbases(classtype, point); for (icppbase base : bases) { ibinding baseclass = base.getbaseclass(); if (baseclass instanceof icppclasstype) { icppclasstype baseclasstype = (icppclasstype) baseclass; icppfield[] basefields = classtypehelper.getdeclaredfields(baseclasstype, point); ivalue compvalue = compositevalue.create(baseclasstype, point, nestinglevel + 1); for (icppfield basefield : basefields) { int fieldpos = cppastfieldreference.getfieldposition(basefield); if (fieldpos == -1) { continue; } record.update(basefield, compvalue.getsubvalue(fieldpos)); values[fieldpos] = compvalue.getsubvalue(fieldpos); } } } icppfield[] fields = classtypehelper.getdeclaredfields(classtype, point); for (icppfield field : fields) { if (field.isstatic()) continue; final icppevaluation value = evalutil.getvariablevalue(field, record, point); int fieldpos = cppastfieldreference.getfieldposition(field); if (fieldpos == -1) { continue; } record.update(field, value); values[fieldpos] = value; } return new compositevalue(null, values); } finally { recursionprotectionset.remove(classtype); } }","repo":"seemoo-lab\/polypyus_pdom","label":[0,0,1,0]}
{"id":22978,"original_code":"private void checkPins(List<X509Certificate> chain) throws CertificateException {\n        PinSet pinSet = mNetworkSecurityConfig.getPins();\n        if (pinSet.pins.isEmpty()\n                || System.currentTimeMillis() > pinSet.expirationTime\n                || !isPinningEnforced(chain)) {\n            return;\n        }\n        Set<String> pinAlgorithms = pinSet.getPinAlgorithms();\n        Map<String, MessageDigest> digestMap = new ArrayMap<String, MessageDigest>(\n                pinAlgorithms.size());\n        for (int i = chain.size() - 1; i >= 0 ; i--) {\n            X509Certificate cert = chain.get(i);\n            byte[] encodedSPKI = cert.getPublicKey().getEncoded();\n            for (String algorithm : pinAlgorithms) {\n                MessageDigest md = digestMap.get(algorithm);\n                if (md == null) {\n                    try {\n                        md = MessageDigest.getInstance(algorithm);\n                    } catch (GeneralSecurityException e) {\n                        throw new RuntimeException(e);\n                    }\n                    digestMap.put(algorithm, md);\n                }\n                if (pinSet.pins.contains(new Pin(algorithm, md.digest(encodedSPKI)))) {\n                    return;\n                }\n            }\n        }\n        \/\/ TODO: Throw a subclass of CertificateException which indicates a pinning failure.\n        throw new CertificateException(\"Pin verification failed\");\n    }","code_wo_comment":"private void checkPins(List<X509Certificate> chain) throws CertificateException {\n        PinSet pinSet = mNetworkSecurityConfig.getPins();\n        if (pinSet.pins.isEmpty()\n                || System.currentTimeMillis() > pinSet.expirationTime\n                || !isPinningEnforced(chain)) {\n            return;\n        }\n        Set<String> pinAlgorithms = pinSet.getPinAlgorithms();\n        Map<String, MessageDigest> digestMap = new ArrayMap<String, MessageDigest>(\n                pinAlgorithms.size());\n        for (int i = chain.size() - 1; i >= 0 ; i--) {\n            X509Certificate cert = chain.get(i);\n            byte[] encodedSPKI = cert.getPublicKey().getEncoded();\n            for (String algorithm : pinAlgorithms) {\n                MessageDigest md = digestMap.get(algorithm);\n                if (md == null) {\n                    try {\n                        md = MessageDigest.getInstance(algorithm);\n                    } catch (GeneralSecurityException e) {\n                        throw new RuntimeException(e);\n                    }\n                    digestMap.put(algorithm, md);\n                }\n                if (pinSet.pins.contains(new Pin(algorithm, md.digest(encodedSPKI)))) {\n                    return;\n                }\n            }\n        }\n       \n        throw new CertificateException(\"Pin verification failed\");\n    }","cleancode":"private void checkpins(list<x509certificate> chain) throws certificateexception { pinset pinset = mnetworksecurityconfig.getpins(); if (pinset.pins.isempty() || system.currenttimemillis() > pinset.expirationtime || !ispinningenforced(chain)) { return; } set<string> pinalgorithms = pinset.getpinalgorithms(); map<string, messagedigest> digestmap = new arraymap<string, messagedigest>( pinalgorithms.size()); for (int i = chain.size() - 1; i >= 0 ; i--) { x509certificate cert = chain.get(i); byte[] encodedspki = cert.getpublickey().getencoded(); for (string algorithm : pinalgorithms) { messagedigest md = digestmap.get(algorithm); if (md == null) { try { md = messagedigest.getinstance(algorithm); } catch (generalsecurityexception e) { throw new runtimeexception(e); } digestmap.put(algorithm, md); } if (pinset.pins.contains(new pin(algorithm, md.digest(encodedspki)))) { return; } } } throw new certificateexception(\"pin verification failed\"); }","repo":"rio-31\/android_frameworks_base-1","label":[0,1,0,0]}
{"id":23034,"original_code":"private static boolean isOnline(){\n\t\ttry{\n\t\t\tnew URL(\"http:\/\/74.125.230.174\").openConnection().connect(); \/\/Confused? Copy the URL and paste it in your browser.\n\t\t\treturn true;\n\t\t}catch (IOException e) {\n\t\t\treturn false;\n\t\t}\n\t}","code_wo_comment":"private static boolean isOnline(){\n\t\ttry{\n\t\t\tnew URL(\"http:\/\/74.125.230.174\").openConnection().connect();\n\t\t\treturn true;\n\t\t}catch (IOException e) {\n\t\t\treturn false;\n\t\t}\n\t}","cleancode":"private static boolean isonline(){ try{ new url(\"http:\/\/74.125.230.174\").openconnection().connect(); return true; }catch (ioexception e) { return false; } }","repo":"scottkillen-vault\/Bunyan","label":[1,0,0,0]}
{"id":31253,"original_code":"private void verifyAllComponents()\n    {\n        \/\/ check root component has no generics\n        if (!this.components.get(this.topname).getGenerics().isEmpty())\n            genericError(String.format(\"top component %s cannot contain generics\", this.topname));\n        \/\/ verify all components\n        for (Component component : this.components.values())\n        {\n            this.currentComponent = component.name;\n            this.verifyPortArch(component.ast);\n            this.verifyIdentifiers(component.ast);\n            this.verifyConstantExpressions(component.ast);\n            this.verifyTypes(component.ast);\n        }\n    }","code_wo_comment":"private void verifyAllComponents()\n    {\n       \n        if (!this.components.get(this.topname).getGenerics().isEmpty())\n            genericError(String.format(\"top component %s cannot contain generics\", this.topname));\n       \n        for (Component component : this.components.values())\n        {\n            this.currentComponent = component.name;\n            this.verifyPortArch(component.ast);\n            this.verifyIdentifiers(component.ast);\n            this.verifyConstantExpressions(component.ast);\n            this.verifyTypes(component.ast);\n        }\n    }","cleancode":"private void verifyallcomponents() { if (!this.components.get(this.topname).getgenerics().isempty()) genericerror(string.format(\"top component %s cannot contain generics\", this.topname)); for (component component : this.components.values()) { this.currentcomponent = component.name; this.verifyportarch(component.ast); this.verifyidentifiers(component.ast); this.verifyconstantexpressions(component.ast); this.verifytypes(component.ast); } }","repo":"reed-foster\/cdl","label":[0,1,0,0]}
{"id":23074,"original_code":"public void testJ5_32_speculative() throws Exception {\n\t\tCppCompositeType J5_struct = createJ5_struct32(vbtManager32);\n\t\tJ5_struct.createLayout(classLayoutChoice, vbtManager32, TaskMonitor.DUMMY);\n\t\tComposite composite = J5_struct.getComposite();\n\t\tCompositeTestUtils.assertExpectedComposite(this, getSpeculatedJ5_32(), composite, true);\n\t}","code_wo_comment":"public void testJ5_32_speculative() throws Exception {\n\t\tCppCompositeType J5_struct = createJ5_struct32(vbtManager32);\n\t\tJ5_struct.createLayout(classLayoutChoice, vbtManager32, TaskMonitor.DUMMY);\n\t\tComposite composite = J5_struct.getComposite();\n\t\tCompositeTestUtils.assertExpectedComposite(this, getSpeculatedJ5_32(), composite, true);\n\t}","cleancode":"public void testj5_32_speculative() throws exception { cppcompositetype j5_struct = createj5_struct32(vbtmanager32); j5_struct.createlayout(classlayoutchoice, vbtmanager32, taskmonitor.dummy); composite composite = j5_struct.getcomposite(); compositetestutils.assertexpectedcomposite(this, getspeculatedj5_32(), composite, true); }","repo":"sigurasg\/ghidra","label":[1,0,0,0]}
{"id":23075,"original_code":"public void testJ5_64_speculative() throws Exception {\n\t\tCppCompositeType J5_struct = createJ5_struct64(vbtManager64);\n\t\tJ5_struct.createLayout(classLayoutChoice, vbtManager64, TaskMonitor.DUMMY);\n\t\tComposite composite = J5_struct.getComposite();\n\t\tCompositeTestUtils.assertExpectedComposite(this, getSpeculatedJ5_64(), composite, true);\n\t}","code_wo_comment":"public void testJ5_64_speculative() throws Exception {\n\t\tCppCompositeType J5_struct = createJ5_struct64(vbtManager64);\n\t\tJ5_struct.createLayout(classLayoutChoice, vbtManager64, TaskMonitor.DUMMY);\n\t\tComposite composite = J5_struct.getComposite();\n\t\tCompositeTestUtils.assertExpectedComposite(this, getSpeculatedJ5_64(), composite, true);\n\t}","cleancode":"public void testj5_64_speculative() throws exception { cppcompositetype j5_struct = createj5_struct64(vbtmanager64); j5_struct.createlayout(classlayoutchoice, vbtmanager64, taskmonitor.dummy); composite composite = j5_struct.getcomposite(); compositetestutils.assertexpectedcomposite(this, getspeculatedj5_64(), composite, true); }","repo":"sigurasg\/ghidra","label":[1,0,0,0]}
{"id":23076,"original_code":"public void testJ6_32_speculative() throws Exception {\n\t\tCppCompositeType J6_struct = createJ6_struct32(vbtManager32);\n\t\tJ6_struct.createLayout(classLayoutChoice, vbtManager32, TaskMonitor.DUMMY);\n\t\tComposite composite = J6_struct.getComposite();\n\t\tCompositeTestUtils.assertExpectedComposite(this, getSpeculatedJ6_32(), composite, true);\n\t}","code_wo_comment":"public void testJ6_32_speculative() throws Exception {\n\t\tCppCompositeType J6_struct = createJ6_struct32(vbtManager32);\n\t\tJ6_struct.createLayout(classLayoutChoice, vbtManager32, TaskMonitor.DUMMY);\n\t\tComposite composite = J6_struct.getComposite();\n\t\tCompositeTestUtils.assertExpectedComposite(this, getSpeculatedJ6_32(), composite, true);\n\t}","cleancode":"public void testj6_32_speculative() throws exception { cppcompositetype j6_struct = createj6_struct32(vbtmanager32); j6_struct.createlayout(classlayoutchoice, vbtmanager32, taskmonitor.dummy); composite composite = j6_struct.getcomposite(); compositetestutils.assertexpectedcomposite(this, getspeculatedj6_32(), composite, true); }","repo":"sigurasg\/ghidra","label":[1,0,0,0]}
{"id":23077,"original_code":"public void testJ6_64_speculative() throws Exception {\n\t\tCppCompositeType J6_struct = createJ6_struct64(vbtManager64);\n\t\tJ6_struct.createLayout(classLayoutChoice, vbtManager64, TaskMonitor.DUMMY);\n\t\tComposite composite = J6_struct.getComposite();\n\t\tCompositeTestUtils.assertExpectedComposite(this, getSpeculatedJ6_64(), composite, true);\n\t}","code_wo_comment":"public void testJ6_64_speculative() throws Exception {\n\t\tCppCompositeType J6_struct = createJ6_struct64(vbtManager64);\n\t\tJ6_struct.createLayout(classLayoutChoice, vbtManager64, TaskMonitor.DUMMY);\n\t\tComposite composite = J6_struct.getComposite();\n\t\tCompositeTestUtils.assertExpectedComposite(this, getSpeculatedJ6_64(), composite, true);\n\t}","cleancode":"public void testj6_64_speculative() throws exception { cppcompositetype j6_struct = createj6_struct64(vbtmanager64); j6_struct.createlayout(classlayoutchoice, vbtmanager64, taskmonitor.dummy); composite composite = j6_struct.getcomposite(); compositetestutils.assertexpectedcomposite(this, getspeculatedj6_64(), composite, true); }","repo":"sigurasg\/ghidra","label":[1,0,0,0]}
{"id":31319,"original_code":"public List<HeatConsumption> findHeatConsumptions() throws IOException {\n        \/\/ TODO convert into model that contains electricity info also\n        return heatRepository.findAll();\n    }","code_wo_comment":"public List<HeatConsumption> findHeatConsumptions() throws IOException {\n       \n        return heatRepository.findAll();\n    }","cleancode":"public list<heatconsumption> findheatconsumptions() throws ioexception { return heatrepository.findall(); }","repo":"renanpelicari\/java-kata","label":[0,1,0,0]}
{"id":31329,"original_code":"public static Document parse(String text, int windowSize, JSONArray spacyEntities, JSONArray dbpediaEntities) {\n\t\tDocument result = new Document();\n\t\tresult._originaltext = text;\n\t\tresult._sentences    = new java.util.ArrayList<Sentence>();\n\t\tList<String> splitSentences = StanfordNLP.splitSentences(text);\n\t\tint lastFoundPosition = -1;\n\t\tint lastSentenceLength = 1;\n\t\tint sentenceCount      = 0;\n\t\tint runningSentinmentScore = 0; \n\t\t\/\/ perform the window parsing - used to do coreref, plus get initial named entities, sentiment, and tokens\n\t\tfor (int sentenceIndex = 0; sentenceIndex < splitSentences.size(); sentenceIndex++) {\n\t\t\tSplitResult sr = getTextWindow(splitSentences, sentenceIndex,windowSize);\n\t\t\tAnnotation sentenceDoc = StanfordNLP.annotateText(sr.text);\n\t\t    List<CoreMap> sentences = sentenceDoc.get(CoreAnnotations.SentencesAnnotation.class);\n\t\t    CoreMap sentence = sentences.get(sr.sentencePositionToUse);\n\t    \tsentenceCount++;\n\t    \tString sentenceText = sentence.get(CoreAnnotations.TextAnnotation.class);\n\t    \tint documentPosition = text.indexOf(sentenceText,lastFoundPosition);\n\t    \tif (documentPosition == -1) { \n\t    \t\tdocumentPosition = lastFoundPosition + lastSentenceLength;\n\t    \t}\n\t    \tjava.util.List<Token> sentenceTokens = Token.extractTokens(sentence, sentenceCount);\n\t    \tSentence s = new Sentence(sentenceText, documentPosition, sentenceCount, sentenceTokens);\n\t    \tTree tree = sentence.get(SentimentCoreAnnotations.SentimentAnnotatedTree.class);\n            int sentiment = RNNCoreAnnotations.getPredictedClass(tree);\n            s.setSentiment(sentiment);\n            runningSentinmentScore += sentiment;\n            List<String> resolvedSentences = Coreference.resolveCoreferences(sentenceDoc);\n            s.setCorefText(resolvedSentences.get(sr.sentencePositionToUse));\n\t    \tresult._sentences.add(s);\n\t    \tlastFoundPosition = documentPosition;\n\t    \tlastSentenceLength = sentenceText.length();\n\t\t}\n\t\tresult._sentimentScore =  ((double) runningSentinmentScore) \/ sentenceCount;\n\t\t\/\/ reparse to get openIE \/ relations items\n\t\tint baseSentenceIndex = -1;\n\t\tfor (Sentence s: result._sentences) {\n\t\t\tAnnotation sentenceDoc = StanfordNLP.annotateText(s.getCorefText());\n\t\t\tbaseSentenceIndex++;\n\t\t\tjava.util.List<Token> sentenceTokens = Token.extractTokens(sentenceDoc.get(CoreAnnotations.SentencesAnnotation.class).get(0), baseSentenceIndex);\n\t\t\tjava.util.List<TripleRelation> triples = TripleRelation.extractTriples(sentenceDoc, baseSentenceIndex);\n\t\t\ttriples = TripleRelation.valiadateTriples(triples, sentenceTokens);\n\t\t\tList<AnnotatedProposition> minieTriplesAP =  StanfordNLP.extractMinIETriples(s.getCorefText());\n\t\t\tjava.util.List<TripleRelation> minetriples = TripleRelation.extractTriples(minieTriplesAP, baseSentenceIndex);\n\t\t\tminetriples = TripleRelation.valiadateTriples(minetriples, sentenceTokens);\n\t\t\tjava.util.List<TripleRelation> combinedTriples = TripleRelation.combine(triples, minetriples);\n\t\t\tcombinedTriples = TripleRelation.reduceTriples(combinedTriples, FilterStyle.FILTER_TO_MAXIMIZE_SUBJ_OBJ_MINIMIZE_RELATION);\n\t\t\t\/\/combinedTriples = TripleRelation.reduceTriples(combinedTriples, FilterStyle.FILTER_TO_MINIMIZE_TERMS);\n\t\t\tTripleRelation.augmentSubjectObjectWithStanfordNER(combinedTriples,s.getNamedEntities());\n\t\t\tTripleRelation.augmentSubjectObjectWithSpacyNER(combinedTriples, spacyEntities, s.getStartPosition(), s.getStartPosition() + s.getOriginalText().length());\n\t\t\tTripleRelation.augmentSubjectObjectWithDBPedia(combinedTriples, dbpediaEntities, s.getStartPosition(), s.getStartPosition() + s.getOriginalText().length());\n\t\t\ts.setTripleRelations(combinedTriples);\n\t\t}\n\t\treturn result;\n\t}","code_wo_comment":"public static Document parse(String text, int windowSize, JSONArray spacyEntities, JSONArray dbpediaEntities) {\n\t\tDocument result = new Document();\n\t\tresult._originaltext = text;\n\t\tresult._sentences    = new java.util.ArrayList<Sentence>();\n\t\tList<String> splitSentences = StanfordNLP.splitSentences(text);\n\t\tint lastFoundPosition = -1;\n\t\tint lastSentenceLength = 1;\n\t\tint sentenceCount      = 0;\n\t\tint runningSentinmentScore = 0; \n\t\n\t\tfor (int sentenceIndex = 0; sentenceIndex < splitSentences.size(); sentenceIndex++) {\n\t\t\tSplitResult sr = getTextWindow(splitSentences, sentenceIndex,windowSize);\n\t\t\tAnnotation sentenceDoc = StanfordNLP.annotateText(sr.text);\n\t\t    List<CoreMap> sentences = sentenceDoc.get(CoreAnnotations.SentencesAnnotation.class);\n\t\t    CoreMap sentence = sentences.get(sr.sentencePositionToUse);\n\t    \tsentenceCount++;\n\t    \tString sentenceText = sentence.get(CoreAnnotations.TextAnnotation.class);\n\t    \tint documentPosition = text.indexOf(sentenceText,lastFoundPosition);\n\t    \tif (documentPosition == -1) { \n\t    \t\tdocumentPosition = lastFoundPosition + lastSentenceLength;\n\t    \t}\n\t    \tjava.util.List<Token> sentenceTokens = Token.extractTokens(sentence, sentenceCount);\n\t    \tSentence s = new Sentence(sentenceText, documentPosition, sentenceCount, sentenceTokens);\n\t    \tTree tree = sentence.get(SentimentCoreAnnotations.SentimentAnnotatedTree.class);\n            int sentiment = RNNCoreAnnotations.getPredictedClass(tree);\n            s.setSentiment(sentiment);\n            runningSentinmentScore += sentiment;\n            List<String> resolvedSentences = Coreference.resolveCoreferences(sentenceDoc);\n            s.setCorefText(resolvedSentences.get(sr.sentencePositionToUse));\n\t    \tresult._sentences.add(s);\n\t    \tlastFoundPosition = documentPosition;\n\t    \tlastSentenceLength = sentenceText.length();\n\t\t}\n\t\tresult._sentimentScore =  ((double) runningSentinmentScore) \/ sentenceCount;\n\t\n\t\tint baseSentenceIndex = -1;\n\t\tfor (Sentence s: result._sentences) {\n\t\t\tAnnotation sentenceDoc = StanfordNLP.annotateText(s.getCorefText());\n\t\t\tbaseSentenceIndex++;\n\t\t\tjava.util.List<Token> sentenceTokens = Token.extractTokens(sentenceDoc.get(CoreAnnotations.SentencesAnnotation.class).get(0), baseSentenceIndex);\n\t\t\tjava.util.List<TripleRelation> triples = TripleRelation.extractTriples(sentenceDoc, baseSentenceIndex);\n\t\t\ttriples = TripleRelation.valiadateTriples(triples, sentenceTokens);\n\t\t\tList<AnnotatedProposition> minieTriplesAP =  StanfordNLP.extractMinIETriples(s.getCorefText());\n\t\t\tjava.util.List<TripleRelation> minetriples = TripleRelation.extractTriples(minieTriplesAP, baseSentenceIndex);\n\t\t\tminetriples = TripleRelation.valiadateTriples(minetriples, sentenceTokens);\n\t\t\tjava.util.List<TripleRelation> combinedTriples = TripleRelation.combine(triples, minetriples);\n\t\t\tcombinedTriples = TripleRelation.reduceTriples(combinedTriples, FilterStyle.FILTER_TO_MAXIMIZE_SUBJ_OBJ_MINIMIZE_RELATION);\n\t\t\n\t\t\tTripleRelation.augmentSubjectObjectWithStanfordNER(combinedTriples,s.getNamedEntities());\n\t\t\tTripleRelation.augmentSubjectObjectWithSpacyNER(combinedTriples, spacyEntities, s.getStartPosition(), s.getStartPosition() + s.getOriginalText().length());\n\t\t\tTripleRelation.augmentSubjectObjectWithDBPedia(combinedTriples, dbpediaEntities, s.getStartPosition(), s.getStartPosition() + s.getOriginalText().length());\n\t\t\ts.setTripleRelations(combinedTriples);\n\t\t}\n\t\treturn result;\n\t}","cleancode":"public static document parse(string text, int windowsize, jsonarray spacyentities, jsonarray dbpediaentities) { document result = new document(); result._originaltext = text; result._sentences = new java.util.arraylist<sentence>(); list<string> splitsentences = stanfordnlp.splitsentences(text); int lastfoundposition = -1; int lastsentencelength = 1; int sentencecount = 0; int runningsentinmentscore = 0; for (int sentenceindex = 0; sentenceindex < splitsentences.size(); sentenceindex++) { splitresult sr = gettextwindow(splitsentences, sentenceindex,windowsize); annotation sentencedoc = stanfordnlp.annotatetext(sr.text); list<coremap> sentences = sentencedoc.get(coreannotations.sentencesannotation.class); coremap sentence = sentences.get(sr.sentencepositiontouse); sentencecount++; string sentencetext = sentence.get(coreannotations.textannotation.class); int documentposition = text.indexof(sentencetext,lastfoundposition); if (documentposition == -1) { documentposition = lastfoundposition + lastsentencelength; } java.util.list<token> sentencetokens = token.extracttokens(sentence, sentencecount); sentence s = new sentence(sentencetext, documentposition, sentencecount, sentencetokens); tree tree = sentence.get(sentimentcoreannotations.sentimentannotatedtree.class); int sentiment = rnncoreannotations.getpredictedclass(tree); s.setsentiment(sentiment); runningsentinmentscore += sentiment; list<string> resolvedsentences = coreference.resolvecoreferences(sentencedoc); s.setcoreftext(resolvedsentences.get(sr.sentencepositiontouse)); result._sentences.add(s); lastfoundposition = documentposition; lastsentencelength = sentencetext.length(); } result._sentimentscore = ((double) runningsentinmentscore) \/ sentencecount; int basesentenceindex = -1; for (sentence s: result._sentences) { annotation sentencedoc = stanfordnlp.annotatetext(s.getcoreftext()); basesentenceindex++; java.util.list<token> sentencetokens = token.extracttokens(sentencedoc.get(coreannotations.sentencesannotation.class).get(0), basesentenceindex); java.util.list<triplerelation> triples = triplerelation.extracttriples(sentencedoc, basesentenceindex); triples = triplerelation.valiadatetriples(triples, sentencetokens); list<annotatedproposition> minietriplesap = stanfordnlp.extractminietriples(s.getcoreftext()); java.util.list<triplerelation> minetriples = triplerelation.extracttriples(minietriplesap, basesentenceindex); minetriples = triplerelation.valiadatetriples(minetriples, sentencetokens); java.util.list<triplerelation> combinedtriples = triplerelation.combine(triples, minetriples); combinedtriples = triplerelation.reducetriples(combinedtriples, filterstyle.filter_to_maximize_subj_obj_minimize_relation); triplerelation.augmentsubjectobjectwithstanfordner(combinedtriples,s.getnamedentities()); triplerelation.augmentsubjectobjectwithspacyner(combinedtriples, spacyentities, s.getstartposition(), s.getstartposition() + s.getoriginaltext().length()); triplerelation.augmentsubjectobjectwithdbpedia(combinedtriples, dbpediaentities, s.getstartposition(), s.getstartposition() + s.getoriginaltext().length()); s.settriplerelations(combinedtriples); } return result; }","repo":"slankas\/OSKE","label":[0,0,0,0]}
{"id":31468,"original_code":"public static boolean isProvidedUserChoicesForNodeInstance(Map<String, List<Parameter<?>>> userChoices,\n\t        String nodeInstanceName) {\n\t\tif (userChoices == null || userChoices.isEmpty())\n\t\t\treturn false;\n\t\tList<Parameter<?>> paramsForNodeInstance = userChoices.get(nodeInstanceName);\n\t\tif (paramsForNodeInstance == null || paramsForNodeInstance.isEmpty())\n\t\t\treturn false;\n\t\treturn true;\n\t}","code_wo_comment":"public static boolean isProvidedUserChoicesForNodeInstance(Map<String, List<Parameter<?>>> userChoices,\n\t        String nodeInstanceName) {\n\t\tif (userChoices == null || userChoices.isEmpty())\n\t\t\treturn false;\n\t\tList<Parameter<?>> paramsForNodeInstance = userChoices.get(nodeInstanceName);\n\t\tif (paramsForNodeInstance == null || paramsForNodeInstance.isEmpty())\n\t\t\treturn false;\n\t\treturn true;\n\t}","cleancode":"public static boolean isprovideduserchoicesfornodeinstance(map<string, list<parameter<?>>> userchoices, string nodeinstancename) { if (userchoices == null || userchoices.isempty()) return false; list<parameter<?>> paramsfornodeinstance = userchoices.get(nodeinstancename); if (paramsfornodeinstance == null || paramsfornodeinstance.isempty()) return false; return true; }","repo":"slipstream\/cimi-mf2c","label":[1,0,0,0]}
{"id":15468,"original_code":"private void handleUpload(HttpServletRequest request, HttpServletResponse resp) throws ServletException, IOException, WsException {\n\t\tcheckPermission(WebswingAction.file_upload);\n\t\ttry {\n\t\t\tString uuid = request.getParameter(\"uuid\");\n\t\t\tif (uuid != null) {\n\t\t\t\tSwingInstance instance = manager.findInstanceBySessionId(uuid);\n\t\t\t\tif (instance != null) {\n\t\t\t\t\tdouble maxMB = instance.getAppConfig().getUploadMaxSize();\n\t\t\t\t\tlong maxsize = (long) (maxMB * 1024 * 1024);\n\t\t\t\t\tPart filePart = request.getPart(\"files[]\"); \/\/ Retrieves <input type=\"file\" name=\"file\">\n\t\t\t\t\tString filename = getFilename(filePart);\n\t\t\t\t\tif (maxsize > 0 && filePart.getSize() > maxsize) {\n\t\t\t\t\t\tresp.setStatus(HttpServletResponse.SC_BAD_REQUEST);\n\t\t\t\t\t\tresp.getWriter().write(String.format(\"File '%s' is too large. (Max. file size is %.1fMB)\", filename, maxMB));\n\t\t\t\t\t} else {\n\t\t\t\t\t\tString tempDir = System.getProperty(Constants.TEMP_DIR_PATH);\n\t\t\t\t\t\tString tempName = UUID.randomUUID().toString();\n\t\t\t\t\t\tInputStream filecontent = filePart.getInputStream();\n\t\t\t\t\t\tFile f = new File(URI.create(tempDir + \"\/\" + tempName));\n\t\t\t\t\t\tFileOutputStream output = new FileOutputStream(f);\n\t\t\t\t\t\tIOUtils.copy(filecontent, output);\n\t\t\t\t\t\toutput.close();\n\t\t\t\t\t\tfilecontent.close();\n\t\t\t\t\t\tlog.info(\"File \" + filename + \" uploaded (size:\" + filePart.getSize() + \") to \" + f.getAbsolutePath());\n\t\t\t\t\t\tUploadEventMsgIn msg = new UploadEventMsgIn();\n\t\t\t\t\t\tmsg.setFileName(filename);\n\t\t\t\t\t\tmsg.setTempFileLocation(f.getAbsolutePath());\n\t\t\t\t\t\tboolean sent = instance.sendToSwing(null, msg);\n\t\t\t\t\t\tif (!sent) {\n\t\t\t\t\t\t\tlog.error(\"Failed to send upload notification to app session. File:\" + filename + \"+ClientID:\" + instance.getClientId());\n\t\t\t\t\t\t\tf.delete();\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tresp.getWriter().write(\"{\\\"files\\\":[{\\\"name\\\":\\\"\" + filename + \"\\\"}]}\"); \/\/ TODO size\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tthrow new Exception(\"Related App instance not found.(\" + uuid + \")\");\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tthrow new Exception(\"UUID not specified in request\");\n\t\t\t}\n\t\t} catch (Exception e) {\n\t\t\tif (e.getCause() instanceof EOFException) {\n\t\t\t\tlog.warn(\"File upload canceled by user: \" + e.getMessage());\n\t\t\t} else {\n\t\t\t\tresp.setStatus(HttpServletResponse.SC_INTERNAL_SERVER_ERROR);\n\t\t\t\tresp.getWriter().write(\"Upload finished with error...\");\n\t\t\t\tlog.error(\"Error while uploading file: \" + e.getMessage(), e);\n\t\t\t}\n\t\t}\n\t}","code_wo_comment":"private void handleUpload(HttpServletRequest request, HttpServletResponse resp) throws ServletException, IOException, WsException {\n\t\tcheckPermission(WebswingAction.file_upload);\n\t\ttry {\n\t\t\tString uuid = request.getParameter(\"uuid\");\n\t\t\tif (uuid != null) {\n\t\t\t\tSwingInstance instance = manager.findInstanceBySessionId(uuid);\n\t\t\t\tif (instance != null) {\n\t\t\t\t\tdouble maxMB = instance.getAppConfig().getUploadMaxSize();\n\t\t\t\t\tlong maxsize = (long) (maxMB * 1024 * 1024);\n\t\t\t\t\tPart filePart = request.getPart(\"files[]\");\n\t\t\t\t\tString filename = getFilename(filePart);\n\t\t\t\t\tif (maxsize > 0 && filePart.getSize() > maxsize) {\n\t\t\t\t\t\tresp.setStatus(HttpServletResponse.SC_BAD_REQUEST);\n\t\t\t\t\t\tresp.getWriter().write(String.format(\"File '%s' is too large. (Max. file size is %.1fMB)\", filename, maxMB));\n\t\t\t\t\t} else {\n\t\t\t\t\t\tString tempDir = System.getProperty(Constants.TEMP_DIR_PATH);\n\t\t\t\t\t\tString tempName = UUID.randomUUID().toString();\n\t\t\t\t\t\tInputStream filecontent = filePart.getInputStream();\n\t\t\t\t\t\tFile f = new File(URI.create(tempDir + \"\/\" + tempName));\n\t\t\t\t\t\tFileOutputStream output = new FileOutputStream(f);\n\t\t\t\t\t\tIOUtils.copy(filecontent, output);\n\t\t\t\t\t\toutput.close();\n\t\t\t\t\t\tfilecontent.close();\n\t\t\t\t\t\tlog.info(\"File \" + filename + \" uploaded (size:\" + filePart.getSize() + \") to \" + f.getAbsolutePath());\n\t\t\t\t\t\tUploadEventMsgIn msg = new UploadEventMsgIn();\n\t\t\t\t\t\tmsg.setFileName(filename);\n\t\t\t\t\t\tmsg.setTempFileLocation(f.getAbsolutePath());\n\t\t\t\t\t\tboolean sent = instance.sendToSwing(null, msg);\n\t\t\t\t\t\tif (!sent) {\n\t\t\t\t\t\t\tlog.error(\"Failed to send upload notification to app session. File:\" + filename + \"+ClientID:\" + instance.getClientId());\n\t\t\t\t\t\t\tf.delete();\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tresp.getWriter().write(\"{\\\"files\\\":[{\\\"name\\\":\\\"\" + filename + \"\\\"}]}\");\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tthrow new Exception(\"Related App instance not found.(\" + uuid + \")\");\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tthrow new Exception(\"UUID not specified in request\");\n\t\t\t}\n\t\t} catch (Exception e) {\n\t\t\tif (e.getCause() instanceof EOFException) {\n\t\t\t\tlog.warn(\"File upload canceled by user: \" + e.getMessage());\n\t\t\t} else {\n\t\t\t\tresp.setStatus(HttpServletResponse.SC_INTERNAL_SERVER_ERROR);\n\t\t\t\tresp.getWriter().write(\"Upload finished with error...\");\n\t\t\t\tlog.error(\"Error while uploading file: \" + e.getMessage(), e);\n\t\t\t}\n\t\t}\n\t}","cleancode":"private void handleupload(httpservletrequest request, httpservletresponse resp) throws servletexception, ioexception, wsexception { checkpermission(webswingaction.file_upload); try { string uuid = request.getparameter(\"uuid\"); if (uuid != null) { swinginstance instance = manager.findinstancebysessionid(uuid); if (instance != null) { double maxmb = instance.getappconfig().getuploadmaxsize(); long maxsize = (long) (maxmb * 1024 * 1024); part filepart = request.getpart(\"files[]\"); string filename = getfilename(filepart); if (maxsize > 0 && filepart.getsize() > maxsize) { resp.setstatus(httpservletresponse.sc_bad_request); resp.getwriter().write(string.format(\"file '%s' is too large. (max. file size is %.1fmb)\", filename, maxmb)); } else { string tempdir = system.getproperty(constants.temp_dir_path); string tempname = uuid.randomuuid().tostring(); inputstream filecontent = filepart.getinputstream(); file f = new file(uri.create(tempdir + \"\/\" + tempname)); fileoutputstream output = new fileoutputstream(f); ioutils.copy(filecontent, output); output.close(); filecontent.close(); log.info(\"file \" + filename + \" uploaded (size:\" + filepart.getsize() + \") to \" + f.getabsolutepath()); uploadeventmsgin msg = new uploadeventmsgin(); msg.setfilename(filename); msg.settempfilelocation(f.getabsolutepath()); boolean sent = instance.sendtoswing(null, msg); if (!sent) { log.error(\"failed to send upload notification to app session. file:\" + filename + \"+clientid:\" + instance.getclientid()); f.delete(); } else { resp.getwriter().write(\"{\\\"files\\\":[{\\\"name\\\":\\\"\" + filename + \"\\\"}]}\"); } } } else { throw new exception(\"related app instance not found.(\" + uuid + \")\"); } } else { throw new exception(\"uuid not specified in request\"); } } catch (exception e) { if (e.getcause() instanceof eofexception) { log.warn(\"file upload canceled by user: \" + e.getmessage()); } else { resp.setstatus(httpservletresponse.sc_internal_server_error); resp.getwriter().write(\"upload finished with error...\"); log.error(\"error while uploading file: \" + e.getmessage(), e); } } }","repo":"swing-fly\/webswing","label":[0,0,0,0]}
{"id":15624,"original_code":"@Override \n    public void enableSupportForSerializationIfApplicable(CancelIndicator cancelIndicator) {\n        if (!IterableExtensions.isNullOrEmpty(targetConfig.protoFiles)) {\n            \/\/ Enable support for proto serialization\n            enabledSerializers.add(SupportedSerializers.PROTO);\n        }\n        for (SupportedSerializers serialization : enabledSerializers) {\n            switch (serialization) {\n                case NATIVE: {\n                    FedNativePythonSerialization pickler = new FedNativePythonSerialization();\n                    code.pr(pickler.generatePreambleForSupport().toString());\n                }\n                case PROTO: {\n                    \/\/ Handle .proto files.\n                    for (String name : targetConfig.protoFiles) {\n                        this.processProtoFile(name, cancelIndicator);\n                        int dotIndex = name.lastIndexOf(\".\");\n                        String rootFilename = dotIndex > 0 ? name.substring(0, dotIndex) : name;\n                        pythonPreamble.pr(\"import \"+rootFilename+\"_pb2 as \"+rootFilename);\n                        protoNames.add(rootFilename);\n                    }\n                }\n                case ROS2: {\n                    \/\/ FIXME: Not supported yet\n                }\n            }\n        }\n    }","code_wo_comment":"@Override \n    public void enableSupportForSerializationIfApplicable(CancelIndicator cancelIndicator) {\n        if (!IterableExtensions.isNullOrEmpty(targetConfig.protoFiles)) {\n           \n            enabledSerializers.add(SupportedSerializers.PROTO);\n        }\n        for (SupportedSerializers serialization : enabledSerializers) {\n            switch (serialization) {\n                case NATIVE: {\n                    FedNativePythonSerialization pickler = new FedNativePythonSerialization();\n                    code.pr(pickler.generatePreambleForSupport().toString());\n                }\n                case PROTO: {\n                   \n                    for (String name : targetConfig.protoFiles) {\n                        this.processProtoFile(name, cancelIndicator);\n                        int dotIndex = name.lastIndexOf(\".\");\n                        String rootFilename = dotIndex > 0 ? name.substring(0, dotIndex) : name;\n                        pythonPreamble.pr(\"import \"+rootFilename+\"_pb2 as \"+rootFilename);\n                        protoNames.add(rootFilename);\n                    }\n                }\n                case ROS2: {\n                   \n                }\n            }\n        }\n    }","cleancode":"@override public void enablesupportforserializationifapplicable(cancelindicator cancelindicator) { if (!iterableextensions.isnullorempty(targetconfig.protofiles)) { enabledserializers.add(supportedserializers.proto); } for (supportedserializers serialization : enabledserializers) { switch (serialization) { case native: { fednativepythonserialization pickler = new fednativepythonserialization(); code.pr(pickler.generatepreambleforsupport().tostring()); } case proto: { for (string name : targetconfig.protofiles) { this.processprotofile(name, cancelindicator); int dotindex = name.lastindexof(\".\"); string rootfilename = dotindex > 0 ? name.substring(0, dotindex) : name; pythonpreamble.pr(\"import \"+rootfilename+\"_pb2 as \"+rootfilename); protonames.add(rootfilename); } } case ros2: { } } } }","repo":"soerendomroes\/lingua-franca","label":[0,1,0,0]}
{"id":15626,"original_code":"@Override \n    public void writeDockerFile(File dockerComposeDir, String dockerFileName, String federateName) {\n        if (mainDef == null) {\n            return;\n        }\n        Path srcGenPath = fileConfig.getSrcGenPath();\n        String dockerFile = srcGenPath + File.separator + dockerFileName;\n        CodeBuilder contents = new CodeBuilder();\n        contents.pr(PythonDockerGenerator.generateDockerFileContent(topLevelName, srcGenPath));\n        try {\n            \/\/ If a dockerfile exists, remove it.\n            Files.deleteIfExists(srcGenPath.resolve(dockerFileName));\n            contents.writeToFile(dockerFile);\n        } catch (IOException e) {\n            Exceptions.sneakyThrow(e);\n        }\n        System.out.println(getDockerBuildCommand(dockerFile, dockerComposeDir, federateName));\n    }","code_wo_comment":"@Override \n    public void writeDockerFile(File dockerComposeDir, String dockerFileName, String federateName) {\n        if (mainDef == null) {\n            return;\n        }\n        Path srcGenPath = fileConfig.getSrcGenPath();\n        String dockerFile = srcGenPath + File.separator + dockerFileName;\n        CodeBuilder contents = new CodeBuilder();\n        contents.pr(PythonDockerGenerator.generateDockerFileContent(topLevelName, srcGenPath));\n        try {\n           \n            Files.deleteIfExists(srcGenPath.resolve(dockerFileName));\n            contents.writeToFile(dockerFile);\n        } catch (IOException e) {\n            Exceptions.sneakyThrow(e);\n        }\n        System.out.println(getDockerBuildCommand(dockerFile, dockerComposeDir, federateName));\n    }","cleancode":"@override public void writedockerfile(file dockercomposedir, string dockerfilename, string federatename) { if (maindef == null) { return; } path srcgenpath = fileconfig.getsrcgenpath(); string dockerfile = srcgenpath + file.separator + dockerfilename; codebuilder contents = new codebuilder(); contents.pr(pythondockergenerator.generatedockerfilecontent(toplevelname, srcgenpath)); try { files.deleteifexists(srcgenpath.resolve(dockerfilename)); contents.writetofile(dockerfile); } catch (ioexception e) { exceptions.sneakythrow(e); } system.out.println(getdockerbuildcommand(dockerfile, dockercomposedir, federatename)); }","repo":"soerendomroes\/lingua-franca","label":[0,0,0,0]}
{"id":32106,"original_code":"@Test\n    public void testMakePaymentForSavingsAccountOnDeposit() throws Exception {\n        savingsBO = createClientSavingsAccount();\n        String deposit = \"400\";\n        CustomerDto clientDto = new CustomerDto();\n        clientDto.setCustomerId(client.getCustomerId());\n        \/\/FIXME why one day in future payment is allowed\n        LocalDate paymentDate = new LocalDate().plusDays(1);\n        LocalDate receiptDate = new LocalDate().minusDays(3);\n        String receiptNumber = \"AA\/03\/UX-9Q\";\n        Assert.assertEquals(0, savingsBO.getAccountPayments().size());\n        AccountPaymentParametersDto depositPayment = new AccountPaymentParametersDto(new UserReferenceDto(savingsBO\n                .getPersonnel().getPersonnelId()), new AccountReferenceDto(savingsBO.getAccountId()), new BigDecimal(\n                deposit), paymentDate, defaultPaymentType, \"comment\", receiptDate, receiptNumber,\n                clientDto);\n        standardAccountService.makePayment(depositPayment);\n        TestObjectFactory.updateObject(savingsBO);\n        Assert.assertEquals(\"The amount returned for the payment should have been \" + deposit, Double\n                .parseDouble(deposit), savingsBO.getLastPmntAmnt());\n        Assert.assertEquals(1, savingsBO.getAccountPayments().size());\n        for (AccountPaymentEntity payment : savingsBO.getAccountPayments()) {\n            Assert.assertEquals(TestUtils.createMoney(deposit), payment.getAmount());\n            Assert.assertEquals(1, payment.getAccountTrxns().size());\n            Assert.assertEquals(paymentDate.toDateMidnight().toDate(), payment.getPaymentDate());\n            Assert.assertEquals(defaultPaymentType.getName(), payment.getPaymentType().getName());\n            Assert.assertEquals(\"comment\", payment.getComment());\n            Assert.assertEquals(savingsBO, payment.getAccount());\n            Assert.assertEquals(savingsBO.getPersonnel(), payment.getCreatedByUser());\n            Assert.assertEquals(receiptDate.toDateMidnight().toDate(), payment.getReceiptDate());\n            Assert.assertEquals(receiptNumber, payment.getReceiptNumber());\n            Assert.assertNull(payment.getCheckNumber());\n            Assert.assertNull(payment.getBankName());\n            Assert.assertNull(payment.getVoucherNumber());\n            Assert.assertTrue(payment.isSavingsDeposit());\n            Assert.assertFalse(payment.isSavingsWithdrawal());\n            Assert.assertTrue(payment.isSavingsDepositOrWithdrawal());\n            for (AccountTrxnEntity accountTrxn : payment.getAccountTrxns()) {\n                Assert.assertEquals(client.getCustomerId(), accountTrxn.getCustomer().getCustomerId());\n            }\n        }\n    }","code_wo_comment":"@Test\n    public void testMakePaymentForSavingsAccountOnDeposit() throws Exception {\n        savingsBO = createClientSavingsAccount();\n        String deposit = \"400\";\n        CustomerDto clientDto = new CustomerDto();\n        clientDto.setCustomerId(client.getCustomerId());\n       \n        LocalDate paymentDate = new LocalDate().plusDays(1);\n        LocalDate receiptDate = new LocalDate().minusDays(3);\n        String receiptNumber = \"AA\/03\/UX-9Q\";\n        Assert.assertEquals(0, savingsBO.getAccountPayments().size());\n        AccountPaymentParametersDto depositPayment = new AccountPaymentParametersDto(new UserReferenceDto(savingsBO\n                .getPersonnel().getPersonnelId()), new AccountReferenceDto(savingsBO.getAccountId()), new BigDecimal(\n                deposit), paymentDate, defaultPaymentType, \"comment\", receiptDate, receiptNumber,\n                clientDto);\n        standardAccountService.makePayment(depositPayment);\n        TestObjectFactory.updateObject(savingsBO);\n        Assert.assertEquals(\"The amount returned for the payment should have been \" + deposit, Double\n                .parseDouble(deposit), savingsBO.getLastPmntAmnt());\n        Assert.assertEquals(1, savingsBO.getAccountPayments().size());\n        for (AccountPaymentEntity payment : savingsBO.getAccountPayments()) {\n            Assert.assertEquals(TestUtils.createMoney(deposit), payment.getAmount());\n            Assert.assertEquals(1, payment.getAccountTrxns().size());\n            Assert.assertEquals(paymentDate.toDateMidnight().toDate(), payment.getPaymentDate());\n            Assert.assertEquals(defaultPaymentType.getName(), payment.getPaymentType().getName());\n            Assert.assertEquals(\"comment\", payment.getComment());\n            Assert.assertEquals(savingsBO, payment.getAccount());\n            Assert.assertEquals(savingsBO.getPersonnel(), payment.getCreatedByUser());\n            Assert.assertEquals(receiptDate.toDateMidnight().toDate(), payment.getReceiptDate());\n            Assert.assertEquals(receiptNumber, payment.getReceiptNumber());\n            Assert.assertNull(payment.getCheckNumber());\n            Assert.assertNull(payment.getBankName());\n            Assert.assertNull(payment.getVoucherNumber());\n            Assert.assertTrue(payment.isSavingsDeposit());\n            Assert.assertFalse(payment.isSavingsWithdrawal());\n            Assert.assertTrue(payment.isSavingsDepositOrWithdrawal());\n            for (AccountTrxnEntity accountTrxn : payment.getAccountTrxns()) {\n                Assert.assertEquals(client.getCustomerId(), accountTrxn.getCustomer().getCustomerId());\n            }\n        }\n    }","cleancode":"@test public void testmakepaymentforsavingsaccountondeposit() throws exception { savingsbo = createclientsavingsaccount(); string deposit = \"400\"; customerdto clientdto = new customerdto(); clientdto.setcustomerid(client.getcustomerid()); localdate paymentdate = new localdate().plusdays(1); localdate receiptdate = new localdate().minusdays(3); string receiptnumber = \"aa\/03\/ux-9q\"; assert.assertequals(0, savingsbo.getaccountpayments().size()); accountpaymentparametersdto depositpayment = new accountpaymentparametersdto(new userreferencedto(savingsbo .getpersonnel().getpersonnelid()), new accountreferencedto(savingsbo.getaccountid()), new bigdecimal( deposit), paymentdate, defaultpaymenttype, \"comment\", receiptdate, receiptnumber, clientdto); standardaccountservice.makepayment(depositpayment); testobjectfactory.updateobject(savingsbo); assert.assertequals(\"the amount returned for the payment should have been \" + deposit, double .parsedouble(deposit), savingsbo.getlastpmntamnt()); assert.assertequals(1, savingsbo.getaccountpayments().size()); for (accountpaymententity payment : savingsbo.getaccountpayments()) { assert.assertequals(testutils.createmoney(deposit), payment.getamount()); assert.assertequals(1, payment.getaccounttrxns().size()); assert.assertequals(paymentdate.todatemidnight().todate(), payment.getpaymentdate()); assert.assertequals(defaultpaymenttype.getname(), payment.getpaymenttype().getname()); assert.assertequals(\"comment\", payment.getcomment()); assert.assertequals(savingsbo, payment.getaccount()); assert.assertequals(savingsbo.getpersonnel(), payment.getcreatedbyuser()); assert.assertequals(receiptdate.todatemidnight().todate(), payment.getreceiptdate()); assert.assertequals(receiptnumber, payment.getreceiptnumber()); assert.assertnull(payment.getchecknumber()); assert.assertnull(payment.getbankname()); assert.assertnull(payment.getvouchernumber()); assert.asserttrue(payment.issavingsdeposit()); assert.assertfalse(payment.issavingswithdrawal()); assert.asserttrue(payment.issavingsdepositorwithdrawal()); for (accounttrxnentity accounttrxn : payment.getaccounttrxns()) { assert.assertequals(client.getcustomerid(), accounttrxn.getcustomer().getcustomerid()); } } }","repo":"sureshkrishnamoorthy\/suresh-mifos","label":[1,0,0,0]}
{"id":32149,"original_code":"public static int raiseTo(int n, int p) {\n    if (n == 0) {\n      return 0;\n    }\n    if (p == 0) {\n      return 1;\n    }\n    if (n == 1) {\n      return n;\n    }\n    long result = n;\n    int counter = 1;\n    while (counter < p) {\n      if (result * n >= Integer.MAX_VALUE) {\n        return Integer.MAX_VALUE;\n      }\n      result *= n;\n      counter++;\n    }\n    return (int) result;\n  }","code_wo_comment":"public static int raiseTo(int n, int p) {\n    if (n == 0) {\n      return 0;\n    }\n    if (p == 0) {\n      return 1;\n    }\n    if (n == 1) {\n      return n;\n    }\n    long result = n;\n    int counter = 1;\n    while (counter < p) {\n      if (result * n >= Integer.MAX_VALUE) {\n        return Integer.MAX_VALUE;\n      }\n      result *= n;\n      counter++;\n    }\n    return (int) result;\n  }","cleancode":"public static int raiseto(int n, int p) { if (n == 0) { return 0; } if (p == 0) { return 1; } if (n == 1) { return n; } long result = n; int counter = 1; while (counter < p) { if (result * n >= integer.max_value) { return integer.max_value; } result *= n; counter++; } return (int) result; }","repo":"sachinlala\/JavaPerfTests","label":[1,0,0,0]}
{"id":24068,"original_code":"public static String assignShard(DocCollection collection, Integer numShards) {\n    if (numShards == null) {\n      numShards = 1;\n    }\n    String returnShardId = null;\n    Map<String, Slice> sliceMap = collection != null ? collection.getActiveSlicesMap() : null;\n    \/\/ TODO: now that we create shards ahead of time, is this code needed?  Esp since hash ranges aren't assigned when creating via this method?\n    if (sliceMap == null) {\n      return \"shard1\";\n    }\n    List<String> shardIdNames = new ArrayList<>(sliceMap.keySet());\n    if (shardIdNames.size() < numShards) {\n      return \"shard\" + (shardIdNames.size() + 1);\n    }\n    \/\/ TODO: don't need to sort to find shard with fewest replicas!\n    \/\/ else figure out which shard needs more replicas\n    final Map<String, Integer> map = new HashMap<>();\n    for (String shardId : shardIdNames) {\n      int cnt = sliceMap.get(shardId).getReplicasMap().size();\n      map.put(shardId, cnt);\n    }\n    Collections.sort(shardIdNames, (String o1, String o2) -> {\n      Integer one = map.get(o1);\n      Integer two = map.get(o2);\n      return one.compareTo(two);\n    });\n    returnShardId = shardIdNames.get(0);\n    return returnShardId;\n  }","code_wo_comment":"public static String assignShard(DocCollection collection, Integer numShards) {\n    if (numShards == null) {\n      numShards = 1;\n    }\n    String returnShardId = null;\n    Map<String, Slice> sliceMap = collection != null ? collection.getActiveSlicesMap() : null;\n   \n    if (sliceMap == null) {\n      return \"shard1\";\n    }\n    List<String> shardIdNames = new ArrayList<>(sliceMap.keySet());\n    if (shardIdNames.size() < numShards) {\n      return \"shard\" + (shardIdNames.size() + 1);\n    }\n   \n   \n    final Map<String, Integer> map = new HashMap<>();\n    for (String shardId : shardIdNames) {\n      int cnt = sliceMap.get(shardId).getReplicasMap().size();\n      map.put(shardId, cnt);\n    }\n    Collections.sort(shardIdNames, (String o1, String o2) -> {\n      Integer one = map.get(o1);\n      Integer two = map.get(o2);\n      return one.compareTo(two);\n    });\n    returnShardId = shardIdNames.get(0);\n    return returnShardId;\n  }","cleancode":"public static string assignshard(doccollection collection, integer numshards) { if (numshards == null) { numshards = 1; } string returnshardid = null; map<string, slice> slicemap = collection != null ? collection.getactiveslicesmap() : null; if (slicemap == null) { return \"shard1\"; } list<string> shardidnames = new arraylist<>(slicemap.keyset()); if (shardidnames.size() < numshards) { return \"shard\" + (shardidnames.size() + 1); } final map<string, integer> map = new hashmap<>(); for (string shardid : shardidnames) { int cnt = slicemap.get(shardid).getreplicasmap().size(); map.put(shardid, cnt); } collections.sort(shardidnames, (string o1, string o2) -> { integer one = map.get(o1); integer two = map.get(o2); return one.compareto(two); }); returnshardid = shardidnames.get(0); return returnshardid; }","repo":"robin850\/solr","label":[1,0,0,0]}
{"id":24102,"original_code":"@Test\n    @MediumTest\n    public void testAppButtonExitsVoiceInput() throws InterruptedException {\n        Runnable exitAction = () -> {\n            NativeUiUtils.clickAppButton(UserFriendlyElementName.CURRENT_POSITION, new PointF());\n        };\n        testExitVoiceInputImpl(exitAction);\n    }","code_wo_comment":"@Test\n    @MediumTest\n    public void testAppButtonExitsVoiceInput() throws InterruptedException {\n        Runnable exitAction = () -> {\n            NativeUiUtils.clickAppButton(UserFriendlyElementName.CURRENT_POSITION, new PointF());\n        };\n        testExitVoiceInputImpl(exitAction);\n    }","cleancode":"@test @mediumtest public void testappbuttonexitsvoiceinput() throws interruptedexception { runnable exitaction = () -> { nativeuiutils.clickappbutton(userfriendlyelementname.current_position, new pointf()); }; testexitvoiceinputimpl(exitaction); }","repo":"sarang-apps\/darshan_browser","label":[0,0,0,1]}
{"id":15921,"original_code":"public static Map<String, List<Object>> parseAttributes(String samlResponse,\n      Set<String> attributes) throws ServletException {\n    Map<String, List<Object>> parsedResult = new HashMap<>();\n    \/\/ TODO - Using a library for managing collections\n    if (attributes == null || attributes.isEmpty()) {\n      return parsedResult;\n    }\n    byte[] samlAssertionDecoded = new byte[0];\n    try {\n      samlAssertionDecoded = Base64.decodeBase64(samlResponse.getBytes(\"UTF-8\"));\n    } catch (UnsupportedEncodingException e) {\n      throw new RuntimeException(\"Unsupported encoding to decode Saml Response\");\n    }\n    ByteArrayInputStream is = new ByteArrayInputStream(samlAssertionDecoded);\n    Assertion assertion;\n    try {\n      DocumentBuilder builder = factory.newDocumentBuilder();\n      Document document = builder.parse(is);\n      Element element = document.getDocumentElement();\n      Unmarshaller unmarshaller = unmarshallerFactory.getUnmarshaller(element);\n      if (unmarshaller == null) {\n        throw new RuntimeException(\"Could not find an unmarshaller for XML parsing\");\n      }\n      XMLObject responseXmlObj = unmarshaller.unmarshall(element);\n      Response response = (Response) responseXmlObj;\n      if (response.getAssertions() == null || response.getAssertions().isEmpty()) {\n        throw new ServletException(\"No assertions found in SAML response\");\n      }\n      assertion = response.getAssertions().get(0);\n    } catch (UnmarshallingException | ParserConfigurationException | SAXException | IOException e) {\n      throw new ServletException(\"Could not parse the SAML assertion\", e);\n    }\n    for (AttributeStatement attributeStatement : assertion.getAttributeStatements()) {\n      for (Attribute attribute : attributeStatement.getAttributes()) {\n        if (attributes.contains(attribute.getName())) {\n          List<Object> values = new ArrayList<>(attribute.getAttributeValues());\n          parsedResult.put(attribute.getName(), values);\n        }\n      }\n    }\n    return parsedResult;\n  }","code_wo_comment":"public static Map<String, List<Object>> parseAttributes(String samlResponse,\n      Set<String> attributes) throws ServletException {\n    Map<String, List<Object>> parsedResult = new HashMap<>();\n   \n    if (attributes == null || attributes.isEmpty()) {\n      return parsedResult;\n    }\n    byte[] samlAssertionDecoded = new byte[0];\n    try {\n      samlAssertionDecoded = Base64.decodeBase64(samlResponse.getBytes(\"UTF-8\"));\n    } catch (UnsupportedEncodingException e) {\n      throw new RuntimeException(\"Unsupported encoding to decode Saml Response\");\n    }\n    ByteArrayInputStream is = new ByteArrayInputStream(samlAssertionDecoded);\n    Assertion assertion;\n    try {\n      DocumentBuilder builder = factory.newDocumentBuilder();\n      Document document = builder.parse(is);\n      Element element = document.getDocumentElement();\n      Unmarshaller unmarshaller = unmarshallerFactory.getUnmarshaller(element);\n      if (unmarshaller == null) {\n        throw new RuntimeException(\"Could not find an unmarshaller for XML parsing\");\n      }\n      XMLObject responseXmlObj = unmarshaller.unmarshall(element);\n      Response response = (Response) responseXmlObj;\n      if (response.getAssertions() == null || response.getAssertions().isEmpty()) {\n        throw new ServletException(\"No assertions found in SAML response\");\n      }\n      assertion = response.getAssertions().get(0);\n    } catch (UnmarshallingException | ParserConfigurationException | SAXException | IOException e) {\n      throw new ServletException(\"Could not parse the SAML assertion\", e);\n    }\n    for (AttributeStatement attributeStatement : assertion.getAttributeStatements()) {\n      for (Attribute attribute : attributeStatement.getAttributes()) {\n        if (attributes.contains(attribute.getName())) {\n          List<Object> values = new ArrayList<>(attribute.getAttributeValues());\n          parsedResult.put(attribute.getName(), values);\n        }\n      }\n    }\n    return parsedResult;\n  }","cleancode":"public static map<string, list<object>> parseattributes(string samlresponse, set<string> attributes) throws servletexception { map<string, list<object>> parsedresult = new hashmap<>(); if (attributes == null || attributes.isempty()) { return parsedresult; } byte[] samlassertiondecoded = new byte[0]; try { samlassertiondecoded = base64.decodebase64(samlresponse.getbytes(\"utf-8\")); } catch (unsupportedencodingexception e) { throw new runtimeexception(\"unsupported encoding to decode saml response\"); } bytearrayinputstream is = new bytearrayinputstream(samlassertiondecoded); assertion assertion; try { documentbuilder builder = factory.newdocumentbuilder(); document document = builder.parse(is); element element = document.getdocumentelement(); unmarshaller unmarshaller = unmarshallerfactory.getunmarshaller(element); if (unmarshaller == null) { throw new runtimeexception(\"could not find an unmarshaller for xml parsing\"); } xmlobject responsexmlobj = unmarshaller.unmarshall(element); response response = (response) responsexmlobj; if (response.getassertions() == null || response.getassertions().isempty()) { throw new servletexception(\"no assertions found in saml response\"); } assertion = response.getassertions().get(0); } catch (unmarshallingexception | parserconfigurationexception | saxexception | ioexception e) { throw new servletexception(\"could not parse the saml assertion\", e); } for (attributestatement attributestatement : assertion.getattributestatements()) { for (attribute attribute : attributestatement.getattributes()) { if (attributes.contains(attribute.getname())) { list<object> values = new arraylist<>(attribute.getattributevalues()); parsedresult.put(attribute.getname(), values); } } } return parsedresult; }","repo":"sharad-oss\/knox","label":[0,1,0,0]}
{"id":16008,"original_code":"@Override\n\tpublic void makeMove() {\n\t\t\/\/ TODO Not just randomly select a tile to mark\n\t\twhile (true) {\n\t\t\ttry {\n\t\t\t\tList<Tile> tiles = getGameLogic().getTerritory().getTiles();\n\t\t\t\tTile tile = tiles.get(GameLogic.RANDOM.nextInt(tiles.size()));\n\t\t\t\ttile.setMarkedPlayer(this);\n\t\t\t\tgetGameLogic().endMove();\n\t\t\t\treturn;\n\t\t\t} catch (TileAreadyMarkedException e) {\n\t\t\t}\n\t\t}\n\t}","code_wo_comment":"@Override\n\tpublic void makeMove() {\n\t\n\t\twhile (true) {\n\t\t\ttry {\n\t\t\t\tList<Tile> tiles = getGameLogic().getTerritory().getTiles();\n\t\t\t\tTile tile = tiles.get(GameLogic.RANDOM.nextInt(tiles.size()));\n\t\t\t\ttile.setMarkedPlayer(this);\n\t\t\t\tgetGameLogic().endMove();\n\t\t\t\treturn;\n\t\t\t} catch (TileAreadyMarkedException e) {\n\t\t\t}\n\t\t}\n\t}","cleancode":"@override public void makemove() { while (true) { try { list<tile> tiles = getgamelogic().getterritory().gettiles(); tile tile = tiles.get(gamelogic.random.nextint(tiles.size())); tile.setmarkedplayer(this); getgamelogic().endmove(); return; } catch (tileareadymarkedexception e) { } } }","repo":"sengerts\/tic-tac-toe","label":[1,0,0,0]}
{"id":16106,"original_code":"public static String getData() {\n        Future<String> f = getInstance().startupFuture.get();\n        if (f == null) {\n            \/\/ FIXME haven't even started yet... need to busy-wait, perhaps\n        }\n        try {\n            String data = f.get(30, TimeUnit.SECONDS);\n            return data;\n        } catch (InterruptedException | ExecutionException e) {\n            \/\/ FIXME failed to startup or was interrupted during startup; maybe throw to the caller?\n            throw new IllegalStateException(e);\n        } catch (TimeoutException e) {\n            \/\/ FIXME got tired of waiting, maybe do something special here?\n            throw new IllegalStateException(e);\n        }\n    }","code_wo_comment":"public static String getData() {\n        Future<String> f = getInstance().startupFuture.get();\n        if (f == null) {\n           \n        }\n        try {\n            String data = f.get(30, TimeUnit.SECONDS);\n            return data;\n        } catch (InterruptedException | ExecutionException e) {\n           \n            throw new IllegalStateException(e);\n        } catch (TimeoutException e) {\n           \n            throw new IllegalStateException(e);\n        }\n    }","cleancode":"public static string getdata() { future<string> f = getinstance().startupfuture.get(); if (f == null) { } try { string data = f.get(30, timeunit.seconds); return data; } catch (interruptedexception | executionexception e) { throw new illegalstateexception(e); } catch (timeoutexception e) { throw new illegalstateexception(e); } }","repo":"seemikehack\/synchronized-startup","label":[0,0,1,0]}
{"id":8111,"original_code":"public synchronized void start() throws IOException, InterruptedException {\n        final AtomicBoolean bound = new AtomicBoolean();\n        running.set(true);\n        Thread t = new Thread(new Runnable() {\n            @Override\n            public void run() {\n                try {\n                    ServerSocket ss = new ServerSocket(port);\n                    synchronized (bound) {\n                        bound.set(true);\n                        bound.notifyAll();\n                    }\n                    Socket[] conn = new Socket[nDataGens];\n                    try {\n                        for (int i = 0; i < nDataGens; i++) {\n                            conn[i] = ss.accept();\n                        }\n                        for (int n = 0; n < nIntervals; ++n) {\n                            \/\/TODO refactor operations according to the protocol message\n                            if (flagStopResume) {\n                                for (int i = 0; i < nDataGens; i++) {\n                                    receiveStopped(conn[i]);\n                                }\n                                protocolActions[n].perform();\n                                if (n != nIntervals - 1) {\n                                    for (int i = 0; i < nDataGens; i++) {\n                                        sendResume(conn[i]);\n                                    }\n                                }\n                            } else {\n                                for (int i = 0; i < nDataGens; i++) {\n                                    receiveReached(conn[i]);\n                                }\n                                protocolActions[n].perform();\n                            }\n                        }\n                    } finally {\n                        for (int i = 0; i < conn.length; ++i) {\n                            if (conn[i] != null) {\n                                conn[i].close();\n                            }\n                        }\n                        ss.close();\n                    }\n                    running.set(false);\n                    synchronized (OrchestratorServer.this) {\n                        OrchestratorServer.this.notifyAll();\n                    }\n                } catch (Throwable t) {\n                    t.printStackTrace();\n                }\n            }\n        });\n        t.start();\n        synchronized (bound) {\n            while (!bound.get()) {\n                bound.wait();\n            }\n        }\n    }","code_wo_comment":"public synchronized void start() throws IOException, InterruptedException {\n        final AtomicBoolean bound = new AtomicBoolean();\n        running.set(true);\n        Thread t = new Thread(new Runnable() {\n            @Override\n            public void run() {\n                try {\n                    ServerSocket ss = new ServerSocket(port);\n                    synchronized (bound) {\n                        bound.set(true);\n                        bound.notifyAll();\n                    }\n                    Socket[] conn = new Socket[nDataGens];\n                    try {\n                        for (int i = 0; i < nDataGens; i++) {\n                            conn[i] = ss.accept();\n                        }\n                        for (int n = 0; n < nIntervals; ++n) {\n                           \n                            if (flagStopResume) {\n                                for (int i = 0; i < nDataGens; i++) {\n                                    receiveStopped(conn[i]);\n                                }\n                                protocolActions[n].perform();\n                                if (n != nIntervals - 1) {\n                                    for (int i = 0; i < nDataGens; i++) {\n                                        sendResume(conn[i]);\n                                    }\n                                }\n                            } else {\n                                for (int i = 0; i < nDataGens; i++) {\n                                    receiveReached(conn[i]);\n                                }\n                                protocolActions[n].perform();\n                            }\n                        }\n                    } finally {\n                        for (int i = 0; i < conn.length; ++i) {\n                            if (conn[i] != null) {\n                                conn[i].close();\n                            }\n                        }\n                        ss.close();\n                    }\n                    running.set(false);\n                    synchronized (OrchestratorServer.this) {\n                        OrchestratorServer.this.notifyAll();\n                    }\n                } catch (Throwable t) {\n                    t.printStackTrace();\n                }\n            }\n        });\n        t.start();\n        synchronized (bound) {\n            while (!bound.get()) {\n                bound.wait();\n            }\n        }\n    }","cleancode":"public synchronized void start() throws ioexception, interruptedexception { final atomicboolean bound = new atomicboolean(); running.set(true); thread t = new thread(new runnable() { @override public void run() { try { serversocket ss = new serversocket(port); synchronized (bound) { bound.set(true); bound.notifyall(); } socket[] conn = new socket[ndatagens]; try { for (int i = 0; i < ndatagens; i++) { conn[i] = ss.accept(); } for (int n = 0; n < nintervals; ++n) { if (flagstopresume) { for (int i = 0; i < ndatagens; i++) { receivestopped(conn[i]); } protocolactions[n].perform(); if (n != nintervals - 1) { for (int i = 0; i < ndatagens; i++) { sendresume(conn[i]); } } } else { for (int i = 0; i < ndatagens; i++) { receivereached(conn[i]); } protocolactions[n].perform(); } } } finally { for (int i = 0; i < conn.length; ++i) { if (conn[i] != null) { conn[i].close(); } } ss.close(); } running.set(false); synchronized (orchestratorserver.this) { orchestratorserver.this.notifyall(); } } catch (throwable t) { t.printstacktrace(); } } }); t.start(); synchronized (bound) { while (!bound.get()) { bound.wait(); } } }","repo":"srinivas491\/AsterixDB","label":[1,0,0,0]}
{"id":16343,"original_code":"@Override\n    public void registerDefaults() {\n        \/\/ @formatter:off\n        \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n        \/\/\/    Air      \/\/\/\n        \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n        register(0, builder()\n                        .properties(PropertyProviderCollections.DEFAULT_GAS)\n                        .translation(\"tile.air.name\")\n                        .build(\"minecraft\", \"air\"));\n        \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n        \/\/\/    Stone    \/\/\/\n        \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n        register(1, simpleBuilder()\n                        .trait(LanternEnumTraits.STONE_TYPE)\n                        .defaultState(state -> state.withTrait(LanternEnumTraits.STONE_TYPE, LanternStoneType.STONE).get())\n                        .itemType(builder -> builder\n                                .keysProvider(collection -> collection\n                                        .register(Keys.STONE_TYPE, LanternStoneType.STONE)\n                                )\n                        )\n                        .properties(builder -> builder\n                                .add(hardness(1.5))\n                                .add(blastResistance(30.0)))\n                        .translation(TranslationProvider.of(LanternEnumTraits.STONE_TYPE))\n                        .build(\"minecraft\", \"stone\"),\n                blockState -> (byte) blockState.getTraitValue(LanternEnumTraits.STONE_TYPE).get().getInternalId());\n        \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n        \/\/\/    Grass    \/\/\/\n        \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n        register(2, simpleBuilder()\n                        .trait(LanternBooleanTraits.SNOWY)\n                        .extendedStateProvider(new SnowyExtendedBlockStateProvider())\n                        .defaultState(state -> state.withTrait(LanternBooleanTraits.SNOWY, false).get())\n                        .itemType()\n                        .properties(builder -> builder\n                                .add(hardness(0.6))\n                                .add(blastResistance(3.0)))\n                        .translation(\"tile.grass.name\")\n                        .build(\"minecraft\", \"grass\"));\n        \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n        \/\/\/    Dirt     \/\/\/\n        \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n        register(3, simpleBuilder()\n                        .traits(LanternEnumTraits.DIRT_TYPE, LanternBooleanTraits.SNOWY)\n                        .defaultState(state -> state\n                                .withTrait(LanternEnumTraits.DIRT_TYPE, LanternDirtType.DIRT).get()\n                                .withTrait(LanternBooleanTraits.SNOWY, false).get())\n                        .extendedStateProvider(new SnowyExtendedBlockStateProvider())\n                        .itemType(builder -> builder\n                                .keysProvider(collection -> collection\n                                        .register(Keys.DIRT_TYPE, LanternDirtType.DIRT)\n                                )\n                        )\n                        .properties(builder -> builder\n                                .add(hardness(0.5))\n                                .add(blastResistance(2.5)))\n                        .translation(TranslationProvider.of(LanternEnumTraits.DIRT_TYPE))\n                        .build(\"minecraft\", \"dirt\"),\n                blockState -> (byte) blockState.getTraitValue(LanternEnumTraits.DIRT_TYPE).get().getInternalId());\n        \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n        \/\/\/ Cobblestone \/\/\/\n        \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n        register(4, simpleBuilder()\n                        .itemType()\n                        .properties(builder -> builder\n                                .add(hardness(2.0))\n                                .add(blastResistance(3.0)))\n                        .translation(\"tile.stonebrick.name\")\n                        .build(\"minecraft\", \"cobblestone\"));\n        \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n        \/\/\/    Planks   \/\/\/\n        \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n        register(5, simpleBuilder()\n                        .trait(LanternEnumTraits.TREE_TYPE)\n                        .defaultState(state -> state.withTrait(LanternEnumTraits.TREE_TYPE, LanternTreeType.OAK).get())\n                        .itemType(builder -> builder\n                                .keysProvider(collection -> collection\n                                        .register(Keys.TREE_TYPE, LanternTreeType.OAK)\n                                )\n                        )\n                        .properties(builder -> builder\n                                .add(hardness(2.0))\n                                .add(blastResistance(5.0))\n                                .add(flammableInfo(5, 20)))\n                        .translation(TranslationProvider.of(LanternEnumTraits.TREE_TYPE, type ->\n                                tr(\"tile.planks.\" + type.getTranslationKeyBase() + \".name\")))\n                        .build(\"minecraft\", \"planks\"),\n                blockState -> (byte) blockState.getTraitValue(LanternEnumTraits.TREE_TYPE).get().getInternalId());\n        \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n        \/\/\/    Sapling   \/\/\/\n        \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n        register(6, simpleBuilder()\n                        .traits(LanternEnumTraits.TREE_TYPE, LanternIntegerTraits.SAPLING_GROWTH_STAGE)\n                        .defaultState(state -> state\n                                .withTrait(LanternEnumTraits.TREE_TYPE, LanternTreeType.OAK).get()\n                                .withTrait(LanternIntegerTraits.SAPLING_GROWTH_STAGE, 0).get())\n                        .itemType(builder -> builder\n                                .keysProvider(collection -> collection\n                                        .register(Keys.TREE_TYPE, LanternTreeType.OAK)\n                                )\n                        )\n                        .properties(builder -> builder\n                                .add(PASSABLE)\n                                .add(INSTANT_BROKEN))\n                        .translation(TranslationProvider.of(LanternEnumTraits.TREE_TYPE, type ->\n                                tr(\"tile.sapling.\" + type.getTranslationKeyBase() + \".name\")))\n                        .build(\"minecraft\", \"sapling\"),\n                blockState -> {\n                    final int type = blockState.getTraitValue(LanternEnumTraits.TREE_TYPE).get().getInternalId();\n                    final int stage = blockState.getTraitValue(LanternIntegerTraits.SAPLING_GROWTH_STAGE).get();\n                    return (byte) (stage << 3 | type);\n                });\n        \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n        \/\/\/    Bedrock   \/\/\/\n        \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n        register(7, simpleBuilder()\n                        .itemType()\n                        .properties(builder -> builder\n                                .add(PropertyProviderCollections.UNBREAKABLE))\n                        .translation(\"tile.bedrock.name\")\n                        .build(\"minecraft\", \"bedrock\"));\n        \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n        \/\/\/     Sand     \/\/\/\n        \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n        register(12, simpleBuilder()\n                        .trait(LanternEnumTraits.SAND_TYPE)\n                        .defaultState(state -> state.withTrait(LanternEnumTraits.SAND_TYPE, LanternSandType.NORMAL).get())\n                        .itemType(builder -> builder\n                                .keysProvider(collection -> collection\n                                        .register(Keys.SAND_TYPE, LanternSandType.NORMAL)\n                                )\n                        )\n                        .properties(builder -> builder\n                                .add(hardness(0.5))\n                                .add(blastResistance(2.5)))\n                        .translation(TranslationProvider.of(LanternEnumTraits.SAND_TYPE))\n                        .build(\"minecraft\", \"sand\"),\n                blockState -> (byte) blockState.getTraitValue(LanternEnumTraits.SAND_TYPE).get().getInternalId());\n        \/\/ TODO: Sand physics behavior\n        \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n        \/\/\/    Gravel    \/\/\/\n        \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n        register(13, simpleBuilder()\n                        .itemType()\n                        .properties(builder -> builder\n                                .add(hardness(0.6))\n                                .add(blastResistance(3.0)))\n                        .translation(\"tile.gravel.name\")\n                        .build(\"minecraft\", \"gravel\"));\n        \/\/ TODO: Gravel physics behavior\n        \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n        \/\/\/   Gold Ore   \/\/\/\n        \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n        register(14, simpleBuilder()\n                        .itemType()\n                        .properties(builder -> builder\n                                .add(hardness(3.0))\n                                .add(blastResistance(15.0)))\n                        .translation(\"tile.oreGold.name\")\n                        .build(\"minecraft\", \"gold_ore\"));\n        \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n        \/\/\/   Iron Ore   \/\/\/\n        \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n        register(15, simpleBuilder()\n                        .itemType()\n                        .properties(builder -> builder\n                                .add(hardness(3.0))\n                                .add(blastResistance(15.0)))\n                        .translation(\"tile.oreIron.name\")\n                        .build(\"minecraft\", \"iron_ore\"));\n        \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n        \/\/\/   Coal Ore   \/\/\/\n        \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n        register(16, simpleBuilder()\n                        .itemType()\n                        .properties(builder -> builder\n                                .add(hardness(3.0))\n                                .add(blastResistance(15.0)))\n                        .translation(\"tile.oreCoal.name\")\n                        .build(\"minecraft\", \"coal_ore\"));\n        \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n        \/\/\/    Log 1     \/\/\/\n        \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n        register(17, logBuilder(LanternEnumTraits.LOG1_TYPE, LanternTreeType.OAK)\n                        .build(\"minecraft\", \"log\"),\n                blockState -> logData(blockState, blockState.getTraitValue(LanternEnumTraits.LOG1_TYPE).get().getInternalId()));\n        \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n        \/\/\/   Leaves 1   \/\/\/\n        \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n        register(18, leavesBuilder(LanternEnumTraits.LEAVES1_TYPE, LanternTreeType.OAK)\n                        .build(\"minecraft\", \"leaves\"),\n                blockState -> leavesData(blockState, blockState.getTraitValue(LanternEnumTraits.LEAVES1_TYPE).get().getInternalId()));\n        \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n        \/\/\/    Sponge    \/\/\/\n        \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n        register(19, simpleBuilder()\n                        .trait(LanternBooleanTraits.IS_WET)\n                        .defaultState(state -> state.withTrait(LanternBooleanTraits.IS_WET, false).get())\n                        .itemType(builder -> builder\n                                .keysProvider(collection -> collection\n                                        .register(Keys.IS_WET, false)\n                                )\n                        )\n                        .properties(builder -> builder\n                                .add(hardness(0.6))\n                                .add(blastResistance(3.0)))\n                        .translation(new SpongeTranslationProvider())\n                        .build(\"minecraft\", \"sponge\"),\n                blockState -> (byte) (blockState.getTraitValue(LanternBooleanTraits.IS_WET).get() ? 1 : 0));\n        \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n        \/\/\/    Glass     \/\/\/\n        \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n        register(20, simpleBuilder()\n                        .itemType()\n                        .properties(builder -> builder\n                                .add(hardness(0.3))\n                                .add(blastResistance(1.5)))\n                        .translation(\"tile.glass.name\")\n                        .build(\"minecraft\", \"glass\"));\n        \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n        \/\/\/   Lapis Ore  \/\/\/\n        \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n        register(21, simpleBuilder()\n                        .itemType()\n                        .properties(builder -> builder\n                                .add(hardness(3.0))\n                                .add(blastResistance(15.0)))\n                        .translation(\"tile.oreLapis.name\")\n                        .build(\"minecraft\", \"lapis_ore\"));\n        \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n        \/\/\/  Lapis Block \/\/\/\n        \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n        register(22, simpleBuilder()\n                        .itemType()\n                        .properties(builder -> builder\n                                .add(hardness(3.0))\n                                .add(blastResistance(15.0)))\n                        .translation(\"tile.blockLapis.name\")\n                        .build(\"minecraft\", \"lapis_block\"));\n        \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n        \/\/\/   Dispenser  \/\/\/\n        \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n        register(23, simpleBuilder()\n                        .traits(LanternEnumTraits.FACING, LanternBooleanTraits.TRIGGERED)\n                        .defaultState(state -> state\n                                .withTrait(LanternEnumTraits.FACING, Direction.NORTH).get()\n                                .withTrait(LanternBooleanTraits.TRIGGERED, false).get())\n                        .itemType()\n                        .properties(builder -> builder\n                                .add(hardness(3.5))\n                                .add(blastResistance(17.5)))\n                        \/\/ .tileEntityType(() -> TileEntityTypes.DISPENSER)\n                        .translation(\"tile.dispenser.name\")\n                        .behaviors(pipeline -> pipeline\n                                .add(new RotationPlacementBehavior()))\n                        .build(\"minecraft\", \"dispenser\"),\n                blockState -> {\n                    int data = directionData(blockState.getTraitValue(LanternEnumTraits.FACING).get());\n                    if (blockState.getTraitValue(LanternBooleanTraits.TRIGGERED).get()) {\n                        data |= 0x8;\n                    }\n                    return (byte) data;\n                });\n        \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n        \/\/\/   Sandstone  \/\/\/\n        \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n        register(24, simpleBuilder()\n                        .trait(LanternEnumTraits.SANDSTONE_TYPE)\n                        .defaultState(state -> state.withTrait(LanternEnumTraits.SANDSTONE_TYPE, LanternSandstoneType.DEFAULT).get())\n                        .itemType(builder -> builder\n                                .keysProvider(collection -> collection\n                                        .register(Keys.SANDSTONE_TYPE, LanternSandstoneType.DEFAULT)\n                                )\n                        )\n                        .properties(builder -> builder\n                                .add(hardness(0.8))\n                                .add(blastResistance(4.0)))\n                        .translation(TranslationProvider.of(LanternEnumTraits.SANDSTONE_TYPE))\n                        .build(\"minecraft\", \"sandstone\"),\n                blockState -> (byte) blockState.getTraitValue(LanternEnumTraits.SANDSTONE_TYPE).get().getInternalId());\n        \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n        \/\/\/   Noteblock  \/\/\/\n        \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n        register(25, simpleBuilder()\n                        .itemType()\n                        .properties(builder -> builder\n                                .add(hardness(0.8))\n                                .add(blastResistance(4.0)))\n                        .translation(\"tile.musicBlock.name\")\n                        .tileEntityType(() -> TileEntityTypes.NOTE)\n                        .behaviors(pipeline -> pipeline\n                                .add(new NoteBlockInteractionBehavior()))\n                        .build(\"minecraft\", \"noteblock\"));\n        \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n        \/\/\/     Bed      \/\/\/\n        \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n        register(26, simpleBuilder()\n                        .traits(LanternEnumTraits.HORIZONTAL_FACING, LanternEnumTraits.BED_PART, LanternBooleanTraits.OCCUPIED)\n                        .defaultState(state -> state\n                                .withTrait(LanternEnumTraits.HORIZONTAL_FACING, Direction.NORTH).get()\n                                .withTrait(LanternEnumTraits.BED_PART, LanternBedPart.FOOT).get()\n                                .withTrait(LanternBooleanTraits.OCCUPIED, false).get())\n                        .properties(builder -> builder\n                                .add(hardness(0.2))\n                                .add(blastResistance(1.0)))\n                        .translation(\"tile.bed.name\")\n                        .build(\"minecraft\", \"bed\"),\n                blockState -> {\n                    final Direction facing = blockState.getTraitValue(LanternEnumTraits.HORIZONTAL_FACING).get();\n                    int type = facing == Direction.SOUTH  ? 0 : facing == Direction.WEST ? 1 :\n                            facing == Direction.NORTH ? 2 : facing == Direction.EAST ? 3 : -1;\n                    checkArgument(type != -1);\n                    if (blockState.getTraitValue(LanternBooleanTraits.OCCUPIED).get()) {\n                        type |= 0x4;\n                    }\n                    if (blockState.getTraitValue(LanternEnumTraits.BED_PART).get() == LanternBedPart.HEAD) {\n                        type |= 0x8;\n                    }\n                    return (byte) type;\n                });\n        \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n        \/\/\/   Golden Rail  \/\/\/\n        \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n        register(27, simpleBuilder()\n                        .traits(LanternEnumTraits.STRAIGHT_RAIL_DIRECTION, LanternBooleanTraits.POWERED)\n                        .defaultState(state -> state\n                                .withTrait(LanternEnumTraits.STRAIGHT_RAIL_DIRECTION, LanternRailDirection.NORTH_SOUTH).get()\n                                .withTrait(LanternBooleanTraits.POWERED, false).get())\n                        .itemType()\n                        .selectionBox(BoundingBoxes::rail)\n                        .properties(builder -> builder\n                                .add(PASSABLE)\n                                .add(hardness(0.7))\n                                .add(blastResistance(3.5)))\n                        .translation(\"tile.goldenRail.name\")\n                        .build(\"minecraft\", \"golden_rail\"),\n                blockState -> {\n                    int type = blockState.getTraitValue(LanternEnumTraits.STRAIGHT_RAIL_DIRECTION).get().getInternalId();\n                    if (blockState.getTraitValue(LanternBooleanTraits.POWERED).get()) {\n                        type |= 0x8;\n                    }\n                    return (byte) type;\n                });\n        \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n        \/\/\/   Detector Rail  \/\/\/\n        \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n        register(28, simpleBuilder()\n                        .traits(LanternEnumTraits.STRAIGHT_RAIL_DIRECTION, LanternBooleanTraits.POWERED)\n                        .defaultState(state -> state\n                                .withTrait(LanternEnumTraits.STRAIGHT_RAIL_DIRECTION, LanternRailDirection.NORTH_SOUTH).get()\n                                .withTrait(LanternBooleanTraits.POWERED, false).get())\n                        .itemType()\n                        .selectionBox(BoundingBoxes::rail)\n                        .properties(builder -> builder\n                                .add(PASSABLE)\n                                .add(hardness(0.7))\n                                .add(blastResistance(3.5)))\n                        .translation(\"tile.detectorRail.name\")\n                        .build(\"minecraft\", \"detector_rail\"),\n                blockState -> {\n                    int type = blockState.getTraitValue(LanternEnumTraits.STRAIGHT_RAIL_DIRECTION).get().getInternalId();\n                    if (blockState.getTraitValue(LanternBooleanTraits.POWERED).get()) {\n                        type |= 0x8;\n                    }\n                    return (byte) type;\n                });\n        \/\/ TODO: 29\n        \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n        \/\/\/   Web   \/\/\/\n        \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n        register(30, simpleBuilder()\n                        .itemType()\n                        .properties(builder -> builder\n                                .add(PASSABLE)\n                                .add(hardness(4.0))\n                                .add(blastResistance(20.0)))\n                        .translation(\"tile.web.name\")\n                        .build(\"minecraft\", \"web\"));\n        \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n        \/\/\/   Tall Grass   \/\/\/\n        \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n        register(31, simpleBuilder()\n                        .traits(LanternEnumTraits.SHRUB_TYPE)\n                            .defaultState(state -> state\n                                    .withTrait(LanternEnumTraits.SHRUB_TYPE, LanternShrubType.DEAD_BUSH).get())\n                        .itemType(builder -> builder\n                                .keysProvider(collection -> collection\n                                        .register(Keys.SHRUB_TYPE, LanternShrubType.DEAD_BUSH)))\n                        .selectionBox(BoundingBoxes.bush())\n                        .properties(builder -> builder\n                                .add(INSTANT_BROKEN)\n                                .add(PASSABLE)\n                                .add(replaceable(true)))\n                        .translation(\"tile.tallgrass.name\")\n                        .build(\"minecraft\", \"tallgrass\"),\n                blockState -> (byte) blockState.getTraitValue(LanternEnumTraits.SHRUB_TYPE).get().getInternalId());\n        \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n        \/\/\/   Dead Bush   \/\/\/\n        \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n        register(32, simpleBuilder()\n                        .properties(builder -> builder\n                                .add(INSTANT_BROKEN)\n                                .add(PASSABLE)\n                                .add(replaceable(true)))\n                        .selectionBox(BoundingBoxes.bush())\n                        .itemType()\n                        .translation(\"tile.deadbush.name\")\n                        .build(\"minecraft\", \"deadbush\"));\n        \/\/ TODO: 33\n        \/\/ TODO: 34\n        \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n        \/\/\/     Wool    \/\/\/\n        \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n        register(35, dyedBuilder(\"tile.wool.%s.name\")\n                        .properties(builder -> builder\n                                .add(hardness(0.8))\n                                .add(blastResistance(4.0)))\n                        .build(\"minecraft\", \"wool\"),\n                this::dyedData);\n        \/\/ TODO: 36\n        \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n        \/\/\/   Yellow Flower   \/\/\/\n        \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n        register(37, simpleBuilder()\n                        .traits(LanternEnumTraits.YELLOW_FLOWER_TYPE)\n                        .defaultState(state -> state\n                                .withTrait(LanternEnumTraits.YELLOW_FLOWER_TYPE, LanternPlantType.DANDELION).get())\n                        .itemType(builder -> builder\n                                .keysProvider(collection -> collection\n                                        .register(Keys.PLANT_TYPE, LanternPlantType.DANDELION)))\n                        .selectionBox(BoundingBoxes.bush())\n                        .properties(builder -> builder\n                                .add(INSTANT_BROKEN)\n                                .add(PASSABLE))\n                        .translation(TranslationProvider.of(LanternEnumTraits.YELLOW_FLOWER_TYPE))\n                        .build(\"minecraft\", \"yellow_flower\"),\n                blockState -> (byte) blockState.getTraitValue(LanternEnumTraits.YELLOW_FLOWER_TYPE).get().getInternalId());\n        \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n        \/\/\/   Red Flower   \/\/\/\n        \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n        register(38, simpleBuilder()\n                        .traits(LanternEnumTraits.RED_FLOWER_TYPE)\n                        .defaultState(state -> state\n                                .withTrait(LanternEnumTraits.RED_FLOWER_TYPE, LanternPlantType.POPPY).get())\n                        .itemType(builder -> builder\n                                .keysProvider(collection -> collection\n                                        .register(Keys.PLANT_TYPE, LanternPlantType.POPPY)))\n                        .selectionBox(BoundingBoxes.bush())\n                        .properties(builder -> builder\n                                .add(INSTANT_BROKEN)\n                                .add(PASSABLE))\n                        .translation(TranslationProvider.of(LanternEnumTraits.RED_FLOWER_TYPE))\n                        .build(\"minecraft\", \"red_flower\"),\n                blockState -> (byte) blockState.getTraitValue(LanternEnumTraits.RED_FLOWER_TYPE).get().getInternalId());\n        \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n        \/\/\/   Brown Mushroom   \/\/\/\n        \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n        register(39, simpleBuilder()\n                        .selectionBox(BoundingBoxes.bush())\n                        .properties(builder -> builder\n                                .add(INSTANT_BROKEN)\n                                .add(PASSABLE)\n                                .add(lightEmission(1)))\n                        .translation(\"tile.mushroom.name\")\n                        .build(\"minecraft\", \"brown_mushroom\"));\n        \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n        \/\/\/   Red Mushroom   \/\/\/\n        \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n        register(40, simpleBuilder()\n                        .selectionBox(BoundingBoxes.bush())\n                        .properties(builder -> builder\n                                .add(INSTANT_BROKEN)\n                                .add(PASSABLE))\n                        .translation(\"tile.mushroom.name\")\n                        .build(\"minecraft\", \"red_mushroom\"));\n        \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n        \/\/\/   Gold Block   \/\/\/\n        \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n        register(41, simpleBuilder()\n                        .itemType()\n                        .properties(builder -> builder\n                                .add(hardness(3.0))\n                                .add(blastResistance(10.0)))\n                        .translation(\"tile.blockGold.name\")\n                        .build(\"minecraft\", \"gold_block\"));\n        \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n        \/\/\/   Iron Block   \/\/\/\n        \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n        register(42, simpleBuilder()\n                        .itemType()\n                        .properties(builder -> builder\n                                .add(hardness(5.0))\n                                .add(blastResistance(10.0)))\n                        .translation(\"tile.blockIron.name\")\n                        .build(\"minecraft\", \"iron_block\"));\n        \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n        \/\/\/ Double Stone Slab 1 \/\/\/\n        \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n        register(43, doubleStoneSlab(LanternEnumTraits.STONE_SLAB1_TYPE, LanternSlabType.STONE)\n                        .translation(\"tile.stoneSlab.name\")\n                        .build(\"minecraft\", \"double_stone_slab\"),\n                blockState -> doubleStoneSlabData(blockState, blockState.getTraitValue(LanternEnumTraits.STONE_SLAB1_TYPE).get().getInternalId()));\n        \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n        \/\/\/   Stone Slab 1   \/\/\/\n        \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n        register(44, stoneSlab(LanternEnumTraits.STONE_SLAB1_TYPE, LanternSlabType.STONE,\n                () -> BlockTypes.STONE_SLAB,\n                () -> BlockTypes.DOUBLE_STONE_SLAB)\n                        .translation(\"tile.stoneSlab.name\")\n                        .collisionBox(BoundingBoxes::slab)\n                        .build(\"minecraft\", \"stone_slab\"),\n                blockState -> stoneSlabData(blockState, blockState.getTraitValue(LanternEnumTraits.STONE_SLAB1_TYPE).get().getInternalId()));\n        \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n        \/\/\/   Brick Block   \/\/\/\n        \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n        register(45, simpleBuilder()\n                        .itemType()\n                        .properties(builder -> builder\n                                .add(hardness(2.0))\n                                .add(blastResistance(10.0)))\n                        .translation(\"tile.brick.name\")\n                        .build(\"minecraft\", \"brick_block\"));\n        \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n        \/\/\/   TNT   \/\/\/\n        \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n        register(46, simpleBuilder()\n                        .trait(LanternBooleanTraits.EXPLODE)\n                        .defaultState(state -> state\n                                .withTrait(LanternBooleanTraits.EXPLODE, false).get())\n                        .itemType()\n                        .properties(builder -> builder\n                                .add(INSTANT_BROKEN))\n                        .translation(\"tile.tnt.name\")\n                        .build(\"minecraft\", \"tnt\"),\n                blockState -> (byte) (blockState.getTraitValue(LanternBooleanTraits.EXPLODE).get() ? 1 : 0));\n        \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n        \/\/\/   Bookshelf   \/\/\/\n        \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n        register(47, simpleBuilder()\n                        .itemType()\n                        .properties(builder -> builder\n                                .add(hardness(1.5))\n                                .add(blastResistance(7.5)))\n                        .translation(\"tile.bookshelf.name\")\n                        .build(\"minecraft\", \"bookshelf\"));\n        \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n        \/\/\/   Mossy Cobblestone   \/\/\/\n        \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n        register(48, simpleBuilder()\n                        .itemType()\n                        .properties(builder -> builder\n                                .add(hardness(2.0))\n                                .add(blastResistance(10.0)))\n                        .translation(\"tile.stoneMoss.name\")\n                        .build(\"minecraft\", \"mossy_cobblestone\"));\n        \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n        \/\/\/   Obsidian   \/\/\/\n        \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n        register(49, simpleBuilder()\n                        .itemType()\n                        .properties(builder -> builder\n                                .add(hardness(50.0))\n                                .add(blastResistance(2000.0)))\n                        .translation(\"tile.obsidian.name\")\n                        .build(\"minecraft\", \"obsidian\"));\n        \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n        \/\/\/   Torch   \/\/\/\n        \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n        register(50, builder()\n                        .trait(LanternEnumTraits.TORCH_FACING)\n                            .defaultState(state -> state\n                                    .withTrait(LanternEnumTraits.TORCH_FACING, Direction.UP).get())\n                        .itemType()\n                        .properties(builder -> builder\n                                .add(PASSABLE)\n                                .add(INSTANT_BROKEN))\n                        .translation(\"tile.torch.name\")\n                        .selectionBox(BoundingBoxes::torch)\n                        .behaviors(pipeline -> pipeline\n                                .add(new BlockSnapshotProviderPlaceBehavior())\n                                .add(new TorchPlacementBehavior())\n                                .add(new SimpleBreakBehavior()))\n                        .build(\"minecraft\", \"torch\"),\n                blockState -> {\n                    final Direction direction = blockState.getTraitValue(LanternEnumTraits.TORCH_FACING).get();\n                    switch (direction) {\n                        case EAST:\n                            return (byte) 1;\n                        case WEST:\n                            return (byte) 2;\n                        case SOUTH:\n                            return (byte) 3;\n                        case NORTH:\n                            return (byte) 4;\n                        case UP:\n                            return (byte) 5;\n                        default:\n                            throw new IllegalArgumentException();\n                    }\n                });\n        \/\/\/\/\/\/\/\/\/\/\/\/\/\/\n        \/\/\/  Fire  \/\/\/\n        \/\/\/\/\/\/\/\/\/\/\/\/\/\/\n        register(51, simpleBuilder()\n                        .properties(builder -> builder\n                                .add(PASSABLE)\n                                .add(INSTANT_BROKEN)\n                                .add(lightEmission(15)))\n                        .collisionBox(BoundingBoxes.NULL)\n                        .translation(\"tile.fire.name\")\n                        .build(\"minecraft\", \"fire\"));\n        \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n        \/\/\/  Mob Spawner  \/\/\/\n        \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n        register(52, simpleBuilder()\n                        .properties(builder -> builder\n                                .add(hardness(5.0))\n                                .add(blastResistance(25.0)))\n                        .translation(\"tile.mobSpawner.name\")\n                        .build(\"minecraft\", \"mob_spawner\"));\n        \/\/ TODO: Oak Stairs\n        \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n        \/\/\/     Chest    \/\/\/\n        \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n        register(54, chestBuilder()\n                        .translation(\"tile.chest.name\")\n                        .build(\"minecraft\", \"chest\"),\n                this::horizontalFacingData);\n        \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n        \/\/\/     Redstone Wire   \/\/\/\n        \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n        register(55, simpleBuilder()\n                        .traits(LanternIntegerTraits.POWER)\n                        .selectionBox(new AABB(0, 0, 0, 1.0, 0.0625, 1.0)) \/\/ TODO: Based on connections\n                        .properties(builder -> builder\n                                .add(PASSABLE)\n                                .add(INSTANT_BROKEN))\n                        .defaultState(state -> state\n                                .withTrait(LanternIntegerTraits.POWER, 0).get())\n                        .translation(\"tile.redstoneDust.name\")\n                        .build(\"minecraft\", \"redstone_wire\"),\n                state -> state.get(Keys.POWER).get().byteValue());\n        \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n        \/\/\/   Diamond Ore   \/\/\/\n        \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n        register(56, simpleBuilder()\n                        .itemType()\n                        .properties(builder -> builder\n                                .add(hardness(3.0))\n                                .add(blastResistance(5.0)))\n                        .translation(\"tile.oreDiamond.name\")\n                        .build(\"minecraft\", \"diamond_ore\"));\n        \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n        \/\/\/   Diamond Block   \/\/\/\n        \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n        register(57, simpleBuilder()\n                        .itemType()\n                        .properties(builder -> builder\n                                .add(hardness(5.0))\n                                .add(blastResistance(10.0)))\n                        .translation(\"tile.blockDiamond.name\")\n                        .build(\"minecraft\", \"diamond_block\"));\n        \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n        \/\/\/   Crafting Table   \/\/\/\n        \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n        register(58, simpleBuilder()\n                        .itemType()\n                        .properties(builder -> builder\n                                .add(hardness(2.5))\n                                .add(blastResistance(12.5)))\n                        .translation(\"tile.workbench.name\")\n                        .behaviors(pipeline -> pipeline\n                                .add(new CraftingTableInteractionBehavior()))\n                        .build(\"minecraft\", \"crafting_table\"));\n        \/\/ TODO: Wheat\n        \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n        \/\/\/   Farmland   \/\/\/\n        \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n        register(60, simpleBuilder()\n                        .collisionBox(BoundingBoxes.farmland())\n                        .trait(LanternIntegerTraits.MOISTURE)\n                        .properties(builder -> builder\n                                .add(hardness(0.6))\n                                .add(blastResistance(3.0)))\n                        .defaultState(state ->\n                                state.withTrait(LanternIntegerTraits.MOISTURE, 0).get())\n                        .translation(\"tile.farmland.name\")\n                        .build(\"minecraft\", \"farmland\"),\n                state -> state.getTraitValue(LanternIntegerTraits.MOISTURE).get().byteValue());\n        \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n        \/\/\/    Furnace   \/\/\/\n        \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n        register(61, furnaceBuilder()\n                        .itemType()\n                        .translation(\"tile.furnace.name\")\n                        .build(\"minecraft\", \"furnace\"),\n                this::directionData);\n        \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n        \/\/\/  Lit Furnace \/\/\/\n        \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n        register(62, furnaceBuilder()\n                        .properties(builder -> builder\n                                .add(lightEmission(13)))\n                        .translation(\"tile.furnace.name\")\n                        .build(\"minecraft\", \"lit_furnace\"),\n                this::directionData);\n        \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n        \/\/\/ Stone Pressure Plate \/\/\/\n        \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n        register(70, pressurePlateBuilder()\n                        .translation(\"tile.pressurePlateStone.name\")\n                        .build(\"minecraft\", \"stone_pressure_plate\"),\n                this::pressurePlateData);\n        \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n        \/\/\/ Wooden Pressure Plate \/\/\/\n        \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n        register(72, pressurePlateBuilder()\n                        .translation(\"tile.pressurePlateWood.name\")\n                        .build(\"minecraft\", \"wooden_pressure_plate\"),\n                this::pressurePlateData);\n        \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n        \/\/\/    Jukebox   \/\/\/\n        \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n        register(84, simpleBuilder()\n                        .itemType()\n                        .traits(LanternBooleanTraits.HAS_RECORD)\n                        .defaultState(state -> state\n                                .withTrait(LanternBooleanTraits.HAS_RECORD, false).get())\n                        .properties(builder -> builder\n                                .add(hardness(2.0))\n                                .add(blastResistance(10.0)))\n                        .tileEntityType(() -> TileEntityTypes.JUKEBOX)\n                        .translation(\"tile.jukebox.name\")\n                        .behaviors(pipeline -> pipeline\n                                .add(new JukeboxInteractionBehavior()))\n                        .build(\"minecraft\", \"jukebox\"),\n                state -> (byte) (state.getTraitValue(LanternBooleanTraits.HAS_RECORD).get() ? 1 : 0));\n        \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n        \/\/\/    Pumpkin   \/\/\/\n        \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n        register(86, pumpkinBuilder()\n                        .itemType(builder -> builder\n                                .properties(properties -> properties\n                                        .add(equipmentType(EquipmentTypes.HEADWEAR))))\n                        .translation(\"tile.pumpkin.name\")\n                        .build(\"minecraft\", \"pumpkin\"),\n                this::horizontalDirectionData);\n        \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n        \/\/\/   Netherrack   \/\/\/\n        \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n        register(87, simpleBuilder()\n                        .itemType()\n                        .properties(builder -> builder\n                                .add(hardness(0.4))\n                                .add(blastResistance(2.0)))\n                        .translation(\"tile.hellrock.name\")\n                        .build(\"minecraft\", \"netherrack\"));\n        \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n        \/\/\/  Lit Pumpkin \/\/\/\n        \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n        register(91, pumpkinBuilder()\n                        .properties(builder -> builder\n                                .add(lightEmission(15)))\n                        .translation(\"tile.litpumpkin.name\")\n                        .build(\"minecraft\", \"lit_pumpkin\"),\n                this::horizontalDirectionData);\n        \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n        \/\/\/ Stained Glass \/\/\/\n        \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n        register(95, dyedBuilder(\"tile.stainedGlass.%s.name\")\n                        .properties(builder -> builder\n                                .add(hardness(0.3))\n                                .add(blastResistance(1.5)))\n                        .build(\"minecraft\", \"stained_glass\"),\n                this::dyedData);\n        \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n        \/\/\/  Iron Bars  \/\/\/\n        \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n        register(101, simpleBuilder()\n                        \/\/ TODO\n                        .itemType()\n                        .properties(builder -> builder\n                                .add(hardness(5.0))\n                                .add(blastResistance(10.0)))\n                        .translation(\"tile.fenceIron.name\")\n                        .build(\"minecraft\", \"iron_bars\"));\n        \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n        \/\/\/   End Stone   \/\/\/\n        \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n        register(121, simpleBuilder()\n                        .itemType()\n                        .properties(builder -> builder\n                                .add(hardness(3.0))\n                                .add(blastResistance(15.0)))\n                        .translation(\"tile.whiteStone.name\")\n                        .build(\"minecraft\", \"end_stone\"));\n        \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n        \/\/\/ Double Wooden Slab \/\/\/\n        \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n        register(125, simpleBuilder()\n                        .traits(LanternEnumTraits.TREE_TYPE)\n                        .defaultState(state -> state\n                                .withTrait(LanternEnumTraits.TREE_TYPE, LanternTreeType.OAK).get())\n                        .translation(TranslationProvider.of(LanternEnumTraits.TREE_TYPE, type ->\n                                tr(\"tile.woodSlab.\" + type.getTranslationKeyBase() + \".name\")))\n                        .itemType(builder -> builder\n                                .keysProvider(collection -> collection\n                                        .register(Keys.TREE_TYPE, LanternTreeType.OAK)\n                                )\n                        )\n                        .properties(builder -> builder\n                                .add(hardness(2.0))\n                                .add(blastResistance(5.0)))\n                        .build(\"minecraft\", \"double_wooden_slab\"),\n                blockState -> (byte) blockState.getTraitValue(LanternEnumTraits.TREE_TYPE).get().getInternalId());\n        \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n        \/\/\/     Wooden Slab    \/\/\/\n        \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n        register(126, simpleBuilder()\n                        .traits(LanternEnumTraits.PORTION_TYPE, LanternEnumTraits.TREE_TYPE)\n                        .defaultState(state -> state\n                                .withTrait(LanternEnumTraits.PORTION_TYPE, LanternPortionType.BOTTOM).get()\n                                .withTrait(LanternEnumTraits.TREE_TYPE, LanternTreeType.OAK).get())\n                        .translation(TranslationProvider.of(LanternEnumTraits.TREE_TYPE, type ->\n                                tr(\"tile.woodSlab.\" + type.getTranslationKeyBase() + \".name\")))\n                        .itemType(builder -> builder\n                                .behaviors(pipeline -> pipeline\n                                        .add(new SlabItemInteractionBehavior<>(LanternEnumTraits.TREE_TYPE,\n                                                () -> BlockTypes.WOODEN_SLAB,\n                                                () -> BlockTypes.DOUBLE_WOODEN_SLAB))\n                                        .add(new PlacementCollisionDetectionBehavior()))\n                                .keysProvider(collection -> collection\n                                        .register(Keys.TREE_TYPE, LanternTreeType.OAK)\n                                )\n                        )\n                        .collisionBox(BoundingBoxes::slab)\n                        .properties(builder -> builder\n                                .add(hardness(2.0))\n                                .add(blastResistance(5.0)))\n                        .build(\"minecraft\", \"wooden_slab\"),\n                blockState -> {\n                    final int type = blockState.getTraitValue(LanternEnumTraits.TREE_TYPE).get().getInternalId();\n                    final int portion = (byte) blockState.getTraitValue(LanternEnumTraits.PORTION_TYPE).get().getInternalId();\n                    return (byte) (portion << 3 | type);\n                });\n        \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n        \/\/\/  Ender Chest  \/\/\/\n        \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n        register(130, simpleBuilder()\n                        .trait(LanternEnumTraits.HORIZONTAL_FACING)\n                        .defaultState(state -> state.withTrait(LanternEnumTraits.HORIZONTAL_FACING, Direction.NORTH).get())\n                        .itemType()\n                        .tileEntityType(() -> TileEntityTypes.ENDER_CHEST)\n                        .properties(builder -> builder\n                                .add(hardness(22.5))\n                                .add(blastResistance(3000.0))\n                                .add(lightEmission(7)))\n                        .translation(\"tile.enderChest.name\")\n                        .collisionBox(BoundingBoxes.chest())\n                        .behaviors(pipeline -> pipeline\n                                .add(new HorizontalRotationPlacementBehavior())\n                                .add(new EnderChestInteractionBehavior()))\n                        .build(\"minecraft\", \"ender_chest\"),\n                this::horizontalFacingData);\n        \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n        \/\/\/ Trapped Chest \/\/\/\n        \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n        register(146, chestBuilder()\n                        .translation(\"tile.chestTrap.name\")\n                        .build(\"minecraft\", \"trapped_chest\"),\n                this::horizontalFacingData);\n        \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n        \/\/\/ Weighted Pressure Plate (Light) \/\/\/\n        \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n        register(147, weightedPressurePlateBuilder()\n                        .translation(\"tile.weightedPlate_light.name\")\n                        .build(\"minecraft\", \"light_weighted_pressure_plate\"),\n                this::weightedPressurePlateData);\n        \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n        \/\/\/ Weighted Pressure Plate (Heavy) \/\/\/\n        \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n        register(148, weightedPressurePlateBuilder()\n                        .translation(\"tile.weightedPlate_heavy.name\")\n                        .build(\"minecraft\", \"heavy_weighted_pressure_plate\"),\n                this::weightedPressurePlateData);\n        \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n        \/\/\/ Redstone Block  \/\/\/\n        \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n        register(152, simpleBuilder()\n                        .itemType()\n                        .properties(builder -> builder\n                                .add(hardness(5.0))\n                                .add(blastResistance(30.0)))\n                        .translation(\"tile.blockRedstone.name\")\n                        .build(\"minecraft\", \"redstone_block\"));\n        \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n        \/\/\/  Quartz Ore  \/\/\/\n        \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n        register(153, simpleBuilder()\n                        .itemType()\n                        .properties(builder -> builder\n                                .add(hardness(3.0))\n                                .add(blastResistance(15.0)))\n                        .translation(\"tile.netherquartz.name\")\n                        .build(\"minecraft\", \"quartz_ore\"));\n        \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n        \/\/\/     Hopper   \/\/\/\n        \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n        register(154, simpleBuilder()\n                        .traits(LanternEnumTraits.HOPPER_FACING, LanternBooleanTraits.ENABLED)\n                        .defaultState(state -> state\n                                .withTrait(LanternEnumTraits.HOPPER_FACING, Direction.DOWN).get()\n                                .withTrait(LanternBooleanTraits.ENABLED, false).get())\n                        .itemType()\n                        .properties(builder -> builder\n                                .add(hardness(3.0))\n                                .add(blastResistance(8.0)))\n                        .translation(\"tile.hopper.name\")\n                        .behaviors(pipeline -> pipeline\n                                .add(new HopperPlacementBehavior()))\n                        .build(\"minecraft\", \"hopper\"),\n                blockState -> {\n                    int data = directionData(blockState.getTraitValue(LanternEnumTraits.HOPPER_FACING).get());\n                    if (!blockState.getTraitValue(LanternBooleanTraits.ENABLED).get()) {\n                        data |= 0x8;\n                    }\n                    return (byte) data;\n                });\n        \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n        \/\/\/  Quartz Block  \/\/\/\n        \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n        register(155, simpleBuilder()\n                        .trait(LanternEnumTraits.QUARTZ_TYPE)\n                        .defaultState(state -> state\n                                .withTrait(LanternEnumTraits.QUARTZ_TYPE, LanternQuartzType.DEFAULT).get())\n                        .itemType(builder -> builder\n                                .keysProvider(collection -> collection\n                                        .register(Keys.QUARTZ_TYPE, LanternQuartzType.DEFAULT)\n                                )\n                        )\n                        .properties(builder -> builder\n                                .add(hardness(0.8))\n                                .add(blastResistance(2.4)))\n                        .translation(TranslationProvider.of(LanternEnumTraits.QUARTZ_TYPE))\n                        .behaviors(pipeline -> pipeline\n                                .add(new QuartzLinesRotationPlacementBehavior()))\n                        .build(\"minecraft\", \"quartz_block\"),\n                blockState -> (byte) blockState.getTraitValue(LanternEnumTraits.QUARTZ_TYPE).get().getInternalId());\n        \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n        \/\/\/    Dropper   \/\/\/\n        \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n        register(158, simpleBuilder()\n                        .traits(LanternEnumTraits.FACING, LanternBooleanTraits.TRIGGERED)\n                        .defaultState(state -> state\n                                .withTrait(LanternEnumTraits.FACING, Direction.NORTH).get()\n                                .withTrait(LanternBooleanTraits.TRIGGERED, false).get())\n                        .itemType()\n                        .properties(builder -> builder\n                                .add(hardness(3.5))\n                                .add(blastResistance(17.5)))\n                        \/\/ .tileEntityType(() -> TileEntityTypes.DROPPER)\n                        .translation(\"tile.dropper.name\")\n                        .behaviors(pipeline -> pipeline\n                                .add(new RotationPlacementBehavior()))\n                        .build(\"minecraft\", \"dropper\"),\n                blockState -> {\n                    int data = directionData(blockState.getTraitValue(LanternEnumTraits.FACING).get());\n                    if (blockState.getTraitValue(LanternBooleanTraits.TRIGGERED).get()) {\n                        data |= 0x8;\n                    }\n                    return (byte) data;\n                });\n        \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n        \/\/\/ Stained Hardended Clay \/\/\/\n        \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n        register(159, dyedBuilder(\"tile.clayHardenedStained.%s.name\")\n                        .properties(builder -> builder\n                                .add(hardness(1.25))\n                                .add(blastResistance(7.0)))\n                        .build(\"minecraft\", \"stained_hardened_clay\"),\n                this::dyedData);\n        \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n        \/\/\/ Stained Glass Pane \/\/\/\n        \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n        register(160, dyedBuilder(\"tile.thinStainedGlass.%s.name\")\n                        .properties(builder -> builder\n                                .add(hardness(0.3))\n                                .add(blastResistance(1.5)))\n                        .build(\"minecraft\", \"stained_glass_pane\"),\n                this::dyedData);\n        \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n        \/\/\/   Leaves 2   \/\/\/\n        \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n        register(161, leavesBuilder(LanternEnumTraits.LEAVES2_TYPE, LanternTreeType.ACACIA)\n                        .build(\"minecraft\", \"leaves2\"),\n                blockState -> leavesData(blockState, blockState.getTraitValue(LanternEnumTraits.LEAVES2_TYPE).get().getInternalId() - 4));\n        \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n        \/\/\/    Log 2     \/\/\/\n        \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n        register(162, logBuilder(LanternEnumTraits.LOG2_TYPE, LanternTreeType.ACACIA)\n                        .build(\"minecraft\", \"log2\"),\n                blockState -> logData(blockState, blockState.getTraitValue(LanternEnumTraits.LOG2_TYPE).get().getInternalId() - 4));\n        \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n        \/\/\/   Barrier    \/\/\/\n        \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n        register(166, simpleBuilder()\n                        .itemType()\n                        .properties(builder -> builder\n                                .add(PropertyProviderCollections.UNBREAKABLE))\n                        .translation(\"tile.barrier.name\")\n                        .build(\"minecraft\", \"barrier\"));\n        \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n        \/\/\/     Carpet    \/\/\/\n        \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n        register(171, dyedBuilder(\"tile.carpet.%s.name\")\n                        .properties(builder -> builder\n                                .add(hardness(0.1))\n                                .add(blastResistance(0.5))\n                                .add(solidMaterial(false)))\n                        .collisionBox(BoundingBoxes.carpet())\n                        .build(\"minecraft\", \"carpet\"),\n                this::dyedData);\n        \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n        \/\/\/ Red Sandstone \/\/\/\n        \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n        register(179, simpleBuilder()\n                        .trait(LanternEnumTraits.SANDSTONE_TYPE)\n                        .defaultState(state -> state.withTrait(LanternEnumTraits.SANDSTONE_TYPE, LanternSandstoneType.DEFAULT).get())\n                        .itemType(builder -> builder\n                                .keysProvider(collection -> collection\n                                        .register(Keys.SANDSTONE_TYPE, LanternSandstoneType.DEFAULT)\n                                )\n                        )\n                        .properties(builder -> builder\n                                .add(hardness(0.8))\n                                .add(blastResistance(4.0)))\n                        .translation(TranslationProvider.of(LanternEnumTraits.SANDSTONE_TYPE))\n                        .build(\"minecraft\", \"red_sandstone\"),\n                blockState -> (byte) blockState.getTraitValue(LanternEnumTraits.SANDSTONE_TYPE).get().getInternalId());\n        \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n        \/\/\/ Double Stone Slab 2 \/\/\/\n        \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n        register(181, doubleStoneSlab(LanternEnumTraits.STONE_SLAB2_TYPE, LanternSlabType.RED_SAND)\n                        .translation(\"tile.stoneSlab2.name\")\n                        .build(\"minecraft\", \"double_stone_slab2\"),\n                blockState -> doubleStoneSlabData(blockState,\n                        blockState.getTraitValue(LanternEnumTraits.STONE_SLAB2_TYPE).get().getInternalId() - 8));\n        \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n        \/\/\/   Stone Slab 2   \/\/\/\n        \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n        register(182, stoneSlab(LanternEnumTraits.STONE_SLAB2_TYPE, LanternSlabType.RED_SAND,\n                () -> BlockTypes.STONE_SLAB2,\n                () -> BlockTypes.DOUBLE_STONE_SLAB2)\n                        .translation(\"tile.stoneSlab2.name\")\n                        .collisionBox(BoundingBoxes::slab)\n                        .build(\"minecraft\", \"stone_slab2\"),\n                blockState -> stoneSlabData(blockState, blockState.getTraitValue(LanternEnumTraits.STONE_SLAB2_TYPE).get().getInternalId() - 8));\n        \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n        \/\/\/   End Rod   \/\/\/\n        \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n        register(198, simpleBuilder()\n                        .itemType()\n                        .properties(builder -> builder\n                                .add(hardness(0.0))\n                                .add(blastResistance(0.0))\n                                .add(lightEmission(14)))\n                        .translation(\"tile.endRod.name\")\n                        .build(\"minecraft\", \"end_rod\"));\n        \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n        \/\/\/  White Shulker Box  \/\/\/\n        \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n        register(219, shulkerBox()\n                        .translation(\"tile.shulkerBoxWhite.name\")\n                        .build(\"minecraft\", \"white_shulker_box\"),\n                this::shulkerBoxData);\n        \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n        \/\/\/  Orange Shulker Box \/\/\/\n        \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n        register(220, shulkerBox()\n                        .translation(\"tile.shulkerBoxOrange.name\")\n                        .build(\"minecraft\", \"orange_shulker_box\"),\n                this::shulkerBoxData);\n        \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n        \/\/\/  Magenta Shulker Box \/\/\/\n        \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n        register(221, shulkerBox()\n                        .translation(\"tile.shulkerBoxMagenta.name\")\n                        .build(\"minecraft\", \"magenta_shulker_box\"),\n                this::shulkerBoxData);\n        \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n        \/\/\/  Light Blue Shulker Box \/\/\/\n        \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n        register(222, shulkerBox()\n                        .translation(\"tile.shulkerBoxLightBlue.name\")\n                        .build(\"minecraft\", \"light_blue_shulker_box\"),\n                this::shulkerBoxData);\n        \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n        \/\/\/  Yellow Shulker Box \/\/\/\n        \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n        register(223, shulkerBox()\n                        .translation(\"tile.shulkerBoxYellow.name\")\n                        .build(\"minecraft\", \"yellow_shulker_box\"),\n                this::shulkerBoxData);\n        \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n        \/\/\/  Lime Shulker Box \/\/\/\n        \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n        register(224, shulkerBox()\n                        .translation(\"tile.shulkerBoxLime.name\")\n                        .build(\"minecraft\", \"lime_shulker_box\"),\n                this::shulkerBoxData);\n        \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n        \/\/\/  Pink Shulker Box \/\/\/\n        \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n        register(225, shulkerBox()\n                        .translation(\"tile.shulkerBoxPink.name\")\n                        .build(\"minecraft\", \"pink_shulker_box\"),\n                this::shulkerBoxData);\n        \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n        \/\/\/  Gray Shulker Box \/\/\/\n        \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n        register(226, shulkerBox()\n                        .translation(\"tile.shulkerBoxGray.name\")\n                        .build(\"minecraft\", \"gray_shulker_box\"),\n                this::shulkerBoxData);\n        \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n        \/\/\/  Gray Shulker Box \/\/\/\n        \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n        register(227, shulkerBox()\n                        .translation(\"tile.shulkerBoxSilver.name\")\n                        .build(\"minecraft\", \"silver_shulker_box\"),\n                this::shulkerBoxData);\n        \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n        \/\/\/  Cyan Shulker Box \/\/\/\n        \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n        register(228, shulkerBox()\n                        .translation(\"tile.shulkerBoxCyan.name\")\n                        .build(\"minecraft\", \"cyan_shulker_box\"),\n                this::shulkerBoxData);\n        \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n        \/\/\/  Purple Shulker Box \/\/\/\n        \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n        register(229, shulkerBox()\n                        .translation(\"tile.shulkerBoxPurple.name\")\n                        .build(\"minecraft\", \"purple_shulker_box\"),\n                this::shulkerBoxData);\n        \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n        \/\/\/  Blue Shulker Box \/\/\/\n        \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n        register(230, shulkerBox()\n                        .translation(\"tile.shulkerBoxBlue.name\")\n                        .build(\"minecraft\", \"blue_shulker_box\"),\n                this::shulkerBoxData);\n        \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n        \/\/\/  Brown Shulker Box \/\/\/\n        \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n        register(231, shulkerBox()\n                        .translation(\"tile.shulkerBoxBrown.name\")\n                        .build(\"minecraft\", \"brown_shulker_box\"),\n                this::shulkerBoxData);\n        \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n        \/\/\/  Green Shulker Box \/\/\/\n        \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n        register(232, shulkerBox()\n                        .translation(\"tile.shulkerBoxGreen.name\")\n                        .build(\"minecraft\", \"green_shulker_box\"),\n                this::shulkerBoxData);\n        \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n        \/\/\/  Red Shulker Box \/\/\/\n        \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n        register(233, shulkerBox()\n                        .translation(\"tile.shulkerBoxRed.name\")\n                        .build(\"minecraft\", \"red_shulker_box\"),\n                this::shulkerBoxData);\n        \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n        \/\/\/  Black Shulker Box \/\/\/\n        \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n        register(234, shulkerBox()\n                        .translation(\"tile.shulkerBoxBlack.name\")\n                        .build(\"minecraft\", \"black_shulker_box\"),\n                this::shulkerBoxData);\n        \/\/\/\/\/\/\/\/\/\/\/\/\/\/\n        \/\/\/  Sign  \/\/\/\n        \/\/\/\/\/\/\/\/\/\/\/\/\/\/\n        register(63, simpleBuilder()\n                        .trait(LanternIntegerTraits.ROTATION)\n                        .defaultState(state -> state\n                                .withTrait(LanternIntegerTraits.ROTATION, 0).get())\n                        .properties(builder -> builder\n                                .add(hardness(1.0))\n                                .add(blastResistance(5.0)))\n                        .behaviors(pipeline -> pipeline\n                                .add(new SignInteractionBehavior()))\n                        .tileEntityType(() -> TileEntityTypes.SIGN)\n                        .build(\"minecraft\", \"standing_sign\"),\n                blockState -> blockState.getTraitValue(LanternIntegerTraits.ROTATION).get().byteValue());\n        register(68, simpleBuilder()\n                        .trait(LanternEnumTraits.HORIZONTAL_FACING)\n                        .defaultState(state -> state\n                                .withTrait(LanternEnumTraits.HORIZONTAL_FACING, Direction.NORTH).get())\n                        .properties(builder -> builder\n                                .add(hardness(1.0))\n                                .add(blastResistance(5.0)))\n                        .behaviors(pipeline -> pipeline\n                                .add(new SignInteractionBehavior()))\n                        .tileEntityType(() -> TileEntityTypes.SIGN)\n                        .build(\"minecraft\", \"wall_sign\"),\n                this::horizontalFacingData);\n        \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n        \/\/\/  Banner  \/\/\/\n        \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n        register(176, simpleBuilder()\n                        .trait(LanternIntegerTraits.ROTATION)\n                        .defaultState(state -> state\n                                .withTrait(LanternIntegerTraits.ROTATION, 0).get())\n                        .properties(builder -> builder\n                                .add(hardness(1.0))\n                                .add(blastResistance(5.0)))\n                        .behaviors(pipeline -> pipeline\n                                .add(new SignInteractionBehavior()))\n                        .tileEntityType(() -> TileEntityTypes.BANNER)\n                        .build(\"minecraft\", \"standing_banner\"),\n                blockState -> blockState.getTraitValue(LanternIntegerTraits.ROTATION).get().byteValue());\n        register(177, simpleBuilder()\n                        .trait(LanternEnumTraits.HORIZONTAL_FACING)\n                        .defaultState(state -> state\n                                .withTrait(LanternEnumTraits.HORIZONTAL_FACING, Direction.NORTH).get())\n                        .properties(builder -> builder\n                                .add(hardness(1.0))\n                                .add(blastResistance(5.0)))\n                        .behaviors(pipeline -> pipeline\n                                .add(new SignInteractionBehavior()))\n                        .tileEntityType(() -> TileEntityTypes.BANNER)\n                        .build(\"minecraft\", \"wall_banner\"),\n                this::horizontalFacingData);\n        \/\/ @formatter:on\n    }","code_wo_comment":"@Override\n    public void registerDefaults() {\n       \n       \n       \n       \n        register(0, builder()\n                        .properties(PropertyProviderCollections.DEFAULT_GAS)\n                        .translation(\"tile.air.name\")\n                        .build(\"minecraft\", \"air\"));\n       \n       \n       \n        register(1, simpleBuilder()\n                        .trait(LanternEnumTraits.STONE_TYPE)\n                        .defaultState(state -> state.withTrait(LanternEnumTraits.STONE_TYPE, LanternStoneType.STONE).get())\n                        .itemType(builder -> builder\n                                .keysProvider(collection -> collection\n                                        .register(Keys.STONE_TYPE, LanternStoneType.STONE)\n                                )\n                        )\n                        .properties(builder -> builder\n                                .add(hardness(1.5))\n                                .add(blastResistance(30.0)))\n                        .translation(TranslationProvider.of(LanternEnumTraits.STONE_TYPE))\n                        .build(\"minecraft\", \"stone\"),\n                blockState -> (byte) blockState.getTraitValue(LanternEnumTraits.STONE_TYPE).get().getInternalId());\n       \n       \n       \n        register(2, simpleBuilder()\n                        .trait(LanternBooleanTraits.SNOWY)\n                        .extendedStateProvider(new SnowyExtendedBlockStateProvider())\n                        .defaultState(state -> state.withTrait(LanternBooleanTraits.SNOWY, false).get())\n                        .itemType()\n                        .properties(builder -> builder\n                                .add(hardness(0.6))\n                                .add(blastResistance(3.0)))\n                        .translation(\"tile.grass.name\")\n                        .build(\"minecraft\", \"grass\"));\n       \n       \n       \n        register(3, simpleBuilder()\n                        .traits(LanternEnumTraits.DIRT_TYPE, LanternBooleanTraits.SNOWY)\n                        .defaultState(state -> state\n                                .withTrait(LanternEnumTraits.DIRT_TYPE, LanternDirtType.DIRT).get()\n                                .withTrait(LanternBooleanTraits.SNOWY, false).get())\n                        .extendedStateProvider(new SnowyExtendedBlockStateProvider())\n                        .itemType(builder -> builder\n                                .keysProvider(collection -> collection\n                                        .register(Keys.DIRT_TYPE, LanternDirtType.DIRT)\n                                )\n                        )\n                        .properties(builder -> builder\n                                .add(hardness(0.5))\n                                .add(blastResistance(2.5)))\n                        .translation(TranslationProvider.of(LanternEnumTraits.DIRT_TYPE))\n                        .build(\"minecraft\", \"dirt\"),\n                blockState -> (byte) blockState.getTraitValue(LanternEnumTraits.DIRT_TYPE).get().getInternalId());\n       \n       \n       \n        register(4, simpleBuilder()\n                        .itemType()\n                        .properties(builder -> builder\n                                .add(hardness(2.0))\n                                .add(blastResistance(3.0)))\n                        .translation(\"tile.stonebrick.name\")\n                        .build(\"minecraft\", \"cobblestone\"));\n       \n       \n       \n        register(5, simpleBuilder()\n                        .trait(LanternEnumTraits.TREE_TYPE)\n                        .defaultState(state -> state.withTrait(LanternEnumTraits.TREE_TYPE, LanternTreeType.OAK).get())\n                        .itemType(builder -> builder\n                                .keysProvider(collection -> collection\n                                        .register(Keys.TREE_TYPE, LanternTreeType.OAK)\n                                )\n                        )\n                        .properties(builder -> builder\n                                .add(hardness(2.0))\n                                .add(blastResistance(5.0))\n                                .add(flammableInfo(5, 20)))\n                        .translation(TranslationProvider.of(LanternEnumTraits.TREE_TYPE, type ->\n                                tr(\"tile.planks.\" + type.getTranslationKeyBase() + \".name\")))\n                        .build(\"minecraft\", \"planks\"),\n                blockState -> (byte) blockState.getTraitValue(LanternEnumTraits.TREE_TYPE).get().getInternalId());\n       \n       \n       \n        register(6, simpleBuilder()\n                        .traits(LanternEnumTraits.TREE_TYPE, LanternIntegerTraits.SAPLING_GROWTH_STAGE)\n                        .defaultState(state -> state\n                                .withTrait(LanternEnumTraits.TREE_TYPE, LanternTreeType.OAK).get()\n                                .withTrait(LanternIntegerTraits.SAPLING_GROWTH_STAGE, 0).get())\n                        .itemType(builder -> builder\n                                .keysProvider(collection -> collection\n                                        .register(Keys.TREE_TYPE, LanternTreeType.OAK)\n                                )\n                        )\n                        .properties(builder -> builder\n                                .add(PASSABLE)\n                                .add(INSTANT_BROKEN))\n                        .translation(TranslationProvider.of(LanternEnumTraits.TREE_TYPE, type ->\n                                tr(\"tile.sapling.\" + type.getTranslationKeyBase() + \".name\")))\n                        .build(\"minecraft\", \"sapling\"),\n                blockState -> {\n                    final int type = blockState.getTraitValue(LanternEnumTraits.TREE_TYPE).get().getInternalId();\n                    final int stage = blockState.getTraitValue(LanternIntegerTraits.SAPLING_GROWTH_STAGE).get();\n                    return (byte) (stage << 3 | type);\n                });\n       \n       \n       \n        register(7, simpleBuilder()\n                        .itemType()\n                        .properties(builder -> builder\n                                .add(PropertyProviderCollections.UNBREAKABLE))\n                        .translation(\"tile.bedrock.name\")\n                        .build(\"minecraft\", \"bedrock\"));\n       \n       \n       \n        register(12, simpleBuilder()\n                        .trait(LanternEnumTraits.SAND_TYPE)\n                        .defaultState(state -> state.withTrait(LanternEnumTraits.SAND_TYPE, LanternSandType.NORMAL).get())\n                        .itemType(builder -> builder\n                                .keysProvider(collection -> collection\n                                        .register(Keys.SAND_TYPE, LanternSandType.NORMAL)\n                                )\n                        )\n                        .properties(builder -> builder\n                                .add(hardness(0.5))\n                                .add(blastResistance(2.5)))\n                        .translation(TranslationProvider.of(LanternEnumTraits.SAND_TYPE))\n                        .build(\"minecraft\", \"sand\"),\n                blockState -> (byte) blockState.getTraitValue(LanternEnumTraits.SAND_TYPE).get().getInternalId());\n       \n       \n       \n       \n        register(13, simpleBuilder()\n                        .itemType()\n                        .properties(builder -> builder\n                                .add(hardness(0.6))\n                                .add(blastResistance(3.0)))\n                        .translation(\"tile.gravel.name\")\n                        .build(\"minecraft\", \"gravel\"));\n       \n       \n       \n       \n        register(14, simpleBuilder()\n                        .itemType()\n                        .properties(builder -> builder\n                                .add(hardness(3.0))\n                                .add(blastResistance(15.0)))\n                        .translation(\"tile.oreGold.name\")\n                        .build(\"minecraft\", \"gold_ore\"));\n       \n       \n       \n        register(15, simpleBuilder()\n                        .itemType()\n                        .properties(builder -> builder\n                                .add(hardness(3.0))\n                                .add(blastResistance(15.0)))\n                        .translation(\"tile.oreIron.name\")\n                        .build(\"minecraft\", \"iron_ore\"));\n       \n       \n       \n        register(16, simpleBuilder()\n                        .itemType()\n                        .properties(builder -> builder\n                                .add(hardness(3.0))\n                                .add(blastResistance(15.0)))\n                        .translation(\"tile.oreCoal.name\")\n                        .build(\"minecraft\", \"coal_ore\"));\n       \n       \n       \n        register(17, logBuilder(LanternEnumTraits.LOG1_TYPE, LanternTreeType.OAK)\n                        .build(\"minecraft\", \"log\"),\n                blockState -> logData(blockState, blockState.getTraitValue(LanternEnumTraits.LOG1_TYPE).get().getInternalId()));\n       \n       \n       \n        register(18, leavesBuilder(LanternEnumTraits.LEAVES1_TYPE, LanternTreeType.OAK)\n                        .build(\"minecraft\", \"leaves\"),\n                blockState -> leavesData(blockState, blockState.getTraitValue(LanternEnumTraits.LEAVES1_TYPE).get().getInternalId()));\n       \n       \n       \n        register(19, simpleBuilder()\n                        .trait(LanternBooleanTraits.IS_WET)\n                        .defaultState(state -> state.withTrait(LanternBooleanTraits.IS_WET, false).get())\n                        .itemType(builder -> builder\n                                .keysProvider(collection -> collection\n                                        .register(Keys.IS_WET, false)\n                                )\n                        )\n                        .properties(builder -> builder\n                                .add(hardness(0.6))\n                                .add(blastResistance(3.0)))\n                        .translation(new SpongeTranslationProvider())\n                        .build(\"minecraft\", \"sponge\"),\n                blockState -> (byte) (blockState.getTraitValue(LanternBooleanTraits.IS_WET).get() ? 1 : 0));\n       \n       \n       \n        register(20, simpleBuilder()\n                        .itemType()\n                        .properties(builder -> builder\n                                .add(hardness(0.3))\n                                .add(blastResistance(1.5)))\n                        .translation(\"tile.glass.name\")\n                        .build(\"minecraft\", \"glass\"));\n       \n       \n       \n        register(21, simpleBuilder()\n                        .itemType()\n                        .properties(builder -> builder\n                                .add(hardness(3.0))\n                                .add(blastResistance(15.0)))\n                        .translation(\"tile.oreLapis.name\")\n                        .build(\"minecraft\", \"lapis_ore\"));\n       \n       \n       \n        register(22, simpleBuilder()\n                        .itemType()\n                        .properties(builder -> builder\n                                .add(hardness(3.0))\n                                .add(blastResistance(15.0)))\n                        .translation(\"tile.blockLapis.name\")\n                        .build(\"minecraft\", \"lapis_block\"));\n       \n       \n       \n        register(23, simpleBuilder()\n                        .traits(LanternEnumTraits.FACING, LanternBooleanTraits.TRIGGERED)\n                        .defaultState(state -> state\n                                .withTrait(LanternEnumTraits.FACING, Direction.NORTH).get()\n                                .withTrait(LanternBooleanTraits.TRIGGERED, false).get())\n                        .itemType()\n                        .properties(builder -> builder\n                                .add(hardness(3.5))\n                                .add(blastResistance(17.5)))\n                       \n                        .translation(\"tile.dispenser.name\")\n                        .behaviors(pipeline -> pipeline\n                                .add(new RotationPlacementBehavior()))\n                        .build(\"minecraft\", \"dispenser\"),\n                blockState -> {\n                    int data = directionData(blockState.getTraitValue(LanternEnumTraits.FACING).get());\n                    if (blockState.getTraitValue(LanternBooleanTraits.TRIGGERED).get()) {\n                        data |= 0x8;\n                    }\n                    return (byte) data;\n                });\n       \n       \n       \n        register(24, simpleBuilder()\n                        .trait(LanternEnumTraits.SANDSTONE_TYPE)\n                        .defaultState(state -> state.withTrait(LanternEnumTraits.SANDSTONE_TYPE, LanternSandstoneType.DEFAULT).get())\n                        .itemType(builder -> builder\n                                .keysProvider(collection -> collection\n                                        .register(Keys.SANDSTONE_TYPE, LanternSandstoneType.DEFAULT)\n                                )\n                        )\n                        .properties(builder -> builder\n                                .add(hardness(0.8))\n                                .add(blastResistance(4.0)))\n                        .translation(TranslationProvider.of(LanternEnumTraits.SANDSTONE_TYPE))\n                        .build(\"minecraft\", \"sandstone\"),\n                blockState -> (byte) blockState.getTraitValue(LanternEnumTraits.SANDSTONE_TYPE).get().getInternalId());\n       \n       \n       \n        register(25, simpleBuilder()\n                        .itemType()\n                        .properties(builder -> builder\n                                .add(hardness(0.8))\n                                .add(blastResistance(4.0)))\n                        .translation(\"tile.musicBlock.name\")\n                        .tileEntityType(() -> TileEntityTypes.NOTE)\n                        .behaviors(pipeline -> pipeline\n                                .add(new NoteBlockInteractionBehavior()))\n                        .build(\"minecraft\", \"noteblock\"));\n       \n       \n       \n        register(26, simpleBuilder()\n                        .traits(LanternEnumTraits.HORIZONTAL_FACING, LanternEnumTraits.BED_PART, LanternBooleanTraits.OCCUPIED)\n                        .defaultState(state -> state\n                                .withTrait(LanternEnumTraits.HORIZONTAL_FACING, Direction.NORTH).get()\n                                .withTrait(LanternEnumTraits.BED_PART, LanternBedPart.FOOT).get()\n                                .withTrait(LanternBooleanTraits.OCCUPIED, false).get())\n                        .properties(builder -> builder\n                                .add(hardness(0.2))\n                                .add(blastResistance(1.0)))\n                        .translation(\"tile.bed.name\")\n                        .build(\"minecraft\", \"bed\"),\n                blockState -> {\n                    final Direction facing = blockState.getTraitValue(LanternEnumTraits.HORIZONTAL_FACING).get();\n                    int type = facing == Direction.SOUTH  ? 0 : facing == Direction.WEST ? 1 :\n                            facing == Direction.NORTH ? 2 : facing == Direction.EAST ? 3 : -1;\n                    checkArgument(type != -1);\n                    if (blockState.getTraitValue(LanternBooleanTraits.OCCUPIED).get()) {\n                        type |= 0x4;\n                    }\n                    if (blockState.getTraitValue(LanternEnumTraits.BED_PART).get() == LanternBedPart.HEAD) {\n                        type |= 0x8;\n                    }\n                    return (byte) type;\n                });\n       \n       \n       \n        register(27, simpleBuilder()\n                        .traits(LanternEnumTraits.STRAIGHT_RAIL_DIRECTION, LanternBooleanTraits.POWERED)\n                        .defaultState(state -> state\n                                .withTrait(LanternEnumTraits.STRAIGHT_RAIL_DIRECTION, LanternRailDirection.NORTH_SOUTH).get()\n                                .withTrait(LanternBooleanTraits.POWERED, false).get())\n                        .itemType()\n                        .selectionBox(BoundingBoxes::rail)\n                        .properties(builder -> builder\n                                .add(PASSABLE)\n                                .add(hardness(0.7))\n                                .add(blastResistance(3.5)))\n                        .translation(\"tile.goldenRail.name\")\n                        .build(\"minecraft\", \"golden_rail\"),\n                blockState -> {\n                    int type = blockState.getTraitValue(LanternEnumTraits.STRAIGHT_RAIL_DIRECTION).get().getInternalId();\n                    if (blockState.getTraitValue(LanternBooleanTraits.POWERED).get()) {\n                        type |= 0x8;\n                    }\n                    return (byte) type;\n                });\n       \n       \n       \n        register(28, simpleBuilder()\n                        .traits(LanternEnumTraits.STRAIGHT_RAIL_DIRECTION, LanternBooleanTraits.POWERED)\n                        .defaultState(state -> state\n                                .withTrait(LanternEnumTraits.STRAIGHT_RAIL_DIRECTION, LanternRailDirection.NORTH_SOUTH).get()\n                                .withTrait(LanternBooleanTraits.POWERED, false).get())\n                        .itemType()\n                        .selectionBox(BoundingBoxes::rail)\n                        .properties(builder -> builder\n                                .add(PASSABLE)\n                                .add(hardness(0.7))\n                                .add(blastResistance(3.5)))\n                        .translation(\"tile.detectorRail.name\")\n                        .build(\"minecraft\", \"detector_rail\"),\n                blockState -> {\n                    int type = blockState.getTraitValue(LanternEnumTraits.STRAIGHT_RAIL_DIRECTION).get().getInternalId();\n                    if (blockState.getTraitValue(LanternBooleanTraits.POWERED).get()) {\n                        type |= 0x8;\n                    }\n                    return (byte) type;\n                });\n       \n       \n       \n       \n        register(30, simpleBuilder()\n                        .itemType()\n                        .properties(builder -> builder\n                                .add(PASSABLE)\n                                .add(hardness(4.0))\n                                .add(blastResistance(20.0)))\n                        .translation(\"tile.web.name\")\n                        .build(\"minecraft\", \"web\"));\n       \n       \n       \n        register(31, simpleBuilder()\n                        .traits(LanternEnumTraits.SHRUB_TYPE)\n                            .defaultState(state -> state\n                                    .withTrait(LanternEnumTraits.SHRUB_TYPE, LanternShrubType.DEAD_BUSH).get())\n                        .itemType(builder -> builder\n                                .keysProvider(collection -> collection\n                                        .register(Keys.SHRUB_TYPE, LanternShrubType.DEAD_BUSH)))\n                        .selectionBox(BoundingBoxes.bush())\n                        .properties(builder -> builder\n                                .add(INSTANT_BROKEN)\n                                .add(PASSABLE)\n                                .add(replaceable(true)))\n                        .translation(\"tile.tallgrass.name\")\n                        .build(\"minecraft\", \"tallgrass\"),\n                blockState -> (byte) blockState.getTraitValue(LanternEnumTraits.SHRUB_TYPE).get().getInternalId());\n       \n       \n       \n        register(32, simpleBuilder()\n                        .properties(builder -> builder\n                                .add(INSTANT_BROKEN)\n                                .add(PASSABLE)\n                                .add(replaceable(true)))\n                        .selectionBox(BoundingBoxes.bush())\n                        .itemType()\n                        .translation(\"tile.deadbush.name\")\n                        .build(\"minecraft\", \"deadbush\"));\n       \n       \n       \n       \n       \n        register(35, dyedBuilder(\"tile.wool.%s.name\")\n                        .properties(builder -> builder\n                                .add(hardness(0.8))\n                                .add(blastResistance(4.0)))\n                        .build(\"minecraft\", \"wool\"),\n                this::dyedData);\n       \n       \n       \n       \n        register(37, simpleBuilder()\n                        .traits(LanternEnumTraits.YELLOW_FLOWER_TYPE)\n                        .defaultState(state -> state\n                                .withTrait(LanternEnumTraits.YELLOW_FLOWER_TYPE, LanternPlantType.DANDELION).get())\n                        .itemType(builder -> builder\n                                .keysProvider(collection -> collection\n                                        .register(Keys.PLANT_TYPE, LanternPlantType.DANDELION)))\n                        .selectionBox(BoundingBoxes.bush())\n                        .properties(builder -> builder\n                                .add(INSTANT_BROKEN)\n                                .add(PASSABLE))\n                        .translation(TranslationProvider.of(LanternEnumTraits.YELLOW_FLOWER_TYPE))\n                        .build(\"minecraft\", \"yellow_flower\"),\n                blockState -> (byte) blockState.getTraitValue(LanternEnumTraits.YELLOW_FLOWER_TYPE).get().getInternalId());\n       \n       \n       \n        register(38, simpleBuilder()\n                        .traits(LanternEnumTraits.RED_FLOWER_TYPE)\n                        .defaultState(state -> state\n                                .withTrait(LanternEnumTraits.RED_FLOWER_TYPE, LanternPlantType.POPPY).get())\n                        .itemType(builder -> builder\n                                .keysProvider(collection -> collection\n                                        .register(Keys.PLANT_TYPE, LanternPlantType.POPPY)))\n                        .selectionBox(BoundingBoxes.bush())\n                        .properties(builder -> builder\n                                .add(INSTANT_BROKEN)\n                                .add(PASSABLE))\n                        .translation(TranslationProvider.of(LanternEnumTraits.RED_FLOWER_TYPE))\n                        .build(\"minecraft\", \"red_flower\"),\n                blockState -> (byte) blockState.getTraitValue(LanternEnumTraits.RED_FLOWER_TYPE).get().getInternalId());\n       \n       \n       \n        register(39, simpleBuilder()\n                        .selectionBox(BoundingBoxes.bush())\n                        .properties(builder -> builder\n                                .add(INSTANT_BROKEN)\n                                .add(PASSABLE)\n                                .add(lightEmission(1)))\n                        .translation(\"tile.mushroom.name\")\n                        .build(\"minecraft\", \"brown_mushroom\"));\n       \n       \n       \n        register(40, simpleBuilder()\n                        .selectionBox(BoundingBoxes.bush())\n                        .properties(builder -> builder\n                                .add(INSTANT_BROKEN)\n                                .add(PASSABLE))\n                        .translation(\"tile.mushroom.name\")\n                        .build(\"minecraft\", \"red_mushroom\"));\n       \n       \n       \n        register(41, simpleBuilder()\n                        .itemType()\n                        .properties(builder -> builder\n                                .add(hardness(3.0))\n                                .add(blastResistance(10.0)))\n                        .translation(\"tile.blockGold.name\")\n                        .build(\"minecraft\", \"gold_block\"));\n       \n       \n       \n        register(42, simpleBuilder()\n                        .itemType()\n                        .properties(builder -> builder\n                                .add(hardness(5.0))\n                                .add(blastResistance(10.0)))\n                        .translation(\"tile.blockIron.name\")\n                        .build(\"minecraft\", \"iron_block\"));\n       \n       \n       \n        register(43, doubleStoneSlab(LanternEnumTraits.STONE_SLAB1_TYPE, LanternSlabType.STONE)\n                        .translation(\"tile.stoneSlab.name\")\n                        .build(\"minecraft\", \"double_stone_slab\"),\n                blockState -> doubleStoneSlabData(blockState, blockState.getTraitValue(LanternEnumTraits.STONE_SLAB1_TYPE).get().getInternalId()));\n       \n       \n       \n        register(44, stoneSlab(LanternEnumTraits.STONE_SLAB1_TYPE, LanternSlabType.STONE,\n                () -> BlockTypes.STONE_SLAB,\n                () -> BlockTypes.DOUBLE_STONE_SLAB)\n                        .translation(\"tile.stoneSlab.name\")\n                        .collisionBox(BoundingBoxes::slab)\n                        .build(\"minecraft\", \"stone_slab\"),\n                blockState -> stoneSlabData(blockState, blockState.getTraitValue(LanternEnumTraits.STONE_SLAB1_TYPE).get().getInternalId()));\n       \n       \n       \n        register(45, simpleBuilder()\n                        .itemType()\n                        .properties(builder -> builder\n                                .add(hardness(2.0))\n                                .add(blastResistance(10.0)))\n                        .translation(\"tile.brick.name\")\n                        .build(\"minecraft\", \"brick_block\"));\n       \n       \n       \n        register(46, simpleBuilder()\n                        .trait(LanternBooleanTraits.EXPLODE)\n                        .defaultState(state -> state\n                                .withTrait(LanternBooleanTraits.EXPLODE, false).get())\n                        .itemType()\n                        .properties(builder -> builder\n                                .add(INSTANT_BROKEN))\n                        .translation(\"tile.tnt.name\")\n                        .build(\"minecraft\", \"tnt\"),\n                blockState -> (byte) (blockState.getTraitValue(LanternBooleanTraits.EXPLODE).get() ? 1 : 0));\n       \n       \n       \n        register(47, simpleBuilder()\n                        .itemType()\n                        .properties(builder -> builder\n                                .add(hardness(1.5))\n                                .add(blastResistance(7.5)))\n                        .translation(\"tile.bookshelf.name\")\n                        .build(\"minecraft\", \"bookshelf\"));\n       \n       \n       \n        register(48, simpleBuilder()\n                        .itemType()\n                        .properties(builder -> builder\n                                .add(hardness(2.0))\n                                .add(blastResistance(10.0)))\n                        .translation(\"tile.stoneMoss.name\")\n                        .build(\"minecraft\", \"mossy_cobblestone\"));\n       \n       \n       \n        register(49, simpleBuilder()\n                        .itemType()\n                        .properties(builder -> builder\n                                .add(hardness(50.0))\n                                .add(blastResistance(2000.0)))\n                        .translation(\"tile.obsidian.name\")\n                        .build(\"minecraft\", \"obsidian\"));\n       \n       \n       \n        register(50, builder()\n                        .trait(LanternEnumTraits.TORCH_FACING)\n                            .defaultState(state -> state\n                                    .withTrait(LanternEnumTraits.TORCH_FACING, Direction.UP).get())\n                        .itemType()\n                        .properties(builder -> builder\n                                .add(PASSABLE)\n                                .add(INSTANT_BROKEN))\n                        .translation(\"tile.torch.name\")\n                        .selectionBox(BoundingBoxes::torch)\n                        .behaviors(pipeline -> pipeline\n                                .add(new BlockSnapshotProviderPlaceBehavior())\n                                .add(new TorchPlacementBehavior())\n                                .add(new SimpleBreakBehavior()))\n                        .build(\"minecraft\", \"torch\"),\n                blockState -> {\n                    final Direction direction = blockState.getTraitValue(LanternEnumTraits.TORCH_FACING).get();\n                    switch (direction) {\n                        case EAST:\n                            return (byte) 1;\n                        case WEST:\n                            return (byte) 2;\n                        case SOUTH:\n                            return (byte) 3;\n                        case NORTH:\n                            return (byte) 4;\n                        case UP:\n                            return (byte) 5;\n                        default:\n                            throw new IllegalArgumentException();\n                    }\n                });\n       \n       \n       \n        register(51, simpleBuilder()\n                        .properties(builder -> builder\n                                .add(PASSABLE)\n                                .add(INSTANT_BROKEN)\n                                .add(lightEmission(15)))\n                        .collisionBox(BoundingBoxes.NULL)\n                        .translation(\"tile.fire.name\")\n                        .build(\"minecraft\", \"fire\"));\n       \n       \n       \n        register(52, simpleBuilder()\n                        .properties(builder -> builder\n                                .add(hardness(5.0))\n                                .add(blastResistance(25.0)))\n                        .translation(\"tile.mobSpawner.name\")\n                        .build(\"minecraft\", \"mob_spawner\"));\n       \n       \n       \n       \n        register(54, chestBuilder()\n                        .translation(\"tile.chest.name\")\n                        .build(\"minecraft\", \"chest\"),\n                this::horizontalFacingData);\n       \n       \n       \n        register(55, simpleBuilder()\n                        .traits(LanternIntegerTraits.POWER)\n                        .selectionBox(new AABB(0, 0, 0, 1.0, 0.0625, 1.0))\n                        .properties(builder -> builder\n                                .add(PASSABLE)\n                                .add(INSTANT_BROKEN))\n                        .defaultState(state -> state\n                                .withTrait(LanternIntegerTraits.POWER, 0).get())\n                        .translation(\"tile.redstoneDust.name\")\n                        .build(\"minecraft\", \"redstone_wire\"),\n                state -> state.get(Keys.POWER).get().byteValue());\n       \n       \n       \n        register(56, simpleBuilder()\n                        .itemType()\n                        .properties(builder -> builder\n                                .add(hardness(3.0))\n                                .add(blastResistance(5.0)))\n                        .translation(\"tile.oreDiamond.name\")\n                        .build(\"minecraft\", \"diamond_ore\"));\n       \n       \n       \n        register(57, simpleBuilder()\n                        .itemType()\n                        .properties(builder -> builder\n                                .add(hardness(5.0))\n                                .add(blastResistance(10.0)))\n                        .translation(\"tile.blockDiamond.name\")\n                        .build(\"minecraft\", \"diamond_block\"));\n       \n       \n       \n        register(58, simpleBuilder()\n                        .itemType()\n                        .properties(builder -> builder\n                                .add(hardness(2.5))\n                                .add(blastResistance(12.5)))\n                        .translation(\"tile.workbench.name\")\n                        .behaviors(pipeline -> pipeline\n                                .add(new CraftingTableInteractionBehavior()))\n                        .build(\"minecraft\", \"crafting_table\"));\n       \n       \n       \n       \n        register(60, simpleBuilder()\n                        .collisionBox(BoundingBoxes.farmland())\n                        .trait(LanternIntegerTraits.MOISTURE)\n                        .properties(builder -> builder\n                                .add(hardness(0.6))\n                                .add(blastResistance(3.0)))\n                        .defaultState(state ->\n                                state.withTrait(LanternIntegerTraits.MOISTURE, 0).get())\n                        .translation(\"tile.farmland.name\")\n                        .build(\"minecraft\", \"farmland\"),\n                state -> state.getTraitValue(LanternIntegerTraits.MOISTURE).get().byteValue());\n       \n       \n       \n        register(61, furnaceBuilder()\n                        .itemType()\n                        .translation(\"tile.furnace.name\")\n                        .build(\"minecraft\", \"furnace\"),\n                this::directionData);\n       \n       \n       \n        register(62, furnaceBuilder()\n                        .properties(builder -> builder\n                                .add(lightEmission(13)))\n                        .translation(\"tile.furnace.name\")\n                        .build(\"minecraft\", \"lit_furnace\"),\n                this::directionData);\n       \n       \n       \n        register(70, pressurePlateBuilder()\n                        .translation(\"tile.pressurePlateStone.name\")\n                        .build(\"minecraft\", \"stone_pressure_plate\"),\n                this::pressurePlateData);\n       \n       \n       \n        register(72, pressurePlateBuilder()\n                        .translation(\"tile.pressurePlateWood.name\")\n                        .build(\"minecraft\", \"wooden_pressure_plate\"),\n                this::pressurePlateData);\n       \n       \n       \n        register(84, simpleBuilder()\n                        .itemType()\n                        .traits(LanternBooleanTraits.HAS_RECORD)\n                        .defaultState(state -> state\n                                .withTrait(LanternBooleanTraits.HAS_RECORD, false).get())\n                        .properties(builder -> builder\n                                .add(hardness(2.0))\n                                .add(blastResistance(10.0)))\n                        .tileEntityType(() -> TileEntityTypes.JUKEBOX)\n                        .translation(\"tile.jukebox.name\")\n                        .behaviors(pipeline -> pipeline\n                                .add(new JukeboxInteractionBehavior()))\n                        .build(\"minecraft\", \"jukebox\"),\n                state -> (byte) (state.getTraitValue(LanternBooleanTraits.HAS_RECORD).get() ? 1 : 0));\n       \n       \n       \n        register(86, pumpkinBuilder()\n                        .itemType(builder -> builder\n                                .properties(properties -> properties\n                                        .add(equipmentType(EquipmentTypes.HEADWEAR))))\n                        .translation(\"tile.pumpkin.name\")\n                        .build(\"minecraft\", \"pumpkin\"),\n                this::horizontalDirectionData);\n       \n       \n       \n        register(87, simpleBuilder()\n                        .itemType()\n                        .properties(builder -> builder\n                                .add(hardness(0.4))\n                                .add(blastResistance(2.0)))\n                        .translation(\"tile.hellrock.name\")\n                        .build(\"minecraft\", \"netherrack\"));\n       \n       \n       \n        register(91, pumpkinBuilder()\n                        .properties(builder -> builder\n                                .add(lightEmission(15)))\n                        .translation(\"tile.litpumpkin.name\")\n                        .build(\"minecraft\", \"lit_pumpkin\"),\n                this::horizontalDirectionData);\n       \n       \n       \n        register(95, dyedBuilder(\"tile.stainedGlass.%s.name\")\n                        .properties(builder -> builder\n                                .add(hardness(0.3))\n                                .add(blastResistance(1.5)))\n                        .build(\"minecraft\", \"stained_glass\"),\n                this::dyedData);\n       \n       \n       \n        register(101, simpleBuilder()\n                       \n                        .itemType()\n                        .properties(builder -> builder\n                                .add(hardness(5.0))\n                                .add(blastResistance(10.0)))\n                        .translation(\"tile.fenceIron.name\")\n                        .build(\"minecraft\", \"iron_bars\"));\n       \n       \n       \n        register(121, simpleBuilder()\n                        .itemType()\n                        .properties(builder -> builder\n                                .add(hardness(3.0))\n                                .add(blastResistance(15.0)))\n                        .translation(\"tile.whiteStone.name\")\n                        .build(\"minecraft\", \"end_stone\"));\n       \n       \n       \n        register(125, simpleBuilder()\n                        .traits(LanternEnumTraits.TREE_TYPE)\n                        .defaultState(state -> state\n                                .withTrait(LanternEnumTraits.TREE_TYPE, LanternTreeType.OAK).get())\n                        .translation(TranslationProvider.of(LanternEnumTraits.TREE_TYPE, type ->\n                                tr(\"tile.woodSlab.\" + type.getTranslationKeyBase() + \".name\")))\n                        .itemType(builder -> builder\n                                .keysProvider(collection -> collection\n                                        .register(Keys.TREE_TYPE, LanternTreeType.OAK)\n                                )\n                        )\n                        .properties(builder -> builder\n                                .add(hardness(2.0))\n                                .add(blastResistance(5.0)))\n                        .build(\"minecraft\", \"double_wooden_slab\"),\n                blockState -> (byte) blockState.getTraitValue(LanternEnumTraits.TREE_TYPE).get().getInternalId());\n       \n       \n       \n        register(126, simpleBuilder()\n                        .traits(LanternEnumTraits.PORTION_TYPE, LanternEnumTraits.TREE_TYPE)\n                        .defaultState(state -> state\n                                .withTrait(LanternEnumTraits.PORTION_TYPE, LanternPortionType.BOTTOM).get()\n                                .withTrait(LanternEnumTraits.TREE_TYPE, LanternTreeType.OAK).get())\n                        .translation(TranslationProvider.of(LanternEnumTraits.TREE_TYPE, type ->\n                                tr(\"tile.woodSlab.\" + type.getTranslationKeyBase() + \".name\")))\n                        .itemType(builder -> builder\n                                .behaviors(pipeline -> pipeline\n                                        .add(new SlabItemInteractionBehavior<>(LanternEnumTraits.TREE_TYPE,\n                                                () -> BlockTypes.WOODEN_SLAB,\n                                                () -> BlockTypes.DOUBLE_WOODEN_SLAB))\n                                        .add(new PlacementCollisionDetectionBehavior()))\n                                .keysProvider(collection -> collection\n                                        .register(Keys.TREE_TYPE, LanternTreeType.OAK)\n                                )\n                        )\n                        .collisionBox(BoundingBoxes::slab)\n                        .properties(builder -> builder\n                                .add(hardness(2.0))\n                                .add(blastResistance(5.0)))\n                        .build(\"minecraft\", \"wooden_slab\"),\n                blockState -> {\n                    final int type = blockState.getTraitValue(LanternEnumTraits.TREE_TYPE).get().getInternalId();\n                    final int portion = (byte) blockState.getTraitValue(LanternEnumTraits.PORTION_TYPE).get().getInternalId();\n                    return (byte) (portion << 3 | type);\n                });\n       \n       \n       \n        register(130, simpleBuilder()\n                        .trait(LanternEnumTraits.HORIZONTAL_FACING)\n                        .defaultState(state -> state.withTrait(LanternEnumTraits.HORIZONTAL_FACING, Direction.NORTH).get())\n                        .itemType()\n                        .tileEntityType(() -> TileEntityTypes.ENDER_CHEST)\n                        .properties(builder -> builder\n                                .add(hardness(22.5))\n                                .add(blastResistance(3000.0))\n                                .add(lightEmission(7)))\n                        .translation(\"tile.enderChest.name\")\n                        .collisionBox(BoundingBoxes.chest())\n                        .behaviors(pipeline -> pipeline\n                                .add(new HorizontalRotationPlacementBehavior())\n                                .add(new EnderChestInteractionBehavior()))\n                        .build(\"minecraft\", \"ender_chest\"),\n                this::horizontalFacingData);\n       \n       \n       \n        register(146, chestBuilder()\n                        .translation(\"tile.chestTrap.name\")\n                        .build(\"minecraft\", \"trapped_chest\"),\n                this::horizontalFacingData);\n       \n       \n       \n        register(147, weightedPressurePlateBuilder()\n                        .translation(\"tile.weightedPlate_light.name\")\n                        .build(\"minecraft\", \"light_weighted_pressure_plate\"),\n                this::weightedPressurePlateData);\n       \n       \n       \n        register(148, weightedPressurePlateBuilder()\n                        .translation(\"tile.weightedPlate_heavy.name\")\n                        .build(\"minecraft\", \"heavy_weighted_pressure_plate\"),\n                this::weightedPressurePlateData);\n       \n       \n       \n        register(152, simpleBuilder()\n                        .itemType()\n                        .properties(builder -> builder\n                                .add(hardness(5.0))\n                                .add(blastResistance(30.0)))\n                        .translation(\"tile.blockRedstone.name\")\n                        .build(\"minecraft\", \"redstone_block\"));\n       \n       \n       \n        register(153, simpleBuilder()\n                        .itemType()\n                        .properties(builder -> builder\n                                .add(hardness(3.0))\n                                .add(blastResistance(15.0)))\n                        .translation(\"tile.netherquartz.name\")\n                        .build(\"minecraft\", \"quartz_ore\"));\n       \n       \n       \n        register(154, simpleBuilder()\n                        .traits(LanternEnumTraits.HOPPER_FACING, LanternBooleanTraits.ENABLED)\n                        .defaultState(state -> state\n                                .withTrait(LanternEnumTraits.HOPPER_FACING, Direction.DOWN).get()\n                                .withTrait(LanternBooleanTraits.ENABLED, false).get())\n                        .itemType()\n                        .properties(builder -> builder\n                                .add(hardness(3.0))\n                                .add(blastResistance(8.0)))\n                        .translation(\"tile.hopper.name\")\n                        .behaviors(pipeline -> pipeline\n                                .add(new HopperPlacementBehavior()))\n                        .build(\"minecraft\", \"hopper\"),\n                blockState -> {\n                    int data = directionData(blockState.getTraitValue(LanternEnumTraits.HOPPER_FACING).get());\n                    if (!blockState.getTraitValue(LanternBooleanTraits.ENABLED).get()) {\n                        data |= 0x8;\n                    }\n                    return (byte) data;\n                });\n       \n       \n       \n        register(155, simpleBuilder()\n                        .trait(LanternEnumTraits.QUARTZ_TYPE)\n                        .defaultState(state -> state\n                                .withTrait(LanternEnumTraits.QUARTZ_TYPE, LanternQuartzType.DEFAULT).get())\n                        .itemType(builder -> builder\n                                .keysProvider(collection -> collection\n                                        .register(Keys.QUARTZ_TYPE, LanternQuartzType.DEFAULT)\n                                )\n                        )\n                        .properties(builder -> builder\n                                .add(hardness(0.8))\n                                .add(blastResistance(2.4)))\n                        .translation(TranslationProvider.of(LanternEnumTraits.QUARTZ_TYPE))\n                        .behaviors(pipeline -> pipeline\n                                .add(new QuartzLinesRotationPlacementBehavior()))\n                        .build(\"minecraft\", \"quartz_block\"),\n                blockState -> (byte) blockState.getTraitValue(LanternEnumTraits.QUARTZ_TYPE).get().getInternalId());\n       \n       \n       \n        register(158, simpleBuilder()\n                        .traits(LanternEnumTraits.FACING, LanternBooleanTraits.TRIGGERED)\n                        .defaultState(state -> state\n                                .withTrait(LanternEnumTraits.FACING, Direction.NORTH).get()\n                                .withTrait(LanternBooleanTraits.TRIGGERED, false).get())\n                        .itemType()\n                        .properties(builder -> builder\n                                .add(hardness(3.5))\n                                .add(blastResistance(17.5)))\n                       \n                        .translation(\"tile.dropper.name\")\n                        .behaviors(pipeline -> pipeline\n                                .add(new RotationPlacementBehavior()))\n                        .build(\"minecraft\", \"dropper\"),\n                blockState -> {\n                    int data = directionData(blockState.getTraitValue(LanternEnumTraits.FACING).get());\n                    if (blockState.getTraitValue(LanternBooleanTraits.TRIGGERED).get()) {\n                        data |= 0x8;\n                    }\n                    return (byte) data;\n                });\n       \n       \n       \n        register(159, dyedBuilder(\"tile.clayHardenedStained.%s.name\")\n                        .properties(builder -> builder\n                                .add(hardness(1.25))\n                                .add(blastResistance(7.0)))\n                        .build(\"minecraft\", \"stained_hardened_clay\"),\n                this::dyedData);\n       \n       \n       \n        register(160, dyedBuilder(\"tile.thinStainedGlass.%s.name\")\n                        .properties(builder -> builder\n                                .add(hardness(0.3))\n                                .add(blastResistance(1.5)))\n                        .build(\"minecraft\", \"stained_glass_pane\"),\n                this::dyedData);\n       \n       \n       \n        register(161, leavesBuilder(LanternEnumTraits.LEAVES2_TYPE, LanternTreeType.ACACIA)\n                        .build(\"minecraft\", \"leaves2\"),\n                blockState -> leavesData(blockState, blockState.getTraitValue(LanternEnumTraits.LEAVES2_TYPE).get().getInternalId() - 4));\n       \n       \n       \n        register(162, logBuilder(LanternEnumTraits.LOG2_TYPE, LanternTreeType.ACACIA)\n                        .build(\"minecraft\", \"log2\"),\n                blockState -> logData(blockState, blockState.getTraitValue(LanternEnumTraits.LOG2_TYPE).get().getInternalId() - 4));\n       \n       \n       \n        register(166, simpleBuilder()\n                        .itemType()\n                        .properties(builder -> builder\n                                .add(PropertyProviderCollections.UNBREAKABLE))\n                        .translation(\"tile.barrier.name\")\n                        .build(\"minecraft\", \"barrier\"));\n       \n       \n       \n        register(171, dyedBuilder(\"tile.carpet.%s.name\")\n                        .properties(builder -> builder\n                                .add(hardness(0.1))\n                                .add(blastResistance(0.5))\n                                .add(solidMaterial(false)))\n                        .collisionBox(BoundingBoxes.carpet())\n                        .build(\"minecraft\", \"carpet\"),\n                this::dyedData);\n       \n       \n       \n        register(179, simpleBuilder()\n                        .trait(LanternEnumTraits.SANDSTONE_TYPE)\n                        .defaultState(state -> state.withTrait(LanternEnumTraits.SANDSTONE_TYPE, LanternSandstoneType.DEFAULT).get())\n                        .itemType(builder -> builder\n                                .keysProvider(collection -> collection\n                                        .register(Keys.SANDSTONE_TYPE, LanternSandstoneType.DEFAULT)\n                                )\n                        )\n                        .properties(builder -> builder\n                                .add(hardness(0.8))\n                                .add(blastResistance(4.0)))\n                        .translation(TranslationProvider.of(LanternEnumTraits.SANDSTONE_TYPE))\n                        .build(\"minecraft\", \"red_sandstone\"),\n                blockState -> (byte) blockState.getTraitValue(LanternEnumTraits.SANDSTONE_TYPE).get().getInternalId());\n       \n       \n       \n        register(181, doubleStoneSlab(LanternEnumTraits.STONE_SLAB2_TYPE, LanternSlabType.RED_SAND)\n                        .translation(\"tile.stoneSlab2.name\")\n                        .build(\"minecraft\", \"double_stone_slab2\"),\n                blockState -> doubleStoneSlabData(blockState,\n                        blockState.getTraitValue(LanternEnumTraits.STONE_SLAB2_TYPE).get().getInternalId() - 8));\n       \n       \n       \n        register(182, stoneSlab(LanternEnumTraits.STONE_SLAB2_TYPE, LanternSlabType.RED_SAND,\n                () -> BlockTypes.STONE_SLAB2,\n                () -> BlockTypes.DOUBLE_STONE_SLAB2)\n                        .translation(\"tile.stoneSlab2.name\")\n                        .collisionBox(BoundingBoxes::slab)\n                        .build(\"minecraft\", \"stone_slab2\"),\n                blockState -> stoneSlabData(blockState, blockState.getTraitValue(LanternEnumTraits.STONE_SLAB2_TYPE).get().getInternalId() - 8));\n       \n       \n       \n        register(198, simpleBuilder()\n                        .itemType()\n                        .properties(builder -> builder\n                                .add(hardness(0.0))\n                                .add(blastResistance(0.0))\n                                .add(lightEmission(14)))\n                        .translation(\"tile.endRod.name\")\n                        .build(\"minecraft\", \"end_rod\"));\n       \n       \n       \n        register(219, shulkerBox()\n                        .translation(\"tile.shulkerBoxWhite.name\")\n                        .build(\"minecraft\", \"white_shulker_box\"),\n                this::shulkerBoxData);\n       \n       \n       \n        register(220, shulkerBox()\n                        .translation(\"tile.shulkerBoxOrange.name\")\n                        .build(\"minecraft\", \"orange_shulker_box\"),\n                this::shulkerBoxData);\n       \n       \n       \n        register(221, shulkerBox()\n                        .translation(\"tile.shulkerBoxMagenta.name\")\n                        .build(\"minecraft\", \"magenta_shulker_box\"),\n                this::shulkerBoxData);\n       \n       \n       \n        register(222, shulkerBox()\n                        .translation(\"tile.shulkerBoxLightBlue.name\")\n                        .build(\"minecraft\", \"light_blue_shulker_box\"),\n                this::shulkerBoxData);\n       \n       \n       \n        register(223, shulkerBox()\n                        .translation(\"tile.shulkerBoxYellow.name\")\n                        .build(\"minecraft\", \"yellow_shulker_box\"),\n                this::shulkerBoxData);\n       \n       \n       \n        register(224, shulkerBox()\n                        .translation(\"tile.shulkerBoxLime.name\")\n                        .build(\"minecraft\", \"lime_shulker_box\"),\n                this::shulkerBoxData);\n       \n       \n       \n        register(225, shulkerBox()\n                        .translation(\"tile.shulkerBoxPink.name\")\n                        .build(\"minecraft\", \"pink_shulker_box\"),\n                this::shulkerBoxData);\n       \n       \n       \n        register(226, shulkerBox()\n                        .translation(\"tile.shulkerBoxGray.name\")\n                        .build(\"minecraft\", \"gray_shulker_box\"),\n                this::shulkerBoxData);\n       \n       \n       \n        register(227, shulkerBox()\n                        .translation(\"tile.shulkerBoxSilver.name\")\n                        .build(\"minecraft\", \"silver_shulker_box\"),\n                this::shulkerBoxData);\n       \n       \n       \n        register(228, shulkerBox()\n                        .translation(\"tile.shulkerBoxCyan.name\")\n                        .build(\"minecraft\", \"cyan_shulker_box\"),\n                this::shulkerBoxData);\n       \n       \n       \n        register(229, shulkerBox()\n                        .translation(\"tile.shulkerBoxPurple.name\")\n                        .build(\"minecraft\", \"purple_shulker_box\"),\n                this::shulkerBoxData);\n       \n       \n       \n        register(230, shulkerBox()\n                        .translation(\"tile.shulkerBoxBlue.name\")\n                        .build(\"minecraft\", \"blue_shulker_box\"),\n                this::shulkerBoxData);\n       \n       \n       \n        register(231, shulkerBox()\n                        .translation(\"tile.shulkerBoxBrown.name\")\n                        .build(\"minecraft\", \"brown_shulker_box\"),\n                this::shulkerBoxData);\n       \n       \n       \n        register(232, shulkerBox()\n                        .translation(\"tile.shulkerBoxGreen.name\")\n                        .build(\"minecraft\", \"green_shulker_box\"),\n                this::shulkerBoxData);\n       \n       \n       \n        register(233, shulkerBox()\n                        .translation(\"tile.shulkerBoxRed.name\")\n                        .build(\"minecraft\", \"red_shulker_box\"),\n                this::shulkerBoxData);\n       \n       \n       \n        register(234, shulkerBox()\n                        .translation(\"tile.shulkerBoxBlack.name\")\n                        .build(\"minecraft\", \"black_shulker_box\"),\n                this::shulkerBoxData);\n       \n       \n       \n        register(63, simpleBuilder()\n                        .trait(LanternIntegerTraits.ROTATION)\n                        .defaultState(state -> state\n                                .withTrait(LanternIntegerTraits.ROTATION, 0).get())\n                        .properties(builder -> builder\n                                .add(hardness(1.0))\n                                .add(blastResistance(5.0)))\n                        .behaviors(pipeline -> pipeline\n                                .add(new SignInteractionBehavior()))\n                        .tileEntityType(() -> TileEntityTypes.SIGN)\n                        .build(\"minecraft\", \"standing_sign\"),\n                blockState -> blockState.getTraitValue(LanternIntegerTraits.ROTATION).get().byteValue());\n        register(68, simpleBuilder()\n                        .trait(LanternEnumTraits.HORIZONTAL_FACING)\n                        .defaultState(state -> state\n                                .withTrait(LanternEnumTraits.HORIZONTAL_FACING, Direction.NORTH).get())\n                        .properties(builder -> builder\n                                .add(hardness(1.0))\n                                .add(blastResistance(5.0)))\n                        .behaviors(pipeline -> pipeline\n                                .add(new SignInteractionBehavior()))\n                        .tileEntityType(() -> TileEntityTypes.SIGN)\n                        .build(\"minecraft\", \"wall_sign\"),\n                this::horizontalFacingData);\n       \n       \n       \n        register(176, simpleBuilder()\n                        .trait(LanternIntegerTraits.ROTATION)\n                        .defaultState(state -> state\n                                .withTrait(LanternIntegerTraits.ROTATION, 0).get())\n                        .properties(builder -> builder\n                                .add(hardness(1.0))\n                                .add(blastResistance(5.0)))\n                        .behaviors(pipeline -> pipeline\n                                .add(new SignInteractionBehavior()))\n                        .tileEntityType(() -> TileEntityTypes.BANNER)\n                        .build(\"minecraft\", \"standing_banner\"),\n                blockState -> blockState.getTraitValue(LanternIntegerTraits.ROTATION).get().byteValue());\n        register(177, simpleBuilder()\n                        .trait(LanternEnumTraits.HORIZONTAL_FACING)\n                        .defaultState(state -> state\n                                .withTrait(LanternEnumTraits.HORIZONTAL_FACING, Direction.NORTH).get())\n                        .properties(builder -> builder\n                                .add(hardness(1.0))\n                                .add(blastResistance(5.0)))\n                        .behaviors(pipeline -> pipeline\n                                .add(new SignInteractionBehavior()))\n                        .tileEntityType(() -> TileEntityTypes.BANNER)\n                        .build(\"minecraft\", \"wall_banner\"),\n                this::horizontalFacingData);\n       \n    }","cleancode":"@override public void registerdefaults() { register(0, builder() .properties(propertyprovidercollections.default_gas) .translation(\"tile.air.name\") .build(\"minecraft\", \"air\")); register(1, simplebuilder() .trait(lanternenumtraits.stone_type) .defaultstate(state -> state.withtrait(lanternenumtraits.stone_type, lanternstonetype.stone).get()) .itemtype(builder -> builder .keysprovider(collection -> collection .register(keys.stone_type, lanternstonetype.stone) ) ) .properties(builder -> builder .add(hardness(1.5)) .add(blastresistance(30.0))) .translation(translationprovider.of(lanternenumtraits.stone_type)) .build(\"minecraft\", \"stone\"), blockstate -> (byte) blockstate.gettraitvalue(lanternenumtraits.stone_type).get().getinternalid()); register(2, simplebuilder() .trait(lanternbooleantraits.snowy) .extendedstateprovider(new snowyextendedblockstateprovider()) .defaultstate(state -> state.withtrait(lanternbooleantraits.snowy, false).get()) .itemtype() .properties(builder -> builder .add(hardness(0.6)) .add(blastresistance(3.0))) .translation(\"tile.grass.name\") .build(\"minecraft\", \"grass\")); register(3, simplebuilder() .traits(lanternenumtraits.dirt_type, lanternbooleantraits.snowy) .defaultstate(state -> state .withtrait(lanternenumtraits.dirt_type, lanterndirttype.dirt).get() .withtrait(lanternbooleantraits.snowy, false).get()) .extendedstateprovider(new snowyextendedblockstateprovider()) .itemtype(builder -> builder .keysprovider(collection -> collection .register(keys.dirt_type, lanterndirttype.dirt) ) ) .properties(builder -> builder .add(hardness(0.5)) .add(blastresistance(2.5))) .translation(translationprovider.of(lanternenumtraits.dirt_type)) .build(\"minecraft\", \"dirt\"), blockstate -> (byte) blockstate.gettraitvalue(lanternenumtraits.dirt_type).get().getinternalid()); register(4, simplebuilder() .itemtype() .properties(builder -> builder .add(hardness(2.0)) .add(blastresistance(3.0))) .translation(\"tile.stonebrick.name\") .build(\"minecraft\", \"cobblestone\")); register(5, simplebuilder() .trait(lanternenumtraits.tree_type) .defaultstate(state -> state.withtrait(lanternenumtraits.tree_type, lanterntreetype.oak).get()) .itemtype(builder -> builder .keysprovider(collection -> collection .register(keys.tree_type, lanterntreetype.oak) ) ) .properties(builder -> builder .add(hardness(2.0)) .add(blastresistance(5.0)) .add(flammableinfo(5, 20))) .translation(translationprovider.of(lanternenumtraits.tree_type, type -> tr(\"tile.planks.\" + type.gettranslationkeybase() + \".name\"))) .build(\"minecraft\", \"planks\"), blockstate -> (byte) blockstate.gettraitvalue(lanternenumtraits.tree_type).get().getinternalid()); register(6, simplebuilder() .traits(lanternenumtraits.tree_type, lanternintegertraits.sapling_growth_stage) .defaultstate(state -> state .withtrait(lanternenumtraits.tree_type, lanterntreetype.oak).get() .withtrait(lanternintegertraits.sapling_growth_stage, 0).get()) .itemtype(builder -> builder .keysprovider(collection -> collection .register(keys.tree_type, lanterntreetype.oak) ) ) .properties(builder -> builder .add(passable) .add(instant_broken)) .translation(translationprovider.of(lanternenumtraits.tree_type, type -> tr(\"tile.sapling.\" + type.gettranslationkeybase() + \".name\"))) .build(\"minecraft\", \"sapling\"), blockstate -> { final int type = blockstate.gettraitvalue(lanternenumtraits.tree_type).get().getinternalid(); final int stage = blockstate.gettraitvalue(lanternintegertraits.sapling_growth_stage).get(); return (byte) (stage << 3 | type); }); register(7, simplebuilder() .itemtype() .properties(builder -> builder .add(propertyprovidercollections.unbreakable)) .translation(\"tile.bedrock.name\") .build(\"minecraft\", \"bedrock\")); register(12, simplebuilder() .trait(lanternenumtraits.sand_type) .defaultstate(state -> state.withtrait(lanternenumtraits.sand_type, lanternsandtype.normal).get()) .itemtype(builder -> builder .keysprovider(collection -> collection .register(keys.sand_type, lanternsandtype.normal) ) ) .properties(builder -> builder .add(hardness(0.5)) .add(blastresistance(2.5))) .translation(translationprovider.of(lanternenumtraits.sand_type)) .build(\"minecraft\", \"sand\"), blockstate -> (byte) blockstate.gettraitvalue(lanternenumtraits.sand_type).get().getinternalid()); register(13, simplebuilder() .itemtype() .properties(builder -> builder .add(hardness(0.6)) .add(blastresistance(3.0))) .translation(\"tile.gravel.name\") .build(\"minecraft\", \"gravel\")); register(14, simplebuilder() .itemtype() .properties(builder -> builder .add(hardness(3.0)) .add(blastresistance(15.0))) .translation(\"tile.oregold.name\") .build(\"minecraft\", \"gold_ore\")); register(15, simplebuilder() .itemtype() .properties(builder -> builder .add(hardness(3.0)) .add(blastresistance(15.0))) .translation(\"tile.oreiron.name\") .build(\"minecraft\", \"iron_ore\")); register(16, simplebuilder() .itemtype() .properties(builder -> builder .add(hardness(3.0)) .add(blastresistance(15.0))) .translation(\"tile.orecoal.name\") .build(\"minecraft\", \"coal_ore\")); register(17, logbuilder(lanternenumtraits.log1_type, lanterntreetype.oak) .build(\"minecraft\", \"log\"), blockstate -> logdata(blockstate, blockstate.gettraitvalue(lanternenumtraits.log1_type).get().getinternalid())); register(18, leavesbuilder(lanternenumtraits.leaves1_type, lanterntreetype.oak) .build(\"minecraft\", \"leaves\"), blockstate -> leavesdata(blockstate, blockstate.gettraitvalue(lanternenumtraits.leaves1_type).get().getinternalid())); register(19, simplebuilder() .trait(lanternbooleantraits.is_wet) .defaultstate(state -> state.withtrait(lanternbooleantraits.is_wet, false).get()) .itemtype(builder -> builder .keysprovider(collection -> collection .register(keys.is_wet, false) ) ) .properties(builder -> builder .add(hardness(0.6)) .add(blastresistance(3.0))) .translation(new spongetranslationprovider()) .build(\"minecraft\", \"sponge\"), blockstate -> (byte) (blockstate.gettraitvalue(lanternbooleantraits.is_wet).get() ? 1 : 0)); register(20, simplebuilder() .itemtype() .properties(builder -> builder .add(hardness(0.3)) .add(blastresistance(1.5))) .translation(\"tile.glass.name\") .build(\"minecraft\", \"glass\")); register(21, simplebuilder() .itemtype() .properties(builder -> builder .add(hardness(3.0)) .add(blastresistance(15.0))) .translation(\"tile.orelapis.name\") .build(\"minecraft\", \"lapis_ore\")); register(22, simplebuilder() .itemtype() .properties(builder -> builder .add(hardness(3.0)) .add(blastresistance(15.0))) .translation(\"tile.blocklapis.name\") .build(\"minecraft\", \"lapis_block\")); register(23, simplebuilder() .traits(lanternenumtraits.facing, lanternbooleantraits.triggered) .defaultstate(state -> state .withtrait(lanternenumtraits.facing, direction.north).get() .withtrait(lanternbooleantraits.triggered, false).get()) .itemtype() .properties(builder -> builder .add(hardness(3.5)) .add(blastresistance(17.5))) .translation(\"tile.dispenser.name\") .behaviors(pipeline -> pipeline .add(new rotationplacementbehavior())) .build(\"minecraft\", \"dispenser\"), blockstate -> { int data = directiondata(blockstate.gettraitvalue(lanternenumtraits.facing).get()); if (blockstate.gettraitvalue(lanternbooleantraits.triggered).get()) { data |= 0x8; } return (byte) data; }); register(24, simplebuilder() .trait(lanternenumtraits.sandstone_type) .defaultstate(state -> state.withtrait(lanternenumtraits.sandstone_type, lanternsandstonetype.default).get()) .itemtype(builder -> builder .keysprovider(collection -> collection .register(keys.sandstone_type, lanternsandstonetype.default) ) ) .properties(builder -> builder .add(hardness(0.8)) .add(blastresistance(4.0))) .translation(translationprovider.of(lanternenumtraits.sandstone_type)) .build(\"minecraft\", \"sandstone\"), blockstate -> (byte) blockstate.gettraitvalue(lanternenumtraits.sandstone_type).get().getinternalid()); register(25, simplebuilder() .itemtype() .properties(builder -> builder .add(hardness(0.8)) .add(blastresistance(4.0))) .translation(\"tile.musicblock.name\") .tileentitytype(() -> tileentitytypes.note) .behaviors(pipeline -> pipeline .add(new noteblockinteractionbehavior())) .build(\"minecraft\", \"noteblock\")); register(26, simplebuilder() .traits(lanternenumtraits.horizontal_facing, lanternenumtraits.bed_part, lanternbooleantraits.occupied) .defaultstate(state -> state .withtrait(lanternenumtraits.horizontal_facing, direction.north).get() .withtrait(lanternenumtraits.bed_part, lanternbedpart.foot).get() .withtrait(lanternbooleantraits.occupied, false).get()) .properties(builder -> builder .add(hardness(0.2)) .add(blastresistance(1.0))) .translation(\"tile.bed.name\") .build(\"minecraft\", \"bed\"), blockstate -> { final direction facing = blockstate.gettraitvalue(lanternenumtraits.horizontal_facing).get(); int type = facing == direction.south ? 0 : facing == direction.west ? 1 : facing == direction.north ? 2 : facing == direction.east ? 3 : -1; checkargument(type != -1); if (blockstate.gettraitvalue(lanternbooleantraits.occupied).get()) { type |= 0x4; } if (blockstate.gettraitvalue(lanternenumtraits.bed_part).get() == lanternbedpart.head) { type |= 0x8; } return (byte) type; }); register(27, simplebuilder() .traits(lanternenumtraits.straight_rail_direction, lanternbooleantraits.powered) .defaultstate(state -> state .withtrait(lanternenumtraits.straight_rail_direction, lanternraildirection.north_south).get() .withtrait(lanternbooleantraits.powered, false).get()) .itemtype() .selectionbox(boundingboxes::rail) .properties(builder -> builder .add(passable) .add(hardness(0.7)) .add(blastresistance(3.5))) .translation(\"tile.goldenrail.name\") .build(\"minecraft\", \"golden_rail\"), blockstate -> { int type = blockstate.gettraitvalue(lanternenumtraits.straight_rail_direction).get().getinternalid(); if (blockstate.gettraitvalue(lanternbooleantraits.powered).get()) { type |= 0x8; } return (byte) type; }); register(28, simplebuilder() .traits(lanternenumtraits.straight_rail_direction, lanternbooleantraits.powered) .defaultstate(state -> state .withtrait(lanternenumtraits.straight_rail_direction, lanternraildirection.north_south).get() .withtrait(lanternbooleantraits.powered, false).get()) .itemtype() .selectionbox(boundingboxes::rail) .properties(builder -> builder .add(passable) .add(hardness(0.7)) .add(blastresistance(3.5))) .translation(\"tile.detectorrail.name\") .build(\"minecraft\", \"detector_rail\"), blockstate -> { int type = blockstate.gettraitvalue(lanternenumtraits.straight_rail_direction).get().getinternalid(); if (blockstate.gettraitvalue(lanternbooleantraits.powered).get()) { type |= 0x8; } return (byte) type; }); register(30, simplebuilder() .itemtype() .properties(builder -> builder .add(passable) .add(hardness(4.0)) .add(blastresistance(20.0))) .translation(\"tile.web.name\") .build(\"minecraft\", \"web\")); register(31, simplebuilder() .traits(lanternenumtraits.shrub_type) .defaultstate(state -> state .withtrait(lanternenumtraits.shrub_type, lanternshrubtype.dead_bush).get()) .itemtype(builder -> builder .keysprovider(collection -> collection .register(keys.shrub_type, lanternshrubtype.dead_bush))) .selectionbox(boundingboxes.bush()) .properties(builder -> builder .add(instant_broken) .add(passable) .add(replaceable(true))) .translation(\"tile.tallgrass.name\") .build(\"minecraft\", \"tallgrass\"), blockstate -> (byte) blockstate.gettraitvalue(lanternenumtraits.shrub_type).get().getinternalid()); register(32, simplebuilder() .properties(builder -> builder .add(instant_broken) .add(passable) .add(replaceable(true))) .selectionbox(boundingboxes.bush()) .itemtype() .translation(\"tile.deadbush.name\") .build(\"minecraft\", \"deadbush\")); register(35, dyedbuilder(\"tile.wool.%s.name\") .properties(builder -> builder .add(hardness(0.8)) .add(blastresistance(4.0))) .build(\"minecraft\", \"wool\"), this::dyeddata); register(37, simplebuilder() .traits(lanternenumtraits.yellow_flower_type) .defaultstate(state -> state .withtrait(lanternenumtraits.yellow_flower_type, lanternplanttype.dandelion).get()) .itemtype(builder -> builder .keysprovider(collection -> collection .register(keys.plant_type, lanternplanttype.dandelion))) .selectionbox(boundingboxes.bush()) .properties(builder -> builder .add(instant_broken) .add(passable)) .translation(translationprovider.of(lanternenumtraits.yellow_flower_type)) .build(\"minecraft\", \"yellow_flower\"), blockstate -> (byte) blockstate.gettraitvalue(lanternenumtraits.yellow_flower_type).get().getinternalid()); register(38, simplebuilder() .traits(lanternenumtraits.red_flower_type) .defaultstate(state -> state .withtrait(lanternenumtraits.red_flower_type, lanternplanttype.poppy).get()) .itemtype(builder -> builder .keysprovider(collection -> collection .register(keys.plant_type, lanternplanttype.poppy))) .selectionbox(boundingboxes.bush()) .properties(builder -> builder .add(instant_broken) .add(passable)) .translation(translationprovider.of(lanternenumtraits.red_flower_type)) .build(\"minecraft\", \"red_flower\"), blockstate -> (byte) blockstate.gettraitvalue(lanternenumtraits.red_flower_type).get().getinternalid()); register(39, simplebuilder() .selectionbox(boundingboxes.bush()) .properties(builder -> builder .add(instant_broken) .add(passable) .add(lightemission(1))) .translation(\"tile.mushroom.name\") .build(\"minecraft\", \"brown_mushroom\")); register(40, simplebuilder() .selectionbox(boundingboxes.bush()) .properties(builder -> builder .add(instant_broken) .add(passable)) .translation(\"tile.mushroom.name\") .build(\"minecraft\", \"red_mushroom\")); register(41, simplebuilder() .itemtype() .properties(builder -> builder .add(hardness(3.0)) .add(blastresistance(10.0))) .translation(\"tile.blockgold.name\") .build(\"minecraft\", \"gold_block\")); register(42, simplebuilder() .itemtype() .properties(builder -> builder .add(hardness(5.0)) .add(blastresistance(10.0))) .translation(\"tile.blockiron.name\") .build(\"minecraft\", \"iron_block\")); register(43, doublestoneslab(lanternenumtraits.stone_slab1_type, lanternslabtype.stone) .translation(\"tile.stoneslab.name\") .build(\"minecraft\", \"double_stone_slab\"), blockstate -> doublestoneslabdata(blockstate, blockstate.gettraitvalue(lanternenumtraits.stone_slab1_type).get().getinternalid())); register(44, stoneslab(lanternenumtraits.stone_slab1_type, lanternslabtype.stone, () -> blocktypes.stone_slab, () -> blocktypes.double_stone_slab) .translation(\"tile.stoneslab.name\") .collisionbox(boundingboxes::slab) .build(\"minecraft\", \"stone_slab\"), blockstate -> stoneslabdata(blockstate, blockstate.gettraitvalue(lanternenumtraits.stone_slab1_type).get().getinternalid())); register(45, simplebuilder() .itemtype() .properties(builder -> builder .add(hardness(2.0)) .add(blastresistance(10.0))) .translation(\"tile.brick.name\") .build(\"minecraft\", \"brick_block\")); register(46, simplebuilder() .trait(lanternbooleantraits.explode) .defaultstate(state -> state .withtrait(lanternbooleantraits.explode, false).get()) .itemtype() .properties(builder -> builder .add(instant_broken)) .translation(\"tile.tnt.name\") .build(\"minecraft\", \"tnt\"), blockstate -> (byte) (blockstate.gettraitvalue(lanternbooleantraits.explode).get() ? 1 : 0)); register(47, simplebuilder() .itemtype() .properties(builder -> builder .add(hardness(1.5)) .add(blastresistance(7.5))) .translation(\"tile.bookshelf.name\") .build(\"minecraft\", \"bookshelf\")); register(48, simplebuilder() .itemtype() .properties(builder -> builder .add(hardness(2.0)) .add(blastresistance(10.0))) .translation(\"tile.stonemoss.name\") .build(\"minecraft\", \"mossy_cobblestone\")); register(49, simplebuilder() .itemtype() .properties(builder -> builder .add(hardness(50.0)) .add(blastresistance(2000.0))) .translation(\"tile.obsidian.name\") .build(\"minecraft\", \"obsidian\")); register(50, builder() .trait(lanternenumtraits.torch_facing) .defaultstate(state -> state .withtrait(lanternenumtraits.torch_facing, direction.up).get()) .itemtype() .properties(builder -> builder .add(passable) .add(instant_broken)) .translation(\"tile.torch.name\") .selectionbox(boundingboxes::torch) .behaviors(pipeline -> pipeline .add(new blocksnapshotproviderplacebehavior()) .add(new torchplacementbehavior()) .add(new simplebreakbehavior())) .build(\"minecraft\", \"torch\"), blockstate -> { final direction direction = blockstate.gettraitvalue(lanternenumtraits.torch_facing).get(); switch (direction) { case east: return (byte) 1; case west: return (byte) 2; case south: return (byte) 3; case north: return (byte) 4; case up: return (byte) 5; default: throw new illegalargumentexception(); } }); register(51, simplebuilder() .properties(builder -> builder .add(passable) .add(instant_broken) .add(lightemission(15))) .collisionbox(boundingboxes.null) .translation(\"tile.fire.name\") .build(\"minecraft\", \"fire\")); register(52, simplebuilder() .properties(builder -> builder .add(hardness(5.0)) .add(blastresistance(25.0))) .translation(\"tile.mobspawner.name\") .build(\"minecraft\", \"mob_spawner\")); register(54, chestbuilder() .translation(\"tile.chest.name\") .build(\"minecraft\", \"chest\"), this::horizontalfacingdata); register(55, simplebuilder() .traits(lanternintegertraits.power) .selectionbox(new aabb(0, 0, 0, 1.0, 0.0625, 1.0)) .properties(builder -> builder .add(passable) .add(instant_broken)) .defaultstate(state -> state .withtrait(lanternintegertraits.power, 0).get()) .translation(\"tile.redstonedust.name\") .build(\"minecraft\", \"redstone_wire\"), state -> state.get(keys.power).get().bytevalue()); register(56, simplebuilder() .itemtype() .properties(builder -> builder .add(hardness(3.0)) .add(blastresistance(5.0))) .translation(\"tile.orediamond.name\") .build(\"minecraft\", \"diamond_ore\")); register(57, simplebuilder() .itemtype() .properties(builder -> builder .add(hardness(5.0)) .add(blastresistance(10.0))) .translation(\"tile.blockdiamond.name\") .build(\"minecraft\", \"diamond_block\")); register(58, simplebuilder() .itemtype() .properties(builder -> builder .add(hardness(2.5)) .add(blastresistance(12.5))) .translation(\"tile.workbench.name\") .behaviors(pipeline -> pipeline .add(new craftingtableinteractionbehavior())) .build(\"minecraft\", \"crafting_table\")); register(60, simplebuilder() .collisionbox(boundingboxes.farmland()) .trait(lanternintegertraits.moisture) .properties(builder -> builder .add(hardness(0.6)) .add(blastresistance(3.0))) .defaultstate(state -> state.withtrait(lanternintegertraits.moisture, 0).get()) .translation(\"tile.farmland.name\") .build(\"minecraft\", \"farmland\"), state -> state.gettraitvalue(lanternintegertraits.moisture).get().bytevalue()); register(61, furnacebuilder() .itemtype() .translation(\"tile.furnace.name\") .build(\"minecraft\", \"furnace\"), this::directiondata); register(62, furnacebuilder() .properties(builder -> builder .add(lightemission(13))) .translation(\"tile.furnace.name\") .build(\"minecraft\", \"lit_furnace\"), this::directiondata); register(70, pressureplatebuilder() .translation(\"tile.pressureplatestone.name\") .build(\"minecraft\", \"stone_pressure_plate\"), this::pressureplatedata); register(72, pressureplatebuilder() .translation(\"tile.pressureplatewood.name\") .build(\"minecraft\", \"wooden_pressure_plate\"), this::pressureplatedata); register(84, simplebuilder() .itemtype() .traits(lanternbooleantraits.has_record) .defaultstate(state -> state .withtrait(lanternbooleantraits.has_record, false).get()) .properties(builder -> builder .add(hardness(2.0)) .add(blastresistance(10.0))) .tileentitytype(() -> tileentitytypes.jukebox) .translation(\"tile.jukebox.name\") .behaviors(pipeline -> pipeline .add(new jukeboxinteractionbehavior())) .build(\"minecraft\", \"jukebox\"), state -> (byte) (state.gettraitvalue(lanternbooleantraits.has_record).get() ? 1 : 0)); register(86, pumpkinbuilder() .itemtype(builder -> builder .properties(properties -> properties .add(equipmenttype(equipmenttypes.headwear)))) .translation(\"tile.pumpkin.name\") .build(\"minecraft\", \"pumpkin\"), this::horizontaldirectiondata); register(87, simplebuilder() .itemtype() .properties(builder -> builder .add(hardness(0.4)) .add(blastresistance(2.0))) .translation(\"tile.hellrock.name\") .build(\"minecraft\", \"netherrack\")); register(91, pumpkinbuilder() .properties(builder -> builder .add(lightemission(15))) .translation(\"tile.litpumpkin.name\") .build(\"minecraft\", \"lit_pumpkin\"), this::horizontaldirectiondata); register(95, dyedbuilder(\"tile.stainedglass.%s.name\") .properties(builder -> builder .add(hardness(0.3)) .add(blastresistance(1.5))) .build(\"minecraft\", \"stained_glass\"), this::dyeddata); register(101, simplebuilder() .itemtype() .properties(builder -> builder .add(hardness(5.0)) .add(blastresistance(10.0))) .translation(\"tile.fenceiron.name\") .build(\"minecraft\", \"iron_bars\")); register(121, simplebuilder() .itemtype() .properties(builder -> builder .add(hardness(3.0)) .add(blastresistance(15.0))) .translation(\"tile.whitestone.name\") .build(\"minecraft\", \"end_stone\")); register(125, simplebuilder() .traits(lanternenumtraits.tree_type) .defaultstate(state -> state .withtrait(lanternenumtraits.tree_type, lanterntreetype.oak).get()) .translation(translationprovider.of(lanternenumtraits.tree_type, type -> tr(\"tile.woodslab.\" + type.gettranslationkeybase() + \".name\"))) .itemtype(builder -> builder .keysprovider(collection -> collection .register(keys.tree_type, lanterntreetype.oak) ) ) .properties(builder -> builder .add(hardness(2.0)) .add(blastresistance(5.0))) .build(\"minecraft\", \"double_wooden_slab\"), blockstate -> (byte) blockstate.gettraitvalue(lanternenumtraits.tree_type).get().getinternalid()); register(126, simplebuilder() .traits(lanternenumtraits.portion_type, lanternenumtraits.tree_type) .defaultstate(state -> state .withtrait(lanternenumtraits.portion_type, lanternportiontype.bottom).get() .withtrait(lanternenumtraits.tree_type, lanterntreetype.oak).get()) .translation(translationprovider.of(lanternenumtraits.tree_type, type -> tr(\"tile.woodslab.\" + type.gettranslationkeybase() + \".name\"))) .itemtype(builder -> builder .behaviors(pipeline -> pipeline .add(new slabiteminteractionbehavior<>(lanternenumtraits.tree_type, () -> blocktypes.wooden_slab, () -> blocktypes.double_wooden_slab)) .add(new placementcollisiondetectionbehavior())) .keysprovider(collection -> collection .register(keys.tree_type, lanterntreetype.oak) ) ) .collisionbox(boundingboxes::slab) .properties(builder -> builder .add(hardness(2.0)) .add(blastresistance(5.0))) .build(\"minecraft\", \"wooden_slab\"), blockstate -> { final int type = blockstate.gettraitvalue(lanternenumtraits.tree_type).get().getinternalid(); final int portion = (byte) blockstate.gettraitvalue(lanternenumtraits.portion_type).get().getinternalid(); return (byte) (portion << 3 | type); }); register(130, simplebuilder() .trait(lanternenumtraits.horizontal_facing) .defaultstate(state -> state.withtrait(lanternenumtraits.horizontal_facing, direction.north).get()) .itemtype() .tileentitytype(() -> tileentitytypes.ender_chest) .properties(builder -> builder .add(hardness(22.5)) .add(blastresistance(3000.0)) .add(lightemission(7))) .translation(\"tile.enderchest.name\") .collisionbox(boundingboxes.chest()) .behaviors(pipeline -> pipeline .add(new horizontalrotationplacementbehavior()) .add(new enderchestinteractionbehavior())) .build(\"minecraft\", \"ender_chest\"), this::horizontalfacingdata); register(146, chestbuilder() .translation(\"tile.chesttrap.name\") .build(\"minecraft\", \"trapped_chest\"), this::horizontalfacingdata); register(147, weightedpressureplatebuilder() .translation(\"tile.weightedplate_light.name\") .build(\"minecraft\", \"light_weighted_pressure_plate\"), this::weightedpressureplatedata); register(148, weightedpressureplatebuilder() .translation(\"tile.weightedplate_heavy.name\") .build(\"minecraft\", \"heavy_weighted_pressure_plate\"), this::weightedpressureplatedata); register(152, simplebuilder() .itemtype() .properties(builder -> builder .add(hardness(5.0)) .add(blastresistance(30.0))) .translation(\"tile.blockredstone.name\") .build(\"minecraft\", \"redstone_block\")); register(153, simplebuilder() .itemtype() .properties(builder -> builder .add(hardness(3.0)) .add(blastresistance(15.0))) .translation(\"tile.netherquartz.name\") .build(\"minecraft\", \"quartz_ore\")); register(154, simplebuilder() .traits(lanternenumtraits.hopper_facing, lanternbooleantraits.enabled) .defaultstate(state -> state .withtrait(lanternenumtraits.hopper_facing, direction.down).get() .withtrait(lanternbooleantraits.enabled, false).get()) .itemtype() .properties(builder -> builder .add(hardness(3.0)) .add(blastresistance(8.0))) .translation(\"tile.hopper.name\") .behaviors(pipeline -> pipeline .add(new hopperplacementbehavior())) .build(\"minecraft\", \"hopper\"), blockstate -> { int data = directiondata(blockstate.gettraitvalue(lanternenumtraits.hopper_facing).get()); if (!blockstate.gettraitvalue(lanternbooleantraits.enabled).get()) { data |= 0x8; } return (byte) data; }); register(155, simplebuilder() .trait(lanternenumtraits.quartz_type) .defaultstate(state -> state .withtrait(lanternenumtraits.quartz_type, lanternquartztype.default).get()) .itemtype(builder -> builder .keysprovider(collection -> collection .register(keys.quartz_type, lanternquartztype.default) ) ) .properties(builder -> builder .add(hardness(0.8)) .add(blastresistance(2.4))) .translation(translationprovider.of(lanternenumtraits.quartz_type)) .behaviors(pipeline -> pipeline .add(new quartzlinesrotationplacementbehavior())) .build(\"minecraft\", \"quartz_block\"), blockstate -> (byte) blockstate.gettraitvalue(lanternenumtraits.quartz_type).get().getinternalid()); register(158, simplebuilder() .traits(lanternenumtraits.facing, lanternbooleantraits.triggered) .defaultstate(state -> state .withtrait(lanternenumtraits.facing, direction.north).get() .withtrait(lanternbooleantraits.triggered, false).get()) .itemtype() .properties(builder -> builder .add(hardness(3.5)) .add(blastresistance(17.5))) .translation(\"tile.dropper.name\") .behaviors(pipeline -> pipeline .add(new rotationplacementbehavior())) .build(\"minecraft\", \"dropper\"), blockstate -> { int data = directiondata(blockstate.gettraitvalue(lanternenumtraits.facing).get()); if (blockstate.gettraitvalue(lanternbooleantraits.triggered).get()) { data |= 0x8; } return (byte) data; }); register(159, dyedbuilder(\"tile.clayhardenedstained.%s.name\") .properties(builder -> builder .add(hardness(1.25)) .add(blastresistance(7.0))) .build(\"minecraft\", \"stained_hardened_clay\"), this::dyeddata); register(160, dyedbuilder(\"tile.thinstainedglass.%s.name\") .properties(builder -> builder .add(hardness(0.3)) .add(blastresistance(1.5))) .build(\"minecraft\", \"stained_glass_pane\"), this::dyeddata); register(161, leavesbuilder(lanternenumtraits.leaves2_type, lanterntreetype.acacia) .build(\"minecraft\", \"leaves2\"), blockstate -> leavesdata(blockstate, blockstate.gettraitvalue(lanternenumtraits.leaves2_type).get().getinternalid() - 4)); register(162, logbuilder(lanternenumtraits.log2_type, lanterntreetype.acacia) .build(\"minecraft\", \"log2\"), blockstate -> logdata(blockstate, blockstate.gettraitvalue(lanternenumtraits.log2_type).get().getinternalid() - 4)); register(166, simplebuilder() .itemtype() .properties(builder -> builder .add(propertyprovidercollections.unbreakable)) .translation(\"tile.barrier.name\") .build(\"minecraft\", \"barrier\")); register(171, dyedbuilder(\"tile.carpet.%s.name\") .properties(builder -> builder .add(hardness(0.1)) .add(blastresistance(0.5)) .add(solidmaterial(false))) .collisionbox(boundingboxes.carpet()) .build(\"minecraft\", \"carpet\"), this::dyeddata); register(179, simplebuilder() .trait(lanternenumtraits.sandstone_type) .defaultstate(state -> state.withtrait(lanternenumtraits.sandstone_type, lanternsandstonetype.default).get()) .itemtype(builder -> builder .keysprovider(collection -> collection .register(keys.sandstone_type, lanternsandstonetype.default) ) ) .properties(builder -> builder .add(hardness(0.8)) .add(blastresistance(4.0))) .translation(translationprovider.of(lanternenumtraits.sandstone_type)) .build(\"minecraft\", \"red_sandstone\"), blockstate -> (byte) blockstate.gettraitvalue(lanternenumtraits.sandstone_type).get().getinternalid()); register(181, doublestoneslab(lanternenumtraits.stone_slab2_type, lanternslabtype.red_sand) .translation(\"tile.stoneslab2.name\") .build(\"minecraft\", \"double_stone_slab2\"), blockstate -> doublestoneslabdata(blockstate, blockstate.gettraitvalue(lanternenumtraits.stone_slab2_type).get().getinternalid() - 8)); register(182, stoneslab(lanternenumtraits.stone_slab2_type, lanternslabtype.red_sand, () -> blocktypes.stone_slab2, () -> blocktypes.double_stone_slab2) .translation(\"tile.stoneslab2.name\") .collisionbox(boundingboxes::slab) .build(\"minecraft\", \"stone_slab2\"), blockstate -> stoneslabdata(blockstate, blockstate.gettraitvalue(lanternenumtraits.stone_slab2_type).get().getinternalid() - 8)); register(198, simplebuilder() .itemtype() .properties(builder -> builder .add(hardness(0.0)) .add(blastresistance(0.0)) .add(lightemission(14))) .translation(\"tile.endrod.name\") .build(\"minecraft\", \"end_rod\")); register(219, shulkerbox() .translation(\"tile.shulkerboxwhite.name\") .build(\"minecraft\", \"white_shulker_box\"), this::shulkerboxdata); register(220, shulkerbox() .translation(\"tile.shulkerboxorange.name\") .build(\"minecraft\", \"orange_shulker_box\"), this::shulkerboxdata); register(221, shulkerbox() .translation(\"tile.shulkerboxmagenta.name\") .build(\"minecraft\", \"magenta_shulker_box\"), this::shulkerboxdata); register(222, shulkerbox() .translation(\"tile.shulkerboxlightblue.name\") .build(\"minecraft\", \"light_blue_shulker_box\"), this::shulkerboxdata); register(223, shulkerbox() .translation(\"tile.shulkerboxyellow.name\") .build(\"minecraft\", \"yellow_shulker_box\"), this::shulkerboxdata); register(224, shulkerbox() .translation(\"tile.shulkerboxlime.name\") .build(\"minecraft\", \"lime_shulker_box\"), this::shulkerboxdata); register(225, shulkerbox() .translation(\"tile.shulkerboxpink.name\") .build(\"minecraft\", \"pink_shulker_box\"), this::shulkerboxdata); register(226, shulkerbox() .translation(\"tile.shulkerboxgray.name\") .build(\"minecraft\", \"gray_shulker_box\"), this::shulkerboxdata); register(227, shulkerbox() .translation(\"tile.shulkerboxsilver.name\") .build(\"minecraft\", \"silver_shulker_box\"), this::shulkerboxdata); register(228, shulkerbox() .translation(\"tile.shulkerboxcyan.name\") .build(\"minecraft\", \"cyan_shulker_box\"), this::shulkerboxdata); register(229, shulkerbox() .translation(\"tile.shulkerboxpurple.name\") .build(\"minecraft\", \"purple_shulker_box\"), this::shulkerboxdata); register(230, shulkerbox() .translation(\"tile.shulkerboxblue.name\") .build(\"minecraft\", \"blue_shulker_box\"), this::shulkerboxdata); register(231, shulkerbox() .translation(\"tile.shulkerboxbrown.name\") .build(\"minecraft\", \"brown_shulker_box\"), this::shulkerboxdata); register(232, shulkerbox() .translation(\"tile.shulkerboxgreen.name\") .build(\"minecraft\", \"green_shulker_box\"), this::shulkerboxdata); register(233, shulkerbox() .translation(\"tile.shulkerboxred.name\") .build(\"minecraft\", \"red_shulker_box\"), this::shulkerboxdata); register(234, shulkerbox() .translation(\"tile.shulkerboxblack.name\") .build(\"minecraft\", \"black_shulker_box\"), this::shulkerboxdata); register(63, simplebuilder() .trait(lanternintegertraits.rotation) .defaultstate(state -> state .withtrait(lanternintegertraits.rotation, 0).get()) .properties(builder -> builder .add(hardness(1.0)) .add(blastresistance(5.0))) .behaviors(pipeline -> pipeline .add(new signinteractionbehavior())) .tileentitytype(() -> tileentitytypes.sign) .build(\"minecraft\", \"standing_sign\"), blockstate -> blockstate.gettraitvalue(lanternintegertraits.rotation).get().bytevalue()); register(68, simplebuilder() .trait(lanternenumtraits.horizontal_facing) .defaultstate(state -> state .withtrait(lanternenumtraits.horizontal_facing, direction.north).get()) .properties(builder -> builder .add(hardness(1.0)) .add(blastresistance(5.0))) .behaviors(pipeline -> pipeline .add(new signinteractionbehavior())) .tileentitytype(() -> tileentitytypes.sign) .build(\"minecraft\", \"wall_sign\"), this::horizontalfacingdata); register(176, simplebuilder() .trait(lanternintegertraits.rotation) .defaultstate(state -> state .withtrait(lanternintegertraits.rotation, 0).get()) .properties(builder -> builder .add(hardness(1.0)) .add(blastresistance(5.0))) .behaviors(pipeline -> pipeline .add(new signinteractionbehavior())) .tileentitytype(() -> tileentitytypes.banner) .build(\"minecraft\", \"standing_banner\"), blockstate -> blockstate.gettraitvalue(lanternintegertraits.rotation).get().bytevalue()); register(177, simplebuilder() .trait(lanternenumtraits.horizontal_facing) .defaultstate(state -> state .withtrait(lanternenumtraits.horizontal_facing, direction.north).get()) .properties(builder -> builder .add(hardness(1.0)) .add(blastresistance(5.0))) .behaviors(pipeline -> pipeline .add(new signinteractionbehavior())) .tileentitytype(() -> tileentitytypes.banner) .build(\"minecraft\", \"wall_banner\"), this::horizontalfacingdata); }","repo":"shisheng-1\/Lantern","label":[1,1,0,0]}

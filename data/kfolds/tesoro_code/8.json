{"id":161,"original_code":"protected final void addSequences(List<String> seqNames, Long seqDefaultValue, boolean ignoreFailure) throws SQLException{\n    \/\/ ToDo: rewrite function to use one SQL call per select\/insert for all items\n    for (String seqName: seqNames){\n      addSequence(seqName, seqDefaultValue, ignoreFailure);\n    }\n  }","code":"protected final void addSequences(List<String> seqNames, Long seqDefaultValue, boolean ignoreFailure) throws SQLException{\n   \n    for (String seqName: seqNames){\n      addSequence(seqName, seqDefaultValue, ignoreFailure);\n    }\n  }","cleancode":"protected final void addsequences(list<string> seqnames, long seqdefaultvalue, boolean ignorefailure) throws sqlexception{ for (string seqname: seqnames){ addsequence(seqname, seqdefaultvalue, ignorefailure); } }","comment":"\/** * add several new sequences to <code>ambarisequencestable<\/code>. * @param seqnames list of sequences to be inserted * @param seqdefaultvalue initial value for the sequence * @param ignorefailure true to ignore insert sql errors * @throws sqlexception * *\/\n\/\/ todo: rewrite function to use one sql call per select\/insert for all items","repo":"shavi71\/ambari","code_context_2":"protected final void addSequences(List<String> seqNames, Long seqDefaultValue, boolean ignoreFailure) throws SQLException{\n\/\/ ToDo: rewrite function to use one SQL call per select\/insert for all items\nfor (String seqName: seqNames){\naddSequence(seqName, seqDefaultValue, ignoreFailure);\n}\n}\n\nprotected final void addSequences(List<String> seqNames, Long seqDefaultValue, boolean ignoreFailure) throws SQLException{\n\/\/ ToDo: rewrite function to use one SQL call per select\/insert for all items\nfor (String seqName: seqNames){\naddSequence(seqName, seqDefaultValue, ignoreFailure);","code_context_10":"protected final void addSequences(List<String> seqNames, Long seqDefaultValue, boolean ignoreFailure) throws SQLException{\n\/\/ ToDo: rewrite function to use one SQL call per select\/insert for all items\nfor (String seqName: seqNames){\naddSequence(seqName, seqDefaultValue, ignoreFailure);\n}\n}\n\nprotected final void addSequences(List<String> seqNames, Long seqDefaultValue, boolean ignoreFailure) throws SQLException{\n\/\/ ToDo: rewrite function to use one SQL call per select\/insert for all items\nfor (String seqName: seqNames){\naddSequence(seqName, seqDefaultValue, ignoreFailure);\n}\n}","code_context_20":"protected final void addSequences(List<String> seqNames, Long seqDefaultValue, boolean ignoreFailure) throws SQLException{\n\/\/ ToDo: rewrite function to use one SQL call per select\/insert for all items\nfor (String seqName: seqNames){\naddSequence(seqName, seqDefaultValue, ignoreFailure);\n}\n}\n\nprotected final void addSequences(List<String> seqNames, Long seqDefaultValue, boolean ignoreFailure) throws SQLException{\n\/\/ ToDo: rewrite function to use one SQL call per select\/insert for all items\nfor (String seqName: seqNames){\naddSequence(seqName, seqDefaultValue, ignoreFailure);\n}\n}","label":[1,0,0,0]}
{"id":24756,"original_code":"public static void addChatMessageFixed(ICommandSender sender, IChatComponent message) {\n        if (sender == null || message == null) return;\n        if (sender instanceof EntityPlayerMP) {\n            if (((EntityPlayerMP)sender).playerNetServerHandler != null) {\n                sender.addChatMessage(message);\n            } else {\n                \/\/TODO Find a way to re-send the message.\n            }\n        } else {\n            sender.addChatMessage(message);\n        }\n    }","code":"public static void addChatMessageFixed(ICommandSender sender, IChatComponent message) {\n        if (sender == null || message == null) return;\n        if (sender instanceof EntityPlayerMP) {\n            if (((EntityPlayerMP)sender).playerNetServerHandler != null) {\n                sender.addChatMessage(message);\n            } else {\n               \n            }\n        } else {\n            sender.addChatMessage(message);\n        }\n    }","cleancode":"public static void addchatmessagefixed(icommandsender sender, ichatcomponent message) { if (sender == null || message == null) return; if (sender instanceof entityplayermp) { if (((entityplayermp)sender).playernetserverhandler != null) { sender.addchatmessage(message); } else { } } else { sender.addchatmessage(message); } }","comment":"\/\/todo find a way to re-send the message.","repo":"repo-alt\/MyEssentials-Core","code_context_2":"sender.addChatMessage(message);\n} else {\n\/\/TODO Find a way to re-send the message.\n}\n} else {","code_context_10":"public static void addChatMessageFixed(ICommandSender sender, IChatComponent message) {\nif (sender == null || message == null) return;\nif (sender instanceof EntityPlayerMP) {\nif (((EntityPlayerMP)sender).playerNetServerHandler != null) {\nsender.addChatMessage(message);\n} else {\n\/\/TODO Find a way to re-send the message.\n}\n} else {\nsender.addChatMessage(message);\n}\n}","code_context_20":"public static void addChatMessageFixed(ICommandSender sender, IChatComponent message) {\nif (sender == null || message == null) return;\nif (sender instanceof EntityPlayerMP) {\nif (((EntityPlayerMP)sender).playerNetServerHandler != null) {\nsender.addChatMessage(message);\n} else {\n\/\/TODO Find a way to re-send the message.\n}\n} else {\nsender.addChatMessage(message);\n}\n}","label":[0,1,0,0]}
{"id":33024,"original_code":"public Node addNode(String s) throws ItemExistsException, PathNotFoundException, VersionException, ConstraintViolationException, LockException, RepositoryException {\n        return null;\n    }","code":"public Node addNode(String s) throws ItemExistsException, PathNotFoundException, VersionException, ConstraintViolationException, LockException, RepositoryException {\n        return null;\n    }","cleancode":"public node addnode(string s) throws itemexistsexception, pathnotfoundexception, versionexception, constraintviolationexception, lockexception, repositoryexception { return null; }","comment":"\/\/ todo all following node inherited methods will be apply under full versioning","repo":"sohaniwso2\/carbon-registry-1","code_context_2":"public Node addNode(String s) throws ItemExistsException, PathNotFoundException, VersionException, ConstraintViolationException, LockException, RepositoryException {\nreturn null;\n}","code_context_10":"public Node addNode(String s) throws ItemExistsException, PathNotFoundException, VersionException, ConstraintViolationException, LockException, RepositoryException {\nreturn null;\n}","code_context_20":"public Node addNode(String s) throws ItemExistsException, PathNotFoundException, VersionException, ConstraintViolationException, LockException, RepositoryException {\nreturn null;\n}","label":[0,1,0,0]}
{"id":33065,"original_code":"private List<DataPoint> getIntersectedSetUsingQuadTree(List<DataPoint> dataset, Rectangle rect) {\n\t\tthrow new UnsupportedOperationException(\"Not Yet Implemented\");\n\t}","code":"private List<DataPoint> getIntersectedSetUsingQuadTree(List<DataPoint> dataset, Rectangle rect) {\n\t\tthrow new UnsupportedOperationException(\"Not Yet Implemented\");\n\t}","cleancode":"private list<datapoint> getintersectedsetusingquadtree(list<datapoint> dataset, rectangle rect) { throw new unsupportedoperationexception(\"not yet implemented\"); }","comment":"\/** * todo implement me *\/","repo":"smozely\/QuadTree","code_context_2":"private List<DataPoint> getIntersectedSetUsingQuadTree(List<DataPoint> dataset, Rectangle rect) {\nthrow new UnsupportedOperationException(\"Not Yet Implemented\");\n}","code_context_10":"private List<DataPoint> getIntersectedSetUsingQuadTree(List<DataPoint> dataset, Rectangle rect) {\nthrow new UnsupportedOperationException(\"Not Yet Implemented\");\n}","code_context_20":"private List<DataPoint> getIntersectedSetUsingQuadTree(List<DataPoint> dataset, Rectangle rect) {\nthrow new UnsupportedOperationException(\"Not Yet Implemented\");\n}","label":[0,1,0,0]}
{"id":8490,"original_code":"private static String getSampleWithLineBreak(){\n        StringBuilder sb = new StringBuilder();\n        sb.append(\"[\");\n        for(int i = 1; i < 4; i++){\n            sb.append(getTypicalElement(i));\n            sb.append(\",\");\n        }\n        sb.append(\"{\\\"id\\\" : 4,\" +\n                \"\\\"author\\\" : \\\"With line\\\\n break\\\",\" + \/\/FIXME this line break is doubled - is this correct??\n                \"\\\"title\\\" : \\\"Book title 4\\\",\" +\n                \"\\\"publish_date\\\" : \\\"2010-05-26\\\"\" +\n                \"},\");\n        sb.append(getTypicalElement(5));\n        sb.append(\",\");\n        sb.append(getTypicalElement(6));\n        sb.append(\"]\");\n        return sb.toString();\n    }","code":"private static String getSampleWithLineBreak(){\n        StringBuilder sb = new StringBuilder();\n        sb.append(\"[\");\n        for(int i = 1; i < 4; i++){\n            sb.append(getTypicalElement(i));\n            sb.append(\",\");\n        }\n        sb.append(\"{\\\"id\\\" : 4,\" +\n                \"\\\"author\\\" : \\\"With line\\\\n break\\\",\" +\n                \"\\\"title\\\" : \\\"Book title 4\\\",\" +\n                \"\\\"publish_date\\\" : \\\"2010-05-26\\\"\" +\n                \"},\");\n        sb.append(getTypicalElement(5));\n        sb.append(\",\");\n        sb.append(getTypicalElement(6));\n        sb.append(\"]\");\n        return sb.toString();\n    }","cleancode":"private static string getsamplewithlinebreak(){ stringbuilder sb = new stringbuilder(); sb.append(\"[\"); for(int i = 1; i < 4; i++){ sb.append(gettypicalelement(i)); sb.append(\",\"); } sb.append(\"{\\\"id\\\" : 4,\" + \"\\\"author\\\" : \\\"with line\\\\n break\\\",\" + \"\\\"title\\\" : \\\"book title 4\\\",\" + \"\\\"publish_date\\\" : \\\"2010-05-26\\\"\" + \"},\"); sb.append(gettypicalelement(5)); sb.append(\",\"); sb.append(gettypicalelement(6)); sb.append(\"]\"); return sb.tostring(); }","comment":"\/\/fixme this line break is doubled - is this correct??","repo":"sbalineni19\/OpenRefine","code_context_2":"}\nsb.append(\"{\\\"id\\\" : 4,\" +\n\"\\\"author\\\" : \\\"With line\\\\n break\\\",\" + \/\/FIXME this line break is doubled - is this correct??\n\"\\\"title\\\" : \\\"Book title 4\\\",\" +\n\"\\\"publish_date\\\" : \\\"2010-05-26\\\"\" +","code_context_10":"private static String getSampleWithLineBreak(){\nStringBuilder sb = new StringBuilder();\nsb.append(\"[\");\nfor(int i = 1; i < 4; i++){\nsb.append(getTypicalElement(i));\nsb.append(\",\");\n}\nsb.append(\"{\\\"id\\\" : 4,\" +\n\"\\\"author\\\" : \\\"With line\\\\n break\\\",\" + \/\/FIXME this line break is doubled - is this correct??\n\"\\\"title\\\" : \\\"Book title 4\\\",\" +\n\"\\\"publish_date\\\" : \\\"2010-05-26\\\"\" +\n\"},\");\nsb.append(getTypicalElement(5));\nsb.append(\",\");\nsb.append(getTypicalElement(6));\nsb.append(\"]\");\nreturn sb.toString();\n}","code_context_20":"private static String getSampleWithLineBreak(){\nStringBuilder sb = new StringBuilder();\nsb.append(\"[\");\nfor(int i = 1; i < 4; i++){\nsb.append(getTypicalElement(i));\nsb.append(\",\");\n}\nsb.append(\"{\\\"id\\\" : 4,\" +\n\"\\\"author\\\" : \\\"With line\\\\n break\\\",\" + \/\/FIXME this line break is doubled - is this correct??\n\"\\\"title\\\" : \\\"Book title 4\\\",\" +\n\"\\\"publish_date\\\" : \\\"2010-05-26\\\"\" +\n\"},\");\nsb.append(getTypicalElement(5));\nsb.append(\",\");\nsb.append(getTypicalElement(6));\nsb.append(\"]\");\nreturn sb.toString();\n}","label":[0,0,1,0]}
{"id":24911,"original_code":"@ParameterizedTest\n    @MethodSource(\"data\") \/\/ bug in junit csvsource parsing - it does a trim, using a manual parsing as workaround\n    void parse(final String csv) {\n        final String[] parts = csv.split(\",\");\n        parse(parser, parts[0], parseInt(parts[1]), parseBoolean(parts[2]), null, parseInt(parts[3]));\n    }","code":"@ParameterizedTest\n    @MethodSource(\"data\")\n    void parse(final String csv) {\n        final String[] parts = csv.split(\",\");\n        parse(parser, parts[0], parseInt(parts[1]), parseBoolean(parts[2]), null, parseInt(parts[3]));\n    }","cleancode":"@parameterizedtest @methodsource(\"data\") void parse(final string csv) { final string[] parts = csv.split(\",\"); parse(parser, parts[0], parseint(parts[1]), parseboolean(parts[2]), null, parseint(parts[3])); }","comment":"\/\/ bug in junit csvsource parsing - it does a trim, using a manual parsing as workaround","repo":"rmannibucau\/access-log-stats","code_context_2":"@ParameterizedTest\n@MethodSource(\"data\") \/\/ bug in junit csvsource parsing - it does a trim, using a manual parsing as workaround\nvoid parse(final String csv) {\nfinal String[] parts = csv.split(\",\");","code_context_10":"@ParameterizedTest\n@MethodSource(\"data\") \/\/ bug in junit csvsource parsing - it does a trim, using a manual parsing as workaround\nvoid parse(final String csv) {\nfinal String[] parts = csv.split(\",\");\nparse(parser, parts[0], parseInt(parts[1]), parseBoolean(parts[2]), null, parseInt(parts[3]));\n}","code_context_20":"@ParameterizedTest\n@MethodSource(\"data\") \/\/ bug in junit csvsource parsing - it does a trim, using a manual parsing as workaround\nvoid parse(final String csv) {\nfinal String[] parts = csv.split(\",\");\nparse(parser, parts[0], parseInt(parts[1]), parseBoolean(parts[2]), null, parseInt(parts[3]));\n}","label":[0,0,1,0]}
{"id":380,"original_code":"@Override\n\t\tpublic boolean accept(File pathname)\n\t\t{\n\t\t\t\/\/ TODO: More checking here - actually parse out tile coord\n\t\t\treturn pathname.isFile() && pathname.getName().endsWith(\".tile\");\n\t\t}","code":"@Override\n\t\tpublic boolean accept(File pathname)\n\t\t{\n\t\t\n\t\t\treturn pathname.isFile() && pathname.getName().endsWith(\".tile\");\n\t\t}","cleancode":"@override public boolean accept(file pathname) { return pathname.isfile() && pathname.getname().endswith(\".tile\"); }","comment":"\/\/ todo: more checking here - actually parse out tile coord","repo":"snuk182\/tectonicus","code_context_2":"public boolean accept(File pathname)\n{\n\/\/ TODO: More checking here - actually parse out tile coord\nreturn pathname.isFile() && pathname.getName().endsWith(\".tile\");\n}","code_context_10":"@Override\npublic boolean accept(File pathname)\n{\n\/\/ TODO: More checking here - actually parse out tile coord\nreturn pathname.isFile() && pathname.getName().endsWith(\".tile\");\n}","code_context_20":"@Override\npublic boolean accept(File pathname)\n{\n\/\/ TODO: More checking here - actually parse out tile coord\nreturn pathname.isFile() && pathname.getName().endsWith(\".tile\");\n}","label":[0,1,0,0]}
{"id":386,"original_code":"public static <T> MetricStorage doubleAsynchronousAccumulator(\n      View view,\n      InstrumentDescriptor instrument,\n      Consumer<ObservableDoubleMeasurement> metricUpdater) {\n    final MetricDescriptor metricDescriptor = MetricDescriptor.create(view, instrument);\n    Aggregator<T> aggregator =\n        view.getAggregation().createAggregator(instrument, ExemplarFilter.neverSample());\n    final AsyncAccumulator<T> measurementAccumulator = new AsyncAccumulator<>(instrument);\n    if (Aggregator.empty() == aggregator) {\n      return empty();\n    }\n    final AttributesProcessor attributesProcessor = view.getAttributesProcessor();\n    \/\/ TODO: Find a way to grab the measurement JUST ONCE for all async metrics.\n    final ObservableDoubleMeasurement result =\n        new ObservableDoubleMeasurement() {\n          @Override\n          public void observe(double value, Attributes attributes) {\n            T accumulation =\n                aggregator.accumulateDoubleMeasurement(value, attributes, Context.current());\n            if (accumulation != null) {\n              measurementAccumulator.record(\n                  attributesProcessor.process(attributes, Context.current()), accumulation);\n            }\n          }\n          @Override\n          public void observe(double value) {\n            observe(value, Attributes.empty());\n          }\n        };\n    return new AsynchronousMetricStorage<>(\n        metricDescriptor, aggregator, measurementAccumulator, () -> metricUpdater.accept(result));\n  }","code":"public static <T> MetricStorage doubleAsynchronousAccumulator(\n      View view,\n      InstrumentDescriptor instrument,\n      Consumer<ObservableDoubleMeasurement> metricUpdater) {\n    final MetricDescriptor metricDescriptor = MetricDescriptor.create(view, instrument);\n    Aggregator<T> aggregator =\n        view.getAggregation().createAggregator(instrument, ExemplarFilter.neverSample());\n    final AsyncAccumulator<T> measurementAccumulator = new AsyncAccumulator<>(instrument);\n    if (Aggregator.empty() == aggregator) {\n      return empty();\n    }\n    final AttributesProcessor attributesProcessor = view.getAttributesProcessor();\n   \n    final ObservableDoubleMeasurement result =\n        new ObservableDoubleMeasurement() {\n          @Override\n          public void observe(double value, Attributes attributes) {\n            T accumulation =\n                aggregator.accumulateDoubleMeasurement(value, attributes, Context.current());\n            if (accumulation != null) {\n              measurementAccumulator.record(\n                  attributesProcessor.process(attributes, Context.current()), accumulation);\n            }\n          }\n          @Override\n          public void observe(double value) {\n            observe(value, Attributes.empty());\n          }\n        };\n    return new AsynchronousMetricStorage<>(\n        metricDescriptor, aggregator, measurementAccumulator, () -> metricUpdater.accept(result));\n  }","cleancode":"public static <t> metricstorage doubleasynchronousaccumulator( view view, instrumentdescriptor instrument, consumer<observabledoublemeasurement> metricupdater) { final metricdescriptor metricdescriptor = metricdescriptor.create(view, instrument); aggregator<t> aggregator = view.getaggregation().createaggregator(instrument, exemplarfilter.neversample()); final asyncaccumulator<t> measurementaccumulator = new asyncaccumulator<>(instrument); if (aggregator.empty() == aggregator) { return empty(); } final attributesprocessor attributesprocessor = view.getattributesprocessor(); final observabledoublemeasurement result = new observabledoublemeasurement() { @override public void observe(double value, attributes attributes) { t accumulation = aggregator.accumulatedoublemeasurement(value, attributes, context.current()); if (accumulation != null) { measurementaccumulator.record( attributesprocessor.process(attributes, context.current()), accumulation); } } @override public void observe(double value) { observe(value, attributes.empty()); } }; return new asynchronousmetricstorage<>( metricdescriptor, aggregator, measurementaccumulator, () -> metricupdater.accept(result)); }","comment":"\/** constructs storage for {@code double} valued instruments. *\/\n\/\/ todo: find a way to grab the measurement just once for all async metrics.","repo":"svalaskevicius\/opentelemetry-java","code_context_2":"public static <T> MetricStorage doubleAsynchronousAccumulator(\nView view,\nInstrumentDescriptor instrument,\nConsumer<ObservableDoubleMeasurement> metricUpdater) {\nfinal MetricDescriptor metricDescriptor = MetricDescriptor.create(view, instrument);\nAggregator<T> aggregator =\nview.getAggregation().createAggregator(instrument, ExemplarFilter.neverSample());\nfinal AsyncAccumulator<T> measurementAccumulator = new AsyncAccumulator<>(instrument);\nif (Aggregator.empty() == aggregator) {\nreturn empty();\n}\nfinal AttributesProcessor attributesProcessor = view.getAttributesProcessor();\n\/\/ TODO: Find a way to grab the measurement JUST ONCE for all async metrics.\nfinal ObservableDoubleMeasurement result =\nnew ObservableDoubleMeasurement() {\n@Override\npublic void observe(double value, Attributes attributes) {\nT accumulation =\naggregator.accumulateDoubleMeasurement(value, attributes, Context.current());\nif (accumulation != null) {\nmeasurementAccumulator.record(\nattributesProcessor.process(attributes, Context.current()), accumulation);\n}\n}\n@Override\npublic void observe(double value) {\nobserve(value, Attributes.empty());\n}\n};\nreturn new AsynchronousMetricStorage<>(\nmetricDescriptor, aggregator, measurementAccumulator, () -> metricUpdater.accept(result));\n}\n\n}\nfinal AttributesProcessor attributesProcessor = view.getAttributesProcessor();\n\/\/ TODO: Find a way to grab the measurement JUST ONCE for all async metrics.\nfinal ObservableDoubleMeasurement result =\nnew ObservableDoubleMeasurement() {","code_context_10":"public static <T> MetricStorage doubleAsynchronousAccumulator(\nView view,\nInstrumentDescriptor instrument,\nConsumer<ObservableDoubleMeasurement> metricUpdater) {\nfinal MetricDescriptor metricDescriptor = MetricDescriptor.create(view, instrument);\nAggregator<T> aggregator =\nview.getAggregation().createAggregator(instrument, ExemplarFilter.neverSample());\nfinal AsyncAccumulator<T> measurementAccumulator = new AsyncAccumulator<>(instrument);\nif (Aggregator.empty() == aggregator) {\nreturn empty();\n}\nfinal AttributesProcessor attributesProcessor = view.getAttributesProcessor();\n\/\/ TODO: Find a way to grab the measurement JUST ONCE for all async metrics.\nfinal ObservableDoubleMeasurement result =\nnew ObservableDoubleMeasurement() {\n@Override\npublic void observe(double value, Attributes attributes) {\nT accumulation =\naggregator.accumulateDoubleMeasurement(value, attributes, Context.current());\nif (accumulation != null) {\nmeasurementAccumulator.record(\nattributesProcessor.process(attributes, Context.current()), accumulation);\n}\n}\n@Override\npublic void observe(double value) {\nobserve(value, Attributes.empty());\n}\n};\nreturn new AsynchronousMetricStorage<>(\nmetricDescriptor, aggregator, measurementAccumulator, () -> metricUpdater.accept(result));\n}\n\nInstrumentDescriptor instrument,\nConsumer<ObservableDoubleMeasurement> metricUpdater) {\nfinal MetricDescriptor metricDescriptor = MetricDescriptor.create(view, instrument);\nAggregator<T> aggregator =\nview.getAggregation().createAggregator(instrument, ExemplarFilter.neverSample());\nfinal AsyncAccumulator<T> measurementAccumulator = new AsyncAccumulator<>(instrument);\nif (Aggregator.empty() == aggregator) {\nreturn empty();\n}\nfinal AttributesProcessor attributesProcessor = view.getAttributesProcessor();\n\/\/ TODO: Find a way to grab the measurement JUST ONCE for all async metrics.\nfinal ObservableDoubleMeasurement result =\nnew ObservableDoubleMeasurement() {\n@Override\npublic void observe(double value, Attributes attributes) {\nT accumulation =\naggregator.accumulateDoubleMeasurement(value, attributes, Context.current());\nif (accumulation != null) {\nmeasurementAccumulator.record(\nattributesProcessor.process(attributes, Context.current()), accumulation);\n}","code_context_20":"public static <T> MetricStorage doubleAsynchronousAccumulator(\nView view,\nInstrumentDescriptor instrument,\nConsumer<ObservableDoubleMeasurement> metricUpdater) {\nfinal MetricDescriptor metricDescriptor = MetricDescriptor.create(view, instrument);\nAggregator<T> aggregator =\nview.getAggregation().createAggregator(instrument, ExemplarFilter.neverSample());\nfinal AsyncAccumulator<T> measurementAccumulator = new AsyncAccumulator<>(instrument);\nif (Aggregator.empty() == aggregator) {\nreturn empty();\n}\nfinal AttributesProcessor attributesProcessor = view.getAttributesProcessor();\n\/\/ TODO: Find a way to grab the measurement JUST ONCE for all async metrics.\nfinal ObservableDoubleMeasurement result =\nnew ObservableDoubleMeasurement() {\n@Override\npublic void observe(double value, Attributes attributes) {\nT accumulation =\naggregator.accumulateDoubleMeasurement(value, attributes, Context.current());\nif (accumulation != null) {\nmeasurementAccumulator.record(\nattributesProcessor.process(attributes, Context.current()), accumulation);\n}\n}\n@Override\npublic void observe(double value) {\nobserve(value, Attributes.empty());\n}\n};\nreturn new AsynchronousMetricStorage<>(\nmetricDescriptor, aggregator, measurementAccumulator, () -> metricUpdater.accept(result));\n}\n\npublic static <T> MetricStorage doubleAsynchronousAccumulator(\nView view,\nInstrumentDescriptor instrument,\nConsumer<ObservableDoubleMeasurement> metricUpdater) {\nfinal MetricDescriptor metricDescriptor = MetricDescriptor.create(view, instrument);\nAggregator<T> aggregator =\nview.getAggregation().createAggregator(instrument, ExemplarFilter.neverSample());\nfinal AsyncAccumulator<T> measurementAccumulator = new AsyncAccumulator<>(instrument);\nif (Aggregator.empty() == aggregator) {\nreturn empty();\n}\nfinal AttributesProcessor attributesProcessor = view.getAttributesProcessor();\n\/\/ TODO: Find a way to grab the measurement JUST ONCE for all async metrics.\nfinal ObservableDoubleMeasurement result =\nnew ObservableDoubleMeasurement() {\n@Override\npublic void observe(double value, Attributes attributes) {\nT accumulation =\naggregator.accumulateDoubleMeasurement(value, attributes, Context.current());\nif (accumulation != null) {\nmeasurementAccumulator.record(\nattributesProcessor.process(attributes, Context.current()), accumulation);\n}\n}\n@Override\npublic void observe(double value) {\nobserve(value, Attributes.empty());\n}\n};\nreturn new AsynchronousMetricStorage<>(\nmetricDescriptor, aggregator, measurementAccumulator, () -> metricUpdater.accept(result));\n}","label":[1,0,0,0]}
{"id":387,"original_code":"public static <T> MetricStorage longAsynchronousAccumulator(\n      View view,\n      InstrumentDescriptor instrument,\n      Consumer<ObservableLongMeasurement> metricUpdater) {\n    final MetricDescriptor metricDescriptor = MetricDescriptor.create(view, instrument);\n    Aggregator<T> aggregator =\n        view.getAggregation().createAggregator(instrument, ExemplarFilter.neverSample());\n    final AsyncAccumulator<T> measurementAccumulator = new AsyncAccumulator<>(instrument);\n    final AttributesProcessor attributesProcessor = view.getAttributesProcessor();\n    \/\/ TODO: Find a way to grab the measurement JUST ONCE for all async metrics.\n    final ObservableLongMeasurement result =\n        new ObservableLongMeasurement() {\n          @Override\n          public void observe(long value, Attributes attributes) {\n            T accumulation =\n                aggregator.accumulateLongMeasurement(value, attributes, Context.current());\n            if (accumulation != null) {\n              measurementAccumulator.record(\n                  attributesProcessor.process(attributes, Context.current()), accumulation);\n            }\n          }\n          @Override\n          public void observe(long value) {\n            observe(value, Attributes.empty());\n          }\n        };\n    return new AsynchronousMetricStorage<>(\n        metricDescriptor, aggregator, measurementAccumulator, () -> metricUpdater.accept(result));\n  }","code":"public static <T> MetricStorage longAsynchronousAccumulator(\n      View view,\n      InstrumentDescriptor instrument,\n      Consumer<ObservableLongMeasurement> metricUpdater) {\n    final MetricDescriptor metricDescriptor = MetricDescriptor.create(view, instrument);\n    Aggregator<T> aggregator =\n        view.getAggregation().createAggregator(instrument, ExemplarFilter.neverSample());\n    final AsyncAccumulator<T> measurementAccumulator = new AsyncAccumulator<>(instrument);\n    final AttributesProcessor attributesProcessor = view.getAttributesProcessor();\n   \n    final ObservableLongMeasurement result =\n        new ObservableLongMeasurement() {\n          @Override\n          public void observe(long value, Attributes attributes) {\n            T accumulation =\n                aggregator.accumulateLongMeasurement(value, attributes, Context.current());\n            if (accumulation != null) {\n              measurementAccumulator.record(\n                  attributesProcessor.process(attributes, Context.current()), accumulation);\n            }\n          }\n          @Override\n          public void observe(long value) {\n            observe(value, Attributes.empty());\n          }\n        };\n    return new AsynchronousMetricStorage<>(\n        metricDescriptor, aggregator, measurementAccumulator, () -> metricUpdater.accept(result));\n  }","cleancode":"public static <t> metricstorage longasynchronousaccumulator( view view, instrumentdescriptor instrument, consumer<observablelongmeasurement> metricupdater) { final metricdescriptor metricdescriptor = metricdescriptor.create(view, instrument); aggregator<t> aggregator = view.getaggregation().createaggregator(instrument, exemplarfilter.neversample()); final asyncaccumulator<t> measurementaccumulator = new asyncaccumulator<>(instrument); final attributesprocessor attributesprocessor = view.getattributesprocessor(); final observablelongmeasurement result = new observablelongmeasurement() { @override public void observe(long value, attributes attributes) { t accumulation = aggregator.accumulatelongmeasurement(value, attributes, context.current()); if (accumulation != null) { measurementaccumulator.record( attributesprocessor.process(attributes, context.current()), accumulation); } } @override public void observe(long value) { observe(value, attributes.empty()); } }; return new asynchronousmetricstorage<>( metricdescriptor, aggregator, measurementaccumulator, () -> metricupdater.accept(result)); }","comment":"\/** constructs storage for {@code long} valued instruments. *\/\n\/\/ todo: find a way to grab the measurement just once for all async metrics.","repo":"svalaskevicius\/opentelemetry-java","code_context_2":"public static <T> MetricStorage longAsynchronousAccumulator(\nView view,\nInstrumentDescriptor instrument,\nConsumer<ObservableLongMeasurement> metricUpdater) {\nfinal MetricDescriptor metricDescriptor = MetricDescriptor.create(view, instrument);\nAggregator<T> aggregator =\nview.getAggregation().createAggregator(instrument, ExemplarFilter.neverSample());\nfinal AsyncAccumulator<T> measurementAccumulator = new AsyncAccumulator<>(instrument);\nfinal AttributesProcessor attributesProcessor = view.getAttributesProcessor();\n\/\/ TODO: Find a way to grab the measurement JUST ONCE for all async metrics.\nfinal ObservableLongMeasurement result =\nnew ObservableLongMeasurement() {\n@Override\npublic void observe(long value, Attributes attributes) {\nT accumulation =\naggregator.accumulateLongMeasurement(value, attributes, Context.current());\nif (accumulation != null) {\nmeasurementAccumulator.record(\nattributesProcessor.process(attributes, Context.current()), accumulation);\n}\n}\n@Override\npublic void observe(long value) {\nobserve(value, Attributes.empty());\n}\n};\nreturn new AsynchronousMetricStorage<>(\nmetricDescriptor, aggregator, measurementAccumulator, () -> metricUpdater.accept(result));\n}\n\nfinal AsyncAccumulator<T> measurementAccumulator = new AsyncAccumulator<>(instrument);\nfinal AttributesProcessor attributesProcessor = view.getAttributesProcessor();\n\/\/ TODO: Find a way to grab the measurement JUST ONCE for all async metrics.\nfinal ObservableLongMeasurement result =\nnew ObservableLongMeasurement() {","code_context_10":"public static <T> MetricStorage longAsynchronousAccumulator(\nView view,\nInstrumentDescriptor instrument,\nConsumer<ObservableLongMeasurement> metricUpdater) {\nfinal MetricDescriptor metricDescriptor = MetricDescriptor.create(view, instrument);\nAggregator<T> aggregator =\nview.getAggregation().createAggregator(instrument, ExemplarFilter.neverSample());\nfinal AsyncAccumulator<T> measurementAccumulator = new AsyncAccumulator<>(instrument);\nfinal AttributesProcessor attributesProcessor = view.getAttributesProcessor();\n\/\/ TODO: Find a way to grab the measurement JUST ONCE for all async metrics.\nfinal ObservableLongMeasurement result =\nnew ObservableLongMeasurement() {\n@Override\npublic void observe(long value, Attributes attributes) {\nT accumulation =\naggregator.accumulateLongMeasurement(value, attributes, Context.current());\nif (accumulation != null) {\nmeasurementAccumulator.record(\nattributesProcessor.process(attributes, Context.current()), accumulation);\n}\n}\n@Override\npublic void observe(long value) {\nobserve(value, Attributes.empty());\n}\n};\nreturn new AsynchronousMetricStorage<>(\nmetricDescriptor, aggregator, measurementAccumulator, () -> metricUpdater.accept(result));\n}\n\npublic static <T> MetricStorage longAsynchronousAccumulator(\nView view,\nInstrumentDescriptor instrument,\nConsumer<ObservableLongMeasurement> metricUpdater) {\nfinal MetricDescriptor metricDescriptor = MetricDescriptor.create(view, instrument);\nAggregator<T> aggregator =\nview.getAggregation().createAggregator(instrument, ExemplarFilter.neverSample());\nfinal AsyncAccumulator<T> measurementAccumulator = new AsyncAccumulator<>(instrument);\nfinal AttributesProcessor attributesProcessor = view.getAttributesProcessor();\n\/\/ TODO: Find a way to grab the measurement JUST ONCE for all async metrics.\nfinal ObservableLongMeasurement result =\nnew ObservableLongMeasurement() {\n@Override\npublic void observe(long value, Attributes attributes) {\nT accumulation =\naggregator.accumulateLongMeasurement(value, attributes, Context.current());\nif (accumulation != null) {\nmeasurementAccumulator.record(\nattributesProcessor.process(attributes, Context.current()), accumulation);\n}","code_context_20":"public static <T> MetricStorage longAsynchronousAccumulator(\nView view,\nInstrumentDescriptor instrument,\nConsumer<ObservableLongMeasurement> metricUpdater) {\nfinal MetricDescriptor metricDescriptor = MetricDescriptor.create(view, instrument);\nAggregator<T> aggregator =\nview.getAggregation().createAggregator(instrument, ExemplarFilter.neverSample());\nfinal AsyncAccumulator<T> measurementAccumulator = new AsyncAccumulator<>(instrument);\nfinal AttributesProcessor attributesProcessor = view.getAttributesProcessor();\n\/\/ TODO: Find a way to grab the measurement JUST ONCE for all async metrics.\nfinal ObservableLongMeasurement result =\nnew ObservableLongMeasurement() {\n@Override\npublic void observe(long value, Attributes attributes) {\nT accumulation =\naggregator.accumulateLongMeasurement(value, attributes, Context.current());\nif (accumulation != null) {\nmeasurementAccumulator.record(\nattributesProcessor.process(attributes, Context.current()), accumulation);\n}\n}\n@Override\npublic void observe(long value) {\nobserve(value, Attributes.empty());\n}\n};\nreturn new AsynchronousMetricStorage<>(\nmetricDescriptor, aggregator, measurementAccumulator, () -> metricUpdater.accept(result));\n}\n\npublic static <T> MetricStorage longAsynchronousAccumulator(\nView view,\nInstrumentDescriptor instrument,\nConsumer<ObservableLongMeasurement> metricUpdater) {\nfinal MetricDescriptor metricDescriptor = MetricDescriptor.create(view, instrument);\nAggregator<T> aggregator =\nview.getAggregation().createAggregator(instrument, ExemplarFilter.neverSample());\nfinal AsyncAccumulator<T> measurementAccumulator = new AsyncAccumulator<>(instrument);\nfinal AttributesProcessor attributesProcessor = view.getAttributesProcessor();\n\/\/ TODO: Find a way to grab the measurement JUST ONCE for all async metrics.\nfinal ObservableLongMeasurement result =\nnew ObservableLongMeasurement() {\n@Override\npublic void observe(long value, Attributes attributes) {\nT accumulation =\naggregator.accumulateLongMeasurement(value, attributes, Context.current());\nif (accumulation != null) {\nmeasurementAccumulator.record(\nattributesProcessor.process(attributes, Context.current()), accumulation);\n}\n}\n@Override\npublic void observe(long value) {\nobserve(value, Attributes.empty());\n}\n};\nreturn new AsynchronousMetricStorage<>(\nmetricDescriptor, aggregator, measurementAccumulator, () -> metricUpdater.accept(result));\n}","label":[1,0,0,0]}
{"id":395,"original_code":"@Override\n    public Path getPath(URI uri) {\n        FileSystem fileSystem = getFileSystem(uri);\n        \/**\n         * TODO: set as a list. one s3FileSystem by region\n         *\/\n        return fileSystem.getPath(uri.getPath());\n    }","code":"@Override\n    public Path getPath(URI uri) {\n        FileSystem fileSystem = getFileSystem(uri);\n       \n        return fileSystem.getPath(uri.getPath());\n    }","cleancode":"@override public path getpath(uri uri) { filesystem filesystem = getfilesystem(uri); return filesystem.getpath(uri.getpath()); }","comment":"\/** * deviation from spec: throws filesystemnotfoundexception if filesystem * hasn't yet been initialized. call newfilesystem() first. * need credentials. maybe set credentials after? how? * todo: we can create a new one if the credentials are present by: * s3:\/\/access-key:secret-key@endpoint.com\/ *\/\n\/** * todo: set as a list. one s3filesystem by region *\/","repo":"skashin\/Amazon-S3-FileSystem-NIO2","code_context_2":"@Override\npublic Path getPath(URI uri) {\nFileSystem fileSystem = getFileSystem(uri);\n\/**\n* TODO: set as a list. one s3FileSystem by region\n*\/\nreturn fileSystem.getPath(uri.getPath());\n}\n\npublic Path getPath(URI uri) {\nFileSystem fileSystem = getFileSystem(uri);\n\/**\n* TODO: set as a list. one s3FileSystem by region\n*\/\nreturn fileSystem.getPath(uri.getPath());\n}","code_context_10":"@Override\npublic Path getPath(URI uri) {\nFileSystem fileSystem = getFileSystem(uri);\n\/**\n* TODO: set as a list. one s3FileSystem by region\n*\/\nreturn fileSystem.getPath(uri.getPath());\n}\n\n@Override\npublic Path getPath(URI uri) {\nFileSystem fileSystem = getFileSystem(uri);\n\/**\n* TODO: set as a list. one s3FileSystem by region\n*\/\nreturn fileSystem.getPath(uri.getPath());\n}","code_context_20":"@Override\npublic Path getPath(URI uri) {\nFileSystem fileSystem = getFileSystem(uri);\n\/**\n* TODO: set as a list. one s3FileSystem by region\n*\/\nreturn fileSystem.getPath(uri.getPath());\n}\n\n@Override\npublic Path getPath(URI uri) {\nFileSystem fileSystem = getFileSystem(uri);\n\/**\n* TODO: set as a list. one s3FileSystem by region\n*\/\nreturn fileSystem.getPath(uri.getPath());\n}","label":[1,1,0,0]}
{"id":24980,"original_code":"protected void runInContextInternal() {\n        if (s_logger.isInfoEnabled()) {\n            s_logger.info(\"starting usage job...\");\n        }\n        \/\/ how about we update the job exec time when the job starts???\n        long execTime = _jobExecTime.getTimeInMillis();\n        long now = System.currentTimeMillis() + 2000; \/\/ 2 second buffer since jobs can run a little early (though usually just by milliseconds)\n        if (execTime < now) {\n            \/\/ if exec time is in the past, calculate the next time the job will execute...if this is a one-off job that is a result\n            \/\/ of scheduleParse() then don't update the next exec time...\n            _jobExecTime.add(Calendar.MINUTE, _aggregationDuration);\n        }\n        UsageJobVO job = _usageJobDao.isOwner(_hostname, _pid);\n        if (job != null) {\n            \/\/ FIXME: we really need to do a better job of not missing any events...so we should some how\n            \/\/        keep track of the last time usage was run, then go from there...\n            \/\/ For executing the job, we treat hourly and daily as special time ranges, using the previous full hour or the previous\n            \/\/ full day.  Otherwise we just subtract off the aggregation range from the current time and use that as start date with\n            \/\/ current time as end date.\n            Calendar cal = Calendar.getInstance(_usageTimezone);\n            cal.setTime(new Date());\n            long startDate = 0;\n            long endDate = 0;\n            if (_aggregationDuration == DAILY_TIME) {\n                cal.roll(Calendar.DAY_OF_YEAR, false);\n                cal.set(Calendar.HOUR_OF_DAY, 0);\n                cal.set(Calendar.MINUTE, 0);\n                cal.set(Calendar.SECOND, 0);\n                cal.set(Calendar.MILLISECOND, 0);\n                startDate = cal.getTime().getTime();\n                cal.roll(Calendar.DAY_OF_YEAR, true);\n                cal.add(Calendar.MILLISECOND, -1);\n                endDate = cal.getTime().getTime();\n            } else if (_aggregationDuration == HOURLY_TIME) {\n                cal.roll(Calendar.HOUR_OF_DAY, false);\n                cal.set(Calendar.MINUTE, 0);\n                cal.set(Calendar.SECOND, 0);\n                cal.set(Calendar.MILLISECOND, 0);\n                startDate = cal.getTime().getTime();\n                cal.roll(Calendar.HOUR_OF_DAY, true);\n                cal.add(Calendar.MILLISECOND, -1);\n                endDate = cal.getTime().getTime();\n            } else {\n                endDate = cal.getTime().getTime(); \/\/ current time\n                cal.add(Calendar.MINUTE, -1 * _aggregationDuration);\n                startDate = cal.getTime().getTime();\n            }\n            parse(job, startDate, endDate);\n            if (_runQuota){\n                try {\n                    _quotaManager.calculateQuotaUsage();\n                }\n                catch (Exception e){\n                    s_logger.error(\"Exception received while calculating quota\", e);\n                }\n                try {\n                    _quotaStatement.sendStatement();\n                } catch (Exception e) {\n                    s_logger.error(\"Exception received while sending statements\", e);\n                }\n                try {\n                    _alertManager.checkAndSendQuotaAlertEmails();\n                } catch (Exception e) {\n                    s_logger.error(\"Exception received while sending alerts\", e);\n                }\n            }\n        } else {\n            if (s_logger.isDebugEnabled()) {\n                s_logger.debug(\"Not owner of usage job, skipping...\");\n            }\n        }\n        if (s_logger.isInfoEnabled()) {\n            s_logger.info(\"usage job complete\");\n        }\n    }","code":"protected void runInContextInternal() {\n        if (s_logger.isInfoEnabled()) {\n            s_logger.info(\"starting usage job...\");\n        }\n       \n        long execTime = _jobExecTime.getTimeInMillis();\n        long now = System.currentTimeMillis() + 2000;\n        if (execTime < now) {\n           \n           \n            _jobExecTime.add(Calendar.MINUTE, _aggregationDuration);\n        }\n        UsageJobVO job = _usageJobDao.isOwner(_hostname, _pid);\n        if (job != null) {\n           \n           \n           \n           \n           \n            Calendar cal = Calendar.getInstance(_usageTimezone);\n            cal.setTime(new Date());\n            long startDate = 0;\n            long endDate = 0;\n            if (_aggregationDuration == DAILY_TIME) {\n                cal.roll(Calendar.DAY_OF_YEAR, false);\n                cal.set(Calendar.HOUR_OF_DAY, 0);\n                cal.set(Calendar.MINUTE, 0);\n                cal.set(Calendar.SECOND, 0);\n                cal.set(Calendar.MILLISECOND, 0);\n                startDate = cal.getTime().getTime();\n                cal.roll(Calendar.DAY_OF_YEAR, true);\n                cal.add(Calendar.MILLISECOND, -1);\n                endDate = cal.getTime().getTime();\n            } else if (_aggregationDuration == HOURLY_TIME) {\n                cal.roll(Calendar.HOUR_OF_DAY, false);\n                cal.set(Calendar.MINUTE, 0);\n                cal.set(Calendar.SECOND, 0);\n                cal.set(Calendar.MILLISECOND, 0);\n                startDate = cal.getTime().getTime();\n                cal.roll(Calendar.HOUR_OF_DAY, true);\n                cal.add(Calendar.MILLISECOND, -1);\n                endDate = cal.getTime().getTime();\n            } else {\n                endDate = cal.getTime().getTime();\n                cal.add(Calendar.MINUTE, -1 * _aggregationDuration);\n                startDate = cal.getTime().getTime();\n            }\n            parse(job, startDate, endDate);\n            if (_runQuota){\n                try {\n                    _quotaManager.calculateQuotaUsage();\n                }\n                catch (Exception e){\n                    s_logger.error(\"Exception received while calculating quota\", e);\n                }\n                try {\n                    _quotaStatement.sendStatement();\n                } catch (Exception e) {\n                    s_logger.error(\"Exception received while sending statements\", e);\n                }\n                try {\n                    _alertManager.checkAndSendQuotaAlertEmails();\n                } catch (Exception e) {\n                    s_logger.error(\"Exception received while sending alerts\", e);\n                }\n            }\n        } else {\n            if (s_logger.isDebugEnabled()) {\n                s_logger.debug(\"Not owner of usage job, skipping...\");\n            }\n        }\n        if (s_logger.isInfoEnabled()) {\n            s_logger.info(\"usage job complete\");\n        }\n    }","cleancode":"protected void runincontextinternal() { if (s_logger.isinfoenabled()) { s_logger.info(\"starting usage job...\"); } long exectime = _jobexectime.gettimeinmillis(); long now = system.currenttimemillis() + 2000; if (exectime < now) { _jobexectime.add(calendar.minute, _aggregationduration); } usagejobvo job = _usagejobdao.isowner(_hostname, _pid); if (job != null) { calendar cal = calendar.getinstance(_usagetimezone); cal.settime(new date()); long startdate = 0; long enddate = 0; if (_aggregationduration == daily_time) { cal.roll(calendar.day_of_year, false); cal.set(calendar.hour_of_day, 0); cal.set(calendar.minute, 0); cal.set(calendar.second, 0); cal.set(calendar.millisecond, 0); startdate = cal.gettime().gettime(); cal.roll(calendar.day_of_year, true); cal.add(calendar.millisecond, -1); enddate = cal.gettime().gettime(); } else if (_aggregationduration == hourly_time) { cal.roll(calendar.hour_of_day, false); cal.set(calendar.minute, 0); cal.set(calendar.second, 0); cal.set(calendar.millisecond, 0); startdate = cal.gettime().gettime(); cal.roll(calendar.hour_of_day, true); cal.add(calendar.millisecond, -1); enddate = cal.gettime().gettime(); } else { enddate = cal.gettime().gettime(); cal.add(calendar.minute, -1 * _aggregationduration); startdate = cal.gettime().gettime(); } parse(job, startdate, enddate); if (_runquota){ try { _quotamanager.calculatequotausage(); } catch (exception e){ s_logger.error(\"exception received while calculating quota\", e); } try { _quotastatement.sendstatement(); } catch (exception e) { s_logger.error(\"exception received while sending statements\", e); } try { _alertmanager.checkandsendquotaalertemails(); } catch (exception e) { s_logger.error(\"exception received while sending alerts\", e); } } } else { if (s_logger.isdebugenabled()) { s_logger.debug(\"not owner of usage job, skipping...\"); } } if (s_logger.isinfoenabled()) { s_logger.info(\"usage job complete\"); } }","comment":"\/\/ how about we update the job exec time when the job starts???\n\/\/ 2 second buffer since jobs can run a little early (though usually just by milliseconds)\n\/\/ if exec time is in the past, calculate the next time the job will execute...if this is a one-off job that is a result \/\/ of scheduleparse() then don't update the next exec time...\n\/\/ fixme: we really need to do a better job of not missing any events...so we should some how \/\/ keep track of the last time usage was run, then go from there... \/\/ for executing the job, we treat hourly and daily as special time ranges, using the previous full hour or the previous \/\/ full day. otherwise we just subtract off the aggregation range from the current time and use that as start date with \/\/ current time as end date.\n\/\/ current time","repo":"serbaut\/cloudstack","code_context_2":"s_logger.info(\"starting usage job...\");\n}\n\/\/ how about we update the job exec time when the job starts???\nlong execTime = _jobExecTime.getTimeInMillis();\nlong now = System.currentTimeMillis() + 2000; \/\/ 2 second buffer since jobs can run a little early (though usually just by milliseconds)\n\n\/\/ how about we update the job exec time when the job starts???\nlong execTime = _jobExecTime.getTimeInMillis();\nlong now = System.currentTimeMillis() + 2000; \/\/ 2 second buffer since jobs can run a little early (though usually just by milliseconds)\nif (execTime < now) {\n\/\/ if exec time is in the past, calculate the next time the job will execute...if this is a one-off job that is a result\n\nlong now = System.currentTimeMillis() + 2000; \/\/ 2 second buffer since jobs can run a little early (though usually just by milliseconds)\nif (execTime < now) {\n\/\/ if exec time is in the past, calculate the next time the job will execute...if this is a one-off job that is a result\n\/\/ of scheduleParse() then don't update the next exec time...\n_jobExecTime.add(Calendar.MINUTE, _aggregationDuration);\n}\n\nUsageJobVO job = _usageJobDao.isOwner(_hostname, _pid);\nif (job != null) {\n\/\/ FIXME: we really need to do a better job of not missing any events...so we should some how\n\/\/ keep track of the last time usage was run, then go from there...\n\/\/ For executing the job, we treat hourly and daily as special time ranges, using the previous full hour or the previous\n\/\/ full day. Otherwise we just subtract off the aggregation range from the current time and use that as start date with\n\/\/ current time as end date.\nCalendar cal = Calendar.getInstance(_usageTimezone);\ncal.setTime(new Date());\n\n\/\/ For executing the job, we treat hourly and daily as special time ranges, using the previous full hour or the previous\n\/\/ full day. Otherwise we just subtract off the aggregation range from the current time and use that as start date with\n\/\/ current time as end date.\nCalendar cal = Calendar.getInstance(_usageTimezone);\ncal.setTime(new Date());","code_context_10":"protected void runInContextInternal() {\nif (s_logger.isInfoEnabled()) {\ns_logger.info(\"starting usage job...\");\n}\n\/\/ how about we update the job exec time when the job starts???\nlong execTime = _jobExecTime.getTimeInMillis();\nlong now = System.currentTimeMillis() + 2000; \/\/ 2 second buffer since jobs can run a little early (though usually just by milliseconds)\nif (execTime < now) {\n\/\/ if exec time is in the past, calculate the next time the job will execute...if this is a one-off job that is a result\n\/\/ of scheduleParse() then don't update the next exec time...\n_jobExecTime.add(Calendar.MINUTE, _aggregationDuration);\n}\nUsageJobVO job = _usageJobDao.isOwner(_hostname, _pid);\nif (job != null) {\n\/\/ FIXME: we really need to do a better job of not missing any events...so we should some how\n\nprotected void runInContextInternal() {\nif (s_logger.isInfoEnabled()) {\ns_logger.info(\"starting usage job...\");\n}\n\/\/ how about we update the job exec time when the job starts???\nlong execTime = _jobExecTime.getTimeInMillis();\nlong now = System.currentTimeMillis() + 2000; \/\/ 2 second buffer since jobs can run a little early (though usually just by milliseconds)\nif (execTime < now) {\n\/\/ if exec time is in the past, calculate the next time the job will execute...if this is a one-off job that is a result\n\/\/ of scheduleParse() then don't update the next exec time...\n_jobExecTime.add(Calendar.MINUTE, _aggregationDuration);\n}\nUsageJobVO job = _usageJobDao.isOwner(_hostname, _pid);\nif (job != null) {\n\/\/ FIXME: we really need to do a better job of not missing any events...so we should some how\n\/\/ keep track of the last time usage was run, then go from there...\n\/\/ For executing the job, we treat hourly and daily as special time ranges, using the previous full hour or the previous\n\nprotected void runInContextInternal() {\nif (s_logger.isInfoEnabled()) {\ns_logger.info(\"starting usage job...\");\n}\n\/\/ how about we update the job exec time when the job starts???\nlong execTime = _jobExecTime.getTimeInMillis();\nlong now = System.currentTimeMillis() + 2000; \/\/ 2 second buffer since jobs can run a little early (though usually just by milliseconds)\nif (execTime < now) {\n\/\/ if exec time is in the past, calculate the next time the job will execute...if this is a one-off job that is a result\n\/\/ of scheduleParse() then don't update the next exec time...\n_jobExecTime.add(Calendar.MINUTE, _aggregationDuration);\n}\nUsageJobVO job = _usageJobDao.isOwner(_hostname, _pid);\nif (job != null) {\n\/\/ FIXME: we really need to do a better job of not missing any events...so we should some how\n\/\/ keep track of the last time usage was run, then go from there...\n\/\/ For executing the job, we treat hourly and daily as special time ranges, using the previous full hour or the previous\n\/\/ full day. Otherwise we just subtract off the aggregation range from the current time and use that as start date with\n\/\/ current time as end date.\nCalendar cal = Calendar.getInstance(_usageTimezone);\n\n\/\/ how about we update the job exec time when the job starts???\nlong execTime = _jobExecTime.getTimeInMillis();\nlong now = System.currentTimeMillis() + 2000; \/\/ 2 second buffer since jobs can run a little early (though usually just by milliseconds)\nif (execTime < now) {\n\/\/ if exec time is in the past, calculate the next time the job will execute...if this is a one-off job that is a result\n\/\/ of scheduleParse() then don't update the next exec time...\n_jobExecTime.add(Calendar.MINUTE, _aggregationDuration);\n}\nUsageJobVO job = _usageJobDao.isOwner(_hostname, _pid);\nif (job != null) {\n\/\/ FIXME: we really need to do a better job of not missing any events...so we should some how\n\/\/ keep track of the last time usage was run, then go from there...\n\/\/ For executing the job, we treat hourly and daily as special time ranges, using the previous full hour or the previous\n\/\/ full day. Otherwise we just subtract off the aggregation range from the current time and use that as start date with\n\/\/ current time as end date.\nCalendar cal = Calendar.getInstance(_usageTimezone);\ncal.setTime(new Date());\nlong startDate = 0;\nlong endDate = 0;\nif (_aggregationDuration == DAILY_TIME) {\ncal.roll(Calendar.DAY_OF_YEAR, false);\ncal.set(Calendar.HOUR_OF_DAY, 0);\ncal.set(Calendar.MINUTE, 0);\ncal.set(Calendar.SECOND, 0);\ncal.set(Calendar.MILLISECOND, 0);\n\n\/\/ if exec time is in the past, calculate the next time the job will execute...if this is a one-off job that is a result\n\/\/ of scheduleParse() then don't update the next exec time...\n_jobExecTime.add(Calendar.MINUTE, _aggregationDuration);\n}\nUsageJobVO job = _usageJobDao.isOwner(_hostname, _pid);\nif (job != null) {\n\/\/ FIXME: we really need to do a better job of not missing any events...so we should some how\n\/\/ keep track of the last time usage was run, then go from there...\n\/\/ For executing the job, we treat hourly and daily as special time ranges, using the previous full hour or the previous\n\/\/ full day. Otherwise we just subtract off the aggregation range from the current time and use that as start date with\n\/\/ current time as end date.\nCalendar cal = Calendar.getInstance(_usageTimezone);\ncal.setTime(new Date());\nlong startDate = 0;\nlong endDate = 0;\nif (_aggregationDuration == DAILY_TIME) {\ncal.roll(Calendar.DAY_OF_YEAR, false);\ncal.set(Calendar.HOUR_OF_DAY, 0);\ncal.set(Calendar.MINUTE, 0);\ncal.set(Calendar.SECOND, 0);\ncal.set(Calendar.MILLISECOND, 0);","code_context_20":"protected void runInContextInternal() {\nif (s_logger.isInfoEnabled()) {\ns_logger.info(\"starting usage job...\");\n}\n\/\/ how about we update the job exec time when the job starts???\nlong execTime = _jobExecTime.getTimeInMillis();\nlong now = System.currentTimeMillis() + 2000; \/\/ 2 second buffer since jobs can run a little early (though usually just by milliseconds)\nif (execTime < now) {\n\/\/ if exec time is in the past, calculate the next time the job will execute...if this is a one-off job that is a result\n\/\/ of scheduleParse() then don't update the next exec time...\n_jobExecTime.add(Calendar.MINUTE, _aggregationDuration);\n}\nUsageJobVO job = _usageJobDao.isOwner(_hostname, _pid);\nif (job != null) {\n\/\/ FIXME: we really need to do a better job of not missing any events...so we should some how\n\/\/ keep track of the last time usage was run, then go from there...\n\/\/ For executing the job, we treat hourly and daily as special time ranges, using the previous full hour or the previous\n\/\/ full day. Otherwise we just subtract off the aggregation range from the current time and use that as start date with\n\/\/ current time as end date.\nCalendar cal = Calendar.getInstance(_usageTimezone);\ncal.setTime(new Date());\nlong startDate = 0;\nlong endDate = 0;\nif (_aggregationDuration == DAILY_TIME) {\ncal.roll(Calendar.DAY_OF_YEAR, false);\n\nprotected void runInContextInternal() {\nif (s_logger.isInfoEnabled()) {\ns_logger.info(\"starting usage job...\");\n}\n\/\/ how about we update the job exec time when the job starts???\nlong execTime = _jobExecTime.getTimeInMillis();\nlong now = System.currentTimeMillis() + 2000; \/\/ 2 second buffer since jobs can run a little early (though usually just by milliseconds)\nif (execTime < now) {\n\/\/ if exec time is in the past, calculate the next time the job will execute...if this is a one-off job that is a result\n\/\/ of scheduleParse() then don't update the next exec time...\n_jobExecTime.add(Calendar.MINUTE, _aggregationDuration);\n}\nUsageJobVO job = _usageJobDao.isOwner(_hostname, _pid);\nif (job != null) {\n\/\/ FIXME: we really need to do a better job of not missing any events...so we should some how\n\/\/ keep track of the last time usage was run, then go from there...\n\/\/ For executing the job, we treat hourly and daily as special time ranges, using the previous full hour or the previous\n\/\/ full day. Otherwise we just subtract off the aggregation range from the current time and use that as start date with\n\/\/ current time as end date.\nCalendar cal = Calendar.getInstance(_usageTimezone);\ncal.setTime(new Date());\nlong startDate = 0;\nlong endDate = 0;\nif (_aggregationDuration == DAILY_TIME) {\ncal.roll(Calendar.DAY_OF_YEAR, false);\ncal.set(Calendar.HOUR_OF_DAY, 0);\ncal.set(Calendar.MINUTE, 0);\n\nprotected void runInContextInternal() {\nif (s_logger.isInfoEnabled()) {\ns_logger.info(\"starting usage job...\");\n}\n\/\/ how about we update the job exec time when the job starts???\nlong execTime = _jobExecTime.getTimeInMillis();\nlong now = System.currentTimeMillis() + 2000; \/\/ 2 second buffer since jobs can run a little early (though usually just by milliseconds)\nif (execTime < now) {\n\/\/ if exec time is in the past, calculate the next time the job will execute...if this is a one-off job that is a result\n\/\/ of scheduleParse() then don't update the next exec time...\n_jobExecTime.add(Calendar.MINUTE, _aggregationDuration);\n}\nUsageJobVO job = _usageJobDao.isOwner(_hostname, _pid);\nif (job != null) {\n\/\/ FIXME: we really need to do a better job of not missing any events...so we should some how\n\/\/ keep track of the last time usage was run, then go from there...\n\/\/ For executing the job, we treat hourly and daily as special time ranges, using the previous full hour or the previous\n\/\/ full day. Otherwise we just subtract off the aggregation range from the current time and use that as start date with\n\/\/ current time as end date.\nCalendar cal = Calendar.getInstance(_usageTimezone);\ncal.setTime(new Date());\nlong startDate = 0;\nlong endDate = 0;\nif (_aggregationDuration == DAILY_TIME) {\ncal.roll(Calendar.DAY_OF_YEAR, false);\ncal.set(Calendar.HOUR_OF_DAY, 0);\ncal.set(Calendar.MINUTE, 0);\ncal.set(Calendar.SECOND, 0);\ncal.set(Calendar.MILLISECOND, 0);\nstartDate = cal.getTime().getTime();\n\nprotected void runInContextInternal() {\nif (s_logger.isInfoEnabled()) {\ns_logger.info(\"starting usage job...\");\n}\n\/\/ how about we update the job exec time when the job starts???\nlong execTime = _jobExecTime.getTimeInMillis();\nlong now = System.currentTimeMillis() + 2000; \/\/ 2 second buffer since jobs can run a little early (though usually just by milliseconds)\nif (execTime < now) {\n\/\/ if exec time is in the past, calculate the next time the job will execute...if this is a one-off job that is a result\n\/\/ of scheduleParse() then don't update the next exec time...\n_jobExecTime.add(Calendar.MINUTE, _aggregationDuration);\n}\nUsageJobVO job = _usageJobDao.isOwner(_hostname, _pid);\nif (job != null) {\n\/\/ FIXME: we really need to do a better job of not missing any events...so we should some how\n\/\/ keep track of the last time usage was run, then go from there...\n\/\/ For executing the job, we treat hourly and daily as special time ranges, using the previous full hour or the previous\n\/\/ full day. Otherwise we just subtract off the aggregation range from the current time and use that as start date with\n\/\/ current time as end date.\nCalendar cal = Calendar.getInstance(_usageTimezone);\ncal.setTime(new Date());\nlong startDate = 0;\nlong endDate = 0;\nif (_aggregationDuration == DAILY_TIME) {\ncal.roll(Calendar.DAY_OF_YEAR, false);\ncal.set(Calendar.HOUR_OF_DAY, 0);\ncal.set(Calendar.MINUTE, 0);\ncal.set(Calendar.SECOND, 0);\ncal.set(Calendar.MILLISECOND, 0);\nstartDate = cal.getTime().getTime();\ncal.roll(Calendar.DAY_OF_YEAR, true);\ncal.add(Calendar.MILLISECOND, -1);\nendDate = cal.getTime().getTime();\n} else if (_aggregationDuration == HOURLY_TIME) {\ncal.roll(Calendar.HOUR_OF_DAY, false);\ncal.set(Calendar.MINUTE, 0);\ncal.set(Calendar.SECOND, 0);\ncal.set(Calendar.MILLISECOND, 0);\nstartDate = cal.getTime().getTime();\n\nprotected void runInContextInternal() {\nif (s_logger.isInfoEnabled()) {\ns_logger.info(\"starting usage job...\");\n}\n\/\/ how about we update the job exec time when the job starts???\nlong execTime = _jobExecTime.getTimeInMillis();\nlong now = System.currentTimeMillis() + 2000; \/\/ 2 second buffer since jobs can run a little early (though usually just by milliseconds)\nif (execTime < now) {\n\/\/ if exec time is in the past, calculate the next time the job will execute...if this is a one-off job that is a result\n\/\/ of scheduleParse() then don't update the next exec time...\n_jobExecTime.add(Calendar.MINUTE, _aggregationDuration);\n}\nUsageJobVO job = _usageJobDao.isOwner(_hostname, _pid);\nif (job != null) {\n\/\/ FIXME: we really need to do a better job of not missing any events...so we should some how\n\/\/ keep track of the last time usage was run, then go from there...\n\/\/ For executing the job, we treat hourly and daily as special time ranges, using the previous full hour or the previous\n\/\/ full day. Otherwise we just subtract off the aggregation range from the current time and use that as start date with\n\/\/ current time as end date.\nCalendar cal = Calendar.getInstance(_usageTimezone);\ncal.setTime(new Date());\nlong startDate = 0;\nlong endDate = 0;\nif (_aggregationDuration == DAILY_TIME) {\ncal.roll(Calendar.DAY_OF_YEAR, false);\ncal.set(Calendar.HOUR_OF_DAY, 0);\ncal.set(Calendar.MINUTE, 0);\ncal.set(Calendar.SECOND, 0);\ncal.set(Calendar.MILLISECOND, 0);\nstartDate = cal.getTime().getTime();\ncal.roll(Calendar.DAY_OF_YEAR, true);\ncal.add(Calendar.MILLISECOND, -1);\nendDate = cal.getTime().getTime();\n} else if (_aggregationDuration == HOURLY_TIME) {\ncal.roll(Calendar.HOUR_OF_DAY, false);\ncal.set(Calendar.MINUTE, 0);\ncal.set(Calendar.SECOND, 0);\ncal.set(Calendar.MILLISECOND, 0);\nstartDate = cal.getTime().getTime();","label":[1,0,1,0]}
{"id":24981,"original_code":"@Override\n    public void parse(UsageJobVO job, long startDateMillis, long endDateMillis) {\n        \/\/ TODO: Shouldn't we also allow parsing by the type of usage?\n        boolean success = false;\n        long timeStart = System.currentTimeMillis();\n        try {\n            if ((endDateMillis == 0) || (endDateMillis > timeStart)) {\n                endDateMillis = timeStart;\n            }\n            long lastSuccess = _usageJobDao.getLastJobSuccessDateMillis();\n            if (lastSuccess != 0) {\n                startDateMillis = lastSuccess + 1; \/\/ 1 millisecond after\n            }\n            if (startDateMillis >= endDateMillis) {\n                if (s_logger.isInfoEnabled()) {\n                    s_logger.info(\"not parsing usage records since start time mills (\" + startDateMillis + \") is on or after end time millis (\" + endDateMillis + \")\");\n                }\n                TransactionLegacy jobUpdateTxn = TransactionLegacy.open(TransactionLegacy.USAGE_DB);\n                try {\n                    jobUpdateTxn.start();\n                    \/\/ everything seemed to work...set endDate as the last success date\n                    _usageJobDao.updateJobSuccess(job.getId(), startDateMillis, endDateMillis, System.currentTimeMillis() - timeStart, success);\n                    \/\/ create a new job if this is a recurring job\n                    if (job.getJobType() == UsageJobVO.JOB_TYPE_RECURRING) {\n                        _usageJobDao.createNewJob(_hostname, _pid, UsageJobVO.JOB_TYPE_RECURRING);\n                    }\n                    jobUpdateTxn.commit();\n                } finally {\n                    jobUpdateTxn.close();\n                }\n                return;\n            }\n            Date startDate = new Date(startDateMillis);\n            Date endDate = new Date(endDateMillis);\n            if (s_logger.isInfoEnabled()) {\n                s_logger.info(\"Parsing usage records between \" + startDate + \" and \" + endDate);\n            }\n            List<AccountVO> accounts = null;\n            List<UserStatisticsVO> userStats = null;\n            Map<String, UsageNetworkVO> networkStats = null;\n            List<VmDiskStatisticsVO> vmDiskStats = null;\n            Map<String, UsageVmDiskVO> vmDiskUsages = null;\n            TransactionLegacy userTxn = TransactionLegacy.open(TransactionLegacy.CLOUD_DB);\n            try {\n                Long limit = Long.valueOf(500);\n                Long offset = Long.valueOf(0);\n                Long lastAccountId = _usageDao.getLastAccountId();\n                if (lastAccountId == null) {\n                    lastAccountId = Long.valueOf(0);\n                }\n                do {\n                    Filter filter = new Filter(AccountVO.class, \"id\", true, offset, limit);\n                    accounts = _accountDao.findActiveAccounts(lastAccountId, filter);\n                    if ((accounts != null) && !accounts.isEmpty()) {\n                        \/\/ now update the accounts in the cloud_usage db\n                        _usageDao.updateAccounts(accounts);\n                    }\n                    offset = new Long(offset.longValue() + limit.longValue());\n                } while ((accounts != null) && !accounts.isEmpty());\n                \/\/ reset offset\n                offset = Long.valueOf(0);\n                do {\n                    Filter filter = new Filter(AccountVO.class, \"id\", true, offset, limit);\n                    accounts = _accountDao.findRecentlyDeletedAccounts(lastAccountId, startDate, filter);\n                    if ((accounts != null) && !accounts.isEmpty()) {\n                        \/\/ now update the accounts in the cloud_usage db\n                        _usageDao.updateAccounts(accounts);\n                    }\n                    offset = new Long(offset.longValue() + limit.longValue());\n                } while ((accounts != null) && !accounts.isEmpty());\n                \/\/ reset offset\n                offset = Long.valueOf(0);\n                do {\n                    Filter filter = new Filter(AccountVO.class, \"id\", true, offset, limit);\n                    accounts = _accountDao.findNewAccounts(lastAccountId, filter);\n                    if ((accounts != null) && !accounts.isEmpty()) {\n                        \/\/ now copy the accounts to cloud_usage db\n                        _usageDao.saveAccounts(accounts);\n                    }\n                    offset = new Long(offset.longValue() + limit.longValue());\n                } while ((accounts != null) && !accounts.isEmpty());\n                \/\/ reset offset\n                offset = Long.valueOf(0);\n                \/\/ get all the user stats to create usage records for the network usage\n                Long lastUserStatsId = _usageDao.getLastUserStatsId();\n                if (lastUserStatsId == null) {\n                    lastUserStatsId = Long.valueOf(0);\n                }\n                SearchCriteria<UserStatisticsVO> sc2 = _userStatsDao.createSearchCriteria();\n                sc2.addAnd(\"id\", SearchCriteria.Op.LTEQ, lastUserStatsId);\n                do {\n                    Filter filter = new Filter(UserStatisticsVO.class, \"id\", true, offset, limit);\n                    userStats = _userStatsDao.search(sc2, filter);\n                    if ((userStats != null) && !userStats.isEmpty()) {\n                        \/\/ now copy the accounts to cloud_usage db\n                        _usageDao.updateUserStats(userStats);\n                    }\n                    offset = new Long(offset.longValue() + limit.longValue());\n                } while ((userStats != null) && !userStats.isEmpty());\n                \/\/ reset offset\n                offset = Long.valueOf(0);\n                sc2 = _userStatsDao.createSearchCriteria();\n                sc2.addAnd(\"id\", SearchCriteria.Op.GT, lastUserStatsId);\n                do {\n                    Filter filter = new Filter(UserStatisticsVO.class, \"id\", true, offset, limit);\n                    userStats = _userStatsDao.search(sc2, filter);\n                    if ((userStats != null) && !userStats.isEmpty()) {\n                        \/\/ now copy the accounts to cloud_usage db\n                        _usageDao.saveUserStats(userStats);\n                    }\n                    offset = new Long(offset.longValue() + limit.longValue());\n                } while ((userStats != null) && !userStats.isEmpty());\n                \/\/ reset offset\n                offset = Long.valueOf(0);\n                \/\/ get all the vm network stats to create usage_VM_network records for the vm network usage\n                Long lastVmDiskStatsId = _usageDao.getLastVmDiskStatsId();\n                if (lastVmDiskStatsId == null) {\n                    lastVmDiskStatsId = Long.valueOf(0);\n                }\n                SearchCriteria<VmDiskStatisticsVO> sc4 = _vmDiskStatsDao.createSearchCriteria();\n                sc4.addAnd(\"id\", SearchCriteria.Op.LTEQ, lastVmDiskStatsId);\n                do {\n                    Filter filter = new Filter(VmDiskStatisticsVO.class, \"id\", true, offset, limit);\n                    vmDiskStats = _vmDiskStatsDao.search(sc4, filter);\n                    if ((vmDiskStats != null) && !vmDiskStats.isEmpty()) {\n                        \/\/ now copy the accounts to cloud_usage db\n                        _usageDao.updateVmDiskStats(vmDiskStats);\n                    }\n                    offset = new Long(offset.longValue() + limit.longValue());\n                } while ((vmDiskStats != null) && !vmDiskStats.isEmpty());\n                \/\/ reset offset\n                offset = Long.valueOf(0);\n                sc4 = _vmDiskStatsDao.createSearchCriteria();\n                sc4.addAnd(\"id\", SearchCriteria.Op.GT, lastVmDiskStatsId);\n                do {\n                    Filter filter = new Filter(VmDiskStatisticsVO.class, \"id\", true, offset, limit);\n                    vmDiskStats = _vmDiskStatsDao.search(sc4, filter);\n                    if ((vmDiskStats != null) && !vmDiskStats.isEmpty()) {\n                        \/\/ now copy the accounts to cloud_usage db\n                        _usageDao.saveVmDiskStats(vmDiskStats);\n                    }\n                    offset = new Long(offset.longValue() + limit.longValue());\n                } while ((vmDiskStats != null) && !vmDiskStats.isEmpty());\n            } finally {\n                userTxn.close();\n            }\n            \/\/ TODO:  Fetch a maximum number of events and process them before moving on to the next range of events\n            \/\/ - get a list of the latest events\n            \/\/ - insert the latest events into the usage.events table\n            List<UsageEventVO> events = _usageEventDao.getRecentEvents(new Date(endDateMillis));\n            TransactionLegacy usageTxn = TransactionLegacy.open(TransactionLegacy.USAGE_DB);\n            try {\n                usageTxn.start();\n                \/\/ make sure start date is before all of our un-processed events (the events are ordered oldest\n                \/\/ to newest, so just test against the first event)\n                if ((events != null) && (events.size() > 0)) {\n                    Date oldestEventDate = events.get(0).getCreateDate();\n                    if (oldestEventDate.getTime() < startDateMillis) {\n                        startDateMillis = oldestEventDate.getTime();\n                        startDate = new Date(startDateMillis);\n                    }\n                    \/\/ - loop over the list of events and create entries in the helper tables\n                    \/\/ - create the usage records using the parse methods below\n                    for (UsageEventVO event : events) {\n                        event.setProcessed(true);\n                        _usageEventDao.update(event.getId(), event);\n                        createHelperRecord(event);\n                    }\n                }\n                \/\/ TODO:  Fetch a maximum number of user stats and process them before moving on to the next range of user stats\n                \/\/ get user stats in order to compute network usage\n                networkStats = _usageNetworkDao.getRecentNetworkStats();\n                Calendar recentlyDeletedCal = Calendar.getInstance(_usageTimezone);\n                recentlyDeletedCal.setTimeInMillis(startDateMillis);\n                recentlyDeletedCal.add(Calendar.MINUTE, -1 * THREE_DAYS_IN_MINUTES);\n                Date recentlyDeletedDate = recentlyDeletedCal.getTime();\n                \/\/ Keep track of user stats for an account, across all of its public IPs\n                Map<String, UserStatisticsVO> aggregatedStats = new HashMap<String, UserStatisticsVO>();\n                int startIndex = 0;\n                do {\n                    userStats = _userStatsDao.listActiveAndRecentlyDeleted(recentlyDeletedDate, startIndex, 500);\n                    if (userStats != null) {\n                        for (UserStatisticsVO userStat : userStats) {\n                            if (userStat.getDeviceId() != null) {\n                                String hostKey = userStat.getDataCenterId() + \"-\" + userStat.getAccountId() + \"-Host-\" + userStat.getDeviceId();\n                                UserStatisticsVO hostAggregatedStat = aggregatedStats.get(hostKey);\n                                if (hostAggregatedStat == null) {\n                                    hostAggregatedStat =\n                                            new UserStatisticsVO(userStat.getAccountId(), userStat.getDataCenterId(), userStat.getPublicIpAddress(), userStat.getDeviceId(),\n                                                    userStat.getDeviceType(), userStat.getNetworkId());\n                                }\n                                hostAggregatedStat.setAggBytesSent(hostAggregatedStat.getAggBytesSent() + userStat.getAggBytesSent());\n                                hostAggregatedStat.setAggBytesReceived(hostAggregatedStat.getAggBytesReceived() + userStat.getAggBytesReceived());\n                                aggregatedStats.put(hostKey, hostAggregatedStat);\n                            }\n                        }\n                    }\n                    startIndex += 500;\n                } while ((userStats != null) && !userStats.isEmpty());\n                \/\/ loop over the user stats, create delta entries in the usage_network helper table\n                int numAcctsProcessed = 0;\n                usageNetworks.clear();\n                for (String key : aggregatedStats.keySet()) {\n                    UsageNetworkVO currentNetworkStats = null;\n                    if (networkStats != null) {\n                        currentNetworkStats = networkStats.get(key);\n                    }\n                    createNetworkHelperEntry(aggregatedStats.get(key), currentNetworkStats, endDateMillis);\n                    numAcctsProcessed++;\n                }\n                _usageNetworkDao.saveUsageNetworks(usageNetworks);\n                if (s_logger.isDebugEnabled()) {\n                    s_logger.debug(\"created network stats helper entries for \" + numAcctsProcessed + \" accts\");\n                }\n                \/\/ get vm disk stats in order to compute vm disk usage\n                vmDiskUsages = _usageVmDiskDao.getRecentVmDiskStats();\n                \/\/ Keep track of user stats for an account, across all of its public IPs\n                Map<String, VmDiskStatisticsVO> aggregatedDiskStats = new HashMap<String, VmDiskStatisticsVO>();\n                startIndex = 0;\n                do {\n                    vmDiskStats = _vmDiskStatsDao.listActiveAndRecentlyDeleted(recentlyDeletedDate, startIndex, 500);\n                    if (vmDiskUsages != null) {\n                        for (VmDiskStatisticsVO vmDiskStat : vmDiskStats) {\n                            if (vmDiskStat.getVmId() != null) {\n                                String hostKey =\n                                        vmDiskStat.getDataCenterId() + \"-\" + vmDiskStat.getAccountId() + \"-Vm-\" + vmDiskStat.getVmId() + \"-Disk-\" + vmDiskStat.getVolumeId();\n                                VmDiskStatisticsVO hostAggregatedStat = aggregatedDiskStats.get(hostKey);\n                                if (hostAggregatedStat == null) {\n                                    hostAggregatedStat =\n                                            new VmDiskStatisticsVO(vmDiskStat.getAccountId(), vmDiskStat.getDataCenterId(), vmDiskStat.getVmId(), vmDiskStat.getVolumeId());\n                                }\n                                hostAggregatedStat.setAggIORead(hostAggregatedStat.getAggIORead() + vmDiskStat.getAggIORead());\n                                hostAggregatedStat.setAggIOWrite(hostAggregatedStat.getAggIOWrite() + vmDiskStat.getAggIOWrite());\n                                hostAggregatedStat.setAggBytesRead(hostAggregatedStat.getAggBytesRead() + vmDiskStat.getAggBytesRead());\n                                hostAggregatedStat.setAggBytesWrite(hostAggregatedStat.getAggBytesWrite() + vmDiskStat.getAggBytesWrite());\n                                aggregatedDiskStats.put(hostKey, hostAggregatedStat);\n                            }\n                        }\n                    }\n                    startIndex += 500;\n                } while ((userStats != null) && !userStats.isEmpty());\n                \/\/ loop over the user stats, create delta entries in the usage_disk helper table\n                numAcctsProcessed = 0;\n                usageVmDisks.clear();\n                for (String key : aggregatedDiskStats.keySet()) {\n                    UsageVmDiskVO currentVmDiskStats = null;\n                    if (vmDiskStats != null) {\n                        currentVmDiskStats = vmDiskUsages.get(key);\n                    }\n                    createVmDiskHelperEntry(aggregatedDiskStats.get(key), currentVmDiskStats, endDateMillis);\n                    numAcctsProcessed++;\n                }\n                _usageVmDiskDao.saveUsageVmDisks(usageVmDisks);\n                if (s_logger.isDebugEnabled()) {\n                    s_logger.debug(\"created vm disk stats helper entries for \" + numAcctsProcessed + \" accts\");\n                }\n                \/\/ commit the helper records, then start a new transaction\n                usageTxn.commit();\n                usageTxn.start();\n                boolean parsed = false;\n                numAcctsProcessed = 0;\n                Date currentStartDate = startDate;\n                Date currentEndDate = endDate;\n                Date tempDate = endDate;\n                Calendar aggregateCal = Calendar.getInstance(_usageTimezone);\n                while ((tempDate.after(startDate)) && ((tempDate.getTime() - startDate.getTime()) > 60000)) {\n                    currentEndDate = tempDate;\n                    aggregateCal.setTime(tempDate);\n                    aggregateCal.add(Calendar.MINUTE, -_aggregationDuration);\n                    tempDate = aggregateCal.getTime();\n                }\n                while (!currentEndDate.after(endDate) || (currentEndDate.getTime() - endDate.getTime() < 60000)) {\n                    Long offset = Long.valueOf(0);\n                    Long limit = Long.valueOf(500);\n                    do {\n                        Filter filter = new Filter(AccountVO.class, \"id\", true, offset, limit);\n                        accounts = _accountDao.listAll(filter);\n                        if ((accounts != null) && !accounts.isEmpty()) {\n                            for (AccountVO account : accounts) {\n                                parsed = parseHelperTables(account, currentStartDate, currentEndDate);\n                                numAcctsProcessed++;\n                            }\n                        }\n                        offset = new Long(offset.longValue() + limit.longValue());\n                    } while ((accounts != null) && !accounts.isEmpty());\n                    if (s_logger.isDebugEnabled()) {\n                        s_logger.debug(\"processed VM\/Network Usage for \" + numAcctsProcessed + \" ACTIVE accts\");\n                    }\n                    numAcctsProcessed = 0;\n                    \/\/ reset offset\n                    offset = Long.valueOf(0);\n                    do {\n                        Filter filter = new Filter(AccountVO.class, \"id\", true, offset, limit);\n                        accounts = _accountDao.findRecentlyDeletedAccounts(null, recentlyDeletedDate, filter);\n                        if ((accounts != null) && !accounts.isEmpty()) {\n                            for (AccountVO account : accounts) {\n                                parsed = parseHelperTables(account, currentStartDate, currentEndDate);\n                                List<Long> publicTemplates = _usageDao.listPublicTemplatesByAccount(account.getId());\n                                for (Long templateId : publicTemplates) {\n                                    \/\/mark public templates owned by deleted accounts as deleted\n                                    List<UsageStorageVO> storageVOs = _usageStorageDao.listById(account.getId(), templateId, StorageTypes.TEMPLATE);\n                                    if (storageVOs.size() > 1) {\n                                        s_logger.warn(\"More that one usage entry for storage: \" + templateId + \" assigned to account: \" + account.getId() +\n                                                \"; marking them all as deleted...\");\n                                    }\n                                    for (UsageStorageVO storageVO : storageVOs) {\n                                        if (s_logger.isDebugEnabled()) {\n                                            s_logger.debug(\"deleting template: \" + storageVO.getId() + \" from account: \" + storageVO.getAccountId());\n                                        }\n                                        storageVO.setDeleted(account.getRemoved());\n                                        _usageStorageDao.update(storageVO);\n                                    }\n                                }\n                                numAcctsProcessed++;\n                            }\n                        }\n                        offset = new Long(offset.longValue() + limit.longValue());\n                    } while ((accounts != null) && !accounts.isEmpty());\n                    currentStartDate = new Date(currentEndDate.getTime() + 1);\n                    aggregateCal.setTime(currentEndDate);\n                    aggregateCal.add(Calendar.MINUTE, _aggregationDuration);\n                    currentEndDate = aggregateCal.getTime();\n                }\n                if (s_logger.isDebugEnabled()) {\n                    s_logger.debug(\"processed Usage for \" + numAcctsProcessed + \" RECENTLY DELETED accts\");\n                }\n                \/\/ FIXME: we don't break the above loop if something fails to parse, so it gets reset every account,\n                \/\/        do we want to break out of processing accounts and rollback if there are errors?\n                if (!parsed) {\n                    usageTxn.rollback();\n                } else {\n                    success = true;\n                }\n            } catch (Exception ex) {\n                s_logger.error(\"Exception in usage manager\", ex);\n                usageTxn.rollback();\n            } finally {\n                \/\/ everything seemed to work...set endDate as the last success date\n                _usageJobDao.updateJobSuccess(job.getId(), startDateMillis, endDateMillis, System.currentTimeMillis() - timeStart, success);\n                \/\/ create a new job if this is a recurring job\n                if (job.getJobType() == UsageJobVO.JOB_TYPE_RECURRING) {\n                    _usageJobDao.createNewJob(_hostname, _pid, UsageJobVO.JOB_TYPE_RECURRING);\n                }\n                usageTxn.commit();\n                usageTxn.close();\n                \/\/ switch back to CLOUD_DB\n                TransactionLegacy swap = TransactionLegacy.open(TransactionLegacy.CLOUD_DB);\n                if (!success) {\n                    _alertMgr.sendAlert(AlertManager.AlertType.ALERT_TYPE_USAGE_SERVER_RESULT, 0, new Long(0), \"Usage job failed. Job id: \" + job.getId(),\n                            \"Usage job failed. Job id: \" + job.getId());\n                } else {\n                    _alertMgr.clearAlert(AlertManager.AlertType.ALERT_TYPE_USAGE_SERVER_RESULT, 0, 0);\n                }\n                swap.close();\n            }\n        } catch (Exception e) {\n            s_logger.error(\"Usage Manager error\", e);\n        }\n    }","code":"@Override\n    public void parse(UsageJobVO job, long startDateMillis, long endDateMillis) {\n       \n        boolean success = false;\n        long timeStart = System.currentTimeMillis();\n        try {\n            if ((endDateMillis == 0) || (endDateMillis > timeStart)) {\n                endDateMillis = timeStart;\n            }\n            long lastSuccess = _usageJobDao.getLastJobSuccessDateMillis();\n            if (lastSuccess != 0) {\n                startDateMillis = lastSuccess + 1;\n            }\n            if (startDateMillis >= endDateMillis) {\n                if (s_logger.isInfoEnabled()) {\n                    s_logger.info(\"not parsing usage records since start time mills (\" + startDateMillis + \") is on or after end time millis (\" + endDateMillis + \")\");\n                }\n                TransactionLegacy jobUpdateTxn = TransactionLegacy.open(TransactionLegacy.USAGE_DB);\n                try {\n                    jobUpdateTxn.start();\n                   \n                    _usageJobDao.updateJobSuccess(job.getId(), startDateMillis, endDateMillis, System.currentTimeMillis() - timeStart, success);\n                   \n                    if (job.getJobType() == UsageJobVO.JOB_TYPE_RECURRING) {\n                        _usageJobDao.createNewJob(_hostname, _pid, UsageJobVO.JOB_TYPE_RECURRING);\n                    }\n                    jobUpdateTxn.commit();\n                } finally {\n                    jobUpdateTxn.close();\n                }\n                return;\n            }\n            Date startDate = new Date(startDateMillis);\n            Date endDate = new Date(endDateMillis);\n            if (s_logger.isInfoEnabled()) {\n                s_logger.info(\"Parsing usage records between \" + startDate + \" and \" + endDate);\n            }\n            List<AccountVO> accounts = null;\n            List<UserStatisticsVO> userStats = null;\n            Map<String, UsageNetworkVO> networkStats = null;\n            List<VmDiskStatisticsVO> vmDiskStats = null;\n            Map<String, UsageVmDiskVO> vmDiskUsages = null;\n            TransactionLegacy userTxn = TransactionLegacy.open(TransactionLegacy.CLOUD_DB);\n            try {\n                Long limit = Long.valueOf(500);\n                Long offset = Long.valueOf(0);\n                Long lastAccountId = _usageDao.getLastAccountId();\n                if (lastAccountId == null) {\n                    lastAccountId = Long.valueOf(0);\n                }\n                do {\n                    Filter filter = new Filter(AccountVO.class, \"id\", true, offset, limit);\n                    accounts = _accountDao.findActiveAccounts(lastAccountId, filter);\n                    if ((accounts != null) && !accounts.isEmpty()) {\n                       \n                        _usageDao.updateAccounts(accounts);\n                    }\n                    offset = new Long(offset.longValue() + limit.longValue());\n                } while ((accounts != null) && !accounts.isEmpty());\n               \n                offset = Long.valueOf(0);\n                do {\n                    Filter filter = new Filter(AccountVO.class, \"id\", true, offset, limit);\n                    accounts = _accountDao.findRecentlyDeletedAccounts(lastAccountId, startDate, filter);\n                    if ((accounts != null) && !accounts.isEmpty()) {\n                       \n                        _usageDao.updateAccounts(accounts);\n                    }\n                    offset = new Long(offset.longValue() + limit.longValue());\n                } while ((accounts != null) && !accounts.isEmpty());\n               \n                offset = Long.valueOf(0);\n                do {\n                    Filter filter = new Filter(AccountVO.class, \"id\", true, offset, limit);\n                    accounts = _accountDao.findNewAccounts(lastAccountId, filter);\n                    if ((accounts != null) && !accounts.isEmpty()) {\n                       \n                        _usageDao.saveAccounts(accounts);\n                    }\n                    offset = new Long(offset.longValue() + limit.longValue());\n                } while ((accounts != null) && !accounts.isEmpty());\n               \n                offset = Long.valueOf(0);\n               \n                Long lastUserStatsId = _usageDao.getLastUserStatsId();\n                if (lastUserStatsId == null) {\n                    lastUserStatsId = Long.valueOf(0);\n                }\n                SearchCriteria<UserStatisticsVO> sc2 = _userStatsDao.createSearchCriteria();\n                sc2.addAnd(\"id\", SearchCriteria.Op.LTEQ, lastUserStatsId);\n                do {\n                    Filter filter = new Filter(UserStatisticsVO.class, \"id\", true, offset, limit);\n                    userStats = _userStatsDao.search(sc2, filter);\n                    if ((userStats != null) && !userStats.isEmpty()) {\n                       \n                        _usageDao.updateUserStats(userStats);\n                    }\n                    offset = new Long(offset.longValue() + limit.longValue());\n                } while ((userStats != null) && !userStats.isEmpty());\n               \n                offset = Long.valueOf(0);\n                sc2 = _userStatsDao.createSearchCriteria();\n                sc2.addAnd(\"id\", SearchCriteria.Op.GT, lastUserStatsId);\n                do {\n                    Filter filter = new Filter(UserStatisticsVO.class, \"id\", true, offset, limit);\n                    userStats = _userStatsDao.search(sc2, filter);\n                    if ((userStats != null) && !userStats.isEmpty()) {\n                       \n                        _usageDao.saveUserStats(userStats);\n                    }\n                    offset = new Long(offset.longValue() + limit.longValue());\n                } while ((userStats != null) && !userStats.isEmpty());\n               \n                offset = Long.valueOf(0);\n               \n                Long lastVmDiskStatsId = _usageDao.getLastVmDiskStatsId();\n                if (lastVmDiskStatsId == null) {\n                    lastVmDiskStatsId = Long.valueOf(0);\n                }\n                SearchCriteria<VmDiskStatisticsVO> sc4 = _vmDiskStatsDao.createSearchCriteria();\n                sc4.addAnd(\"id\", SearchCriteria.Op.LTEQ, lastVmDiskStatsId);\n                do {\n                    Filter filter = new Filter(VmDiskStatisticsVO.class, \"id\", true, offset, limit);\n                    vmDiskStats = _vmDiskStatsDao.search(sc4, filter);\n                    if ((vmDiskStats != null) && !vmDiskStats.isEmpty()) {\n                       \n                        _usageDao.updateVmDiskStats(vmDiskStats);\n                    }\n                    offset = new Long(offset.longValue() + limit.longValue());\n                } while ((vmDiskStats != null) && !vmDiskStats.isEmpty());\n               \n                offset = Long.valueOf(0);\n                sc4 = _vmDiskStatsDao.createSearchCriteria();\n                sc4.addAnd(\"id\", SearchCriteria.Op.GT, lastVmDiskStatsId);\n                do {\n                    Filter filter = new Filter(VmDiskStatisticsVO.class, \"id\", true, offset, limit);\n                    vmDiskStats = _vmDiskStatsDao.search(sc4, filter);\n                    if ((vmDiskStats != null) && !vmDiskStats.isEmpty()) {\n                       \n                        _usageDao.saveVmDiskStats(vmDiskStats);\n                    }\n                    offset = new Long(offset.longValue() + limit.longValue());\n                } while ((vmDiskStats != null) && !vmDiskStats.isEmpty());\n            } finally {\n                userTxn.close();\n            }\n           \n           \n           \n            List<UsageEventVO> events = _usageEventDao.getRecentEvents(new Date(endDateMillis));\n            TransactionLegacy usageTxn = TransactionLegacy.open(TransactionLegacy.USAGE_DB);\n            try {\n                usageTxn.start();\n               \n               \n                if ((events != null) && (events.size() > 0)) {\n                    Date oldestEventDate = events.get(0).getCreateDate();\n                    if (oldestEventDate.getTime() < startDateMillis) {\n                        startDateMillis = oldestEventDate.getTime();\n                        startDate = new Date(startDateMillis);\n                    }\n                   \n                   \n                    for (UsageEventVO event : events) {\n                        event.setProcessed(true);\n                        _usageEventDao.update(event.getId(), event);\n                        createHelperRecord(event);\n                    }\n                }\n               \n               \n                networkStats = _usageNetworkDao.getRecentNetworkStats();\n                Calendar recentlyDeletedCal = Calendar.getInstance(_usageTimezone);\n                recentlyDeletedCal.setTimeInMillis(startDateMillis);\n                recentlyDeletedCal.add(Calendar.MINUTE, -1 * THREE_DAYS_IN_MINUTES);\n                Date recentlyDeletedDate = recentlyDeletedCal.getTime();\n               \n                Map<String, UserStatisticsVO> aggregatedStats = new HashMap<String, UserStatisticsVO>();\n                int startIndex = 0;\n                do {\n                    userStats = _userStatsDao.listActiveAndRecentlyDeleted(recentlyDeletedDate, startIndex, 500);\n                    if (userStats != null) {\n                        for (UserStatisticsVO userStat : userStats) {\n                            if (userStat.getDeviceId() != null) {\n                                String hostKey = userStat.getDataCenterId() + \"-\" + userStat.getAccountId() + \"-Host-\" + userStat.getDeviceId();\n                                UserStatisticsVO hostAggregatedStat = aggregatedStats.get(hostKey);\n                                if (hostAggregatedStat == null) {\n                                    hostAggregatedStat =\n                                            new UserStatisticsVO(userStat.getAccountId(), userStat.getDataCenterId(), userStat.getPublicIpAddress(), userStat.getDeviceId(),\n                                                    userStat.getDeviceType(), userStat.getNetworkId());\n                                }\n                                hostAggregatedStat.setAggBytesSent(hostAggregatedStat.getAggBytesSent() + userStat.getAggBytesSent());\n                                hostAggregatedStat.setAggBytesReceived(hostAggregatedStat.getAggBytesReceived() + userStat.getAggBytesReceived());\n                                aggregatedStats.put(hostKey, hostAggregatedStat);\n                            }\n                        }\n                    }\n                    startIndex += 500;\n                } while ((userStats != null) && !userStats.isEmpty());\n               \n                int numAcctsProcessed = 0;\n                usageNetworks.clear();\n                for (String key : aggregatedStats.keySet()) {\n                    UsageNetworkVO currentNetworkStats = null;\n                    if (networkStats != null) {\n                        currentNetworkStats = networkStats.get(key);\n                    }\n                    createNetworkHelperEntry(aggregatedStats.get(key), currentNetworkStats, endDateMillis);\n                    numAcctsProcessed++;\n                }\n                _usageNetworkDao.saveUsageNetworks(usageNetworks);\n                if (s_logger.isDebugEnabled()) {\n                    s_logger.debug(\"created network stats helper entries for \" + numAcctsProcessed + \" accts\");\n                }\n               \n                vmDiskUsages = _usageVmDiskDao.getRecentVmDiskStats();\n               \n                Map<String, VmDiskStatisticsVO> aggregatedDiskStats = new HashMap<String, VmDiskStatisticsVO>();\n                startIndex = 0;\n                do {\n                    vmDiskStats = _vmDiskStatsDao.listActiveAndRecentlyDeleted(recentlyDeletedDate, startIndex, 500);\n                    if (vmDiskUsages != null) {\n                        for (VmDiskStatisticsVO vmDiskStat : vmDiskStats) {\n                            if (vmDiskStat.getVmId() != null) {\n                                String hostKey =\n                                        vmDiskStat.getDataCenterId() + \"-\" + vmDiskStat.getAccountId() + \"-Vm-\" + vmDiskStat.getVmId() + \"-Disk-\" + vmDiskStat.getVolumeId();\n                                VmDiskStatisticsVO hostAggregatedStat = aggregatedDiskStats.get(hostKey);\n                                if (hostAggregatedStat == null) {\n                                    hostAggregatedStat =\n                                            new VmDiskStatisticsVO(vmDiskStat.getAccountId(), vmDiskStat.getDataCenterId(), vmDiskStat.getVmId(), vmDiskStat.getVolumeId());\n                                }\n                                hostAggregatedStat.setAggIORead(hostAggregatedStat.getAggIORead() + vmDiskStat.getAggIORead());\n                                hostAggregatedStat.setAggIOWrite(hostAggregatedStat.getAggIOWrite() + vmDiskStat.getAggIOWrite());\n                                hostAggregatedStat.setAggBytesRead(hostAggregatedStat.getAggBytesRead() + vmDiskStat.getAggBytesRead());\n                                hostAggregatedStat.setAggBytesWrite(hostAggregatedStat.getAggBytesWrite() + vmDiskStat.getAggBytesWrite());\n                                aggregatedDiskStats.put(hostKey, hostAggregatedStat);\n                            }\n                        }\n                    }\n                    startIndex += 500;\n                } while ((userStats != null) && !userStats.isEmpty());\n               \n                numAcctsProcessed = 0;\n                usageVmDisks.clear();\n                for (String key : aggregatedDiskStats.keySet()) {\n                    UsageVmDiskVO currentVmDiskStats = null;\n                    if (vmDiskStats != null) {\n                        currentVmDiskStats = vmDiskUsages.get(key);\n                    }\n                    createVmDiskHelperEntry(aggregatedDiskStats.get(key), currentVmDiskStats, endDateMillis);\n                    numAcctsProcessed++;\n                }\n                _usageVmDiskDao.saveUsageVmDisks(usageVmDisks);\n                if (s_logger.isDebugEnabled()) {\n                    s_logger.debug(\"created vm disk stats helper entries for \" + numAcctsProcessed + \" accts\");\n                }\n               \n                usageTxn.commit();\n                usageTxn.start();\n                boolean parsed = false;\n                numAcctsProcessed = 0;\n                Date currentStartDate = startDate;\n                Date currentEndDate = endDate;\n                Date tempDate = endDate;\n                Calendar aggregateCal = Calendar.getInstance(_usageTimezone);\n                while ((tempDate.after(startDate)) && ((tempDate.getTime() - startDate.getTime()) > 60000)) {\n                    currentEndDate = tempDate;\n                    aggregateCal.setTime(tempDate);\n                    aggregateCal.add(Calendar.MINUTE, -_aggregationDuration);\n                    tempDate = aggregateCal.getTime();\n                }\n                while (!currentEndDate.after(endDate) || (currentEndDate.getTime() - endDate.getTime() < 60000)) {\n                    Long offset = Long.valueOf(0);\n                    Long limit = Long.valueOf(500);\n                    do {\n                        Filter filter = new Filter(AccountVO.class, \"id\", true, offset, limit);\n                        accounts = _accountDao.listAll(filter);\n                        if ((accounts != null) && !accounts.isEmpty()) {\n                            for (AccountVO account : accounts) {\n                                parsed = parseHelperTables(account, currentStartDate, currentEndDate);\n                                numAcctsProcessed++;\n                            }\n                        }\n                        offset = new Long(offset.longValue() + limit.longValue());\n                    } while ((accounts != null) && !accounts.isEmpty());\n                    if (s_logger.isDebugEnabled()) {\n                        s_logger.debug(\"processed VM\/Network Usage for \" + numAcctsProcessed + \" ACTIVE accts\");\n                    }\n                    numAcctsProcessed = 0;\n                   \n                    offset = Long.valueOf(0);\n                    do {\n                        Filter filter = new Filter(AccountVO.class, \"id\", true, offset, limit);\n                        accounts = _accountDao.findRecentlyDeletedAccounts(null, recentlyDeletedDate, filter);\n                        if ((accounts != null) && !accounts.isEmpty()) {\n                            for (AccountVO account : accounts) {\n                                parsed = parseHelperTables(account, currentStartDate, currentEndDate);\n                                List<Long> publicTemplates = _usageDao.listPublicTemplatesByAccount(account.getId());\n                                for (Long templateId : publicTemplates) {\n                                   \n                                    List<UsageStorageVO> storageVOs = _usageStorageDao.listById(account.getId(), templateId, StorageTypes.TEMPLATE);\n                                    if (storageVOs.size() > 1) {\n                                        s_logger.warn(\"More that one usage entry for storage: \" + templateId + \" assigned to account: \" + account.getId() +\n                                                \"; marking them all as deleted...\");\n                                    }\n                                    for (UsageStorageVO storageVO : storageVOs) {\n                                        if (s_logger.isDebugEnabled()) {\n                                            s_logger.debug(\"deleting template: \" + storageVO.getId() + \" from account: \" + storageVO.getAccountId());\n                                        }\n                                        storageVO.setDeleted(account.getRemoved());\n                                        _usageStorageDao.update(storageVO);\n                                    }\n                                }\n                                numAcctsProcessed++;\n                            }\n                        }\n                        offset = new Long(offset.longValue() + limit.longValue());\n                    } while ((accounts != null) && !accounts.isEmpty());\n                    currentStartDate = new Date(currentEndDate.getTime() + 1);\n                    aggregateCal.setTime(currentEndDate);\n                    aggregateCal.add(Calendar.MINUTE, _aggregationDuration);\n                    currentEndDate = aggregateCal.getTime();\n                }\n                if (s_logger.isDebugEnabled()) {\n                    s_logger.debug(\"processed Usage for \" + numAcctsProcessed + \" RECENTLY DELETED accts\");\n                }\n               \n               \n                if (!parsed) {\n                    usageTxn.rollback();\n                } else {\n                    success = true;\n                }\n            } catch (Exception ex) {\n                s_logger.error(\"Exception in usage manager\", ex);\n                usageTxn.rollback();\n            } finally {\n               \n                _usageJobDao.updateJobSuccess(job.getId(), startDateMillis, endDateMillis, System.currentTimeMillis() - timeStart, success);\n               \n                if (job.getJobType() == UsageJobVO.JOB_TYPE_RECURRING) {\n                    _usageJobDao.createNewJob(_hostname, _pid, UsageJobVO.JOB_TYPE_RECURRING);\n                }\n                usageTxn.commit();\n                usageTxn.close();\n               \n                TransactionLegacy swap = TransactionLegacy.open(TransactionLegacy.CLOUD_DB);\n                if (!success) {\n                    _alertMgr.sendAlert(AlertManager.AlertType.ALERT_TYPE_USAGE_SERVER_RESULT, 0, new Long(0), \"Usage job failed. Job id: \" + job.getId(),\n                            \"Usage job failed. Job id: \" + job.getId());\n                } else {\n                    _alertMgr.clearAlert(AlertManager.AlertType.ALERT_TYPE_USAGE_SERVER_RESULT, 0, 0);\n                }\n                swap.close();\n            }\n        } catch (Exception e) {\n            s_logger.error(\"Usage Manager error\", e);\n        }\n    }","cleancode":"@override public void parse(usagejobvo job, long startdatemillis, long enddatemillis) { boolean success = false; long timestart = system.currenttimemillis(); try { if ((enddatemillis == 0) || (enddatemillis > timestart)) { enddatemillis = timestart; } long lastsuccess = _usagejobdao.getlastjobsuccessdatemillis(); if (lastsuccess != 0) { startdatemillis = lastsuccess + 1; } if (startdatemillis >= enddatemillis) { if (s_logger.isinfoenabled()) { s_logger.info(\"not parsing usage records since start time mills (\" + startdatemillis + \") is on or after end time millis (\" + enddatemillis + \")\"); } transactionlegacy jobupdatetxn = transactionlegacy.open(transactionlegacy.usage_db); try { jobupdatetxn.start(); _usagejobdao.updatejobsuccess(job.getid(), startdatemillis, enddatemillis, system.currenttimemillis() - timestart, success); if (job.getjobtype() == usagejobvo.job_type_recurring) { _usagejobdao.createnewjob(_hostname, _pid, usagejobvo.job_type_recurring); } jobupdatetxn.commit(); } finally { jobupdatetxn.close(); } return; } date startdate = new date(startdatemillis); date enddate = new date(enddatemillis); if (s_logger.isinfoenabled()) { s_logger.info(\"parsing usage records between \" + startdate + \" and \" + enddate); } list<accountvo> accounts = null; list<userstatisticsvo> userstats = null; map<string, usagenetworkvo> networkstats = null; list<vmdiskstatisticsvo> vmdiskstats = null; map<string, usagevmdiskvo> vmdiskusages = null; transactionlegacy usertxn = transactionlegacy.open(transactionlegacy.cloud_db); try { long limit = long.valueof(500); long offset = long.valueof(0); long lastaccountid = _usagedao.getlastaccountid(); if (lastaccountid == null) { lastaccountid = long.valueof(0); } do { filter filter = new filter(accountvo.class, \"id\", true, offset, limit); accounts = _accountdao.findactiveaccounts(lastaccountid, filter); if ((accounts != null) && !accounts.isempty()) { _usagedao.updateaccounts(accounts); } offset = new long(offset.longvalue() + limit.longvalue()); } while ((accounts != null) && !accounts.isempty()); offset = long.valueof(0); do { filter filter = new filter(accountvo.class, \"id\", true, offset, limit); accounts = _accountdao.findrecentlydeletedaccounts(lastaccountid, startdate, filter); if ((accounts != null) && !accounts.isempty()) { _usagedao.updateaccounts(accounts); } offset = new long(offset.longvalue() + limit.longvalue()); } while ((accounts != null) && !accounts.isempty()); offset = long.valueof(0); do { filter filter = new filter(accountvo.class, \"id\", true, offset, limit); accounts = _accountdao.findnewaccounts(lastaccountid, filter); if ((accounts != null) && !accounts.isempty()) { _usagedao.saveaccounts(accounts); } offset = new long(offset.longvalue() + limit.longvalue()); } while ((accounts != null) && !accounts.isempty()); offset = long.valueof(0); long lastuserstatsid = _usagedao.getlastuserstatsid(); if (lastuserstatsid == null) { lastuserstatsid = long.valueof(0); } searchcriteria<userstatisticsvo> sc2 = _userstatsdao.createsearchcriteria(); sc2.addand(\"id\", searchcriteria.op.lteq, lastuserstatsid); do { filter filter = new filter(userstatisticsvo.class, \"id\", true, offset, limit); userstats = _userstatsdao.search(sc2, filter); if ((userstats != null) && !userstats.isempty()) { _usagedao.updateuserstats(userstats); } offset = new long(offset.longvalue() + limit.longvalue()); } while ((userstats != null) && !userstats.isempty()); offset = long.valueof(0); sc2 = _userstatsdao.createsearchcriteria(); sc2.addand(\"id\", searchcriteria.op.gt, lastuserstatsid); do { filter filter = new filter(userstatisticsvo.class, \"id\", true, offset, limit); userstats = _userstatsdao.search(sc2, filter); if ((userstats != null) && !userstats.isempty()) { _usagedao.saveuserstats(userstats); } offset = new long(offset.longvalue() + limit.longvalue()); } while ((userstats != null) && !userstats.isempty()); offset = long.valueof(0); long lastvmdiskstatsid = _usagedao.getlastvmdiskstatsid(); if (lastvmdiskstatsid == null) { lastvmdiskstatsid = long.valueof(0); } searchcriteria<vmdiskstatisticsvo> sc4 = _vmdiskstatsdao.createsearchcriteria(); sc4.addand(\"id\", searchcriteria.op.lteq, lastvmdiskstatsid); do { filter filter = new filter(vmdiskstatisticsvo.class, \"id\", true, offset, limit); vmdiskstats = _vmdiskstatsdao.search(sc4, filter); if ((vmdiskstats != null) && !vmdiskstats.isempty()) { _usagedao.updatevmdiskstats(vmdiskstats); } offset = new long(offset.longvalue() + limit.longvalue()); } while ((vmdiskstats != null) && !vmdiskstats.isempty()); offset = long.valueof(0); sc4 = _vmdiskstatsdao.createsearchcriteria(); sc4.addand(\"id\", searchcriteria.op.gt, lastvmdiskstatsid); do { filter filter = new filter(vmdiskstatisticsvo.class, \"id\", true, offset, limit); vmdiskstats = _vmdiskstatsdao.search(sc4, filter); if ((vmdiskstats != null) && !vmdiskstats.isempty()) { _usagedao.savevmdiskstats(vmdiskstats); } offset = new long(offset.longvalue() + limit.longvalue()); } while ((vmdiskstats != null) && !vmdiskstats.isempty()); } finally { usertxn.close(); } list<usageeventvo> events = _usageeventdao.getrecentevents(new date(enddatemillis)); transactionlegacy usagetxn = transactionlegacy.open(transactionlegacy.usage_db); try { usagetxn.start(); if ((events != null) && (events.size() > 0)) { date oldesteventdate = events.get(0).getcreatedate(); if (oldesteventdate.gettime() < startdatemillis) { startdatemillis = oldesteventdate.gettime(); startdate = new date(startdatemillis); } for (usageeventvo event : events) { event.setprocessed(true); _usageeventdao.update(event.getid(), event); createhelperrecord(event); } } networkstats = _usagenetworkdao.getrecentnetworkstats(); calendar recentlydeletedcal = calendar.getinstance(_usagetimezone); recentlydeletedcal.settimeinmillis(startdatemillis); recentlydeletedcal.add(calendar.minute, -1 * three_days_in_minutes); date recentlydeleteddate = recentlydeletedcal.gettime(); map<string, userstatisticsvo> aggregatedstats = new hashmap<string, userstatisticsvo>(); int startindex = 0; do { userstats = _userstatsdao.listactiveandrecentlydeleted(recentlydeleteddate, startindex, 500); if (userstats != null) { for (userstatisticsvo userstat : userstats) { if (userstat.getdeviceid() != null) { string hostkey = userstat.getdatacenterid() + \"-\" + userstat.getaccountid() + \"-host-\" + userstat.getdeviceid(); userstatisticsvo hostaggregatedstat = aggregatedstats.get(hostkey); if (hostaggregatedstat == null) { hostaggregatedstat = new userstatisticsvo(userstat.getaccountid(), userstat.getdatacenterid(), userstat.getpublicipaddress(), userstat.getdeviceid(), userstat.getdevicetype(), userstat.getnetworkid()); } hostaggregatedstat.setaggbytessent(hostaggregatedstat.getaggbytessent() + userstat.getaggbytessent()); hostaggregatedstat.setaggbytesreceived(hostaggregatedstat.getaggbytesreceived() + userstat.getaggbytesreceived()); aggregatedstats.put(hostkey, hostaggregatedstat); } } } startindex += 500; } while ((userstats != null) && !userstats.isempty()); int numacctsprocessed = 0; usagenetworks.clear(); for (string key : aggregatedstats.keyset()) { usagenetworkvo currentnetworkstats = null; if (networkstats != null) { currentnetworkstats = networkstats.get(key); } createnetworkhelperentry(aggregatedstats.get(key), currentnetworkstats, enddatemillis); numacctsprocessed++; } _usagenetworkdao.saveusagenetworks(usagenetworks); if (s_logger.isdebugenabled()) { s_logger.debug(\"created network stats helper entries for \" + numacctsprocessed + \" accts\"); } vmdiskusages = _usagevmdiskdao.getrecentvmdiskstats(); map<string, vmdiskstatisticsvo> aggregateddiskstats = new hashmap<string, vmdiskstatisticsvo>(); startindex = 0; do { vmdiskstats = _vmdiskstatsdao.listactiveandrecentlydeleted(recentlydeleteddate, startindex, 500); if (vmdiskusages != null) { for (vmdiskstatisticsvo vmdiskstat : vmdiskstats) { if (vmdiskstat.getvmid() != null) { string hostkey = vmdiskstat.getdatacenterid() + \"-\" + vmdiskstat.getaccountid() + \"-vm-\" + vmdiskstat.getvmid() + \"-disk-\" + vmdiskstat.getvolumeid(); vmdiskstatisticsvo hostaggregatedstat = aggregateddiskstats.get(hostkey); if (hostaggregatedstat == null) { hostaggregatedstat = new vmdiskstatisticsvo(vmdiskstat.getaccountid(), vmdiskstat.getdatacenterid(), vmdiskstat.getvmid(), vmdiskstat.getvolumeid()); } hostaggregatedstat.setaggioread(hostaggregatedstat.getaggioread() + vmdiskstat.getaggioread()); hostaggregatedstat.setaggiowrite(hostaggregatedstat.getaggiowrite() + vmdiskstat.getaggiowrite()); hostaggregatedstat.setaggbytesread(hostaggregatedstat.getaggbytesread() + vmdiskstat.getaggbytesread()); hostaggregatedstat.setaggbyteswrite(hostaggregatedstat.getaggbyteswrite() + vmdiskstat.getaggbyteswrite()); aggregateddiskstats.put(hostkey, hostaggregatedstat); } } } startindex += 500; } while ((userstats != null) && !userstats.isempty()); numacctsprocessed = 0; usagevmdisks.clear(); for (string key : aggregateddiskstats.keyset()) { usagevmdiskvo currentvmdiskstats = null; if (vmdiskstats != null) { currentvmdiskstats = vmdiskusages.get(key); } createvmdiskhelperentry(aggregateddiskstats.get(key), currentvmdiskstats, enddatemillis); numacctsprocessed++; } _usagevmdiskdao.saveusagevmdisks(usagevmdisks); if (s_logger.isdebugenabled()) { s_logger.debug(\"created vm disk stats helper entries for \" + numacctsprocessed + \" accts\"); } usagetxn.commit(); usagetxn.start(); boolean parsed = false; numacctsprocessed = 0; date currentstartdate = startdate; date currentenddate = enddate; date tempdate = enddate; calendar aggregatecal = calendar.getinstance(_usagetimezone); while ((tempdate.after(startdate)) && ((tempdate.gettime() - startdate.gettime()) > 60000)) { currentenddate = tempdate; aggregatecal.settime(tempdate); aggregatecal.add(calendar.minute, -_aggregationduration); tempdate = aggregatecal.gettime(); } while (!currentenddate.after(enddate) || (currentenddate.gettime() - enddate.gettime() < 60000)) { long offset = long.valueof(0); long limit = long.valueof(500); do { filter filter = new filter(accountvo.class, \"id\", true, offset, limit); accounts = _accountdao.listall(filter); if ((accounts != null) && !accounts.isempty()) { for (accountvo account : accounts) { parsed = parsehelpertables(account, currentstartdate, currentenddate); numacctsprocessed++; } } offset = new long(offset.longvalue() + limit.longvalue()); } while ((accounts != null) && !accounts.isempty()); if (s_logger.isdebugenabled()) { s_logger.debug(\"processed vm\/network usage for \" + numacctsprocessed + \" active accts\"); } numacctsprocessed = 0; offset = long.valueof(0); do { filter filter = new filter(accountvo.class, \"id\", true, offset, limit); accounts = _accountdao.findrecentlydeletedaccounts(null, recentlydeleteddate, filter); if ((accounts != null) && !accounts.isempty()) { for (accountvo account : accounts) { parsed = parsehelpertables(account, currentstartdate, currentenddate); list<long> publictemplates = _usagedao.listpublictemplatesbyaccount(account.getid()); for (long templateid : publictemplates) { list<usagestoragevo> storagevos = _usagestoragedao.listbyid(account.getid(), templateid, storagetypes.template); if (storagevos.size() > 1) { s_logger.warn(\"more that one usage entry for storage: \" + templateid + \" assigned to account: \" + account.getid() + \"; marking them all as deleted...\"); } for (usagestoragevo storagevo : storagevos) { if (s_logger.isdebugenabled()) { s_logger.debug(\"deleting template: \" + storagevo.getid() + \" from account: \" + storagevo.getaccountid()); } storagevo.setdeleted(account.getremoved()); _usagestoragedao.update(storagevo); } } numacctsprocessed++; } } offset = new long(offset.longvalue() + limit.longvalue()); } while ((accounts != null) && !accounts.isempty()); currentstartdate = new date(currentenddate.gettime() + 1); aggregatecal.settime(currentenddate); aggregatecal.add(calendar.minute, _aggregationduration); currentenddate = aggregatecal.gettime(); } if (s_logger.isdebugenabled()) { s_logger.debug(\"processed usage for \" + numacctsprocessed + \" recently deleted accts\"); } if (!parsed) { usagetxn.rollback(); } else { success = true; } } catch (exception ex) { s_logger.error(\"exception in usage manager\", ex); usagetxn.rollback(); } finally { _usagejobdao.updatejobsuccess(job.getid(), startdatemillis, enddatemillis, system.currenttimemillis() - timestart, success); if (job.getjobtype() == usagejobvo.job_type_recurring) { _usagejobdao.createnewjob(_hostname, _pid, usagejobvo.job_type_recurring); } usagetxn.commit(); usagetxn.close(); transactionlegacy swap = transactionlegacy.open(transactionlegacy.cloud_db); if (!success) { _alertmgr.sendalert(alertmanager.alerttype.alert_type_usage_server_result, 0, new long(0), \"usage job failed. job id: \" + job.getid(), \"usage job failed. job id: \" + job.getid()); } else { _alertmgr.clearalert(alertmanager.alerttype.alert_type_usage_server_result, 0, 0); } swap.close(); } } catch (exception e) { s_logger.error(\"usage manager error\", e); } }","comment":"\/\/ todo: shouldn't we also allow parsing by the type of usage?\n\/\/ 1 millisecond after\n\/\/ everything seemed to work...set enddate as the last success date\n\/\/ create a new job if this is a recurring job\n\/\/ now update the accounts in the cloud_usage db\n\/\/ reset offset\n\/\/ now update the accounts in the cloud_usage db\n\/\/ reset offset\n\/\/ now copy the accounts to cloud_usage db\n\/\/ reset offset\n\/\/ get all the user stats to create usage records for the network usage\n\/\/ now copy the accounts to cloud_usage db\n\/\/ reset offset\n\/\/ now copy the accounts to cloud_usage db\n\/\/ reset offset\n\/\/ get all the vm network stats to create usage_vm_network records for the vm network usage\n\/\/ now copy the accounts to cloud_usage db\n\/\/ reset offset\n\/\/ now copy the accounts to cloud_usage db\n\/\/ todo: fetch a maximum number of events and process them before moving on to the next range of events \/\/ - get a list of the latest events \/\/ - insert the latest events into the usage.events table\n\/\/ make sure start date is before all of our un-processed events (the events are ordered oldest \/\/ to newest, so just test against the first event)\n\/\/ - loop over the list of events and create entries in the helper tables \/\/ - create the usage records using the parse methods below\n\/\/ todo: fetch a maximum number of user stats and process them before moving on to the next range of user stats \/\/ get user stats in order to compute network usage\n\/\/ keep track of user stats for an account, across all of its public ips\n\/\/ loop over the user stats, create delta entries in the usage_network helper table\n\/\/ get vm disk stats in order to compute vm disk usage\n\/\/ keep track of user stats for an account, across all of its public ips\n\/\/ loop over the user stats, create delta entries in the usage_disk helper table\n\/\/ commit the helper records, then start a new transaction\n\/\/ reset offset\n\/\/mark public templates owned by deleted accounts as deleted\n\/\/ fixme: we don't break the above loop if something fails to parse, so it gets reset every account, \/\/ do we want to break out of processing accounts and rollback if there are errors?\n\/\/ everything seemed to work...set enddate as the last success date\n\/\/ create a new job if this is a recurring job\n\/\/ switch back to cloud_db","repo":"serbaut\/cloudstack","code_context_2":"@Override\npublic void parse(UsageJobVO job, long startDateMillis, long endDateMillis) {\n\/\/ TODO: Shouldn't we also allow parsing by the type of usage?\nboolean success = false;\nlong timeStart = System.currentTimeMillis();\n\nlong lastSuccess = _usageJobDao.getLastJobSuccessDateMillis();\nif (lastSuccess != 0) {\nstartDateMillis = lastSuccess + 1; \/\/ 1 millisecond after\n}\nif (startDateMillis >= endDateMillis) {\n\ntry {\njobUpdateTxn.start();\n\/\/ everything seemed to work...set endDate as the last success date\n_usageJobDao.updateJobSuccess(job.getId(), startDateMillis, endDateMillis, System.currentTimeMillis() - timeStart, success);\n\/\/ create a new job if this is a recurring job\n\n\/\/ everything seemed to work...set endDate as the last success date\n_usageJobDao.updateJobSuccess(job.getId(), startDateMillis, endDateMillis, System.currentTimeMillis() - timeStart, success);\n\/\/ create a new job if this is a recurring job\nif (job.getJobType() == UsageJobVO.JOB_TYPE_RECURRING) {\n_usageJobDao.createNewJob(_hostname, _pid, UsageJobVO.JOB_TYPE_RECURRING);\n\naccounts = _accountDao.findActiveAccounts(lastAccountId, filter);\nif ((accounts != null) && !accounts.isEmpty()) {\n\/\/ now update the accounts in the cloud_usage db\n_usageDao.updateAccounts(accounts);\n}\n\noffset = new Long(offset.longValue() + limit.longValue());\n} while ((accounts != null) && !accounts.isEmpty());\n\/\/ reset offset\noffset = Long.valueOf(0);\ndo {\n\naccounts = _accountDao.findActiveAccounts(lastAccountId, filter);\nif ((accounts != null) && !accounts.isEmpty()) {\n\/\/ now update the accounts in the cloud_usage db\n_usageDao.updateAccounts(accounts);\n}\n\noffset = new Long(offset.longValue() + limit.longValue());\n} while ((accounts != null) && !accounts.isEmpty());\n\/\/ reset offset\noffset = Long.valueOf(0);\ndo {\n\naccounts = _accountDao.findNewAccounts(lastAccountId, filter);\nif ((accounts != null) && !accounts.isEmpty()) {\n\/\/ now copy the accounts to cloud_usage db\n_usageDao.saveAccounts(accounts);\n}\n\noffset = new Long(offset.longValue() + limit.longValue());\n} while ((accounts != null) && !accounts.isEmpty());\n\/\/ reset offset\noffset = Long.valueOf(0);\ndo {\n\n\/\/ reset offset\noffset = Long.valueOf(0);\n\/\/ get all the user stats to create usage records for the network usage\nLong lastUserStatsId = _usageDao.getLastUserStatsId();\nif (lastUserStatsId == null) {\n\naccounts = _accountDao.findNewAccounts(lastAccountId, filter);\nif ((accounts != null) && !accounts.isEmpty()) {\n\/\/ now copy the accounts to cloud_usage db\n_usageDao.saveAccounts(accounts);\n}\n\noffset = new Long(offset.longValue() + limit.longValue());\n} while ((accounts != null) && !accounts.isEmpty());\n\/\/ reset offset\noffset = Long.valueOf(0);\ndo {\n\naccounts = _accountDao.findNewAccounts(lastAccountId, filter);\nif ((accounts != null) && !accounts.isEmpty()) {\n\/\/ now copy the accounts to cloud_usage db\n_usageDao.saveAccounts(accounts);\n}\n\noffset = new Long(offset.longValue() + limit.longValue());\n} while ((accounts != null) && !accounts.isEmpty());\n\/\/ reset offset\noffset = Long.valueOf(0);\ndo {\n\n\/\/ reset offset\noffset = Long.valueOf(0);\n\/\/ get all the vm network stats to create usage_VM_network records for the vm network usage\nLong lastVmDiskStatsId = _usageDao.getLastVmDiskStatsId();\nif (lastVmDiskStatsId == null) {\n\naccounts = _accountDao.findNewAccounts(lastAccountId, filter);\nif ((accounts != null) && !accounts.isEmpty()) {\n\/\/ now copy the accounts to cloud_usage db\n_usageDao.saveAccounts(accounts);\n}\n\noffset = new Long(offset.longValue() + limit.longValue());\n} while ((accounts != null) && !accounts.isEmpty());\n\/\/ reset offset\noffset = Long.valueOf(0);\ndo {\n\naccounts = _accountDao.findNewAccounts(lastAccountId, filter);\nif ((accounts != null) && !accounts.isEmpty()) {\n\/\/ now copy the accounts to cloud_usage db\n_usageDao.saveAccounts(accounts);\n}\n\nuserTxn.close();\n}\n\/\/ TODO: Fetch a maximum number of events and process them before moving on to the next range of events\n\/\/ - get a list of the latest events\n\/\/ - insert the latest events into the usage.events table\nList<UsageEventVO> events = _usageEventDao.getRecentEvents(new Date(endDateMillis));\nTransactionLegacy usageTxn = TransactionLegacy.open(TransactionLegacy.USAGE_DB);\n\ntry {\nusageTxn.start();\n\/\/ make sure start date is before all of our un-processed events (the events are ordered oldest\n\/\/ to newest, so just test against the first event)\nif ((events != null) && (events.size() > 0)) {\nDate oldestEventDate = events.get(0).getCreateDate();\n\nstartDate = new Date(startDateMillis);\n}\n\/\/ - loop over the list of events and create entries in the helper tables\n\/\/ - create the usage records using the parse methods below\nfor (UsageEventVO event : events) {\nevent.setProcessed(true);\n\n}\n}\n\/\/ TODO: Fetch a maximum number of user stats and process them before moving on to the next range of user stats\n\/\/ get user stats in order to compute network usage\nnetworkStats = _usageNetworkDao.getRecentNetworkStats();\nCalendar recentlyDeletedCal = Calendar.getInstance(_usageTimezone);\n\nrecentlyDeletedCal.add(Calendar.MINUTE, -1 * THREE_DAYS_IN_MINUTES);\nDate recentlyDeletedDate = recentlyDeletedCal.getTime();\n\/\/ Keep track of user stats for an account, across all of its public IPs\nMap<String, UserStatisticsVO> aggregatedStats = new HashMap<String, UserStatisticsVO>();\nint startIndex = 0;\n\nstartIndex += 500;\n} while ((userStats != null) && !userStats.isEmpty());\n\/\/ loop over the user stats, create delta entries in the usage_network helper table\nint numAcctsProcessed = 0;\nusageNetworks.clear();\n\ns_logger.debug(\"created network stats helper entries for \" + numAcctsProcessed + \" accts\");\n}\n\/\/ get vm disk stats in order to compute vm disk usage\nvmDiskUsages = _usageVmDiskDao.getRecentVmDiskStats();\n\/\/ Keep track of user stats for an account, across all of its public IPs\n\nrecentlyDeletedCal.add(Calendar.MINUTE, -1 * THREE_DAYS_IN_MINUTES);\nDate recentlyDeletedDate = recentlyDeletedCal.getTime();\n\/\/ Keep track of user stats for an account, across all of its public IPs\nMap<String, UserStatisticsVO> aggregatedStats = new HashMap<String, UserStatisticsVO>();\nint startIndex = 0;\n\nstartIndex += 500;\n} while ((userStats != null) && !userStats.isEmpty());\n\/\/ loop over the user stats, create delta entries in the usage_disk helper table\nnumAcctsProcessed = 0;\nusageVmDisks.clear();\n\ns_logger.debug(\"created vm disk stats helper entries for \" + numAcctsProcessed + \" accts\");\n}\n\/\/ commit the helper records, then start a new transaction\nusageTxn.commit();\nusageTxn.start();\n\noffset = new Long(offset.longValue() + limit.longValue());\n} while ((accounts != null) && !accounts.isEmpty());\n\/\/ reset offset\noffset = Long.valueOf(0);\ndo {\n\nList<Long> publicTemplates = _usageDao.listPublicTemplatesByAccount(account.getId());\nfor (Long templateId : publicTemplates) {\n\/\/mark public templates owned by deleted accounts as deleted\nList<UsageStorageVO> storageVOs = _usageStorageDao.listById(account.getId(), templateId, StorageTypes.TEMPLATE);\nif (storageVOs.size() > 1) {\n\ns_logger.debug(\"processed Usage for \" + numAcctsProcessed + \" RECENTLY DELETED accts\");\n}\n\/\/ FIXME: we don't break the above loop if something fails to parse, so it gets reset every account,\n\/\/ do we want to break out of processing accounts and rollback if there are errors?\nif (!parsed) {\nusageTxn.rollback();\n\ntry {\njobUpdateTxn.start();\n\/\/ everything seemed to work...set endDate as the last success date\n_usageJobDao.updateJobSuccess(job.getId(), startDateMillis, endDateMillis, System.currentTimeMillis() - timeStart, success);\n\/\/ create a new job if this is a recurring job\n\n\/\/ everything seemed to work...set endDate as the last success date\n_usageJobDao.updateJobSuccess(job.getId(), startDateMillis, endDateMillis, System.currentTimeMillis() - timeStart, success);\n\/\/ create a new job if this is a recurring job\nif (job.getJobType() == UsageJobVO.JOB_TYPE_RECURRING) {\n_usageJobDao.createNewJob(_hostname, _pid, UsageJobVO.JOB_TYPE_RECURRING);\n\nusageTxn.commit();\nusageTxn.close();\n\/\/ switch back to CLOUD_DB\nTransactionLegacy swap = TransactionLegacy.open(TransactionLegacy.CLOUD_DB);\nif (!success) {","code_context_10":"@Override\npublic void parse(UsageJobVO job, long startDateMillis, long endDateMillis) {\n\/\/ TODO: Shouldn't we also allow parsing by the type of usage?\nboolean success = false;\nlong timeStart = System.currentTimeMillis();\ntry {\nif ((endDateMillis == 0) || (endDateMillis > timeStart)) {\nendDateMillis = timeStart;\n}\nlong lastSuccess = _usageJobDao.getLastJobSuccessDateMillis();\nif (lastSuccess != 0) {\nstartDateMillis = lastSuccess + 1; \/\/ 1 millisecond after\n}\n\npublic void parse(UsageJobVO job, long startDateMillis, long endDateMillis) {\n\/\/ TODO: Shouldn't we also allow parsing by the type of usage?\nboolean success = false;\nlong timeStart = System.currentTimeMillis();\ntry {\nif ((endDateMillis == 0) || (endDateMillis > timeStart)) {\nendDateMillis = timeStart;\n}\nlong lastSuccess = _usageJobDao.getLastJobSuccessDateMillis();\nif (lastSuccess != 0) {\nstartDateMillis = lastSuccess + 1; \/\/ 1 millisecond after\n}\nif (startDateMillis >= endDateMillis) {\nif (s_logger.isInfoEnabled()) {\ns_logger.info(\"not parsing usage records since start time mills (\" + startDateMillis + \") is on or after end time millis (\" + endDateMillis + \")\");\n}\nTransactionLegacy jobUpdateTxn = TransactionLegacy.open(TransactionLegacy.USAGE_DB);\ntry {\njobUpdateTxn.start();\n\/\/ everything seemed to work...set endDate as the last success date\n_usageJobDao.updateJobSuccess(job.getId(), startDateMillis, endDateMillis, System.currentTimeMillis() - timeStart, success);\n\nif (lastSuccess != 0) {\nstartDateMillis = lastSuccess + 1; \/\/ 1 millisecond after\n}\nif (startDateMillis >= endDateMillis) {\nif (s_logger.isInfoEnabled()) {\ns_logger.info(\"not parsing usage records since start time mills (\" + startDateMillis + \") is on or after end time millis (\" + endDateMillis + \")\");\n}\nTransactionLegacy jobUpdateTxn = TransactionLegacy.open(TransactionLegacy.USAGE_DB);\ntry {\njobUpdateTxn.start();\n\/\/ everything seemed to work...set endDate as the last success date\n_usageJobDao.updateJobSuccess(job.getId(), startDateMillis, endDateMillis, System.currentTimeMillis() - timeStart, success);\n\/\/ create a new job if this is a recurring job\nif (job.getJobType() == UsageJobVO.JOB_TYPE_RECURRING) {\n_usageJobDao.createNewJob(_hostname, _pid, UsageJobVO.JOB_TYPE_RECURRING);\n}\njobUpdateTxn.commit();\n} finally {\njobUpdateTxn.close();\n}\nreturn;\n\n}\nif (startDateMillis >= endDateMillis) {\nif (s_logger.isInfoEnabled()) {\ns_logger.info(\"not parsing usage records since start time mills (\" + startDateMillis + \") is on or after end time millis (\" + endDateMillis + \")\");\n}\nTransactionLegacy jobUpdateTxn = TransactionLegacy.open(TransactionLegacy.USAGE_DB);\ntry {\njobUpdateTxn.start();\n\/\/ everything seemed to work...set endDate as the last success date\n_usageJobDao.updateJobSuccess(job.getId(), startDateMillis, endDateMillis, System.currentTimeMillis() - timeStart, success);\n\/\/ create a new job if this is a recurring job\nif (job.getJobType() == UsageJobVO.JOB_TYPE_RECURRING) {\n_usageJobDao.createNewJob(_hostname, _pid, UsageJobVO.JOB_TYPE_RECURRING);\n}\njobUpdateTxn.commit();\n} finally {\njobUpdateTxn.close();\n}\nreturn;\n}\nDate startDate = new Date(startDateMillis);\n\nLong limit = Long.valueOf(500);\nLong offset = Long.valueOf(0);\nLong lastAccountId = _usageDao.getLastAccountId();\nif (lastAccountId == null) {\nlastAccountId = Long.valueOf(0);\n}\ndo {\nFilter filter = new Filter(AccountVO.class, \"id\", true, offset, limit);\naccounts = _accountDao.findActiveAccounts(lastAccountId, filter);\nif ((accounts != null) && !accounts.isEmpty()) {\n\/\/ now update the accounts in the cloud_usage db\n_usageDao.updateAccounts(accounts);\n}\noffset = new Long(offset.longValue() + limit.longValue());\n} while ((accounts != null) && !accounts.isEmpty());\n\/\/ reset offset\noffset = Long.valueOf(0);\ndo {\nFilter filter = new Filter(AccountVO.class, \"id\", true, offset, limit);\naccounts = _accountDao.findRecentlyDeletedAccounts(lastAccountId, startDate, filter);\nif ((accounts != null) && !accounts.isEmpty()) {\n\n}\ndo {\nFilter filter = new Filter(AccountVO.class, \"id\", true, offset, limit);\naccounts = _accountDao.findActiveAccounts(lastAccountId, filter);\nif ((accounts != null) && !accounts.isEmpty()) {\n\/\/ now update the accounts in the cloud_usage db\n_usageDao.updateAccounts(accounts);\n}\noffset = new Long(offset.longValue() + limit.longValue());\n} while ((accounts != null) && !accounts.isEmpty());\n\/\/ reset offset\noffset = Long.valueOf(0);\ndo {\nFilter filter = new Filter(AccountVO.class, \"id\", true, offset, limit);\naccounts = _accountDao.findRecentlyDeletedAccounts(lastAccountId, startDate, filter);\nif ((accounts != null) && !accounts.isEmpty()) {\n\/\/ now update the accounts in the cloud_usage db\n_usageDao.updateAccounts(accounts);\n}\noffset = new Long(offset.longValue() + limit.longValue());\n} while ((accounts != null) && !accounts.isEmpty());\n\nLong limit = Long.valueOf(500);\nLong offset = Long.valueOf(0);\nLong lastAccountId = _usageDao.getLastAccountId();\nif (lastAccountId == null) {\nlastAccountId = Long.valueOf(0);\n}\ndo {\nFilter filter = new Filter(AccountVO.class, \"id\", true, offset, limit);\naccounts = _accountDao.findActiveAccounts(lastAccountId, filter);\nif ((accounts != null) && !accounts.isEmpty()) {\n\/\/ now update the accounts in the cloud_usage db\n_usageDao.updateAccounts(accounts);\n}\noffset = new Long(offset.longValue() + limit.longValue());\n} while ((accounts != null) && !accounts.isEmpty());\n\/\/ reset offset\noffset = Long.valueOf(0);\ndo {\nFilter filter = new Filter(AccountVO.class, \"id\", true, offset, limit);\naccounts = _accountDao.findRecentlyDeletedAccounts(lastAccountId, startDate, filter);\nif ((accounts != null) && !accounts.isEmpty()) {\n\n}\ndo {\nFilter filter = new Filter(AccountVO.class, \"id\", true, offset, limit);\naccounts = _accountDao.findActiveAccounts(lastAccountId, filter);\nif ((accounts != null) && !accounts.isEmpty()) {\n\/\/ now update the accounts in the cloud_usage db\n_usageDao.updateAccounts(accounts);\n}\noffset = new Long(offset.longValue() + limit.longValue());\n} while ((accounts != null) && !accounts.isEmpty());\n\/\/ reset offset\noffset = Long.valueOf(0);\ndo {\nFilter filter = new Filter(AccountVO.class, \"id\", true, offset, limit);\naccounts = _accountDao.findRecentlyDeletedAccounts(lastAccountId, startDate, filter);\nif ((accounts != null) && !accounts.isEmpty()) {\n\/\/ now update the accounts in the cloud_usage db\n_usageDao.updateAccounts(accounts);\n}\noffset = new Long(offset.longValue() + limit.longValue());\n} while ((accounts != null) && !accounts.isEmpty());\n\n_usageDao.updateAccounts(accounts);\n}\noffset = new Long(offset.longValue() + limit.longValue());\n} while ((accounts != null) && !accounts.isEmpty());\n\/\/ reset offset\noffset = Long.valueOf(0);\ndo {\nFilter filter = new Filter(AccountVO.class, \"id\", true, offset, limit);\naccounts = _accountDao.findNewAccounts(lastAccountId, filter);\nif ((accounts != null) && !accounts.isEmpty()) {\n\/\/ now copy the accounts to cloud_usage db\n_usageDao.saveAccounts(accounts);\n}\noffset = new Long(offset.longValue() + limit.longValue());\n} while ((accounts != null) && !accounts.isEmpty());\n\/\/ reset offset\noffset = Long.valueOf(0);\n\/\/ get all the user stats to create usage records for the network usage\nLong lastUserStatsId = _usageDao.getLastUserStatsId();\nif (lastUserStatsId == null) {\nlastUserStatsId = Long.valueOf(0);\n\n}\ndo {\nFilter filter = new Filter(AccountVO.class, \"id\", true, offset, limit);\naccounts = _accountDao.findActiveAccounts(lastAccountId, filter);\nif ((accounts != null) && !accounts.isEmpty()) {\n\/\/ now update the accounts in the cloud_usage db\n_usageDao.updateAccounts(accounts);\n}\noffset = new Long(offset.longValue() + limit.longValue());\n} while ((accounts != null) && !accounts.isEmpty());\n\/\/ reset offset\noffset = Long.valueOf(0);\ndo {\nFilter filter = new Filter(AccountVO.class, \"id\", true, offset, limit);\naccounts = _accountDao.findRecentlyDeletedAccounts(lastAccountId, startDate, filter);\nif ((accounts != null) && !accounts.isEmpty()) {\n\/\/ now update the accounts in the cloud_usage db\n_usageDao.updateAccounts(accounts);\n}\noffset = new Long(offset.longValue() + limit.longValue());\n} while ((accounts != null) && !accounts.isEmpty());\n\nFilter filter = new Filter(AccountVO.class, \"id\", true, offset, limit);\naccounts = _accountDao.findNewAccounts(lastAccountId, filter);\nif ((accounts != null) && !accounts.isEmpty()) {\n\/\/ now copy the accounts to cloud_usage db\n_usageDao.saveAccounts(accounts);\n}\noffset = new Long(offset.longValue() + limit.longValue());\n} while ((accounts != null) && !accounts.isEmpty());\n\/\/ reset offset\noffset = Long.valueOf(0);\n\/\/ get all the user stats to create usage records for the network usage\nLong lastUserStatsId = _usageDao.getLastUserStatsId();\nif (lastUserStatsId == null) {\nlastUserStatsId = Long.valueOf(0);\n}\nSearchCriteria<UserStatisticsVO> sc2 = _userStatsDao.createSearchCriteria();\nsc2.addAnd(\"id\", SearchCriteria.Op.LTEQ, lastUserStatsId);\ndo {\nFilter filter = new Filter(UserStatisticsVO.class, \"id\", true, offset, limit);\nuserStats = _userStatsDao.search(sc2, filter);\nif ((userStats != null) && !userStats.isEmpty()) {\n\n_usageDao.updateAccounts(accounts);\n}\noffset = new Long(offset.longValue() + limit.longValue());\n} while ((accounts != null) && !accounts.isEmpty());\n\/\/ reset offset\noffset = Long.valueOf(0);\ndo {\nFilter filter = new Filter(AccountVO.class, \"id\", true, offset, limit);\naccounts = _accountDao.findNewAccounts(lastAccountId, filter);\nif ((accounts != null) && !accounts.isEmpty()) {\n\/\/ now copy the accounts to cloud_usage db\n_usageDao.saveAccounts(accounts);\n}\noffset = new Long(offset.longValue() + limit.longValue());\n} while ((accounts != null) && !accounts.isEmpty());\n\/\/ reset offset\noffset = Long.valueOf(0);\n\/\/ get all the user stats to create usage records for the network usage\nLong lastUserStatsId = _usageDao.getLastUserStatsId();\nif (lastUserStatsId == null) {\nlastUserStatsId = Long.valueOf(0);\n\n}\ndo {\nFilter filter = new Filter(AccountVO.class, \"id\", true, offset, limit);\naccounts = _accountDao.findActiveAccounts(lastAccountId, filter);\nif ((accounts != null) && !accounts.isEmpty()) {\n\/\/ now update the accounts in the cloud_usage db\n_usageDao.updateAccounts(accounts);\n}\noffset = new Long(offset.longValue() + limit.longValue());\n} while ((accounts != null) && !accounts.isEmpty());\n\/\/ reset offset\noffset = Long.valueOf(0);\ndo {\nFilter filter = new Filter(AccountVO.class, \"id\", true, offset, limit);\naccounts = _accountDao.findRecentlyDeletedAccounts(lastAccountId, startDate, filter);\nif ((accounts != null) && !accounts.isEmpty()) {\n\/\/ now update the accounts in the cloud_usage db\n_usageDao.updateAccounts(accounts);\n}\noffset = new Long(offset.longValue() + limit.longValue());\n} while ((accounts != null) && !accounts.isEmpty());\n\n_usageDao.updateAccounts(accounts);\n}\noffset = new Long(offset.longValue() + limit.longValue());\n} while ((accounts != null) && !accounts.isEmpty());\n\/\/ reset offset\noffset = Long.valueOf(0);\ndo {\nFilter filter = new Filter(AccountVO.class, \"id\", true, offset, limit);\naccounts = _accountDao.findNewAccounts(lastAccountId, filter);\nif ((accounts != null) && !accounts.isEmpty()) {\n\/\/ now copy the accounts to cloud_usage db\n_usageDao.saveAccounts(accounts);\n}\noffset = new Long(offset.longValue() + limit.longValue());\n} while ((accounts != null) && !accounts.isEmpty());\n\/\/ reset offset\noffset = Long.valueOf(0);\n\/\/ get all the user stats to create usage records for the network usage\nLong lastUserStatsId = _usageDao.getLastUserStatsId();\nif (lastUserStatsId == null) {\nlastUserStatsId = Long.valueOf(0);\n\n}\ndo {\nFilter filter = new Filter(AccountVO.class, \"id\", true, offset, limit);\naccounts = _accountDao.findActiveAccounts(lastAccountId, filter);\nif ((accounts != null) && !accounts.isEmpty()) {\n\/\/ now update the accounts in the cloud_usage db\n_usageDao.updateAccounts(accounts);\n}\noffset = new Long(offset.longValue() + limit.longValue());\n} while ((accounts != null) && !accounts.isEmpty());\n\/\/ reset offset\noffset = Long.valueOf(0);\ndo {\nFilter filter = new Filter(AccountVO.class, \"id\", true, offset, limit);\naccounts = _accountDao.findRecentlyDeletedAccounts(lastAccountId, startDate, filter);\nif ((accounts != null) && !accounts.isEmpty()) {\n\/\/ now update the accounts in the cloud_usage db\n_usageDao.updateAccounts(accounts);\n}\noffset = new Long(offset.longValue() + limit.longValue());\n} while ((accounts != null) && !accounts.isEmpty());\n\nFilter filter = new Filter(UserStatisticsVO.class, \"id\", true, offset, limit);\nuserStats = _userStatsDao.search(sc2, filter);\nif ((userStats != null) && !userStats.isEmpty()) {\n\/\/ now copy the accounts to cloud_usage db\n_usageDao.saveUserStats(userStats);\n}\noffset = new Long(offset.longValue() + limit.longValue());\n} while ((userStats != null) && !userStats.isEmpty());\n\/\/ reset offset\noffset = Long.valueOf(0);\n\/\/ get all the vm network stats to create usage_VM_network records for the vm network usage\nLong lastVmDiskStatsId = _usageDao.getLastVmDiskStatsId();\nif (lastVmDiskStatsId == null) {\nlastVmDiskStatsId = Long.valueOf(0);\n}\nSearchCriteria<VmDiskStatisticsVO> sc4 = _vmDiskStatsDao.createSearchCriteria();\nsc4.addAnd(\"id\", SearchCriteria.Op.LTEQ, lastVmDiskStatsId);\ndo {\nFilter filter = new Filter(VmDiskStatisticsVO.class, \"id\", true, offset, limit);\nvmDiskStats = _vmDiskStatsDao.search(sc4, filter);\nif ((vmDiskStats != null) && !vmDiskStats.isEmpty()) {\n\n_usageDao.updateAccounts(accounts);\n}\noffset = new Long(offset.longValue() + limit.longValue());\n} while ((accounts != null) && !accounts.isEmpty());\n\/\/ reset offset\noffset = Long.valueOf(0);\ndo {\nFilter filter = new Filter(AccountVO.class, \"id\", true, offset, limit);\naccounts = _accountDao.findNewAccounts(lastAccountId, filter);\nif ((accounts != null) && !accounts.isEmpty()) {\n\/\/ now copy the accounts to cloud_usage db\n_usageDao.saveAccounts(accounts);\n}\noffset = new Long(offset.longValue() + limit.longValue());\n} while ((accounts != null) && !accounts.isEmpty());\n\/\/ reset offset\noffset = Long.valueOf(0);\n\/\/ get all the user stats to create usage records for the network usage\nLong lastUserStatsId = _usageDao.getLastUserStatsId();\nif (lastUserStatsId == null) {\nlastUserStatsId = Long.valueOf(0);\n\n}\ndo {\nFilter filter = new Filter(AccountVO.class, \"id\", true, offset, limit);\naccounts = _accountDao.findActiveAccounts(lastAccountId, filter);\nif ((accounts != null) && !accounts.isEmpty()) {\n\/\/ now update the accounts in the cloud_usage db\n_usageDao.updateAccounts(accounts);\n}\noffset = new Long(offset.longValue() + limit.longValue());\n} while ((accounts != null) && !accounts.isEmpty());\n\/\/ reset offset\noffset = Long.valueOf(0);\ndo {\nFilter filter = new Filter(AccountVO.class, \"id\", true, offset, limit);\naccounts = _accountDao.findRecentlyDeletedAccounts(lastAccountId, startDate, filter);\nif ((accounts != null) && !accounts.isEmpty()) {\n\/\/ now update the accounts in the cloud_usage db\n_usageDao.updateAccounts(accounts);\n}\noffset = new Long(offset.longValue() + limit.longValue());\n} while ((accounts != null) && !accounts.isEmpty());\n\n_usageDao.updateAccounts(accounts);\n}\noffset = new Long(offset.longValue() + limit.longValue());\n} while ((accounts != null) && !accounts.isEmpty());\n\/\/ reset offset\noffset = Long.valueOf(0);\ndo {\nFilter filter = new Filter(AccountVO.class, \"id\", true, offset, limit);\naccounts = _accountDao.findNewAccounts(lastAccountId, filter);\nif ((accounts != null) && !accounts.isEmpty()) {\n\/\/ now copy the accounts to cloud_usage db\n_usageDao.saveAccounts(accounts);\n}\noffset = new Long(offset.longValue() + limit.longValue());\n} while ((accounts != null) && !accounts.isEmpty());\n\/\/ reset offset\noffset = Long.valueOf(0);\n\/\/ get all the user stats to create usage records for the network usage\nLong lastUserStatsId = _usageDao.getLastUserStatsId();\nif (lastUserStatsId == null) {\nlastUserStatsId = Long.valueOf(0);\n\nvmDiskStats = _vmDiskStatsDao.search(sc4, filter);\nif ((vmDiskStats != null) && !vmDiskStats.isEmpty()) {\n\/\/ now copy the accounts to cloud_usage db\n_usageDao.saveVmDiskStats(vmDiskStats);\n}\noffset = new Long(offset.longValue() + limit.longValue());\n} while ((vmDiskStats != null) && !vmDiskStats.isEmpty());\n} finally {\nuserTxn.close();\n}\n\/\/ TODO: Fetch a maximum number of events and process them before moving on to the next range of events\n\/\/ - get a list of the latest events\n\/\/ - insert the latest events into the usage.events table\nList<UsageEventVO> events = _usageEventDao.getRecentEvents(new Date(endDateMillis));\nTransactionLegacy usageTxn = TransactionLegacy.open(TransactionLegacy.USAGE_DB);\ntry {\nusageTxn.start();\n\/\/ make sure start date is before all of our un-processed events (the events are ordered oldest\n\/\/ to newest, so just test against the first event)\nif ((events != null) && (events.size() > 0)) {\nDate oldestEventDate = events.get(0).getCreateDate();\nif (oldestEventDate.getTime() < startDateMillis) {\nstartDateMillis = oldestEventDate.getTime();\n\n} finally {\nuserTxn.close();\n}\n\/\/ TODO: Fetch a maximum number of events and process them before moving on to the next range of events\n\/\/ - get a list of the latest events\n\/\/ - insert the latest events into the usage.events table\nList<UsageEventVO> events = _usageEventDao.getRecentEvents(new Date(endDateMillis));\nTransactionLegacy usageTxn = TransactionLegacy.open(TransactionLegacy.USAGE_DB);\ntry {\nusageTxn.start();\n\/\/ make sure start date is before all of our un-processed events (the events are ordered oldest\n\/\/ to newest, so just test against the first event)\nif ((events != null) && (events.size() > 0)) {\nDate oldestEventDate = events.get(0).getCreateDate();\nif (oldestEventDate.getTime() < startDateMillis) {\nstartDateMillis = oldestEventDate.getTime();\nstartDate = new Date(startDateMillis);\n}\n\/\/ - loop over the list of events and create entries in the helper tables\n\/\/ - create the usage records using the parse methods below\nfor (UsageEventVO event : events) {\nevent.setProcessed(true);\n\ntry {\nusageTxn.start();\n\/\/ make sure start date is before all of our un-processed events (the events are ordered oldest\n\/\/ to newest, so just test against the first event)\nif ((events != null) && (events.size() > 0)) {\nDate oldestEventDate = events.get(0).getCreateDate();\nif (oldestEventDate.getTime() < startDateMillis) {\nstartDateMillis = oldestEventDate.getTime();\nstartDate = new Date(startDateMillis);\n}\n\/\/ - loop over the list of events and create entries in the helper tables\n\/\/ - create the usage records using the parse methods below\nfor (UsageEventVO event : events) {\nevent.setProcessed(true);\n_usageEventDao.update(event.getId(), event);\ncreateHelperRecord(event);\n}\n}\n\/\/ TODO: Fetch a maximum number of user stats and process them before moving on to the next range of user stats\n\/\/ get user stats in order to compute network usage\nnetworkStats = _usageNetworkDao.getRecentNetworkStats();\nCalendar recentlyDeletedCal = Calendar.getInstance(_usageTimezone);\n\nstartDate = new Date(startDateMillis);\n}\n\/\/ - loop over the list of events and create entries in the helper tables\n\/\/ - create the usage records using the parse methods below\nfor (UsageEventVO event : events) {\nevent.setProcessed(true);\n_usageEventDao.update(event.getId(), event);\ncreateHelperRecord(event);\n}\n}\n\/\/ TODO: Fetch a maximum number of user stats and process them before moving on to the next range of user stats\n\/\/ get user stats in order to compute network usage\nnetworkStats = _usageNetworkDao.getRecentNetworkStats();\nCalendar recentlyDeletedCal = Calendar.getInstance(_usageTimezone);\nrecentlyDeletedCal.setTimeInMillis(startDateMillis);\nrecentlyDeletedCal.add(Calendar.MINUTE, -1 * THREE_DAYS_IN_MINUTES);\nDate recentlyDeletedDate = recentlyDeletedCal.getTime();\n\/\/ Keep track of user stats for an account, across all of its public IPs\nMap<String, UserStatisticsVO> aggregatedStats = new HashMap<String, UserStatisticsVO>();\nint startIndex = 0;\ndo {\nuserStats = _userStatsDao.listActiveAndRecentlyDeleted(recentlyDeletedDate, startIndex, 500);\n\ncreateHelperRecord(event);\n}\n}\n\/\/ TODO: Fetch a maximum number of user stats and process them before moving on to the next range of user stats\n\/\/ get user stats in order to compute network usage\nnetworkStats = _usageNetworkDao.getRecentNetworkStats();\nCalendar recentlyDeletedCal = Calendar.getInstance(_usageTimezone);\nrecentlyDeletedCal.setTimeInMillis(startDateMillis);\nrecentlyDeletedCal.add(Calendar.MINUTE, -1 * THREE_DAYS_IN_MINUTES);\nDate recentlyDeletedDate = recentlyDeletedCal.getTime();\n\/\/ Keep track of user stats for an account, across all of its public IPs\nMap<String, UserStatisticsVO> aggregatedStats = new HashMap<String, UserStatisticsVO>();\nint startIndex = 0;\ndo {\nuserStats = _userStatsDao.listActiveAndRecentlyDeleted(recentlyDeletedDate, startIndex, 500);\nif (userStats != null) {\nfor (UserStatisticsVO userStat : userStats) {\nif (userStat.getDeviceId() != null) {\nString hostKey = userStat.getDataCenterId() + \"-\" + userStat.getAccountId() + \"-Host-\" + userStat.getDeviceId();\nUserStatisticsVO hostAggregatedStat = aggregatedStats.get(hostKey);\nif (hostAggregatedStat == null) {\n\nuserStat.getDeviceType(), userStat.getNetworkId());\n}\nhostAggregatedStat.setAggBytesSent(hostAggregatedStat.getAggBytesSent() + userStat.getAggBytesSent());\nhostAggregatedStat.setAggBytesReceived(hostAggregatedStat.getAggBytesReceived() + userStat.getAggBytesReceived());\naggregatedStats.put(hostKey, hostAggregatedStat);\n}\n}\n}\nstartIndex += 500;\n} while ((userStats != null) && !userStats.isEmpty());\n\/\/ loop over the user stats, create delta entries in the usage_network helper table\nint numAcctsProcessed = 0;\nusageNetworks.clear();\nfor (String key : aggregatedStats.keySet()) {\nUsageNetworkVO currentNetworkStats = null;\nif (networkStats != null) {\ncurrentNetworkStats = networkStats.get(key);\n}\ncreateNetworkHelperEntry(aggregatedStats.get(key), currentNetworkStats, endDateMillis);\nnumAcctsProcessed++;\n}\n\nif (networkStats != null) {\ncurrentNetworkStats = networkStats.get(key);\n}\ncreateNetworkHelperEntry(aggregatedStats.get(key), currentNetworkStats, endDateMillis);\nnumAcctsProcessed++;\n}\n_usageNetworkDao.saveUsageNetworks(usageNetworks);\nif (s_logger.isDebugEnabled()) {\ns_logger.debug(\"created network stats helper entries for \" + numAcctsProcessed + \" accts\");\n}\n\/\/ get vm disk stats in order to compute vm disk usage\nvmDiskUsages = _usageVmDiskDao.getRecentVmDiskStats();\n\/\/ Keep track of user stats for an account, across all of its public IPs\nMap<String, VmDiskStatisticsVO> aggregatedDiskStats = new HashMap<String, VmDiskStatisticsVO>();\nstartIndex = 0;\ndo {\nvmDiskStats = _vmDiskStatsDao.listActiveAndRecentlyDeleted(recentlyDeletedDate, startIndex, 500);\nif (vmDiskUsages != null) {\nfor (VmDiskStatisticsVO vmDiskStat : vmDiskStats) {\nif (vmDiskStat.getVmId() != null) {\nString hostKey =\n\ncreateHelperRecord(event);\n}\n}\n\/\/ TODO: Fetch a maximum number of user stats and process them before moving on to the next range of user stats\n\/\/ get user stats in order to compute network usage\nnetworkStats = _usageNetworkDao.getRecentNetworkStats();\nCalendar recentlyDeletedCal = Calendar.getInstance(_usageTimezone);\nrecentlyDeletedCal.setTimeInMillis(startDateMillis);\nrecentlyDeletedCal.add(Calendar.MINUTE, -1 * THREE_DAYS_IN_MINUTES);\nDate recentlyDeletedDate = recentlyDeletedCal.getTime();\n\/\/ Keep track of user stats for an account, across all of its public IPs\nMap<String, UserStatisticsVO> aggregatedStats = new HashMap<String, UserStatisticsVO>();\nint startIndex = 0;\ndo {\nuserStats = _userStatsDao.listActiveAndRecentlyDeleted(recentlyDeletedDate, startIndex, 500);\nif (userStats != null) {\nfor (UserStatisticsVO userStat : userStats) {\nif (userStat.getDeviceId() != null) {\nString hostKey = userStat.getDataCenterId() + \"-\" + userStat.getAccountId() + \"-Host-\" + userStat.getDeviceId();\nUserStatisticsVO hostAggregatedStat = aggregatedStats.get(hostKey);\nif (hostAggregatedStat == null) {\n\nhostAggregatedStat.setAggIORead(hostAggregatedStat.getAggIORead() + vmDiskStat.getAggIORead());\nhostAggregatedStat.setAggIOWrite(hostAggregatedStat.getAggIOWrite() + vmDiskStat.getAggIOWrite());\nhostAggregatedStat.setAggBytesRead(hostAggregatedStat.getAggBytesRead() + vmDiskStat.getAggBytesRead());\nhostAggregatedStat.setAggBytesWrite(hostAggregatedStat.getAggBytesWrite() + vmDiskStat.getAggBytesWrite());\naggregatedDiskStats.put(hostKey, hostAggregatedStat);\n}\n}\n}\nstartIndex += 500;\n} while ((userStats != null) && !userStats.isEmpty());\n\/\/ loop over the user stats, create delta entries in the usage_disk helper table\nnumAcctsProcessed = 0;\nusageVmDisks.clear();\nfor (String key : aggregatedDiskStats.keySet()) {\nUsageVmDiskVO currentVmDiskStats = null;\nif (vmDiskStats != null) {\ncurrentVmDiskStats = vmDiskUsages.get(key);\n}\ncreateVmDiskHelperEntry(aggregatedDiskStats.get(key), currentVmDiskStats, endDateMillis);\nnumAcctsProcessed++;\n}\n\nif (vmDiskStats != null) {\ncurrentVmDiskStats = vmDiskUsages.get(key);\n}\ncreateVmDiskHelperEntry(aggregatedDiskStats.get(key), currentVmDiskStats, endDateMillis);\nnumAcctsProcessed++;\n}\n_usageVmDiskDao.saveUsageVmDisks(usageVmDisks);\nif (s_logger.isDebugEnabled()) {\ns_logger.debug(\"created vm disk stats helper entries for \" + numAcctsProcessed + \" accts\");\n}\n\/\/ commit the helper records, then start a new transaction\nusageTxn.commit();\nusageTxn.start();\nboolean parsed = false;\nnumAcctsProcessed = 0;\nDate currentStartDate = startDate;\nDate currentEndDate = endDate;\nDate tempDate = endDate;\nCalendar aggregateCal = Calendar.getInstance(_usageTimezone);\nwhile ((tempDate.after(startDate)) && ((tempDate.getTime() - startDate.getTime()) > 60000)) {\ncurrentEndDate = tempDate;\n\n}\ndo {\nFilter filter = new Filter(AccountVO.class, \"id\", true, offset, limit);\naccounts = _accountDao.findActiveAccounts(lastAccountId, filter);\nif ((accounts != null) && !accounts.isEmpty()) {\n\/\/ now update the accounts in the cloud_usage db\n_usageDao.updateAccounts(accounts);\n}\noffset = new Long(offset.longValue() + limit.longValue());\n} while ((accounts != null) && !accounts.isEmpty());\n\/\/ reset offset\noffset = Long.valueOf(0);\ndo {\nFilter filter = new Filter(AccountVO.class, \"id\", true, offset, limit);\naccounts = _accountDao.findRecentlyDeletedAccounts(lastAccountId, startDate, filter);\nif ((accounts != null) && !accounts.isEmpty()) {\n\/\/ now update the accounts in the cloud_usage db\n_usageDao.updateAccounts(accounts);\n}\noffset = new Long(offset.longValue() + limit.longValue());\n} while ((accounts != null) && !accounts.isEmpty());\n\n\/\/ reset offset\noffset = Long.valueOf(0);\ndo {\nFilter filter = new Filter(AccountVO.class, \"id\", true, offset, limit);\naccounts = _accountDao.findRecentlyDeletedAccounts(null, recentlyDeletedDate, filter);\nif ((accounts != null) && !accounts.isEmpty()) {\nfor (AccountVO account : accounts) {\nparsed = parseHelperTables(account, currentStartDate, currentEndDate);\nList<Long> publicTemplates = _usageDao.listPublicTemplatesByAccount(account.getId());\nfor (Long templateId : publicTemplates) {\n\/\/mark public templates owned by deleted accounts as deleted\nList<UsageStorageVO> storageVOs = _usageStorageDao.listById(account.getId(), templateId, StorageTypes.TEMPLATE);\nif (storageVOs.size() > 1) {\ns_logger.warn(\"More that one usage entry for storage: \" + templateId + \" assigned to account: \" + account.getId() +\n\"; marking them all as deleted...\");\n}\nfor (UsageStorageVO storageVO : storageVOs) {\nif (s_logger.isDebugEnabled()) {\ns_logger.debug(\"deleting template: \" + storageVO.getId() + \" from account: \" + storageVO.getAccountId());\n}\nstorageVO.setDeleted(account.getRemoved());\n\noffset = new Long(offset.longValue() + limit.longValue());\n} while ((accounts != null) && !accounts.isEmpty());\ncurrentStartDate = new Date(currentEndDate.getTime() + 1);\naggregateCal.setTime(currentEndDate);\naggregateCal.add(Calendar.MINUTE, _aggregationDuration);\ncurrentEndDate = aggregateCal.getTime();\n}\nif (s_logger.isDebugEnabled()) {\ns_logger.debug(\"processed Usage for \" + numAcctsProcessed + \" RECENTLY DELETED accts\");\n}\n\/\/ FIXME: we don't break the above loop if something fails to parse, so it gets reset every account,\n\/\/ do we want to break out of processing accounts and rollback if there are errors?\nif (!parsed) {\nusageTxn.rollback();\n} else {\nsuccess = true;\n}\n} catch (Exception ex) {\ns_logger.error(\"Exception in usage manager\", ex);\nusageTxn.rollback();\n} finally {\n\/\/ everything seemed to work...set endDate as the last success date\n\nif (lastSuccess != 0) {\nstartDateMillis = lastSuccess + 1; \/\/ 1 millisecond after\n}\nif (startDateMillis >= endDateMillis) {\nif (s_logger.isInfoEnabled()) {\ns_logger.info(\"not parsing usage records since start time mills (\" + startDateMillis + \") is on or after end time millis (\" + endDateMillis + \")\");\n}\nTransactionLegacy jobUpdateTxn = TransactionLegacy.open(TransactionLegacy.USAGE_DB);\ntry {\njobUpdateTxn.start();\n\/\/ everything seemed to work...set endDate as the last success date\n_usageJobDao.updateJobSuccess(job.getId(), startDateMillis, endDateMillis, System.currentTimeMillis() - timeStart, success);\n\/\/ create a new job if this is a recurring job\nif (job.getJobType() == UsageJobVO.JOB_TYPE_RECURRING) {\n_usageJobDao.createNewJob(_hostname, _pid, UsageJobVO.JOB_TYPE_RECURRING);\n}\njobUpdateTxn.commit();\n} finally {\njobUpdateTxn.close();\n}\nreturn;\n\n}\nif (startDateMillis >= endDateMillis) {\nif (s_logger.isInfoEnabled()) {\ns_logger.info(\"not parsing usage records since start time mills (\" + startDateMillis + \") is on or after end time millis (\" + endDateMillis + \")\");\n}\nTransactionLegacy jobUpdateTxn = TransactionLegacy.open(TransactionLegacy.USAGE_DB);\ntry {\njobUpdateTxn.start();\n\/\/ everything seemed to work...set endDate as the last success date\n_usageJobDao.updateJobSuccess(job.getId(), startDateMillis, endDateMillis, System.currentTimeMillis() - timeStart, success);\n\/\/ create a new job if this is a recurring job\nif (job.getJobType() == UsageJobVO.JOB_TYPE_RECURRING) {\n_usageJobDao.createNewJob(_hostname, _pid, UsageJobVO.JOB_TYPE_RECURRING);\n}\njobUpdateTxn.commit();\n} finally {\njobUpdateTxn.close();\n}\nreturn;\n}\nDate startDate = new Date(startDateMillis);\n\nusageTxn.rollback();\n} finally {\n\/\/ everything seemed to work...set endDate as the last success date\n_usageJobDao.updateJobSuccess(job.getId(), startDateMillis, endDateMillis, System.currentTimeMillis() - timeStart, success);\n\/\/ create a new job if this is a recurring job\nif (job.getJobType() == UsageJobVO.JOB_TYPE_RECURRING) {\n_usageJobDao.createNewJob(_hostname, _pid, UsageJobVO.JOB_TYPE_RECURRING);\n}\nusageTxn.commit();\nusageTxn.close();\n\/\/ switch back to CLOUD_DB\nTransactionLegacy swap = TransactionLegacy.open(TransactionLegacy.CLOUD_DB);\nif (!success) {\n_alertMgr.sendAlert(AlertManager.AlertType.ALERT_TYPE_USAGE_SERVER_RESULT, 0, new Long(0), \"Usage job failed. Job id: \" + job.getId(),\n\"Usage job failed. Job id: \" + job.getId());\n} else {\n_alertMgr.clearAlert(AlertManager.AlertType.ALERT_TYPE_USAGE_SERVER_RESULT, 0, 0);\n}\nswap.close();\n}\n} catch (Exception e) {","code_context_20":"@Override\npublic void parse(UsageJobVO job, long startDateMillis, long endDateMillis) {\n\/\/ TODO: Shouldn't we also allow parsing by the type of usage?\nboolean success = false;\nlong timeStart = System.currentTimeMillis();\ntry {\nif ((endDateMillis == 0) || (endDateMillis > timeStart)) {\nendDateMillis = timeStart;\n}\nlong lastSuccess = _usageJobDao.getLastJobSuccessDateMillis();\nif (lastSuccess != 0) {\nstartDateMillis = lastSuccess + 1; \/\/ 1 millisecond after\n}\nif (startDateMillis >= endDateMillis) {\nif (s_logger.isInfoEnabled()) {\ns_logger.info(\"not parsing usage records since start time mills (\" + startDateMillis + \") is on or after end time millis (\" + endDateMillis + \")\");\n}\nTransactionLegacy jobUpdateTxn = TransactionLegacy.open(TransactionLegacy.USAGE_DB);\ntry {\njobUpdateTxn.start();\n\/\/ everything seemed to work...set endDate as the last success date\n_usageJobDao.updateJobSuccess(job.getId(), startDateMillis, endDateMillis, System.currentTimeMillis() - timeStart, success);\n\/\/ create a new job if this is a recurring job\n\n@Override\npublic void parse(UsageJobVO job, long startDateMillis, long endDateMillis) {\n\/\/ TODO: Shouldn't we also allow parsing by the type of usage?\nboolean success = false;\nlong timeStart = System.currentTimeMillis();\ntry {\nif ((endDateMillis == 0) || (endDateMillis > timeStart)) {\nendDateMillis = timeStart;\n}\nlong lastSuccess = _usageJobDao.getLastJobSuccessDateMillis();\nif (lastSuccess != 0) {\nstartDateMillis = lastSuccess + 1; \/\/ 1 millisecond after\n}\nif (startDateMillis >= endDateMillis) {\nif (s_logger.isInfoEnabled()) {\ns_logger.info(\"not parsing usage records since start time mills (\" + startDateMillis + \") is on or after end time millis (\" + endDateMillis + \")\");\n}\nTransactionLegacy jobUpdateTxn = TransactionLegacy.open(TransactionLegacy.USAGE_DB);\ntry {\njobUpdateTxn.start();\n\/\/ everything seemed to work...set endDate as the last success date\n_usageJobDao.updateJobSuccess(job.getId(), startDateMillis, endDateMillis, System.currentTimeMillis() - timeStart, success);\n\/\/ create a new job if this is a recurring job\nif (job.getJobType() == UsageJobVO.JOB_TYPE_RECURRING) {\n_usageJobDao.createNewJob(_hostname, _pid, UsageJobVO.JOB_TYPE_RECURRING);\n}\njobUpdateTxn.commit();\n} finally {\njobUpdateTxn.close();\n}\nreturn;\n}\n\n@Override\npublic void parse(UsageJobVO job, long startDateMillis, long endDateMillis) {\n\/\/ TODO: Shouldn't we also allow parsing by the type of usage?\nboolean success = false;\nlong timeStart = System.currentTimeMillis();\ntry {\nif ((endDateMillis == 0) || (endDateMillis > timeStart)) {\nendDateMillis = timeStart;\n}\nlong lastSuccess = _usageJobDao.getLastJobSuccessDateMillis();\nif (lastSuccess != 0) {\nstartDateMillis = lastSuccess + 1; \/\/ 1 millisecond after\n}\nif (startDateMillis >= endDateMillis) {\nif (s_logger.isInfoEnabled()) {\ns_logger.info(\"not parsing usage records since start time mills (\" + startDateMillis + \") is on or after end time millis (\" + endDateMillis + \")\");\n}\nTransactionLegacy jobUpdateTxn = TransactionLegacy.open(TransactionLegacy.USAGE_DB);\ntry {\njobUpdateTxn.start();\n\/\/ everything seemed to work...set endDate as the last success date\n_usageJobDao.updateJobSuccess(job.getId(), startDateMillis, endDateMillis, System.currentTimeMillis() - timeStart, success);\n\/\/ create a new job if this is a recurring job\nif (job.getJobType() == UsageJobVO.JOB_TYPE_RECURRING) {\n_usageJobDao.createNewJob(_hostname, _pid, UsageJobVO.JOB_TYPE_RECURRING);\n}\njobUpdateTxn.commit();\n} finally {\njobUpdateTxn.close();\n}\nreturn;\n}\nDate startDate = new Date(startDateMillis);\nDate endDate = new Date(endDateMillis);\nif (s_logger.isInfoEnabled()) {\ns_logger.info(\"Parsing usage records between \" + startDate + \" and \" + endDate);\n}\nList<AccountVO> accounts = null;\nList<UserStatisticsVO> userStats = null;\nMap<String, UsageNetworkVO> networkStats = null;\nList<VmDiskStatisticsVO> vmDiskStats = null;\n\n\/\/ TODO: Shouldn't we also allow parsing by the type of usage?\nboolean success = false;\nlong timeStart = System.currentTimeMillis();\ntry {\nif ((endDateMillis == 0) || (endDateMillis > timeStart)) {\nendDateMillis = timeStart;\n}\nlong lastSuccess = _usageJobDao.getLastJobSuccessDateMillis();\nif (lastSuccess != 0) {\nstartDateMillis = lastSuccess + 1; \/\/ 1 millisecond after\n}\nif (startDateMillis >= endDateMillis) {\nif (s_logger.isInfoEnabled()) {\ns_logger.info(\"not parsing usage records since start time mills (\" + startDateMillis + \") is on or after end time millis (\" + endDateMillis + \")\");\n}\nTransactionLegacy jobUpdateTxn = TransactionLegacy.open(TransactionLegacy.USAGE_DB);\ntry {\njobUpdateTxn.start();\n\/\/ everything seemed to work...set endDate as the last success date\n_usageJobDao.updateJobSuccess(job.getId(), startDateMillis, endDateMillis, System.currentTimeMillis() - timeStart, success);\n\/\/ create a new job if this is a recurring job\nif (job.getJobType() == UsageJobVO.JOB_TYPE_RECURRING) {\n_usageJobDao.createNewJob(_hostname, _pid, UsageJobVO.JOB_TYPE_RECURRING);\n}\njobUpdateTxn.commit();\n} finally {\njobUpdateTxn.close();\n}\nreturn;\n}\nDate startDate = new Date(startDateMillis);\nDate endDate = new Date(endDateMillis);\nif (s_logger.isInfoEnabled()) {\ns_logger.info(\"Parsing usage records between \" + startDate + \" and \" + endDate);\n}\nList<AccountVO> accounts = null;\nList<UserStatisticsVO> userStats = null;\nMap<String, UsageNetworkVO> networkStats = null;\nList<VmDiskStatisticsVO> vmDiskStats = null;\nMap<String, UsageVmDiskVO> vmDiskUsages = null;\nTransactionLegacy userTxn = TransactionLegacy.open(TransactionLegacy.CLOUD_DB);\n\nif (s_logger.isInfoEnabled()) {\ns_logger.info(\"Parsing usage records between \" + startDate + \" and \" + endDate);\n}\nList<AccountVO> accounts = null;\nList<UserStatisticsVO> userStats = null;\nMap<String, UsageNetworkVO> networkStats = null;\nList<VmDiskStatisticsVO> vmDiskStats = null;\nMap<String, UsageVmDiskVO> vmDiskUsages = null;\nTransactionLegacy userTxn = TransactionLegacy.open(TransactionLegacy.CLOUD_DB);\ntry {\nLong limit = Long.valueOf(500);\nLong offset = Long.valueOf(0);\nLong lastAccountId = _usageDao.getLastAccountId();\nif (lastAccountId == null) {\nlastAccountId = Long.valueOf(0);\n}\ndo {\nFilter filter = new Filter(AccountVO.class, \"id\", true, offset, limit);\naccounts = _accountDao.findActiveAccounts(lastAccountId, filter);\nif ((accounts != null) && !accounts.isEmpty()) {\n\/\/ now update the accounts in the cloud_usage db\n_usageDao.updateAccounts(accounts);\n}\noffset = new Long(offset.longValue() + limit.longValue());\n} while ((accounts != null) && !accounts.isEmpty());\n\/\/ reset offset\noffset = Long.valueOf(0);\ndo {\nFilter filter = new Filter(AccountVO.class, \"id\", true, offset, limit);\naccounts = _accountDao.findRecentlyDeletedAccounts(lastAccountId, startDate, filter);\nif ((accounts != null) && !accounts.isEmpty()) {\n\/\/ now update the accounts in the cloud_usage db\n_usageDao.updateAccounts(accounts);\n}\noffset = new Long(offset.longValue() + limit.longValue());\n} while ((accounts != null) && !accounts.isEmpty());\n\/\/ reset offset\noffset = Long.valueOf(0);\ndo {\nFilter filter = new Filter(AccountVO.class, \"id\", true, offset, limit);\naccounts = _accountDao.findNewAccounts(lastAccountId, filter);\n\nMap<String, UsageNetworkVO> networkStats = null;\nList<VmDiskStatisticsVO> vmDiskStats = null;\nMap<String, UsageVmDiskVO> vmDiskUsages = null;\nTransactionLegacy userTxn = TransactionLegacy.open(TransactionLegacy.CLOUD_DB);\ntry {\nLong limit = Long.valueOf(500);\nLong offset = Long.valueOf(0);\nLong lastAccountId = _usageDao.getLastAccountId();\nif (lastAccountId == null) {\nlastAccountId = Long.valueOf(0);\n}\ndo {\nFilter filter = new Filter(AccountVO.class, \"id\", true, offset, limit);\naccounts = _accountDao.findActiveAccounts(lastAccountId, filter);\nif ((accounts != null) && !accounts.isEmpty()) {\n\/\/ now update the accounts in the cloud_usage db\n_usageDao.updateAccounts(accounts);\n}\noffset = new Long(offset.longValue() + limit.longValue());\n} while ((accounts != null) && !accounts.isEmpty());\n\/\/ reset offset\noffset = Long.valueOf(0);\ndo {\nFilter filter = new Filter(AccountVO.class, \"id\", true, offset, limit);\naccounts = _accountDao.findRecentlyDeletedAccounts(lastAccountId, startDate, filter);\nif ((accounts != null) && !accounts.isEmpty()) {\n\/\/ now update the accounts in the cloud_usage db\n_usageDao.updateAccounts(accounts);\n}\noffset = new Long(offset.longValue() + limit.longValue());\n} while ((accounts != null) && !accounts.isEmpty());\n\/\/ reset offset\noffset = Long.valueOf(0);\ndo {\nFilter filter = new Filter(AccountVO.class, \"id\", true, offset, limit);\naccounts = _accountDao.findNewAccounts(lastAccountId, filter);\nif ((accounts != null) && !accounts.isEmpty()) {\n\/\/ now copy the accounts to cloud_usage db\n_usageDao.saveAccounts(accounts);\n}\noffset = new Long(offset.longValue() + limit.longValue());\n\nif (s_logger.isInfoEnabled()) {\ns_logger.info(\"Parsing usage records between \" + startDate + \" and \" + endDate);\n}\nList<AccountVO> accounts = null;\nList<UserStatisticsVO> userStats = null;\nMap<String, UsageNetworkVO> networkStats = null;\nList<VmDiskStatisticsVO> vmDiskStats = null;\nMap<String, UsageVmDiskVO> vmDiskUsages = null;\nTransactionLegacy userTxn = TransactionLegacy.open(TransactionLegacy.CLOUD_DB);\ntry {\nLong limit = Long.valueOf(500);\nLong offset = Long.valueOf(0);\nLong lastAccountId = _usageDao.getLastAccountId();\nif (lastAccountId == null) {\nlastAccountId = Long.valueOf(0);\n}\ndo {\nFilter filter = new Filter(AccountVO.class, \"id\", true, offset, limit);\naccounts = _accountDao.findActiveAccounts(lastAccountId, filter);\nif ((accounts != null) && !accounts.isEmpty()) {\n\/\/ now update the accounts in the cloud_usage db\n_usageDao.updateAccounts(accounts);\n}\noffset = new Long(offset.longValue() + limit.longValue());\n} while ((accounts != null) && !accounts.isEmpty());\n\/\/ reset offset\noffset = Long.valueOf(0);\ndo {\nFilter filter = new Filter(AccountVO.class, \"id\", true, offset, limit);\naccounts = _accountDao.findRecentlyDeletedAccounts(lastAccountId, startDate, filter);\nif ((accounts != null) && !accounts.isEmpty()) {\n\/\/ now update the accounts in the cloud_usage db\n_usageDao.updateAccounts(accounts);\n}\noffset = new Long(offset.longValue() + limit.longValue());\n} while ((accounts != null) && !accounts.isEmpty());\n\/\/ reset offset\noffset = Long.valueOf(0);\ndo {\nFilter filter = new Filter(AccountVO.class, \"id\", true, offset, limit);\naccounts = _accountDao.findNewAccounts(lastAccountId, filter);\n\nMap<String, UsageNetworkVO> networkStats = null;\nList<VmDiskStatisticsVO> vmDiskStats = null;\nMap<String, UsageVmDiskVO> vmDiskUsages = null;\nTransactionLegacy userTxn = TransactionLegacy.open(TransactionLegacy.CLOUD_DB);\ntry {\nLong limit = Long.valueOf(500);\nLong offset = Long.valueOf(0);\nLong lastAccountId = _usageDao.getLastAccountId();\nif (lastAccountId == null) {\nlastAccountId = Long.valueOf(0);\n}\ndo {\nFilter filter = new Filter(AccountVO.class, \"id\", true, offset, limit);\naccounts = _accountDao.findActiveAccounts(lastAccountId, filter);\nif ((accounts != null) && !accounts.isEmpty()) {\n\/\/ now update the accounts in the cloud_usage db\n_usageDao.updateAccounts(accounts);\n}\noffset = new Long(offset.longValue() + limit.longValue());\n} while ((accounts != null) && !accounts.isEmpty());\n\/\/ reset offset\noffset = Long.valueOf(0);\ndo {\nFilter filter = new Filter(AccountVO.class, \"id\", true, offset, limit);\naccounts = _accountDao.findRecentlyDeletedAccounts(lastAccountId, startDate, filter);\nif ((accounts != null) && !accounts.isEmpty()) {\n\/\/ now update the accounts in the cloud_usage db\n_usageDao.updateAccounts(accounts);\n}\noffset = new Long(offset.longValue() + limit.longValue());\n} while ((accounts != null) && !accounts.isEmpty());\n\/\/ reset offset\noffset = Long.valueOf(0);\ndo {\nFilter filter = new Filter(AccountVO.class, \"id\", true, offset, limit);\naccounts = _accountDao.findNewAccounts(lastAccountId, filter);\nif ((accounts != null) && !accounts.isEmpty()) {\n\/\/ now copy the accounts to cloud_usage db\n_usageDao.saveAccounts(accounts);\n}\noffset = new Long(offset.longValue() + limit.longValue());\n\n}\noffset = new Long(offset.longValue() + limit.longValue());\n} while ((accounts != null) && !accounts.isEmpty());\n\/\/ reset offset\noffset = Long.valueOf(0);\ndo {\nFilter filter = new Filter(AccountVO.class, \"id\", true, offset, limit);\naccounts = _accountDao.findRecentlyDeletedAccounts(lastAccountId, startDate, filter);\nif ((accounts != null) && !accounts.isEmpty()) {\n\/\/ now update the accounts in the cloud_usage db\n_usageDao.updateAccounts(accounts);\n}\noffset = new Long(offset.longValue() + limit.longValue());\n} while ((accounts != null) && !accounts.isEmpty());\n\/\/ reset offset\noffset = Long.valueOf(0);\ndo {\nFilter filter = new Filter(AccountVO.class, \"id\", true, offset, limit);\naccounts = _accountDao.findNewAccounts(lastAccountId, filter);\nif ((accounts != null) && !accounts.isEmpty()) {\n\/\/ now copy the accounts to cloud_usage db\n_usageDao.saveAccounts(accounts);\n}\noffset = new Long(offset.longValue() + limit.longValue());\n} while ((accounts != null) && !accounts.isEmpty());\n\/\/ reset offset\noffset = Long.valueOf(0);\n\/\/ get all the user stats to create usage records for the network usage\nLong lastUserStatsId = _usageDao.getLastUserStatsId();\nif (lastUserStatsId == null) {\nlastUserStatsId = Long.valueOf(0);\n}\nSearchCriteria<UserStatisticsVO> sc2 = _userStatsDao.createSearchCriteria();\nsc2.addAnd(\"id\", SearchCriteria.Op.LTEQ, lastUserStatsId);\ndo {\nFilter filter = new Filter(UserStatisticsVO.class, \"id\", true, offset, limit);\nuserStats = _userStatsDao.search(sc2, filter);\nif ((userStats != null) && !userStats.isEmpty()) {\n\/\/ now copy the accounts to cloud_usage db\n_usageDao.updateUserStats(userStats);\n}\n\nMap<String, UsageNetworkVO> networkStats = null;\nList<VmDiskStatisticsVO> vmDiskStats = null;\nMap<String, UsageVmDiskVO> vmDiskUsages = null;\nTransactionLegacy userTxn = TransactionLegacy.open(TransactionLegacy.CLOUD_DB);\ntry {\nLong limit = Long.valueOf(500);\nLong offset = Long.valueOf(0);\nLong lastAccountId = _usageDao.getLastAccountId();\nif (lastAccountId == null) {\nlastAccountId = Long.valueOf(0);\n}\ndo {\nFilter filter = new Filter(AccountVO.class, \"id\", true, offset, limit);\naccounts = _accountDao.findActiveAccounts(lastAccountId, filter);\nif ((accounts != null) && !accounts.isEmpty()) {\n\/\/ now update the accounts in the cloud_usage db\n_usageDao.updateAccounts(accounts);\n}\noffset = new Long(offset.longValue() + limit.longValue());\n} while ((accounts != null) && !accounts.isEmpty());\n\/\/ reset offset\noffset = Long.valueOf(0);\ndo {\nFilter filter = new Filter(AccountVO.class, \"id\", true, offset, limit);\naccounts = _accountDao.findRecentlyDeletedAccounts(lastAccountId, startDate, filter);\nif ((accounts != null) && !accounts.isEmpty()) {\n\/\/ now update the accounts in the cloud_usage db\n_usageDao.updateAccounts(accounts);\n}\noffset = new Long(offset.longValue() + limit.longValue());\n} while ((accounts != null) && !accounts.isEmpty());\n\/\/ reset offset\noffset = Long.valueOf(0);\ndo {\nFilter filter = new Filter(AccountVO.class, \"id\", true, offset, limit);\naccounts = _accountDao.findNewAccounts(lastAccountId, filter);\nif ((accounts != null) && !accounts.isEmpty()) {\n\/\/ now copy the accounts to cloud_usage db\n_usageDao.saveAccounts(accounts);\n}\noffset = new Long(offset.longValue() + limit.longValue());\n\naccounts = _accountDao.findRecentlyDeletedAccounts(lastAccountId, startDate, filter);\nif ((accounts != null) && !accounts.isEmpty()) {\n\/\/ now update the accounts in the cloud_usage db\n_usageDao.updateAccounts(accounts);\n}\noffset = new Long(offset.longValue() + limit.longValue());\n} while ((accounts != null) && !accounts.isEmpty());\n\/\/ reset offset\noffset = Long.valueOf(0);\ndo {\nFilter filter = new Filter(AccountVO.class, \"id\", true, offset, limit);\naccounts = _accountDao.findNewAccounts(lastAccountId, filter);\nif ((accounts != null) && !accounts.isEmpty()) {\n\/\/ now copy the accounts to cloud_usage db\n_usageDao.saveAccounts(accounts);\n}\noffset = new Long(offset.longValue() + limit.longValue());\n} while ((accounts != null) && !accounts.isEmpty());\n\/\/ reset offset\noffset = Long.valueOf(0);\n\/\/ get all the user stats to create usage records for the network usage\nLong lastUserStatsId = _usageDao.getLastUserStatsId();\nif (lastUserStatsId == null) {\nlastUserStatsId = Long.valueOf(0);\n}\nSearchCriteria<UserStatisticsVO> sc2 = _userStatsDao.createSearchCriteria();\nsc2.addAnd(\"id\", SearchCriteria.Op.LTEQ, lastUserStatsId);\ndo {\nFilter filter = new Filter(UserStatisticsVO.class, \"id\", true, offset, limit);\nuserStats = _userStatsDao.search(sc2, filter);\nif ((userStats != null) && !userStats.isEmpty()) {\n\/\/ now copy the accounts to cloud_usage db\n_usageDao.updateUserStats(userStats);\n}\noffset = new Long(offset.longValue() + limit.longValue());\n} while ((userStats != null) && !userStats.isEmpty());\n\/\/ reset offset\noffset = Long.valueOf(0);\nsc2 = _userStatsDao.createSearchCriteria();\nsc2.addAnd(\"id\", SearchCriteria.Op.GT, lastUserStatsId);\ndo {\n\n}\noffset = new Long(offset.longValue() + limit.longValue());\n} while ((accounts != null) && !accounts.isEmpty());\n\/\/ reset offset\noffset = Long.valueOf(0);\ndo {\nFilter filter = new Filter(AccountVO.class, \"id\", true, offset, limit);\naccounts = _accountDao.findRecentlyDeletedAccounts(lastAccountId, startDate, filter);\nif ((accounts != null) && !accounts.isEmpty()) {\n\/\/ now update the accounts in the cloud_usage db\n_usageDao.updateAccounts(accounts);\n}\noffset = new Long(offset.longValue() + limit.longValue());\n} while ((accounts != null) && !accounts.isEmpty());\n\/\/ reset offset\noffset = Long.valueOf(0);\ndo {\nFilter filter = new Filter(AccountVO.class, \"id\", true, offset, limit);\naccounts = _accountDao.findNewAccounts(lastAccountId, filter);\nif ((accounts != null) && !accounts.isEmpty()) {\n\/\/ now copy the accounts to cloud_usage db\n_usageDao.saveAccounts(accounts);\n}\noffset = new Long(offset.longValue() + limit.longValue());\n} while ((accounts != null) && !accounts.isEmpty());\n\/\/ reset offset\noffset = Long.valueOf(0);\n\/\/ get all the user stats to create usage records for the network usage\nLong lastUserStatsId = _usageDao.getLastUserStatsId();\nif (lastUserStatsId == null) {\nlastUserStatsId = Long.valueOf(0);\n}\nSearchCriteria<UserStatisticsVO> sc2 = _userStatsDao.createSearchCriteria();\nsc2.addAnd(\"id\", SearchCriteria.Op.LTEQ, lastUserStatsId);\ndo {\nFilter filter = new Filter(UserStatisticsVO.class, \"id\", true, offset, limit);\nuserStats = _userStatsDao.search(sc2, filter);\nif ((userStats != null) && !userStats.isEmpty()) {\n\/\/ now copy the accounts to cloud_usage db\n_usageDao.updateUserStats(userStats);\n}\n\nMap<String, UsageNetworkVO> networkStats = null;\nList<VmDiskStatisticsVO> vmDiskStats = null;\nMap<String, UsageVmDiskVO> vmDiskUsages = null;\nTransactionLegacy userTxn = TransactionLegacy.open(TransactionLegacy.CLOUD_DB);\ntry {\nLong limit = Long.valueOf(500);\nLong offset = Long.valueOf(0);\nLong lastAccountId = _usageDao.getLastAccountId();\nif (lastAccountId == null) {\nlastAccountId = Long.valueOf(0);\n}\ndo {\nFilter filter = new Filter(AccountVO.class, \"id\", true, offset, limit);\naccounts = _accountDao.findActiveAccounts(lastAccountId, filter);\nif ((accounts != null) && !accounts.isEmpty()) {\n\/\/ now update the accounts in the cloud_usage db\n_usageDao.updateAccounts(accounts);\n}\noffset = new Long(offset.longValue() + limit.longValue());\n} while ((accounts != null) && !accounts.isEmpty());\n\/\/ reset offset\noffset = Long.valueOf(0);\ndo {\nFilter filter = new Filter(AccountVO.class, \"id\", true, offset, limit);\naccounts = _accountDao.findRecentlyDeletedAccounts(lastAccountId, startDate, filter);\nif ((accounts != null) && !accounts.isEmpty()) {\n\/\/ now update the accounts in the cloud_usage db\n_usageDao.updateAccounts(accounts);\n}\noffset = new Long(offset.longValue() + limit.longValue());\n} while ((accounts != null) && !accounts.isEmpty());\n\/\/ reset offset\noffset = Long.valueOf(0);\ndo {\nFilter filter = new Filter(AccountVO.class, \"id\", true, offset, limit);\naccounts = _accountDao.findNewAccounts(lastAccountId, filter);\nif ((accounts != null) && !accounts.isEmpty()) {\n\/\/ now copy the accounts to cloud_usage db\n_usageDao.saveAccounts(accounts);\n}\noffset = new Long(offset.longValue() + limit.longValue());\n\n}\noffset = new Long(offset.longValue() + limit.longValue());\n} while ((accounts != null) && !accounts.isEmpty());\n\/\/ reset offset\noffset = Long.valueOf(0);\ndo {\nFilter filter = new Filter(AccountVO.class, \"id\", true, offset, limit);\naccounts = _accountDao.findRecentlyDeletedAccounts(lastAccountId, startDate, filter);\nif ((accounts != null) && !accounts.isEmpty()) {\n\/\/ now update the accounts in the cloud_usage db\n_usageDao.updateAccounts(accounts);\n}\noffset = new Long(offset.longValue() + limit.longValue());\n} while ((accounts != null) && !accounts.isEmpty());\n\/\/ reset offset\noffset = Long.valueOf(0);\ndo {\nFilter filter = new Filter(AccountVO.class, \"id\", true, offset, limit);\naccounts = _accountDao.findNewAccounts(lastAccountId, filter);\nif ((accounts != null) && !accounts.isEmpty()) {\n\/\/ now copy the accounts to cloud_usage db\n_usageDao.saveAccounts(accounts);\n}\noffset = new Long(offset.longValue() + limit.longValue());\n} while ((accounts != null) && !accounts.isEmpty());\n\/\/ reset offset\noffset = Long.valueOf(0);\n\/\/ get all the user stats to create usage records for the network usage\nLong lastUserStatsId = _usageDao.getLastUserStatsId();\nif (lastUserStatsId == null) {\nlastUserStatsId = Long.valueOf(0);\n}\nSearchCriteria<UserStatisticsVO> sc2 = _userStatsDao.createSearchCriteria();\nsc2.addAnd(\"id\", SearchCriteria.Op.LTEQ, lastUserStatsId);\ndo {\nFilter filter = new Filter(UserStatisticsVO.class, \"id\", true, offset, limit);\nuserStats = _userStatsDao.search(sc2, filter);\nif ((userStats != null) && !userStats.isEmpty()) {\n\/\/ now copy the accounts to cloud_usage db\n_usageDao.updateUserStats(userStats);\n}\n\nMap<String, UsageNetworkVO> networkStats = null;\nList<VmDiskStatisticsVO> vmDiskStats = null;\nMap<String, UsageVmDiskVO> vmDiskUsages = null;\nTransactionLegacy userTxn = TransactionLegacy.open(TransactionLegacy.CLOUD_DB);\ntry {\nLong limit = Long.valueOf(500);\nLong offset = Long.valueOf(0);\nLong lastAccountId = _usageDao.getLastAccountId();\nif (lastAccountId == null) {\nlastAccountId = Long.valueOf(0);\n}\ndo {\nFilter filter = new Filter(AccountVO.class, \"id\", true, offset, limit);\naccounts = _accountDao.findActiveAccounts(lastAccountId, filter);\nif ((accounts != null) && !accounts.isEmpty()) {\n\/\/ now update the accounts in the cloud_usage db\n_usageDao.updateAccounts(accounts);\n}\noffset = new Long(offset.longValue() + limit.longValue());\n} while ((accounts != null) && !accounts.isEmpty());\n\/\/ reset offset\noffset = Long.valueOf(0);\ndo {\nFilter filter = new Filter(AccountVO.class, \"id\", true, offset, limit);\naccounts = _accountDao.findRecentlyDeletedAccounts(lastAccountId, startDate, filter);\nif ((accounts != null) && !accounts.isEmpty()) {\n\/\/ now update the accounts in the cloud_usage db\n_usageDao.updateAccounts(accounts);\n}\noffset = new Long(offset.longValue() + limit.longValue());\n} while ((accounts != null) && !accounts.isEmpty());\n\/\/ reset offset\noffset = Long.valueOf(0);\ndo {\nFilter filter = new Filter(AccountVO.class, \"id\", true, offset, limit);\naccounts = _accountDao.findNewAccounts(lastAccountId, filter);\nif ((accounts != null) && !accounts.isEmpty()) {\n\/\/ now copy the accounts to cloud_usage db\n_usageDao.saveAccounts(accounts);\n}\noffset = new Long(offset.longValue() + limit.longValue());\n\n\/\/ now copy the accounts to cloud_usage db\n_usageDao.updateUserStats(userStats);\n}\noffset = new Long(offset.longValue() + limit.longValue());\n} while ((userStats != null) && !userStats.isEmpty());\n\/\/ reset offset\noffset = Long.valueOf(0);\nsc2 = _userStatsDao.createSearchCriteria();\nsc2.addAnd(\"id\", SearchCriteria.Op.GT, lastUserStatsId);\ndo {\nFilter filter = new Filter(UserStatisticsVO.class, \"id\", true, offset, limit);\nuserStats = _userStatsDao.search(sc2, filter);\nif ((userStats != null) && !userStats.isEmpty()) {\n\/\/ now copy the accounts to cloud_usage db\n_usageDao.saveUserStats(userStats);\n}\noffset = new Long(offset.longValue() + limit.longValue());\n} while ((userStats != null) && !userStats.isEmpty());\n\/\/ reset offset\noffset = Long.valueOf(0);\n\/\/ get all the vm network stats to create usage_VM_network records for the vm network usage\nLong lastVmDiskStatsId = _usageDao.getLastVmDiskStatsId();\nif (lastVmDiskStatsId == null) {\nlastVmDiskStatsId = Long.valueOf(0);\n}\nSearchCriteria<VmDiskStatisticsVO> sc4 = _vmDiskStatsDao.createSearchCriteria();\nsc4.addAnd(\"id\", SearchCriteria.Op.LTEQ, lastVmDiskStatsId);\ndo {\nFilter filter = new Filter(VmDiskStatisticsVO.class, \"id\", true, offset, limit);\nvmDiskStats = _vmDiskStatsDao.search(sc4, filter);\nif ((vmDiskStats != null) && !vmDiskStats.isEmpty()) {\n\/\/ now copy the accounts to cloud_usage db\n_usageDao.updateVmDiskStats(vmDiskStats);\n}\noffset = new Long(offset.longValue() + limit.longValue());\n} while ((vmDiskStats != null) && !vmDiskStats.isEmpty());\n\/\/ reset offset\noffset = Long.valueOf(0);\nsc4 = _vmDiskStatsDao.createSearchCriteria();\nsc4.addAnd(\"id\", SearchCriteria.Op.GT, lastVmDiskStatsId);\ndo {\n\n}\noffset = new Long(offset.longValue() + limit.longValue());\n} while ((accounts != null) && !accounts.isEmpty());\n\/\/ reset offset\noffset = Long.valueOf(0);\ndo {\nFilter filter = new Filter(AccountVO.class, \"id\", true, offset, limit);\naccounts = _accountDao.findRecentlyDeletedAccounts(lastAccountId, startDate, filter);\nif ((accounts != null) && !accounts.isEmpty()) {\n\/\/ now update the accounts in the cloud_usage db\n_usageDao.updateAccounts(accounts);\n}\noffset = new Long(offset.longValue() + limit.longValue());\n} while ((accounts != null) && !accounts.isEmpty());\n\/\/ reset offset\noffset = Long.valueOf(0);\ndo {\nFilter filter = new Filter(AccountVO.class, \"id\", true, offset, limit);\naccounts = _accountDao.findNewAccounts(lastAccountId, filter);\nif ((accounts != null) && !accounts.isEmpty()) {\n\/\/ now copy the accounts to cloud_usage db\n_usageDao.saveAccounts(accounts);\n}\noffset = new Long(offset.longValue() + limit.longValue());\n} while ((accounts != null) && !accounts.isEmpty());\n\/\/ reset offset\noffset = Long.valueOf(0);\n\/\/ get all the user stats to create usage records for the network usage\nLong lastUserStatsId = _usageDao.getLastUserStatsId();\nif (lastUserStatsId == null) {\nlastUserStatsId = Long.valueOf(0);\n}\nSearchCriteria<UserStatisticsVO> sc2 = _userStatsDao.createSearchCriteria();\nsc2.addAnd(\"id\", SearchCriteria.Op.LTEQ, lastUserStatsId);\ndo {\nFilter filter = new Filter(UserStatisticsVO.class, \"id\", true, offset, limit);\nuserStats = _userStatsDao.search(sc2, filter);\nif ((userStats != null) && !userStats.isEmpty()) {\n\/\/ now copy the accounts to cloud_usage db\n_usageDao.updateUserStats(userStats);\n}\n\nMap<String, UsageNetworkVO> networkStats = null;\nList<VmDiskStatisticsVO> vmDiskStats = null;\nMap<String, UsageVmDiskVO> vmDiskUsages = null;\nTransactionLegacy userTxn = TransactionLegacy.open(TransactionLegacy.CLOUD_DB);\ntry {\nLong limit = Long.valueOf(500);\nLong offset = Long.valueOf(0);\nLong lastAccountId = _usageDao.getLastAccountId();\nif (lastAccountId == null) {\nlastAccountId = Long.valueOf(0);\n}\ndo {\nFilter filter = new Filter(AccountVO.class, \"id\", true, offset, limit);\naccounts = _accountDao.findActiveAccounts(lastAccountId, filter);\nif ((accounts != null) && !accounts.isEmpty()) {\n\/\/ now update the accounts in the cloud_usage db\n_usageDao.updateAccounts(accounts);\n}\noffset = new Long(offset.longValue() + limit.longValue());\n} while ((accounts != null) && !accounts.isEmpty());\n\/\/ reset offset\noffset = Long.valueOf(0);\ndo {\nFilter filter = new Filter(AccountVO.class, \"id\", true, offset, limit);\naccounts = _accountDao.findRecentlyDeletedAccounts(lastAccountId, startDate, filter);\nif ((accounts != null) && !accounts.isEmpty()) {\n\/\/ now update the accounts in the cloud_usage db\n_usageDao.updateAccounts(accounts);\n}\noffset = new Long(offset.longValue() + limit.longValue());\n} while ((accounts != null) && !accounts.isEmpty());\n\/\/ reset offset\noffset = Long.valueOf(0);\ndo {\nFilter filter = new Filter(AccountVO.class, \"id\", true, offset, limit);\naccounts = _accountDao.findNewAccounts(lastAccountId, filter);\nif ((accounts != null) && !accounts.isEmpty()) {\n\/\/ now copy the accounts to cloud_usage db\n_usageDao.saveAccounts(accounts);\n}\noffset = new Long(offset.longValue() + limit.longValue());\n\n}\noffset = new Long(offset.longValue() + limit.longValue());\n} while ((accounts != null) && !accounts.isEmpty());\n\/\/ reset offset\noffset = Long.valueOf(0);\ndo {\nFilter filter = new Filter(AccountVO.class, \"id\", true, offset, limit);\naccounts = _accountDao.findRecentlyDeletedAccounts(lastAccountId, startDate, filter);\nif ((accounts != null) && !accounts.isEmpty()) {\n\/\/ now update the accounts in the cloud_usage db\n_usageDao.updateAccounts(accounts);\n}\noffset = new Long(offset.longValue() + limit.longValue());\n} while ((accounts != null) && !accounts.isEmpty());\n\/\/ reset offset\noffset = Long.valueOf(0);\ndo {\nFilter filter = new Filter(AccountVO.class, \"id\", true, offset, limit);\naccounts = _accountDao.findNewAccounts(lastAccountId, filter);\nif ((accounts != null) && !accounts.isEmpty()) {\n\/\/ now copy the accounts to cloud_usage db\n_usageDao.saveAccounts(accounts);\n}\noffset = new Long(offset.longValue() + limit.longValue());\n} while ((accounts != null) && !accounts.isEmpty());\n\/\/ reset offset\noffset = Long.valueOf(0);\n\/\/ get all the user stats to create usage records for the network usage\nLong lastUserStatsId = _usageDao.getLastUserStatsId();\nif (lastUserStatsId == null) {\nlastUserStatsId = Long.valueOf(0);\n}\nSearchCriteria<UserStatisticsVO> sc2 = _userStatsDao.createSearchCriteria();\nsc2.addAnd(\"id\", SearchCriteria.Op.LTEQ, lastUserStatsId);\ndo {\nFilter filter = new Filter(UserStatisticsVO.class, \"id\", true, offset, limit);\nuserStats = _userStatsDao.search(sc2, filter);\nif ((userStats != null) && !userStats.isEmpty()) {\n\/\/ now copy the accounts to cloud_usage db\n_usageDao.updateUserStats(userStats);\n}\n\n_usageDao.updateVmDiskStats(vmDiskStats);\n}\noffset = new Long(offset.longValue() + limit.longValue());\n} while ((vmDiskStats != null) && !vmDiskStats.isEmpty());\n\/\/ reset offset\noffset = Long.valueOf(0);\nsc4 = _vmDiskStatsDao.createSearchCriteria();\nsc4.addAnd(\"id\", SearchCriteria.Op.GT, lastVmDiskStatsId);\ndo {\nFilter filter = new Filter(VmDiskStatisticsVO.class, \"id\", true, offset, limit);\nvmDiskStats = _vmDiskStatsDao.search(sc4, filter);\nif ((vmDiskStats != null) && !vmDiskStats.isEmpty()) {\n\/\/ now copy the accounts to cloud_usage db\n_usageDao.saveVmDiskStats(vmDiskStats);\n}\noffset = new Long(offset.longValue() + limit.longValue());\n} while ((vmDiskStats != null) && !vmDiskStats.isEmpty());\n} finally {\nuserTxn.close();\n}\n\/\/ TODO: Fetch a maximum number of events and process them before moving on to the next range of events\n\/\/ - get a list of the latest events\n\/\/ - insert the latest events into the usage.events table\nList<UsageEventVO> events = _usageEventDao.getRecentEvents(new Date(endDateMillis));\nTransactionLegacy usageTxn = TransactionLegacy.open(TransactionLegacy.USAGE_DB);\ntry {\nusageTxn.start();\n\/\/ make sure start date is before all of our un-processed events (the events are ordered oldest\n\/\/ to newest, so just test against the first event)\nif ((events != null) && (events.size() > 0)) {\nDate oldestEventDate = events.get(0).getCreateDate();\nif (oldestEventDate.getTime() < startDateMillis) {\nstartDateMillis = oldestEventDate.getTime();\nstartDate = new Date(startDateMillis);\n}\n\/\/ - loop over the list of events and create entries in the helper tables\n\/\/ - create the usage records using the parse methods below\nfor (UsageEventVO event : events) {\nevent.setProcessed(true);\n_usageEventDao.update(event.getId(), event);\ncreateHelperRecord(event);\n}\n}\n\nsc4.addAnd(\"id\", SearchCriteria.Op.GT, lastVmDiskStatsId);\ndo {\nFilter filter = new Filter(VmDiskStatisticsVO.class, \"id\", true, offset, limit);\nvmDiskStats = _vmDiskStatsDao.search(sc4, filter);\nif ((vmDiskStats != null) && !vmDiskStats.isEmpty()) {\n\/\/ now copy the accounts to cloud_usage db\n_usageDao.saveVmDiskStats(vmDiskStats);\n}\noffset = new Long(offset.longValue() + limit.longValue());\n} while ((vmDiskStats != null) && !vmDiskStats.isEmpty());\n} finally {\nuserTxn.close();\n}\n\/\/ TODO: Fetch a maximum number of events and process them before moving on to the next range of events\n\/\/ - get a list of the latest events\n\/\/ - insert the latest events into the usage.events table\nList<UsageEventVO> events = _usageEventDao.getRecentEvents(new Date(endDateMillis));\nTransactionLegacy usageTxn = TransactionLegacy.open(TransactionLegacy.USAGE_DB);\ntry {\nusageTxn.start();\n\/\/ make sure start date is before all of our un-processed events (the events are ordered oldest\n\/\/ to newest, so just test against the first event)\nif ((events != null) && (events.size() > 0)) {\nDate oldestEventDate = events.get(0).getCreateDate();\nif (oldestEventDate.getTime() < startDateMillis) {\nstartDateMillis = oldestEventDate.getTime();\nstartDate = new Date(startDateMillis);\n}\n\/\/ - loop over the list of events and create entries in the helper tables\n\/\/ - create the usage records using the parse methods below\nfor (UsageEventVO event : events) {\nevent.setProcessed(true);\n_usageEventDao.update(event.getId(), event);\ncreateHelperRecord(event);\n}\n}\n\/\/ TODO: Fetch a maximum number of user stats and process them before moving on to the next range of user stats\n\/\/ get user stats in order to compute network usage\nnetworkStats = _usageNetworkDao.getRecentNetworkStats();\nCalendar recentlyDeletedCal = Calendar.getInstance(_usageTimezone);\nrecentlyDeletedCal.setTimeInMillis(startDateMillis);\nrecentlyDeletedCal.add(Calendar.MINUTE, -1 * THREE_DAYS_IN_MINUTES);\n\noffset = new Long(offset.longValue() + limit.longValue());\n} while ((vmDiskStats != null) && !vmDiskStats.isEmpty());\n} finally {\nuserTxn.close();\n}\n\/\/ TODO: Fetch a maximum number of events and process them before moving on to the next range of events\n\/\/ - get a list of the latest events\n\/\/ - insert the latest events into the usage.events table\nList<UsageEventVO> events = _usageEventDao.getRecentEvents(new Date(endDateMillis));\nTransactionLegacy usageTxn = TransactionLegacy.open(TransactionLegacy.USAGE_DB);\ntry {\nusageTxn.start();\n\/\/ make sure start date is before all of our un-processed events (the events are ordered oldest\n\/\/ to newest, so just test against the first event)\nif ((events != null) && (events.size() > 0)) {\nDate oldestEventDate = events.get(0).getCreateDate();\nif (oldestEventDate.getTime() < startDateMillis) {\nstartDateMillis = oldestEventDate.getTime();\nstartDate = new Date(startDateMillis);\n}\n\/\/ - loop over the list of events and create entries in the helper tables\n\/\/ - create the usage records using the parse methods below\nfor (UsageEventVO event : events) {\nevent.setProcessed(true);\n_usageEventDao.update(event.getId(), event);\ncreateHelperRecord(event);\n}\n}\n\/\/ TODO: Fetch a maximum number of user stats and process them before moving on to the next range of user stats\n\/\/ get user stats in order to compute network usage\nnetworkStats = _usageNetworkDao.getRecentNetworkStats();\nCalendar recentlyDeletedCal = Calendar.getInstance(_usageTimezone);\nrecentlyDeletedCal.setTimeInMillis(startDateMillis);\nrecentlyDeletedCal.add(Calendar.MINUTE, -1 * THREE_DAYS_IN_MINUTES);\nDate recentlyDeletedDate = recentlyDeletedCal.getTime();\n\/\/ Keep track of user stats for an account, across all of its public IPs\nMap<String, UserStatisticsVO> aggregatedStats = new HashMap<String, UserStatisticsVO>();\nint startIndex = 0;\ndo {\nuserStats = _userStatsDao.listActiveAndRecentlyDeleted(recentlyDeletedDate, startIndex, 500);\nif (userStats != null) {\nfor (UserStatisticsVO userStat : userStats) {\n\nList<UsageEventVO> events = _usageEventDao.getRecentEvents(new Date(endDateMillis));\nTransactionLegacy usageTxn = TransactionLegacy.open(TransactionLegacy.USAGE_DB);\ntry {\nusageTxn.start();\n\/\/ make sure start date is before all of our un-processed events (the events are ordered oldest\n\/\/ to newest, so just test against the first event)\nif ((events != null) && (events.size() > 0)) {\nDate oldestEventDate = events.get(0).getCreateDate();\nif (oldestEventDate.getTime() < startDateMillis) {\nstartDateMillis = oldestEventDate.getTime();\nstartDate = new Date(startDateMillis);\n}\n\/\/ - loop over the list of events and create entries in the helper tables\n\/\/ - create the usage records using the parse methods below\nfor (UsageEventVO event : events) {\nevent.setProcessed(true);\n_usageEventDao.update(event.getId(), event);\ncreateHelperRecord(event);\n}\n}\n\/\/ TODO: Fetch a maximum number of user stats and process them before moving on to the next range of user stats\n\/\/ get user stats in order to compute network usage\nnetworkStats = _usageNetworkDao.getRecentNetworkStats();\nCalendar recentlyDeletedCal = Calendar.getInstance(_usageTimezone);\nrecentlyDeletedCal.setTimeInMillis(startDateMillis);\nrecentlyDeletedCal.add(Calendar.MINUTE, -1 * THREE_DAYS_IN_MINUTES);\nDate recentlyDeletedDate = recentlyDeletedCal.getTime();\n\/\/ Keep track of user stats for an account, across all of its public IPs\nMap<String, UserStatisticsVO> aggregatedStats = new HashMap<String, UserStatisticsVO>();\nint startIndex = 0;\ndo {\nuserStats = _userStatsDao.listActiveAndRecentlyDeleted(recentlyDeletedDate, startIndex, 500);\nif (userStats != null) {\nfor (UserStatisticsVO userStat : userStats) {\nif (userStat.getDeviceId() != null) {\nString hostKey = userStat.getDataCenterId() + \"-\" + userStat.getAccountId() + \"-Host-\" + userStat.getDeviceId();\nUserStatisticsVO hostAggregatedStat = aggregatedStats.get(hostKey);\nif (hostAggregatedStat == null) {\nhostAggregatedStat =\nnew UserStatisticsVO(userStat.getAccountId(), userStat.getDataCenterId(), userStat.getPublicIpAddress(), userStat.getDeviceId(),\nuserStat.getDeviceType(), userStat.getNetworkId());\n}\n\nDate oldestEventDate = events.get(0).getCreateDate();\nif (oldestEventDate.getTime() < startDateMillis) {\nstartDateMillis = oldestEventDate.getTime();\nstartDate = new Date(startDateMillis);\n}\n\/\/ - loop over the list of events and create entries in the helper tables\n\/\/ - create the usage records using the parse methods below\nfor (UsageEventVO event : events) {\nevent.setProcessed(true);\n_usageEventDao.update(event.getId(), event);\ncreateHelperRecord(event);\n}\n}\n\/\/ TODO: Fetch a maximum number of user stats and process them before moving on to the next range of user stats\n\/\/ get user stats in order to compute network usage\nnetworkStats = _usageNetworkDao.getRecentNetworkStats();\nCalendar recentlyDeletedCal = Calendar.getInstance(_usageTimezone);\nrecentlyDeletedCal.setTimeInMillis(startDateMillis);\nrecentlyDeletedCal.add(Calendar.MINUTE, -1 * THREE_DAYS_IN_MINUTES);\nDate recentlyDeletedDate = recentlyDeletedCal.getTime();\n\/\/ Keep track of user stats for an account, across all of its public IPs\nMap<String, UserStatisticsVO> aggregatedStats = new HashMap<String, UserStatisticsVO>();\nint startIndex = 0;\ndo {\nuserStats = _userStatsDao.listActiveAndRecentlyDeleted(recentlyDeletedDate, startIndex, 500);\nif (userStats != null) {\nfor (UserStatisticsVO userStat : userStats) {\nif (userStat.getDeviceId() != null) {\nString hostKey = userStat.getDataCenterId() + \"-\" + userStat.getAccountId() + \"-Host-\" + userStat.getDeviceId();\nUserStatisticsVO hostAggregatedStat = aggregatedStats.get(hostKey);\nif (hostAggregatedStat == null) {\nhostAggregatedStat =\nnew UserStatisticsVO(userStat.getAccountId(), userStat.getDataCenterId(), userStat.getPublicIpAddress(), userStat.getDeviceId(),\nuserStat.getDeviceType(), userStat.getNetworkId());\n}\nhostAggregatedStat.setAggBytesSent(hostAggregatedStat.getAggBytesSent() + userStat.getAggBytesSent());\nhostAggregatedStat.setAggBytesReceived(hostAggregatedStat.getAggBytesReceived() + userStat.getAggBytesReceived());\naggregatedStats.put(hostKey, hostAggregatedStat);\n}\n}\n}\n\ndo {\nuserStats = _userStatsDao.listActiveAndRecentlyDeleted(recentlyDeletedDate, startIndex, 500);\nif (userStats != null) {\nfor (UserStatisticsVO userStat : userStats) {\nif (userStat.getDeviceId() != null) {\nString hostKey = userStat.getDataCenterId() + \"-\" + userStat.getAccountId() + \"-Host-\" + userStat.getDeviceId();\nUserStatisticsVO hostAggregatedStat = aggregatedStats.get(hostKey);\nif (hostAggregatedStat == null) {\nhostAggregatedStat =\nnew UserStatisticsVO(userStat.getAccountId(), userStat.getDataCenterId(), userStat.getPublicIpAddress(), userStat.getDeviceId(),\nuserStat.getDeviceType(), userStat.getNetworkId());\n}\nhostAggregatedStat.setAggBytesSent(hostAggregatedStat.getAggBytesSent() + userStat.getAggBytesSent());\nhostAggregatedStat.setAggBytesReceived(hostAggregatedStat.getAggBytesReceived() + userStat.getAggBytesReceived());\naggregatedStats.put(hostKey, hostAggregatedStat);\n}\n}\n}\nstartIndex += 500;\n} while ((userStats != null) && !userStats.isEmpty());\n\/\/ loop over the user stats, create delta entries in the usage_network helper table\nint numAcctsProcessed = 0;\nusageNetworks.clear();\nfor (String key : aggregatedStats.keySet()) {\nUsageNetworkVO currentNetworkStats = null;\nif (networkStats != null) {\ncurrentNetworkStats = networkStats.get(key);\n}\ncreateNetworkHelperEntry(aggregatedStats.get(key), currentNetworkStats, endDateMillis);\nnumAcctsProcessed++;\n}\n_usageNetworkDao.saveUsageNetworks(usageNetworks);\nif (s_logger.isDebugEnabled()) {\ns_logger.debug(\"created network stats helper entries for \" + numAcctsProcessed + \" accts\");\n}\n\/\/ get vm disk stats in order to compute vm disk usage\nvmDiskUsages = _usageVmDiskDao.getRecentVmDiskStats();\n\/\/ Keep track of user stats for an account, across all of its public IPs\nMap<String, VmDiskStatisticsVO> aggregatedDiskStats = new HashMap<String, VmDiskStatisticsVO>();\nstartIndex = 0;\ndo {\n\n}\n}\n}\nstartIndex += 500;\n} while ((userStats != null) && !userStats.isEmpty());\n\/\/ loop over the user stats, create delta entries in the usage_network helper table\nint numAcctsProcessed = 0;\nusageNetworks.clear();\nfor (String key : aggregatedStats.keySet()) {\nUsageNetworkVO currentNetworkStats = null;\nif (networkStats != null) {\ncurrentNetworkStats = networkStats.get(key);\n}\ncreateNetworkHelperEntry(aggregatedStats.get(key), currentNetworkStats, endDateMillis);\nnumAcctsProcessed++;\n}\n_usageNetworkDao.saveUsageNetworks(usageNetworks);\nif (s_logger.isDebugEnabled()) {\ns_logger.debug(\"created network stats helper entries for \" + numAcctsProcessed + \" accts\");\n}\n\/\/ get vm disk stats in order to compute vm disk usage\nvmDiskUsages = _usageVmDiskDao.getRecentVmDiskStats();\n\/\/ Keep track of user stats for an account, across all of its public IPs\nMap<String, VmDiskStatisticsVO> aggregatedDiskStats = new HashMap<String, VmDiskStatisticsVO>();\nstartIndex = 0;\ndo {\nvmDiskStats = _vmDiskStatsDao.listActiveAndRecentlyDeleted(recentlyDeletedDate, startIndex, 500);\nif (vmDiskUsages != null) {\nfor (VmDiskStatisticsVO vmDiskStat : vmDiskStats) {\nif (vmDiskStat.getVmId() != null) {\nString hostKey =\nvmDiskStat.getDataCenterId() + \"-\" + vmDiskStat.getAccountId() + \"-Vm-\" + vmDiskStat.getVmId() + \"-Disk-\" + vmDiskStat.getVolumeId();\nVmDiskStatisticsVO hostAggregatedStat = aggregatedDiskStats.get(hostKey);\nif (hostAggregatedStat == null) {\nhostAggregatedStat =\nnew VmDiskStatisticsVO(vmDiskStat.getAccountId(), vmDiskStat.getDataCenterId(), vmDiskStat.getVmId(), vmDiskStat.getVolumeId());\n}\nhostAggregatedStat.setAggIORead(hostAggregatedStat.getAggIORead() + vmDiskStat.getAggIORead());\nhostAggregatedStat.setAggIOWrite(hostAggregatedStat.getAggIOWrite() + vmDiskStat.getAggIOWrite());\nhostAggregatedStat.setAggBytesRead(hostAggregatedStat.getAggBytesRead() + vmDiskStat.getAggBytesRead());\nhostAggregatedStat.setAggBytesWrite(hostAggregatedStat.getAggBytesWrite() + vmDiskStat.getAggBytesWrite());\n\nDate oldestEventDate = events.get(0).getCreateDate();\nif (oldestEventDate.getTime() < startDateMillis) {\nstartDateMillis = oldestEventDate.getTime();\nstartDate = new Date(startDateMillis);\n}\n\/\/ - loop over the list of events and create entries in the helper tables\n\/\/ - create the usage records using the parse methods below\nfor (UsageEventVO event : events) {\nevent.setProcessed(true);\n_usageEventDao.update(event.getId(), event);\ncreateHelperRecord(event);\n}\n}\n\/\/ TODO: Fetch a maximum number of user stats and process them before moving on to the next range of user stats\n\/\/ get user stats in order to compute network usage\nnetworkStats = _usageNetworkDao.getRecentNetworkStats();\nCalendar recentlyDeletedCal = Calendar.getInstance(_usageTimezone);\nrecentlyDeletedCal.setTimeInMillis(startDateMillis);\nrecentlyDeletedCal.add(Calendar.MINUTE, -1 * THREE_DAYS_IN_MINUTES);\nDate recentlyDeletedDate = recentlyDeletedCal.getTime();\n\/\/ Keep track of user stats for an account, across all of its public IPs\nMap<String, UserStatisticsVO> aggregatedStats = new HashMap<String, UserStatisticsVO>();\nint startIndex = 0;\ndo {\nuserStats = _userStatsDao.listActiveAndRecentlyDeleted(recentlyDeletedDate, startIndex, 500);\nif (userStats != null) {\nfor (UserStatisticsVO userStat : userStats) {\nif (userStat.getDeviceId() != null) {\nString hostKey = userStat.getDataCenterId() + \"-\" + userStat.getAccountId() + \"-Host-\" + userStat.getDeviceId();\nUserStatisticsVO hostAggregatedStat = aggregatedStats.get(hostKey);\nif (hostAggregatedStat == null) {\nhostAggregatedStat =\nnew UserStatisticsVO(userStat.getAccountId(), userStat.getDataCenterId(), userStat.getPublicIpAddress(), userStat.getDeviceId(),\nuserStat.getDeviceType(), userStat.getNetworkId());\n}\nhostAggregatedStat.setAggBytesSent(hostAggregatedStat.getAggBytesSent() + userStat.getAggBytesSent());\nhostAggregatedStat.setAggBytesReceived(hostAggregatedStat.getAggBytesReceived() + userStat.getAggBytesReceived());\naggregatedStats.put(hostKey, hostAggregatedStat);\n}\n}\n}\n\nif (vmDiskUsages != null) {\nfor (VmDiskStatisticsVO vmDiskStat : vmDiskStats) {\nif (vmDiskStat.getVmId() != null) {\nString hostKey =\nvmDiskStat.getDataCenterId() + \"-\" + vmDiskStat.getAccountId() + \"-Vm-\" + vmDiskStat.getVmId() + \"-Disk-\" + vmDiskStat.getVolumeId();\nVmDiskStatisticsVO hostAggregatedStat = aggregatedDiskStats.get(hostKey);\nif (hostAggregatedStat == null) {\nhostAggregatedStat =\nnew VmDiskStatisticsVO(vmDiskStat.getAccountId(), vmDiskStat.getDataCenterId(), vmDiskStat.getVmId(), vmDiskStat.getVolumeId());\n}\nhostAggregatedStat.setAggIORead(hostAggregatedStat.getAggIORead() + vmDiskStat.getAggIORead());\nhostAggregatedStat.setAggIOWrite(hostAggregatedStat.getAggIOWrite() + vmDiskStat.getAggIOWrite());\nhostAggregatedStat.setAggBytesRead(hostAggregatedStat.getAggBytesRead() + vmDiskStat.getAggBytesRead());\nhostAggregatedStat.setAggBytesWrite(hostAggregatedStat.getAggBytesWrite() + vmDiskStat.getAggBytesWrite());\naggregatedDiskStats.put(hostKey, hostAggregatedStat);\n}\n}\n}\nstartIndex += 500;\n} while ((userStats != null) && !userStats.isEmpty());\n\/\/ loop over the user stats, create delta entries in the usage_disk helper table\nnumAcctsProcessed = 0;\nusageVmDisks.clear();\nfor (String key : aggregatedDiskStats.keySet()) {\nUsageVmDiskVO currentVmDiskStats = null;\nif (vmDiskStats != null) {\ncurrentVmDiskStats = vmDiskUsages.get(key);\n}\ncreateVmDiskHelperEntry(aggregatedDiskStats.get(key), currentVmDiskStats, endDateMillis);\nnumAcctsProcessed++;\n}\n_usageVmDiskDao.saveUsageVmDisks(usageVmDisks);\nif (s_logger.isDebugEnabled()) {\ns_logger.debug(\"created vm disk stats helper entries for \" + numAcctsProcessed + \" accts\");\n}\n\/\/ commit the helper records, then start a new transaction\nusageTxn.commit();\nusageTxn.start();\nboolean parsed = false;\nnumAcctsProcessed = 0;\nDate currentStartDate = startDate;\n\n}\n}\n}\nstartIndex += 500;\n} while ((userStats != null) && !userStats.isEmpty());\n\/\/ loop over the user stats, create delta entries in the usage_disk helper table\nnumAcctsProcessed = 0;\nusageVmDisks.clear();\nfor (String key : aggregatedDiskStats.keySet()) {\nUsageVmDiskVO currentVmDiskStats = null;\nif (vmDiskStats != null) {\ncurrentVmDiskStats = vmDiskUsages.get(key);\n}\ncreateVmDiskHelperEntry(aggregatedDiskStats.get(key), currentVmDiskStats, endDateMillis);\nnumAcctsProcessed++;\n}\n_usageVmDiskDao.saveUsageVmDisks(usageVmDisks);\nif (s_logger.isDebugEnabled()) {\ns_logger.debug(\"created vm disk stats helper entries for \" + numAcctsProcessed + \" accts\");\n}\n\/\/ commit the helper records, then start a new transaction\nusageTxn.commit();\nusageTxn.start();\nboolean parsed = false;\nnumAcctsProcessed = 0;\nDate currentStartDate = startDate;\nDate currentEndDate = endDate;\nDate tempDate = endDate;\nCalendar aggregateCal = Calendar.getInstance(_usageTimezone);\nwhile ((tempDate.after(startDate)) && ((tempDate.getTime() - startDate.getTime()) > 60000)) {\ncurrentEndDate = tempDate;\naggregateCal.setTime(tempDate);\naggregateCal.add(Calendar.MINUTE, -_aggregationDuration);\ntempDate = aggregateCal.getTime();\n}\nwhile (!currentEndDate.after(endDate) || (currentEndDate.getTime() - endDate.getTime() < 60000)) {\nLong offset = Long.valueOf(0);\nLong limit = Long.valueOf(500);\ndo {\nFilter filter = new Filter(AccountVO.class, \"id\", true, offset, limit);\naccounts = _accountDao.listAll(filter);\n\nMap<String, UsageNetworkVO> networkStats = null;\nList<VmDiskStatisticsVO> vmDiskStats = null;\nMap<String, UsageVmDiskVO> vmDiskUsages = null;\nTransactionLegacy userTxn = TransactionLegacy.open(TransactionLegacy.CLOUD_DB);\ntry {\nLong limit = Long.valueOf(500);\nLong offset = Long.valueOf(0);\nLong lastAccountId = _usageDao.getLastAccountId();\nif (lastAccountId == null) {\nlastAccountId = Long.valueOf(0);\n}\ndo {\nFilter filter = new Filter(AccountVO.class, \"id\", true, offset, limit);\naccounts = _accountDao.findActiveAccounts(lastAccountId, filter);\nif ((accounts != null) && !accounts.isEmpty()) {\n\/\/ now update the accounts in the cloud_usage db\n_usageDao.updateAccounts(accounts);\n}\noffset = new Long(offset.longValue() + limit.longValue());\n} while ((accounts != null) && !accounts.isEmpty());\n\/\/ reset offset\noffset = Long.valueOf(0);\ndo {\nFilter filter = new Filter(AccountVO.class, \"id\", true, offset, limit);\naccounts = _accountDao.findRecentlyDeletedAccounts(lastAccountId, startDate, filter);\nif ((accounts != null) && !accounts.isEmpty()) {\n\/\/ now update the accounts in the cloud_usage db\n_usageDao.updateAccounts(accounts);\n}\noffset = new Long(offset.longValue() + limit.longValue());\n} while ((accounts != null) && !accounts.isEmpty());\n\/\/ reset offset\noffset = Long.valueOf(0);\ndo {\nFilter filter = new Filter(AccountVO.class, \"id\", true, offset, limit);\naccounts = _accountDao.findNewAccounts(lastAccountId, filter);\nif ((accounts != null) && !accounts.isEmpty()) {\n\/\/ now copy the accounts to cloud_usage db\n_usageDao.saveAccounts(accounts);\n}\noffset = new Long(offset.longValue() + limit.longValue());\n\nparsed = parseHelperTables(account, currentStartDate, currentEndDate);\nnumAcctsProcessed++;\n}\n}\noffset = new Long(offset.longValue() + limit.longValue());\n} while ((accounts != null) && !accounts.isEmpty());\nif (s_logger.isDebugEnabled()) {\ns_logger.debug(\"processed VM\/Network Usage for \" + numAcctsProcessed + \" ACTIVE accts\");\n}\nnumAcctsProcessed = 0;\n\/\/ reset offset\noffset = Long.valueOf(0);\ndo {\nFilter filter = new Filter(AccountVO.class, \"id\", true, offset, limit);\naccounts = _accountDao.findRecentlyDeletedAccounts(null, recentlyDeletedDate, filter);\nif ((accounts != null) && !accounts.isEmpty()) {\nfor (AccountVO account : accounts) {\nparsed = parseHelperTables(account, currentStartDate, currentEndDate);\nList<Long> publicTemplates = _usageDao.listPublicTemplatesByAccount(account.getId());\nfor (Long templateId : publicTemplates) {\n\/\/mark public templates owned by deleted accounts as deleted\nList<UsageStorageVO> storageVOs = _usageStorageDao.listById(account.getId(), templateId, StorageTypes.TEMPLATE);\nif (storageVOs.size() > 1) {\ns_logger.warn(\"More that one usage entry for storage: \" + templateId + \" assigned to account: \" + account.getId() +\n\"; marking them all as deleted...\");\n}\nfor (UsageStorageVO storageVO : storageVOs) {\nif (s_logger.isDebugEnabled()) {\ns_logger.debug(\"deleting template: \" + storageVO.getId() + \" from account: \" + storageVO.getAccountId());\n}\nstorageVO.setDeleted(account.getRemoved());\n_usageStorageDao.update(storageVO);\n}\n}\nnumAcctsProcessed++;\n}\n}\noffset = new Long(offset.longValue() + limit.longValue());\n} while ((accounts != null) && !accounts.isEmpty());\ncurrentStartDate = new Date(currentEndDate.getTime() + 1);\naggregateCal.setTime(currentEndDate);\n\nif (s_logger.isDebugEnabled()) {\ns_logger.debug(\"deleting template: \" + storageVO.getId() + \" from account: \" + storageVO.getAccountId());\n}\nstorageVO.setDeleted(account.getRemoved());\n_usageStorageDao.update(storageVO);\n}\n}\nnumAcctsProcessed++;\n}\n}\noffset = new Long(offset.longValue() + limit.longValue());\n} while ((accounts != null) && !accounts.isEmpty());\ncurrentStartDate = new Date(currentEndDate.getTime() + 1);\naggregateCal.setTime(currentEndDate);\naggregateCal.add(Calendar.MINUTE, _aggregationDuration);\ncurrentEndDate = aggregateCal.getTime();\n}\nif (s_logger.isDebugEnabled()) {\ns_logger.debug(\"processed Usage for \" + numAcctsProcessed + \" RECENTLY DELETED accts\");\n}\n\/\/ FIXME: we don't break the above loop if something fails to parse, so it gets reset every account,\n\/\/ do we want to break out of processing accounts and rollback if there are errors?\nif (!parsed) {\nusageTxn.rollback();\n} else {\nsuccess = true;\n}\n} catch (Exception ex) {\ns_logger.error(\"Exception in usage manager\", ex);\nusageTxn.rollback();\n} finally {\n\/\/ everything seemed to work...set endDate as the last success date\n_usageJobDao.updateJobSuccess(job.getId(), startDateMillis, endDateMillis, System.currentTimeMillis() - timeStart, success);\n\/\/ create a new job if this is a recurring job\nif (job.getJobType() == UsageJobVO.JOB_TYPE_RECURRING) {\n_usageJobDao.createNewJob(_hostname, _pid, UsageJobVO.JOB_TYPE_RECURRING);\n}\nusageTxn.commit();\nusageTxn.close();\n\/\/ switch back to CLOUD_DB\nTransactionLegacy swap = TransactionLegacy.open(TransactionLegacy.CLOUD_DB);\nif (!success) {\n\n@Override\npublic void parse(UsageJobVO job, long startDateMillis, long endDateMillis) {\n\/\/ TODO: Shouldn't we also allow parsing by the type of usage?\nboolean success = false;\nlong timeStart = System.currentTimeMillis();\ntry {\nif ((endDateMillis == 0) || (endDateMillis > timeStart)) {\nendDateMillis = timeStart;\n}\nlong lastSuccess = _usageJobDao.getLastJobSuccessDateMillis();\nif (lastSuccess != 0) {\nstartDateMillis = lastSuccess + 1; \/\/ 1 millisecond after\n}\nif (startDateMillis >= endDateMillis) {\nif (s_logger.isInfoEnabled()) {\ns_logger.info(\"not parsing usage records since start time mills (\" + startDateMillis + \") is on or after end time millis (\" + endDateMillis + \")\");\n}\nTransactionLegacy jobUpdateTxn = TransactionLegacy.open(TransactionLegacy.USAGE_DB);\ntry {\njobUpdateTxn.start();\n\/\/ everything seemed to work...set endDate as the last success date\n_usageJobDao.updateJobSuccess(job.getId(), startDateMillis, endDateMillis, System.currentTimeMillis() - timeStart, success);\n\/\/ create a new job if this is a recurring job\nif (job.getJobType() == UsageJobVO.JOB_TYPE_RECURRING) {\n_usageJobDao.createNewJob(_hostname, _pid, UsageJobVO.JOB_TYPE_RECURRING);\n}\njobUpdateTxn.commit();\n} finally {\njobUpdateTxn.close();\n}\nreturn;\n}\nDate startDate = new Date(startDateMillis);\nDate endDate = new Date(endDateMillis);\nif (s_logger.isInfoEnabled()) {\ns_logger.info(\"Parsing usage records between \" + startDate + \" and \" + endDate);\n}\nList<AccountVO> accounts = null;\nList<UserStatisticsVO> userStats = null;\nMap<String, UsageNetworkVO> networkStats = null;\nList<VmDiskStatisticsVO> vmDiskStats = null;\n\n\/\/ TODO: Shouldn't we also allow parsing by the type of usage?\nboolean success = false;\nlong timeStart = System.currentTimeMillis();\ntry {\nif ((endDateMillis == 0) || (endDateMillis > timeStart)) {\nendDateMillis = timeStart;\n}\nlong lastSuccess = _usageJobDao.getLastJobSuccessDateMillis();\nif (lastSuccess != 0) {\nstartDateMillis = lastSuccess + 1; \/\/ 1 millisecond after\n}\nif (startDateMillis >= endDateMillis) {\nif (s_logger.isInfoEnabled()) {\ns_logger.info(\"not parsing usage records since start time mills (\" + startDateMillis + \") is on or after end time millis (\" + endDateMillis + \")\");\n}\nTransactionLegacy jobUpdateTxn = TransactionLegacy.open(TransactionLegacy.USAGE_DB);\ntry {\njobUpdateTxn.start();\n\/\/ everything seemed to work...set endDate as the last success date\n_usageJobDao.updateJobSuccess(job.getId(), startDateMillis, endDateMillis, System.currentTimeMillis() - timeStart, success);\n\/\/ create a new job if this is a recurring job\nif (job.getJobType() == UsageJobVO.JOB_TYPE_RECURRING) {\n_usageJobDao.createNewJob(_hostname, _pid, UsageJobVO.JOB_TYPE_RECURRING);\n}\njobUpdateTxn.commit();\n} finally {\njobUpdateTxn.close();\n}\nreturn;\n}\nDate startDate = new Date(startDateMillis);\nDate endDate = new Date(endDateMillis);\nif (s_logger.isInfoEnabled()) {\ns_logger.info(\"Parsing usage records between \" + startDate + \" and \" + endDate);\n}\nList<AccountVO> accounts = null;\nList<UserStatisticsVO> userStats = null;\nMap<String, UsageNetworkVO> networkStats = null;\nList<VmDiskStatisticsVO> vmDiskStats = null;\nMap<String, UsageVmDiskVO> vmDiskUsages = null;\nTransactionLegacy userTxn = TransactionLegacy.open(TransactionLegacy.CLOUD_DB);\n\n}\n\/\/ FIXME: we don't break the above loop if something fails to parse, so it gets reset every account,\n\/\/ do we want to break out of processing accounts and rollback if there are errors?\nif (!parsed) {\nusageTxn.rollback();\n} else {\nsuccess = true;\n}\n} catch (Exception ex) {\ns_logger.error(\"Exception in usage manager\", ex);\nusageTxn.rollback();\n} finally {\n\/\/ everything seemed to work...set endDate as the last success date\n_usageJobDao.updateJobSuccess(job.getId(), startDateMillis, endDateMillis, System.currentTimeMillis() - timeStart, success);\n\/\/ create a new job if this is a recurring job\nif (job.getJobType() == UsageJobVO.JOB_TYPE_RECURRING) {\n_usageJobDao.createNewJob(_hostname, _pid, UsageJobVO.JOB_TYPE_RECURRING);\n}\nusageTxn.commit();\nusageTxn.close();\n\/\/ switch back to CLOUD_DB\nTransactionLegacy swap = TransactionLegacy.open(TransactionLegacy.CLOUD_DB);\nif (!success) {\n_alertMgr.sendAlert(AlertManager.AlertType.ALERT_TYPE_USAGE_SERVER_RESULT, 0, new Long(0), \"Usage job failed. Job id: \" + job.getId(),\n\"Usage job failed. Job id: \" + job.getId());\n} else {\n_alertMgr.clearAlert(AlertManager.AlertType.ALERT_TYPE_USAGE_SERVER_RESULT, 0, 0);\n}\nswap.close();\n}\n} catch (Exception e) {\ns_logger.error(\"Usage Manager error\", e);\n}\n}","label":[1,1,0,0]}
{"id":33175,"original_code":"@SuppressWarnings(\"unchecked\")\n\tpublic static <T> T[] toArray(List<T> list){\n\t\treturn (T[]) list.toArray();\n\t}","code":"@SuppressWarnings(\"unchecked\")\n\tpublic static <T> T[] toArray(List<T> list){\n\t\treturn (T[]) list.toArray();\n\t}","cleancode":"@suppresswarnings(\"unchecked\") public static <t> t[] toarray(list<t> list){ return (t[]) list.toarray(); }","comment":"\/\/fixme: do this without the suppresswarnings tag","repo":"sisbell\/appia","code_context_2":"@SuppressWarnings(\"unchecked\")\npublic static <T> T[] toArray(List<T> list){\nreturn (T[]) list.toArray();\n}","code_context_10":"@SuppressWarnings(\"unchecked\")\npublic static <T> T[] toArray(List<T> list){\nreturn (T[]) list.toArray();\n}","code_context_20":"@SuppressWarnings(\"unchecked\")\npublic static <T> T[] toArray(List<T> list){\nreturn (T[]) list.toArray();\n}","label":[1,0,0,0]}
{"id":408,"original_code":"@SuppressWarnings(\"nls\")\n  @Override\n  protected FilterResult doFilterInternal(HttpServletRequest request, HttpServletResponse response)\n      throws ServletException, IOException {\n    response = new IgnoreContentWrapper(response);\n    response.addHeader(\"P3P\", \"CP=\\\"CAO PSA OUR\\\"\");\n    response.setHeader(\"X-Content-Type-Options\", \"nosniff\");\n    \/\/ Chrome sucks.\n    \/\/ http:\/\/dev.equella.com\/issues\/8025\n    \/\/ http:\/\/dev.equella.com\/issues\/5612\n    String ua = request.getHeader(\"User-Agent\");\n    if (ua != null && ua.contains(\"Chrome\")) {\n      response.addHeader(\"X-XSS-Protection\", \"0\");\n    } else {\n      response.setHeader(\"X-XSS-Protection\", \"1; mode=block\");\n    }\n    if (stsMaxAge != -1) {\n      response.setHeader(\n          \"Strict-Transport-Security\", \"max-age=\" + stsMaxAge + \"; includeSubDomains\");\n    }\n    return new FilterResult(response);\n  }","code":"@SuppressWarnings(\"nls\")\n  @Override\n  protected FilterResult doFilterInternal(HttpServletRequest request, HttpServletResponse response)\n      throws ServletException, IOException {\n    response = new IgnoreContentWrapper(response);\n    response.addHeader(\"P3P\", \"CP=\\\"CAO PSA OUR\\\"\");\n    response.setHeader(\"X-Content-Type-Options\", \"nosniff\");\n   \n   \n   \n    String ua = request.getHeader(\"User-Agent\");\n    if (ua != null && ua.contains(\"Chrome\")) {\n      response.addHeader(\"X-XSS-Protection\", \"0\");\n    } else {\n      response.setHeader(\"X-XSS-Protection\", \"1; mode=block\");\n    }\n    if (stsMaxAge != -1) {\n      response.setHeader(\n          \"Strict-Transport-Security\", \"max-age=\" + stsMaxAge + \"; includeSubDomains\");\n    }\n    return new FilterResult(response);\n  }","cleancode":"@suppresswarnings(\"nls\") @override protected filterresult dofilterinternal(httpservletrequest request, httpservletresponse response) throws servletexception, ioexception { response = new ignorecontentwrapper(response); response.addheader(\"p3p\", \"cp=\\\"cao psa our\\\"\"); response.setheader(\"x-content-type-options\", \"nosniff\"); string ua = request.getheader(\"user-agent\"); if (ua != null && ua.contains(\"chrome\")) { response.addheader(\"x-xss-protection\", \"0\"); } else { response.setheader(\"x-xss-protection\", \"1; mode=block\"); } if (stsmaxage != -1) { response.setheader( \"strict-transport-security\", \"max-age=\" + stsmaxage + \"; includesubdomains\"); } return new filterresult(response); }","comment":"\/\/ chrome sucks. \/\/ http:\/\/dev.equella.com\/issues\/8025 \/\/ http:\/\/dev.equella.com\/issues\/5612","repo":"rmathis\/openEQUELLA","code_context_2":"response.addHeader(\"P3P\", \"CP=\\\"CAO PSA OUR\\\"\");\nresponse.setHeader(\"X-Content-Type-Options\", \"nosniff\");\n\/\/ Chrome sucks.\n\/\/ http:\/\/dev.equella.com\/issues\/8025\n\/\/ http:\/\/dev.equella.com\/issues\/5612\nString ua = request.getHeader(\"User-Agent\");\nif (ua != null && ua.contains(\"Chrome\")) {","code_context_10":"@SuppressWarnings(\"nls\")\n@Override\nprotected FilterResult doFilterInternal(HttpServletRequest request, HttpServletResponse response)\nthrows ServletException, IOException {\nresponse = new IgnoreContentWrapper(response);\nresponse.addHeader(\"P3P\", \"CP=\\\"CAO PSA OUR\\\"\");\nresponse.setHeader(\"X-Content-Type-Options\", \"nosniff\");\n\/\/ Chrome sucks.\n\/\/ http:\/\/dev.equella.com\/issues\/8025\n\/\/ http:\/\/dev.equella.com\/issues\/5612\nString ua = request.getHeader(\"User-Agent\");\nif (ua != null && ua.contains(\"Chrome\")) {\nresponse.addHeader(\"X-XSS-Protection\", \"0\");\n} else {\nresponse.setHeader(\"X-XSS-Protection\", \"1; mode=block\");\n}\nif (stsMaxAge != -1) {\nresponse.setHeader(\n\"Strict-Transport-Security\", \"max-age=\" + stsMaxAge + \"; includeSubDomains\");\n}","code_context_20":"@SuppressWarnings(\"nls\")\n@Override\nprotected FilterResult doFilterInternal(HttpServletRequest request, HttpServletResponse response)\nthrows ServletException, IOException {\nresponse = new IgnoreContentWrapper(response);\nresponse.addHeader(\"P3P\", \"CP=\\\"CAO PSA OUR\\\"\");\nresponse.setHeader(\"X-Content-Type-Options\", \"nosniff\");\n\/\/ Chrome sucks.\n\/\/ http:\/\/dev.equella.com\/issues\/8025\n\/\/ http:\/\/dev.equella.com\/issues\/5612\nString ua = request.getHeader(\"User-Agent\");\nif (ua != null && ua.contains(\"Chrome\")) {\nresponse.addHeader(\"X-XSS-Protection\", \"0\");\n} else {\nresponse.setHeader(\"X-XSS-Protection\", \"1; mode=block\");\n}\nif (stsMaxAge != -1) {\nresponse.setHeader(\n\"Strict-Transport-Security\", \"max-age=\" + stsMaxAge + \"; includeSubDomains\");\n}\nreturn new FilterResult(response);\n}","label":[0,0,1,0]}
{"id":16797,"original_code":"public static Listener createListener(boolean ads,\n      io.envoyproxy.envoy.api.v2.core.ApiVersion rdsTransportVersion,\n      io.envoyproxy.envoy.api.v2.core.ApiVersion rdsResourceVersion, String listenerName,\n      int port, String routeName) {\n    ConfigSource.Builder configSourceBuilder = ConfigSource.newBuilder()\n        .setResourceApiVersion(rdsResourceVersion);\n    ConfigSource rdsSource = ads\n        ? configSourceBuilder\n        .setAds(AggregatedConfigSource.getDefaultInstance())\n        .build()\n        : configSourceBuilder\n            .setApiConfigSource(ApiConfigSource.newBuilder()\n                .setApiType(ApiType.GRPC)\n                .setTransportApiVersion(rdsTransportVersion)\n                .addGrpcServices(GrpcService.newBuilder()\n                    .setEnvoyGrpc(EnvoyGrpc.newBuilder()\n                        .setClusterName(XDS_CLUSTER))))\n            .build();\n    HttpConnectionManager manager = HttpConnectionManager.newBuilder()\n        .setCodecType(CodecType.AUTO)\n        .setStatPrefix(\"http\")\n        .setRds(Rds.newBuilder()\n            .setConfigSource(rdsSource)\n            .setRouteConfigName(routeName))\n        .addHttpFilters(HttpFilter.newBuilder()\n            .setName(Resources.FILTER_ENVOY_ROUTER))\n        .build();\n    return Listener.newBuilder()\n        .setName(listenerName)\n        .setAddress(Address.newBuilder()\n            .setSocketAddress(SocketAddress.newBuilder()\n                .setAddress(ANY_ADDRESS)\n                .setPortValue(port)\n                .setProtocol(Protocol.TCP)))\n        .addFilterChains(FilterChain.newBuilder()\n            .addFilters(Filter.newBuilder()\n                .setName(Resources.FILTER_HTTP_CONNECTION_MANAGER)\n                .setTypedConfig(Any.pack(manager))))\n        .build();\n  }","code":"public static Listener createListener(boolean ads,\n      io.envoyproxy.envoy.api.v2.core.ApiVersion rdsTransportVersion,\n      io.envoyproxy.envoy.api.v2.core.ApiVersion rdsResourceVersion, String listenerName,\n      int port, String routeName) {\n    ConfigSource.Builder configSourceBuilder = ConfigSource.newBuilder()\n        .setResourceApiVersion(rdsResourceVersion);\n    ConfigSource rdsSource = ads\n        ? configSourceBuilder\n        .setAds(AggregatedConfigSource.getDefaultInstance())\n        .build()\n        : configSourceBuilder\n            .setApiConfigSource(ApiConfigSource.newBuilder()\n                .setApiType(ApiType.GRPC)\n                .setTransportApiVersion(rdsTransportVersion)\n                .addGrpcServices(GrpcService.newBuilder()\n                    .setEnvoyGrpc(EnvoyGrpc.newBuilder()\n                        .setClusterName(XDS_CLUSTER))))\n            .build();\n    HttpConnectionManager manager = HttpConnectionManager.newBuilder()\n        .setCodecType(CodecType.AUTO)\n        .setStatPrefix(\"http\")\n        .setRds(Rds.newBuilder()\n            .setConfigSource(rdsSource)\n            .setRouteConfigName(routeName))\n        .addHttpFilters(HttpFilter.newBuilder()\n            .setName(Resources.FILTER_ENVOY_ROUTER))\n        .build();\n    return Listener.newBuilder()\n        .setName(listenerName)\n        .setAddress(Address.newBuilder()\n            .setSocketAddress(SocketAddress.newBuilder()\n                .setAddress(ANY_ADDRESS)\n                .setPortValue(port)\n                .setProtocol(Protocol.TCP)))\n        .addFilterChains(FilterChain.newBuilder()\n            .addFilters(Filter.newBuilder()\n                .setName(Resources.FILTER_HTTP_CONNECTION_MANAGER)\n                .setTypedConfig(Any.pack(manager))))\n        .build();\n  }","cleancode":"public static listener createlistener(boolean ads, io.envoyproxy.envoy.api.v2.core.apiversion rdstransportversion, io.envoyproxy.envoy.api.v2.core.apiversion rdsresourceversion, string listenername, int port, string routename) { configsource.builder configsourcebuilder = configsource.newbuilder() .setresourceapiversion(rdsresourceversion); configsource rdssource = ads ? configsourcebuilder .setads(aggregatedconfigsource.getdefaultinstance()) .build() : configsourcebuilder .setapiconfigsource(apiconfigsource.newbuilder() .setapitype(apitype.grpc) .settransportapiversion(rdstransportversion) .addgrpcservices(grpcservice.newbuilder() .setenvoygrpc(envoygrpc.newbuilder() .setclustername(xds_cluster)))) .build(); httpconnectionmanager manager = httpconnectionmanager.newbuilder() .setcodectype(codectype.auto) .setstatprefix(\"http\") .setrds(rds.newbuilder() .setconfigsource(rdssource) .setrouteconfigname(routename)) .addhttpfilters(httpfilter.newbuilder() .setname(resources.filter_envoy_router)) .build(); return listener.newbuilder() .setname(listenername) .setaddress(address.newbuilder() .setsocketaddress(socketaddress.newbuilder() .setaddress(any_address) .setportvalue(port) .setprotocol(protocol.tcp))) .addfilterchains(filterchain.newbuilder() .addfilters(filter.newbuilder() .setname(resources.filter_http_connection_manager) .settypedconfig(any.pack(manager)))) .build(); }","comment":"\/** * returns a new test listener. * @param ads should rds for the listener be configured to use xds? * @param rdstransportversion the transport_api_version that should be set for rds * @param rdsresourceversion the resource_api_version that should be set for rds * @param listenername name of the new listener * @param port port to use for the listener * @param routename name of the test route that is associated with this listener *\/","repo":"smtilden\/java-control-plane","code_context_2":"public static Listener createListener(boolean ads,\nio.envoyproxy.envoy.api.v2.core.ApiVersion rdsTransportVersion,\nio.envoyproxy.envoy.api.v2.core.ApiVersion rdsResourceVersion, String listenerName,\nint port, String routeName) {\nConfigSource.Builder configSourceBuilder = ConfigSource.newBuilder()\n.setResourceApiVersion(rdsResourceVersion);\nConfigSource rdsSource = ads\n? configSourceBuilder\n.setAds(AggregatedConfigSource.getDefaultInstance())\n.build()\n: configSourceBuilder\n.setApiConfigSource(ApiConfigSource.newBuilder()\n.setApiType(ApiType.GRPC)\n.setTransportApiVersion(rdsTransportVersion)\n.addGrpcServices(GrpcService.newBuilder()\n.setEnvoyGrpc(EnvoyGrpc.newBuilder()\n.setClusterName(XDS_CLUSTER))))\n.build();\nHttpConnectionManager manager = HttpConnectionManager.newBuilder()\n.setCodecType(CodecType.AUTO)\n.setStatPrefix(\"http\")\n.setRds(Rds.newBuilder()\n.setConfigSource(rdsSource)\n.setRouteConfigName(routeName))\n.addHttpFilters(HttpFilter.newBuilder()\n.setName(Resources.FILTER_ENVOY_ROUTER))\n.build();\nreturn Listener.newBuilder()\n.setName(listenerName)\n.setAddress(Address.newBuilder()\n.setSocketAddress(SocketAddress.newBuilder()\n.setAddress(ANY_ADDRESS)\n.setPortValue(port)\n.setProtocol(Protocol.TCP)))\n.addFilterChains(FilterChain.newBuilder()\n.addFilters(Filter.newBuilder()\n.setName(Resources.FILTER_HTTP_CONNECTION_MANAGER)\n.setTypedConfig(Any.pack(manager))))\n.build();\n}","code_context_10":"public static Listener createListener(boolean ads,\nio.envoyproxy.envoy.api.v2.core.ApiVersion rdsTransportVersion,\nio.envoyproxy.envoy.api.v2.core.ApiVersion rdsResourceVersion, String listenerName,\nint port, String routeName) {\nConfigSource.Builder configSourceBuilder = ConfigSource.newBuilder()\n.setResourceApiVersion(rdsResourceVersion);\nConfigSource rdsSource = ads\n? configSourceBuilder\n.setAds(AggregatedConfigSource.getDefaultInstance())\n.build()\n: configSourceBuilder\n.setApiConfigSource(ApiConfigSource.newBuilder()\n.setApiType(ApiType.GRPC)\n.setTransportApiVersion(rdsTransportVersion)\n.addGrpcServices(GrpcService.newBuilder()\n.setEnvoyGrpc(EnvoyGrpc.newBuilder()\n.setClusterName(XDS_CLUSTER))))\n.build();\nHttpConnectionManager manager = HttpConnectionManager.newBuilder()\n.setCodecType(CodecType.AUTO)\n.setStatPrefix(\"http\")\n.setRds(Rds.newBuilder()\n.setConfigSource(rdsSource)\n.setRouteConfigName(routeName))\n.addHttpFilters(HttpFilter.newBuilder()\n.setName(Resources.FILTER_ENVOY_ROUTER))\n.build();\nreturn Listener.newBuilder()\n.setName(listenerName)\n.setAddress(Address.newBuilder()\n.setSocketAddress(SocketAddress.newBuilder()\n.setAddress(ANY_ADDRESS)\n.setPortValue(port)\n.setProtocol(Protocol.TCP)))\n.addFilterChains(FilterChain.newBuilder()\n.addFilters(Filter.newBuilder()\n.setName(Resources.FILTER_HTTP_CONNECTION_MANAGER)\n.setTypedConfig(Any.pack(manager))))\n.build();\n}","code_context_20":"public static Listener createListener(boolean ads,\nio.envoyproxy.envoy.api.v2.core.ApiVersion rdsTransportVersion,\nio.envoyproxy.envoy.api.v2.core.ApiVersion rdsResourceVersion, String listenerName,\nint port, String routeName) {\nConfigSource.Builder configSourceBuilder = ConfigSource.newBuilder()\n.setResourceApiVersion(rdsResourceVersion);\nConfigSource rdsSource = ads\n? configSourceBuilder\n.setAds(AggregatedConfigSource.getDefaultInstance())\n.build()\n: configSourceBuilder\n.setApiConfigSource(ApiConfigSource.newBuilder()\n.setApiType(ApiType.GRPC)\n.setTransportApiVersion(rdsTransportVersion)\n.addGrpcServices(GrpcService.newBuilder()\n.setEnvoyGrpc(EnvoyGrpc.newBuilder()\n.setClusterName(XDS_CLUSTER))))\n.build();\nHttpConnectionManager manager = HttpConnectionManager.newBuilder()\n.setCodecType(CodecType.AUTO)\n.setStatPrefix(\"http\")\n.setRds(Rds.newBuilder()\n.setConfigSource(rdsSource)\n.setRouteConfigName(routeName))\n.addHttpFilters(HttpFilter.newBuilder()\n.setName(Resources.FILTER_ENVOY_ROUTER))\n.build();\nreturn Listener.newBuilder()\n.setName(listenerName)\n.setAddress(Address.newBuilder()\n.setSocketAddress(SocketAddress.newBuilder()\n.setAddress(ANY_ADDRESS)\n.setPortValue(port)\n.setProtocol(Protocol.TCP)))\n.addFilterChains(FilterChain.newBuilder()\n.addFilters(Filter.newBuilder()\n.setName(Resources.FILTER_HTTP_CONNECTION_MANAGER)\n.setTypedConfig(Any.pack(manager))))\n.build();\n}","label":[0,0,0,0]}
{"id":24996,"original_code":"@Override\n    public void performInitialization(Object model) {\n        setFieldBindingObjectPath(getBindingInfo().getBindingObjectPath());\n        super.performInitialization(model);\n        if (bindingInfo != null) {\n            bindingInfo.setDefaults(ViewLifecycle.getActiveLifecycle().getView(), getPropertyName());\n        }\n        \/\/ TODO: set object path for prototypes equal to the tree group object path?\n    }","code":"@Override\n    public void performInitialization(Object model) {\n        setFieldBindingObjectPath(getBindingInfo().getBindingObjectPath());\n        super.performInitialization(model);\n        if (bindingInfo != null) {\n            bindingInfo.setDefaults(ViewLifecycle.getActiveLifecycle().getView(), getPropertyName());\n        }\n       \n    }","cleancode":"@override public void performinitialization(object model) { setfieldbindingobjectpath(getbindinginfo().getbindingobjectpath()); super.performinitialization(model); if (bindinginfo != null) { bindinginfo.setdefaults(viewlifecycle.getactivelifecycle().getview(), getpropertyname()); } }","comment":"\/** * the following actions are performed: * * <ul> * <li>set fieldbindmodelpath to the collection model path (since the fields * have to belong to the same model as the collection)<\/li> * <li>set defaults for binding<\/li> * <li>calls view helper service to initialize prototypes<\/li> * <\/ul> *\/\n\/\/ todo: set object path for prototypes equal to the tree group object path?","repo":"ricepanda\/rice","code_context_2":"@Override\npublic void performInitialization(Object model) {\nsetFieldBindingObjectPath(getBindingInfo().getBindingObjectPath());\nsuper.performInitialization(model);\nif (bindingInfo != null) {\nbindingInfo.setDefaults(ViewLifecycle.getActiveLifecycle().getView(), getPropertyName());\n}\n\/\/ TODO: set object path for prototypes equal to the tree group object path?\n}\n\nbindingInfo.setDefaults(ViewLifecycle.getActiveLifecycle().getView(), getPropertyName());\n}\n\/\/ TODO: set object path for prototypes equal to the tree group object path?\n}","code_context_10":"@Override\npublic void performInitialization(Object model) {\nsetFieldBindingObjectPath(getBindingInfo().getBindingObjectPath());\nsuper.performInitialization(model);\nif (bindingInfo != null) {\nbindingInfo.setDefaults(ViewLifecycle.getActiveLifecycle().getView(), getPropertyName());\n}\n\/\/ TODO: set object path for prototypes equal to the tree group object path?\n}\n\n@Override\npublic void performInitialization(Object model) {\nsetFieldBindingObjectPath(getBindingInfo().getBindingObjectPath());\nsuper.performInitialization(model);\nif (bindingInfo != null) {\nbindingInfo.setDefaults(ViewLifecycle.getActiveLifecycle().getView(), getPropertyName());\n}\n\/\/ TODO: set object path for prototypes equal to the tree group object path?\n}","code_context_20":"@Override\npublic void performInitialization(Object model) {\nsetFieldBindingObjectPath(getBindingInfo().getBindingObjectPath());\nsuper.performInitialization(model);\nif (bindingInfo != null) {\nbindingInfo.setDefaults(ViewLifecycle.getActiveLifecycle().getView(), getPropertyName());\n}\n\/\/ TODO: set object path for prototypes equal to the tree group object path?\n}\n\n@Override\npublic void performInitialization(Object model) {\nsetFieldBindingObjectPath(getBindingInfo().getBindingObjectPath());\nsuper.performInitialization(model);\nif (bindingInfo != null) {\nbindingInfo.setDefaults(ViewLifecycle.getActiveLifecycle().getView(), getPropertyName());\n}\n\/\/ TODO: set object path for prototypes equal to the tree group object path?\n}","label":[0,1,0,0]}
{"id":25027,"original_code":"@Override\n    public Map<String, String> getOptionList(String id) {\n        \/\/ TODO: Return genre map\n        return super.getOptionList(id);\n    }","code":"@Override\n    public Map<String, String> getOptionList(String id) {\n       \n        return super.getOptionList(id);\n    }","cleancode":"@override public map<string, string> getoptionlist(string id) { return super.getoptionlist(id); }","comment":"\/\/ todo: return genre map","repo":"stuckless\/sagetv-phoenix-core","code_context_2":"@Override\npublic Map<String, String> getOptionList(String id) {\n\/\/ TODO: Return genre map\nreturn super.getOptionList(id);\n}","code_context_10":"@Override\npublic Map<String, String> getOptionList(String id) {\n\/\/ TODO: Return genre map\nreturn super.getOptionList(id);\n}","code_context_20":"@Override\npublic Map<String, String> getOptionList(String id) {\n\/\/ TODO: Return genre map\nreturn super.getOptionList(id);\n}","label":[0,1,0,0]}
{"id":16873,"original_code":"private List<InferenceInOutSequence> getInputOutputAssets() throws IOException {\n        \/\/ TODO: Caching, don't read inputs for every inference\n        List<InferenceInOutSequence> inOutList =\n                getInputOutputAssets(mContext, mInputOutputAssets, mInputOutputDatasets);\n        Boolean lastGolden = null;\n        for (InferenceInOutSequence sequence : inOutList) {\n            mHasGoldenOutputs = sequence.hasGoldenOutput();\n            if (lastGolden == null) {\n                lastGolden = mHasGoldenOutputs;\n            } else {\n                if (lastGolden != mHasGoldenOutputs) {\n                    throw new IllegalArgumentException(\n                            \"Some inputs for \" + mModelName + \" have outputs while some don't.\");\n                }\n            }\n        }\n        return inOutList;\n    }","code":"private List<InferenceInOutSequence> getInputOutputAssets() throws IOException {\n       \n        List<InferenceInOutSequence> inOutList =\n                getInputOutputAssets(mContext, mInputOutputAssets, mInputOutputDatasets);\n        Boolean lastGolden = null;\n        for (InferenceInOutSequence sequence : inOutList) {\n            mHasGoldenOutputs = sequence.hasGoldenOutput();\n            if (lastGolden == null) {\n                lastGolden = mHasGoldenOutputs;\n            } else {\n                if (lastGolden != mHasGoldenOutputs) {\n                    throw new IllegalArgumentException(\n                            \"Some inputs for \" + mModelName + \" have outputs while some don't.\");\n                }\n            }\n        }\n        return inOutList;\n    }","cleancode":"private list<inferenceinoutsequence> getinputoutputassets() throws ioexception { list<inferenceinoutsequence> inoutlist = getinputoutputassets(mcontext, minputoutputassets, minputoutputdatasets); boolean lastgolden = null; for (inferenceinoutsequence sequence : inoutlist) { mhasgoldenoutputs = sequence.hasgoldenoutput(); if (lastgolden == null) { lastgolden = mhasgoldenoutputs; } else { if (lastgolden != mhasgoldenoutputs) { throw new illegalargumentexception( \"some inputs for \" + mmodelname + \" have outputs while some don't.\"); } } } return inoutlist; }","comment":"\/\/ todo: caching, don't read inputs for every inference","repo":"riscv-android-src\/platform-test-mlts-benchmark","code_context_2":"private List<InferenceInOutSequence> getInputOutputAssets() throws IOException {\n\/\/ TODO: Caching, don't read inputs for every inference\nList<InferenceInOutSequence> inOutList =\ngetInputOutputAssets(mContext, mInputOutputAssets, mInputOutputDatasets);","code_context_10":"private List<InferenceInOutSequence> getInputOutputAssets() throws IOException {\n\/\/ TODO: Caching, don't read inputs for every inference\nList<InferenceInOutSequence> inOutList =\ngetInputOutputAssets(mContext, mInputOutputAssets, mInputOutputDatasets);\nBoolean lastGolden = null;\nfor (InferenceInOutSequence sequence : inOutList) {\nmHasGoldenOutputs = sequence.hasGoldenOutput();\nif (lastGolden == null) {\nlastGolden = mHasGoldenOutputs;\n} else {\nif (lastGolden != mHasGoldenOutputs) {\nthrow new IllegalArgumentException(","code_context_20":"private List<InferenceInOutSequence> getInputOutputAssets() throws IOException {\n\/\/ TODO: Caching, don't read inputs for every inference\nList<InferenceInOutSequence> inOutList =\ngetInputOutputAssets(mContext, mInputOutputAssets, mInputOutputDatasets);\nBoolean lastGolden = null;\nfor (InferenceInOutSequence sequence : inOutList) {\nmHasGoldenOutputs = sequence.hasGoldenOutput();\nif (lastGolden == null) {\nlastGolden = mHasGoldenOutputs;\n} else {\nif (lastGolden != mHasGoldenOutputs) {\nthrow new IllegalArgumentException(\n\"Some inputs for \" + mModelName + \" have outputs while some don't.\");\n}\n}\n}\nreturn inOutList;\n}","label":[0,1,0,0]}
{"id":16874,"original_code":"public static List<InferenceInOutSequence> getInputOutputAssets(Context context,\n            InferenceInOutSequence.FromAssets[] inputOutputAssets,\n            InferenceInOutSequence.FromDataset[] inputOutputDatasets) throws IOException {\n        \/\/ TODO: Caching, don't read inputs for every inference\n        List<InferenceInOutSequence> inOutList = new ArrayList<>();\n        if (inputOutputAssets != null) {\n            for (InferenceInOutSequence.FromAssets ioAsset : inputOutputAssets) {\n                inOutList.add(ioAsset.readAssets(context.getAssets()));\n            }\n        }\n        if (inputOutputDatasets != null) {\n            for (InferenceInOutSequence.FromDataset dataset : inputOutputDatasets) {\n                inOutList.addAll(dataset.readDataset(context.getAssets(), context.getCacheDir()));\n            }\n        }\n        return inOutList;\n    }","code":"public static List<InferenceInOutSequence> getInputOutputAssets(Context context,\n            InferenceInOutSequence.FromAssets[] inputOutputAssets,\n            InferenceInOutSequence.FromDataset[] inputOutputDatasets) throws IOException {\n       \n        List<InferenceInOutSequence> inOutList = new ArrayList<>();\n        if (inputOutputAssets != null) {\n            for (InferenceInOutSequence.FromAssets ioAsset : inputOutputAssets) {\n                inOutList.add(ioAsset.readAssets(context.getAssets()));\n            }\n        }\n        if (inputOutputDatasets != null) {\n            for (InferenceInOutSequence.FromDataset dataset : inputOutputDatasets) {\n                inOutList.addAll(dataset.readDataset(context.getAssets(), context.getCacheDir()));\n            }\n        }\n        return inOutList;\n    }","cleancode":"public static list<inferenceinoutsequence> getinputoutputassets(context context, inferenceinoutsequence.fromassets[] inputoutputassets, inferenceinoutsequence.fromdataset[] inputoutputdatasets) throws ioexception { list<inferenceinoutsequence> inoutlist = new arraylist<>(); if (inputoutputassets != null) { for (inferenceinoutsequence.fromassets ioasset : inputoutputassets) { inoutlist.add(ioasset.readassets(context.getassets())); } } if (inputoutputdatasets != null) { for (inferenceinoutsequence.fromdataset dataset : inputoutputdatasets) { inoutlist.addall(dataset.readdataset(context.getassets(), context.getcachedir())); } } return inoutlist; }","comment":"\/\/ todo: caching, don't read inputs for every inference","repo":"riscv-android-src\/platform-test-mlts-benchmark","code_context_2":"InferenceInOutSequence.FromAssets[] inputOutputAssets,\nInferenceInOutSequence.FromDataset[] inputOutputDatasets) throws IOException {\n\/\/ TODO: Caching, don't read inputs for every inference\nList<InferenceInOutSequence> inOutList = new ArrayList<>();\nif (inputOutputAssets != null) {","code_context_10":"public static List<InferenceInOutSequence> getInputOutputAssets(Context context,\nInferenceInOutSequence.FromAssets[] inputOutputAssets,\nInferenceInOutSequence.FromDataset[] inputOutputDatasets) throws IOException {\n\/\/ TODO: Caching, don't read inputs for every inference\nList<InferenceInOutSequence> inOutList = new ArrayList<>();\nif (inputOutputAssets != null) {\nfor (InferenceInOutSequence.FromAssets ioAsset : inputOutputAssets) {\ninOutList.add(ioAsset.readAssets(context.getAssets()));\n}\n}\nif (inputOutputDatasets != null) {\nfor (InferenceInOutSequence.FromDataset dataset : inputOutputDatasets) {\ninOutList.addAll(dataset.readDataset(context.getAssets(), context.getCacheDir()));\n}","code_context_20":"public static List<InferenceInOutSequence> getInputOutputAssets(Context context,\nInferenceInOutSequence.FromAssets[] inputOutputAssets,\nInferenceInOutSequence.FromDataset[] inputOutputDatasets) throws IOException {\n\/\/ TODO: Caching, don't read inputs for every inference\nList<InferenceInOutSequence> inOutList = new ArrayList<>();\nif (inputOutputAssets != null) {\nfor (InferenceInOutSequence.FromAssets ioAsset : inputOutputAssets) {\ninOutList.add(ioAsset.readAssets(context.getAssets()));\n}\n}\nif (inputOutputDatasets != null) {\nfor (InferenceInOutSequence.FromDataset dataset : inputOutputDatasets) {\ninOutList.addAll(dataset.readDataset(context.getAssets(), context.getCacheDir()));\n}\n}\nreturn inOutList;\n}","label":[0,1,0,0]}
{"id":33261,"original_code":"@Test\n\tpublic void testJMeterJtlFileWithTransactionsAndTransactionsBug() throws Exception {\n\t\tString[] runArgs = {\n\t\t\t\"--report.dir\",\n\t\t\ttemporaryFolder.getRoot().getPath(),\n\t\t\t\"jmeter\",\n\t\t\t\"--report-logline-type\",\n\t\t\t\"transaction\",\n\t\t\t\"-gt\",\n\t\t\t\"-gh\",\n\t\t\t\"-gr\",\n\t\t\t\"-gp\",\n\t\t\t\"-group-by-http-status\",\n\t\t\t\"src\/test\/resources\/jmeter\/result_with_url_and_sample_transaction_lines_with_bug.jtl\"\n\t\t};\n\t\tString result = LogRaterRunTestUtil.getOutputFromLogRater(runArgs);\n\t\tSystem.out.printf(\"[%s]%n\", result);\n\t\t\/\/ sampler samples (e.g. http request)\n\t\tassertFalse(\"Contains 1 GET Jaw Kat\", result.contains(\"GET Jaw Kat,200,1\"));\n\t\tassertFalse(\"Contains 1 GET Jaw Yaw\", result.contains(\"GET Jaw Yaw,200,1\"));\n\t\t\/\/ transaction controller samples\n\t\tassertTrue(\"Contains 1 cog\", result.contains(\"cog,200,1\"));\n\t\tassertTrue(\"Contains 1 som\", result.contains(\"som,200,1\"));\n\t\t\/\/ buggy transaction controller samples, are classified as transactions because URL column is available\n\t\tassertTrue(\"Contains 3 ane transactions\", result.contains(\"ane,204,3\"));\n\t\tassertTrue(\"The files contain 5 lines of which 0 failure lines.\", result.contains(\"total-counter-success-total,5,0\"));\n\t}","code":"@Test\n\tpublic void testJMeterJtlFileWithTransactionsAndTransactionsBug() throws Exception {\n\t\tString[] runArgs = {\n\t\t\t\"--report.dir\",\n\t\t\ttemporaryFolder.getRoot().getPath(),\n\t\t\t\"jmeter\",\n\t\t\t\"--report-logline-type\",\n\t\t\t\"transaction\",\n\t\t\t\"-gt\",\n\t\t\t\"-gh\",\n\t\t\t\"-gr\",\n\t\t\t\"-gp\",\n\t\t\t\"-group-by-http-status\",\n\t\t\t\"src\/test\/resources\/jmeter\/result_with_url_and_sample_transaction_lines_with_bug.jtl\"\n\t\t};\n\t\tString result = LogRaterRunTestUtil.getOutputFromLogRater(runArgs);\n\t\tSystem.out.printf(\"[%s]%n\", result);\n\t\n\t\tassertFalse(\"Contains 1 GET Jaw Kat\", result.contains(\"GET Jaw Kat,200,1\"));\n\t\tassertFalse(\"Contains 1 GET Jaw Yaw\", result.contains(\"GET Jaw Yaw,200,1\"));\n\t\n\t\tassertTrue(\"Contains 1 cog\", result.contains(\"cog,200,1\"));\n\t\tassertTrue(\"Contains 1 som\", result.contains(\"som,200,1\"));\n\t\n\t\tassertTrue(\"Contains 3 ane transactions\", result.contains(\"ane,204,3\"));\n\t\tassertTrue(\"The files contain 5 lines of which 0 failure lines.\", result.contains(\"total-counter-success-total,5,0\"));\n\t}","cleancode":"@test public void testjmeterjtlfilewithtransactionsandtransactionsbug() throws exception { string[] runargs = { \"--report.dir\", temporaryfolder.getroot().getpath(), \"jmeter\", \"--report-logline-type\", \"transaction\", \"-gt\", \"-gh\", \"-gr\", \"-gp\", \"-group-by-http-status\", \"src\/test\/resources\/jmeter\/result_with_url_and_sample_transaction_lines_with_bug.jtl\" }; string result = lograterruntestutil.getoutputfromlograter(runargs); system.out.printf(\"[%s]%n\", result); assertfalse(\"contains 1 get jaw kat\", result.contains(\"get jaw kat,200,1\")); assertfalse(\"contains 1 get jaw yaw\", result.contains(\"get jaw yaw,200,1\")); asserttrue(\"contains 1 cog\", result.contains(\"cog,200,1\")); asserttrue(\"contains 1 som\", result.contains(\"som,200,1\")); asserttrue(\"contains 3 ane transactions\", result.contains(\"ane,204,3\")); asserttrue(\"the files contain 5 lines of which 0 failure lines.\", result.contains(\"total-counter-success-total,5,0\")); }","comment":"\/\/ sampler samples (e.g. http request)\n\/\/ transaction controller samples\n\/\/ buggy transaction controller samples, are classified as transactions because url column is available","repo":"stokpop\/lograter","code_context_2":"String result = LogRaterRunTestUtil.getOutputFromLogRater(runArgs);\nSystem.out.printf(\"[%s]%n\", result);\n\/\/ sampler samples (e.g. http request)\nassertFalse(\"Contains 1 GET Jaw Kat\", result.contains(\"GET Jaw Kat,200,1\"));\nassertFalse(\"Contains 1 GET Jaw Yaw\", result.contains(\"GET Jaw Yaw,200,1\"));\n\nassertFalse(\"Contains 1 GET Jaw Kat\", result.contains(\"GET Jaw Kat,200,1\"));\nassertFalse(\"Contains 1 GET Jaw Yaw\", result.contains(\"GET Jaw Yaw,200,1\"));\n\/\/ transaction controller samples\nassertTrue(\"Contains 1 cog\", result.contains(\"cog,200,1\"));\nassertTrue(\"Contains 1 som\", result.contains(\"som,200,1\"));\n\nassertTrue(\"Contains 1 cog\", result.contains(\"cog,200,1\"));\nassertTrue(\"Contains 1 som\", result.contains(\"som,200,1\"));\n\/\/ buggy transaction controller samples, are classified as transactions because URL column is available\nassertTrue(\"Contains 3 ane transactions\", result.contains(\"ane,204,3\"));\nassertTrue(\"The files contain 5 lines of which 0 failure lines.\", result.contains(\"total-counter-success-total,5,0\"));","code_context_10":"\"transaction\",\n\"-gt\",\n\"-gh\",\n\"-gr\",\n\"-gp\",\n\"-group-by-http-status\",\n\"src\/test\/resources\/jmeter\/result_with_url_and_sample_transaction_lines_with_bug.jtl\"\n};\nString result = LogRaterRunTestUtil.getOutputFromLogRater(runArgs);\nSystem.out.printf(\"[%s]%n\", result);\n\/\/ sampler samples (e.g. http request)\nassertFalse(\"Contains 1 GET Jaw Kat\", result.contains(\"GET Jaw Kat,200,1\"));\nassertFalse(\"Contains 1 GET Jaw Yaw\", result.contains(\"GET Jaw Yaw,200,1\"));\n\/\/ transaction controller samples\nassertTrue(\"Contains 1 cog\", result.contains(\"cog,200,1\"));\nassertTrue(\"Contains 1 som\", result.contains(\"som,200,1\"));\n\/\/ buggy transaction controller samples, are classified as transactions because URL column is available\nassertTrue(\"Contains 3 ane transactions\", result.contains(\"ane,204,3\"));\nassertTrue(\"The files contain 5 lines of which 0 failure lines.\", result.contains(\"total-counter-success-total,5,0\"));\n}\n\n\"-gr\",\n\"-gp\",\n\"-group-by-http-status\",\n\"src\/test\/resources\/jmeter\/result_with_url_and_sample_transaction_lines_with_bug.jtl\"\n};\nString result = LogRaterRunTestUtil.getOutputFromLogRater(runArgs);\nSystem.out.printf(\"[%s]%n\", result);\n\/\/ sampler samples (e.g. http request)\nassertFalse(\"Contains 1 GET Jaw Kat\", result.contains(\"GET Jaw Kat,200,1\"));\nassertFalse(\"Contains 1 GET Jaw Yaw\", result.contains(\"GET Jaw Yaw,200,1\"));\n\/\/ transaction controller samples\nassertTrue(\"Contains 1 cog\", result.contains(\"cog,200,1\"));\nassertTrue(\"Contains 1 som\", result.contains(\"som,200,1\"));\n\/\/ buggy transaction controller samples, are classified as transactions because URL column is available\nassertTrue(\"Contains 3 ane transactions\", result.contains(\"ane,204,3\"));\nassertTrue(\"The files contain 5 lines of which 0 failure lines.\", result.contains(\"total-counter-success-total,5,0\"));\n}\n\n\"src\/test\/resources\/jmeter\/result_with_url_and_sample_transaction_lines_with_bug.jtl\"\n};\nString result = LogRaterRunTestUtil.getOutputFromLogRater(runArgs);\nSystem.out.printf(\"[%s]%n\", result);\n\/\/ sampler samples (e.g. http request)\nassertFalse(\"Contains 1 GET Jaw Kat\", result.contains(\"GET Jaw Kat,200,1\"));\nassertFalse(\"Contains 1 GET Jaw Yaw\", result.contains(\"GET Jaw Yaw,200,1\"));\n\/\/ transaction controller samples\nassertTrue(\"Contains 1 cog\", result.contains(\"cog,200,1\"));\nassertTrue(\"Contains 1 som\", result.contains(\"som,200,1\"));\n\/\/ buggy transaction controller samples, are classified as transactions because URL column is available\nassertTrue(\"Contains 3 ane transactions\", result.contains(\"ane,204,3\"));\nassertTrue(\"The files contain 5 lines of which 0 failure lines.\", result.contains(\"total-counter-success-total,5,0\"));\n}","code_context_20":"@Test\npublic void testJMeterJtlFileWithTransactionsAndTransactionsBug() throws Exception {\nString[] runArgs = {\n\"--report.dir\",\ntemporaryFolder.getRoot().getPath(),\n\"jmeter\",\n\"--report-logline-type\",\n\"transaction\",\n\"-gt\",\n\"-gh\",\n\"-gr\",\n\"-gp\",\n\"-group-by-http-status\",\n\"src\/test\/resources\/jmeter\/result_with_url_and_sample_transaction_lines_with_bug.jtl\"\n};\nString result = LogRaterRunTestUtil.getOutputFromLogRater(runArgs);\nSystem.out.printf(\"[%s]%n\", result);\n\/\/ sampler samples (e.g. http request)\nassertFalse(\"Contains 1 GET Jaw Kat\", result.contains(\"GET Jaw Kat,200,1\"));\nassertFalse(\"Contains 1 GET Jaw Yaw\", result.contains(\"GET Jaw Yaw,200,1\"));\n\/\/ transaction controller samples\nassertTrue(\"Contains 1 cog\", result.contains(\"cog,200,1\"));\nassertTrue(\"Contains 1 som\", result.contains(\"som,200,1\"));\n\/\/ buggy transaction controller samples, are classified as transactions because URL column is available\nassertTrue(\"Contains 3 ane transactions\", result.contains(\"ane,204,3\"));\nassertTrue(\"The files contain 5 lines of which 0 failure lines.\", result.contains(\"total-counter-success-total,5,0\"));\n}\n\n@Test\npublic void testJMeterJtlFileWithTransactionsAndTransactionsBug() throws Exception {\nString[] runArgs = {\n\"--report.dir\",\ntemporaryFolder.getRoot().getPath(),\n\"jmeter\",\n\"--report-logline-type\",\n\"transaction\",\n\"-gt\",\n\"-gh\",\n\"-gr\",\n\"-gp\",\n\"-group-by-http-status\",\n\"src\/test\/resources\/jmeter\/result_with_url_and_sample_transaction_lines_with_bug.jtl\"\n};\nString result = LogRaterRunTestUtil.getOutputFromLogRater(runArgs);\nSystem.out.printf(\"[%s]%n\", result);\n\/\/ sampler samples (e.g. http request)\nassertFalse(\"Contains 1 GET Jaw Kat\", result.contains(\"GET Jaw Kat,200,1\"));\nassertFalse(\"Contains 1 GET Jaw Yaw\", result.contains(\"GET Jaw Yaw,200,1\"));\n\/\/ transaction controller samples\nassertTrue(\"Contains 1 cog\", result.contains(\"cog,200,1\"));\nassertTrue(\"Contains 1 som\", result.contains(\"som,200,1\"));\n\/\/ buggy transaction controller samples, are classified as transactions because URL column is available\nassertTrue(\"Contains 3 ane transactions\", result.contains(\"ane,204,3\"));\nassertTrue(\"The files contain 5 lines of which 0 failure lines.\", result.contains(\"total-counter-success-total,5,0\"));\n}\n\n\"--report.dir\",\ntemporaryFolder.getRoot().getPath(),\n\"jmeter\",\n\"--report-logline-type\",\n\"transaction\",\n\"-gt\",\n\"-gh\",\n\"-gr\",\n\"-gp\",\n\"-group-by-http-status\",\n\"src\/test\/resources\/jmeter\/result_with_url_and_sample_transaction_lines_with_bug.jtl\"\n};\nString result = LogRaterRunTestUtil.getOutputFromLogRater(runArgs);\nSystem.out.printf(\"[%s]%n\", result);\n\/\/ sampler samples (e.g. http request)\nassertFalse(\"Contains 1 GET Jaw Kat\", result.contains(\"GET Jaw Kat,200,1\"));\nassertFalse(\"Contains 1 GET Jaw Yaw\", result.contains(\"GET Jaw Yaw,200,1\"));\n\/\/ transaction controller samples\nassertTrue(\"Contains 1 cog\", result.contains(\"cog,200,1\"));\nassertTrue(\"Contains 1 som\", result.contains(\"som,200,1\"));\n\/\/ buggy transaction controller samples, are classified as transactions because URL column is available\nassertTrue(\"Contains 3 ane transactions\", result.contains(\"ane,204,3\"));\nassertTrue(\"The files contain 5 lines of which 0 failure lines.\", result.contains(\"total-counter-success-total,5,0\"));\n}","label":[0,0,0,0]}
{"id":33268,"original_code":"@Override\n    public CustomProfile extractUserProfile(User user) throws InvalidDefinitionException {\n        \/\/ fetch custom attributes\n        List<UserAttributes> userAttributes = user.getAttributes().stream()\n                .filter(ua -> !ua.getIdentifier().startsWith(\"aac.\"))\n                .collect(Collectors.toList());\n        \/\/ fetch identities\n        Collection<UserIdentity> identities = user.getIdentities();\n        if (identities.isEmpty()) {\n            return extract(userAttributes);\n        }\n        \/\/ TODO decide how to merge identities into a single profile\n        \/\/ for now get first identity, should be last logged in\n        UserIdentity id = identities.iterator().next();\n        CustomProfile profile = extract(mergeAttributes(userAttributes, id.getAttributes()));\n        return profile;\n    }","code":"@Override\n    public CustomProfile extractUserProfile(User user) throws InvalidDefinitionException {\n       \n        List<UserAttributes> userAttributes = user.getAttributes().stream()\n                .filter(ua -> !ua.getIdentifier().startsWith(\"aac.\"))\n                .collect(Collectors.toList());\n       \n        Collection<UserIdentity> identities = user.getIdentities();\n        if (identities.isEmpty()) {\n            return extract(userAttributes);\n        }\n       \n       \n        UserIdentity id = identities.iterator().next();\n        CustomProfile profile = extract(mergeAttributes(userAttributes, id.getAttributes()));\n        return profile;\n    }","cleancode":"@override public customprofile extractuserprofile(user user) throws invaliddefinitionexception { list<userattributes> userattributes = user.getattributes().stream() .filter(ua -> !ua.getidentifier().startswith(\"aac.\")) .collect(collectors.tolist()); collection<useridentity> identities = user.getidentities(); if (identities.isempty()) { return extract(userattributes); } useridentity id = identities.iterator().next(); customprofile profile = extract(mergeattributes(userattributes, id.getattributes())); return profile; }","comment":"\/\/ fetch custom attributes\n\/\/ fetch identities\n\/\/ todo decide how to merge identities into a single profile \/\/ for now get first identity, should be last logged in","repo":"smartcommunitylab\/AAC","code_context_2":"@Override\npublic CustomProfile extractUserProfile(User user) throws InvalidDefinitionException {\n\/\/ fetch custom attributes\nList<UserAttributes> userAttributes = user.getAttributes().stream()\n.filter(ua -> !ua.getIdentifier().startsWith(\"aac.\"))\n\n.filter(ua -> !ua.getIdentifier().startsWith(\"aac.\"))\n.collect(Collectors.toList());\n\/\/ fetch identities\nCollection<UserIdentity> identities = user.getIdentities();\nif (identities.isEmpty()) {\n\nreturn extract(userAttributes);\n}\n\/\/ TODO decide how to merge identities into a single profile\n\/\/ for now get first identity, should be last logged in\nUserIdentity id = identities.iterator().next();\nCustomProfile profile = extract(mergeAttributes(userAttributes, id.getAttributes()));","code_context_10":"@Override\npublic CustomProfile extractUserProfile(User user) throws InvalidDefinitionException {\n\/\/ fetch custom attributes\nList<UserAttributes> userAttributes = user.getAttributes().stream()\n.filter(ua -> !ua.getIdentifier().startsWith(\"aac.\"))\n.collect(Collectors.toList());\n\/\/ fetch identities\nCollection<UserIdentity> identities = user.getIdentities();\nif (identities.isEmpty()) {\nreturn extract(userAttributes);\n}\n\/\/ TODO decide how to merge identities into a single profile\n\/\/ for now get first identity, should be last logged in\n\n@Override\npublic CustomProfile extractUserProfile(User user) throws InvalidDefinitionException {\n\/\/ fetch custom attributes\nList<UserAttributes> userAttributes = user.getAttributes().stream()\n.filter(ua -> !ua.getIdentifier().startsWith(\"aac.\"))\n.collect(Collectors.toList());\n\/\/ fetch identities\nCollection<UserIdentity> identities = user.getIdentities();\nif (identities.isEmpty()) {\nreturn extract(userAttributes);\n}\n\/\/ TODO decide how to merge identities into a single profile\n\/\/ for now get first identity, should be last logged in\nUserIdentity id = identities.iterator().next();\nCustomProfile profile = extract(mergeAttributes(userAttributes, id.getAttributes()));\nreturn profile;\n}\n\npublic CustomProfile extractUserProfile(User user) throws InvalidDefinitionException {\n\/\/ fetch custom attributes\nList<UserAttributes> userAttributes = user.getAttributes().stream()\n.filter(ua -> !ua.getIdentifier().startsWith(\"aac.\"))\n.collect(Collectors.toList());\n\/\/ fetch identities\nCollection<UserIdentity> identities = user.getIdentities();\nif (identities.isEmpty()) {\nreturn extract(userAttributes);\n}\n\/\/ TODO decide how to merge identities into a single profile\n\/\/ for now get first identity, should be last logged in\nUserIdentity id = identities.iterator().next();\nCustomProfile profile = extract(mergeAttributes(userAttributes, id.getAttributes()));\nreturn profile;\n}","code_context_20":"@Override\npublic CustomProfile extractUserProfile(User user) throws InvalidDefinitionException {\n\/\/ fetch custom attributes\nList<UserAttributes> userAttributes = user.getAttributes().stream()\n.filter(ua -> !ua.getIdentifier().startsWith(\"aac.\"))\n.collect(Collectors.toList());\n\/\/ fetch identities\nCollection<UserIdentity> identities = user.getIdentities();\nif (identities.isEmpty()) {\nreturn extract(userAttributes);\n}\n\/\/ TODO decide how to merge identities into a single profile\n\/\/ for now get first identity, should be last logged in\nUserIdentity id = identities.iterator().next();\nCustomProfile profile = extract(mergeAttributes(userAttributes, id.getAttributes()));\nreturn profile;\n}\n\n@Override\npublic CustomProfile extractUserProfile(User user) throws InvalidDefinitionException {\n\/\/ fetch custom attributes\nList<UserAttributes> userAttributes = user.getAttributes().stream()\n.filter(ua -> !ua.getIdentifier().startsWith(\"aac.\"))\n.collect(Collectors.toList());\n\/\/ fetch identities\nCollection<UserIdentity> identities = user.getIdentities();\nif (identities.isEmpty()) {\nreturn extract(userAttributes);\n}\n\/\/ TODO decide how to merge identities into a single profile\n\/\/ for now get first identity, should be last logged in\nUserIdentity id = identities.iterator().next();\nCustomProfile profile = extract(mergeAttributes(userAttributes, id.getAttributes()));\nreturn profile;\n}\n\n@Override\npublic CustomProfile extractUserProfile(User user) throws InvalidDefinitionException {\n\/\/ fetch custom attributes\nList<UserAttributes> userAttributes = user.getAttributes().stream()\n.filter(ua -> !ua.getIdentifier().startsWith(\"aac.\"))\n.collect(Collectors.toList());\n\/\/ fetch identities\nCollection<UserIdentity> identities = user.getIdentities();\nif (identities.isEmpty()) {\nreturn extract(userAttributes);\n}\n\/\/ TODO decide how to merge identities into a single profile\n\/\/ for now get first identity, should be last logged in\nUserIdentity id = identities.iterator().next();\nCustomProfile profile = extract(mergeAttributes(userAttributes, id.getAttributes()));\nreturn profile;\n}","label":[1,0,0,0]}
{"id":16896,"original_code":"public TypeUse getTypeUse(XSSimpleType owner) {\n            if(typeUse!=null)\n                return typeUse;\n            JCodeModel cm = getCodeModel();\n            JDefinedClass a;\n            try {\n                a = cm._class(adapter);\n                a.hide();   \/\/ we assume this is given by the user\n                a._extends(cm.ref(XmlAdapter.class).narrow(String.class).narrow(\n                        cm.ref(type)));\n            } catch (JClassAlreadyExistsException e) {\n                a = e.getExistingClass();\n            }\n            \/\/ TODO: it's not correct to say that it adapts from String,\n            \/\/ but OTOH I don't think we can compute that.\n            typeUse = TypeUseFactory.adapt(\n                    CBuiltinLeafInfo.STRING,\n                    new CAdapter(a));\n            return typeUse;\n        }","code":"public TypeUse getTypeUse(XSSimpleType owner) {\n            if(typeUse!=null)\n                return typeUse;\n            JCodeModel cm = getCodeModel();\n            JDefinedClass a;\n            try {\n                a = cm._class(adapter);\n                a.hide();  \n                a._extends(cm.ref(XmlAdapter.class).narrow(String.class).narrow(\n                        cm.ref(type)));\n            } catch (JClassAlreadyExistsException e) {\n                a = e.getExistingClass();\n            }\n           \n           \n            typeUse = TypeUseFactory.adapt(\n                    CBuiltinLeafInfo.STRING,\n                    new CAdapter(a));\n            return typeUse;\n        }","cleancode":"public typeuse gettypeuse(xssimpletype owner) { if(typeuse!=null) return typeuse; jcodemodel cm = getcodemodel(); jdefinedclass a; try { a = cm._class(adapter); a.hide(); a._extends(cm.ref(xmladapter.class).narrow(string.class).narrow( cm.ref(type))); } catch (jclassalreadyexistsexception e) { a = e.getexistingclass(); } typeuse = typeusefactory.adapt( cbuiltinleafinfo.string, new cadapter(a)); return typeuse; }","comment":"\/\/ we assume this is given by the user\n\/\/ todo: it's not correct to say that it adapts from string, \/\/ but otoh i don't think we can compute that.","repo":"renshuaibing-aaron\/jdk1.8-source-analysis","code_context_2":"try {\na = cm._class(adapter);\na.hide(); \/\/ we assume this is given by the user\na._extends(cm.ref(XmlAdapter.class).narrow(String.class).narrow(\ncm.ref(type)));\n\na = e.getExistingClass();\n}\n\/\/ TODO: it's not correct to say that it adapts from String,\n\/\/ but OTOH I don't think we can compute that.\ntypeUse = TypeUseFactory.adapt(\nCBuiltinLeafInfo.STRING,","code_context_10":"public TypeUse getTypeUse(XSSimpleType owner) {\nif(typeUse!=null)\nreturn typeUse;\nJCodeModel cm = getCodeModel();\nJDefinedClass a;\ntry {\na = cm._class(adapter);\na.hide(); \/\/ we assume this is given by the user\na._extends(cm.ref(XmlAdapter.class).narrow(String.class).narrow(\ncm.ref(type)));\n} catch (JClassAlreadyExistsException e) {\na = e.getExistingClass();\n}\n\/\/ TODO: it's not correct to say that it adapts from String,\n\/\/ but OTOH I don't think we can compute that.\ntypeUse = TypeUseFactory.adapt(\nCBuiltinLeafInfo.STRING,\nnew CAdapter(a));\n\nJCodeModel cm = getCodeModel();\nJDefinedClass a;\ntry {\na = cm._class(adapter);\na.hide(); \/\/ we assume this is given by the user\na._extends(cm.ref(XmlAdapter.class).narrow(String.class).narrow(\ncm.ref(type)));\n} catch (JClassAlreadyExistsException e) {\na = e.getExistingClass();\n}\n\/\/ TODO: it's not correct to say that it adapts from String,\n\/\/ but OTOH I don't think we can compute that.\ntypeUse = TypeUseFactory.adapt(\nCBuiltinLeafInfo.STRING,\nnew CAdapter(a));\nreturn typeUse;\n}","code_context_20":"public TypeUse getTypeUse(XSSimpleType owner) {\nif(typeUse!=null)\nreturn typeUse;\nJCodeModel cm = getCodeModel();\nJDefinedClass a;\ntry {\na = cm._class(adapter);\na.hide(); \/\/ we assume this is given by the user\na._extends(cm.ref(XmlAdapter.class).narrow(String.class).narrow(\ncm.ref(type)));\n} catch (JClassAlreadyExistsException e) {\na = e.getExistingClass();\n}\n\/\/ TODO: it's not correct to say that it adapts from String,\n\/\/ but OTOH I don't think we can compute that.\ntypeUse = TypeUseFactory.adapt(\nCBuiltinLeafInfo.STRING,\nnew CAdapter(a));\nreturn typeUse;\n}\n\npublic TypeUse getTypeUse(XSSimpleType owner) {\nif(typeUse!=null)\nreturn typeUse;\nJCodeModel cm = getCodeModel();\nJDefinedClass a;\ntry {\na = cm._class(adapter);\na.hide(); \/\/ we assume this is given by the user\na._extends(cm.ref(XmlAdapter.class).narrow(String.class).narrow(\ncm.ref(type)));\n} catch (JClassAlreadyExistsException e) {\na = e.getExistingClass();\n}\n\/\/ TODO: it's not correct to say that it adapts from String,\n\/\/ but OTOH I don't think we can compute that.\ntypeUse = TypeUseFactory.adapt(\nCBuiltinLeafInfo.STRING,\nnew CAdapter(a));\nreturn typeUse;\n}","label":[1,0,0,0]}
{"id":8710,"original_code":"public EntityIdentifier[] searchForGroups(\n            final String query,\n            final SearchMethod method,\n            @SuppressWarnings(\"unchecked\") final Class leaftype) {\n        \/\/ only search for groups\n        if (leaftype != IPerson.class) {\n            return new EntityIdentifier[] {};\n        }\n        if (LOGGER.isDebugEnabled()) {\n            LOGGER.debug(\"Searching Grouper for groups matching query: \" + query);\n        }\n        \/\/ result groups.\n        List<EntityIdentifier> groups = new ArrayList<EntityIdentifier>();\n        try {\n            \/\/ TODO: searches need to be performed against the group display\n            \/\/ name rather than the group key\n            GcFindGroups groupSearch = new GcFindGroups();\n            WsQueryFilter filter = new WsQueryFilter();\n            \/\/ is this an exact search or fuzzy\n            if ((method == SearchMethod.DISCRETE_CI) || (method == SearchMethod.DISCRETE)) {\n                filter.setQueryFilterType(\"FIND_BY_GROUP_NAME_EXACT\");\n            } else {\n                filter.setQueryFilterType(\"FIND_BY_GROUP_NAME_APPROXIMATE\");\n            }\n            filter.setGroupName(query);\n            groupSearch.assignQueryFilter(filter);\n            WsFindGroupsResults results = groupSearch.execute();\n            if (results != null && results.getGroupResults() != null) {\n                for (WsGroup g : results.getGroupResults()) {\n                    if (validKey(g.getName())) {\n                        if (LOGGER.isTraceEnabled()) {\n                            LOGGER.trace(\"Retrieved group: \" + g.getName());\n                        }\n                        groups.add(new EntityIdentifier(g.getName(), IEntityGroup.class));\n                    }\n                }\n            }\n            if (LOGGER.isDebugEnabled()) {\n                LOGGER.debug(\"Returning \" + groups.size() + \" results for query \" + query);\n            }\n            return groups.toArray(new EntityIdentifier[groups.size()]);\n        } catch (Exception e) {\n            LOGGER.warn(\n                    \"Exception while attempting to retrieve \"\n                            + \"search results for query \"\n                            + query\n                            + \" and entity type \"\n                            + leaftype.getCanonicalName()\n                            + \" : \"\n                            + e.getMessage());\n            return new EntityIdentifier[] {};\n        }\n    }","code":"public EntityIdentifier[] searchForGroups(\n            final String query,\n            final SearchMethod method,\n            @SuppressWarnings(\"unchecked\") final Class leaftype) {\n       \n        if (leaftype != IPerson.class) {\n            return new EntityIdentifier[] {};\n        }\n        if (LOGGER.isDebugEnabled()) {\n            LOGGER.debug(\"Searching Grouper for groups matching query: \" + query);\n        }\n       \n        List<EntityIdentifier> groups = new ArrayList<EntityIdentifier>();\n        try {\n           \n           \n            GcFindGroups groupSearch = new GcFindGroups();\n            WsQueryFilter filter = new WsQueryFilter();\n           \n            if ((method == SearchMethod.DISCRETE_CI) || (method == SearchMethod.DISCRETE)) {\n                filter.setQueryFilterType(\"FIND_BY_GROUP_NAME_EXACT\");\n            } else {\n                filter.setQueryFilterType(\"FIND_BY_GROUP_NAME_APPROXIMATE\");\n            }\n            filter.setGroupName(query);\n            groupSearch.assignQueryFilter(filter);\n            WsFindGroupsResults results = groupSearch.execute();\n            if (results != null && results.getGroupResults() != null) {\n                for (WsGroup g : results.getGroupResults()) {\n                    if (validKey(g.getName())) {\n                        if (LOGGER.isTraceEnabled()) {\n                            LOGGER.trace(\"Retrieved group: \" + g.getName());\n                        }\n                        groups.add(new EntityIdentifier(g.getName(), IEntityGroup.class));\n                    }\n                }\n            }\n            if (LOGGER.isDebugEnabled()) {\n                LOGGER.debug(\"Returning \" + groups.size() + \" results for query \" + query);\n            }\n            return groups.toArray(new EntityIdentifier[groups.size()]);\n        } catch (Exception e) {\n            LOGGER.warn(\n                    \"Exception while attempting to retrieve \"\n                            + \"search results for query \"\n                            + query\n                            + \" and entity type \"\n                            + leaftype.getCanonicalName()\n                            + \" : \"\n                            + e.getMessage());\n            return new EntityIdentifier[] {};\n        }\n    }","cleancode":"public entityidentifier[] searchforgroups( final string query, final searchmethod method, @suppresswarnings(\"unchecked\") final class leaftype) { if (leaftype != iperson.class) { return new entityidentifier[] {}; } if (logger.isdebugenabled()) { logger.debug(\"searching grouper for groups matching query: \" + query); } list<entityidentifier> groups = new arraylist<entityidentifier>(); try { gcfindgroups groupsearch = new gcfindgroups(); wsqueryfilter filter = new wsqueryfilter(); if ((method == searchmethod.discrete_ci) || (method == searchmethod.discrete)) { filter.setqueryfiltertype(\"find_by_group_name_exact\"); } else { filter.setqueryfiltertype(\"find_by_group_name_approximate\"); } filter.setgroupname(query); groupsearch.assignqueryfilter(filter); wsfindgroupsresults results = groupsearch.execute(); if (results != null && results.getgroupresults() != null) { for (wsgroup g : results.getgroupresults()) { if (validkey(g.getname())) { if (logger.istraceenabled()) { logger.trace(\"retrieved group: \" + g.getname()); } groups.add(new entityidentifier(g.getname(), ientitygroup.class)); } } } if (logger.isdebugenabled()) { logger.debug(\"returning \" + groups.size() + \" results for query \" + query); } return groups.toarray(new entityidentifier[groups.size()]); } catch (exception e) { logger.warn( \"exception while attempting to retrieve \" + \"search results for query \" + query + \" and entity type \" + leaftype.getcanonicalname() + \" : \" + e.getmessage()); return new entityidentifier[] {}; } }","comment":"\/* (non-javadoc) * @see org.apereo.portal.groups.ientitygroupstore#searchforgroups(java.lang.string, int, java.lang.class) *\/\n\/\/ only search for groups\n\/\/ result groups.\n\/\/ todo: searches need to be performed against the group display \/\/ name rather than the group key\n\/\/ is this an exact search or fuzzy","repo":"shreeshreee\/Uport","code_context_2":"public EntityIdentifier[] searchForGroups(\nfinal String query,\nfinal SearchMethod method,\n@SuppressWarnings(\"unchecked\") final Class leaftype) {\n\/\/ only search for groups\nif (leaftype != IPerson.class) {\nreturn new EntityIdentifier[] {};\n}\nif (LOGGER.isDebugEnabled()) {\nLOGGER.debug(\"Searching Grouper for groups matching query: \" + query);\n}\n\/\/ result groups.\nList<EntityIdentifier> groups = new ArrayList<EntityIdentifier>();\ntry {\n\/\/ TODO: searches need to be performed against the group display\n\/\/ name rather than the group key\nGcFindGroups groupSearch = new GcFindGroups();\nWsQueryFilter filter = new WsQueryFilter();\n\/\/ is this an exact search or fuzzy\nif ((method == SearchMethod.DISCRETE_CI) || (method == SearchMethod.DISCRETE)) {\nfilter.setQueryFilterType(\"FIND_BY_GROUP_NAME_EXACT\");\n} else {\nfilter.setQueryFilterType(\"FIND_BY_GROUP_NAME_APPROXIMATE\");\n}\nfilter.setGroupName(query);\ngroupSearch.assignQueryFilter(filter);\nWsFindGroupsResults results = groupSearch.execute();\nif (results != null && results.getGroupResults() != null) {\nfor (WsGroup g : results.getGroupResults()) {\nif (validKey(g.getName())) {\nif (LOGGER.isTraceEnabled()) {\nLOGGER.trace(\"Retrieved group: \" + g.getName());\n}\ngroups.add(new EntityIdentifier(g.getName(), IEntityGroup.class));\n}\n}\n}\nif (LOGGER.isDebugEnabled()) {\nLOGGER.debug(\"Returning \" + groups.size() + \" results for query \" + query);\n}\nreturn groups.toArray(new EntityIdentifier[groups.size()]);\n} catch (Exception e) {\nLOGGER.warn(\n\"Exception while attempting to retrieve \"\n+ \"search results for query \"\n+ query\n+ \" and entity type \"\n+ leaftype.getCanonicalName()\n+ \" : \"\n+ e.getMessage());\nreturn new EntityIdentifier[] {};\n}\n}\n\nfinal SearchMethod method,\n@SuppressWarnings(\"unchecked\") final Class leaftype) {\n\/\/ only search for groups\nif (leaftype != IPerson.class) {\nreturn new EntityIdentifier[] {};\n\nLOGGER.debug(\"Searching Grouper for groups matching query: \" + query);\n}\n\/\/ result groups.\nList<EntityIdentifier> groups = new ArrayList<EntityIdentifier>();\ntry {\n\nList<EntityIdentifier> groups = new ArrayList<EntityIdentifier>();\ntry {\n\/\/ TODO: searches need to be performed against the group display\n\/\/ name rather than the group key\nGcFindGroups groupSearch = new GcFindGroups();\nWsQueryFilter filter = new WsQueryFilter();\n\nGcFindGroups groupSearch = new GcFindGroups();\nWsQueryFilter filter = new WsQueryFilter();\n\/\/ is this an exact search or fuzzy\nif ((method == SearchMethod.DISCRETE_CI) || (method == SearchMethod.DISCRETE)) {\nfilter.setQueryFilterType(\"FIND_BY_GROUP_NAME_EXACT\");","code_context_10":"public EntityIdentifier[] searchForGroups(\nfinal String query,\nfinal SearchMethod method,\n@SuppressWarnings(\"unchecked\") final Class leaftype) {\n\/\/ only search for groups\nif (leaftype != IPerson.class) {\nreturn new EntityIdentifier[] {};\n}\nif (LOGGER.isDebugEnabled()) {\nLOGGER.debug(\"Searching Grouper for groups matching query: \" + query);\n}\n\/\/ result groups.\nList<EntityIdentifier> groups = new ArrayList<EntityIdentifier>();\ntry {\n\/\/ TODO: searches need to be performed against the group display\n\/\/ name rather than the group key\nGcFindGroups groupSearch = new GcFindGroups();\nWsQueryFilter filter = new WsQueryFilter();\n\/\/ is this an exact search or fuzzy\nif ((method == SearchMethod.DISCRETE_CI) || (method == SearchMethod.DISCRETE)) {\nfilter.setQueryFilterType(\"FIND_BY_GROUP_NAME_EXACT\");\n} else {\nfilter.setQueryFilterType(\"FIND_BY_GROUP_NAME_APPROXIMATE\");\n}\nfilter.setGroupName(query);\ngroupSearch.assignQueryFilter(filter);\nWsFindGroupsResults results = groupSearch.execute();\nif (results != null && results.getGroupResults() != null) {\nfor (WsGroup g : results.getGroupResults()) {\nif (validKey(g.getName())) {\nif (LOGGER.isTraceEnabled()) {\nLOGGER.trace(\"Retrieved group: \" + g.getName());\n}\ngroups.add(new EntityIdentifier(g.getName(), IEntityGroup.class));\n}\n}\n}\nif (LOGGER.isDebugEnabled()) {\nLOGGER.debug(\"Returning \" + groups.size() + \" results for query \" + query);\n}\nreturn groups.toArray(new EntityIdentifier[groups.size()]);\n} catch (Exception e) {\nLOGGER.warn(\n\"Exception while attempting to retrieve \"\n+ \"search results for query \"\n+ query\n+ \" and entity type \"\n+ leaftype.getCanonicalName()\n+ \" : \"\n+ e.getMessage());\nreturn new EntityIdentifier[] {};\n}\n}\n\npublic EntityIdentifier[] searchForGroups(\nfinal String query,\nfinal SearchMethod method,\n@SuppressWarnings(\"unchecked\") final Class leaftype) {\n\/\/ only search for groups\nif (leaftype != IPerson.class) {\nreturn new EntityIdentifier[] {};\n}\nif (LOGGER.isDebugEnabled()) {\nLOGGER.debug(\"Searching Grouper for groups matching query: \" + query);\n}\n\/\/ result groups.\nList<EntityIdentifier> groups = new ArrayList<EntityIdentifier>();\ntry {\n\/\/ TODO: searches need to be performed against the group display\n\nfinal String query,\nfinal SearchMethod method,\n@SuppressWarnings(\"unchecked\") final Class leaftype) {\n\/\/ only search for groups\nif (leaftype != IPerson.class) {\nreturn new EntityIdentifier[] {};\n}\nif (LOGGER.isDebugEnabled()) {\nLOGGER.debug(\"Searching Grouper for groups matching query: \" + query);\n}\n\/\/ result groups.\nList<EntityIdentifier> groups = new ArrayList<EntityIdentifier>();\ntry {\n\/\/ TODO: searches need to be performed against the group display\n\/\/ name rather than the group key\nGcFindGroups groupSearch = new GcFindGroups();\nWsQueryFilter filter = new WsQueryFilter();\n\/\/ is this an exact search or fuzzy\nif ((method == SearchMethod.DISCRETE_CI) || (method == SearchMethod.DISCRETE)) {\nfilter.setQueryFilterType(\"FIND_BY_GROUP_NAME_EXACT\");\n} else {\n\n\/\/ only search for groups\nif (leaftype != IPerson.class) {\nreturn new EntityIdentifier[] {};\n}\nif (LOGGER.isDebugEnabled()) {\nLOGGER.debug(\"Searching Grouper for groups matching query: \" + query);\n}\n\/\/ result groups.\nList<EntityIdentifier> groups = new ArrayList<EntityIdentifier>();\ntry {\n\/\/ TODO: searches need to be performed against the group display\n\/\/ name rather than the group key\nGcFindGroups groupSearch = new GcFindGroups();\nWsQueryFilter filter = new WsQueryFilter();\n\/\/ is this an exact search or fuzzy\nif ((method == SearchMethod.DISCRETE_CI) || (method == SearchMethod.DISCRETE)) {\nfilter.setQueryFilterType(\"FIND_BY_GROUP_NAME_EXACT\");\n} else {\nfilter.setQueryFilterType(\"FIND_BY_GROUP_NAME_APPROXIMATE\");\n}\nfilter.setGroupName(query);\ngroupSearch.assignQueryFilter(filter);\n\nif (LOGGER.isDebugEnabled()) {\nLOGGER.debug(\"Searching Grouper for groups matching query: \" + query);\n}\n\/\/ result groups.\nList<EntityIdentifier> groups = new ArrayList<EntityIdentifier>();\ntry {\n\/\/ TODO: searches need to be performed against the group display\n\/\/ name rather than the group key\nGcFindGroups groupSearch = new GcFindGroups();\nWsQueryFilter filter = new WsQueryFilter();\n\/\/ is this an exact search or fuzzy\nif ((method == SearchMethod.DISCRETE_CI) || (method == SearchMethod.DISCRETE)) {\nfilter.setQueryFilterType(\"FIND_BY_GROUP_NAME_EXACT\");\n} else {\nfilter.setQueryFilterType(\"FIND_BY_GROUP_NAME_APPROXIMATE\");\n}\nfilter.setGroupName(query);\ngroupSearch.assignQueryFilter(filter);\nWsFindGroupsResults results = groupSearch.execute();\nif (results != null && results.getGroupResults() != null) {\nfor (WsGroup g : results.getGroupResults()) {","code_context_20":"public EntityIdentifier[] searchForGroups(\nfinal String query,\nfinal SearchMethod method,\n@SuppressWarnings(\"unchecked\") final Class leaftype) {\n\/\/ only search for groups\nif (leaftype != IPerson.class) {\nreturn new EntityIdentifier[] {};\n}\nif (LOGGER.isDebugEnabled()) {\nLOGGER.debug(\"Searching Grouper for groups matching query: \" + query);\n}\n\/\/ result groups.\nList<EntityIdentifier> groups = new ArrayList<EntityIdentifier>();\ntry {\n\/\/ TODO: searches need to be performed against the group display\n\/\/ name rather than the group key\nGcFindGroups groupSearch = new GcFindGroups();\nWsQueryFilter filter = new WsQueryFilter();\n\/\/ is this an exact search or fuzzy\nif ((method == SearchMethod.DISCRETE_CI) || (method == SearchMethod.DISCRETE)) {\nfilter.setQueryFilterType(\"FIND_BY_GROUP_NAME_EXACT\");\n} else {\nfilter.setQueryFilterType(\"FIND_BY_GROUP_NAME_APPROXIMATE\");\n}\nfilter.setGroupName(query);\ngroupSearch.assignQueryFilter(filter);\nWsFindGroupsResults results = groupSearch.execute();\nif (results != null && results.getGroupResults() != null) {\nfor (WsGroup g : results.getGroupResults()) {\nif (validKey(g.getName())) {\nif (LOGGER.isTraceEnabled()) {\nLOGGER.trace(\"Retrieved group: \" + g.getName());\n}\ngroups.add(new EntityIdentifier(g.getName(), IEntityGroup.class));\n}\n}\n}\nif (LOGGER.isDebugEnabled()) {\nLOGGER.debug(\"Returning \" + groups.size() + \" results for query \" + query);\n}\nreturn groups.toArray(new EntityIdentifier[groups.size()]);\n} catch (Exception e) {\nLOGGER.warn(\n\"Exception while attempting to retrieve \"\n+ \"search results for query \"\n+ query\n+ \" and entity type \"\n+ leaftype.getCanonicalName()\n+ \" : \"\n+ e.getMessage());\nreturn new EntityIdentifier[] {};\n}\n}\n\npublic EntityIdentifier[] searchForGroups(\nfinal String query,\nfinal SearchMethod method,\n@SuppressWarnings(\"unchecked\") final Class leaftype) {\n\/\/ only search for groups\nif (leaftype != IPerson.class) {\nreturn new EntityIdentifier[] {};\n}\nif (LOGGER.isDebugEnabled()) {\nLOGGER.debug(\"Searching Grouper for groups matching query: \" + query);\n}\n\/\/ result groups.\nList<EntityIdentifier> groups = new ArrayList<EntityIdentifier>();\ntry {\n\/\/ TODO: searches need to be performed against the group display\n\/\/ name rather than the group key\nGcFindGroups groupSearch = new GcFindGroups();\nWsQueryFilter filter = new WsQueryFilter();\n\/\/ is this an exact search or fuzzy\nif ((method == SearchMethod.DISCRETE_CI) || (method == SearchMethod.DISCRETE)) {\nfilter.setQueryFilterType(\"FIND_BY_GROUP_NAME_EXACT\");\n} else {\nfilter.setQueryFilterType(\"FIND_BY_GROUP_NAME_APPROXIMATE\");\n}\nfilter.setGroupName(query);\n\npublic EntityIdentifier[] searchForGroups(\nfinal String query,\nfinal SearchMethod method,\n@SuppressWarnings(\"unchecked\") final Class leaftype) {\n\/\/ only search for groups\nif (leaftype != IPerson.class) {\nreturn new EntityIdentifier[] {};\n}\nif (LOGGER.isDebugEnabled()) {\nLOGGER.debug(\"Searching Grouper for groups matching query: \" + query);\n}\n\/\/ result groups.\nList<EntityIdentifier> groups = new ArrayList<EntityIdentifier>();\ntry {\n\/\/ TODO: searches need to be performed against the group display\n\/\/ name rather than the group key\nGcFindGroups groupSearch = new GcFindGroups();\nWsQueryFilter filter = new WsQueryFilter();\n\/\/ is this an exact search or fuzzy\nif ((method == SearchMethod.DISCRETE_CI) || (method == SearchMethod.DISCRETE)) {\nfilter.setQueryFilterType(\"FIND_BY_GROUP_NAME_EXACT\");\n} else {\nfilter.setQueryFilterType(\"FIND_BY_GROUP_NAME_APPROXIMATE\");\n}\nfilter.setGroupName(query);\ngroupSearch.assignQueryFilter(filter);\nWsFindGroupsResults results = groupSearch.execute();\nif (results != null && results.getGroupResults() != null) {\nfor (WsGroup g : results.getGroupResults()) {\nif (validKey(g.getName())) {\nif (LOGGER.isTraceEnabled()) {\nLOGGER.trace(\"Retrieved group: \" + g.getName());\n\npublic EntityIdentifier[] searchForGroups(\nfinal String query,\nfinal SearchMethod method,\n@SuppressWarnings(\"unchecked\") final Class leaftype) {\n\/\/ only search for groups\nif (leaftype != IPerson.class) {\nreturn new EntityIdentifier[] {};\n}\nif (LOGGER.isDebugEnabled()) {\nLOGGER.debug(\"Searching Grouper for groups matching query: \" + query);\n}\n\/\/ result groups.\nList<EntityIdentifier> groups = new ArrayList<EntityIdentifier>();\ntry {\n\/\/ TODO: searches need to be performed against the group display\n\/\/ name rather than the group key\nGcFindGroups groupSearch = new GcFindGroups();\nWsQueryFilter filter = new WsQueryFilter();\n\/\/ is this an exact search or fuzzy\nif ((method == SearchMethod.DISCRETE_CI) || (method == SearchMethod.DISCRETE)) {\nfilter.setQueryFilterType(\"FIND_BY_GROUP_NAME_EXACT\");\n} else {\nfilter.setQueryFilterType(\"FIND_BY_GROUP_NAME_APPROXIMATE\");\n}\nfilter.setGroupName(query);\ngroupSearch.assignQueryFilter(filter);\nWsFindGroupsResults results = groupSearch.execute();\nif (results != null && results.getGroupResults() != null) {\nfor (WsGroup g : results.getGroupResults()) {\nif (validKey(g.getName())) {\nif (LOGGER.isTraceEnabled()) {\nLOGGER.trace(\"Retrieved group: \" + g.getName());\n}\ngroups.add(new EntityIdentifier(g.getName(), IEntityGroup.class));\n}\n}\n\npublic EntityIdentifier[] searchForGroups(\nfinal String query,\nfinal SearchMethod method,\n@SuppressWarnings(\"unchecked\") final Class leaftype) {\n\/\/ only search for groups\nif (leaftype != IPerson.class) {\nreturn new EntityIdentifier[] {};\n}\nif (LOGGER.isDebugEnabled()) {\nLOGGER.debug(\"Searching Grouper for groups matching query: \" + query);\n}\n\/\/ result groups.\nList<EntityIdentifier> groups = new ArrayList<EntityIdentifier>();\ntry {\n\/\/ TODO: searches need to be performed against the group display\n\/\/ name rather than the group key\nGcFindGroups groupSearch = new GcFindGroups();\nWsQueryFilter filter = new WsQueryFilter();\n\/\/ is this an exact search or fuzzy\nif ((method == SearchMethod.DISCRETE_CI) || (method == SearchMethod.DISCRETE)) {\nfilter.setQueryFilterType(\"FIND_BY_GROUP_NAME_EXACT\");\n} else {\nfilter.setQueryFilterType(\"FIND_BY_GROUP_NAME_APPROXIMATE\");\n}\nfilter.setGroupName(query);\ngroupSearch.assignQueryFilter(filter);\nWsFindGroupsResults results = groupSearch.execute();\nif (results != null && results.getGroupResults() != null) {\nfor (WsGroup g : results.getGroupResults()) {\nif (validKey(g.getName())) {\nif (LOGGER.isTraceEnabled()) {\nLOGGER.trace(\"Retrieved group: \" + g.getName());\n}\ngroups.add(new EntityIdentifier(g.getName(), IEntityGroup.class));\n}\n}\n}\nif (LOGGER.isDebugEnabled()) {\nLOGGER.debug(\"Returning \" + groups.size() + \" results for query \" + query);","label":[1,0,0,0]}
{"id":33289,"original_code":"@Override\n  public void run(RunNotifier runNotifier) {\n    runNotifier.fireTestRunStarted(topLevelDesc);\n    for (SelfTest selfTest : selfTests) {\n      for (SelfTestCase selfTestCase : selfTest.getSelfTestCases()) {\n        Description currentDesc = createTestCaseDescription(selfTestCase);\n        runNotifier.fireTestStarted(currentDesc);\n        try {\n          selfTest.runTest(selfTestCase);\n        } catch (IllegalAccessException | IllegalArgumentException | InvocationTargetException\n            | AssertionError e) {\n          runNotifier.fireTestFailure(new Failure(currentDesc, e));\n        }\n        runNotifier.fireTestFinished(currentDesc);\n      }\n    }\n    \/\/ TODO: Fill in the Result instance appropriately.\n    runNotifier.fireTestRunFinished(new Result());\n  }","code":"@Override\n  public void run(RunNotifier runNotifier) {\n    runNotifier.fireTestRunStarted(topLevelDesc);\n    for (SelfTest selfTest : selfTests) {\n      for (SelfTestCase selfTestCase : selfTest.getSelfTestCases()) {\n        Description currentDesc = createTestCaseDescription(selfTestCase);\n        runNotifier.fireTestStarted(currentDesc);\n        try {\n          selfTest.runTest(selfTestCase);\n        } catch (IllegalAccessException | IllegalArgumentException | InvocationTargetException\n            | AssertionError e) {\n          runNotifier.fireTestFailure(new Failure(currentDesc, e));\n        }\n        runNotifier.fireTestFinished(currentDesc);\n      }\n    }\n   \n    runNotifier.fireTestRunFinished(new Result());\n  }","cleancode":"@override public void run(runnotifier runnotifier) { runnotifier.firetestrunstarted(topleveldesc); for (selftest selftest : selftests) { for (selftestcase selftestcase : selftest.getselftestcases()) { description currentdesc = createtestcasedescription(selftestcase); runnotifier.fireteststarted(currentdesc); try { selftest.runtest(selftestcase); } catch (illegalaccessexception | illegalargumentexception | invocationtargetexception | assertionerror e) { runnotifier.firetestfailure(new failure(currentdesc, e)); } runnotifier.firetestfinished(currentdesc); } } runnotifier.firetestrunfinished(new result()); }","comment":"\/** * runs the tests and reports results. *\/\n\/\/ todo: fill in the result instance appropriately.","repo":"scottmcmaster\/blogcode","code_context_2":"@Override\npublic void run(RunNotifier runNotifier) {\nrunNotifier.fireTestRunStarted(topLevelDesc);\nfor (SelfTest selfTest : selfTests) {\nfor (SelfTestCase selfTestCase : selfTest.getSelfTestCases()) {\nDescription currentDesc = createTestCaseDescription(selfTestCase);\nrunNotifier.fireTestStarted(currentDesc);\ntry {\nselfTest.runTest(selfTestCase);\n} catch (IllegalAccessException | IllegalArgumentException | InvocationTargetException\n| AssertionError e) {\nrunNotifier.fireTestFailure(new Failure(currentDesc, e));\n}\nrunNotifier.fireTestFinished(currentDesc);\n}\n}\n\/\/ TODO: Fill in the Result instance appropriately.\nrunNotifier.fireTestRunFinished(new Result());\n}\n\n}\n}\n\/\/ TODO: Fill in the Result instance appropriately.\nrunNotifier.fireTestRunFinished(new Result());\n}","code_context_10":"@Override\npublic void run(RunNotifier runNotifier) {\nrunNotifier.fireTestRunStarted(topLevelDesc);\nfor (SelfTest selfTest : selfTests) {\nfor (SelfTestCase selfTestCase : selfTest.getSelfTestCases()) {\nDescription currentDesc = createTestCaseDescription(selfTestCase);\nrunNotifier.fireTestStarted(currentDesc);\ntry {\nselfTest.runTest(selfTestCase);\n} catch (IllegalAccessException | IllegalArgumentException | InvocationTargetException\n| AssertionError e) {\nrunNotifier.fireTestFailure(new Failure(currentDesc, e));\n}\nrunNotifier.fireTestFinished(currentDesc);\n}\n}\n\/\/ TODO: Fill in the Result instance appropriately.\nrunNotifier.fireTestRunFinished(new Result());\n}\n\nrunNotifier.fireTestStarted(currentDesc);\ntry {\nselfTest.runTest(selfTestCase);\n} catch (IllegalAccessException | IllegalArgumentException | InvocationTargetException\n| AssertionError e) {\nrunNotifier.fireTestFailure(new Failure(currentDesc, e));\n}\nrunNotifier.fireTestFinished(currentDesc);\n}\n}\n\/\/ TODO: Fill in the Result instance appropriately.\nrunNotifier.fireTestRunFinished(new Result());\n}","code_context_20":"@Override\npublic void run(RunNotifier runNotifier) {\nrunNotifier.fireTestRunStarted(topLevelDesc);\nfor (SelfTest selfTest : selfTests) {\nfor (SelfTestCase selfTestCase : selfTest.getSelfTestCases()) {\nDescription currentDesc = createTestCaseDescription(selfTestCase);\nrunNotifier.fireTestStarted(currentDesc);\ntry {\nselfTest.runTest(selfTestCase);\n} catch (IllegalAccessException | IllegalArgumentException | InvocationTargetException\n| AssertionError e) {\nrunNotifier.fireTestFailure(new Failure(currentDesc, e));\n}\nrunNotifier.fireTestFinished(currentDesc);\n}\n}\n\/\/ TODO: Fill in the Result instance appropriately.\nrunNotifier.fireTestRunFinished(new Result());\n}\n\n@Override\npublic void run(RunNotifier runNotifier) {\nrunNotifier.fireTestRunStarted(topLevelDesc);\nfor (SelfTest selfTest : selfTests) {\nfor (SelfTestCase selfTestCase : selfTest.getSelfTestCases()) {\nDescription currentDesc = createTestCaseDescription(selfTestCase);\nrunNotifier.fireTestStarted(currentDesc);\ntry {\nselfTest.runTest(selfTestCase);\n} catch (IllegalAccessException | IllegalArgumentException | InvocationTargetException\n| AssertionError e) {\nrunNotifier.fireTestFailure(new Failure(currentDesc, e));\n}\nrunNotifier.fireTestFinished(currentDesc);\n}\n}\n\/\/ TODO: Fill in the Result instance appropriately.\nrunNotifier.fireTestRunFinished(new Result());\n}","label":[0,1,0,0]}
{"id":8757,"original_code":"@Override\n        public void notifyChildrenChanged(final RemoteUserInfo remoteUserInfo,\n                final String parentId, final Bundle options) {\n            \/\/ TODO(Post-P): Need a way to notify to a specific browser in framework.\n            notifyChildrenChangedForCompat(remoteUserInfo, parentId, options);\n        }","code":"@Override\n        public void notifyChildrenChanged(final RemoteUserInfo remoteUserInfo,\n                final String parentId, final Bundle options) {\n           \n            notifyChildrenChangedForCompat(remoteUserInfo, parentId, options);\n        }","cleancode":"@override public void notifychildrenchanged(final remoteuserinfo remoteuserinfo, final string parentid, final bundle options) { notifychildrenchangedforcompat(remoteuserinfo, parentid, options); }","comment":"\/\/ todo(post-p): need a way to notify to a specific browser in framework.","repo":"svasilinets\/androidx","code_context_2":"public void notifyChildrenChanged(final RemoteUserInfo remoteUserInfo,\nfinal String parentId, final Bundle options) {\n\/\/ TODO(Post-P): Need a way to notify to a specific browser in framework.\nnotifyChildrenChangedForCompat(remoteUserInfo, parentId, options);\n}","code_context_10":"@Override\npublic void notifyChildrenChanged(final RemoteUserInfo remoteUserInfo,\nfinal String parentId, final Bundle options) {\n\/\/ TODO(Post-P): Need a way to notify to a specific browser in framework.\nnotifyChildrenChangedForCompat(remoteUserInfo, parentId, options);\n}","code_context_20":"@Override\npublic void notifyChildrenChanged(final RemoteUserInfo remoteUserInfo,\nfinal String parentId, final Bundle options) {\n\/\/ TODO(Post-P): Need a way to notify to a specific browser in framework.\nnotifyChildrenChangedForCompat(remoteUserInfo, parentId, options);\n}","label":[1,0,0,0]}
{"id":25273,"original_code":"@Override\n\tpublic IASTTranslationUnit getTranslationUnit(IFile fileToParse) throws UnsupportedDialectException {\n    \t\/\/TODO - At this time, we purely delegate blindly\n    \t\/\/In the future, we may need to delegate based upon context provided\n        return defaultService.getTranslationUnit(fileToParse);\n    }","code":"@Override\n\tpublic IASTTranslationUnit getTranslationUnit(IFile fileToParse) throws UnsupportedDialectException {\n    \n    \n        return defaultService.getTranslationUnit(fileToParse);\n    }","cleancode":"@override public iasttranslationunit gettranslationunit(ifile filetoparse) throws unsupporteddialectexception { return defaultservice.gettranslationunit(filetoparse); }","comment":"\/\/todo - at this time, we purely delegate blindly \/\/in the future, we may need to delegate based upon context provided","repo":"seemoo-lab\/polypyus_pdom","code_context_2":"@Override\npublic IASTTranslationUnit getTranslationUnit(IFile fileToParse) throws UnsupportedDialectException {\n\/\/TODO - At this time, we purely delegate blindly\n\/\/In the future, we may need to delegate based upon context provided\nreturn defaultService.getTranslationUnit(fileToParse);\n}","code_context_10":"@Override\npublic IASTTranslationUnit getTranslationUnit(IFile fileToParse) throws UnsupportedDialectException {\n\/\/TODO - At this time, we purely delegate blindly\n\/\/In the future, we may need to delegate based upon context provided\nreturn defaultService.getTranslationUnit(fileToParse);\n}","code_context_20":"@Override\npublic IASTTranslationUnit getTranslationUnit(IFile fileToParse) throws UnsupportedDialectException {\n\/\/TODO - At this time, we purely delegate blindly\n\/\/In the future, we may need to delegate based upon context provided\nreturn defaultService.getTranslationUnit(fileToParse);\n}","label":[0,1,0,0]}
{"id":25274,"original_code":"@Override\n\tpublic IASTTranslationUnit getTranslationUnit(IFile fileToParse, ICodeReaderFactory fileCreator) throws UnsupportedDialectException {\n    \t\/\/TODO - At this time, we purely delegate blindly\n    \t\/\/In the future, we may need to delegate based upon context provided\n    \treturn defaultService.getTranslationUnit(fileToParse, fileCreator );\n    }","code":"@Override\n\tpublic IASTTranslationUnit getTranslationUnit(IFile fileToParse, ICodeReaderFactory fileCreator) throws UnsupportedDialectException {\n    \n    \n    \treturn defaultService.getTranslationUnit(fileToParse, fileCreator );\n    }","cleancode":"@override public iasttranslationunit gettranslationunit(ifile filetoparse, icodereaderfactory filecreator) throws unsupporteddialectexception { return defaultservice.gettranslationunit(filetoparse, filecreator ); }","comment":"\/\/todo - at this time, we purely delegate blindly \/\/in the future, we may need to delegate based upon context provided","repo":"seemoo-lab\/polypyus_pdom","code_context_2":"@Override\npublic IASTTranslationUnit getTranslationUnit(IFile fileToParse, ICodeReaderFactory fileCreator) throws UnsupportedDialectException {\n\/\/TODO - At this time, we purely delegate blindly\n\/\/In the future, we may need to delegate based upon context provided\nreturn defaultService.getTranslationUnit(fileToParse, fileCreator );\n}","code_context_10":"@Override\npublic IASTTranslationUnit getTranslationUnit(IFile fileToParse, ICodeReaderFactory fileCreator) throws UnsupportedDialectException {\n\/\/TODO - At this time, we purely delegate blindly\n\/\/In the future, we may need to delegate based upon context provided\nreturn defaultService.getTranslationUnit(fileToParse, fileCreator );\n}","code_context_20":"@Override\npublic IASTTranslationUnit getTranslationUnit(IFile fileToParse, ICodeReaderFactory fileCreator) throws UnsupportedDialectException {\n\/\/TODO - At this time, we purely delegate blindly\n\/\/In the future, we may need to delegate based upon context provided\nreturn defaultService.getTranslationUnit(fileToParse, fileCreator );\n}","label":[0,1,0,0]}
{"id":25275,"original_code":"@Override\n\tpublic IASTTranslationUnit getTranslationUnit(IFile fileToParse, ICodeReaderFactory fileCreator, IParserConfiguration configuration) throws UnsupportedDialectException {\n    \t\/\/TODO - At this time, we purely delegate blindly\n    \t\/\/In the future, we may need to delegate based upon context provided\n        return defaultService.getTranslationUnit(fileToParse, fileCreator, configuration );\n    }","code":"@Override\n\tpublic IASTTranslationUnit getTranslationUnit(IFile fileToParse, ICodeReaderFactory fileCreator, IParserConfiguration configuration) throws UnsupportedDialectException {\n    \n    \n        return defaultService.getTranslationUnit(fileToParse, fileCreator, configuration );\n    }","cleancode":"@override public iasttranslationunit gettranslationunit(ifile filetoparse, icodereaderfactory filecreator, iparserconfiguration configuration) throws unsupporteddialectexception { return defaultservice.gettranslationunit(filetoparse, filecreator, configuration ); }","comment":"\/\/todo - at this time, we purely delegate blindly \/\/in the future, we may need to delegate based upon context provided","repo":"seemoo-lab\/polypyus_pdom","code_context_2":"@Override\npublic IASTTranslationUnit getTranslationUnit(IFile fileToParse, ICodeReaderFactory fileCreator, IParserConfiguration configuration) throws UnsupportedDialectException {\n\/\/TODO - At this time, we purely delegate blindly\n\/\/In the future, we may need to delegate based upon context provided\nreturn defaultService.getTranslationUnit(fileToParse, fileCreator, configuration );\n}","code_context_10":"@Override\npublic IASTTranslationUnit getTranslationUnit(IFile fileToParse, ICodeReaderFactory fileCreator, IParserConfiguration configuration) throws UnsupportedDialectException {\n\/\/TODO - At this time, we purely delegate blindly\n\/\/In the future, we may need to delegate based upon context provided\nreturn defaultService.getTranslationUnit(fileToParse, fileCreator, configuration );\n}","code_context_20":"@Override\npublic IASTTranslationUnit getTranslationUnit(IFile fileToParse, ICodeReaderFactory fileCreator, IParserConfiguration configuration) throws UnsupportedDialectException {\n\/\/TODO - At this time, we purely delegate blindly\n\/\/In the future, we may need to delegate based upon context provided\nreturn defaultService.getTranslationUnit(fileToParse, fileCreator, configuration );\n}","label":[0,1,0,0]}
{"id":25276,"original_code":"@Override\n\tpublic IASTCompletionNode getCompletionNode(IFile fileToParse, int offset,\n            ICodeReaderFactory fileCreator) throws UnsupportedDialectException {\n        \/\/TODO - At this time, we purely delegate blindly\n        \/\/In the future, we may need to delegate based upon context provided\n        return defaultService.getCompletionNode(fileToParse, offset, fileCreator);\n    }","code":"@Override\n\tpublic IASTCompletionNode getCompletionNode(IFile fileToParse, int offset,\n            ICodeReaderFactory fileCreator) throws UnsupportedDialectException {\n       \n       \n        return defaultService.getCompletionNode(fileToParse, offset, fileCreator);\n    }","cleancode":"@override public iastcompletionnode getcompletionnode(ifile filetoparse, int offset, icodereaderfactory filecreator) throws unsupporteddialectexception { return defaultservice.getcompletionnode(filetoparse, offset, filecreator); }","comment":"\/\/todo - at this time, we purely delegate blindly \/\/in the future, we may need to delegate based upon context provided","repo":"seemoo-lab\/polypyus_pdom","code_context_2":"public IASTCompletionNode getCompletionNode(IFile fileToParse, int offset,\nICodeReaderFactory fileCreator) throws UnsupportedDialectException {\n\/\/TODO - At this time, we purely delegate blindly\n\/\/In the future, we may need to delegate based upon context provided\nreturn defaultService.getCompletionNode(fileToParse, offset, fileCreator);\n}","code_context_10":"@Override\npublic IASTCompletionNode getCompletionNode(IFile fileToParse, int offset,\nICodeReaderFactory fileCreator) throws UnsupportedDialectException {\n\/\/TODO - At this time, we purely delegate blindly\n\/\/In the future, we may need to delegate based upon context provided\nreturn defaultService.getCompletionNode(fileToParse, offset, fileCreator);\n}","code_context_20":"@Override\npublic IASTCompletionNode getCompletionNode(IFile fileToParse, int offset,\nICodeReaderFactory fileCreator) throws UnsupportedDialectException {\n\/\/TODO - At this time, we purely delegate blindly\n\/\/In the future, we may need to delegate based upon context provided\nreturn defaultService.getCompletionNode(fileToParse, offset, fileCreator);\n}","label":[0,1,0,0]}
{"id":25277,"original_code":"@Override\n\tpublic IASTCompletionNode getCompletionNode(IStorage fileToParse, IProject project, int offset,\n            ICodeReaderFactory fileCreator) throws UnsupportedDialectException {\n        \/\/TODO - At this time, we purely delegate blindly\n        \/\/In the future, we may need to delegate based upon context provided\n        return defaultService.getCompletionNode(fileToParse, project, offset, fileCreator);\n    }","code":"@Override\n\tpublic IASTCompletionNode getCompletionNode(IStorage fileToParse, IProject project, int offset,\n            ICodeReaderFactory fileCreator) throws UnsupportedDialectException {\n       \n       \n        return defaultService.getCompletionNode(fileToParse, project, offset, fileCreator);\n    }","cleancode":"@override public iastcompletionnode getcompletionnode(istorage filetoparse, iproject project, int offset, icodereaderfactory filecreator) throws unsupporteddialectexception { return defaultservice.getcompletionnode(filetoparse, project, offset, filecreator); }","comment":"\/\/todo - at this time, we purely delegate blindly \/\/in the future, we may need to delegate based upon context provided","repo":"seemoo-lab\/polypyus_pdom","code_context_2":"public IASTCompletionNode getCompletionNode(IStorage fileToParse, IProject project, int offset,\nICodeReaderFactory fileCreator) throws UnsupportedDialectException {\n\/\/TODO - At this time, we purely delegate blindly\n\/\/In the future, we may need to delegate based upon context provided\nreturn defaultService.getCompletionNode(fileToParse, project, offset, fileCreator);\n}","code_context_10":"@Override\npublic IASTCompletionNode getCompletionNode(IStorage fileToParse, IProject project, int offset,\nICodeReaderFactory fileCreator) throws UnsupportedDialectException {\n\/\/TODO - At this time, we purely delegate blindly\n\/\/In the future, we may need to delegate based upon context provided\nreturn defaultService.getCompletionNode(fileToParse, project, offset, fileCreator);\n}","code_context_20":"@Override\npublic IASTCompletionNode getCompletionNode(IStorage fileToParse, IProject project, int offset,\nICodeReaderFactory fileCreator) throws UnsupportedDialectException {\n\/\/TODO - At this time, we purely delegate blindly\n\/\/In the future, we may need to delegate based upon context provided\nreturn defaultService.getCompletionNode(fileToParse, project, offset, fileCreator);\n}","label":[0,1,0,0]}
{"id":17091,"original_code":"@Override\n  public List<SpawnResult> writeOutputToFile(\n      AbstractAction action,\n      ActionExecutionContext actionExecutionContext,\n      DeterministicWriter deterministicWriter,\n      boolean makeExecutable, boolean isRemotable)\n      throws ExecException {\n    Path outputPath =\n        actionExecutionContext.getInputPath(Iterables.getOnlyElement(action.getOutputs()));\n    \/\/ TODO(ulfjack): Consider acquiring local resources here before trying to write the file.\n    try (AutoProfiler p =\n        AutoProfiler.logged(\n            \"running write for action \" + action.prettyPrint(),\n            logger,\n            \/*minTimeForLoggingInMilliseconds=*\/ 100)) {\n      try {\n        try (OutputStream out = new BufferedOutputStream(outputPath.getOutputStream())) {\n          deterministicWriter.writeOutputFile(out);\n        }\n        if (makeExecutable) {\n          outputPath.setExecutable(true);\n        }\n      } catch (IOException e) {\n        throw new EnvironmentalExecException(\"IOException during file write\", e);\n      }\n    }\n    return ImmutableList.of();\n  }","code":"@Override\n  public List<SpawnResult> writeOutputToFile(\n      AbstractAction action,\n      ActionExecutionContext actionExecutionContext,\n      DeterministicWriter deterministicWriter,\n      boolean makeExecutable, boolean isRemotable)\n      throws ExecException {\n    Path outputPath =\n        actionExecutionContext.getInputPath(Iterables.getOnlyElement(action.getOutputs()));\n   \n    try (AutoProfiler p =\n        AutoProfiler.logged(\n            \"running write for action \" + action.prettyPrint(),\n            logger,\n            100)) {\n      try {\n        try (OutputStream out = new BufferedOutputStream(outputPath.getOutputStream())) {\n          deterministicWriter.writeOutputFile(out);\n        }\n        if (makeExecutable) {\n          outputPath.setExecutable(true);\n        }\n      } catch (IOException e) {\n        throw new EnvironmentalExecException(\"IOException during file write\", e);\n      }\n    }\n    return ImmutableList.of();\n  }","cleancode":"@override public list<spawnresult> writeoutputtofile( abstractaction action, actionexecutioncontext actionexecutioncontext, deterministicwriter deterministicwriter, boolean makeexecutable, boolean isremotable) throws execexception { path outputpath = actionexecutioncontext.getinputpath(iterables.getonlyelement(action.getoutputs())); try (autoprofiler p = autoprofiler.logged( \"running write for action \" + action.prettyprint(), logger, 100)) { try { try (outputstream out = new bufferedoutputstream(outputpath.getoutputstream())) { deterministicwriter.writeoutputfile(out); } if (makeexecutable) { outputpath.setexecutable(true); } } catch (ioexception e) { throw new environmentalexecexception(\"ioexception during file write\", e); } } return immutablelist.of(); }","comment":"\/\/ todo(ulfjack): consider acquiring local resources here before trying to write the file.\n\/*mintimeforlogginginmilliseconds=*\/","repo":"sevki\/bazel","code_context_2":"Path outputPath =\nactionExecutionContext.getInputPath(Iterables.getOnlyElement(action.getOutputs()));\n\/\/ TODO(ulfjack): Consider acquiring local resources here before trying to write the file.\ntry (AutoProfiler p =\nAutoProfiler.logged(\n\n\"running write for action \" + action.prettyPrint(),\nlogger,\n\/*minTimeForLoggingInMilliseconds=*\/ 100)) {\ntry {\ntry (OutputStream out = new BufferedOutputStream(outputPath.getOutputStream())) {","code_context_10":"@Override\npublic List<SpawnResult> writeOutputToFile(\nAbstractAction action,\nActionExecutionContext actionExecutionContext,\nDeterministicWriter deterministicWriter,\nboolean makeExecutable, boolean isRemotable)\nthrows ExecException {\nPath outputPath =\nactionExecutionContext.getInputPath(Iterables.getOnlyElement(action.getOutputs()));\n\/\/ TODO(ulfjack): Consider acquiring local resources here before trying to write the file.\ntry (AutoProfiler p =\nAutoProfiler.logged(\n\"running write for action \" + action.prettyPrint(),\nlogger,\n\/*minTimeForLoggingInMilliseconds=*\/ 100)) {\ntry {\ntry (OutputStream out = new BufferedOutputStream(outputPath.getOutputStream())) {\ndeterministicWriter.writeOutputFile(out);\n}\nif (makeExecutable) {\n\nDeterministicWriter deterministicWriter,\nboolean makeExecutable, boolean isRemotable)\nthrows ExecException {\nPath outputPath =\nactionExecutionContext.getInputPath(Iterables.getOnlyElement(action.getOutputs()));\n\/\/ TODO(ulfjack): Consider acquiring local resources here before trying to write the file.\ntry (AutoProfiler p =\nAutoProfiler.logged(\n\"running write for action \" + action.prettyPrint(),\nlogger,\n\/*minTimeForLoggingInMilliseconds=*\/ 100)) {\ntry {\ntry (OutputStream out = new BufferedOutputStream(outputPath.getOutputStream())) {\ndeterministicWriter.writeOutputFile(out);\n}\nif (makeExecutable) {\noutputPath.setExecutable(true);\n}\n} catch (IOException e) {\nthrow new EnvironmentalExecException(\"IOException during file write\", e);\n}","code_context_20":"@Override\npublic List<SpawnResult> writeOutputToFile(\nAbstractAction action,\nActionExecutionContext actionExecutionContext,\nDeterministicWriter deterministicWriter,\nboolean makeExecutable, boolean isRemotable)\nthrows ExecException {\nPath outputPath =\nactionExecutionContext.getInputPath(Iterables.getOnlyElement(action.getOutputs()));\n\/\/ TODO(ulfjack): Consider acquiring local resources here before trying to write the file.\ntry (AutoProfiler p =\nAutoProfiler.logged(\n\"running write for action \" + action.prettyPrint(),\nlogger,\n\/*minTimeForLoggingInMilliseconds=*\/ 100)) {\ntry {\ntry (OutputStream out = new BufferedOutputStream(outputPath.getOutputStream())) {\ndeterministicWriter.writeOutputFile(out);\n}\nif (makeExecutable) {\noutputPath.setExecutable(true);\n}\n} catch (IOException e) {\nthrow new EnvironmentalExecException(\"IOException during file write\", e);\n}\n}\nreturn ImmutableList.of();\n}\n\n@Override\npublic List<SpawnResult> writeOutputToFile(\nAbstractAction action,\nActionExecutionContext actionExecutionContext,\nDeterministicWriter deterministicWriter,\nboolean makeExecutable, boolean isRemotable)\nthrows ExecException {\nPath outputPath =\nactionExecutionContext.getInputPath(Iterables.getOnlyElement(action.getOutputs()));\n\/\/ TODO(ulfjack): Consider acquiring local resources here before trying to write the file.\ntry (AutoProfiler p =\nAutoProfiler.logged(\n\"running write for action \" + action.prettyPrint(),\nlogger,\n\/*minTimeForLoggingInMilliseconds=*\/ 100)) {\ntry {\ntry (OutputStream out = new BufferedOutputStream(outputPath.getOutputStream())) {\ndeterministicWriter.writeOutputFile(out);\n}\nif (makeExecutable) {\noutputPath.setExecutable(true);\n}\n} catch (IOException e) {\nthrow new EnvironmentalExecException(\"IOException during file write\", e);\n}\n}\nreturn ImmutableList.of();\n}","label":[0,1,0,0]}
{"id":733,"original_code":"public static void stopTimerQueue() {\n    singleton.stop();\n    singleton.queue = new PriorityQueue();\n  }","code":"public static void stopTimerQueue() {\n    singleton.stop();\n    singleton.queue = new PriorityQueue();\n  }","cleancode":"public static void stoptimerqueue() { singleton.stop(); singleton.queue = new priorityqueue(); }","comment":"\/** called by locksstestcase.teardown() to prevent events from happening * after tests complete. tk - fix when this is made a lockssmanager. *\/","repo":"rondinelisaad\/lockss-daemon","code_context_2":"public static void stopTimerQueue() {\nsingleton.stop();\nsingleton.queue = new PriorityQueue();\n}","code_context_10":"public static void stopTimerQueue() {\nsingleton.stop();\nsingleton.queue = new PriorityQueue();\n}","code_context_20":"public static void stopTimerQueue() {\nsingleton.stop();\nsingleton.queue = new PriorityQueue();\n}","label":[0,0,1,0]}
{"id":25316,"original_code":"@Deprecated \/\/ caused issues https:\/\/github.com\/holgerbrandl\/r4intellij\/issues\/79\n    private static ArrayList<String> getInstallationFromPaths(@NotNull final String scriptName, @NotNull final String[] paths) {\n        final ArrayList<String> result = new ArrayList<String>();\n        for (String path : paths) {\n            \/\/ does not work in tests\n            final VirtualFile rootVDir = LocalFileSystem.getInstance().findFileByPath(path);\n            if (rootVDir != null) {\n\/\/                final VirtualFile rScript = rootVDir.findFileByRelativePath(\"bin\/\" + scriptName);\n                final File rScript = findScript(scriptName, path);\n                if (rScript != null) {\n                    result.add(FileUtil.toSystemDependentName(rScript.getPath()));\n                }\n            }\n        }\n        return result;\n    }","code":"@Deprecated     private static ArrayList<String> getInstallationFromPaths(@NotNull final String scriptName, @NotNull final String[] paths) {\n        final ArrayList<String> result = new ArrayList<String>();\n        for (String path : paths) {\n           \n            final VirtualFile rootVDir = LocalFileSystem.getInstance().findFileByPath(path);\n            if (rootVDir != null) {\n                final File rScript = findScript(scriptName, path);\n                if (rScript != null) {\n                    result.add(FileUtil.toSystemDependentName(rScript.getPath()));\n                }\n            }\n        }\n        return result;\n    }","cleancode":"@deprecated private static arraylist<string> getinstallationfrompaths(@notnull final string scriptname, @notnull final string[] paths) { final arraylist<string> result = new arraylist<string>(); for (string path : paths) { final virtualfile rootvdir = localfilesystem.getinstance().findfilebypath(path); if (rootvdir != null) { final file rscript = findscript(scriptname, path); if (rscript != null) { result.add(fileutil.tosystemdependentname(rscript.getpath())); } } } return result; }","comment":"\/\/ caused issues https:\/\/github.com\/holgerbrandl\/r4intellij\/issues\/79\n\/\/ does not work in tests\n\/\/ final virtualfile rscript = rootvdir.findfilebyrelativepath(\"bin\/\" + scriptname);","repo":"rillig\/r4intellij","code_context_2":"@Deprecated \/\/ caused issues https:\/\/github.com\/holgerbrandl\/r4intellij\/issues\/79\nprivate static ArrayList<String> getInstallationFromPaths(@NotNull final String scriptName, @NotNull final String[] paths) {\nfinal ArrayList<String> result = new ArrayList<String>();\n\nfinal ArrayList<String> result = new ArrayList<String>();\nfor (String path : paths) {\n\/\/ does not work in tests\nfinal VirtualFile rootVDir = LocalFileSystem.getInstance().findFileByPath(path);\nif (rootVDir != null) {\n\nfinal VirtualFile rootVDir = LocalFileSystem.getInstance().findFileByPath(path);\nif (rootVDir != null) {\n\/\/ final VirtualFile rScript = rootVDir.findFileByRelativePath(\"bin\/\" + scriptName);\nfinal File rScript = findScript(scriptName, path);\nif (rScript != null) {","code_context_10":"@Deprecated \/\/ caused issues https:\/\/github.com\/holgerbrandl\/r4intellij\/issues\/79\nprivate static ArrayList<String> getInstallationFromPaths(@NotNull final String scriptName, @NotNull final String[] paths) {\nfinal ArrayList<String> result = new ArrayList<String>();\nfor (String path : paths) {\n\/\/ does not work in tests\nfinal VirtualFile rootVDir = LocalFileSystem.getInstance().findFileByPath(path);\nif (rootVDir != null) {\n\/\/ final VirtualFile rScript = rootVDir.findFileByRelativePath(\"bin\/\" + scriptName);\nfinal File rScript = findScript(scriptName, path);\nif (rScript != null) {\nresult.add(FileUtil.toSystemDependentName(rScript.getPath()));\n\n@Deprecated \/\/ caused issues https:\/\/github.com\/holgerbrandl\/r4intellij\/issues\/79\nprivate static ArrayList<String> getInstallationFromPaths(@NotNull final String scriptName, @NotNull final String[] paths) {\nfinal ArrayList<String> result = new ArrayList<String>();\nfor (String path : paths) {\n\/\/ does not work in tests\nfinal VirtualFile rootVDir = LocalFileSystem.getInstance().findFileByPath(path);\nif (rootVDir != null) {\n\/\/ final VirtualFile rScript = rootVDir.findFileByRelativePath(\"bin\/\" + scriptName);\nfinal File rScript = findScript(scriptName, path);\nif (rScript != null) {\nresult.add(FileUtil.toSystemDependentName(rScript.getPath()));\n}\n}\n}\nreturn result;\n\n@Deprecated \/\/ caused issues https:\/\/github.com\/holgerbrandl\/r4intellij\/issues\/79\nprivate static ArrayList<String> getInstallationFromPaths(@NotNull final String scriptName, @NotNull final String[] paths) {\nfinal ArrayList<String> result = new ArrayList<String>();\nfor (String path : paths) {\n\/\/ does not work in tests\nfinal VirtualFile rootVDir = LocalFileSystem.getInstance().findFileByPath(path);\nif (rootVDir != null) {\n\/\/ final VirtualFile rScript = rootVDir.findFileByRelativePath(\"bin\/\" + scriptName);\nfinal File rScript = findScript(scriptName, path);\nif (rScript != null) {\nresult.add(FileUtil.toSystemDependentName(rScript.getPath()));\n}\n}\n}\nreturn result;\n}","code_context_20":"@Deprecated \/\/ caused issues https:\/\/github.com\/holgerbrandl\/r4intellij\/issues\/79\nprivate static ArrayList<String> getInstallationFromPaths(@NotNull final String scriptName, @NotNull final String[] paths) {\nfinal ArrayList<String> result = new ArrayList<String>();\nfor (String path : paths) {\n\/\/ does not work in tests\nfinal VirtualFile rootVDir = LocalFileSystem.getInstance().findFileByPath(path);\nif (rootVDir != null) {\n\/\/ final VirtualFile rScript = rootVDir.findFileByRelativePath(\"bin\/\" + scriptName);\nfinal File rScript = findScript(scriptName, path);\nif (rScript != null) {\nresult.add(FileUtil.toSystemDependentName(rScript.getPath()));\n}\n}\n}\nreturn result;\n}\n\n@Deprecated \/\/ caused issues https:\/\/github.com\/holgerbrandl\/r4intellij\/issues\/79\nprivate static ArrayList<String> getInstallationFromPaths(@NotNull final String scriptName, @NotNull final String[] paths) {\nfinal ArrayList<String> result = new ArrayList<String>();\nfor (String path : paths) {\n\/\/ does not work in tests\nfinal VirtualFile rootVDir = LocalFileSystem.getInstance().findFileByPath(path);\nif (rootVDir != null) {\n\/\/ final VirtualFile rScript = rootVDir.findFileByRelativePath(\"bin\/\" + scriptName);\nfinal File rScript = findScript(scriptName, path);\nif (rScript != null) {\nresult.add(FileUtil.toSystemDependentName(rScript.getPath()));\n}\n}\n}\nreturn result;\n}\n\n@Deprecated \/\/ caused issues https:\/\/github.com\/holgerbrandl\/r4intellij\/issues\/79\nprivate static ArrayList<String> getInstallationFromPaths(@NotNull final String scriptName, @NotNull final String[] paths) {\nfinal ArrayList<String> result = new ArrayList<String>();\nfor (String path : paths) {\n\/\/ does not work in tests\nfinal VirtualFile rootVDir = LocalFileSystem.getInstance().findFileByPath(path);\nif (rootVDir != null) {\n\/\/ final VirtualFile rScript = rootVDir.findFileByRelativePath(\"bin\/\" + scriptName);\nfinal File rScript = findScript(scriptName, path);\nif (rScript != null) {\nresult.add(FileUtil.toSystemDependentName(rScript.getPath()));\n}\n}\n}\nreturn result;\n}","label":[0,0,1,0]}
{"id":784,"original_code":"@Test\n\t@Ignore \/\/Fix or deprecate fromExecutor, this test might randomly hang on CI\n\tpublic void rejectedExecutionExceptionOnErrorSignalExecutor()\n\t\t\tthrows InterruptedException {\n\t\tException exception = new IllegalStateException();\n\t\tfinal AtomicReference<Throwable> throwableInOnOperatorError =\n\t\t\t\tnew AtomicReference<>();\n\t\tfinal AtomicReference<Object> dataInOnOperatorError = new AtomicReference<>();\n\t\ttry {\n\t\t\tCountDownLatch hookLatch = new CountDownLatch(2);\n\t\t\tHooks.onOperatorError((t, d) -> {\n\t\t\t\tthrowableInOnOperatorError.set(t);\n\t\t\t\tdataInOnOperatorError.set(d);\n\t\t\t\thookLatch.countDown();\n\t\t\t\treturn t;\n\t\t\t});\n\t\t\tExecutorService executor = newCachedThreadPool();\n\t\t\tCountDownLatch latch = new CountDownLatch(1);\n\t\t\tAssertSubscriber<Integer> assertSubscriber = new AssertSubscriber<>();\n\t\t\tFlux.range(0, 5)\n\t\t\t    .publishOn(fromExecutorService(executor))\n\t\t\t    .doOnNext(s -> {\n\t\t\t\t    try {\n\t\t\t\t\t    latch.await();\n\t\t\t\t    }\n\t\t\t\t    catch (InterruptedException e) {\n\t\t\t\t\t    throw Exceptions.propagate(exception);\n\t\t\t\t    }\n\t\t\t    })\n\t\t\t    .publishOn(fromExecutor(executor))\n\t\t\t    .subscribe(assertSubscriber);\n\t\t\texecutor.shutdownNow();\n\t\t\tassertSubscriber.assertNoValues()\n\t\t\t                .assertNoError()\n\t\t\t                .assertNotComplete();\n\t\t\thookLatch.await();\n\t\t\tassertThat(throwableInOnOperatorError.get()).isInstanceOf(RejectedExecutionException.class);\n\t\t\tassertThat(throwableInOnOperatorError.get().getSuppressed()[0]).isSameAs(exception);\n\t\t}\n\t\tfinally {\n\t\t\tHooks.resetOnOperatorError();\n\t\t}\n\t}","code":"@Test\n\t@Ignore\n\tpublic void rejectedExecutionExceptionOnErrorSignalExecutor()\n\t\t\tthrows InterruptedException {\n\t\tException exception = new IllegalStateException();\n\t\tfinal AtomicReference<Throwable> throwableInOnOperatorError =\n\t\t\t\tnew AtomicReference<>();\n\t\tfinal AtomicReference<Object> dataInOnOperatorError = new AtomicReference<>();\n\t\ttry {\n\t\t\tCountDownLatch hookLatch = new CountDownLatch(2);\n\t\t\tHooks.onOperatorError((t, d) -> {\n\t\t\t\tthrowableInOnOperatorError.set(t);\n\t\t\t\tdataInOnOperatorError.set(d);\n\t\t\t\thookLatch.countDown();\n\t\t\t\treturn t;\n\t\t\t});\n\t\t\tExecutorService executor = newCachedThreadPool();\n\t\t\tCountDownLatch latch = new CountDownLatch(1);\n\t\t\tAssertSubscriber<Integer> assertSubscriber = new AssertSubscriber<>();\n\t\t\tFlux.range(0, 5)\n\t\t\t    .publishOn(fromExecutorService(executor))\n\t\t\t    .doOnNext(s -> {\n\t\t\t\t    try {\n\t\t\t\t\t    latch.await();\n\t\t\t\t    }\n\t\t\t\t    catch (InterruptedException e) {\n\t\t\t\t\t    throw Exceptions.propagate(exception);\n\t\t\t\t    }\n\t\t\t    })\n\t\t\t    .publishOn(fromExecutor(executor))\n\t\t\t    .subscribe(assertSubscriber);\n\t\t\texecutor.shutdownNow();\n\t\t\tassertSubscriber.assertNoValues()\n\t\t\t                .assertNoError()\n\t\t\t                .assertNotComplete();\n\t\t\thookLatch.await();\n\t\t\tassertThat(throwableInOnOperatorError.get()).isInstanceOf(RejectedExecutionException.class);\n\t\t\tassertThat(throwableInOnOperatorError.get().getSuppressed()[0]).isSameAs(exception);\n\t\t}\n\t\tfinally {\n\t\t\tHooks.resetOnOperatorError();\n\t\t}\n\t}","cleancode":"@test @ignore public void rejectedexecutionexceptiononerrorsignalexecutor() throws interruptedexception { exception exception = new illegalstateexception(); final atomicreference<throwable> throwableinonoperatorerror = new atomicreference<>(); final atomicreference<object> datainonoperatorerror = new atomicreference<>(); try { countdownlatch hooklatch = new countdownlatch(2); hooks.onoperatorerror((t, d) -> { throwableinonoperatorerror.set(t); datainonoperatorerror.set(d); hooklatch.countdown(); return t; }); executorservice executor = newcachedthreadpool(); countdownlatch latch = new countdownlatch(1); assertsubscriber<integer> assertsubscriber = new assertsubscriber<>(); flux.range(0, 5) .publishon(fromexecutorservice(executor)) .doonnext(s -> { try { latch.await(); } catch (interruptedexception e) { throw exceptions.propagate(exception); } }) .publishon(fromexecutor(executor)) .subscribe(assertsubscriber); executor.shutdownnow(); assertsubscriber.assertnovalues() .assertnoerror() .assertnotcomplete(); hooklatch.await(); assertthat(throwableinonoperatorerror.get()).isinstanceof(rejectedexecutionexception.class); assertthat(throwableinonoperatorerror.get().getsuppressed()[0]).issameas(exception); } finally { hooks.resetonoperatorerror(); } }","comment":"\/\/fix or deprecate fromexecutor, this test might randomly hang on ci","repo":"steppedreckoner\/reactor-core","code_context_2":"@Test\n@Ignore \/\/Fix or deprecate fromExecutor, this test might randomly hang on CI\npublic void rejectedExecutionExceptionOnErrorSignalExecutor()\nthrows InterruptedException {","code_context_10":"@Test\n@Ignore \/\/Fix or deprecate fromExecutor, this test might randomly hang on CI\npublic void rejectedExecutionExceptionOnErrorSignalExecutor()\nthrows InterruptedException {\nException exception = new IllegalStateException();\nfinal AtomicReference<Throwable> throwableInOnOperatorError =\nnew AtomicReference<>();\nfinal AtomicReference<Object> dataInOnOperatorError = new AtomicReference<>();\ntry {\nCountDownLatch hookLatch = new CountDownLatch(2);\nHooks.onOperatorError((t, d) -> {\nthrowableInOnOperatorError.set(t);","code_context_20":"@Test\n@Ignore \/\/Fix or deprecate fromExecutor, this test might randomly hang on CI\npublic void rejectedExecutionExceptionOnErrorSignalExecutor()\nthrows InterruptedException {\nException exception = new IllegalStateException();\nfinal AtomicReference<Throwable> throwableInOnOperatorError =\nnew AtomicReference<>();\nfinal AtomicReference<Object> dataInOnOperatorError = new AtomicReference<>();\ntry {\nCountDownLatch hookLatch = new CountDownLatch(2);\nHooks.onOperatorError((t, d) -> {\nthrowableInOnOperatorError.set(t);\ndataInOnOperatorError.set(d);\nhookLatch.countDown();\nreturn t;\n});\nExecutorService executor = newCachedThreadPool();\nCountDownLatch latch = new CountDownLatch(1);\nAssertSubscriber<Integer> assertSubscriber = new AssertSubscriber<>();\nFlux.range(0, 5)\n.publishOn(fromExecutorService(executor))\n.doOnNext(s -> {","label":[0,0,0,1]}
{"id":25367,"original_code":"void stopSolver() {\n        if (solverFuture != null) {\n            \/\/ TODO what happens if solver hasn't started yet (solve() is called asynchronously)\n            solver.terminateEarly();\n            \/\/ make sure solver has terminated and propagate exceptions\n            try {\n                solverFuture.get();\n                solverFuture = null;\n            } catch (InterruptedException e) {\n                Thread.currentThread().interrupt();\n                throw new RuntimeException(\"Failed to stop solver\", e);\n            } catch (ExecutionException e) {\n                throw new RuntimeException(\"Failed to stop solver\", e);\n            }\n        }\n    }","code":"void stopSolver() {\n        if (solverFuture != null) {\n           \n            solver.terminateEarly();\n           \n            try {\n                solverFuture.get();\n                solverFuture = null;\n            } catch (InterruptedException e) {\n                Thread.currentThread().interrupt();\n                throw new RuntimeException(\"Failed to stop solver\", e);\n            } catch (ExecutionException e) {\n                throw new RuntimeException(\"Failed to stop solver\", e);\n            }\n        }\n    }","cleancode":"void stopsolver() { if (solverfuture != null) { solver.terminateearly(); try { solverfuture.get(); solverfuture = null; } catch (interruptedexception e) { thread.currentthread().interrupt(); throw new runtimeexception(\"failed to stop solver\", e); } catch (executionexception e) { throw new runtimeexception(\"failed to stop solver\", e); } } }","comment":"\/\/ todo what happens if solver hasn't started yet (solve() is called asynchronously)\n\/\/ make sure solver has terminated and propagate exceptions","repo":"rsynek-bot-account\/optaweb-vehicle-routing","code_context_2":"void stopSolver() {\nif (solverFuture != null) {\n\/\/ TODO what happens if solver hasn't started yet (solve() is called asynchronously)\nsolver.terminateEarly();\n\/\/ make sure solver has terminated and propagate exceptions\n\n\/\/ TODO what happens if solver hasn't started yet (solve() is called asynchronously)\nsolver.terminateEarly();\n\/\/ make sure solver has terminated and propagate exceptions\ntry {\nsolverFuture.get();","code_context_10":"void stopSolver() {\nif (solverFuture != null) {\n\/\/ TODO what happens if solver hasn't started yet (solve() is called asynchronously)\nsolver.terminateEarly();\n\/\/ make sure solver has terminated and propagate exceptions\ntry {\nsolverFuture.get();\nsolverFuture = null;\n} catch (InterruptedException e) {\nThread.currentThread().interrupt();\nthrow new RuntimeException(\"Failed to stop solver\", e);\n} catch (ExecutionException e) {\nthrow new RuntimeException(\"Failed to stop solver\", e);\n\nvoid stopSolver() {\nif (solverFuture != null) {\n\/\/ TODO what happens if solver hasn't started yet (solve() is called asynchronously)\nsolver.terminateEarly();\n\/\/ make sure solver has terminated and propagate exceptions\ntry {\nsolverFuture.get();\nsolverFuture = null;\n} catch (InterruptedException e) {\nThread.currentThread().interrupt();\nthrow new RuntimeException(\"Failed to stop solver\", e);\n} catch (ExecutionException e) {\nthrow new RuntimeException(\"Failed to stop solver\", e);\n}\n}","code_context_20":"void stopSolver() {\nif (solverFuture != null) {\n\/\/ TODO what happens if solver hasn't started yet (solve() is called asynchronously)\nsolver.terminateEarly();\n\/\/ make sure solver has terminated and propagate exceptions\ntry {\nsolverFuture.get();\nsolverFuture = null;\n} catch (InterruptedException e) {\nThread.currentThread().interrupt();\nthrow new RuntimeException(\"Failed to stop solver\", e);\n} catch (ExecutionException e) {\nthrow new RuntimeException(\"Failed to stop solver\", e);\n}\n}\n}\n\nvoid stopSolver() {\nif (solverFuture != null) {\n\/\/ TODO what happens if solver hasn't started yet (solve() is called asynchronously)\nsolver.terminateEarly();\n\/\/ make sure solver has terminated and propagate exceptions\ntry {\nsolverFuture.get();\nsolverFuture = null;\n} catch (InterruptedException e) {\nThread.currentThread().interrupt();\nthrow new RuntimeException(\"Failed to stop solver\", e);\n} catch (ExecutionException e) {\nthrow new RuntimeException(\"Failed to stop solver\", e);\n}\n}\n}","label":[1,0,0,0]}
{"id":813,"original_code":"@Override\n  public boolean asyncCheckpoint(long fileId) throws AlluxioTException {\n    return false;\n  }","code":"@Override\n  public boolean asyncCheckpoint(long fileId) throws AlluxioTException {\n    return false;\n  }","cleancode":"@override public boolean asynccheckpoint(long fileid) throws alluxiotexception { return false; }","comment":"\/\/ todo(calvin): make this supported again.","repo":"shaneknapp\/tachyon","code_context_2":"@Override\npublic boolean asyncCheckpoint(long fileId) throws AlluxioTException {\nreturn false;\n}","code_context_10":"@Override\npublic boolean asyncCheckpoint(long fileId) throws AlluxioTException {\nreturn false;\n}","code_context_20":"@Override\npublic boolean asyncCheckpoint(long fileId) throws AlluxioTException {\nreturn false;\n}","label":[1,0,0,0]}
{"id":825,"original_code":"private Instance marshall(ServiceInstance serviceInstance) {\n\t\tString hostname = serviceInstance.getHost();\n\t\tString cluster = getClusterName(serviceInstance);\n\t\tBoolean status = Boolean.TRUE; \/\/TODO: where to get?\n\t\tif (hostname != null && cluster != null && status != null) {\n\t\t\tInstance instance = new Instance(hostname, cluster, status);\n\t\t\t\/\/ TODO: reimplement when metadata is in commons\n\t\t\t\/\/ add metadata\n\t\t\t\/*Map<String, String> metadata = instanceInfo.getMetadata();\n\t\t\tif (metadata != null) {\n\t\t\t\tinstance.getAttributes().putAll(metadata);\n\t\t\t}*\/\n\t\t\t\/\/ add ports\n\t\t\tinstance.getAttributes().put(\"port\", String.valueOf(serviceInstance.getPort()));\n\t\t\tboolean securePortEnabled = serviceInstance.isSecure();\n\t\t\tif (securePortEnabled) {\n\t\t\t\tinstance.getAttributes().put(\"securePort\", String.valueOf(serviceInstance.getPort()));\n\t\t\t}\n\t\t\treturn instance;\n\t\t}\n\t\telse {\n\t\t\treturn null;\n\t\t}\n\t}","code":"private Instance marshall(ServiceInstance serviceInstance) {\n\t\tString hostname = serviceInstance.getHost();\n\t\tString cluster = getClusterName(serviceInstance);\n\t\tBoolean status = Boolean.TRUE;\n\t\tif (hostname != null && cluster != null && status != null) {\n\t\t\tInstance instance = new Instance(hostname, cluster, status);\n\t\t\n\t\t\n\t\t\n\t\t\n\t\t\tinstance.getAttributes().put(\"port\", String.valueOf(serviceInstance.getPort()));\n\t\t\tboolean securePortEnabled = serviceInstance.isSecure();\n\t\t\tif (securePortEnabled) {\n\t\t\t\tinstance.getAttributes().put(\"securePort\", String.valueOf(serviceInstance.getPort()));\n\t\t\t}\n\t\t\treturn instance;\n\t\t}\n\t\telse {\n\t\t\treturn null;\n\t\t}\n\t}","cleancode":"private instance marshall(serviceinstance serviceinstance) { string hostname = serviceinstance.gethost(); string cluster = getclustername(serviceinstance); boolean status = boolean.true; if (hostname != null && cluster != null && status != null) { instance instance = new instance(hostname, cluster, status); instance.getattributes().put(\"port\", string.valueof(serviceinstance.getport())); boolean secureportenabled = serviceinstance.issecure(); if (secureportenabled) { instance.getattributes().put(\"secureport\", string.valueof(serviceinstance.getport())); } return instance; } else { return null; } }","comment":"\/** * private helper that marshals the information from each instance into something that * turbine can understand. override this method for your own implementation for * parsing eureka info. * @param serviceinstance * @return instance *\/\n\/\/todo: where to get?\n\/\/ todo: reimplement when metadata is in commons \/\/ add metadata \/*map<string, string> metadata = instanceinfo.getmetadata(); if (metadata != null) { instance.getattributes().putall(metadata); }*\/\n\/\/ add ports","repo":"royclarkson\/spring-cloud-netflix","code_context_2":"private Instance marshall(ServiceInstance serviceInstance) {\nString hostname = serviceInstance.getHost();\nString cluster = getClusterName(serviceInstance);\nBoolean status = Boolean.TRUE; \/\/TODO: where to get?\nif (hostname != null && cluster != null && status != null) {\nInstance instance = new Instance(hostname, cluster, status);\n\/\/ TODO: reimplement when metadata is in commons\n\/\/ add metadata\n\/*Map<String, String> metadata = instanceInfo.getMetadata();\nif (metadata != null) {\ninstance.getAttributes().putAll(metadata);\n}*\/\n\/\/ add ports\ninstance.getAttributes().put(\"port\", String.valueOf(serviceInstance.getPort()));\nboolean securePortEnabled = serviceInstance.isSecure();\nif (securePortEnabled) {\ninstance.getAttributes().put(\"securePort\", String.valueOf(serviceInstance.getPort()));\n}\nreturn instance;\n}\nelse {\nreturn null;\n}\n}\n\nString hostname = serviceInstance.getHost();\nString cluster = getClusterName(serviceInstance);\nBoolean status = Boolean.TRUE; \/\/TODO: where to get?\nif (hostname != null && cluster != null && status != null) {\nInstance instance = new Instance(hostname, cluster, status);\n\nif (hostname != null && cluster != null && status != null) {\nInstance instance = new Instance(hostname, cluster, status);\n\/\/ TODO: reimplement when metadata is in commons\n\/\/ add metadata\n\/*Map<String, String> metadata = instanceInfo.getMetadata();\nif (metadata != null) {\ninstance.getAttributes().putAll(metadata);\n}*\/\n\/\/ add ports\ninstance.getAttributes().put(\"port\", String.valueOf(serviceInstance.getPort()));\n\ninstance.getAttributes().putAll(metadata);\n}*\/\n\/\/ add ports\ninstance.getAttributes().put(\"port\", String.valueOf(serviceInstance.getPort()));\nboolean securePortEnabled = serviceInstance.isSecure();","code_context_10":"private Instance marshall(ServiceInstance serviceInstance) {\nString hostname = serviceInstance.getHost();\nString cluster = getClusterName(serviceInstance);\nBoolean status = Boolean.TRUE; \/\/TODO: where to get?\nif (hostname != null && cluster != null && status != null) {\nInstance instance = new Instance(hostname, cluster, status);\n\/\/ TODO: reimplement when metadata is in commons\n\/\/ add metadata\n\/*Map<String, String> metadata = instanceInfo.getMetadata();\nif (metadata != null) {\ninstance.getAttributes().putAll(metadata);\n}*\/\n\/\/ add ports\ninstance.getAttributes().put(\"port\", String.valueOf(serviceInstance.getPort()));\nboolean securePortEnabled = serviceInstance.isSecure();\nif (securePortEnabled) {\ninstance.getAttributes().put(\"securePort\", String.valueOf(serviceInstance.getPort()));\n}\nreturn instance;\n}\nelse {\nreturn null;\n}\n}\n\nprivate Instance marshall(ServiceInstance serviceInstance) {\nString hostname = serviceInstance.getHost();\nString cluster = getClusterName(serviceInstance);\nBoolean status = Boolean.TRUE; \/\/TODO: where to get?\nif (hostname != null && cluster != null && status != null) {\nInstance instance = new Instance(hostname, cluster, status);\n\/\/ TODO: reimplement when metadata is in commons\n\/\/ add metadata\n\/*Map<String, String> metadata = instanceInfo.getMetadata();\nif (metadata != null) {\ninstance.getAttributes().putAll(metadata);\n}*\/\n\/\/ add ports\ninstance.getAttributes().put(\"port\", String.valueOf(serviceInstance.getPort()));\n\nprivate Instance marshall(ServiceInstance serviceInstance) {\nString hostname = serviceInstance.getHost();\nString cluster = getClusterName(serviceInstance);\nBoolean status = Boolean.TRUE; \/\/TODO: where to get?\nif (hostname != null && cluster != null && status != null) {\nInstance instance = new Instance(hostname, cluster, status);\n\/\/ TODO: reimplement when metadata is in commons\n\/\/ add metadata\n\/*Map<String, String> metadata = instanceInfo.getMetadata();\nif (metadata != null) {\ninstance.getAttributes().putAll(metadata);\n}*\/\n\/\/ add ports\ninstance.getAttributes().put(\"port\", String.valueOf(serviceInstance.getPort()));\nboolean securePortEnabled = serviceInstance.isSecure();\nif (securePortEnabled) {\ninstance.getAttributes().put(\"securePort\", String.valueOf(serviceInstance.getPort()));\n}\nreturn instance;\n}\nelse {\nreturn null;\n\nString cluster = getClusterName(serviceInstance);\nBoolean status = Boolean.TRUE; \/\/TODO: where to get?\nif (hostname != null && cluster != null && status != null) {\nInstance instance = new Instance(hostname, cluster, status);\n\/\/ TODO: reimplement when metadata is in commons\n\/\/ add metadata\n\/*Map<String, String> metadata = instanceInfo.getMetadata();\nif (metadata != null) {\ninstance.getAttributes().putAll(metadata);\n}*\/\n\/\/ add ports\ninstance.getAttributes().put(\"port\", String.valueOf(serviceInstance.getPort()));\nboolean securePortEnabled = serviceInstance.isSecure();\nif (securePortEnabled) {\ninstance.getAttributes().put(\"securePort\", String.valueOf(serviceInstance.getPort()));\n}\nreturn instance;\n}\nelse {\nreturn null;\n}","code_context_20":"private Instance marshall(ServiceInstance serviceInstance) {\nString hostname = serviceInstance.getHost();\nString cluster = getClusterName(serviceInstance);\nBoolean status = Boolean.TRUE; \/\/TODO: where to get?\nif (hostname != null && cluster != null && status != null) {\nInstance instance = new Instance(hostname, cluster, status);\n\/\/ TODO: reimplement when metadata is in commons\n\/\/ add metadata\n\/*Map<String, String> metadata = instanceInfo.getMetadata();\nif (metadata != null) {\ninstance.getAttributes().putAll(metadata);\n}*\/\n\/\/ add ports\ninstance.getAttributes().put(\"port\", String.valueOf(serviceInstance.getPort()));\nboolean securePortEnabled = serviceInstance.isSecure();\nif (securePortEnabled) {\ninstance.getAttributes().put(\"securePort\", String.valueOf(serviceInstance.getPort()));\n}\nreturn instance;\n}\nelse {\nreturn null;\n}\n}\n\nprivate Instance marshall(ServiceInstance serviceInstance) {\nString hostname = serviceInstance.getHost();\nString cluster = getClusterName(serviceInstance);\nBoolean status = Boolean.TRUE; \/\/TODO: where to get?\nif (hostname != null && cluster != null && status != null) {\nInstance instance = new Instance(hostname, cluster, status);\n\/\/ TODO: reimplement when metadata is in commons\n\/\/ add metadata\n\/*Map<String, String> metadata = instanceInfo.getMetadata();\nif (metadata != null) {\ninstance.getAttributes().putAll(metadata);\n}*\/\n\/\/ add ports\ninstance.getAttributes().put(\"port\", String.valueOf(serviceInstance.getPort()));\nboolean securePortEnabled = serviceInstance.isSecure();\nif (securePortEnabled) {\ninstance.getAttributes().put(\"securePort\", String.valueOf(serviceInstance.getPort()));\n}\nreturn instance;\n}\nelse {\nreturn null;\n}\n}\n\nprivate Instance marshall(ServiceInstance serviceInstance) {\nString hostname = serviceInstance.getHost();\nString cluster = getClusterName(serviceInstance);\nBoolean status = Boolean.TRUE; \/\/TODO: where to get?\nif (hostname != null && cluster != null && status != null) {\nInstance instance = new Instance(hostname, cluster, status);\n\/\/ TODO: reimplement when metadata is in commons\n\/\/ add metadata\n\/*Map<String, String> metadata = instanceInfo.getMetadata();\nif (metadata != null) {\ninstance.getAttributes().putAll(metadata);\n}*\/\n\/\/ add ports\ninstance.getAttributes().put(\"port\", String.valueOf(serviceInstance.getPort()));\nboolean securePortEnabled = serviceInstance.isSecure();\nif (securePortEnabled) {\ninstance.getAttributes().put(\"securePort\", String.valueOf(serviceInstance.getPort()));\n}\nreturn instance;\n}\nelse {\nreturn null;\n}\n}\n\nprivate Instance marshall(ServiceInstance serviceInstance) {\nString hostname = serviceInstance.getHost();\nString cluster = getClusterName(serviceInstance);\nBoolean status = Boolean.TRUE; \/\/TODO: where to get?\nif (hostname != null && cluster != null && status != null) {\nInstance instance = new Instance(hostname, cluster, status);\n\/\/ TODO: reimplement when metadata is in commons\n\/\/ add metadata\n\/*Map<String, String> metadata = instanceInfo.getMetadata();\nif (metadata != null) {\ninstance.getAttributes().putAll(metadata);\n}*\/\n\/\/ add ports\ninstance.getAttributes().put(\"port\", String.valueOf(serviceInstance.getPort()));\nboolean securePortEnabled = serviceInstance.isSecure();\nif (securePortEnabled) {\ninstance.getAttributes().put(\"securePort\", String.valueOf(serviceInstance.getPort()));\n}\nreturn instance;\n}\nelse {\nreturn null;\n}\n}","label":[1,1,0,0]}
{"id":17289,"original_code":"@PostConstruct\n    public void setup(){\n        \/\/Do not use getClass() here... a typical weld issue...\n        endpointUrl=appConfiguration.getBaseEndpoint() + ServiceProviderConfigWS.class.getAnnotation(Path.class).value();\n    }","code":"@PostConstruct\n    public void setup(){\n       \n        endpointUrl=appConfiguration.getBaseEndpoint() + ServiceProviderConfigWS.class.getAnnotation(Path.class).value();\n    }","cleancode":"@postconstruct public void setup(){ endpointurl=appconfiguration.getbaseendpoint() + serviceproviderconfigws.class.getannotation(path.class).value(); }","comment":"\/\/do not use getclass() here... a typical weld issue...","repo":"shoebkhan09\/oxTrust","code_context_2":"@PostConstruct\npublic void setup(){\n\/\/Do not use getClass() here... a typical weld issue...\nendpointUrl=appConfiguration.getBaseEndpoint() + ServiceProviderConfigWS.class.getAnnotation(Path.class).value();\n}","code_context_10":"@PostConstruct\npublic void setup(){\n\/\/Do not use getClass() here... a typical weld issue...\nendpointUrl=appConfiguration.getBaseEndpoint() + ServiceProviderConfigWS.class.getAnnotation(Path.class).value();\n}","code_context_20":"@PostConstruct\npublic void setup(){\n\/\/Do not use getClass() here... a typical weld issue...\nendpointUrl=appConfiguration.getBaseEndpoint() + ServiceProviderConfigWS.class.getAnnotation(Path.class).value();\n}","label":[0,0,1,0]}
{"id":25484,"original_code":"@Test public void testUserDefinedAggregateFunctionImplementsInterface() {\n    final String empDept = JdbcTest.EmpDeptTableFactory.class.getName();\n    final String mySum3 = Smalls.MySum3.class.getName();\n    final String model = \"{\\n\"\n        + \"  version: '1.0',\\n\"\n        + \"   schemas: [\\n\"\n        + \"     {\\n\"\n        + \"       name: 'adhoc',\\n\"\n        + \"       tables: [\\n\"\n        + \"         {\\n\"\n        + \"           name: 'EMPLOYEES',\\n\"\n        + \"           type: 'custom',\\n\"\n        + \"           factory: '\" + empDept + \"',\\n\"\n        + \"           operand: {'foo': true, 'bar': 345}\\n\"\n        + \"         }\\n\"\n        + \"       ],\\n\"\n        + \"       functions: [\\n\"\n        + \"         {\\n\"\n        + \"           name: 'MY_SUM3',\\n\"\n        + \"           className: '\" + mySum3 + \"'\\n\"\n        + \"         }\\n\"\n        + \"       ]\\n\"\n        + \"     }\\n\"\n        + \"   ]\\n\"\n        + \"}\";\n    final CalciteAssert.AssertThat with = CalciteAssert.model(model)\n        .withDefaultSchema(\"adhoc\");\n    with.query(\"select my_sum3(\\\"deptno\\\") as p from EMPLOYEES\\n\")\n        .returns(\"P=50\\n\");\n    with.withDefaultSchema(null)\n        .query(\"select \\\"adhoc\\\".my_sum3(\\\"deptno\\\") as p\\n\"\n            + \"from \\\"adhoc\\\".EMPLOYEES\\n\")\n        .returns(\"P=50\\n\");\n    with.query(\"select my_sum3(\\\"empid\\\"), \\\"deptno\\\" as p from EMPLOYEES\\n\")\n        .throws_(\"Expression 'deptno' is not being grouped\");\n    with.query(\"select my_sum3(\\\"deptno\\\") as p from EMPLOYEES\\n\")\n        .returns(\"P=50\\n\");\n    with.query(\"select my_sum3(\\\"name\\\") as p from EMPLOYEES\\n\")\n        .throws_(\"No match found for function signature MY_SUM3(<CHARACTER>)\");\n    with.query(\"select my_sum3(\\\"deptno\\\", 1) as p from EMPLOYEES\\n\")\n        .throws_(\"No match found for function signature \"\n            + \"MY_SUM3(<NUMERIC>, <NUMERIC>)\");\n    with.query(\"select my_sum3() as p from EMPLOYEES\\n\")\n        .throws_(\"No match found for function signature MY_SUM3()\");\n    with.query(\"select \\\"deptno\\\", my_sum3(\\\"deptno\\\") as p from EMPLOYEES\\n\"\n        + \"group by \\\"deptno\\\"\")\n        .returnsUnordered(\"deptno=20; P=20\",\n            \"deptno=10; P=30\");\n  }","code":"@Test public void testUserDefinedAggregateFunctionImplementsInterface() {\n    final String empDept = JdbcTest.EmpDeptTableFactory.class.getName();\n    final String mySum3 = Smalls.MySum3.class.getName();\n    final String model = \"{\\n\"\n        + \"  version: '1.0',\\n\"\n        + \"   schemas: [\\n\"\n        + \"     {\\n\"\n        + \"       name: 'adhoc',\\n\"\n        + \"       tables: [\\n\"\n        + \"         {\\n\"\n        + \"           name: 'EMPLOYEES',\\n\"\n        + \"           type: 'custom',\\n\"\n        + \"           factory: '\" + empDept + \"',\\n\"\n        + \"           operand: {'foo': true, 'bar': 345}\\n\"\n        + \"         }\\n\"\n        + \"       ],\\n\"\n        + \"       functions: [\\n\"\n        + \"         {\\n\"\n        + \"           name: 'MY_SUM3',\\n\"\n        + \"           className: '\" + mySum3 + \"'\\n\"\n        + \"         }\\n\"\n        + \"       ]\\n\"\n        + \"     }\\n\"\n        + \"   ]\\n\"\n        + \"}\";\n    final CalciteAssert.AssertThat with = CalciteAssert.model(model)\n        .withDefaultSchema(\"adhoc\");\n    with.query(\"select my_sum3(\\\"deptno\\\") as p from EMPLOYEES\\n\")\n        .returns(\"P=50\\n\");\n    with.withDefaultSchema(null)\n        .query(\"select \\\"adhoc\\\".my_sum3(\\\"deptno\\\") as p\\n\"\n            + \"from \\\"adhoc\\\".EMPLOYEES\\n\")\n        .returns(\"P=50\\n\");\n    with.query(\"select my_sum3(\\\"empid\\\"), \\\"deptno\\\" as p from EMPLOYEES\\n\")\n        .throws_(\"Expression 'deptno' is not being grouped\");\n    with.query(\"select my_sum3(\\\"deptno\\\") as p from EMPLOYEES\\n\")\n        .returns(\"P=50\\n\");\n    with.query(\"select my_sum3(\\\"name\\\") as p from EMPLOYEES\\n\")\n        .throws_(\"No match found for function signature MY_SUM3(<CHARACTER>)\");\n    with.query(\"select my_sum3(\\\"deptno\\\", 1) as p from EMPLOYEES\\n\")\n        .throws_(\"No match found for function signature \"\n            + \"MY_SUM3(<NUMERIC>, <NUMERIC>)\");\n    with.query(\"select my_sum3() as p from EMPLOYEES\\n\")\n        .throws_(\"No match found for function signature MY_SUM3()\");\n    with.query(\"select \\\"deptno\\\", my_sum3(\\\"deptno\\\") as p from EMPLOYEES\\n\"\n        + \"group by \\\"deptno\\\"\")\n        .returnsUnordered(\"deptno=20; P=20\",\n            \"deptno=10; P=30\");\n  }","cleancode":"@test public void testuserdefinedaggregatefunctionimplementsinterface() { final string empdept = jdbctest.empdepttablefactory.class.getname(); final string mysum3 = smalls.mysum3.class.getname(); final string model = \"{\\n\" + \" version: '1.0',\\n\" + \" schemas: [\\n\" + \" {\\n\" + \" name: 'adhoc',\\n\" + \" tables: [\\n\" + \" {\\n\" + \" name: 'employees',\\n\" + \" type: 'custom',\\n\" + \" factory: '\" + empdept + \"',\\n\" + \" operand: {'foo': true, 'bar': 345}\\n\" + \" }\\n\" + \" ],\\n\" + \" functions: [\\n\" + \" {\\n\" + \" name: 'my_sum3',\\n\" + \" classname: '\" + mysum3 + \"'\\n\" + \" }\\n\" + \" ]\\n\" + \" }\\n\" + \" ]\\n\" + \"}\"; final calciteassert.assertthat with = calciteassert.model(model) .withdefaultschema(\"adhoc\"); with.query(\"select my_sum3(\\\"deptno\\\") as p from employees\\n\") .returns(\"p=50\\n\"); with.withdefaultschema(null) .query(\"select \\\"adhoc\\\".my_sum3(\\\"deptno\\\") as p\\n\" + \"from \\\"adhoc\\\".employees\\n\") .returns(\"p=50\\n\"); with.query(\"select my_sum3(\\\"empid\\\"), \\\"deptno\\\" as p from employees\\n\") .throws_(\"expression 'deptno' is not being grouped\"); with.query(\"select my_sum3(\\\"deptno\\\") as p from employees\\n\") .returns(\"p=50\\n\"); with.query(\"select my_sum3(\\\"name\\\") as p from employees\\n\") .throws_(\"no match found for function signature my_sum3(<character>)\"); with.query(\"select my_sum3(\\\"deptno\\\", 1) as p from employees\\n\") .throws_(\"no match found for function signature \" + \"my_sum3(<numeric>, <numeric>)\"); with.query(\"select my_sum3() as p from employees\\n\") .throws_(\"no match found for function signature my_sum3()\"); with.query(\"select \\\"deptno\\\", my_sum3(\\\"deptno\\\") as p from employees\\n\" + \"group by \\\"deptno\\\"\") .returnsunordered(\"deptno=20; p=20\", \"deptno=10; p=30\"); }","comment":"\/** test case for * <a href=\"https:\/\/issues.apache.org\/jira\/browse\/calcite-1434\">[calcite-1434] * aggregatefunctionimpl doesnt work if the class implements a generic * interface<\/a>. *\/","repo":"sarasara100\/Quicksql","code_context_2":"@Test public void testUserDefinedAggregateFunctionImplementsInterface() {\nfinal String empDept = JdbcTest.EmpDeptTableFactory.class.getName();\nfinal String mySum3 = Smalls.MySum3.class.getName();\nfinal String model = \"{\\n\"\n+ \" version: '1.0',\\n\"\n+ \" schemas: [\\n\"\n+ \" {\\n\"\n+ \" name: 'adhoc',\\n\"\n+ \" tables: [\\n\"\n+ \" {\\n\"\n+ \" name: 'EMPLOYEES',\\n\"\n+ \" type: 'custom',\\n\"\n+ \" factory: '\" + empDept + \"',\\n\"\n+ \" operand: {'foo': true, 'bar': 345}\\n\"\n+ \" }\\n\"\n+ \" ],\\n\"\n+ \" functions: [\\n\"\n+ \" {\\n\"\n+ \" name: 'MY_SUM3',\\n\"\n+ \" className: '\" + mySum3 + \"'\\n\"\n+ \" }\\n\"\n+ \" ]\\n\"\n+ \" }\\n\"\n+ \" ]\\n\"\n+ \"}\";\nfinal CalciteAssert.AssertThat with = CalciteAssert.model(model)\n.withDefaultSchema(\"adhoc\");\nwith.query(\"select my_sum3(\\\"deptno\\\") as p from EMPLOYEES\\n\")\n.returns(\"P=50\\n\");\nwith.withDefaultSchema(null)\n.query(\"select \\\"adhoc\\\".my_sum3(\\\"deptno\\\") as p\\n\"\n+ \"from \\\"adhoc\\\".EMPLOYEES\\n\")\n.returns(\"P=50\\n\");\nwith.query(\"select my_sum3(\\\"empid\\\"), \\\"deptno\\\" as p from EMPLOYEES\\n\")\n.throws_(\"Expression 'deptno' is not being grouped\");\nwith.query(\"select my_sum3(\\\"deptno\\\") as p from EMPLOYEES\\n\")\n.returns(\"P=50\\n\");\nwith.query(\"select my_sum3(\\\"name\\\") as p from EMPLOYEES\\n\")\n.throws_(\"No match found for function signature MY_SUM3(<CHARACTER>)\");\nwith.query(\"select my_sum3(\\\"deptno\\\", 1) as p from EMPLOYEES\\n\")\n.throws_(\"No match found for function signature \"\n+ \"MY_SUM3(<NUMERIC>, <NUMERIC>)\");\nwith.query(\"select my_sum3() as p from EMPLOYEES\\n\")\n.throws_(\"No match found for function signature MY_SUM3()\");\nwith.query(\"select \\\"deptno\\\", my_sum3(\\\"deptno\\\") as p from EMPLOYEES\\n\"\n+ \"group by \\\"deptno\\\"\")\n.returnsUnordered(\"deptno=20; P=20\",\n\"deptno=10; P=30\");\n}","code_context_10":"@Test public void testUserDefinedAggregateFunctionImplementsInterface() {\nfinal String empDept = JdbcTest.EmpDeptTableFactory.class.getName();\nfinal String mySum3 = Smalls.MySum3.class.getName();\nfinal String model = \"{\\n\"\n+ \" version: '1.0',\\n\"\n+ \" schemas: [\\n\"\n+ \" {\\n\"\n+ \" name: 'adhoc',\\n\"\n+ \" tables: [\\n\"\n+ \" {\\n\"\n+ \" name: 'EMPLOYEES',\\n\"\n+ \" type: 'custom',\\n\"\n+ \" factory: '\" + empDept + \"',\\n\"\n+ \" operand: {'foo': true, 'bar': 345}\\n\"\n+ \" }\\n\"\n+ \" ],\\n\"\n+ \" functions: [\\n\"\n+ \" {\\n\"\n+ \" name: 'MY_SUM3',\\n\"\n+ \" className: '\" + mySum3 + \"'\\n\"\n+ \" }\\n\"\n+ \" ]\\n\"\n+ \" }\\n\"\n+ \" ]\\n\"\n+ \"}\";\nfinal CalciteAssert.AssertThat with = CalciteAssert.model(model)\n.withDefaultSchema(\"adhoc\");\nwith.query(\"select my_sum3(\\\"deptno\\\") as p from EMPLOYEES\\n\")\n.returns(\"P=50\\n\");\nwith.withDefaultSchema(null)\n.query(\"select \\\"adhoc\\\".my_sum3(\\\"deptno\\\") as p\\n\"\n+ \"from \\\"adhoc\\\".EMPLOYEES\\n\")\n.returns(\"P=50\\n\");\nwith.query(\"select my_sum3(\\\"empid\\\"), \\\"deptno\\\" as p from EMPLOYEES\\n\")\n.throws_(\"Expression 'deptno' is not being grouped\");\nwith.query(\"select my_sum3(\\\"deptno\\\") as p from EMPLOYEES\\n\")\n.returns(\"P=50\\n\");\nwith.query(\"select my_sum3(\\\"name\\\") as p from EMPLOYEES\\n\")\n.throws_(\"No match found for function signature MY_SUM3(<CHARACTER>)\");\nwith.query(\"select my_sum3(\\\"deptno\\\", 1) as p from EMPLOYEES\\n\")\n.throws_(\"No match found for function signature \"\n+ \"MY_SUM3(<NUMERIC>, <NUMERIC>)\");\nwith.query(\"select my_sum3() as p from EMPLOYEES\\n\")\n.throws_(\"No match found for function signature MY_SUM3()\");\nwith.query(\"select \\\"deptno\\\", my_sum3(\\\"deptno\\\") as p from EMPLOYEES\\n\"\n+ \"group by \\\"deptno\\\"\")\n.returnsUnordered(\"deptno=20; P=20\",\n\"deptno=10; P=30\");\n}","code_context_20":"@Test public void testUserDefinedAggregateFunctionImplementsInterface() {\nfinal String empDept = JdbcTest.EmpDeptTableFactory.class.getName();\nfinal String mySum3 = Smalls.MySum3.class.getName();\nfinal String model = \"{\\n\"\n+ \" version: '1.0',\\n\"\n+ \" schemas: [\\n\"\n+ \" {\\n\"\n+ \" name: 'adhoc',\\n\"\n+ \" tables: [\\n\"\n+ \" {\\n\"\n+ \" name: 'EMPLOYEES',\\n\"\n+ \" type: 'custom',\\n\"\n+ \" factory: '\" + empDept + \"',\\n\"\n+ \" operand: {'foo': true, 'bar': 345}\\n\"\n+ \" }\\n\"\n+ \" ],\\n\"\n+ \" functions: [\\n\"\n+ \" {\\n\"\n+ \" name: 'MY_SUM3',\\n\"\n+ \" className: '\" + mySum3 + \"'\\n\"\n+ \" }\\n\"\n+ \" ]\\n\"\n+ \" }\\n\"\n+ \" ]\\n\"\n+ \"}\";\nfinal CalciteAssert.AssertThat with = CalciteAssert.model(model)\n.withDefaultSchema(\"adhoc\");\nwith.query(\"select my_sum3(\\\"deptno\\\") as p from EMPLOYEES\\n\")\n.returns(\"P=50\\n\");\nwith.withDefaultSchema(null)\n.query(\"select \\\"adhoc\\\".my_sum3(\\\"deptno\\\") as p\\n\"\n+ \"from \\\"adhoc\\\".EMPLOYEES\\n\")\n.returns(\"P=50\\n\");\nwith.query(\"select my_sum3(\\\"empid\\\"), \\\"deptno\\\" as p from EMPLOYEES\\n\")\n.throws_(\"Expression 'deptno' is not being grouped\");\nwith.query(\"select my_sum3(\\\"deptno\\\") as p from EMPLOYEES\\n\")\n.returns(\"P=50\\n\");\nwith.query(\"select my_sum3(\\\"name\\\") as p from EMPLOYEES\\n\")\n.throws_(\"No match found for function signature MY_SUM3(<CHARACTER>)\");\nwith.query(\"select my_sum3(\\\"deptno\\\", 1) as p from EMPLOYEES\\n\")\n.throws_(\"No match found for function signature \"\n+ \"MY_SUM3(<NUMERIC>, <NUMERIC>)\");\nwith.query(\"select my_sum3() as p from EMPLOYEES\\n\")\n.throws_(\"No match found for function signature MY_SUM3()\");\nwith.query(\"select \\\"deptno\\\", my_sum3(\\\"deptno\\\") as p from EMPLOYEES\\n\"\n+ \"group by \\\"deptno\\\"\")\n.returnsUnordered(\"deptno=20; P=20\",\n\"deptno=10; P=30\");\n}","label":[0,0,0,1]}
{"id":25500,"original_code":"@Override\n    public void generateNormalAppearance()\n    {\n        PDAnnotationInk ink = (PDAnnotationInk) getAnnotation();\n        PDColor color = ink.getColor();\n        if (color == null || color.getComponents().length == 0)\n        {\n            return;\n        }\n        \/\/ PDF spec does not mention \/Border for ink annotations, but it is used if \/BS is not available\n        AnnotationBorder ab = AnnotationBorder.getAnnotationBorder(ink, ink.getBorderStyle());\n        if (Float.compare(ab.width, 0) == 0)\n        {\n            return;\n        }\n        \/\/ Adjust rectangle even if not empty\n        \/\/ file from PDF.js issue 13447\n        \/\/TODO in a class structure this should be overridable\n        float minX = Float.MAX_VALUE;\n        float minY = Float.MAX_VALUE;\n        float maxX = Float.MIN_VALUE;\n        float maxY = Float.MIN_VALUE;\n        for (float[] pathArray : ink.getInkList())\n        {\n            int nPoints = pathArray.length \/ 2;\n            for (int i = 0; i < nPoints; ++i)\n            {\n                float x = pathArray[i * 2];\n                float y = pathArray[i * 2 + 1];\n                minX = Math.min(minX, x);\n                minY = Math.min(minY, y);\n                maxX = Math.max(maxX, x);\n                maxY = Math.max(maxY, y);\n            }\n        }\n        PDRectangle rect = ink.getRectangle();\n        rect.setLowerLeftX(Math.min(minX - ab.width * 2, rect.getLowerLeftX()));\n        rect.setLowerLeftY(Math.min(minY - ab.width * 2, rect.getLowerLeftY()));\n        rect.setUpperRightX(Math.max(maxX + ab.width * 2, rect.getUpperRightX()));\n        rect.setUpperRightY(Math.max(maxY + ab.width * 2, rect.getUpperRightY()));\n        ink.setRectangle(rect);\n        try (PDAppearanceContentStream cs = getNormalAppearanceAsContentStream())\n        {\n            setOpacity(cs, ink.getConstantOpacity());\n            cs.setStrokingColor(color);\n            if (ab.dashArray != null)\n            {\n                cs.setLineDashPattern(ab.dashArray, 0);\n            }\n            cs.setLineWidth(ab.width);\n            for (float[] pathArray : ink.getInkList())\n            {\n                int nPoints = pathArray.length \/ 2;\n                \/\/ \"When drawn, the points shall be connected by straight lines or curves \n                \/\/ in an implementation-dependent way\" - we do lines.\n                for (int i = 0; i < nPoints; ++i)\n                {\n                    float x = pathArray[i * 2];\n                    float y = pathArray[i * 2 + 1];\n                    if (i == 0)\n                    {\n                        cs.moveTo(x, y);\n                    }\n                    else\n                    {\n                        cs.lineTo(x, y);\n                    }\n                }\n                cs.stroke();\n            }\n        }\n        catch (IOException ex)\n        {\n            LOG.error(ex);\n        }\n    }","code":"@Override\n    public void generateNormalAppearance()\n    {\n        PDAnnotationInk ink = (PDAnnotationInk) getAnnotation();\n        PDColor color = ink.getColor();\n        if (color == null || color.getComponents().length == 0)\n        {\n            return;\n        }\n       \n        AnnotationBorder ab = AnnotationBorder.getAnnotationBorder(ink, ink.getBorderStyle());\n        if (Float.compare(ab.width, 0) == 0)\n        {\n            return;\n        }\n       \n       \n       \n        float minX = Float.MAX_VALUE;\n        float minY = Float.MAX_VALUE;\n        float maxX = Float.MIN_VALUE;\n        float maxY = Float.MIN_VALUE;\n        for (float[] pathArray : ink.getInkList())\n        {\n            int nPoints = pathArray.length \/ 2;\n            for (int i = 0; i < nPoints; ++i)\n            {\n                float x = pathArray[i * 2];\n                float y = pathArray[i * 2 + 1];\n                minX = Math.min(minX, x);\n                minY = Math.min(minY, y);\n                maxX = Math.max(maxX, x);\n                maxY = Math.max(maxY, y);\n            }\n        }\n        PDRectangle rect = ink.getRectangle();\n        rect.setLowerLeftX(Math.min(minX - ab.width * 2, rect.getLowerLeftX()));\n        rect.setLowerLeftY(Math.min(minY - ab.width * 2, rect.getLowerLeftY()));\n        rect.setUpperRightX(Math.max(maxX + ab.width * 2, rect.getUpperRightX()));\n        rect.setUpperRightY(Math.max(maxY + ab.width * 2, rect.getUpperRightY()));\n        ink.setRectangle(rect);\n        try (PDAppearanceContentStream cs = getNormalAppearanceAsContentStream())\n        {\n            setOpacity(cs, ink.getConstantOpacity());\n            cs.setStrokingColor(color);\n            if (ab.dashArray != null)\n            {\n                cs.setLineDashPattern(ab.dashArray, 0);\n            }\n            cs.setLineWidth(ab.width);\n            for (float[] pathArray : ink.getInkList())\n            {\n                int nPoints = pathArray.length \/ 2;\n               \n               \n                for (int i = 0; i < nPoints; ++i)\n                {\n                    float x = pathArray[i * 2];\n                    float y = pathArray[i * 2 + 1];\n                    if (i == 0)\n                    {\n                        cs.moveTo(x, y);\n                    }\n                    else\n                    {\n                        cs.lineTo(x, y);\n                    }\n                }\n                cs.stroke();\n            }\n        }\n        catch (IOException ex)\n        {\n            LOG.error(ex);\n        }\n    }","cleancode":"@override public void generatenormalappearance() { pdannotationink ink = (pdannotationink) getannotation(); pdcolor color = ink.getcolor(); if (color == null || color.getcomponents().length == 0) { return; } annotationborder ab = annotationborder.getannotationborder(ink, ink.getborderstyle()); if (float.compare(ab.width, 0) == 0) { return; } float minx = float.max_value; float miny = float.max_value; float maxx = float.min_value; float maxy = float.min_value; for (float[] patharray : ink.getinklist()) { int npoints = patharray.length \/ 2; for (int i = 0; i < npoints; ++i) { float x = patharray[i * 2]; float y = patharray[i * 2 + 1]; minx = math.min(minx, x); miny = math.min(miny, y); maxx = math.max(maxx, x); maxy = math.max(maxy, y); } } pdrectangle rect = ink.getrectangle(); rect.setlowerleftx(math.min(minx - ab.width * 2, rect.getlowerleftx())); rect.setlowerlefty(math.min(miny - ab.width * 2, rect.getlowerlefty())); rect.setupperrightx(math.max(maxx + ab.width * 2, rect.getupperrightx())); rect.setupperrighty(math.max(maxy + ab.width * 2, rect.getupperrighty())); ink.setrectangle(rect); try (pdappearancecontentstream cs = getnormalappearanceascontentstream()) { setopacity(cs, ink.getconstantopacity()); cs.setstrokingcolor(color); if (ab.dasharray != null) { cs.setlinedashpattern(ab.dasharray, 0); } cs.setlinewidth(ab.width); for (float[] patharray : ink.getinklist()) { int npoints = patharray.length \/ 2; for (int i = 0; i < npoints; ++i) { float x = patharray[i * 2]; float y = patharray[i * 2 + 1]; if (i == 0) { cs.moveto(x, y); } else { cs.lineto(x, y); } } cs.stroke(); } } catch (ioexception ex) { log.error(ex); } }","comment":"\/\/ pdf spec does not mention \/border for ink annotations, but it is used if \/bs is not available\n\/\/ adjust rectangle even if not empty \/\/ file from pdf.js issue 13447 \/\/todo in a class structure this should be overridable\n\/\/ \"when drawn, the points shall be connected by straight lines or curves \/\/ in an implementation-dependent way\" - we do lines.","repo":"steven-g\/pdfbox","code_context_2":"return;\n}\n\/\/ PDF spec does not mention \/Border for ink annotations, but it is used if \/BS is not available\nAnnotationBorder ab = AnnotationBorder.getAnnotationBorder(ink, ink.getBorderStyle());\nif (Float.compare(ab.width, 0) == 0)\n\nreturn;\n}\n\/\/ Adjust rectangle even if not empty\n\/\/ file from PDF.js issue 13447\n\/\/TODO in a class structure this should be overridable\nfloat minX = Float.MAX_VALUE;\nfloat minY = Float.MAX_VALUE;\n\n{\nint nPoints = pathArray.length \/ 2;\n\/\/ \"When drawn, the points shall be connected by straight lines or curves\n\/\/ in an implementation-dependent way\" - we do lines.\nfor (int i = 0; i < nPoints; ++i)\n{","code_context_10":"@Override\npublic void generateNormalAppearance()\n{\nPDAnnotationInk ink = (PDAnnotationInk) getAnnotation();\nPDColor color = ink.getColor();\nif (color == null || color.getComponents().length == 0)\n{\nreturn;\n}\n\/\/ PDF spec does not mention \/Border for ink annotations, but it is used if \/BS is not available\nAnnotationBorder ab = AnnotationBorder.getAnnotationBorder(ink, ink.getBorderStyle());\nif (Float.compare(ab.width, 0) == 0)\n{\nreturn;\n}\n\/\/ Adjust rectangle even if not empty\n\/\/ file from PDF.js issue 13447\n\/\/TODO in a class structure this should be overridable\nfloat minX = Float.MAX_VALUE;\nfloat minY = Float.MAX_VALUE;\n\nif (color == null || color.getComponents().length == 0)\n{\nreturn;\n}\n\/\/ PDF spec does not mention \/Border for ink annotations, but it is used if \/BS is not available\nAnnotationBorder ab = AnnotationBorder.getAnnotationBorder(ink, ink.getBorderStyle());\nif (Float.compare(ab.width, 0) == 0)\n{\nreturn;\n}\n\/\/ Adjust rectangle even if not empty\n\/\/ file from PDF.js issue 13447\n\/\/TODO in a class structure this should be overridable\nfloat minX = Float.MAX_VALUE;\nfloat minY = Float.MAX_VALUE;\nfloat maxX = Float.MIN_VALUE;\nfloat maxY = Float.MIN_VALUE;\nfor (float[] pathArray : ink.getInkList())\n{\nint nPoints = pathArray.length \/ 2;\nfor (int i = 0; i < nPoints; ++i)\n{\nfloat x = pathArray[i * 2];\n\nsetOpacity(cs, ink.getConstantOpacity());\ncs.setStrokingColor(color);\nif (ab.dashArray != null)\n{\ncs.setLineDashPattern(ab.dashArray, 0);\n}\ncs.setLineWidth(ab.width);\nfor (float[] pathArray : ink.getInkList())\n{\nint nPoints = pathArray.length \/ 2;\n\/\/ \"When drawn, the points shall be connected by straight lines or curves\n\/\/ in an implementation-dependent way\" - we do lines.\nfor (int i = 0; i < nPoints; ++i)\n{\nfloat x = pathArray[i * 2];\nfloat y = pathArray[i * 2 + 1];\nif (i == 0)\n{\ncs.moveTo(x, y);\n}\nelse\n{","code_context_20":"@Override\npublic void generateNormalAppearance()\n{\nPDAnnotationInk ink = (PDAnnotationInk) getAnnotation();\nPDColor color = ink.getColor();\nif (color == null || color.getComponents().length == 0)\n{\nreturn;\n}\n\/\/ PDF spec does not mention \/Border for ink annotations, but it is used if \/BS is not available\nAnnotationBorder ab = AnnotationBorder.getAnnotationBorder(ink, ink.getBorderStyle());\nif (Float.compare(ab.width, 0) == 0)\n{\nreturn;\n}\n\/\/ Adjust rectangle even if not empty\n\/\/ file from PDF.js issue 13447\n\/\/TODO in a class structure this should be overridable\nfloat minX = Float.MAX_VALUE;\nfloat minY = Float.MAX_VALUE;\nfloat maxX = Float.MIN_VALUE;\nfloat maxY = Float.MIN_VALUE;\nfor (float[] pathArray : ink.getInkList())\n{\nint nPoints = pathArray.length \/ 2;\nfor (int i = 0; i < nPoints; ++i)\n{\nfloat x = pathArray[i * 2];\nfloat y = pathArray[i * 2 + 1];\nminX = Math.min(minX, x);\n\n@Override\npublic void generateNormalAppearance()\n{\nPDAnnotationInk ink = (PDAnnotationInk) getAnnotation();\nPDColor color = ink.getColor();\nif (color == null || color.getComponents().length == 0)\n{\nreturn;\n}\n\/\/ PDF spec does not mention \/Border for ink annotations, but it is used if \/BS is not available\nAnnotationBorder ab = AnnotationBorder.getAnnotationBorder(ink, ink.getBorderStyle());\nif (Float.compare(ab.width, 0) == 0)\n{\nreturn;\n}\n\/\/ Adjust rectangle even if not empty\n\/\/ file from PDF.js issue 13447\n\/\/TODO in a class structure this should be overridable\nfloat minX = Float.MAX_VALUE;\nfloat minY = Float.MAX_VALUE;\nfloat maxX = Float.MIN_VALUE;\nfloat maxY = Float.MIN_VALUE;\nfor (float[] pathArray : ink.getInkList())\n{\nint nPoints = pathArray.length \/ 2;\nfor (int i = 0; i < nPoints; ++i)\n{\nfloat x = pathArray[i * 2];\nfloat y = pathArray[i * 2 + 1];\nminX = Math.min(minX, x);\nminY = Math.min(minY, y);\nmaxX = Math.max(maxX, x);\nmaxY = Math.max(maxY, y);\n}\n}\nPDRectangle rect = ink.getRectangle();\nrect.setLowerLeftX(Math.min(minX - ab.width * 2, rect.getLowerLeftX()));\nrect.setLowerLeftY(Math.min(minY - ab.width * 2, rect.getLowerLeftY()));\n\n}\n}\nPDRectangle rect = ink.getRectangle();\nrect.setLowerLeftX(Math.min(minX - ab.width * 2, rect.getLowerLeftX()));\nrect.setLowerLeftY(Math.min(minY - ab.width * 2, rect.getLowerLeftY()));\nrect.setUpperRightX(Math.max(maxX + ab.width * 2, rect.getUpperRightX()));\nrect.setUpperRightY(Math.max(maxY + ab.width * 2, rect.getUpperRightY()));\nink.setRectangle(rect);\ntry (PDAppearanceContentStream cs = getNormalAppearanceAsContentStream())\n{\nsetOpacity(cs, ink.getConstantOpacity());\ncs.setStrokingColor(color);\nif (ab.dashArray != null)\n{\ncs.setLineDashPattern(ab.dashArray, 0);\n}\ncs.setLineWidth(ab.width);\nfor (float[] pathArray : ink.getInkList())\n{\nint nPoints = pathArray.length \/ 2;\n\/\/ \"When drawn, the points shall be connected by straight lines or curves\n\/\/ in an implementation-dependent way\" - we do lines.\nfor (int i = 0; i < nPoints; ++i)\n{\nfloat x = pathArray[i * 2];\nfloat y = pathArray[i * 2 + 1];\nif (i == 0)\n{\ncs.moveTo(x, y);\n}\nelse\n{\ncs.lineTo(x, y);\n}\n}\ncs.stroke();\n}\n}\ncatch (IOException ex)\n{\nLOG.error(ex);\n}","label":[1,0,0,0]}
{"id":987,"original_code":"private OuterJoinPushDownResult processLimitedOuterJoin(RowExpression inheritedPredicate, RowExpression outerEffectivePredicate, RowExpression innerEffectivePredicate, RowExpression joinPredicate, Collection<VariableReferenceExpression> outerVariables)\n        {\n            checkArgument(Iterables.all(VariablesExtractor.extractUnique(outerEffectivePredicate), in(outerVariables)), \"outerEffectivePredicate must only contain variables from outerVariables\");\n            checkArgument(Iterables.all(VariablesExtractor.extractUnique(innerEffectivePredicate), not(in(outerVariables))), \"innerEffectivePredicate must not contain variables from outerVariables\");\n            ImmutableList.Builder<RowExpression> outerPushdownConjuncts = ImmutableList.builder();\n            ImmutableList.Builder<RowExpression> innerPushdownConjuncts = ImmutableList.builder();\n            ImmutableList.Builder<RowExpression> postJoinConjuncts = ImmutableList.builder();\n            ImmutableList.Builder<RowExpression> joinConjuncts = ImmutableList.builder();\n            \/\/ Strip out non-deterministic conjuncts\n            postJoinConjuncts.addAll(filter(extractConjuncts(inheritedPredicate), not(determinismEvaluator::isDeterministic)));\n            inheritedPredicate = logicalRowExpressions.filterDeterministicConjuncts(inheritedPredicate);\n            outerEffectivePredicate = logicalRowExpressions.filterDeterministicConjuncts(outerEffectivePredicate);\n            innerEffectivePredicate = logicalRowExpressions.filterDeterministicConjuncts(innerEffectivePredicate);\n            joinConjuncts.addAll(filter(extractConjuncts(joinPredicate), not(determinismEvaluator::isDeterministic)));\n            joinPredicate = logicalRowExpressions.filterDeterministicConjuncts(joinPredicate);\n            \/\/ Generate equality inferences\n            EqualityInference inheritedInference = createEqualityInference(inheritedPredicate);\n            EqualityInference outerInference = createEqualityInference(inheritedPredicate, outerEffectivePredicate);\n            EqualityInference.EqualityPartition equalityPartition = inheritedInference.generateEqualitiesPartitionedBy(in(outerVariables));\n            RowExpression outerOnlyInheritedEqualities = logicalRowExpressions.combineConjuncts(equalityPartition.getScopeEqualities());\n            EqualityInference potentialNullSymbolInference = createEqualityInference(outerOnlyInheritedEqualities, outerEffectivePredicate, innerEffectivePredicate, joinPredicate);\n            \/\/ See if we can push inherited predicates down\n            for (RowExpression conjunct : nonInferableConjuncts(inheritedPredicate)) {\n                RowExpression outerRewritten = outerInference.rewriteExpression(conjunct, in(outerVariables));\n                if (outerRewritten != null) {\n                    outerPushdownConjuncts.add(outerRewritten);\n                    \/\/ A conjunct can only be pushed down into an inner side if it can be rewritten in terms of the outer side\n                    RowExpression innerRewritten = potentialNullSymbolInference.rewriteExpression(outerRewritten, not(in(outerVariables)));\n                    if (innerRewritten != null) {\n                        innerPushdownConjuncts.add(innerRewritten);\n                    }\n                }\n                else {\n                    postJoinConjuncts.add(conjunct);\n                }\n            }\n            \/\/ Add the equalities from the inferences back in\n            outerPushdownConjuncts.addAll(equalityPartition.getScopeEqualities());\n            postJoinConjuncts.addAll(equalityPartition.getScopeComplementEqualities());\n            postJoinConjuncts.addAll(equalityPartition.getScopeStraddlingEqualities());\n            \/\/ See if we can push down any outer effective predicates to the inner side\n            for (RowExpression conjunct : nonInferableConjuncts(outerEffectivePredicate)) {\n                RowExpression rewritten = potentialNullSymbolInference.rewriteExpression(conjunct, not(in(outerVariables)));\n                if (rewritten != null) {\n                    innerPushdownConjuncts.add(rewritten);\n                }\n            }\n            \/\/ See if we can push down join predicates to the inner side\n            for (RowExpression conjunct : nonInferableConjuncts(joinPredicate)) {\n                RowExpression innerRewritten = potentialNullSymbolInference.rewriteExpression(conjunct, not(in(outerVariables)));\n                if (innerRewritten != null) {\n                    innerPushdownConjuncts.add(innerRewritten);\n                }\n                else {\n                    joinConjuncts.add(conjunct);\n                }\n            }\n            \/\/ Push outer and join equalities into the inner side. For example:\n            \/\/ SELECT * FROM nation LEFT OUTER JOIN region ON nation.regionkey = region.regionkey and nation.name = region.name WHERE nation.name = 'blah'\n            EqualityInference potentialNullSymbolInferenceWithoutInnerInferred = createEqualityInference(outerOnlyInheritedEqualities, outerEffectivePredicate, joinPredicate);\n            innerPushdownConjuncts.addAll(potentialNullSymbolInferenceWithoutInnerInferred.generateEqualitiesPartitionedBy(not(in(outerVariables))).getScopeEqualities());\n            \/\/ TODO: we can further improve simplifying the equalities by considering other relationships from the outer side\n            EqualityInference.EqualityPartition joinEqualityPartition = createEqualityInference(joinPredicate).generateEqualitiesPartitionedBy(not(in(outerVariables)));\n            innerPushdownConjuncts.addAll(joinEqualityPartition.getScopeEqualities());\n            joinConjuncts.addAll(joinEqualityPartition.getScopeComplementEqualities())\n                    .addAll(joinEqualityPartition.getScopeStraddlingEqualities());\n            return new OuterJoinPushDownResult(logicalRowExpressions.combineConjuncts(outerPushdownConjuncts.build()),\n                    logicalRowExpressions.combineConjuncts(innerPushdownConjuncts.build()),\n                    logicalRowExpressions.combineConjuncts(joinConjuncts.build()),\n                    logicalRowExpressions.combineConjuncts(postJoinConjuncts.build()));\n        }","code":"private OuterJoinPushDownResult processLimitedOuterJoin(RowExpression inheritedPredicate, RowExpression outerEffectivePredicate, RowExpression innerEffectivePredicate, RowExpression joinPredicate, Collection<VariableReferenceExpression> outerVariables)\n        {\n            checkArgument(Iterables.all(VariablesExtractor.extractUnique(outerEffectivePredicate), in(outerVariables)), \"outerEffectivePredicate must only contain variables from outerVariables\");\n            checkArgument(Iterables.all(VariablesExtractor.extractUnique(innerEffectivePredicate), not(in(outerVariables))), \"innerEffectivePredicate must not contain variables from outerVariables\");\n            ImmutableList.Builder<RowExpression> outerPushdownConjuncts = ImmutableList.builder();\n            ImmutableList.Builder<RowExpression> innerPushdownConjuncts = ImmutableList.builder();\n            ImmutableList.Builder<RowExpression> postJoinConjuncts = ImmutableList.builder();\n            ImmutableList.Builder<RowExpression> joinConjuncts = ImmutableList.builder();\n           \n            postJoinConjuncts.addAll(filter(extractConjuncts(inheritedPredicate), not(determinismEvaluator::isDeterministic)));\n            inheritedPredicate = logicalRowExpressions.filterDeterministicConjuncts(inheritedPredicate);\n            outerEffectivePredicate = logicalRowExpressions.filterDeterministicConjuncts(outerEffectivePredicate);\n            innerEffectivePredicate = logicalRowExpressions.filterDeterministicConjuncts(innerEffectivePredicate);\n            joinConjuncts.addAll(filter(extractConjuncts(joinPredicate), not(determinismEvaluator::isDeterministic)));\n            joinPredicate = logicalRowExpressions.filterDeterministicConjuncts(joinPredicate);\n           \n            EqualityInference inheritedInference = createEqualityInference(inheritedPredicate);\n            EqualityInference outerInference = createEqualityInference(inheritedPredicate, outerEffectivePredicate);\n            EqualityInference.EqualityPartition equalityPartition = inheritedInference.generateEqualitiesPartitionedBy(in(outerVariables));\n            RowExpression outerOnlyInheritedEqualities = logicalRowExpressions.combineConjuncts(equalityPartition.getScopeEqualities());\n            EqualityInference potentialNullSymbolInference = createEqualityInference(outerOnlyInheritedEqualities, outerEffectivePredicate, innerEffectivePredicate, joinPredicate);\n           \n            for (RowExpression conjunct : nonInferableConjuncts(inheritedPredicate)) {\n                RowExpression outerRewritten = outerInference.rewriteExpression(conjunct, in(outerVariables));\n                if (outerRewritten != null) {\n                    outerPushdownConjuncts.add(outerRewritten);\n                   \n                    RowExpression innerRewritten = potentialNullSymbolInference.rewriteExpression(outerRewritten, not(in(outerVariables)));\n                    if (innerRewritten != null) {\n                        innerPushdownConjuncts.add(innerRewritten);\n                    }\n                }\n                else {\n                    postJoinConjuncts.add(conjunct);\n                }\n            }\n           \n            outerPushdownConjuncts.addAll(equalityPartition.getScopeEqualities());\n            postJoinConjuncts.addAll(equalityPartition.getScopeComplementEqualities());\n            postJoinConjuncts.addAll(equalityPartition.getScopeStraddlingEqualities());\n           \n            for (RowExpression conjunct : nonInferableConjuncts(outerEffectivePredicate)) {\n                RowExpression rewritten = potentialNullSymbolInference.rewriteExpression(conjunct, not(in(outerVariables)));\n                if (rewritten != null) {\n                    innerPushdownConjuncts.add(rewritten);\n                }\n            }\n           \n            for (RowExpression conjunct : nonInferableConjuncts(joinPredicate)) {\n                RowExpression innerRewritten = potentialNullSymbolInference.rewriteExpression(conjunct, not(in(outerVariables)));\n                if (innerRewritten != null) {\n                    innerPushdownConjuncts.add(innerRewritten);\n                }\n                else {\n                    joinConjuncts.add(conjunct);\n                }\n            }\n           \n           \n            EqualityInference potentialNullSymbolInferenceWithoutInnerInferred = createEqualityInference(outerOnlyInheritedEqualities, outerEffectivePredicate, joinPredicate);\n            innerPushdownConjuncts.addAll(potentialNullSymbolInferenceWithoutInnerInferred.generateEqualitiesPartitionedBy(not(in(outerVariables))).getScopeEqualities());\n           \n            EqualityInference.EqualityPartition joinEqualityPartition = createEqualityInference(joinPredicate).generateEqualitiesPartitionedBy(not(in(outerVariables)));\n            innerPushdownConjuncts.addAll(joinEqualityPartition.getScopeEqualities());\n            joinConjuncts.addAll(joinEqualityPartition.getScopeComplementEqualities())\n                    .addAll(joinEqualityPartition.getScopeStraddlingEqualities());\n            return new OuterJoinPushDownResult(logicalRowExpressions.combineConjuncts(outerPushdownConjuncts.build()),\n                    logicalRowExpressions.combineConjuncts(innerPushdownConjuncts.build()),\n                    logicalRowExpressions.combineConjuncts(joinConjuncts.build()),\n                    logicalRowExpressions.combineConjuncts(postJoinConjuncts.build()));\n        }","cleancode":"private outerjoinpushdownresult processlimitedouterjoin(rowexpression inheritedpredicate, rowexpression outereffectivepredicate, rowexpression innereffectivepredicate, rowexpression joinpredicate, collection<variablereferenceexpression> outervariables) { checkargument(iterables.all(variablesextractor.extractunique(outereffectivepredicate), in(outervariables)), \"outereffectivepredicate must only contain variables from outervariables\"); checkargument(iterables.all(variablesextractor.extractunique(innereffectivepredicate), not(in(outervariables))), \"innereffectivepredicate must not contain variables from outervariables\"); immutablelist.builder<rowexpression> outerpushdownconjuncts = immutablelist.builder(); immutablelist.builder<rowexpression> innerpushdownconjuncts = immutablelist.builder(); immutablelist.builder<rowexpression> postjoinconjuncts = immutablelist.builder(); immutablelist.builder<rowexpression> joinconjuncts = immutablelist.builder(); postjoinconjuncts.addall(filter(extractconjuncts(inheritedpredicate), not(determinismevaluator::isdeterministic))); inheritedpredicate = logicalrowexpressions.filterdeterministicconjuncts(inheritedpredicate); outereffectivepredicate = logicalrowexpressions.filterdeterministicconjuncts(outereffectivepredicate); innereffectivepredicate = logicalrowexpressions.filterdeterministicconjuncts(innereffectivepredicate); joinconjuncts.addall(filter(extractconjuncts(joinpredicate), not(determinismevaluator::isdeterministic))); joinpredicate = logicalrowexpressions.filterdeterministicconjuncts(joinpredicate); equalityinference inheritedinference = createequalityinference(inheritedpredicate); equalityinference outerinference = createequalityinference(inheritedpredicate, outereffectivepredicate); equalityinference.equalitypartition equalitypartition = inheritedinference.generateequalitiespartitionedby(in(outervariables)); rowexpression outeronlyinheritedequalities = logicalrowexpressions.combineconjuncts(equalitypartition.getscopeequalities()); equalityinference potentialnullsymbolinference = createequalityinference(outeronlyinheritedequalities, outereffectivepredicate, innereffectivepredicate, joinpredicate); for (rowexpression conjunct : noninferableconjuncts(inheritedpredicate)) { rowexpression outerrewritten = outerinference.rewriteexpression(conjunct, in(outervariables)); if (outerrewritten != null) { outerpushdownconjuncts.add(outerrewritten); rowexpression innerrewritten = potentialnullsymbolinference.rewriteexpression(outerrewritten, not(in(outervariables))); if (innerrewritten != null) { innerpushdownconjuncts.add(innerrewritten); } } else { postjoinconjuncts.add(conjunct); } } outerpushdownconjuncts.addall(equalitypartition.getscopeequalities()); postjoinconjuncts.addall(equalitypartition.getscopecomplementequalities()); postjoinconjuncts.addall(equalitypartition.getscopestraddlingequalities()); for (rowexpression conjunct : noninferableconjuncts(outereffectivepredicate)) { rowexpression rewritten = potentialnullsymbolinference.rewriteexpression(conjunct, not(in(outervariables))); if (rewritten != null) { innerpushdownconjuncts.add(rewritten); } } for (rowexpression conjunct : noninferableconjuncts(joinpredicate)) { rowexpression innerrewritten = potentialnullsymbolinference.rewriteexpression(conjunct, not(in(outervariables))); if (innerrewritten != null) { innerpushdownconjuncts.add(innerrewritten); } else { joinconjuncts.add(conjunct); } } equalityinference potentialnullsymbolinferencewithoutinnerinferred = createequalityinference(outeronlyinheritedequalities, outereffectivepredicate, joinpredicate); innerpushdownconjuncts.addall(potentialnullsymbolinferencewithoutinnerinferred.generateequalitiespartitionedby(not(in(outervariables))).getscopeequalities()); equalityinference.equalitypartition joinequalitypartition = createequalityinference(joinpredicate).generateequalitiespartitionedby(not(in(outervariables))); innerpushdownconjuncts.addall(joinequalitypartition.getscopeequalities()); joinconjuncts.addall(joinequalitypartition.getscopecomplementequalities()) .addall(joinequalitypartition.getscopestraddlingequalities()); return new outerjoinpushdownresult(logicalrowexpressions.combineconjuncts(outerpushdownconjuncts.build()), logicalrowexpressions.combineconjuncts(innerpushdownconjuncts.build()), logicalrowexpressions.combineconjuncts(joinconjuncts.build()), logicalrowexpressions.combineconjuncts(postjoinconjuncts.build())); }","comment":"\/\/ strip out non-deterministic conjuncts\n\/\/ generate equality inferences\n\/\/ see if we can push inherited predicates down\n\/\/ a conjunct can only be pushed down into an inner side if it can be rewritten in terms of the outer side\n\/\/ add the equalities from the inferences back in\n\/\/ see if we can push down any outer effective predicates to the inner side\n\/\/ see if we can push down join predicates to the inner side\n\/\/ push outer and join equalities into the inner side. for example: \/\/ select * from nation left outer join region on nation.regionkey = region.regionkey and nation.name = region.name where nation.name = 'blah'\n\/\/ todo: we can further improve simplifying the equalities by considering other relationships from the outer side","repo":"shrinidhijoshi\/presto","code_context_2":"ImmutableList.Builder<RowExpression> postJoinConjuncts = ImmutableList.builder();\nImmutableList.Builder<RowExpression> joinConjuncts = ImmutableList.builder();\n\/\/ Strip out non-deterministic conjuncts\npostJoinConjuncts.addAll(filter(extractConjuncts(inheritedPredicate), not(determinismEvaluator::isDeterministic)));\ninheritedPredicate = logicalRowExpressions.filterDeterministicConjuncts(inheritedPredicate);\n\njoinConjuncts.addAll(filter(extractConjuncts(joinPredicate), not(determinismEvaluator::isDeterministic)));\njoinPredicate = logicalRowExpressions.filterDeterministicConjuncts(joinPredicate);\n\/\/ Generate equality inferences\nEqualityInference inheritedInference = createEqualityInference(inheritedPredicate);\nEqualityInference outerInference = createEqualityInference(inheritedPredicate, outerEffectivePredicate);\n\nRowExpression outerOnlyInheritedEqualities = logicalRowExpressions.combineConjuncts(equalityPartition.getScopeEqualities());\nEqualityInference potentialNullSymbolInference = createEqualityInference(outerOnlyInheritedEqualities, outerEffectivePredicate, innerEffectivePredicate, joinPredicate);\n\/\/ See if we can push inherited predicates down\nfor (RowExpression conjunct : nonInferableConjuncts(inheritedPredicate)) {\nRowExpression outerRewritten = outerInference.rewriteExpression(conjunct, in(outerVariables));\n\nif (outerRewritten != null) {\nouterPushdownConjuncts.add(outerRewritten);\n\/\/ A conjunct can only be pushed down into an inner side if it can be rewritten in terms of the outer side\nRowExpression innerRewritten = potentialNullSymbolInference.rewriteExpression(outerRewritten, not(in(outerVariables)));\nif (innerRewritten != null) {\n\n}\n}\n\/\/ Add the equalities from the inferences back in\nouterPushdownConjuncts.addAll(equalityPartition.getScopeEqualities());\npostJoinConjuncts.addAll(equalityPartition.getScopeComplementEqualities());\n\npostJoinConjuncts.addAll(equalityPartition.getScopeComplementEqualities());\npostJoinConjuncts.addAll(equalityPartition.getScopeStraddlingEqualities());\n\/\/ See if we can push down any outer effective predicates to the inner side\nfor (RowExpression conjunct : nonInferableConjuncts(outerEffectivePredicate)) {\nRowExpression rewritten = potentialNullSymbolInference.rewriteExpression(conjunct, not(in(outerVariables)));\n\n}\n}\n\/\/ See if we can push down join predicates to the inner side\nfor (RowExpression conjunct : nonInferableConjuncts(joinPredicate)) {\nRowExpression innerRewritten = potentialNullSymbolInference.rewriteExpression(conjunct, not(in(outerVariables)));\n\n}\n}\n\/\/ Push outer and join equalities into the inner side. For example:\n\/\/ SELECT * FROM nation LEFT OUTER JOIN region ON nation.regionkey = region.regionkey and nation.name = region.name WHERE nation.name = 'blah'\nEqualityInference potentialNullSymbolInferenceWithoutInnerInferred = createEqualityInference(outerOnlyInheritedEqualities, outerEffectivePredicate, joinPredicate);\ninnerPushdownConjuncts.addAll(potentialNullSymbolInferenceWithoutInnerInferred.generateEqualitiesPartitionedBy(not(in(outerVariables))).getScopeEqualities());\n\nEqualityInference potentialNullSymbolInferenceWithoutInnerInferred = createEqualityInference(outerOnlyInheritedEqualities, outerEffectivePredicate, joinPredicate);\ninnerPushdownConjuncts.addAll(potentialNullSymbolInferenceWithoutInnerInferred.generateEqualitiesPartitionedBy(not(in(outerVariables))).getScopeEqualities());\n\/\/ TODO: we can further improve simplifying the equalities by considering other relationships from the outer side\nEqualityInference.EqualityPartition joinEqualityPartition = createEqualityInference(joinPredicate).generateEqualitiesPartitionedBy(not(in(outerVariables)));\ninnerPushdownConjuncts.addAll(joinEqualityPartition.getScopeEqualities());","code_context_10":"private OuterJoinPushDownResult processLimitedOuterJoin(RowExpression inheritedPredicate, RowExpression outerEffectivePredicate, RowExpression innerEffectivePredicate, RowExpression joinPredicate, Collection<VariableReferenceExpression> outerVariables)\n{\ncheckArgument(Iterables.all(VariablesExtractor.extractUnique(outerEffectivePredicate), in(outerVariables)), \"outerEffectivePredicate must only contain variables from outerVariables\");\ncheckArgument(Iterables.all(VariablesExtractor.extractUnique(innerEffectivePredicate), not(in(outerVariables))), \"innerEffectivePredicate must not contain variables from outerVariables\");\nImmutableList.Builder<RowExpression> outerPushdownConjuncts = ImmutableList.builder();\nImmutableList.Builder<RowExpression> innerPushdownConjuncts = ImmutableList.builder();\nImmutableList.Builder<RowExpression> postJoinConjuncts = ImmutableList.builder();\nImmutableList.Builder<RowExpression> joinConjuncts = ImmutableList.builder();\n\/\/ Strip out non-deterministic conjuncts\npostJoinConjuncts.addAll(filter(extractConjuncts(inheritedPredicate), not(determinismEvaluator::isDeterministic)));\ninheritedPredicate = logicalRowExpressions.filterDeterministicConjuncts(inheritedPredicate);\nouterEffectivePredicate = logicalRowExpressions.filterDeterministicConjuncts(outerEffectivePredicate);\ninnerEffectivePredicate = logicalRowExpressions.filterDeterministicConjuncts(innerEffectivePredicate);\njoinConjuncts.addAll(filter(extractConjuncts(joinPredicate), not(determinismEvaluator::isDeterministic)));\njoinPredicate = logicalRowExpressions.filterDeterministicConjuncts(joinPredicate);\n\/\/ Generate equality inferences\nEqualityInference inheritedInference = createEqualityInference(inheritedPredicate);\nEqualityInference outerInference = createEqualityInference(inheritedPredicate, outerEffectivePredicate);\nEqualityInference.EqualityPartition equalityPartition = inheritedInference.generateEqualitiesPartitionedBy(in(outerVariables));\n\nImmutableList.Builder<RowExpression> innerPushdownConjuncts = ImmutableList.builder();\nImmutableList.Builder<RowExpression> postJoinConjuncts = ImmutableList.builder();\nImmutableList.Builder<RowExpression> joinConjuncts = ImmutableList.builder();\n\/\/ Strip out non-deterministic conjuncts\npostJoinConjuncts.addAll(filter(extractConjuncts(inheritedPredicate), not(determinismEvaluator::isDeterministic)));\ninheritedPredicate = logicalRowExpressions.filterDeterministicConjuncts(inheritedPredicate);\nouterEffectivePredicate = logicalRowExpressions.filterDeterministicConjuncts(outerEffectivePredicate);\ninnerEffectivePredicate = logicalRowExpressions.filterDeterministicConjuncts(innerEffectivePredicate);\njoinConjuncts.addAll(filter(extractConjuncts(joinPredicate), not(determinismEvaluator::isDeterministic)));\njoinPredicate = logicalRowExpressions.filterDeterministicConjuncts(joinPredicate);\n\/\/ Generate equality inferences\nEqualityInference inheritedInference = createEqualityInference(inheritedPredicate);\nEqualityInference outerInference = createEqualityInference(inheritedPredicate, outerEffectivePredicate);\nEqualityInference.EqualityPartition equalityPartition = inheritedInference.generateEqualitiesPartitionedBy(in(outerVariables));\nRowExpression outerOnlyInheritedEqualities = logicalRowExpressions.combineConjuncts(equalityPartition.getScopeEqualities());\nEqualityInference potentialNullSymbolInference = createEqualityInference(outerOnlyInheritedEqualities, outerEffectivePredicate, innerEffectivePredicate, joinPredicate);\n\/\/ See if we can push inherited predicates down\nfor (RowExpression conjunct : nonInferableConjuncts(inheritedPredicate)) {\nRowExpression outerRewritten = outerInference.rewriteExpression(conjunct, in(outerVariables));\nif (outerRewritten != null) {\nouterPushdownConjuncts.add(outerRewritten);\n\nouterEffectivePredicate = logicalRowExpressions.filterDeterministicConjuncts(outerEffectivePredicate);\ninnerEffectivePredicate = logicalRowExpressions.filterDeterministicConjuncts(innerEffectivePredicate);\njoinConjuncts.addAll(filter(extractConjuncts(joinPredicate), not(determinismEvaluator::isDeterministic)));\njoinPredicate = logicalRowExpressions.filterDeterministicConjuncts(joinPredicate);\n\/\/ Generate equality inferences\nEqualityInference inheritedInference = createEqualityInference(inheritedPredicate);\nEqualityInference outerInference = createEqualityInference(inheritedPredicate, outerEffectivePredicate);\nEqualityInference.EqualityPartition equalityPartition = inheritedInference.generateEqualitiesPartitionedBy(in(outerVariables));\nRowExpression outerOnlyInheritedEqualities = logicalRowExpressions.combineConjuncts(equalityPartition.getScopeEqualities());\nEqualityInference potentialNullSymbolInference = createEqualityInference(outerOnlyInheritedEqualities, outerEffectivePredicate, innerEffectivePredicate, joinPredicate);\n\/\/ See if we can push inherited predicates down\nfor (RowExpression conjunct : nonInferableConjuncts(inheritedPredicate)) {\nRowExpression outerRewritten = outerInference.rewriteExpression(conjunct, in(outerVariables));\nif (outerRewritten != null) {\nouterPushdownConjuncts.add(outerRewritten);\n\/\/ A conjunct can only be pushed down into an inner side if it can be rewritten in terms of the outer side\nRowExpression innerRewritten = potentialNullSymbolInference.rewriteExpression(outerRewritten, not(in(outerVariables)));\nif (innerRewritten != null) {\ninnerPushdownConjuncts.add(innerRewritten);\n}\n}\n\nEqualityInference inheritedInference = createEqualityInference(inheritedPredicate);\nEqualityInference outerInference = createEqualityInference(inheritedPredicate, outerEffectivePredicate);\nEqualityInference.EqualityPartition equalityPartition = inheritedInference.generateEqualitiesPartitionedBy(in(outerVariables));\nRowExpression outerOnlyInheritedEqualities = logicalRowExpressions.combineConjuncts(equalityPartition.getScopeEqualities());\nEqualityInference potentialNullSymbolInference = createEqualityInference(outerOnlyInheritedEqualities, outerEffectivePredicate, innerEffectivePredicate, joinPredicate);\n\/\/ See if we can push inherited predicates down\nfor (RowExpression conjunct : nonInferableConjuncts(inheritedPredicate)) {\nRowExpression outerRewritten = outerInference.rewriteExpression(conjunct, in(outerVariables));\nif (outerRewritten != null) {\nouterPushdownConjuncts.add(outerRewritten);\n\/\/ A conjunct can only be pushed down into an inner side if it can be rewritten in terms of the outer side\nRowExpression innerRewritten = potentialNullSymbolInference.rewriteExpression(outerRewritten, not(in(outerVariables)));\nif (innerRewritten != null) {\ninnerPushdownConjuncts.add(innerRewritten);\n}\n}\nelse {\npostJoinConjuncts.add(conjunct);\n}\n}\n\/\/ Add the equalities from the inferences back in\n\n\/\/ A conjunct can only be pushed down into an inner side if it can be rewritten in terms of the outer side\nRowExpression innerRewritten = potentialNullSymbolInference.rewriteExpression(outerRewritten, not(in(outerVariables)));\nif (innerRewritten != null) {\ninnerPushdownConjuncts.add(innerRewritten);\n}\n}\nelse {\npostJoinConjuncts.add(conjunct);\n}\n}\n\/\/ Add the equalities from the inferences back in\nouterPushdownConjuncts.addAll(equalityPartition.getScopeEqualities());\npostJoinConjuncts.addAll(equalityPartition.getScopeComplementEqualities());\npostJoinConjuncts.addAll(equalityPartition.getScopeStraddlingEqualities());\n\/\/ See if we can push down any outer effective predicates to the inner side\nfor (RowExpression conjunct : nonInferableConjuncts(outerEffectivePredicate)) {\nRowExpression rewritten = potentialNullSymbolInference.rewriteExpression(conjunct, not(in(outerVariables)));\nif (rewritten != null) {\ninnerPushdownConjuncts.add(rewritten);\n}\n}\n\n}\n}\nelse {\npostJoinConjuncts.add(conjunct);\n}\n}\n\/\/ Add the equalities from the inferences back in\nouterPushdownConjuncts.addAll(equalityPartition.getScopeEqualities());\npostJoinConjuncts.addAll(equalityPartition.getScopeComplementEqualities());\npostJoinConjuncts.addAll(equalityPartition.getScopeStraddlingEqualities());\n\/\/ See if we can push down any outer effective predicates to the inner side\nfor (RowExpression conjunct : nonInferableConjuncts(outerEffectivePredicate)) {\nRowExpression rewritten = potentialNullSymbolInference.rewriteExpression(conjunct, not(in(outerVariables)));\nif (rewritten != null) {\ninnerPushdownConjuncts.add(rewritten);\n}\n}\n\/\/ See if we can push down join predicates to the inner side\nfor (RowExpression conjunct : nonInferableConjuncts(joinPredicate)) {\nRowExpression innerRewritten = potentialNullSymbolInference.rewriteExpression(conjunct, not(in(outerVariables)));\nif (innerRewritten != null) {\n\nouterPushdownConjuncts.addAll(equalityPartition.getScopeEqualities());\npostJoinConjuncts.addAll(equalityPartition.getScopeComplementEqualities());\npostJoinConjuncts.addAll(equalityPartition.getScopeStraddlingEqualities());\n\/\/ See if we can push down any outer effective predicates to the inner side\nfor (RowExpression conjunct : nonInferableConjuncts(outerEffectivePredicate)) {\nRowExpression rewritten = potentialNullSymbolInference.rewriteExpression(conjunct, not(in(outerVariables)));\nif (rewritten != null) {\ninnerPushdownConjuncts.add(rewritten);\n}\n}\n\/\/ See if we can push down join predicates to the inner side\nfor (RowExpression conjunct : nonInferableConjuncts(joinPredicate)) {\nRowExpression innerRewritten = potentialNullSymbolInference.rewriteExpression(conjunct, not(in(outerVariables)));\nif (innerRewritten != null) {\ninnerPushdownConjuncts.add(innerRewritten);\n}\nelse {\njoinConjuncts.add(conjunct);\n}\n}\n\/\/ Push outer and join equalities into the inner side. For example:\n\n\/\/ See if we can push down join predicates to the inner side\nfor (RowExpression conjunct : nonInferableConjuncts(joinPredicate)) {\nRowExpression innerRewritten = potentialNullSymbolInference.rewriteExpression(conjunct, not(in(outerVariables)));\nif (innerRewritten != null) {\ninnerPushdownConjuncts.add(innerRewritten);\n}\nelse {\njoinConjuncts.add(conjunct);\n}\n}\n\/\/ Push outer and join equalities into the inner side. For example:\n\/\/ SELECT * FROM nation LEFT OUTER JOIN region ON nation.regionkey = region.regionkey and nation.name = region.name WHERE nation.name = 'blah'\nEqualityInference potentialNullSymbolInferenceWithoutInnerInferred = createEqualityInference(outerOnlyInheritedEqualities, outerEffectivePredicate, joinPredicate);\ninnerPushdownConjuncts.addAll(potentialNullSymbolInferenceWithoutInnerInferred.generateEqualitiesPartitionedBy(not(in(outerVariables))).getScopeEqualities());\n\/\/ TODO: we can further improve simplifying the equalities by considering other relationships from the outer side\nEqualityInference.EqualityPartition joinEqualityPartition = createEqualityInference(joinPredicate).generateEqualitiesPartitionedBy(not(in(outerVariables)));\ninnerPushdownConjuncts.addAll(joinEqualityPartition.getScopeEqualities());\njoinConjuncts.addAll(joinEqualityPartition.getScopeComplementEqualities())\n.addAll(joinEqualityPartition.getScopeStraddlingEqualities());\nreturn new OuterJoinPushDownResult(logicalRowExpressions.combineConjuncts(outerPushdownConjuncts.build()),\nlogicalRowExpressions.combineConjuncts(innerPushdownConjuncts.build()),\nlogicalRowExpressions.combineConjuncts(joinConjuncts.build()),\n\ninnerPushdownConjuncts.add(innerRewritten);\n}\nelse {\njoinConjuncts.add(conjunct);\n}\n}\n\/\/ Push outer and join equalities into the inner side. For example:\n\/\/ SELECT * FROM nation LEFT OUTER JOIN region ON nation.regionkey = region.regionkey and nation.name = region.name WHERE nation.name = 'blah'\nEqualityInference potentialNullSymbolInferenceWithoutInnerInferred = createEqualityInference(outerOnlyInheritedEqualities, outerEffectivePredicate, joinPredicate);\ninnerPushdownConjuncts.addAll(potentialNullSymbolInferenceWithoutInnerInferred.generateEqualitiesPartitionedBy(not(in(outerVariables))).getScopeEqualities());\n\/\/ TODO: we can further improve simplifying the equalities by considering other relationships from the outer side\nEqualityInference.EqualityPartition joinEqualityPartition = createEqualityInference(joinPredicate).generateEqualitiesPartitionedBy(not(in(outerVariables)));\ninnerPushdownConjuncts.addAll(joinEqualityPartition.getScopeEqualities());\njoinConjuncts.addAll(joinEqualityPartition.getScopeComplementEqualities())\n.addAll(joinEqualityPartition.getScopeStraddlingEqualities());\nreturn new OuterJoinPushDownResult(logicalRowExpressions.combineConjuncts(outerPushdownConjuncts.build()),\nlogicalRowExpressions.combineConjuncts(innerPushdownConjuncts.build()),\nlogicalRowExpressions.combineConjuncts(joinConjuncts.build()),\nlogicalRowExpressions.combineConjuncts(postJoinConjuncts.build()));\n}","code_context_20":"private OuterJoinPushDownResult processLimitedOuterJoin(RowExpression inheritedPredicate, RowExpression outerEffectivePredicate, RowExpression innerEffectivePredicate, RowExpression joinPredicate, Collection<VariableReferenceExpression> outerVariables)\n{\ncheckArgument(Iterables.all(VariablesExtractor.extractUnique(outerEffectivePredicate), in(outerVariables)), \"outerEffectivePredicate must only contain variables from outerVariables\");\ncheckArgument(Iterables.all(VariablesExtractor.extractUnique(innerEffectivePredicate), not(in(outerVariables))), \"innerEffectivePredicate must not contain variables from outerVariables\");\nImmutableList.Builder<RowExpression> outerPushdownConjuncts = ImmutableList.builder();\nImmutableList.Builder<RowExpression> innerPushdownConjuncts = ImmutableList.builder();\nImmutableList.Builder<RowExpression> postJoinConjuncts = ImmutableList.builder();\nImmutableList.Builder<RowExpression> joinConjuncts = ImmutableList.builder();\n\/\/ Strip out non-deterministic conjuncts\npostJoinConjuncts.addAll(filter(extractConjuncts(inheritedPredicate), not(determinismEvaluator::isDeterministic)));\ninheritedPredicate = logicalRowExpressions.filterDeterministicConjuncts(inheritedPredicate);\nouterEffectivePredicate = logicalRowExpressions.filterDeterministicConjuncts(outerEffectivePredicate);\ninnerEffectivePredicate = logicalRowExpressions.filterDeterministicConjuncts(innerEffectivePredicate);\njoinConjuncts.addAll(filter(extractConjuncts(joinPredicate), not(determinismEvaluator::isDeterministic)));\njoinPredicate = logicalRowExpressions.filterDeterministicConjuncts(joinPredicate);\n\/\/ Generate equality inferences\nEqualityInference inheritedInference = createEqualityInference(inheritedPredicate);\nEqualityInference outerInference = createEqualityInference(inheritedPredicate, outerEffectivePredicate);\nEqualityInference.EqualityPartition equalityPartition = inheritedInference.generateEqualitiesPartitionedBy(in(outerVariables));\nRowExpression outerOnlyInheritedEqualities = logicalRowExpressions.combineConjuncts(equalityPartition.getScopeEqualities());\nEqualityInference potentialNullSymbolInference = createEqualityInference(outerOnlyInheritedEqualities, outerEffectivePredicate, innerEffectivePredicate, joinPredicate);\n\/\/ See if we can push inherited predicates down\nfor (RowExpression conjunct : nonInferableConjuncts(inheritedPredicate)) {\nRowExpression outerRewritten = outerInference.rewriteExpression(conjunct, in(outerVariables));\nif (outerRewritten != null) {\nouterPushdownConjuncts.add(outerRewritten);\n\/\/ A conjunct can only be pushed down into an inner side if it can be rewritten in terms of the outer side\nRowExpression innerRewritten = potentialNullSymbolInference.rewriteExpression(outerRewritten, not(in(outerVariables)));\nif (innerRewritten != null) {\n\nprivate OuterJoinPushDownResult processLimitedOuterJoin(RowExpression inheritedPredicate, RowExpression outerEffectivePredicate, RowExpression innerEffectivePredicate, RowExpression joinPredicate, Collection<VariableReferenceExpression> outerVariables)\n{\ncheckArgument(Iterables.all(VariablesExtractor.extractUnique(outerEffectivePredicate), in(outerVariables)), \"outerEffectivePredicate must only contain variables from outerVariables\");\ncheckArgument(Iterables.all(VariablesExtractor.extractUnique(innerEffectivePredicate), not(in(outerVariables))), \"innerEffectivePredicate must not contain variables from outerVariables\");\nImmutableList.Builder<RowExpression> outerPushdownConjuncts = ImmutableList.builder();\nImmutableList.Builder<RowExpression> innerPushdownConjuncts = ImmutableList.builder();\nImmutableList.Builder<RowExpression> postJoinConjuncts = ImmutableList.builder();\nImmutableList.Builder<RowExpression> joinConjuncts = ImmutableList.builder();\n\/\/ Strip out non-deterministic conjuncts\npostJoinConjuncts.addAll(filter(extractConjuncts(inheritedPredicate), not(determinismEvaluator::isDeterministic)));\ninheritedPredicate = logicalRowExpressions.filterDeterministicConjuncts(inheritedPredicate);\nouterEffectivePredicate = logicalRowExpressions.filterDeterministicConjuncts(outerEffectivePredicate);\ninnerEffectivePredicate = logicalRowExpressions.filterDeterministicConjuncts(innerEffectivePredicate);\njoinConjuncts.addAll(filter(extractConjuncts(joinPredicate), not(determinismEvaluator::isDeterministic)));\njoinPredicate = logicalRowExpressions.filterDeterministicConjuncts(joinPredicate);\n\/\/ Generate equality inferences\nEqualityInference inheritedInference = createEqualityInference(inheritedPredicate);\nEqualityInference outerInference = createEqualityInference(inheritedPredicate, outerEffectivePredicate);\nEqualityInference.EqualityPartition equalityPartition = inheritedInference.generateEqualitiesPartitionedBy(in(outerVariables));\nRowExpression outerOnlyInheritedEqualities = logicalRowExpressions.combineConjuncts(equalityPartition.getScopeEqualities());\nEqualityInference potentialNullSymbolInference = createEqualityInference(outerOnlyInheritedEqualities, outerEffectivePredicate, innerEffectivePredicate, joinPredicate);\n\/\/ See if we can push inherited predicates down\nfor (RowExpression conjunct : nonInferableConjuncts(inheritedPredicate)) {\nRowExpression outerRewritten = outerInference.rewriteExpression(conjunct, in(outerVariables));\nif (outerRewritten != null) {\nouterPushdownConjuncts.add(outerRewritten);\n\/\/ A conjunct can only be pushed down into an inner side if it can be rewritten in terms of the outer side\nRowExpression innerRewritten = potentialNullSymbolInference.rewriteExpression(outerRewritten, not(in(outerVariables)));\nif (innerRewritten != null) {\ninnerPushdownConjuncts.add(innerRewritten);\n}\n}\nelse {\npostJoinConjuncts.add(conjunct);\n}\n}\n\n{\ncheckArgument(Iterables.all(VariablesExtractor.extractUnique(outerEffectivePredicate), in(outerVariables)), \"outerEffectivePredicate must only contain variables from outerVariables\");\ncheckArgument(Iterables.all(VariablesExtractor.extractUnique(innerEffectivePredicate), not(in(outerVariables))), \"innerEffectivePredicate must not contain variables from outerVariables\");\nImmutableList.Builder<RowExpression> outerPushdownConjuncts = ImmutableList.builder();\nImmutableList.Builder<RowExpression> innerPushdownConjuncts = ImmutableList.builder();\nImmutableList.Builder<RowExpression> postJoinConjuncts = ImmutableList.builder();\nImmutableList.Builder<RowExpression> joinConjuncts = ImmutableList.builder();\n\/\/ Strip out non-deterministic conjuncts\npostJoinConjuncts.addAll(filter(extractConjuncts(inheritedPredicate), not(determinismEvaluator::isDeterministic)));\ninheritedPredicate = logicalRowExpressions.filterDeterministicConjuncts(inheritedPredicate);\nouterEffectivePredicate = logicalRowExpressions.filterDeterministicConjuncts(outerEffectivePredicate);\ninnerEffectivePredicate = logicalRowExpressions.filterDeterministicConjuncts(innerEffectivePredicate);\njoinConjuncts.addAll(filter(extractConjuncts(joinPredicate), not(determinismEvaluator::isDeterministic)));\njoinPredicate = logicalRowExpressions.filterDeterministicConjuncts(joinPredicate);\n\/\/ Generate equality inferences\nEqualityInference inheritedInference = createEqualityInference(inheritedPredicate);\nEqualityInference outerInference = createEqualityInference(inheritedPredicate, outerEffectivePredicate);\nEqualityInference.EqualityPartition equalityPartition = inheritedInference.generateEqualitiesPartitionedBy(in(outerVariables));\nRowExpression outerOnlyInheritedEqualities = logicalRowExpressions.combineConjuncts(equalityPartition.getScopeEqualities());\nEqualityInference potentialNullSymbolInference = createEqualityInference(outerOnlyInheritedEqualities, outerEffectivePredicate, innerEffectivePredicate, joinPredicate);\n\/\/ See if we can push inherited predicates down\nfor (RowExpression conjunct : nonInferableConjuncts(inheritedPredicate)) {\nRowExpression outerRewritten = outerInference.rewriteExpression(conjunct, in(outerVariables));\nif (outerRewritten != null) {\nouterPushdownConjuncts.add(outerRewritten);\n\/\/ A conjunct can only be pushed down into an inner side if it can be rewritten in terms of the outer side\nRowExpression innerRewritten = potentialNullSymbolInference.rewriteExpression(outerRewritten, not(in(outerVariables)));\nif (innerRewritten != null) {\ninnerPushdownConjuncts.add(innerRewritten);\n}\n}\nelse {\npostJoinConjuncts.add(conjunct);\n}\n}\n\/\/ Add the equalities from the inferences back in\nouterPushdownConjuncts.addAll(equalityPartition.getScopeEqualities());\npostJoinConjuncts.addAll(equalityPartition.getScopeComplementEqualities());\npostJoinConjuncts.addAll(equalityPartition.getScopeStraddlingEqualities());\n\/\/ See if we can push down any outer effective predicates to the inner side\nfor (RowExpression conjunct : nonInferableConjuncts(outerEffectivePredicate)) {\n\nImmutableList.Builder<RowExpression> postJoinConjuncts = ImmutableList.builder();\nImmutableList.Builder<RowExpression> joinConjuncts = ImmutableList.builder();\n\/\/ Strip out non-deterministic conjuncts\npostJoinConjuncts.addAll(filter(extractConjuncts(inheritedPredicate), not(determinismEvaluator::isDeterministic)));\ninheritedPredicate = logicalRowExpressions.filterDeterministicConjuncts(inheritedPredicate);\nouterEffectivePredicate = logicalRowExpressions.filterDeterministicConjuncts(outerEffectivePredicate);\ninnerEffectivePredicate = logicalRowExpressions.filterDeterministicConjuncts(innerEffectivePredicate);\njoinConjuncts.addAll(filter(extractConjuncts(joinPredicate), not(determinismEvaluator::isDeterministic)));\njoinPredicate = logicalRowExpressions.filterDeterministicConjuncts(joinPredicate);\n\/\/ Generate equality inferences\nEqualityInference inheritedInference = createEqualityInference(inheritedPredicate);\nEqualityInference outerInference = createEqualityInference(inheritedPredicate, outerEffectivePredicate);\nEqualityInference.EqualityPartition equalityPartition = inheritedInference.generateEqualitiesPartitionedBy(in(outerVariables));\nRowExpression outerOnlyInheritedEqualities = logicalRowExpressions.combineConjuncts(equalityPartition.getScopeEqualities());\nEqualityInference potentialNullSymbolInference = createEqualityInference(outerOnlyInheritedEqualities, outerEffectivePredicate, innerEffectivePredicate, joinPredicate);\n\/\/ See if we can push inherited predicates down\nfor (RowExpression conjunct : nonInferableConjuncts(inheritedPredicate)) {\nRowExpression outerRewritten = outerInference.rewriteExpression(conjunct, in(outerVariables));\nif (outerRewritten != null) {\nouterPushdownConjuncts.add(outerRewritten);\n\/\/ A conjunct can only be pushed down into an inner side if it can be rewritten in terms of the outer side\nRowExpression innerRewritten = potentialNullSymbolInference.rewriteExpression(outerRewritten, not(in(outerVariables)));\nif (innerRewritten != null) {\ninnerPushdownConjuncts.add(innerRewritten);\n}\n}\nelse {\npostJoinConjuncts.add(conjunct);\n}\n}\n\/\/ Add the equalities from the inferences back in\nouterPushdownConjuncts.addAll(equalityPartition.getScopeEqualities());\npostJoinConjuncts.addAll(equalityPartition.getScopeComplementEqualities());\npostJoinConjuncts.addAll(equalityPartition.getScopeStraddlingEqualities());\n\/\/ See if we can push down any outer effective predicates to the inner side\nfor (RowExpression conjunct : nonInferableConjuncts(outerEffectivePredicate)) {\nRowExpression rewritten = potentialNullSymbolInference.rewriteExpression(conjunct, not(in(outerVariables)));\nif (rewritten != null) {\ninnerPushdownConjuncts.add(rewritten);\n}\n}\n\nEqualityInference inheritedInference = createEqualityInference(inheritedPredicate);\nEqualityInference outerInference = createEqualityInference(inheritedPredicate, outerEffectivePredicate);\nEqualityInference.EqualityPartition equalityPartition = inheritedInference.generateEqualitiesPartitionedBy(in(outerVariables));\nRowExpression outerOnlyInheritedEqualities = logicalRowExpressions.combineConjuncts(equalityPartition.getScopeEqualities());\nEqualityInference potentialNullSymbolInference = createEqualityInference(outerOnlyInheritedEqualities, outerEffectivePredicate, innerEffectivePredicate, joinPredicate);\n\/\/ See if we can push inherited predicates down\nfor (RowExpression conjunct : nonInferableConjuncts(inheritedPredicate)) {\nRowExpression outerRewritten = outerInference.rewriteExpression(conjunct, in(outerVariables));\nif (outerRewritten != null) {\nouterPushdownConjuncts.add(outerRewritten);\n\/\/ A conjunct can only be pushed down into an inner side if it can be rewritten in terms of the outer side\nRowExpression innerRewritten = potentialNullSymbolInference.rewriteExpression(outerRewritten, not(in(outerVariables)));\nif (innerRewritten != null) {\ninnerPushdownConjuncts.add(innerRewritten);\n}\n}\nelse {\npostJoinConjuncts.add(conjunct);\n}\n}\n\/\/ Add the equalities from the inferences back in\nouterPushdownConjuncts.addAll(equalityPartition.getScopeEqualities());\npostJoinConjuncts.addAll(equalityPartition.getScopeComplementEqualities());\npostJoinConjuncts.addAll(equalityPartition.getScopeStraddlingEqualities());\n\/\/ See if we can push down any outer effective predicates to the inner side\nfor (RowExpression conjunct : nonInferableConjuncts(outerEffectivePredicate)) {\nRowExpression rewritten = potentialNullSymbolInference.rewriteExpression(conjunct, not(in(outerVariables)));\nif (rewritten != null) {\ninnerPushdownConjuncts.add(rewritten);\n}\n}\n\/\/ See if we can push down join predicates to the inner side\nfor (RowExpression conjunct : nonInferableConjuncts(joinPredicate)) {\nRowExpression innerRewritten = potentialNullSymbolInference.rewriteExpression(conjunct, not(in(outerVariables)));\nif (innerRewritten != null) {\ninnerPushdownConjuncts.add(innerRewritten);\n}\nelse {\njoinConjuncts.add(conjunct);\n}\n}\n\nEqualityInference potentialNullSymbolInference = createEqualityInference(outerOnlyInheritedEqualities, outerEffectivePredicate, innerEffectivePredicate, joinPredicate);\n\/\/ See if we can push inherited predicates down\nfor (RowExpression conjunct : nonInferableConjuncts(inheritedPredicate)) {\nRowExpression outerRewritten = outerInference.rewriteExpression(conjunct, in(outerVariables));\nif (outerRewritten != null) {\nouterPushdownConjuncts.add(outerRewritten);\n\/\/ A conjunct can only be pushed down into an inner side if it can be rewritten in terms of the outer side\nRowExpression innerRewritten = potentialNullSymbolInference.rewriteExpression(outerRewritten, not(in(outerVariables)));\nif (innerRewritten != null) {\ninnerPushdownConjuncts.add(innerRewritten);\n}\n}\nelse {\npostJoinConjuncts.add(conjunct);\n}\n}\n\/\/ Add the equalities from the inferences back in\nouterPushdownConjuncts.addAll(equalityPartition.getScopeEqualities());\npostJoinConjuncts.addAll(equalityPartition.getScopeComplementEqualities());\npostJoinConjuncts.addAll(equalityPartition.getScopeStraddlingEqualities());\n\/\/ See if we can push down any outer effective predicates to the inner side\nfor (RowExpression conjunct : nonInferableConjuncts(outerEffectivePredicate)) {\nRowExpression rewritten = potentialNullSymbolInference.rewriteExpression(conjunct, not(in(outerVariables)));\nif (rewritten != null) {\ninnerPushdownConjuncts.add(rewritten);\n}\n}\n\/\/ See if we can push down join predicates to the inner side\nfor (RowExpression conjunct : nonInferableConjuncts(joinPredicate)) {\nRowExpression innerRewritten = potentialNullSymbolInference.rewriteExpression(conjunct, not(in(outerVariables)));\nif (innerRewritten != null) {\ninnerPushdownConjuncts.add(innerRewritten);\n}\nelse {\njoinConjuncts.add(conjunct);\n}\n}\n\/\/ Push outer and join equalities into the inner side. For example:\n\/\/ SELECT * FROM nation LEFT OUTER JOIN region ON nation.regionkey = region.regionkey and nation.name = region.name WHERE nation.name = 'blah'\nEqualityInference potentialNullSymbolInferenceWithoutInnerInferred = createEqualityInference(outerOnlyInheritedEqualities, outerEffectivePredicate, joinPredicate);\ninnerPushdownConjuncts.addAll(potentialNullSymbolInferenceWithoutInnerInferred.generateEqualitiesPartitionedBy(not(in(outerVariables))).getScopeEqualities());\n\nRowExpression innerRewritten = potentialNullSymbolInference.rewriteExpression(outerRewritten, not(in(outerVariables)));\nif (innerRewritten != null) {\ninnerPushdownConjuncts.add(innerRewritten);\n}\n}\nelse {\npostJoinConjuncts.add(conjunct);\n}\n}\n\/\/ Add the equalities from the inferences back in\nouterPushdownConjuncts.addAll(equalityPartition.getScopeEqualities());\npostJoinConjuncts.addAll(equalityPartition.getScopeComplementEqualities());\npostJoinConjuncts.addAll(equalityPartition.getScopeStraddlingEqualities());\n\/\/ See if we can push down any outer effective predicates to the inner side\nfor (RowExpression conjunct : nonInferableConjuncts(outerEffectivePredicate)) {\nRowExpression rewritten = potentialNullSymbolInference.rewriteExpression(conjunct, not(in(outerVariables)));\nif (rewritten != null) {\ninnerPushdownConjuncts.add(rewritten);\n}\n}\n\/\/ See if we can push down join predicates to the inner side\nfor (RowExpression conjunct : nonInferableConjuncts(joinPredicate)) {\nRowExpression innerRewritten = potentialNullSymbolInference.rewriteExpression(conjunct, not(in(outerVariables)));\nif (innerRewritten != null) {\ninnerPushdownConjuncts.add(innerRewritten);\n}\nelse {\njoinConjuncts.add(conjunct);\n}\n}\n\/\/ Push outer and join equalities into the inner side. For example:\n\/\/ SELECT * FROM nation LEFT OUTER JOIN region ON nation.regionkey = region.regionkey and nation.name = region.name WHERE nation.name = 'blah'\nEqualityInference potentialNullSymbolInferenceWithoutInnerInferred = createEqualityInference(outerOnlyInheritedEqualities, outerEffectivePredicate, joinPredicate);\ninnerPushdownConjuncts.addAll(potentialNullSymbolInferenceWithoutInnerInferred.generateEqualitiesPartitionedBy(not(in(outerVariables))).getScopeEqualities());\n\/\/ TODO: we can further improve simplifying the equalities by considering other relationships from the outer side\nEqualityInference.EqualityPartition joinEqualityPartition = createEqualityInference(joinPredicate).generateEqualitiesPartitionedBy(not(in(outerVariables)));\ninnerPushdownConjuncts.addAll(joinEqualityPartition.getScopeEqualities());\njoinConjuncts.addAll(joinEqualityPartition.getScopeComplementEqualities())\n.addAll(joinEqualityPartition.getScopeStraddlingEqualities());\nreturn new OuterJoinPushDownResult(logicalRowExpressions.combineConjuncts(outerPushdownConjuncts.build()),\nlogicalRowExpressions.combineConjuncts(innerPushdownConjuncts.build()),\n\nouterPushdownConjuncts.addAll(equalityPartition.getScopeEqualities());\npostJoinConjuncts.addAll(equalityPartition.getScopeComplementEqualities());\npostJoinConjuncts.addAll(equalityPartition.getScopeStraddlingEqualities());\n\/\/ See if we can push down any outer effective predicates to the inner side\nfor (RowExpression conjunct : nonInferableConjuncts(outerEffectivePredicate)) {\nRowExpression rewritten = potentialNullSymbolInference.rewriteExpression(conjunct, not(in(outerVariables)));\nif (rewritten != null) {\ninnerPushdownConjuncts.add(rewritten);\n}\n}\n\/\/ See if we can push down join predicates to the inner side\nfor (RowExpression conjunct : nonInferableConjuncts(joinPredicate)) {\nRowExpression innerRewritten = potentialNullSymbolInference.rewriteExpression(conjunct, not(in(outerVariables)));\nif (innerRewritten != null) {\ninnerPushdownConjuncts.add(innerRewritten);\n}\nelse {\njoinConjuncts.add(conjunct);\n}\n}\n\/\/ Push outer and join equalities into the inner side. For example:\n\/\/ SELECT * FROM nation LEFT OUTER JOIN region ON nation.regionkey = region.regionkey and nation.name = region.name WHERE nation.name = 'blah'\nEqualityInference potentialNullSymbolInferenceWithoutInnerInferred = createEqualityInference(outerOnlyInheritedEqualities, outerEffectivePredicate, joinPredicate);\ninnerPushdownConjuncts.addAll(potentialNullSymbolInferenceWithoutInnerInferred.generateEqualitiesPartitionedBy(not(in(outerVariables))).getScopeEqualities());\n\/\/ TODO: we can further improve simplifying the equalities by considering other relationships from the outer side\nEqualityInference.EqualityPartition joinEqualityPartition = createEqualityInference(joinPredicate).generateEqualitiesPartitionedBy(not(in(outerVariables)));\ninnerPushdownConjuncts.addAll(joinEqualityPartition.getScopeEqualities());\njoinConjuncts.addAll(joinEqualityPartition.getScopeComplementEqualities())\n.addAll(joinEqualityPartition.getScopeStraddlingEqualities());\nreturn new OuterJoinPushDownResult(logicalRowExpressions.combineConjuncts(outerPushdownConjuncts.build()),\nlogicalRowExpressions.combineConjuncts(innerPushdownConjuncts.build()),\nlogicalRowExpressions.combineConjuncts(joinConjuncts.build()),\nlogicalRowExpressions.combineConjuncts(postJoinConjuncts.build()));\n}\n\nfor (RowExpression conjunct : nonInferableConjuncts(outerEffectivePredicate)) {\nRowExpression rewritten = potentialNullSymbolInference.rewriteExpression(conjunct, not(in(outerVariables)));\nif (rewritten != null) {\ninnerPushdownConjuncts.add(rewritten);\n}\n}\n\/\/ See if we can push down join predicates to the inner side\nfor (RowExpression conjunct : nonInferableConjuncts(joinPredicate)) {\nRowExpression innerRewritten = potentialNullSymbolInference.rewriteExpression(conjunct, not(in(outerVariables)));\nif (innerRewritten != null) {\ninnerPushdownConjuncts.add(innerRewritten);\n}\nelse {\njoinConjuncts.add(conjunct);\n}\n}\n\/\/ Push outer and join equalities into the inner side. For example:\n\/\/ SELECT * FROM nation LEFT OUTER JOIN region ON nation.regionkey = region.regionkey and nation.name = region.name WHERE nation.name = 'blah'\nEqualityInference potentialNullSymbolInferenceWithoutInnerInferred = createEqualityInference(outerOnlyInheritedEqualities, outerEffectivePredicate, joinPredicate);\ninnerPushdownConjuncts.addAll(potentialNullSymbolInferenceWithoutInnerInferred.generateEqualitiesPartitionedBy(not(in(outerVariables))).getScopeEqualities());\n\/\/ TODO: we can further improve simplifying the equalities by considering other relationships from the outer side\nEqualityInference.EqualityPartition joinEqualityPartition = createEqualityInference(joinPredicate).generateEqualitiesPartitionedBy(not(in(outerVariables)));\ninnerPushdownConjuncts.addAll(joinEqualityPartition.getScopeEqualities());\njoinConjuncts.addAll(joinEqualityPartition.getScopeComplementEqualities())\n.addAll(joinEqualityPartition.getScopeStraddlingEqualities());\nreturn new OuterJoinPushDownResult(logicalRowExpressions.combineConjuncts(outerPushdownConjuncts.build()),\nlogicalRowExpressions.combineConjuncts(innerPushdownConjuncts.build()),\nlogicalRowExpressions.combineConjuncts(joinConjuncts.build()),\nlogicalRowExpressions.combineConjuncts(postJoinConjuncts.build()));\n}","label":[1,0,0,0]}
{"id":17401,"original_code":"public static SqlTypeName zetaSqlTypeToCalciteType(TypeKind zetaSqlType) {\n    switch (zetaSqlType) {\n      case TYPE_INT64:\n        return SqlTypeName.BIGINT;\n      case TYPE_NUMERIC:\n        return SqlTypeName.DECIMAL;\n      case TYPE_DOUBLE:\n        return SqlTypeName.DOUBLE;\n      case TYPE_STRING:\n        return SqlTypeName.VARCHAR;\n      case TYPE_TIMESTAMP:\n        return SqlTypeName.TIMESTAMP;\n      case TYPE_BOOL:\n        return SqlTypeName.BOOLEAN;\n      case TYPE_BYTES:\n        return SqlTypeName.VARBINARY;\n        \/\/ TODO[BEAM-9179] Add conversion code for ARRAY and ROW types\n      default:\n        throw new IllegalArgumentException(\"Unsupported ZetaSQL type: \" + zetaSqlType.name());\n    }\n  }","code":"public static SqlTypeName zetaSqlTypeToCalciteType(TypeKind zetaSqlType) {\n    switch (zetaSqlType) {\n      case TYPE_INT64:\n        return SqlTypeName.BIGINT;\n      case TYPE_NUMERIC:\n        return SqlTypeName.DECIMAL;\n      case TYPE_DOUBLE:\n        return SqlTypeName.DOUBLE;\n      case TYPE_STRING:\n        return SqlTypeName.VARCHAR;\n      case TYPE_TIMESTAMP:\n        return SqlTypeName.TIMESTAMP;\n      case TYPE_BOOL:\n        return SqlTypeName.BOOLEAN;\n      case TYPE_BYTES:\n        return SqlTypeName.VARBINARY;\n       \n      default:\n        throw new IllegalArgumentException(\"Unsupported ZetaSQL type: \" + zetaSqlType.name());\n    }\n  }","cleancode":"public static sqltypename zetasqltypetocalcitetype(typekind zetasqltype) { switch (zetasqltype) { case type_int64: return sqltypename.bigint; case type_numeric: return sqltypename.decimal; case type_double: return sqltypename.double; case type_string: return sqltypename.varchar; case type_timestamp: return sqltypename.timestamp; case type_bool: return sqltypename.boolean; case type_bytes: return sqltypename.varbinary; default: throw new illegalargumentexception(\"unsupported zetasql type: \" + zetasqltype.name()); } }","comment":"\/\/ todo[beam-9179] add conversion code for array and row types","repo":"stephenoken\/beam","code_context_2":"case TYPE_BYTES:\nreturn SqlTypeName.VARBINARY;\n\/\/ TODO[BEAM-9179] Add conversion code for ARRAY and ROW types\ndefault:\nthrow new IllegalArgumentException(\"Unsupported ZetaSQL type: \" + zetaSqlType.name());","code_context_10":"case TYPE_DOUBLE:\nreturn SqlTypeName.DOUBLE;\ncase TYPE_STRING:\nreturn SqlTypeName.VARCHAR;\ncase TYPE_TIMESTAMP:\nreturn SqlTypeName.TIMESTAMP;\ncase TYPE_BOOL:\nreturn SqlTypeName.BOOLEAN;\ncase TYPE_BYTES:\nreturn SqlTypeName.VARBINARY;\n\/\/ TODO[BEAM-9179] Add conversion code for ARRAY and ROW types\ndefault:\nthrow new IllegalArgumentException(\"Unsupported ZetaSQL type: \" + zetaSqlType.name());\n}\n}","code_context_20":"public static SqlTypeName zetaSqlTypeToCalciteType(TypeKind zetaSqlType) {\nswitch (zetaSqlType) {\ncase TYPE_INT64:\nreturn SqlTypeName.BIGINT;\ncase TYPE_NUMERIC:\nreturn SqlTypeName.DECIMAL;\ncase TYPE_DOUBLE:\nreturn SqlTypeName.DOUBLE;\ncase TYPE_STRING:\nreturn SqlTypeName.VARCHAR;\ncase TYPE_TIMESTAMP:\nreturn SqlTypeName.TIMESTAMP;\ncase TYPE_BOOL:\nreturn SqlTypeName.BOOLEAN;\ncase TYPE_BYTES:\nreturn SqlTypeName.VARBINARY;\n\/\/ TODO[BEAM-9179] Add conversion code for ARRAY and ROW types\ndefault:\nthrow new IllegalArgumentException(\"Unsupported ZetaSQL type: \" + zetaSqlType.name());\n}\n}","label":[0,1,0,0]}
{"id":33808,"original_code":"private boolean checkPermission(Cluster cluster, boolean readOnly) {\n    for (GrantedAuthority grantedAuthority : securityHelper.getCurrentAuthorities()) {\n      if (grantedAuthority instanceof AmbariGrantedAuthority) {\n        AmbariGrantedAuthority authority       = (AmbariGrantedAuthority) grantedAuthority;\n        PrivilegeEntity        privilegeEntity = authority.getPrivilegeEntity();\n        Integer                permissionId    = privilegeEntity.getPermission().getId();\n        \/\/ admin has full access\n        if (permissionId.equals(PermissionEntity.AMBARI_ADMINISTRATOR_PERMISSION)) {\n          return true;\n        }\n        if (cluster != null) {\n          if (cluster.checkPermission(privilegeEntity, readOnly)) {\n            return true;\n          }\n        }\n      }\n    }\n    \/\/ TODO : should we log this?\n    return false;\n  }","code":"private boolean checkPermission(Cluster cluster, boolean readOnly) {\n    for (GrantedAuthority grantedAuthority : securityHelper.getCurrentAuthorities()) {\n      if (grantedAuthority instanceof AmbariGrantedAuthority) {\n        AmbariGrantedAuthority authority       = (AmbariGrantedAuthority) grantedAuthority;\n        PrivilegeEntity        privilegeEntity = authority.getPrivilegeEntity();\n        Integer                permissionId    = privilegeEntity.getPermission().getId();\n       \n        if (permissionId.equals(PermissionEntity.AMBARI_ADMINISTRATOR_PERMISSION)) {\n          return true;\n        }\n        if (cluster != null) {\n          if (cluster.checkPermission(privilegeEntity, readOnly)) {\n            return true;\n          }\n        }\n      }\n    }\n   \n    return false;\n  }","cleancode":"private boolean checkpermission(cluster cluster, boolean readonly) { for (grantedauthority grantedauthority : securityhelper.getcurrentauthorities()) { if (grantedauthority instanceof ambarigrantedauthority) { ambarigrantedauthority authority = (ambarigrantedauthority) grantedauthority; privilegeentity privilegeentity = authority.getprivilegeentity(); integer permissionid = privilegeentity.getpermission().getid(); if (permissionid.equals(permissionentity.ambari_administrator_permission)) { return true; } if (cluster != null) { if (cluster.checkpermission(privilegeentity, readonly)) { return true; } } } } return false; }","comment":"\/** * determine whether or not access to the given cluster resource should be allowed based * on the privileges of the current user. * * @param cluster the cluster * @param readonly indicate whether or not this check is for a read only operation * * @return true if the access to this cluster is allowed *\/\n\/\/ admin has full access\n\/\/ todo : should we log this?","repo":"runningt\/ambari","code_context_2":"private boolean checkPermission(Cluster cluster, boolean readOnly) {\nfor (GrantedAuthority grantedAuthority : securityHelper.getCurrentAuthorities()) {\nif (grantedAuthority instanceof AmbariGrantedAuthority) {\nAmbariGrantedAuthority authority = (AmbariGrantedAuthority) grantedAuthority;\nPrivilegeEntity privilegeEntity = authority.getPrivilegeEntity();\nInteger permissionId = privilegeEntity.getPermission().getId();\n\/\/ admin has full access\nif (permissionId.equals(PermissionEntity.AMBARI_ADMINISTRATOR_PERMISSION)) {\nreturn true;\n}\nif (cluster != null) {\nif (cluster.checkPermission(privilegeEntity, readOnly)) {\nreturn true;\n}\n}\n}\n}\n\/\/ TODO : should we log this?\nreturn false;\n}\n\nPrivilegeEntity privilegeEntity = authority.getPrivilegeEntity();\nInteger permissionId = privilegeEntity.getPermission().getId();\n\/\/ admin has full access\nif (permissionId.equals(PermissionEntity.AMBARI_ADMINISTRATOR_PERMISSION)) {\nreturn true;\n\n}\n}\n\/\/ TODO : should we log this?\nreturn false;\n}","code_context_10":"private boolean checkPermission(Cluster cluster, boolean readOnly) {\nfor (GrantedAuthority grantedAuthority : securityHelper.getCurrentAuthorities()) {\nif (grantedAuthority instanceof AmbariGrantedAuthority) {\nAmbariGrantedAuthority authority = (AmbariGrantedAuthority) grantedAuthority;\nPrivilegeEntity privilegeEntity = authority.getPrivilegeEntity();\nInteger permissionId = privilegeEntity.getPermission().getId();\n\/\/ admin has full access\nif (permissionId.equals(PermissionEntity.AMBARI_ADMINISTRATOR_PERMISSION)) {\nreturn true;\n}\nif (cluster != null) {\nif (cluster.checkPermission(privilegeEntity, readOnly)) {\nreturn true;\n}\n}\n}\n}\n\/\/ TODO : should we log this?\nreturn false;\n}\n\nprivate boolean checkPermission(Cluster cluster, boolean readOnly) {\nfor (GrantedAuthority grantedAuthority : securityHelper.getCurrentAuthorities()) {\nif (grantedAuthority instanceof AmbariGrantedAuthority) {\nAmbariGrantedAuthority authority = (AmbariGrantedAuthority) grantedAuthority;\nPrivilegeEntity privilegeEntity = authority.getPrivilegeEntity();\nInteger permissionId = privilegeEntity.getPermission().getId();\n\/\/ admin has full access\nif (permissionId.equals(PermissionEntity.AMBARI_ADMINISTRATOR_PERMISSION)) {\nreturn true;\n}\nif (cluster != null) {\nif (cluster.checkPermission(privilegeEntity, readOnly)) {\nreturn true;\n}\n}\n}\n}\n\nif (permissionId.equals(PermissionEntity.AMBARI_ADMINISTRATOR_PERMISSION)) {\nreturn true;\n}\nif (cluster != null) {\nif (cluster.checkPermission(privilegeEntity, readOnly)) {\nreturn true;\n}\n}\n}\n}\n\/\/ TODO : should we log this?\nreturn false;\n}","code_context_20":"private boolean checkPermission(Cluster cluster, boolean readOnly) {\nfor (GrantedAuthority grantedAuthority : securityHelper.getCurrentAuthorities()) {\nif (grantedAuthority instanceof AmbariGrantedAuthority) {\nAmbariGrantedAuthority authority = (AmbariGrantedAuthority) grantedAuthority;\nPrivilegeEntity privilegeEntity = authority.getPrivilegeEntity();\nInteger permissionId = privilegeEntity.getPermission().getId();\n\/\/ admin has full access\nif (permissionId.equals(PermissionEntity.AMBARI_ADMINISTRATOR_PERMISSION)) {\nreturn true;\n}\nif (cluster != null) {\nif (cluster.checkPermission(privilegeEntity, readOnly)) {\nreturn true;\n}\n}\n}\n}\n\/\/ TODO : should we log this?\nreturn false;\n}\n\nprivate boolean checkPermission(Cluster cluster, boolean readOnly) {\nfor (GrantedAuthority grantedAuthority : securityHelper.getCurrentAuthorities()) {\nif (grantedAuthority instanceof AmbariGrantedAuthority) {\nAmbariGrantedAuthority authority = (AmbariGrantedAuthority) grantedAuthority;\nPrivilegeEntity privilegeEntity = authority.getPrivilegeEntity();\nInteger permissionId = privilegeEntity.getPermission().getId();\n\/\/ admin has full access\nif (permissionId.equals(PermissionEntity.AMBARI_ADMINISTRATOR_PERMISSION)) {\nreturn true;\n}\nif (cluster != null) {\nif (cluster.checkPermission(privilegeEntity, readOnly)) {\nreturn true;\n}\n}\n}\n}\n\/\/ TODO : should we log this?\nreturn false;\n}\n\nprivate boolean checkPermission(Cluster cluster, boolean readOnly) {\nfor (GrantedAuthority grantedAuthority : securityHelper.getCurrentAuthorities()) {\nif (grantedAuthority instanceof AmbariGrantedAuthority) {\nAmbariGrantedAuthority authority = (AmbariGrantedAuthority) grantedAuthority;\nPrivilegeEntity privilegeEntity = authority.getPrivilegeEntity();\nInteger permissionId = privilegeEntity.getPermission().getId();\n\/\/ admin has full access\nif (permissionId.equals(PermissionEntity.AMBARI_ADMINISTRATOR_PERMISSION)) {\nreturn true;\n}\nif (cluster != null) {\nif (cluster.checkPermission(privilegeEntity, readOnly)) {\nreturn true;\n}\n}\n}\n}\n\/\/ TODO : should we log this?\nreturn false;\n}","label":[1,0,0,0]}
{"id":1051,"original_code":"@Override\n    public ShuffleDataModel.KValueTypeId getKValueTypeId() {\n       int val = ngetKValueTypeId(this.pointerToStore);\n       if (val==ShuffleDataModel.KValueTypeId.Int.state){\n           return ShuffleDataModel.KValueTypeId.Int;\n       }\n       else if (val == ShuffleDataModel.KValueTypeId.Long.state){\n            return ShuffleDataModel.KValueTypeId.Long;\n       }\n       else if (val == ShuffleDataModel.KValueTypeId.Float.state){\n           return ShuffleDataModel.KValueTypeId.Float;\n       }\n       else if (val == ShuffleDataModel.KValueTypeId.Double.state){\n           return ShuffleDataModel.KValueTypeId.Double;\n       }\n       else if (val == ShuffleDataModel.KValueTypeId.String.state){\n           return ShuffleDataModel.KValueTypeId.String;\n       }\n       else if (val == ShuffleDataModel.KValueTypeId.ByteArray.state){\n           return ShuffleDataModel.KValueTypeId.ByteArray;\n       }\n       else if (val ==  ShuffleDataModel.KValueTypeId.Object.state){\n           return ShuffleDataModel.KValueTypeId.Object;\n       }\n       else if (val == ShuffleDataModel.KValueTypeId.Unknown.state) {\n           throw new RuntimeException(\"Unknown key value type encountered\");\n       }\n       else {\n    \t   throw new RuntimeException(\"unsupported key value type encountered\");\n       }\n    }","code":"@Override\n    public ShuffleDataModel.KValueTypeId getKValueTypeId() {\n       int val = ngetKValueTypeId(this.pointerToStore);\n       if (val==ShuffleDataModel.KValueTypeId.Int.state){\n           return ShuffleDataModel.KValueTypeId.Int;\n       }\n       else if (val == ShuffleDataModel.KValueTypeId.Long.state){\n            return ShuffleDataModel.KValueTypeId.Long;\n       }\n       else if (val == ShuffleDataModel.KValueTypeId.Float.state){\n           return ShuffleDataModel.KValueTypeId.Float;\n       }\n       else if (val == ShuffleDataModel.KValueTypeId.Double.state){\n           return ShuffleDataModel.KValueTypeId.Double;\n       }\n       else if (val == ShuffleDataModel.KValueTypeId.String.state){\n           return ShuffleDataModel.KValueTypeId.String;\n       }\n       else if (val == ShuffleDataModel.KValueTypeId.ByteArray.state){\n           return ShuffleDataModel.KValueTypeId.ByteArray;\n       }\n       else if (val ==  ShuffleDataModel.KValueTypeId.Object.state){\n           return ShuffleDataModel.KValueTypeId.Object;\n       }\n       else if (val == ShuffleDataModel.KValueTypeId.Unknown.state) {\n           throw new RuntimeException(\"Unknown key value type encountered\");\n       }\n       else {\n    \t   throw new RuntimeException(\"unsupported key value type encountered\");\n       }\n    }","cleancode":"@override public shuffledatamodel.kvaluetypeid getkvaluetypeid() { int val = ngetkvaluetypeid(this.pointertostore); if (val==shuffledatamodel.kvaluetypeid.int.state){ return shuffledatamodel.kvaluetypeid.int; } else if (val == shuffledatamodel.kvaluetypeid.long.state){ return shuffledatamodel.kvaluetypeid.long; } else if (val == shuffledatamodel.kvaluetypeid.float.state){ return shuffledatamodel.kvaluetypeid.float; } else if (val == shuffledatamodel.kvaluetypeid.double.state){ return shuffledatamodel.kvaluetypeid.double; } else if (val == shuffledatamodel.kvaluetypeid.string.state){ return shuffledatamodel.kvaluetypeid.string; } else if (val == shuffledatamodel.kvaluetypeid.bytearray.state){ return shuffledatamodel.kvaluetypeid.bytearray; } else if (val == shuffledatamodel.kvaluetypeid.object.state){ return shuffledatamodel.kvaluetypeid.object; } else if (val == shuffledatamodel.kvaluetypeid.unknown.state) { throw new runtimeexception(\"unknown key value type encountered\"); } else { throw new runtimeexception(\"unsupported key value type encountered\"); } }","comment":"\/** * todo: we will need to design the shared-memory region data structure, so that we can carry * the key\/value type definition over from map shuffle store via the shuffle channel, plus this enum * category information for key. * @return *\/","repo":"sparkle-plugin\/sparkle","code_context_2":"@Override\npublic ShuffleDataModel.KValueTypeId getKValueTypeId() {\nint val = ngetKValueTypeId(this.pointerToStore);\nif (val==ShuffleDataModel.KValueTypeId.Int.state){\nreturn ShuffleDataModel.KValueTypeId.Int;\n}\nelse if (val == ShuffleDataModel.KValueTypeId.Long.state){\nreturn ShuffleDataModel.KValueTypeId.Long;\n}\nelse if (val == ShuffleDataModel.KValueTypeId.Float.state){\nreturn ShuffleDataModel.KValueTypeId.Float;\n}\nelse if (val == ShuffleDataModel.KValueTypeId.Double.state){\nreturn ShuffleDataModel.KValueTypeId.Double;\n}\nelse if (val == ShuffleDataModel.KValueTypeId.String.state){\nreturn ShuffleDataModel.KValueTypeId.String;\n}\nelse if (val == ShuffleDataModel.KValueTypeId.ByteArray.state){\nreturn ShuffleDataModel.KValueTypeId.ByteArray;\n}\nelse if (val == ShuffleDataModel.KValueTypeId.Object.state){\nreturn ShuffleDataModel.KValueTypeId.Object;\n}\nelse if (val == ShuffleDataModel.KValueTypeId.Unknown.state) {\nthrow new RuntimeException(\"Unknown key value type encountered\");\n}\nelse {\nthrow new RuntimeException(\"unsupported key value type encountered\");\n}\n}","code_context_10":"@Override\npublic ShuffleDataModel.KValueTypeId getKValueTypeId() {\nint val = ngetKValueTypeId(this.pointerToStore);\nif (val==ShuffleDataModel.KValueTypeId.Int.state){\nreturn ShuffleDataModel.KValueTypeId.Int;\n}\nelse if (val == ShuffleDataModel.KValueTypeId.Long.state){\nreturn ShuffleDataModel.KValueTypeId.Long;\n}\nelse if (val == ShuffleDataModel.KValueTypeId.Float.state){\nreturn ShuffleDataModel.KValueTypeId.Float;\n}\nelse if (val == ShuffleDataModel.KValueTypeId.Double.state){\nreturn ShuffleDataModel.KValueTypeId.Double;\n}\nelse if (val == ShuffleDataModel.KValueTypeId.String.state){\nreturn ShuffleDataModel.KValueTypeId.String;\n}\nelse if (val == ShuffleDataModel.KValueTypeId.ByteArray.state){\nreturn ShuffleDataModel.KValueTypeId.ByteArray;\n}\nelse if (val == ShuffleDataModel.KValueTypeId.Object.state){\nreturn ShuffleDataModel.KValueTypeId.Object;\n}\nelse if (val == ShuffleDataModel.KValueTypeId.Unknown.state) {\nthrow new RuntimeException(\"Unknown key value type encountered\");\n}\nelse {\nthrow new RuntimeException(\"unsupported key value type encountered\");\n}\n}","code_context_20":"@Override\npublic ShuffleDataModel.KValueTypeId getKValueTypeId() {\nint val = ngetKValueTypeId(this.pointerToStore);\nif (val==ShuffleDataModel.KValueTypeId.Int.state){\nreturn ShuffleDataModel.KValueTypeId.Int;\n}\nelse if (val == ShuffleDataModel.KValueTypeId.Long.state){\nreturn ShuffleDataModel.KValueTypeId.Long;\n}\nelse if (val == ShuffleDataModel.KValueTypeId.Float.state){\nreturn ShuffleDataModel.KValueTypeId.Float;\n}\nelse if (val == ShuffleDataModel.KValueTypeId.Double.state){\nreturn ShuffleDataModel.KValueTypeId.Double;\n}\nelse if (val == ShuffleDataModel.KValueTypeId.String.state){\nreturn ShuffleDataModel.KValueTypeId.String;\n}\nelse if (val == ShuffleDataModel.KValueTypeId.ByteArray.state){\nreturn ShuffleDataModel.KValueTypeId.ByteArray;\n}\nelse if (val == ShuffleDataModel.KValueTypeId.Object.state){\nreturn ShuffleDataModel.KValueTypeId.Object;\n}\nelse if (val == ShuffleDataModel.KValueTypeId.Unknown.state) {\nthrow new RuntimeException(\"Unknown key value type encountered\");\n}\nelse {\nthrow new RuntimeException(\"unsupported key value type encountered\");\n}\n}","label":[1,0,0,0]}
{"id":9251,"original_code":"public Optional<ClassName> copierClassFor(MemberModel memberModel) {\n        if (canCopyReference(memberModel)) {\n            return Optional.empty();\n        }\n        if (canUseStandardCopier(memberModel)) {\n            return Optional.of(ClassName.get(StandardMemberCopier.class));\n        }\n        \/\/ FIXME: Ugly hack, but some services (Health) have shapes with names\n        \/\/ that differ only in the casing of the first letter, and generating\n        \/\/ classes for them breaks on case insensitive filesystems...\n        String shapeName = memberModel.getC2jShape();\n        if (shapeName.substring(0, 1).toLowerCase(Locale.ENGLISH).equals(shapeName.substring(0, 1))) {\n            shapeName = \"_\" + shapeName;\n        }\n        return Optional.of(poetExtensions.getModelClass(shapeName + \"Copier\"));\n    }","code":"public Optional<ClassName> copierClassFor(MemberModel memberModel) {\n        if (canCopyReference(memberModel)) {\n            return Optional.empty();\n        }\n        if (canUseStandardCopier(memberModel)) {\n            return Optional.of(ClassName.get(StandardMemberCopier.class));\n        }\n       \n       \n       \n        String shapeName = memberModel.getC2jShape();\n        if (shapeName.substring(0, 1).toLowerCase(Locale.ENGLISH).equals(shapeName.substring(0, 1))) {\n            shapeName = \"_\" + shapeName;\n        }\n        return Optional.of(poetExtensions.getModelClass(shapeName + \"Copier\"));\n    }","cleancode":"public optional<classname> copierclassfor(membermodel membermodel) { if (cancopyreference(membermodel)) { return optional.empty(); } if (canusestandardcopier(membermodel)) { return optional.of(classname.get(standardmembercopier.class)); } string shapename = membermodel.getc2jshape(); if (shapename.substring(0, 1).tolowercase(locale.english).equals(shapename.substring(0, 1))) { shapename = \"_\" + shapename; } return optional.of(poetextensions.getmodelclass(shapename + \"copier\")); }","comment":"\/\/ fixme: ugly hack, but some services (health) have shapes with names \/\/ that differ only in the casing of the first letter, and generating \/\/ classes for them breaks on case insensitive filesystems...","repo":"slachiewicz\/aws-sdk-java-v2","code_context_2":"return Optional.of(ClassName.get(StandardMemberCopier.class));\n}\n\/\/ FIXME: Ugly hack, but some services (Health) have shapes with names\n\/\/ that differ only in the casing of the first letter, and generating\n\/\/ classes for them breaks on case insensitive filesystems...\nString shapeName = memberModel.getC2jShape();\nif (shapeName.substring(0, 1).toLowerCase(Locale.ENGLISH).equals(shapeName.substring(0, 1))) {","code_context_10":"public Optional<ClassName> copierClassFor(MemberModel memberModel) {\nif (canCopyReference(memberModel)) {\nreturn Optional.empty();\n}\nif (canUseStandardCopier(memberModel)) {\nreturn Optional.of(ClassName.get(StandardMemberCopier.class));\n}\n\/\/ FIXME: Ugly hack, but some services (Health) have shapes with names\n\/\/ that differ only in the casing of the first letter, and generating\n\/\/ classes for them breaks on case insensitive filesystems...\nString shapeName = memberModel.getC2jShape();\nif (shapeName.substring(0, 1).toLowerCase(Locale.ENGLISH).equals(shapeName.substring(0, 1))) {\nshapeName = \"_\" + shapeName;\n}\nreturn Optional.of(poetExtensions.getModelClass(shapeName + \"Copier\"));\n}","code_context_20":"public Optional<ClassName> copierClassFor(MemberModel memberModel) {\nif (canCopyReference(memberModel)) {\nreturn Optional.empty();\n}\nif (canUseStandardCopier(memberModel)) {\nreturn Optional.of(ClassName.get(StandardMemberCopier.class));\n}\n\/\/ FIXME: Ugly hack, but some services (Health) have shapes with names\n\/\/ that differ only in the casing of the first letter, and generating\n\/\/ classes for them breaks on case insensitive filesystems...\nString shapeName = memberModel.getC2jShape();\nif (shapeName.substring(0, 1).toLowerCase(Locale.ENGLISH).equals(shapeName.substring(0, 1))) {\nshapeName = \"_\" + shapeName;\n}\nreturn Optional.of(poetExtensions.getModelClass(shapeName + \"Copier\"));\n}","label":[1,0,0,0]}
{"id":1396,"original_code":"private synchronized void fillCostMapWithGeometries() {\n        if (mGeometryList.isEmpty()) {\n            Log.wtf(TAG, \"Empty geometries list\");\n            setValid(false);\n            return;\n        }\n        \/\/ Get the grid boundaries to determine the size of the cost map.\n        double[][] positions = findGeometriesBoundaries();\n        if (positions == null) {\n            Log.wtf(TAG, \"Could not find grid boundaries\");\n            setValid(false);\n            return;\n        }\n        \/\/ Create the grid.\n        makeGrid(positions, MIN_COST);\n        for (Geometry g : mGeometryList) {\n            int size = g.mPolygon.getSize();\n            List<Transform> points = g.mPolygon.getPoints();\n            \/\/ DiscretizedVertices contain only X and Y.\n            int[][] discretizedVertices = new int[size][2];\n            for (int i = 0; i < size; i++) {\n                double[] pointPosition = points.get(i).getPosition();\n                discretizedVertices[i][0] = (int) Math.floor(pointPosition[0] \/ getResolution());\n                discretizedVertices[i][1] = (int) Math.floor(pointPosition[1] \/ getResolution());\n            }\n            \/\/ TODO mCost is not used, function below sets polygon regions to OBSTACLE_COST.\n            drawPolygonOnGrid(discretizedVertices);\n        }\n    }","code":"private synchronized void fillCostMapWithGeometries() {\n        if (mGeometryList.isEmpty()) {\n            Log.wtf(TAG, \"Empty geometries list\");\n            setValid(false);\n            return;\n        }\n       \n        double[][] positions = findGeometriesBoundaries();\n        if (positions == null) {\n            Log.wtf(TAG, \"Could not find grid boundaries\");\n            setValid(false);\n            return;\n        }\n       \n        makeGrid(positions, MIN_COST);\n        for (Geometry g : mGeometryList) {\n            int size = g.mPolygon.getSize();\n            List<Transform> points = g.mPolygon.getPoints();\n           \n            int[][] discretizedVertices = new int[size][2];\n            for (int i = 0; i < size; i++) {\n                double[] pointPosition = points.get(i).getPosition();\n                discretizedVertices[i][0] = (int) Math.floor(pointPosition[0] \/ getResolution());\n                discretizedVertices[i][1] = (int) Math.floor(pointPosition[1] \/ getResolution());\n            }\n           \n            drawPolygonOnGrid(discretizedVertices);\n        }\n    }","cleancode":"private synchronized void fillcostmapwithgeometries() { if (mgeometrylist.isempty()) { log.wtf(tag, \"empty geometries list\"); setvalid(false); return; } double[][] positions = findgeometriesboundaries(); if (positions == null) { log.wtf(tag, \"could not find grid boundaries\"); setvalid(false); return; } makegrid(positions, min_cost); for (geometry g : mgeometrylist) { int size = g.mpolygon.getsize(); list<transform> points = g.mpolygon.getpoints(); int[][] discretizedvertices = new int[size][2]; for (int i = 0; i < size; i++) { double[] pointposition = points.get(i).getposition(); discretizedvertices[i][0] = (int) math.floor(pointposition[0] \/ getresolution()); discretizedvertices[i][1] = (int) math.floor(pointposition[1] \/ getresolution()); } drawpolygonongrid(discretizedvertices); } }","comment":"\/** * sets a costmap grid and fills it with the geometry polygons. *\/ \/\/ todo(playerone) remove sync\n\/\/ get the grid boundaries to determine the size of the cost map.\n\/\/ create the grid.\n\/\/ discretizedvertices contain only x and y.\n\/\/ todo mcost is not used, function below sets polygon regions to obstacle_cost.","repo":"rhickman\/cellbots3","code_context_2":"private synchronized void fillCostMapWithGeometries() {\nif (mGeometryList.isEmpty()) {\nLog.wtf(TAG, \"Empty geometries list\");\nsetValid(false);\nreturn;\n}\n\/\/ Get the grid boundaries to determine the size of the cost map.\ndouble[][] positions = findGeometriesBoundaries();\nif (positions == null) {\nLog.wtf(TAG, \"Could not find grid boundaries\");\nsetValid(false);\nreturn;\n}\n\/\/ Create the grid.\nmakeGrid(positions, MIN_COST);\nfor (Geometry g : mGeometryList) {\nint size = g.mPolygon.getSize();\nList<Transform> points = g.mPolygon.getPoints();\n\/\/ DiscretizedVertices contain only X and Y.\nint[][] discretizedVertices = new int[size][2];\nfor (int i = 0; i < size; i++) {\ndouble[] pointPosition = points.get(i).getPosition();\ndiscretizedVertices[i][0] = (int) Math.floor(pointPosition[0] \/ getResolution());\ndiscretizedVertices[i][1] = (int) Math.floor(pointPosition[1] \/ getResolution());\n}\n\/\/ TODO mCost is not used, function below sets polygon regions to OBSTACLE_COST.\ndrawPolygonOnGrid(discretizedVertices);\n}\n}\n\nreturn;\n}\n\/\/ Get the grid boundaries to determine the size of the cost map.\ndouble[][] positions = findGeometriesBoundaries();\nif (positions == null) {\n\nreturn;\n}\n\/\/ Create the grid.\nmakeGrid(positions, MIN_COST);\nfor (Geometry g : mGeometryList) {\n\nint size = g.mPolygon.getSize();\nList<Transform> points = g.mPolygon.getPoints();\n\/\/ DiscretizedVertices contain only X and Y.\nint[][] discretizedVertices = new int[size][2];\nfor (int i = 0; i < size; i++) {\n\ndiscretizedVertices[i][1] = (int) Math.floor(pointPosition[1] \/ getResolution());\n}\n\/\/ TODO mCost is not used, function below sets polygon regions to OBSTACLE_COST.\ndrawPolygonOnGrid(discretizedVertices);\n}","code_context_10":"private synchronized void fillCostMapWithGeometries() {\nif (mGeometryList.isEmpty()) {\nLog.wtf(TAG, \"Empty geometries list\");\nsetValid(false);\nreturn;\n}\n\/\/ Get the grid boundaries to determine the size of the cost map.\ndouble[][] positions = findGeometriesBoundaries();\nif (positions == null) {\nLog.wtf(TAG, \"Could not find grid boundaries\");\nsetValid(false);\nreturn;\n}\n\/\/ Create the grid.\nmakeGrid(positions, MIN_COST);\nfor (Geometry g : mGeometryList) {\nint size = g.mPolygon.getSize();\nList<Transform> points = g.mPolygon.getPoints();\n\/\/ DiscretizedVertices contain only X and Y.\nint[][] discretizedVertices = new int[size][2];\nfor (int i = 0; i < size; i++) {\ndouble[] pointPosition = points.get(i).getPosition();\ndiscretizedVertices[i][0] = (int) Math.floor(pointPosition[0] \/ getResolution());\ndiscretizedVertices[i][1] = (int) Math.floor(pointPosition[1] \/ getResolution());\n}\n\/\/ TODO mCost is not used, function below sets polygon regions to OBSTACLE_COST.\ndrawPolygonOnGrid(discretizedVertices);\n}\n}\n\nprivate synchronized void fillCostMapWithGeometries() {\nif (mGeometryList.isEmpty()) {\nLog.wtf(TAG, \"Empty geometries list\");\nsetValid(false);\nreturn;\n}\n\/\/ Get the grid boundaries to determine the size of the cost map.\ndouble[][] positions = findGeometriesBoundaries();\nif (positions == null) {\nLog.wtf(TAG, \"Could not find grid boundaries\");\nsetValid(false);\nreturn;\n}\n\/\/ Create the grid.\nmakeGrid(positions, MIN_COST);\nfor (Geometry g : mGeometryList) {\nint size = g.mPolygon.getSize();\n\nsetValid(false);\nreturn;\n}\n\/\/ Get the grid boundaries to determine the size of the cost map.\ndouble[][] positions = findGeometriesBoundaries();\nif (positions == null) {\nLog.wtf(TAG, \"Could not find grid boundaries\");\nsetValid(false);\nreturn;\n}\n\/\/ Create the grid.\nmakeGrid(positions, MIN_COST);\nfor (Geometry g : mGeometryList) {\nint size = g.mPolygon.getSize();\nList<Transform> points = g.mPolygon.getPoints();\n\/\/ DiscretizedVertices contain only X and Y.\nint[][] discretizedVertices = new int[size][2];\nfor (int i = 0; i < size; i++) {\ndouble[] pointPosition = points.get(i).getPosition();\ndiscretizedVertices[i][0] = (int) Math.floor(pointPosition[0] \/ getResolution());\ndiscretizedVertices[i][1] = (int) Math.floor(pointPosition[1] \/ getResolution());\n\nif (positions == null) {\nLog.wtf(TAG, \"Could not find grid boundaries\");\nsetValid(false);\nreturn;\n}\n\/\/ Create the grid.\nmakeGrid(positions, MIN_COST);\nfor (Geometry g : mGeometryList) {\nint size = g.mPolygon.getSize();\nList<Transform> points = g.mPolygon.getPoints();\n\/\/ DiscretizedVertices contain only X and Y.\nint[][] discretizedVertices = new int[size][2];\nfor (int i = 0; i < size; i++) {\ndouble[] pointPosition = points.get(i).getPosition();\ndiscretizedVertices[i][0] = (int) Math.floor(pointPosition[0] \/ getResolution());\ndiscretizedVertices[i][1] = (int) Math.floor(pointPosition[1] \/ getResolution());\n}\n\/\/ TODO mCost is not used, function below sets polygon regions to OBSTACLE_COST.\ndrawPolygonOnGrid(discretizedVertices);\n}\n}\n\nfor (Geometry g : mGeometryList) {\nint size = g.mPolygon.getSize();\nList<Transform> points = g.mPolygon.getPoints();\n\/\/ DiscretizedVertices contain only X and Y.\nint[][] discretizedVertices = new int[size][2];\nfor (int i = 0; i < size; i++) {\ndouble[] pointPosition = points.get(i).getPosition();\ndiscretizedVertices[i][0] = (int) Math.floor(pointPosition[0] \/ getResolution());\ndiscretizedVertices[i][1] = (int) Math.floor(pointPosition[1] \/ getResolution());\n}\n\/\/ TODO mCost is not used, function below sets polygon regions to OBSTACLE_COST.\ndrawPolygonOnGrid(discretizedVertices);\n}\n}","code_context_20":"private synchronized void fillCostMapWithGeometries() {\nif (mGeometryList.isEmpty()) {\nLog.wtf(TAG, \"Empty geometries list\");\nsetValid(false);\nreturn;\n}\n\/\/ Get the grid boundaries to determine the size of the cost map.\ndouble[][] positions = findGeometriesBoundaries();\nif (positions == null) {\nLog.wtf(TAG, \"Could not find grid boundaries\");\nsetValid(false);\nreturn;\n}\n\/\/ Create the grid.\nmakeGrid(positions, MIN_COST);\nfor (Geometry g : mGeometryList) {\nint size = g.mPolygon.getSize();\nList<Transform> points = g.mPolygon.getPoints();\n\/\/ DiscretizedVertices contain only X and Y.\nint[][] discretizedVertices = new int[size][2];\nfor (int i = 0; i < size; i++) {\ndouble[] pointPosition = points.get(i).getPosition();\ndiscretizedVertices[i][0] = (int) Math.floor(pointPosition[0] \/ getResolution());\ndiscretizedVertices[i][1] = (int) Math.floor(pointPosition[1] \/ getResolution());\n}\n\/\/ TODO mCost is not used, function below sets polygon regions to OBSTACLE_COST.\ndrawPolygonOnGrid(discretizedVertices);\n}\n}\n\nprivate synchronized void fillCostMapWithGeometries() {\nif (mGeometryList.isEmpty()) {\nLog.wtf(TAG, \"Empty geometries list\");\nsetValid(false);\nreturn;\n}\n\/\/ Get the grid boundaries to determine the size of the cost map.\ndouble[][] positions = findGeometriesBoundaries();\nif (positions == null) {\nLog.wtf(TAG, \"Could not find grid boundaries\");\nsetValid(false);\nreturn;\n}\n\/\/ Create the grid.\nmakeGrid(positions, MIN_COST);\nfor (Geometry g : mGeometryList) {\nint size = g.mPolygon.getSize();\nList<Transform> points = g.mPolygon.getPoints();\n\/\/ DiscretizedVertices contain only X and Y.\nint[][] discretizedVertices = new int[size][2];\nfor (int i = 0; i < size; i++) {\ndouble[] pointPosition = points.get(i).getPosition();\ndiscretizedVertices[i][0] = (int) Math.floor(pointPosition[0] \/ getResolution());\ndiscretizedVertices[i][1] = (int) Math.floor(pointPosition[1] \/ getResolution());\n}\n\/\/ TODO mCost is not used, function below sets polygon regions to OBSTACLE_COST.\ndrawPolygonOnGrid(discretizedVertices);\n\nprivate synchronized void fillCostMapWithGeometries() {\nif (mGeometryList.isEmpty()) {\nLog.wtf(TAG, \"Empty geometries list\");\nsetValid(false);\nreturn;\n}\n\/\/ Get the grid boundaries to determine the size of the cost map.\ndouble[][] positions = findGeometriesBoundaries();\nif (positions == null) {\nLog.wtf(TAG, \"Could not find grid boundaries\");\nsetValid(false);\nreturn;\n}\n\/\/ Create the grid.\nmakeGrid(positions, MIN_COST);\nfor (Geometry g : mGeometryList) {\nint size = g.mPolygon.getSize();\nList<Transform> points = g.mPolygon.getPoints();\n\/\/ DiscretizedVertices contain only X and Y.\nint[][] discretizedVertices = new int[size][2];\nfor (int i = 0; i < size; i++) {\ndouble[] pointPosition = points.get(i).getPosition();\ndiscretizedVertices[i][0] = (int) Math.floor(pointPosition[0] \/ getResolution());\ndiscretizedVertices[i][1] = (int) Math.floor(pointPosition[1] \/ getResolution());\n}\n\/\/ TODO mCost is not used, function below sets polygon regions to OBSTACLE_COST.\ndrawPolygonOnGrid(discretizedVertices);\n}\n}\n\nprivate synchronized void fillCostMapWithGeometries() {\nif (mGeometryList.isEmpty()) {\nLog.wtf(TAG, \"Empty geometries list\");\nsetValid(false);\nreturn;\n}\n\/\/ Get the grid boundaries to determine the size of the cost map.\ndouble[][] positions = findGeometriesBoundaries();\nif (positions == null) {\nLog.wtf(TAG, \"Could not find grid boundaries\");\nsetValid(false);\nreturn;\n}\n\/\/ Create the grid.\nmakeGrid(positions, MIN_COST);\nfor (Geometry g : mGeometryList) {\nint size = g.mPolygon.getSize();\nList<Transform> points = g.mPolygon.getPoints();\n\/\/ DiscretizedVertices contain only X and Y.\nint[][] discretizedVertices = new int[size][2];\nfor (int i = 0; i < size; i++) {\ndouble[] pointPosition = points.get(i).getPosition();\ndiscretizedVertices[i][0] = (int) Math.floor(pointPosition[0] \/ getResolution());\ndiscretizedVertices[i][1] = (int) Math.floor(pointPosition[1] \/ getResolution());\n}\n\/\/ TODO mCost is not used, function below sets polygon regions to OBSTACLE_COST.\ndrawPolygonOnGrid(discretizedVertices);\n}\n}\n\n}\n\/\/ Get the grid boundaries to determine the size of the cost map.\ndouble[][] positions = findGeometriesBoundaries();\nif (positions == null) {\nLog.wtf(TAG, \"Could not find grid boundaries\");\nsetValid(false);\nreturn;\n}\n\/\/ Create the grid.\nmakeGrid(positions, MIN_COST);\nfor (Geometry g : mGeometryList) {\nint size = g.mPolygon.getSize();\nList<Transform> points = g.mPolygon.getPoints();\n\/\/ DiscretizedVertices contain only X and Y.\nint[][] discretizedVertices = new int[size][2];\nfor (int i = 0; i < size; i++) {\ndouble[] pointPosition = points.get(i).getPosition();\ndiscretizedVertices[i][0] = (int) Math.floor(pointPosition[0] \/ getResolution());\ndiscretizedVertices[i][1] = (int) Math.floor(pointPosition[1] \/ getResolution());\n}\n\/\/ TODO mCost is not used, function below sets polygon regions to OBSTACLE_COST.\ndrawPolygonOnGrid(discretizedVertices);\n}\n}","label":[1,0,0,0]}
{"id":1397,"original_code":"private synchronized double[][] findGeometriesBoundaries() {\n        if (mGeometryList.isEmpty()) {\n            Log.wtf(TAG, \"Empty geometries list\");\n            return null;\n        }\n        double minX = Double.MAX_VALUE;\n        double maxX = -Double.MAX_VALUE;\n        double minY = Double.MAX_VALUE;\n        double maxY = -Double.MAX_VALUE;\n        for (Geometry g : mGeometryList) {\n            int size = g.mPolygon.getSize();\n            List<Transform> points = g.mPolygon.getPoints();\n            for (int i = 0; i < size; i++) {\n                double[] pointPosition = points.get(i).getPosition();\n                minX = Math.min(minX, pointPosition[0]);\n                maxX = Math.max(maxX, pointPosition[0]);\n                minY = Math.min(minY, pointPosition[1]);\n                maxY = Math.max(maxY, pointPosition[1]);\n            }\n        }\n        return new double[][]{{minX - mRobotRadius, minY - mRobotRadius},\n                              {maxX + mRobotRadius, maxY + mRobotRadius}};\n    }","code":"private synchronized double[][] findGeometriesBoundaries() {\n        if (mGeometryList.isEmpty()) {\n            Log.wtf(TAG, \"Empty geometries list\");\n            return null;\n        }\n        double minX = Double.MAX_VALUE;\n        double maxX = -Double.MAX_VALUE;\n        double minY = Double.MAX_VALUE;\n        double maxY = -Double.MAX_VALUE;\n        for (Geometry g : mGeometryList) {\n            int size = g.mPolygon.getSize();\n            List<Transform> points = g.mPolygon.getPoints();\n            for (int i = 0; i < size; i++) {\n                double[] pointPosition = points.get(i).getPosition();\n                minX = Math.min(minX, pointPosition[0]);\n                maxX = Math.max(maxX, pointPosition[0]);\n                minY = Math.min(minY, pointPosition[1]);\n                maxY = Math.max(maxY, pointPosition[1]);\n            }\n        }\n        return new double[][]{{minX - mRobotRadius, minY - mRobotRadius},\n                              {maxX + mRobotRadius, maxY + mRobotRadius}};\n    }","cleancode":"private synchronized double[][] findgeometriesboundaries() { if (mgeometrylist.isempty()) { log.wtf(tag, \"empty geometries list\"); return null; } double minx = double.max_value; double maxx = -double.max_value; double miny = double.max_value; double maxy = -double.max_value; for (geometry g : mgeometrylist) { int size = g.mpolygon.getsize(); list<transform> points = g.mpolygon.getpoints(); for (int i = 0; i < size; i++) { double[] pointposition = points.get(i).getposition(); minx = math.min(minx, pointposition[0]); maxx = math.max(maxx, pointposition[0]); miny = math.min(miny, pointposition[1]); maxy = math.max(maxy, pointposition[1]); } } return new double[][]{{minx - mrobotradius, miny - mrobotradius}, {maxx + mrobotradius, maxy + mrobotradius}}; }","comment":"\/** * finds the boundaries of all the geometry polygons in x and y. * the boundaries are extended by robot radius in each direction. * * @return array of doubles {{minx, miny}}, {{maxx, maxy}}. *\/ \/\/ todo(playerone) remove sync","repo":"rhickman\/cellbots3","code_context_2":"private synchronized double[][] findGeometriesBoundaries() {\nif (mGeometryList.isEmpty()) {\nLog.wtf(TAG, \"Empty geometries list\");\nreturn null;\n}\ndouble minX = Double.MAX_VALUE;\ndouble maxX = -Double.MAX_VALUE;\ndouble minY = Double.MAX_VALUE;\ndouble maxY = -Double.MAX_VALUE;\nfor (Geometry g : mGeometryList) {\nint size = g.mPolygon.getSize();\nList<Transform> points = g.mPolygon.getPoints();\nfor (int i = 0; i < size; i++) {\ndouble[] pointPosition = points.get(i).getPosition();\nminX = Math.min(minX, pointPosition[0]);\nmaxX = Math.max(maxX, pointPosition[0]);\nminY = Math.min(minY, pointPosition[1]);\nmaxY = Math.max(maxY, pointPosition[1]);\n}\n}\nreturn new double[][]{{minX - mRobotRadius, minY - mRobotRadius},\n{maxX + mRobotRadius, maxY + mRobotRadius}};\n}","code_context_10":"private synchronized double[][] findGeometriesBoundaries() {\nif (mGeometryList.isEmpty()) {\nLog.wtf(TAG, \"Empty geometries list\");\nreturn null;\n}\ndouble minX = Double.MAX_VALUE;\ndouble maxX = -Double.MAX_VALUE;\ndouble minY = Double.MAX_VALUE;\ndouble maxY = -Double.MAX_VALUE;\nfor (Geometry g : mGeometryList) {\nint size = g.mPolygon.getSize();\nList<Transform> points = g.mPolygon.getPoints();\nfor (int i = 0; i < size; i++) {\ndouble[] pointPosition = points.get(i).getPosition();\nminX = Math.min(minX, pointPosition[0]);\nmaxX = Math.max(maxX, pointPosition[0]);\nminY = Math.min(minY, pointPosition[1]);\nmaxY = Math.max(maxY, pointPosition[1]);\n}\n}\nreturn new double[][]{{minX - mRobotRadius, minY - mRobotRadius},\n{maxX + mRobotRadius, maxY + mRobotRadius}};\n}","code_context_20":"private synchronized double[][] findGeometriesBoundaries() {\nif (mGeometryList.isEmpty()) {\nLog.wtf(TAG, \"Empty geometries list\");\nreturn null;\n}\ndouble minX = Double.MAX_VALUE;\ndouble maxX = -Double.MAX_VALUE;\ndouble minY = Double.MAX_VALUE;\ndouble maxY = -Double.MAX_VALUE;\nfor (Geometry g : mGeometryList) {\nint size = g.mPolygon.getSize();\nList<Transform> points = g.mPolygon.getPoints();\nfor (int i = 0; i < size; i++) {\ndouble[] pointPosition = points.get(i).getPosition();\nminX = Math.min(minX, pointPosition[0]);\nmaxX = Math.max(maxX, pointPosition[0]);\nminY = Math.min(minY, pointPosition[1]);\nmaxY = Math.max(maxY, pointPosition[1]);\n}\n}\nreturn new double[][]{{minX - mRobotRadius, minY - mRobotRadius},\n{maxX + mRobotRadius, maxY + mRobotRadius}};\n}","label":[1,0,0,0]}
{"id":34326,"original_code":"public String exportAll(String filename) throws IOException {\n    \/\/ currently only support python - maybe in future we'll support js too\n    String python = LangUtils.toPython();\n    Files.write(Paths.get(filename), python.toString().getBytes());\n    info(\"saved %s to %s\", getName(), filename);\n    return python;\n  }","code":"public String exportAll(String filename) throws IOException {\n   \n    String python = LangUtils.toPython();\n    Files.write(Paths.get(filename), python.toString().getBytes());\n    info(\"saved %s to %s\", getName(), filename);\n    return python;\n  }","cleancode":"public string exportall(string filename) throws ioexception { string python = langutils.topython(); files.write(paths.get(filename), python.tostring().getbytes()); info(\"saved %s to %s\", getname(), filename); return python; }","comment":"\/\/ currently only support python - maybe in future we'll support js too","repo":"srayner\/myrobotlab","code_context_2":"public String exportAll(String filename) throws IOException {\n\/\/ currently only support python - maybe in future we'll support js too\nString python = LangUtils.toPython();\nFiles.write(Paths.get(filename), python.toString().getBytes());","code_context_10":"public String exportAll(String filename) throws IOException {\n\/\/ currently only support python - maybe in future we'll support js too\nString python = LangUtils.toPython();\nFiles.write(Paths.get(filename), python.toString().getBytes());\ninfo(\"saved %s to %s\", getName(), filename);\nreturn python;\n}","code_context_20":"public String exportAll(String filename) throws IOException {\n\/\/ currently only support python - maybe in future we'll support js too\nString python = LangUtils.toPython();\nFiles.write(Paths.get(filename), python.toString().getBytes());\ninfo(\"saved %s to %s\", getName(), filename);\nreturn python;\n}","label":[1,0,0,0]}
{"id":26189,"original_code":"private void addButtonActionPerformed(java.awt.event.ActionEvent evt) {\/\/GEN-FIRST:event_addButtonActionPerformed\n        try {\n            \/\/ TODO add your handling code here:\n            try {\n                clip.stop();\n            }\n            catch(Exception e) {\n            }\n            try {\n                Class.forName(\"oracle.jdbc.driver.OracleDriver\");\n            } catch (ClassNotFoundException ex) {\n                Logger.getLogger(AdminView.class.getName()).log(Level.SEVERE, null, ex);\n            }\n            \/\/step2 create  the connection object\n            Connection con=DriverManager.getConnection(\n                    \"jdbc:oracle:thin:@localhost:1521:newdatabase\",\"system\",\"not12345\");\n            \/\/step3 create the statement object\n            Statement stmt=con.createStatement();\n            \/\/step4 execute query\n            ResultSet rs=stmt.executeQuery(\"select * from album\");\n            ArrayList<String> albumList = new ArrayList<String>();\n            HashMap<String, String> albumID = new HashMap<>();\n            while(rs.next()) {\n                albumList.add((rs.getString(2)));\n                albumID.put(rs.getString(2), rs.getString(1));\n            }\n            \/\/step4 execute query\n            rs=stmt.executeQuery(\"select * from artist\");\n            ArrayList<String> artistList = new ArrayList<String>();\n            HashMap<String, String> artistID = new HashMap<>();\n            while(rs.next()) {\n                artistList.add((rs.getString(2)));\n                artistID.put(rs.getString(2), rs.getString(1));\n            }\n            \/\/step5 close the connection object\n            con.close();\n            \/\/ TODO add your handling code here:\n\/\/            JTextField id = new JTextField();\n            JTextField name = new JTextField();\n            JTextField genre = new JTextField();\n            JTextField song_num = new JTextField();\n            JComboBox<String> albums = new JComboBox<String>(albumList.toArray(new String[0]));\n            JList artists = new JList(artistList.toArray(new String[0]));\n            artists.setSelectionMode(\n            ListSelectionModel.MULTIPLE_INTERVAL_SELECTION);\n            int[] select = {19, 20, 22};\n            Object[] input = {\n\/\/                \"Id : \", id,\n                \"Name : \", name,\n                \"Genre :\", genre,\n                \"Artist :\", artists,\n                \"Song Number in Album :\", song_num,\n                \"Album :\", albums,\n            };\n            int option = JOptionPane.showConfirmDialog(this, input, \"Enter Song details\", JOptionPane.OK_CANCEL_OPTION);\n            if(option == JOptionPane.OK_OPTION) {\n                JFileChooser jfc = new JFileChooser();\n\t\tint returnValue = jfc.showOpenDialog(null);\n\t\t\/\/ int returnValue = jfc.showSaveDialog(null);\n                String filePath = null;\n\t\tif (returnValue == JFileChooser.APPROVE_OPTION) {\n                    File selectedFile = jfc.getSelectedFile();\n                    System.out.println(selectedFile.getAbsolutePath());\n                    filePath = selectedFile.getAbsolutePath();\n                }\n                 try{  \n                    File f=new File(filePath);  \n                    Class.forName(\"oracle.jdbc.driver.OracleDriver\");  \n                    con = DriverManager.getConnection(\n                             \"jdbc:oracle:thin:@localhost:1521:newdatabase\",\"system\",\"not12345\");\n                    PreparedStatement ps = con.prepareStatement (\"insert into song values(?, ?, ?, ?, ?, ?, ?)\");\n                    ps.setString(1, null);  \n                    ps.setString(2, name.getText());\n                    ps.setString(3, albumID.get(albums.getSelectedItem().toString()));\n                    ps.setString(4, genre.getText());\n                    ps.setInt(5, 0);\n                    ps.setInt(6, Integer.parseInt(song_num.getText()));\n                    System.out.println(\"\"+f.length());\n                    ps.setBytes(7, readFile(filePath));\n                    ps.executeUpdate();\n                    ps.close();\n                    PreparedStatement ps1 = con.prepareStatement (\"select id from song where name=? and album_id=?\");\n                    ps1.setString(1, name.getText());  \n                    ps1.setString(2, albumID.get(albums.getSelectedItem().toString()));\n                    \/\/step4 execute query\n                    ResultSet rs1=ps1.executeQuery();\n                    String id = \"\";\n                    while(rs1.next()) {\n                        id = rs1.getString(1);\n                    }\n                    ps1.close();\n                    for(Object a:artists.getSelectedValuesList()) {\n                        ps = con.prepareCall (\"{call addsongartist(?, ?)}\");\n                        ps.setString(1, id);  \n                        ps.setString(2, artistID.get(a.toString()));\n                        ps.executeUpdate();\n                        ps.close();\n                    }\n                    con.close();  \n                } catch (Exception e) {e.printStackTrace();}  \n                this.updateTable();\n                JOptionPane.showMessageDialog(this, \"Success!\\n\");\n            }\n        } catch (Exception e) {\n            JOptionPane.showMessageDialog(this, \"Error!\\n\"+e.getMessage());\n        }\n    }","code":"private void addButtonActionPerformed(java.awt.event.ActionEvent evt) {        try {\n           \n            try {\n                clip.stop();\n            }\n            catch(Exception e) {\n            }\n            try {\n                Class.forName(\"oracle.jdbc.driver.OracleDriver\");\n            } catch (ClassNotFoundException ex) {\n                Logger.getLogger(AdminView.class.getName()).log(Level.SEVERE, null, ex);\n            }\n           \n            Connection con=DriverManager.getConnection(\n                    \"jdbc:oracle:thin:@localhost:1521:newdatabase\",\"system\",\"not12345\");\n           \n            Statement stmt=con.createStatement();\n           \n            ResultSet rs=stmt.executeQuery(\"select * from album\");\n            ArrayList<String> albumList = new ArrayList<String>();\n            HashMap<String, String> albumID = new HashMap<>();\n            while(rs.next()) {\n                albumList.add((rs.getString(2)));\n                albumID.put(rs.getString(2), rs.getString(1));\n            }\n           \n            rs=stmt.executeQuery(\"select * from artist\");\n            ArrayList<String> artistList = new ArrayList<String>();\n            HashMap<String, String> artistID = new HashMap<>();\n            while(rs.next()) {\n                artistList.add((rs.getString(2)));\n                artistID.put(rs.getString(2), rs.getString(1));\n            }\n           \n            con.close();\n           \n            JTextField name = new JTextField();\n            JTextField genre = new JTextField();\n            JTextField song_num = new JTextField();\n            JComboBox<String> albums = new JComboBox<String>(albumList.toArray(new String[0]));\n            JList artists = new JList(artistList.toArray(new String[0]));\n            artists.setSelectionMode(\n            ListSelectionModel.MULTIPLE_INTERVAL_SELECTION);\n            int[] select = {19, 20, 22};\n            Object[] input = {\n                \"Name : \", name,\n                \"Genre :\", genre,\n                \"Artist :\", artists,\n                \"Song Number in Album :\", song_num,\n                \"Album :\", albums,\n            };\n            int option = JOptionPane.showConfirmDialog(this, input, \"Enter Song details\", JOptionPane.OK_CANCEL_OPTION);\n            if(option == JOptionPane.OK_OPTION) {\n                JFileChooser jfc = new JFileChooser();\n\t\tint returnValue = jfc.showOpenDialog(null);\n\t\n                String filePath = null;\n\t\tif (returnValue == JFileChooser.APPROVE_OPTION) {\n                    File selectedFile = jfc.getSelectedFile();\n                    System.out.println(selectedFile.getAbsolutePath());\n                    filePath = selectedFile.getAbsolutePath();\n                }\n                 try{  \n                    File f=new File(filePath);  \n                    Class.forName(\"oracle.jdbc.driver.OracleDriver\");  \n                    con = DriverManager.getConnection(\n                             \"jdbc:oracle:thin:@localhost:1521:newdatabase\",\"system\",\"not12345\");\n                    PreparedStatement ps = con.prepareStatement (\"insert into song values(?, ?, ?, ?, ?, ?, ?)\");\n                    ps.setString(1, null);  \n                    ps.setString(2, name.getText());\n                    ps.setString(3, albumID.get(albums.getSelectedItem().toString()));\n                    ps.setString(4, genre.getText());\n                    ps.setInt(5, 0);\n                    ps.setInt(6, Integer.parseInt(song_num.getText()));\n                    System.out.println(\"\"+f.length());\n                    ps.setBytes(7, readFile(filePath));\n                    ps.executeUpdate();\n                    ps.close();\n                    PreparedStatement ps1 = con.prepareStatement (\"select id from song where name=? and album_id=?\");\n                    ps1.setString(1, name.getText());  \n                    ps1.setString(2, albumID.get(albums.getSelectedItem().toString()));\n                   \n                    ResultSet rs1=ps1.executeQuery();\n                    String id = \"\";\n                    while(rs1.next()) {\n                        id = rs1.getString(1);\n                    }\n                    ps1.close();\n                    for(Object a:artists.getSelectedValuesList()) {\n                        ps = con.prepareCall (\"{call addsongartist(?, ?)}\");\n                        ps.setString(1, id);  \n                        ps.setString(2, artistID.get(a.toString()));\n                        ps.executeUpdate();\n                        ps.close();\n                    }\n                    con.close();  \n                } catch (Exception e) {e.printStackTrace();}  \n                this.updateTable();\n                JOptionPane.showMessageDialog(this, \"Success!\\n\");\n            }\n        } catch (Exception e) {\n            JOptionPane.showMessageDialog(this, \"Error!\\n\"+e.getMessage());\n        }\n    }","cleancode":"private void addbuttonactionperformed(java.awt.event.actionevent evt) { try { try { clip.stop(); } catch(exception e) { } try { class.forname(\"oracle.jdbc.driver.oracledriver\"); } catch (classnotfoundexception ex) { logger.getlogger(adminview.class.getname()).log(level.severe, null, ex); } connection con=drivermanager.getconnection( \"jdbc:oracle:thin:@localhost:1521:newdatabase\",\"system\",\"not12345\"); statement stmt=con.createstatement(); resultset rs=stmt.executequery(\"select * from album\"); arraylist<string> albumlist = new arraylist<string>(); hashmap<string, string> albumid = new hashmap<>(); while(rs.next()) { albumlist.add((rs.getstring(2))); albumid.put(rs.getstring(2), rs.getstring(1)); } rs=stmt.executequery(\"select * from artist\"); arraylist<string> artistlist = new arraylist<string>(); hashmap<string, string> artistid = new hashmap<>(); while(rs.next()) { artistlist.add((rs.getstring(2))); artistid.put(rs.getstring(2), rs.getstring(1)); } con.close(); jtextfield name = new jtextfield(); jtextfield genre = new jtextfield(); jtextfield song_num = new jtextfield(); jcombobox<string> albums = new jcombobox<string>(albumlist.toarray(new string[0])); jlist artists = new jlist(artistlist.toarray(new string[0])); artists.setselectionmode( listselectionmodel.multiple_interval_selection); int[] select = {19, 20, 22}; object[] input = { \"name : \", name, \"genre :\", genre, \"artist :\", artists, \"song number in album :\", song_num, \"album :\", albums, }; int option = joptionpane.showconfirmdialog(this, input, \"enter song details\", joptionpane.ok_cancel_option); if(option == joptionpane.ok_option) { jfilechooser jfc = new jfilechooser(); int returnvalue = jfc.showopendialog(null); string filepath = null; if (returnvalue == jfilechooser.approve_option) { file selectedfile = jfc.getselectedfile(); system.out.println(selectedfile.getabsolutepath()); filepath = selectedfile.getabsolutepath(); } try{ file f=new file(filepath); class.forname(\"oracle.jdbc.driver.oracledriver\"); con = drivermanager.getconnection( \"jdbc:oracle:thin:@localhost:1521:newdatabase\",\"system\",\"not12345\"); preparedstatement ps = con.preparestatement (\"insert into song values(?, ?, ?, ?, ?, ?, ?)\"); ps.setstring(1, null); ps.setstring(2, name.gettext()); ps.setstring(3, albumid.get(albums.getselecteditem().tostring())); ps.setstring(4, genre.gettext()); ps.setint(5, 0); ps.setint(6, integer.parseint(song_num.gettext())); system.out.println(\"\"+f.length()); ps.setbytes(7, readfile(filepath)); ps.executeupdate(); ps.close(); preparedstatement ps1 = con.preparestatement (\"select id from song where name=? and album_id=?\"); ps1.setstring(1, name.gettext()); ps1.setstring(2, albumid.get(albums.getselecteditem().tostring())); resultset rs1=ps1.executequery(); string id = \"\"; while(rs1.next()) { id = rs1.getstring(1); } ps1.close(); for(object a:artists.getselectedvalueslist()) { ps = con.preparecall (\"{call addsongartist(?, ?)}\"); ps.setstring(1, id); ps.setstring(2, artistid.get(a.tostring())); ps.executeupdate(); ps.close(); } con.close(); } catch (exception e) {e.printstacktrace();} this.updatetable(); joptionpane.showmessagedialog(this, \"success!\\n\"); } } catch (exception e) { joptionpane.showmessagedialog(this, \"error!\\n\"+e.getmessage()); } }","comment":"\/\/gen-first:event_addbuttonactionperformed\n\/\/ todo add your handling code here:\n\/\/step2 create the connection object\n\/\/step3 create the statement object\n\/\/step4 execute query\n\/\/step4 execute query\n\/\/step5 close the connection object\n\/\/ todo add your handling code here: \/\/ jtextfield id = new jtextfield();\n\/\/ \"id : \", id,\n\/\/ int returnvalue = jfc.showsavedialog(null);\n\/\/step4 execute query","repo":"shivamkumar78\/Music_Application","code_context_2":"private void addButtonActionPerformed(java.awt.event.ActionEvent evt) {\/\/GEN-FIRST:event_addButtonActionPerformed\ntry {\n\/\/ TODO add your handling code here:\n\nprivate void addButtonActionPerformed(java.awt.event.ActionEvent evt) {\/\/GEN-FIRST:event_addButtonActionPerformed\ntry {\n\/\/ TODO add your handling code here:\ntry {\nclip.stop();\n\nLogger.getLogger(AdminView.class.getName()).log(Level.SEVERE, null, ex);\n}\n\/\/step2 create the connection object\nConnection con=DriverManager.getConnection(\n\"jdbc:oracle:thin:@localhost:1521:newdatabase\",\"system\",\"not12345\");\n\nConnection con=DriverManager.getConnection(\n\"jdbc:oracle:thin:@localhost:1521:newdatabase\",\"system\",\"not12345\");\n\/\/step3 create the statement object\nStatement stmt=con.createStatement();\n\/\/step4 execute query\n\n\/\/step3 create the statement object\nStatement stmt=con.createStatement();\n\/\/step4 execute query\nResultSet rs=stmt.executeQuery(\"select * from album\");\nArrayList<String> albumList = new ArrayList<String>();\n\n\/\/step3 create the statement object\nStatement stmt=con.createStatement();\n\/\/step4 execute query\nResultSet rs=stmt.executeQuery(\"select * from album\");\nArrayList<String> albumList = new ArrayList<String>();\n\nartistID.put(rs.getString(2), rs.getString(1));\n}\n\/\/step5 close the connection object\ncon.close();\n\/\/ TODO add your handling code here:\n\nprivate void addButtonActionPerformed(java.awt.event.ActionEvent evt) {\/\/GEN-FIRST:event_addButtonActionPerformed\ntry {\n\/\/ TODO add your handling code here:\ntry {\nclip.stop();\n}\n\nint[] select = {19, 20, 22};\nObject[] input = {\n\/\/ \"Id : \", id,\n\"Name : \", name,\n\"Genre :\", genre,\n\nJFileChooser jfc = new JFileChooser();\nint returnValue = jfc.showOpenDialog(null);\n\/\/ int returnValue = jfc.showSaveDialog(null);\nString filePath = null;\nif (returnValue == JFileChooser.APPROVE_OPTION) {\n\n\/\/step3 create the statement object\nStatement stmt=con.createStatement();\n\/\/step4 execute query\nResultSet rs=stmt.executeQuery(\"select * from album\");\nArrayList<String> albumList = new ArrayList<String>();","code_context_10":"private void addButtonActionPerformed(java.awt.event.ActionEvent evt) {\/\/GEN-FIRST:event_addButtonActionPerformed\ntry {\n\/\/ TODO add your handling code here:\ntry {\nclip.stop();\n}\ncatch(Exception e) {\n}\ntry {\nClass.forName(\"oracle.jdbc.driver.OracleDriver\");\n} catch (ClassNotFoundException ex) {\n\nprivate void addButtonActionPerformed(java.awt.event.ActionEvent evt) {\/\/GEN-FIRST:event_addButtonActionPerformed\ntry {\n\/\/ TODO add your handling code here:\ntry {\nclip.stop();\n}\ncatch(Exception e) {\n}\ntry {\nClass.forName(\"oracle.jdbc.driver.OracleDriver\");\n} catch (ClassNotFoundException ex) {\nLogger.getLogger(AdminView.class.getName()).log(Level.SEVERE, null, ex);\n}\n\ntry {\nclip.stop();\n}\ncatch(Exception e) {\n}\ntry {\nClass.forName(\"oracle.jdbc.driver.OracleDriver\");\n} catch (ClassNotFoundException ex) {\nLogger.getLogger(AdminView.class.getName()).log(Level.SEVERE, null, ex);\n}\n\/\/step2 create the connection object\nConnection con=DriverManager.getConnection(\n\"jdbc:oracle:thin:@localhost:1521:newdatabase\",\"system\",\"not12345\");\n\/\/step3 create the statement object\nStatement stmt=con.createStatement();\n\/\/step4 execute query\nResultSet rs=stmt.executeQuery(\"select * from album\");\nArrayList<String> albumList = new ArrayList<String>();\nHashMap<String, String> albumID = new HashMap<>();\nwhile(rs.next()) {\nalbumList.add((rs.getString(2)));\n\ncatch(Exception e) {\n}\ntry {\nClass.forName(\"oracle.jdbc.driver.OracleDriver\");\n} catch (ClassNotFoundException ex) {\nLogger.getLogger(AdminView.class.getName()).log(Level.SEVERE, null, ex);\n}\n\/\/step2 create the connection object\nConnection con=DriverManager.getConnection(\n\"jdbc:oracle:thin:@localhost:1521:newdatabase\",\"system\",\"not12345\");\n\/\/step3 create the statement object\nStatement stmt=con.createStatement();\n\/\/step4 execute query\nResultSet rs=stmt.executeQuery(\"select * from album\");\nArrayList<String> albumList = new ArrayList<String>();\nHashMap<String, String> albumID = new HashMap<>();\nwhile(rs.next()) {\nalbumList.add((rs.getString(2)));\nalbumID.put(rs.getString(2), rs.getString(1));\n}\n\/\/step4 execute query\n\ntry {\nClass.forName(\"oracle.jdbc.driver.OracleDriver\");\n} catch (ClassNotFoundException ex) {\nLogger.getLogger(AdminView.class.getName()).log(Level.SEVERE, null, ex);\n}\n\/\/step2 create the connection object\nConnection con=DriverManager.getConnection(\n\"jdbc:oracle:thin:@localhost:1521:newdatabase\",\"system\",\"not12345\");\n\/\/step3 create the statement object\nStatement stmt=con.createStatement();\n\/\/step4 execute query\nResultSet rs=stmt.executeQuery(\"select * from album\");\nArrayList<String> albumList = new ArrayList<String>();\nHashMap<String, String> albumID = new HashMap<>();\nwhile(rs.next()) {\nalbumList.add((rs.getString(2)));\nalbumID.put(rs.getString(2), rs.getString(1));\n}\n\/\/step4 execute query\nrs=stmt.executeQuery(\"select * from artist\");\nArrayList<String> artistList = new ArrayList<String>();\n\ntry {\nClass.forName(\"oracle.jdbc.driver.OracleDriver\");\n} catch (ClassNotFoundException ex) {\nLogger.getLogger(AdminView.class.getName()).log(Level.SEVERE, null, ex);\n}\n\/\/step2 create the connection object\nConnection con=DriverManager.getConnection(\n\"jdbc:oracle:thin:@localhost:1521:newdatabase\",\"system\",\"not12345\");\n\/\/step3 create the statement object\nStatement stmt=con.createStatement();\n\/\/step4 execute query\nResultSet rs=stmt.executeQuery(\"select * from album\");\nArrayList<String> albumList = new ArrayList<String>();\nHashMap<String, String> albumID = new HashMap<>();\nwhile(rs.next()) {\nalbumList.add((rs.getString(2)));\nalbumID.put(rs.getString(2), rs.getString(1));\n}\n\/\/step4 execute query\nrs=stmt.executeQuery(\"select * from artist\");\nArrayList<String> artistList = new ArrayList<String>();\n\nalbumID.put(rs.getString(2), rs.getString(1));\n}\n\/\/step4 execute query\nrs=stmt.executeQuery(\"select * from artist\");\nArrayList<String> artistList = new ArrayList<String>();\nHashMap<String, String> artistID = new HashMap<>();\nwhile(rs.next()) {\nartistList.add((rs.getString(2)));\nartistID.put(rs.getString(2), rs.getString(1));\n}\n\/\/step5 close the connection object\ncon.close();\n\/\/ TODO add your handling code here:\n\/\/ JTextField id = new JTextField();\nJTextField name = new JTextField();\nJTextField genre = new JTextField();\nJTextField song_num = new JTextField();\nJComboBox<String> albums = new JComboBox<String>(albumList.toArray(new String[0]));\nJList artists = new JList(artistList.toArray(new String[0]));\nartists.setSelectionMode(\nListSelectionModel.MULTIPLE_INTERVAL_SELECTION);\n\nprivate void addButtonActionPerformed(java.awt.event.ActionEvent evt) {\/\/GEN-FIRST:event_addButtonActionPerformed\ntry {\n\/\/ TODO add your handling code here:\ntry {\nclip.stop();\n}\ncatch(Exception e) {\n}\ntry {\nClass.forName(\"oracle.jdbc.driver.OracleDriver\");\n} catch (ClassNotFoundException ex) {\nLogger.getLogger(AdminView.class.getName()).log(Level.SEVERE, null, ex);\n}\n\/\/step2 create the connection object\n\n\/\/ JTextField id = new JTextField();\nJTextField name = new JTextField();\nJTextField genre = new JTextField();\nJTextField song_num = new JTextField();\nJComboBox<String> albums = new JComboBox<String>(albumList.toArray(new String[0]));\nJList artists = new JList(artistList.toArray(new String[0]));\nartists.setSelectionMode(\nListSelectionModel.MULTIPLE_INTERVAL_SELECTION);\nint[] select = {19, 20, 22};\nObject[] input = {\n\/\/ \"Id : \", id,\n\"Name : \", name,\n\"Genre :\", genre,\n\"Artist :\", artists,\n\"Song Number in Album :\", song_num,\n\"Album :\", albums,\n};\nint option = JOptionPane.showConfirmDialog(this, input, \"Enter Song details\", JOptionPane.OK_CANCEL_OPTION);\nif(option == JOptionPane.OK_OPTION) {\nJFileChooser jfc = new JFileChooser();\nint returnValue = jfc.showOpenDialog(null);\n\n\"Name : \", name,\n\"Genre :\", genre,\n\"Artist :\", artists,\n\"Song Number in Album :\", song_num,\n\"Album :\", albums,\n};\nint option = JOptionPane.showConfirmDialog(this, input, \"Enter Song details\", JOptionPane.OK_CANCEL_OPTION);\nif(option == JOptionPane.OK_OPTION) {\nJFileChooser jfc = new JFileChooser();\nint returnValue = jfc.showOpenDialog(null);\n\/\/ int returnValue = jfc.showSaveDialog(null);\nString filePath = null;\nif (returnValue == JFileChooser.APPROVE_OPTION) {\nFile selectedFile = jfc.getSelectedFile();\nSystem.out.println(selectedFile.getAbsolutePath());\nfilePath = selectedFile.getAbsolutePath();\n}\ntry{\nFile f=new File(filePath);\nClass.forName(\"oracle.jdbc.driver.OracleDriver\");\ncon = DriverManager.getConnection(\n\ntry {\nClass.forName(\"oracle.jdbc.driver.OracleDriver\");\n} catch (ClassNotFoundException ex) {\nLogger.getLogger(AdminView.class.getName()).log(Level.SEVERE, null, ex);\n}\n\/\/step2 create the connection object\nConnection con=DriverManager.getConnection(\n\"jdbc:oracle:thin:@localhost:1521:newdatabase\",\"system\",\"not12345\");\n\/\/step3 create the statement object\nStatement stmt=con.createStatement();\n\/\/step4 execute query\nResultSet rs=stmt.executeQuery(\"select * from album\");\nArrayList<String> albumList = new ArrayList<String>();\nHashMap<String, String> albumID = new HashMap<>();\nwhile(rs.next()) {\nalbumList.add((rs.getString(2)));\nalbumID.put(rs.getString(2), rs.getString(1));\n}\n\/\/step4 execute query\nrs=stmt.executeQuery(\"select * from artist\");\nArrayList<String> artistList = new ArrayList<String>();","code_context_20":"private void addButtonActionPerformed(java.awt.event.ActionEvent evt) {\/\/GEN-FIRST:event_addButtonActionPerformed\ntry {\n\/\/ TODO add your handling code here:\ntry {\nclip.stop();\n}\ncatch(Exception e) {\n}\ntry {\nClass.forName(\"oracle.jdbc.driver.OracleDriver\");\n} catch (ClassNotFoundException ex) {\nLogger.getLogger(AdminView.class.getName()).log(Level.SEVERE, null, ex);\n}\n\/\/step2 create the connection object\nConnection con=DriverManager.getConnection(\n\"jdbc:oracle:thin:@localhost:1521:newdatabase\",\"system\",\"not12345\");\n\/\/step3 create the statement object\nStatement stmt=con.createStatement();\n\/\/step4 execute query\nResultSet rs=stmt.executeQuery(\"select * from album\");\nArrayList<String> albumList = new ArrayList<String>();\n\nprivate void addButtonActionPerformed(java.awt.event.ActionEvent evt) {\/\/GEN-FIRST:event_addButtonActionPerformed\ntry {\n\/\/ TODO add your handling code here:\ntry {\nclip.stop();\n}\ncatch(Exception e) {\n}\ntry {\nClass.forName(\"oracle.jdbc.driver.OracleDriver\");\n} catch (ClassNotFoundException ex) {\nLogger.getLogger(AdminView.class.getName()).log(Level.SEVERE, null, ex);\n}\n\/\/step2 create the connection object\nConnection con=DriverManager.getConnection(\n\"jdbc:oracle:thin:@localhost:1521:newdatabase\",\"system\",\"not12345\");\n\/\/step3 create the statement object\nStatement stmt=con.createStatement();\n\/\/step4 execute query\nResultSet rs=stmt.executeQuery(\"select * from album\");\nArrayList<String> albumList = new ArrayList<String>();\nHashMap<String, String> albumID = new HashMap<>();\nwhile(rs.next()) {\n\nprivate void addButtonActionPerformed(java.awt.event.ActionEvent evt) {\/\/GEN-FIRST:event_addButtonActionPerformed\ntry {\n\/\/ TODO add your handling code here:\ntry {\nclip.stop();\n}\ncatch(Exception e) {\n}\ntry {\nClass.forName(\"oracle.jdbc.driver.OracleDriver\");\n} catch (ClassNotFoundException ex) {\nLogger.getLogger(AdminView.class.getName()).log(Level.SEVERE, null, ex);\n}\n\/\/step2 create the connection object\nConnection con=DriverManager.getConnection(\n\"jdbc:oracle:thin:@localhost:1521:newdatabase\",\"system\",\"not12345\");\n\/\/step3 create the statement object\nStatement stmt=con.createStatement();\n\/\/step4 execute query\nResultSet rs=stmt.executeQuery(\"select * from album\");\nArrayList<String> albumList = new ArrayList<String>();\nHashMap<String, String> albumID = new HashMap<>();\nwhile(rs.next()) {\nalbumList.add((rs.getString(2)));\nalbumID.put(rs.getString(2), rs.getString(1));\n}\n\/\/step4 execute query\nrs=stmt.executeQuery(\"select * from artist\");\nArrayList<String> artistList = new ArrayList<String>();\nHashMap<String, String> artistID = new HashMap<>();\nwhile(rs.next()) {\nartistList.add((rs.getString(2)));\nartistID.put(rs.getString(2), rs.getString(1));\n}\n\nprivate void addButtonActionPerformed(java.awt.event.ActionEvent evt) {\/\/GEN-FIRST:event_addButtonActionPerformed\ntry {\n\/\/ TODO add your handling code here:\ntry {\nclip.stop();\n}\ncatch(Exception e) {\n}\ntry {\nClass.forName(\"oracle.jdbc.driver.OracleDriver\");\n} catch (ClassNotFoundException ex) {\nLogger.getLogger(AdminView.class.getName()).log(Level.SEVERE, null, ex);\n}\n\/\/step2 create the connection object\nConnection con=DriverManager.getConnection(\n\"jdbc:oracle:thin:@localhost:1521:newdatabase\",\"system\",\"not12345\");\n\/\/step3 create the statement object\nStatement stmt=con.createStatement();\n\/\/step4 execute query\nResultSet rs=stmt.executeQuery(\"select * from album\");\nArrayList<String> albumList = new ArrayList<String>();\nHashMap<String, String> albumID = new HashMap<>();\nwhile(rs.next()) {\nalbumList.add((rs.getString(2)));\nalbumID.put(rs.getString(2), rs.getString(1));\n}\n\/\/step4 execute query\nrs=stmt.executeQuery(\"select * from artist\");\nArrayList<String> artistList = new ArrayList<String>();\nHashMap<String, String> artistID = new HashMap<>();\nwhile(rs.next()) {\nartistList.add((rs.getString(2)));\nartistID.put(rs.getString(2), rs.getString(1));\n}\n\/\/step5 close the connection object\ncon.close();\n\/\/ TODO add your handling code here:\n\nprivate void addButtonActionPerformed(java.awt.event.ActionEvent evt) {\/\/GEN-FIRST:event_addButtonActionPerformed\ntry {\n\/\/ TODO add your handling code here:\ntry {\nclip.stop();\n}\ncatch(Exception e) {\n}\ntry {\nClass.forName(\"oracle.jdbc.driver.OracleDriver\");\n} catch (ClassNotFoundException ex) {\nLogger.getLogger(AdminView.class.getName()).log(Level.SEVERE, null, ex);\n}\n\/\/step2 create the connection object\nConnection con=DriverManager.getConnection(\n\"jdbc:oracle:thin:@localhost:1521:newdatabase\",\"system\",\"not12345\");\n\/\/step3 create the statement object\nStatement stmt=con.createStatement();\n\/\/step4 execute query\nResultSet rs=stmt.executeQuery(\"select * from album\");\nArrayList<String> albumList = new ArrayList<String>();\nHashMap<String, String> albumID = new HashMap<>();\nwhile(rs.next()) {\nalbumList.add((rs.getString(2)));\nalbumID.put(rs.getString(2), rs.getString(1));\n}\n\/\/step4 execute query\nrs=stmt.executeQuery(\"select * from artist\");\nArrayList<String> artistList = new ArrayList<String>();\nHashMap<String, String> artistID = new HashMap<>();\nwhile(rs.next()) {\nartistList.add((rs.getString(2)));\nartistID.put(rs.getString(2), rs.getString(1));\n}\n\/\/step5 close the connection object\ncon.close();\n\/\/ TODO add your handling code here:\n\/\/ JTextField id = new JTextField();\nJTextField name = new JTextField();\n\nprivate void addButtonActionPerformed(java.awt.event.ActionEvent evt) {\/\/GEN-FIRST:event_addButtonActionPerformed\ntry {\n\/\/ TODO add your handling code here:\ntry {\nclip.stop();\n}\ncatch(Exception e) {\n}\ntry {\nClass.forName(\"oracle.jdbc.driver.OracleDriver\");\n} catch (ClassNotFoundException ex) {\nLogger.getLogger(AdminView.class.getName()).log(Level.SEVERE, null, ex);\n}\n\/\/step2 create the connection object\nConnection con=DriverManager.getConnection(\n\"jdbc:oracle:thin:@localhost:1521:newdatabase\",\"system\",\"not12345\");\n\/\/step3 create the statement object\nStatement stmt=con.createStatement();\n\/\/step4 execute query\nResultSet rs=stmt.executeQuery(\"select * from album\");\nArrayList<String> albumList = new ArrayList<String>();\nHashMap<String, String> albumID = new HashMap<>();\nwhile(rs.next()) {\nalbumList.add((rs.getString(2)));\nalbumID.put(rs.getString(2), rs.getString(1));\n}\n\/\/step4 execute query\nrs=stmt.executeQuery(\"select * from artist\");\nArrayList<String> artistList = new ArrayList<String>();\nHashMap<String, String> artistID = new HashMap<>();\nwhile(rs.next()) {\nartistList.add((rs.getString(2)));\nartistID.put(rs.getString(2), rs.getString(1));\n}\n\/\/step5 close the connection object\ncon.close();\n\/\/ TODO add your handling code here:\n\/\/ JTextField id = new JTextField();\nJTextField name = new JTextField();\n\nConnection con=DriverManager.getConnection(\n\"jdbc:oracle:thin:@localhost:1521:newdatabase\",\"system\",\"not12345\");\n\/\/step3 create the statement object\nStatement stmt=con.createStatement();\n\/\/step4 execute query\nResultSet rs=stmt.executeQuery(\"select * from album\");\nArrayList<String> albumList = new ArrayList<String>();\nHashMap<String, String> albumID = new HashMap<>();\nwhile(rs.next()) {\nalbumList.add((rs.getString(2)));\nalbumID.put(rs.getString(2), rs.getString(1));\n}\n\/\/step4 execute query\nrs=stmt.executeQuery(\"select * from artist\");\nArrayList<String> artistList = new ArrayList<String>();\nHashMap<String, String> artistID = new HashMap<>();\nwhile(rs.next()) {\nartistList.add((rs.getString(2)));\nartistID.put(rs.getString(2), rs.getString(1));\n}\n\/\/step5 close the connection object\ncon.close();\n\/\/ TODO add your handling code here:\n\/\/ JTextField id = new JTextField();\nJTextField name = new JTextField();\nJTextField genre = new JTextField();\nJTextField song_num = new JTextField();\nJComboBox<String> albums = new JComboBox<String>(albumList.toArray(new String[0]));\nJList artists = new JList(artistList.toArray(new String[0]));\nartists.setSelectionMode(\nListSelectionModel.MULTIPLE_INTERVAL_SELECTION);\nint[] select = {19, 20, 22};\nObject[] input = {\n\/\/ \"Id : \", id,\n\"Name : \", name,\n\"Genre :\", genre,\n\"Artist :\", artists,\n\"Song Number in Album :\", song_num,\n\"Album :\", albums,\n};\nint option = JOptionPane.showConfirmDialog(this, input, \"Enter Song details\", JOptionPane.OK_CANCEL_OPTION);\n\nprivate void addButtonActionPerformed(java.awt.event.ActionEvent evt) {\/\/GEN-FIRST:event_addButtonActionPerformed\ntry {\n\/\/ TODO add your handling code here:\ntry {\nclip.stop();\n}\ncatch(Exception e) {\n}\ntry {\nClass.forName(\"oracle.jdbc.driver.OracleDriver\");\n} catch (ClassNotFoundException ex) {\nLogger.getLogger(AdminView.class.getName()).log(Level.SEVERE, null, ex);\n}\n\/\/step2 create the connection object\nConnection con=DriverManager.getConnection(\n\"jdbc:oracle:thin:@localhost:1521:newdatabase\",\"system\",\"not12345\");\n\/\/step3 create the statement object\nStatement stmt=con.createStatement();\n\/\/step4 execute query\nResultSet rs=stmt.executeQuery(\"select * from album\");\nArrayList<String> albumList = new ArrayList<String>();\nHashMap<String, String> albumID = new HashMap<>();\nwhile(rs.next()) {\nalbumList.add((rs.getString(2)));\n\nrs=stmt.executeQuery(\"select * from artist\");\nArrayList<String> artistList = new ArrayList<String>();\nHashMap<String, String> artistID = new HashMap<>();\nwhile(rs.next()) {\nartistList.add((rs.getString(2)));\nartistID.put(rs.getString(2), rs.getString(1));\n}\n\/\/step5 close the connection object\ncon.close();\n\/\/ TODO add your handling code here:\n\/\/ JTextField id = new JTextField();\nJTextField name = new JTextField();\nJTextField genre = new JTextField();\nJTextField song_num = new JTextField();\nJComboBox<String> albums = new JComboBox<String>(albumList.toArray(new String[0]));\nJList artists = new JList(artistList.toArray(new String[0]));\nartists.setSelectionMode(\nListSelectionModel.MULTIPLE_INTERVAL_SELECTION);\nint[] select = {19, 20, 22};\nObject[] input = {\n\/\/ \"Id : \", id,\n\"Name : \", name,\n\"Genre :\", genre,\n\"Artist :\", artists,\n\"Song Number in Album :\", song_num,\n\"Album :\", albums,\n};\nint option = JOptionPane.showConfirmDialog(this, input, \"Enter Song details\", JOptionPane.OK_CANCEL_OPTION);\nif(option == JOptionPane.OK_OPTION) {\nJFileChooser jfc = new JFileChooser();\nint returnValue = jfc.showOpenDialog(null);\n\/\/ int returnValue = jfc.showSaveDialog(null);\nString filePath = null;\nif (returnValue == JFileChooser.APPROVE_OPTION) {\nFile selectedFile = jfc.getSelectedFile();\nSystem.out.println(selectedFile.getAbsolutePath());\nfilePath = selectedFile.getAbsolutePath();\n}\ntry{\nFile f=new File(filePath);\nClass.forName(\"oracle.jdbc.driver.OracleDriver\");\n\nJTextField name = new JTextField();\nJTextField genre = new JTextField();\nJTextField song_num = new JTextField();\nJComboBox<String> albums = new JComboBox<String>(albumList.toArray(new String[0]));\nJList artists = new JList(artistList.toArray(new String[0]));\nartists.setSelectionMode(\nListSelectionModel.MULTIPLE_INTERVAL_SELECTION);\nint[] select = {19, 20, 22};\nObject[] input = {\n\/\/ \"Id : \", id,\n\"Name : \", name,\n\"Genre :\", genre,\n\"Artist :\", artists,\n\"Song Number in Album :\", song_num,\n\"Album :\", albums,\n};\nint option = JOptionPane.showConfirmDialog(this, input, \"Enter Song details\", JOptionPane.OK_CANCEL_OPTION);\nif(option == JOptionPane.OK_OPTION) {\nJFileChooser jfc = new JFileChooser();\nint returnValue = jfc.showOpenDialog(null);\n\/\/ int returnValue = jfc.showSaveDialog(null);\nString filePath = null;\nif (returnValue == JFileChooser.APPROVE_OPTION) {\nFile selectedFile = jfc.getSelectedFile();\nSystem.out.println(selectedFile.getAbsolutePath());\nfilePath = selectedFile.getAbsolutePath();\n}\ntry{\nFile f=new File(filePath);\nClass.forName(\"oracle.jdbc.driver.OracleDriver\");\ncon = DriverManager.getConnection(\n\"jdbc:oracle:thin:@localhost:1521:newdatabase\",\"system\",\"not12345\");\nPreparedStatement ps = con.prepareStatement (\"insert into song values(?, ?, ?, ?, ?, ?, ?)\");\nps.setString(1, null);\nps.setString(2, name.getText());\nps.setString(3, albumID.get(albums.getSelectedItem().toString()));\nps.setString(4, genre.getText());\nps.setInt(5, 0);\nps.setInt(6, Integer.parseInt(song_num.getText()));\nSystem.out.println(\"\"+f.length());\nps.setBytes(7, readFile(filePath));\n\nprivate void addButtonActionPerformed(java.awt.event.ActionEvent evt) {\/\/GEN-FIRST:event_addButtonActionPerformed\ntry {\n\/\/ TODO add your handling code here:\ntry {\nclip.stop();\n}\ncatch(Exception e) {\n}\ntry {\nClass.forName(\"oracle.jdbc.driver.OracleDriver\");\n} catch (ClassNotFoundException ex) {\nLogger.getLogger(AdminView.class.getName()).log(Level.SEVERE, null, ex);\n}\n\/\/step2 create the connection object\nConnection con=DriverManager.getConnection(\n\"jdbc:oracle:thin:@localhost:1521:newdatabase\",\"system\",\"not12345\");\n\/\/step3 create the statement object\nStatement stmt=con.createStatement();\n\/\/step4 execute query\nResultSet rs=stmt.executeQuery(\"select * from album\");\nArrayList<String> albumList = new ArrayList<String>();\nHashMap<String, String> albumID = new HashMap<>();\nwhile(rs.next()) {\nalbumList.add((rs.getString(2)));\nalbumID.put(rs.getString(2), rs.getString(1));\n}\n\/\/step4 execute query\nrs=stmt.executeQuery(\"select * from artist\");\nArrayList<String> artistList = new ArrayList<String>();\nHashMap<String, String> artistID = new HashMap<>();\nwhile(rs.next()) {\nartistList.add((rs.getString(2)));\nartistID.put(rs.getString(2), rs.getString(1));\n}\n\/\/step5 close the connection object\ncon.close();\n\/\/ TODO add your handling code here:\n\/\/ JTextField id = new JTextField();\nJTextField name = new JTextField();","label":[0,1,0,0]}
{"id":26190,"original_code":"private void addArtistActionPerformed(java.awt.event.ActionEvent evt) {\/\/GEN-FIRST:event_addArtistActionPerformed\n        \/\/ TODO add your handling code here:\n        try {\n            \/\/ TODO add your handling code here:\n            searchText.setText(\"\");\n            try {\n                Class.forName(\"oracle.jdbc.driver.OracleDriver\");\n            } catch (ClassNotFoundException ex) {\n                Logger.getLogger(AdminView.class.getName()).log(Level.SEVERE, null, ex);\n            }\n            \/\/ TODO add your handling code here:\n\/\/            JTextField id = new JTextField();\n            JTextField name = new JTextField();\n            JTextField about = new JTextField();\n            Object[] input = {\n\/\/                \"Id : \", id,\n                \"Name : \", name,\n                \"About : \", about,\n            };\n            int option = JOptionPane.showConfirmDialog(this, input, \"Enter Artist details\", JOptionPane.OK_CANCEL_OPTION);\n            if(option == JOptionPane.OK_OPTION) {\n                 try{  \n                    Class.forName(\"oracle.jdbc.driver.OracleDriver\");  \n                     Connection con = DriverManager.getConnection(\n                             \"jdbc:oracle:thin:@localhost:1521:newdatabase\",\"system\",\"not12345\");\n                    CallableStatement ps = con.prepareCall (\"{call addartist(?, ?, ?)}\");\n                    ps.setString(1,null);  \n                    ps.setString(2, name.getText());\n                    ps.setString(3, about.getText());\n                    ps.executeUpdate();\n                    ps.close();\n                    con.close();  \n                } catch (Exception e) {e.printStackTrace();}  \n                JOptionPane.showMessageDialog(this, \"Success!\\n\");\n            }\n        } catch (Exception e) {\n            JOptionPane.showMessageDialog(this, \"Error!\\n\"+e.getMessage());\n        }\n    }","code":"private void addArtistActionPerformed(java.awt.event.ActionEvent evt) {       \n        try {\n           \n            searchText.setText(\"\");\n            try {\n                Class.forName(\"oracle.jdbc.driver.OracleDriver\");\n            } catch (ClassNotFoundException ex) {\n                Logger.getLogger(AdminView.class.getName()).log(Level.SEVERE, null, ex);\n            }\n           \n            JTextField name = new JTextField();\n            JTextField about = new JTextField();\n            Object[] input = {\n                \"Name : \", name,\n                \"About : \", about,\n            };\n            int option = JOptionPane.showConfirmDialog(this, input, \"Enter Artist details\", JOptionPane.OK_CANCEL_OPTION);\n            if(option == JOptionPane.OK_OPTION) {\n                 try{  \n                    Class.forName(\"oracle.jdbc.driver.OracleDriver\");  \n                     Connection con = DriverManager.getConnection(\n                             \"jdbc:oracle:thin:@localhost:1521:newdatabase\",\"system\",\"not12345\");\n                    CallableStatement ps = con.prepareCall (\"{call addartist(?, ?, ?)}\");\n                    ps.setString(1,null);  \n                    ps.setString(2, name.getText());\n                    ps.setString(3, about.getText());\n                    ps.executeUpdate();\n                    ps.close();\n                    con.close();  \n                } catch (Exception e) {e.printStackTrace();}  \n                JOptionPane.showMessageDialog(this, \"Success!\\n\");\n            }\n        } catch (Exception e) {\n            JOptionPane.showMessageDialog(this, \"Error!\\n\"+e.getMessage());\n        }\n    }","cleancode":"private void addartistactionperformed(java.awt.event.actionevent evt) { try { searchtext.settext(\"\"); try { class.forname(\"oracle.jdbc.driver.oracledriver\"); } catch (classnotfoundexception ex) { logger.getlogger(adminview.class.getname()).log(level.severe, null, ex); } jtextfield name = new jtextfield(); jtextfield about = new jtextfield(); object[] input = { \"name : \", name, \"about : \", about, }; int option = joptionpane.showconfirmdialog(this, input, \"enter artist details\", joptionpane.ok_cancel_option); if(option == joptionpane.ok_option) { try{ class.forname(\"oracle.jdbc.driver.oracledriver\"); connection con = drivermanager.getconnection( \"jdbc:oracle:thin:@localhost:1521:newdatabase\",\"system\",\"not12345\"); callablestatement ps = con.preparecall (\"{call addartist(?, ?, ?)}\"); ps.setstring(1,null); ps.setstring(2, name.gettext()); ps.setstring(3, about.gettext()); ps.executeupdate(); ps.close(); con.close(); } catch (exception e) {e.printstacktrace();} joptionpane.showmessagedialog(this, \"success!\\n\"); } } catch (exception e) { joptionpane.showmessagedialog(this, \"error!\\n\"+e.getmessage()); } }","comment":"\/\/gen-first:event_addartistactionperformed\n\/\/ todo add your handling code here:\n\/\/ todo add your handling code here:\n\/\/ todo add your handling code here: \/\/ jtextfield id = new jtextfield();\n\/\/ \"id : \", id,","repo":"shivamkumar78\/Music_Application","code_context_2":"private void addArtistActionPerformed(java.awt.event.ActionEvent evt) {\/\/GEN-FIRST:event_addArtistActionPerformed\n\/\/ TODO add your handling code here:\ntry {\n\nprivate void addArtistActionPerformed(java.awt.event.ActionEvent evt) {\/\/GEN-FIRST:event_addArtistActionPerformed\n\/\/ TODO add your handling code here:\ntry {\n\/\/ TODO add your handling code here:\n\nprivate void addArtistActionPerformed(java.awt.event.ActionEvent evt) {\/\/GEN-FIRST:event_addArtistActionPerformed\n\/\/ TODO add your handling code here:\ntry {\n\/\/ TODO add your handling code here:\n\nprivate void addArtistActionPerformed(java.awt.event.ActionEvent evt) {\/\/GEN-FIRST:event_addArtistActionPerformed\n\/\/ TODO add your handling code here:\ntry {\n\/\/ TODO add your handling code here:\nsearchText.setText(\"\");\n\nJTextField about = new JTextField();\nObject[] input = {\n\/\/ \"Id : \", id,\n\"Name : \", name,\n\"About : \", about,","code_context_10":"private void addArtistActionPerformed(java.awt.event.ActionEvent evt) {\/\/GEN-FIRST:event_addArtistActionPerformed\n\/\/ TODO add your handling code here:\ntry {\n\/\/ TODO add your handling code here:\nsearchText.setText(\"\");\ntry {\nClass.forName(\"oracle.jdbc.driver.OracleDriver\");\n} catch (ClassNotFoundException ex) {\nLogger.getLogger(AdminView.class.getName()).log(Level.SEVERE, null, ex);\n}\n\/\/ TODO add your handling code here:\n\nprivate void addArtistActionPerformed(java.awt.event.ActionEvent evt) {\/\/GEN-FIRST:event_addArtistActionPerformed\n\/\/ TODO add your handling code here:\ntry {\n\/\/ TODO add your handling code here:\nsearchText.setText(\"\");\ntry {\nClass.forName(\"oracle.jdbc.driver.OracleDriver\");\n} catch (ClassNotFoundException ex) {\nLogger.getLogger(AdminView.class.getName()).log(Level.SEVERE, null, ex);\n}\n\/\/ TODO add your handling code here:\n\/\/ JTextField id = new JTextField();\n\nprivate void addArtistActionPerformed(java.awt.event.ActionEvent evt) {\/\/GEN-FIRST:event_addArtistActionPerformed\n\/\/ TODO add your handling code here:\ntry {\n\/\/ TODO add your handling code here:\nsearchText.setText(\"\");\ntry {\nClass.forName(\"oracle.jdbc.driver.OracleDriver\");\n} catch (ClassNotFoundException ex) {\nLogger.getLogger(AdminView.class.getName()).log(Level.SEVERE, null, ex);\n}\n\/\/ TODO add your handling code here:\n\/\/ JTextField id = new JTextField();\n\nprivate void addArtistActionPerformed(java.awt.event.ActionEvent evt) {\/\/GEN-FIRST:event_addArtistActionPerformed\n\/\/ TODO add your handling code here:\ntry {\n\/\/ TODO add your handling code here:\nsearchText.setText(\"\");\ntry {\nClass.forName(\"oracle.jdbc.driver.OracleDriver\");\n} catch (ClassNotFoundException ex) {\nLogger.getLogger(AdminView.class.getName()).log(Level.SEVERE, null, ex);\n}\n\/\/ TODO add your handling code here:\n\/\/ JTextField id = new JTextField();\nJTextField name = new JTextField();\n\ntry {\nClass.forName(\"oracle.jdbc.driver.OracleDriver\");\n} catch (ClassNotFoundException ex) {\nLogger.getLogger(AdminView.class.getName()).log(Level.SEVERE, null, ex);\n}\n\/\/ TODO add your handling code here:\n\/\/ JTextField id = new JTextField();\nJTextField name = new JTextField();\nJTextField about = new JTextField();\nObject[] input = {\n\/\/ \"Id : \", id,\n\"Name : \", name,\n\"About : \", about,\n};\nint option = JOptionPane.showConfirmDialog(this, input, \"Enter Artist details\", JOptionPane.OK_CANCEL_OPTION);\nif(option == JOptionPane.OK_OPTION) {\ntry{\nClass.forName(\"oracle.jdbc.driver.OracleDriver\");\nConnection con = DriverManager.getConnection(\n\"jdbc:oracle:thin:@localhost:1521:newdatabase\",\"system\",\"not12345\");\nCallableStatement ps = con.prepareCall (\"{call addartist(?, ?, ?)}\");","code_context_20":"private void addArtistActionPerformed(java.awt.event.ActionEvent evt) {\/\/GEN-FIRST:event_addArtistActionPerformed\n\/\/ TODO add your handling code here:\ntry {\n\/\/ TODO add your handling code here:\nsearchText.setText(\"\");\ntry {\nClass.forName(\"oracle.jdbc.driver.OracleDriver\");\n} catch (ClassNotFoundException ex) {\nLogger.getLogger(AdminView.class.getName()).log(Level.SEVERE, null, ex);\n}\n\/\/ TODO add your handling code here:\n\/\/ JTextField id = new JTextField();\nJTextField name = new JTextField();\nJTextField about = new JTextField();\nObject[] input = {\n\/\/ \"Id : \", id,\n\"Name : \", name,\n\"About : \", about,\n};\nint option = JOptionPane.showConfirmDialog(this, input, \"Enter Artist details\", JOptionPane.OK_CANCEL_OPTION);\nif(option == JOptionPane.OK_OPTION) {\n\nprivate void addArtistActionPerformed(java.awt.event.ActionEvent evt) {\/\/GEN-FIRST:event_addArtistActionPerformed\n\/\/ TODO add your handling code here:\ntry {\n\/\/ TODO add your handling code here:\nsearchText.setText(\"\");\ntry {\nClass.forName(\"oracle.jdbc.driver.OracleDriver\");\n} catch (ClassNotFoundException ex) {\nLogger.getLogger(AdminView.class.getName()).log(Level.SEVERE, null, ex);\n}\n\/\/ TODO add your handling code here:\n\/\/ JTextField id = new JTextField();\nJTextField name = new JTextField();\nJTextField about = new JTextField();\nObject[] input = {\n\/\/ \"Id : \", id,\n\"Name : \", name,\n\"About : \", about,\n};\nint option = JOptionPane.showConfirmDialog(this, input, \"Enter Artist details\", JOptionPane.OK_CANCEL_OPTION);\nif(option == JOptionPane.OK_OPTION) {\ntry{\n\nprivate void addArtistActionPerformed(java.awt.event.ActionEvent evt) {\/\/GEN-FIRST:event_addArtistActionPerformed\n\/\/ TODO add your handling code here:\ntry {\n\/\/ TODO add your handling code here:\nsearchText.setText(\"\");\ntry {\nClass.forName(\"oracle.jdbc.driver.OracleDriver\");\n} catch (ClassNotFoundException ex) {\nLogger.getLogger(AdminView.class.getName()).log(Level.SEVERE, null, ex);\n}\n\/\/ TODO add your handling code here:\n\/\/ JTextField id = new JTextField();\nJTextField name = new JTextField();\nJTextField about = new JTextField();\nObject[] input = {\n\/\/ \"Id : \", id,\n\"Name : \", name,\n\"About : \", about,\n};\nint option = JOptionPane.showConfirmDialog(this, input, \"Enter Artist details\", JOptionPane.OK_CANCEL_OPTION);\nif(option == JOptionPane.OK_OPTION) {\ntry{\n\nprivate void addArtistActionPerformed(java.awt.event.ActionEvent evt) {\/\/GEN-FIRST:event_addArtistActionPerformed\n\/\/ TODO add your handling code here:\ntry {\n\/\/ TODO add your handling code here:\nsearchText.setText(\"\");\ntry {\nClass.forName(\"oracle.jdbc.driver.OracleDriver\");\n} catch (ClassNotFoundException ex) {\nLogger.getLogger(AdminView.class.getName()).log(Level.SEVERE, null, ex);\n}\n\/\/ TODO add your handling code here:\n\/\/ JTextField id = new JTextField();\nJTextField name = new JTextField();\nJTextField about = new JTextField();\nObject[] input = {\n\/\/ \"Id : \", id,\n\"Name : \", name,\n\"About : \", about,\n};\nint option = JOptionPane.showConfirmDialog(this, input, \"Enter Artist details\", JOptionPane.OK_CANCEL_OPTION);\nif(option == JOptionPane.OK_OPTION) {\ntry{\nClass.forName(\"oracle.jdbc.driver.OracleDriver\");\n\nprivate void addArtistActionPerformed(java.awt.event.ActionEvent evt) {\/\/GEN-FIRST:event_addArtistActionPerformed\n\/\/ TODO add your handling code here:\ntry {\n\/\/ TODO add your handling code here:\nsearchText.setText(\"\");\ntry {\nClass.forName(\"oracle.jdbc.driver.OracleDriver\");\n} catch (ClassNotFoundException ex) {\nLogger.getLogger(AdminView.class.getName()).log(Level.SEVERE, null, ex);\n}\n\/\/ TODO add your handling code here:\n\/\/ JTextField id = new JTextField();\nJTextField name = new JTextField();\nJTextField about = new JTextField();\nObject[] input = {\n\/\/ \"Id : \", id,\n\"Name : \", name,\n\"About : \", about,\n};\nint option = JOptionPane.showConfirmDialog(this, input, \"Enter Artist details\", JOptionPane.OK_CANCEL_OPTION);\nif(option == JOptionPane.OK_OPTION) {\ntry{\nClass.forName(\"oracle.jdbc.driver.OracleDriver\");\nConnection con = DriverManager.getConnection(\n\"jdbc:oracle:thin:@localhost:1521:newdatabase\",\"system\",\"not12345\");\nCallableStatement ps = con.prepareCall (\"{call addartist(?, ?, ?)}\");\nps.setString(1,null);\nps.setString(2, name.getText());\nps.setString(3, about.getText());\nps.executeUpdate();\nps.close();\ncon.close();\n} catch (Exception e) {e.printStackTrace();}\nJOptionPane.showMessageDialog(this, \"Success!\\n\");\n}\n} catch (Exception e) {","label":[0,1,0,0]}
{"id":26191,"original_code":"private void addAlbumActionPerformed(java.awt.event.ActionEvent evt) {\/\/GEN-FIRST:event_addAlbumActionPerformed\n        \/\/ TODO add your handling code here:\n        try {\n            \/\/ TODO add your handling code here:\n            try {\n                Class.forName(\"oracle.jdbc.driver.OracleDriver\");\n            } catch (ClassNotFoundException ex) {\n                Logger.getLogger(AdminView.class.getName()).log(Level.SEVERE, null, ex);\n            }\n            \/\/ TODO add your handling code here:\n\/\/            JTextField id = new JTextField();\n            JTextField name = new JTextField();\n            Object[] input = {\n\/\/                \"Id : \", id,\n                \"Name : \", name,\n            };\n            int option = JOptionPane.showConfirmDialog(this, input, \"Enter Album details\", JOptionPane.OK_CANCEL_OPTION);\n            if(option == JOptionPane.OK_OPTION) {\n                 try{  \n                    Class.forName(\"oracle.jdbc.driver.OracleDriver\");  \n                    Connection con = DriverManager.getConnection(\n                             \"jdbc:oracle:thin:@localhost:1521:newdatabase\",\"system\",\"not12345\");\n                    CallableStatement ps = con.prepareCall (\"{call addalbum(?, ?)}\");\n                    ps.setString(1, null);  \n                    ps.setString(2, name.getText());\n                    ps.executeUpdate();\n                    ps.close();\n                    con.close();  \n                } catch (Exception e) {e.printStackTrace();}  \n                JOptionPane.showMessageDialog(this, \"Success!\\n\");\n            }\n        } catch (Exception e) {\n            JOptionPane.showMessageDialog(this, \"Error!\\n\"+e.getMessage());\n        }\n    }","code":"private void addAlbumActionPerformed(java.awt.event.ActionEvent evt) {       \n        try {\n           \n            try {\n                Class.forName(\"oracle.jdbc.driver.OracleDriver\");\n            } catch (ClassNotFoundException ex) {\n                Logger.getLogger(AdminView.class.getName()).log(Level.SEVERE, null, ex);\n            }\n           \n            JTextField name = new JTextField();\n            Object[] input = {\n                \"Name : \", name,\n            };\n            int option = JOptionPane.showConfirmDialog(this, input, \"Enter Album details\", JOptionPane.OK_CANCEL_OPTION);\n            if(option == JOptionPane.OK_OPTION) {\n                 try{  \n                    Class.forName(\"oracle.jdbc.driver.OracleDriver\");  \n                    Connection con = DriverManager.getConnection(\n                             \"jdbc:oracle:thin:@localhost:1521:newdatabase\",\"system\",\"not12345\");\n                    CallableStatement ps = con.prepareCall (\"{call addalbum(?, ?)}\");\n                    ps.setString(1, null);  \n                    ps.setString(2, name.getText());\n                    ps.executeUpdate();\n                    ps.close();\n                    con.close();  \n                } catch (Exception e) {e.printStackTrace();}  \n                JOptionPane.showMessageDialog(this, \"Success!\\n\");\n            }\n        } catch (Exception e) {\n            JOptionPane.showMessageDialog(this, \"Error!\\n\"+e.getMessage());\n        }\n    }","cleancode":"private void addalbumactionperformed(java.awt.event.actionevent evt) { try { try { class.forname(\"oracle.jdbc.driver.oracledriver\"); } catch (classnotfoundexception ex) { logger.getlogger(adminview.class.getname()).log(level.severe, null, ex); } jtextfield name = new jtextfield(); object[] input = { \"name : \", name, }; int option = joptionpane.showconfirmdialog(this, input, \"enter album details\", joptionpane.ok_cancel_option); if(option == joptionpane.ok_option) { try{ class.forname(\"oracle.jdbc.driver.oracledriver\"); connection con = drivermanager.getconnection( \"jdbc:oracle:thin:@localhost:1521:newdatabase\",\"system\",\"not12345\"); callablestatement ps = con.preparecall (\"{call addalbum(?, ?)}\"); ps.setstring(1, null); ps.setstring(2, name.gettext()); ps.executeupdate(); ps.close(); con.close(); } catch (exception e) {e.printstacktrace();} joptionpane.showmessagedialog(this, \"success!\\n\"); } } catch (exception e) { joptionpane.showmessagedialog(this, \"error!\\n\"+e.getmessage()); } }","comment":"\/\/gen-first:event_addalbumactionperformed\n\/\/ todo add your handling code here:\n\/\/ todo add your handling code here:\n\/\/ todo add your handling code here: \/\/ jtextfield id = new jtextfield();\n\/\/ \"id : \", id,","repo":"shivamkumar78\/Music_Application","code_context_2":"private void addAlbumActionPerformed(java.awt.event.ActionEvent evt) {\/\/GEN-FIRST:event_addAlbumActionPerformed\n\/\/ TODO add your handling code here:\ntry {\n\nprivate void addAlbumActionPerformed(java.awt.event.ActionEvent evt) {\/\/GEN-FIRST:event_addAlbumActionPerformed\n\/\/ TODO add your handling code here:\ntry {\n\/\/ TODO add your handling code here:\n\nprivate void addAlbumActionPerformed(java.awt.event.ActionEvent evt) {\/\/GEN-FIRST:event_addAlbumActionPerformed\n\/\/ TODO add your handling code here:\ntry {\n\/\/ TODO add your handling code here:\n\nprivate void addAlbumActionPerformed(java.awt.event.ActionEvent evt) {\/\/GEN-FIRST:event_addAlbumActionPerformed\n\/\/ TODO add your handling code here:\ntry {\n\/\/ TODO add your handling code here:\ntry {\n\nJTextField name = new JTextField();\nObject[] input = {\n\/\/ \"Id : \", id,\n\"Name : \", name,\n};","code_context_10":"private void addAlbumActionPerformed(java.awt.event.ActionEvent evt) {\/\/GEN-FIRST:event_addAlbumActionPerformed\n\/\/ TODO add your handling code here:\ntry {\n\/\/ TODO add your handling code here:\ntry {\nClass.forName(\"oracle.jdbc.driver.OracleDriver\");\n} catch (ClassNotFoundException ex) {\nLogger.getLogger(AdminView.class.getName()).log(Level.SEVERE, null, ex);\n}\n\/\/ TODO add your handling code here:\n\/\/ JTextField id = new JTextField();\n\nprivate void addAlbumActionPerformed(java.awt.event.ActionEvent evt) {\/\/GEN-FIRST:event_addAlbumActionPerformed\n\/\/ TODO add your handling code here:\ntry {\n\/\/ TODO add your handling code here:\ntry {\nClass.forName(\"oracle.jdbc.driver.OracleDriver\");\n} catch (ClassNotFoundException ex) {\nLogger.getLogger(AdminView.class.getName()).log(Level.SEVERE, null, ex);\n}\n\/\/ TODO add your handling code here:\n\/\/ JTextField id = new JTextField();\nJTextField name = new JTextField();\n\nprivate void addAlbumActionPerformed(java.awt.event.ActionEvent evt) {\/\/GEN-FIRST:event_addAlbumActionPerformed\n\/\/ TODO add your handling code here:\ntry {\n\/\/ TODO add your handling code here:\ntry {\nClass.forName(\"oracle.jdbc.driver.OracleDriver\");\n} catch (ClassNotFoundException ex) {\nLogger.getLogger(AdminView.class.getName()).log(Level.SEVERE, null, ex);\n}\n\/\/ TODO add your handling code here:\n\/\/ JTextField id = new JTextField();\nJTextField name = new JTextField();\n\nprivate void addAlbumActionPerformed(java.awt.event.ActionEvent evt) {\/\/GEN-FIRST:event_addAlbumActionPerformed\n\/\/ TODO add your handling code here:\ntry {\n\/\/ TODO add your handling code here:\ntry {\nClass.forName(\"oracle.jdbc.driver.OracleDriver\");\n} catch (ClassNotFoundException ex) {\nLogger.getLogger(AdminView.class.getName()).log(Level.SEVERE, null, ex);\n}\n\/\/ TODO add your handling code here:\n\/\/ JTextField id = new JTextField();\nJTextField name = new JTextField();\nObject[] input = {\n\n\/\/ TODO add your handling code here:\ntry {\nClass.forName(\"oracle.jdbc.driver.OracleDriver\");\n} catch (ClassNotFoundException ex) {\nLogger.getLogger(AdminView.class.getName()).log(Level.SEVERE, null, ex);\n}\n\/\/ TODO add your handling code here:\n\/\/ JTextField id = new JTextField();\nJTextField name = new JTextField();\nObject[] input = {\n\/\/ \"Id : \", id,\n\"Name : \", name,\n};\nint option = JOptionPane.showConfirmDialog(this, input, \"Enter Album details\", JOptionPane.OK_CANCEL_OPTION);\nif(option == JOptionPane.OK_OPTION) {\ntry{\nClass.forName(\"oracle.jdbc.driver.OracleDriver\");\nConnection con = DriverManager.getConnection(\n\"jdbc:oracle:thin:@localhost:1521:newdatabase\",\"system\",\"not12345\");\nCallableStatement ps = con.prepareCall (\"{call addalbum(?, ?)}\");\nps.setString(1, null);","code_context_20":"private void addAlbumActionPerformed(java.awt.event.ActionEvent evt) {\/\/GEN-FIRST:event_addAlbumActionPerformed\n\/\/ TODO add your handling code here:\ntry {\n\/\/ TODO add your handling code here:\ntry {\nClass.forName(\"oracle.jdbc.driver.OracleDriver\");\n} catch (ClassNotFoundException ex) {\nLogger.getLogger(AdminView.class.getName()).log(Level.SEVERE, null, ex);\n}\n\/\/ TODO add your handling code here:\n\/\/ JTextField id = new JTextField();\nJTextField name = new JTextField();\nObject[] input = {\n\/\/ \"Id : \", id,\n\"Name : \", name,\n};\nint option = JOptionPane.showConfirmDialog(this, input, \"Enter Album details\", JOptionPane.OK_CANCEL_OPTION);\nif(option == JOptionPane.OK_OPTION) {\ntry{\nClass.forName(\"oracle.jdbc.driver.OracleDriver\");\nConnection con = DriverManager.getConnection(\n\nprivate void addAlbumActionPerformed(java.awt.event.ActionEvent evt) {\/\/GEN-FIRST:event_addAlbumActionPerformed\n\/\/ TODO add your handling code here:\ntry {\n\/\/ TODO add your handling code here:\ntry {\nClass.forName(\"oracle.jdbc.driver.OracleDriver\");\n} catch (ClassNotFoundException ex) {\nLogger.getLogger(AdminView.class.getName()).log(Level.SEVERE, null, ex);\n}\n\/\/ TODO add your handling code here:\n\/\/ JTextField id = new JTextField();\nJTextField name = new JTextField();\nObject[] input = {\n\/\/ \"Id : \", id,\n\"Name : \", name,\n};\nint option = JOptionPane.showConfirmDialog(this, input, \"Enter Album details\", JOptionPane.OK_CANCEL_OPTION);\nif(option == JOptionPane.OK_OPTION) {\ntry{\nClass.forName(\"oracle.jdbc.driver.OracleDriver\");\nConnection con = DriverManager.getConnection(\n\"jdbc:oracle:thin:@localhost:1521:newdatabase\",\"system\",\"not12345\");\n\nprivate void addAlbumActionPerformed(java.awt.event.ActionEvent evt) {\/\/GEN-FIRST:event_addAlbumActionPerformed\n\/\/ TODO add your handling code here:\ntry {\n\/\/ TODO add your handling code here:\ntry {\nClass.forName(\"oracle.jdbc.driver.OracleDriver\");\n} catch (ClassNotFoundException ex) {\nLogger.getLogger(AdminView.class.getName()).log(Level.SEVERE, null, ex);\n}\n\/\/ TODO add your handling code here:\n\/\/ JTextField id = new JTextField();\nJTextField name = new JTextField();\nObject[] input = {\n\/\/ \"Id : \", id,\n\"Name : \", name,\n};\nint option = JOptionPane.showConfirmDialog(this, input, \"Enter Album details\", JOptionPane.OK_CANCEL_OPTION);\nif(option == JOptionPane.OK_OPTION) {\ntry{\nClass.forName(\"oracle.jdbc.driver.OracleDriver\");\nConnection con = DriverManager.getConnection(\n\"jdbc:oracle:thin:@localhost:1521:newdatabase\",\"system\",\"not12345\");\n\nprivate void addAlbumActionPerformed(java.awt.event.ActionEvent evt) {\/\/GEN-FIRST:event_addAlbumActionPerformed\n\/\/ TODO add your handling code here:\ntry {\n\/\/ TODO add your handling code here:\ntry {\nClass.forName(\"oracle.jdbc.driver.OracleDriver\");\n} catch (ClassNotFoundException ex) {\nLogger.getLogger(AdminView.class.getName()).log(Level.SEVERE, null, ex);\n}\n\/\/ TODO add your handling code here:\n\/\/ JTextField id = new JTextField();\nJTextField name = new JTextField();\nObject[] input = {\n\/\/ \"Id : \", id,\n\"Name : \", name,\n};\nint option = JOptionPane.showConfirmDialog(this, input, \"Enter Album details\", JOptionPane.OK_CANCEL_OPTION);\nif(option == JOptionPane.OK_OPTION) {\ntry{\nClass.forName(\"oracle.jdbc.driver.OracleDriver\");\nConnection con = DriverManager.getConnection(\n\"jdbc:oracle:thin:@localhost:1521:newdatabase\",\"system\",\"not12345\");\nCallableStatement ps = con.prepareCall (\"{call addalbum(?, ?)}\");\n\nprivate void addAlbumActionPerformed(java.awt.event.ActionEvent evt) {\/\/GEN-FIRST:event_addAlbumActionPerformed\n\/\/ TODO add your handling code here:\ntry {\n\/\/ TODO add your handling code here:\ntry {\nClass.forName(\"oracle.jdbc.driver.OracleDriver\");\n} catch (ClassNotFoundException ex) {\nLogger.getLogger(AdminView.class.getName()).log(Level.SEVERE, null, ex);\n}\n\/\/ TODO add your handling code here:\n\/\/ JTextField id = new JTextField();\nJTextField name = new JTextField();\nObject[] input = {\n\/\/ \"Id : \", id,\n\"Name : \", name,\n};\nint option = JOptionPane.showConfirmDialog(this, input, \"Enter Album details\", JOptionPane.OK_CANCEL_OPTION);\nif(option == JOptionPane.OK_OPTION) {\ntry{\nClass.forName(\"oracle.jdbc.driver.OracleDriver\");\nConnection con = DriverManager.getConnection(\n\"jdbc:oracle:thin:@localhost:1521:newdatabase\",\"system\",\"not12345\");\nCallableStatement ps = con.prepareCall (\"{call addalbum(?, ?)}\");\nps.setString(1, null);\nps.setString(2, name.getText());\nps.executeUpdate();\nps.close();\ncon.close();\n} catch (Exception e) {e.printStackTrace();}\nJOptionPane.showMessageDialog(this, \"Success!\\n\");\n}\n} catch (Exception e) {\nJOptionPane.showMessageDialog(this, \"Error!\\n\"+e.getMessage());\n}","label":[0,1,0,0]}
{"id":26243,"original_code":"public RunResult run(RunDecision runDecision) throws DetectUserFriendlyException, InterruptedException, IntegrationException {\n        \/\/TODO: Better way for run manager to get dependencies so he can be tested. (And better ways of creating his objects)\n        final DetectConfiguration detectConfiguration = detectContext.getBean(DetectConfiguration.class);\n        final DetectConfigurationFactory detectConfigurationFactory = detectContext.getBean(DetectConfigurationFactory.class);\n        final DirectoryManager directoryManager = detectContext.getBean(DirectoryManager.class);\n        final EventSystem eventSystem = detectContext.getBean(EventSystem.class);\n        final CodeLocationNameManager codeLocationNameManager = detectContext.getBean(CodeLocationNameManager.class);\n        final BdioCodeLocationCreator bdioCodeLocationCreator = detectContext.getBean(BdioCodeLocationCreator.class);\n        final ConnectionManager connectionManager = detectContext.getBean(ConnectionManager.class);\n        final DetectInfo detectInfo = detectContext.getBean(DetectInfo.class);\n        final RunResult runResult = new RunResult();\n        final RunOptions runOptions = detectConfigurationFactory.createRunOptions();\n        final DetectToolFilter detectToolFilter = runOptions.getDetectToolFilter();\n        if (runDecision.willRunBlackduck()) {\n            logger.info(\"Black Duck tools will run.\");\n            final ConnectivityManager connectivityManager = detectContext.getBean(ConnectivityManager.class);\n            if (connectivityManager.getPhoneHomeManager().isPresent()) {\n                connectivityManager.getPhoneHomeManager().get().startPhoneHome();\n            }\n            DetectorEnvironment detectorEnvironment = new DetectorEnvironment(directoryManager.getSourceDirectory(), Collections.emptySet(), 0, null, false);\n            DetectorFactory detectorFactory = detectContext.getBean(DetectorFactory.class);\n            logger.info(ReportConstants.RUN_SEPARATOR);\n            if (detectToolFilter.shouldInclude(DetectTool.DOCKER)) {\n                logger.info(\"Will include the docker tool.\");\n                ToolRunner toolRunner = new ToolRunner(eventSystem, detectorFactory.createDockerDetector(detectorEnvironment));\n                toolRunner.run(runResult);\n                logger.info(\"Docker actions finished.\");\n            } else {\n                logger.info(\"Docker tool will not be run.\");\n            }\n            logger.info(ReportConstants.RUN_SEPARATOR);\n            if (detectToolFilter.shouldInclude(DetectTool.BAZEL)) {\n                logger.info(\"Will include the bazel tool.\");\n                ToolRunner toolRunner = new ToolRunner(eventSystem, detectorFactory.createBazelDetector(detectorEnvironment));\n                toolRunner.run(runResult);\n                logger.info(\"Bazel actions finished.\");\n            } else {\n                logger.info(\"Bazel tool will not be run.\");\n            }\n            logger.info(ReportConstants.RUN_SEPARATOR);\n            if (detectToolFilter.shouldInclude(DetectTool.DETECTOR)) {\n                logger.info(\"Will include the detector tool.\");\n                final String projectBomTool = detectConfiguration.getProperty(DetectProperty.DETECT_PROJECT_DETECTOR, PropertyAuthority.None);\n                final SearchOptions searchOptions = detectConfigurationFactory.createSearchOptions(directoryManager.getSourceDirectory());\n                final DetectorTool detectorTool = new DetectorTool(detectContext);\n                final DetectorToolResult detectorToolResult = detectorTool.performDetectors(searchOptions, projectBomTool);\n                runResult.addToolNameVersionIfPresent(DetectTool.DETECTOR, detectorToolResult.bomToolProjectNameVersion);\n                runResult.addDetectCodeLocations(detectorToolResult.bomToolCodeLocations);\n                runResult.addApplicableDetectors(detectorToolResult.applicableDetectorTypes);\n                if (detectorToolResult.failedDetectorTypes.size() > 0) {\n                    eventSystem.publishEvent(Event.ExitCode, new ExitCodeRequest(ExitCodeType.FAILURE_DETECTOR, \"A detector failed.\"));\n                }\n                logger.info(\"Detector actions finished.\");\n            } else {\n                logger.info(\"Detector tool will not be run.\");\n            }\n            logger.info(ReportConstants.RUN_SEPARATOR);\n            logger.info(\"Completed code location tools.\");\n            logger.info(\"Determining project info.\");\n            final ProjectNameVersionOptions projectNameVersionOptions = detectConfigurationFactory.createProjectNameVersionOptions(directoryManager.getSourceDirectory().getName());\n            final ProjectNameVersionDecider projectNameVersionDecider = new ProjectNameVersionDecider(projectNameVersionOptions);\n            final NameVersion projectNameVersion = projectNameVersionDecider.decideProjectNameVersion(runOptions.getPreferredTools(), runResult.getDetectToolProjectInfo());\n            logger.info(\"Project name: \" + projectNameVersion.getName());\n            logger.info(\"Project version: \" + projectNameVersion.getVersion());\n            Optional<ProjectVersionWrapper> projectVersionWrapper = Optional.empty();\n            if (connectivityManager.isDetectOnline() && connectivityManager.getBlackDuckServicesFactory().isPresent()) {\n                final BlackDuckServicesFactory blackDuckServicesFactory = connectivityManager.getBlackDuckServicesFactory().get();\n                logger.info(\"Getting or creating project.\");\n                final DetectProjectServiceOptions options = detectConfigurationFactory.createDetectProjectServiceOptions();\n                final DetectProjectMappingService detectProjectMappingService = new DetectProjectMappingService(blackDuckServicesFactory.createBlackDuckService());\n                final DetectProjectService detectProjectService = new DetectProjectService(blackDuckServicesFactory, options, detectProjectMappingService);\n                projectVersionWrapper = Optional.of(detectProjectService.createOrUpdateHubProject(projectNameVersion, options.getApplicationId()));\n                if (projectVersionWrapper.isPresent() && runOptions.shouldUnmapCodeLocations()) {\n                    logger.info(\"Unmapping code locations.\");\n                    final DetectCodeLocationUnmapService detectCodeLocationUnmapService = new DetectCodeLocationUnmapService(blackDuckServicesFactory.createBlackDuckService(), blackDuckServicesFactory.createCodeLocationService());\n                    detectCodeLocationUnmapService.unmapCodeLocations(projectVersionWrapper.get().getProjectVersionView());\n                } else {\n                    logger.debug(\"Will not unmap code locations: Project view was not present, or should not unmap code locations.\");\n                }\n            } else {\n                logger.debug(\"Detect is not online, and will not create the project.\");\n            }\n            logger.info(\"Completed project and version actions.\");\n            logger.info(\"Processing Detect Code Locations.\");\n            final CodeLocationWaitData codeLocationWaitData = new CodeLocationWaitData();\n            final BdioManager bdioManager = new BdioManager(detectInfo, new SimpleBdioFactory(), new IntegrationEscapeUtil(), codeLocationNameManager, detectConfiguration, bdioCodeLocationCreator, directoryManager, eventSystem);\n            final BdioResult bdioResult = bdioManager.createBdioFiles(runOptions.getAggregateName(), projectNameVersion, runResult.getDetectCodeLocations());\n            if (bdioResult.getUploadTargets().size() > 0) {\n                logger.info(\"Created \" + bdioResult.getUploadTargets().size() + \" BDIO files.\");\n                bdioResult.getUploadTargets().forEach(it -> eventSystem.publishEvent(Event.OutputFileOfInterest, it.getUploadFile()));\n                if (connectivityManager.isDetectOnline() && connectivityManager.getBlackDuckServicesFactory().isPresent()) {\n                    logger.info(\"Uploading BDIO files.\");\n                    final BlackDuckServicesFactory blackDuckServicesFactory = connectivityManager.getBlackDuckServicesFactory().get();\n                    final DetectBdioUploadService detectBdioUploadService = new DetectBdioUploadService(detectConfiguration, blackDuckServicesFactory.createBdioUploadService(), eventSystem);\n                    final CodeLocationCreationData<UploadBatchOutput> uploadBatchOutputCodeLocationCreationData = detectBdioUploadService.uploadBdioFiles(bdioResult.getUploadTargets());\n                    codeLocationWaitData.setFromBdioCodeLocationCreationData(uploadBatchOutputCodeLocationCreationData);\n                }\n            } else {\n                logger.debug(\"Did not create any BDIO files.\");\n            }\n            logger.info(\"Completed Detect Code Location processing.\");\n            logger.info(ReportConstants.RUN_SEPARATOR);\n            if (detectToolFilter.shouldInclude(DetectTool.SIGNATURE_SCAN)) {\n                logger.info(\"Will include the signature scanner tool.\");\n                final BlackDuckSignatureScannerOptions blackDuckSignatureScannerOptions = detectConfigurationFactory.createBlackDuckSignatureScannerOptions();\n                final BlackDuckSignatureScannerTool blackDuckSignatureScannerTool = new BlackDuckSignatureScannerTool(blackDuckSignatureScannerOptions, detectContext);\n                final SignatureScannerToolResult signatureScannerToolResult = blackDuckSignatureScannerTool.runScanTool(projectNameVersion, runResult.getDockerTar());\n                if (signatureScannerToolResult.getResult() == Result.SUCCESS && signatureScannerToolResult.getCreationData().isPresent()) {\n                    codeLocationWaitData.setFromSignatureScannerCodeLocationCreationData(signatureScannerToolResult.getCreationData().get());\n                }\n                logger.info(\"Signature scanner actions finished.\");\n            } else {\n                logger.info(\"Signature scan tool will not be run.\");\n            }\n            logger.info(ReportConstants.RUN_SEPARATOR);\n            if (detectToolFilter.shouldInclude(DetectTool.BINARY_SCAN)) {\n                logger.info(\"Will include the binary scanner tool.\");\n                if (connectivityManager.isDetectOnline() && connectivityManager.getBlackDuckServicesFactory().isPresent()) {\n                    final BlackDuckServicesFactory blackDuckServicesFactory = connectivityManager.getBlackDuckServicesFactory().get();\n                    final BlackDuckBinaryScannerTool blackDuckBinaryScanner = new BlackDuckBinaryScannerTool(eventSystem, codeLocationNameManager, detectConfiguration, blackDuckServicesFactory);\n                    BinaryScanToolResult result = blackDuckBinaryScanner.performBinaryScanActions(projectNameVersion);\n                    if (result.isSuccessful()) {\n                        codeLocationWaitData.setFromBinaryScan(result.getNotificationTaskRange(), result.getCodeLocationNames());\n                    }\n                }\n                logger.info(\"Binary scanner actions finished.\");\n            } else {\n                logger.info(\"Binary scan tool will not be run.\");\n            }\n            logger.info(ReportConstants.RUN_SEPARATOR);\n            if (projectVersionWrapper.isPresent() && connectivityManager.isDetectOnline() && connectivityManager.getBlackDuckServicesFactory().isPresent()) {\n                final BlackDuckServicesFactory blackDuckServicesFactory = connectivityManager.getBlackDuckServicesFactory().get();\n                logger.info(\"Will perform Black Duck post actions.\");\n                final BlackduckReportOptions blackduckReportOptions = detectConfigurationFactory.createReportOptions();\n                final PolicyCheckOptions policyCheckOptions = detectConfigurationFactory.createPolicyCheckOptions();\n                final long timeoutInSeconds = detectConfigurationFactory.getTimeoutInSeconds();\n                final BlackduckPostActions blackduckPostActions = new BlackduckPostActions(blackDuckServicesFactory, eventSystem);\n                blackduckPostActions.perform(blackduckReportOptions, policyCheckOptions, codeLocationWaitData, projectVersionWrapper.get(), timeoutInSeconds);\n                final boolean hasAtLeastOneBdio = !bdioResult.getUploadTargets().isEmpty();\n                final boolean shouldHaveScanned = detectToolFilter.shouldInclude(DetectTool.SIGNATURE_SCAN);\n                if (hasAtLeastOneBdio || shouldHaveScanned) {\n                    final Optional<String> componentsLink = projectVersionWrapper.get().getProjectVersionView().getFirstLink(ProjectVersionView.COMPONENTS_LINK);\n                    if (componentsLink.isPresent()) {\n                        logger.info(String.format(\"To see your results, follow the URL: %s\", componentsLink.get()));\n                    }\n                }\n                logger.info(\"Black Duck actions have finished.\");\n            } else {\n                logger.debug(\"Will not perform post actions: Detect is not online.\");\n            }\n        } else {\n            logger.info(\"Black Duck tools will NOT be run.\");\n        }\n        if (runDecision.willRunPolaris()) {\n            logger.info(ReportConstants.RUN_SEPARATOR);\n            if (detectToolFilter.shouldInclude(DetectTool.POLARIS)) {\n                logger.info(\"Will include the Polaris tool.\");\n                final PolarisTool polarisTool = new PolarisTool(eventSystem, directoryManager, new ExecutableRunner(), connectionManager, detectConfiguration);\n                polarisTool.runPolaris(new Slf4jIntLogger(logger), directoryManager.getSourceDirectory());\n                logger.info(\"Polaris actions finished.\");\n            } else {\n                logger.info(\"Polaris CLI tool will not be run.\");\n            }\n        } else {\n            logger.info(\"Polaris tools will NOT be run.\");\n        }\n        logger.info(\"All tools have finished.\");\n        logger.info(ReportConstants.RUN_SEPARATOR);\n        return runResult;\n    }","code":"public RunResult run(RunDecision runDecision) throws DetectUserFriendlyException, InterruptedException, IntegrationException {\n       \n        final DetectConfiguration detectConfiguration = detectContext.getBean(DetectConfiguration.class);\n        final DetectConfigurationFactory detectConfigurationFactory = detectContext.getBean(DetectConfigurationFactory.class);\n        final DirectoryManager directoryManager = detectContext.getBean(DirectoryManager.class);\n        final EventSystem eventSystem = detectContext.getBean(EventSystem.class);\n        final CodeLocationNameManager codeLocationNameManager = detectContext.getBean(CodeLocationNameManager.class);\n        final BdioCodeLocationCreator bdioCodeLocationCreator = detectContext.getBean(BdioCodeLocationCreator.class);\n        final ConnectionManager connectionManager = detectContext.getBean(ConnectionManager.class);\n        final DetectInfo detectInfo = detectContext.getBean(DetectInfo.class);\n        final RunResult runResult = new RunResult();\n        final RunOptions runOptions = detectConfigurationFactory.createRunOptions();\n        final DetectToolFilter detectToolFilter = runOptions.getDetectToolFilter();\n        if (runDecision.willRunBlackduck()) {\n            logger.info(\"Black Duck tools will run.\");\n            final ConnectivityManager connectivityManager = detectContext.getBean(ConnectivityManager.class);\n            if (connectivityManager.getPhoneHomeManager().isPresent()) {\n                connectivityManager.getPhoneHomeManager().get().startPhoneHome();\n            }\n            DetectorEnvironment detectorEnvironment = new DetectorEnvironment(directoryManager.getSourceDirectory(), Collections.emptySet(), 0, null, false);\n            DetectorFactory detectorFactory = detectContext.getBean(DetectorFactory.class);\n            logger.info(ReportConstants.RUN_SEPARATOR);\n            if (detectToolFilter.shouldInclude(DetectTool.DOCKER)) {\n                logger.info(\"Will include the docker tool.\");\n                ToolRunner toolRunner = new ToolRunner(eventSystem, detectorFactory.createDockerDetector(detectorEnvironment));\n                toolRunner.run(runResult);\n                logger.info(\"Docker actions finished.\");\n            } else {\n                logger.info(\"Docker tool will not be run.\");\n            }\n            logger.info(ReportConstants.RUN_SEPARATOR);\n            if (detectToolFilter.shouldInclude(DetectTool.BAZEL)) {\n                logger.info(\"Will include the bazel tool.\");\n                ToolRunner toolRunner = new ToolRunner(eventSystem, detectorFactory.createBazelDetector(detectorEnvironment));\n                toolRunner.run(runResult);\n                logger.info(\"Bazel actions finished.\");\n            } else {\n                logger.info(\"Bazel tool will not be run.\");\n            }\n            logger.info(ReportConstants.RUN_SEPARATOR);\n            if (detectToolFilter.shouldInclude(DetectTool.DETECTOR)) {\n                logger.info(\"Will include the detector tool.\");\n                final String projectBomTool = detectConfiguration.getProperty(DetectProperty.DETECT_PROJECT_DETECTOR, PropertyAuthority.None);\n                final SearchOptions searchOptions = detectConfigurationFactory.createSearchOptions(directoryManager.getSourceDirectory());\n                final DetectorTool detectorTool = new DetectorTool(detectContext);\n                final DetectorToolResult detectorToolResult = detectorTool.performDetectors(searchOptions, projectBomTool);\n                runResult.addToolNameVersionIfPresent(DetectTool.DETECTOR, detectorToolResult.bomToolProjectNameVersion);\n                runResult.addDetectCodeLocations(detectorToolResult.bomToolCodeLocations);\n                runResult.addApplicableDetectors(detectorToolResult.applicableDetectorTypes);\n                if (detectorToolResult.failedDetectorTypes.size() > 0) {\n                    eventSystem.publishEvent(Event.ExitCode, new ExitCodeRequest(ExitCodeType.FAILURE_DETECTOR, \"A detector failed.\"));\n                }\n                logger.info(\"Detector actions finished.\");\n            } else {\n                logger.info(\"Detector tool will not be run.\");\n            }\n            logger.info(ReportConstants.RUN_SEPARATOR);\n            logger.info(\"Completed code location tools.\");\n            logger.info(\"Determining project info.\");\n            final ProjectNameVersionOptions projectNameVersionOptions = detectConfigurationFactory.createProjectNameVersionOptions(directoryManager.getSourceDirectory().getName());\n            final ProjectNameVersionDecider projectNameVersionDecider = new ProjectNameVersionDecider(projectNameVersionOptions);\n            final NameVersion projectNameVersion = projectNameVersionDecider.decideProjectNameVersion(runOptions.getPreferredTools(), runResult.getDetectToolProjectInfo());\n            logger.info(\"Project name: \" + projectNameVersion.getName());\n            logger.info(\"Project version: \" + projectNameVersion.getVersion());\n            Optional<ProjectVersionWrapper> projectVersionWrapper = Optional.empty();\n            if (connectivityManager.isDetectOnline() && connectivityManager.getBlackDuckServicesFactory().isPresent()) {\n                final BlackDuckServicesFactory blackDuckServicesFactory = connectivityManager.getBlackDuckServicesFactory().get();\n                logger.info(\"Getting or creating project.\");\n                final DetectProjectServiceOptions options = detectConfigurationFactory.createDetectProjectServiceOptions();\n                final DetectProjectMappingService detectProjectMappingService = new DetectProjectMappingService(blackDuckServicesFactory.createBlackDuckService());\n                final DetectProjectService detectProjectService = new DetectProjectService(blackDuckServicesFactory, options, detectProjectMappingService);\n                projectVersionWrapper = Optional.of(detectProjectService.createOrUpdateHubProject(projectNameVersion, options.getApplicationId()));\n                if (projectVersionWrapper.isPresent() && runOptions.shouldUnmapCodeLocations()) {\n                    logger.info(\"Unmapping code locations.\");\n                    final DetectCodeLocationUnmapService detectCodeLocationUnmapService = new DetectCodeLocationUnmapService(blackDuckServicesFactory.createBlackDuckService(), blackDuckServicesFactory.createCodeLocationService());\n                    detectCodeLocationUnmapService.unmapCodeLocations(projectVersionWrapper.get().getProjectVersionView());\n                } else {\n                    logger.debug(\"Will not unmap code locations: Project view was not present, or should not unmap code locations.\");\n                }\n            } else {\n                logger.debug(\"Detect is not online, and will not create the project.\");\n            }\n            logger.info(\"Completed project and version actions.\");\n            logger.info(\"Processing Detect Code Locations.\");\n            final CodeLocationWaitData codeLocationWaitData = new CodeLocationWaitData();\n            final BdioManager bdioManager = new BdioManager(detectInfo, new SimpleBdioFactory(), new IntegrationEscapeUtil(), codeLocationNameManager, detectConfiguration, bdioCodeLocationCreator, directoryManager, eventSystem);\n            final BdioResult bdioResult = bdioManager.createBdioFiles(runOptions.getAggregateName(), projectNameVersion, runResult.getDetectCodeLocations());\n            if (bdioResult.getUploadTargets().size() > 0) {\n                logger.info(\"Created \" + bdioResult.getUploadTargets().size() + \" BDIO files.\");\n                bdioResult.getUploadTargets().forEach(it -> eventSystem.publishEvent(Event.OutputFileOfInterest, it.getUploadFile()));\n                if (connectivityManager.isDetectOnline() && connectivityManager.getBlackDuckServicesFactory().isPresent()) {\n                    logger.info(\"Uploading BDIO files.\");\n                    final BlackDuckServicesFactory blackDuckServicesFactory = connectivityManager.getBlackDuckServicesFactory().get();\n                    final DetectBdioUploadService detectBdioUploadService = new DetectBdioUploadService(detectConfiguration, blackDuckServicesFactory.createBdioUploadService(), eventSystem);\n                    final CodeLocationCreationData<UploadBatchOutput> uploadBatchOutputCodeLocationCreationData = detectBdioUploadService.uploadBdioFiles(bdioResult.getUploadTargets());\n                    codeLocationWaitData.setFromBdioCodeLocationCreationData(uploadBatchOutputCodeLocationCreationData);\n                }\n            } else {\n                logger.debug(\"Did not create any BDIO files.\");\n            }\n            logger.info(\"Completed Detect Code Location processing.\");\n            logger.info(ReportConstants.RUN_SEPARATOR);\n            if (detectToolFilter.shouldInclude(DetectTool.SIGNATURE_SCAN)) {\n                logger.info(\"Will include the signature scanner tool.\");\n                final BlackDuckSignatureScannerOptions blackDuckSignatureScannerOptions = detectConfigurationFactory.createBlackDuckSignatureScannerOptions();\n                final BlackDuckSignatureScannerTool blackDuckSignatureScannerTool = new BlackDuckSignatureScannerTool(blackDuckSignatureScannerOptions, detectContext);\n                final SignatureScannerToolResult signatureScannerToolResult = blackDuckSignatureScannerTool.runScanTool(projectNameVersion, runResult.getDockerTar());\n                if (signatureScannerToolResult.getResult() == Result.SUCCESS && signatureScannerToolResult.getCreationData().isPresent()) {\n                    codeLocationWaitData.setFromSignatureScannerCodeLocationCreationData(signatureScannerToolResult.getCreationData().get());\n                }\n                logger.info(\"Signature scanner actions finished.\");\n            } else {\n                logger.info(\"Signature scan tool will not be run.\");\n            }\n            logger.info(ReportConstants.RUN_SEPARATOR);\n            if (detectToolFilter.shouldInclude(DetectTool.BINARY_SCAN)) {\n                logger.info(\"Will include the binary scanner tool.\");\n                if (connectivityManager.isDetectOnline() && connectivityManager.getBlackDuckServicesFactory().isPresent()) {\n                    final BlackDuckServicesFactory blackDuckServicesFactory = connectivityManager.getBlackDuckServicesFactory().get();\n                    final BlackDuckBinaryScannerTool blackDuckBinaryScanner = new BlackDuckBinaryScannerTool(eventSystem, codeLocationNameManager, detectConfiguration, blackDuckServicesFactory);\n                    BinaryScanToolResult result = blackDuckBinaryScanner.performBinaryScanActions(projectNameVersion);\n                    if (result.isSuccessful()) {\n                        codeLocationWaitData.setFromBinaryScan(result.getNotificationTaskRange(), result.getCodeLocationNames());\n                    }\n                }\n                logger.info(\"Binary scanner actions finished.\");\n            } else {\n                logger.info(\"Binary scan tool will not be run.\");\n            }\n            logger.info(ReportConstants.RUN_SEPARATOR);\n            if (projectVersionWrapper.isPresent() && connectivityManager.isDetectOnline() && connectivityManager.getBlackDuckServicesFactory().isPresent()) {\n                final BlackDuckServicesFactory blackDuckServicesFactory = connectivityManager.getBlackDuckServicesFactory().get();\n                logger.info(\"Will perform Black Duck post actions.\");\n                final BlackduckReportOptions blackduckReportOptions = detectConfigurationFactory.createReportOptions();\n                final PolicyCheckOptions policyCheckOptions = detectConfigurationFactory.createPolicyCheckOptions();\n                final long timeoutInSeconds = detectConfigurationFactory.getTimeoutInSeconds();\n                final BlackduckPostActions blackduckPostActions = new BlackduckPostActions(blackDuckServicesFactory, eventSystem);\n                blackduckPostActions.perform(blackduckReportOptions, policyCheckOptions, codeLocationWaitData, projectVersionWrapper.get(), timeoutInSeconds);\n                final boolean hasAtLeastOneBdio = !bdioResult.getUploadTargets().isEmpty();\n                final boolean shouldHaveScanned = detectToolFilter.shouldInclude(DetectTool.SIGNATURE_SCAN);\n                if (hasAtLeastOneBdio || shouldHaveScanned) {\n                    final Optional<String> componentsLink = projectVersionWrapper.get().getProjectVersionView().getFirstLink(ProjectVersionView.COMPONENTS_LINK);\n                    if (componentsLink.isPresent()) {\n                        logger.info(String.format(\"To see your results, follow the URL: %s\", componentsLink.get()));\n                    }\n                }\n                logger.info(\"Black Duck actions have finished.\");\n            } else {\n                logger.debug(\"Will not perform post actions: Detect is not online.\");\n            }\n        } else {\n            logger.info(\"Black Duck tools will NOT be run.\");\n        }\n        if (runDecision.willRunPolaris()) {\n            logger.info(ReportConstants.RUN_SEPARATOR);\n            if (detectToolFilter.shouldInclude(DetectTool.POLARIS)) {\n                logger.info(\"Will include the Polaris tool.\");\n                final PolarisTool polarisTool = new PolarisTool(eventSystem, directoryManager, new ExecutableRunner(), connectionManager, detectConfiguration);\n                polarisTool.runPolaris(new Slf4jIntLogger(logger), directoryManager.getSourceDirectory());\n                logger.info(\"Polaris actions finished.\");\n            } else {\n                logger.info(\"Polaris CLI tool will not be run.\");\n            }\n        } else {\n            logger.info(\"Polaris tools will NOT be run.\");\n        }\n        logger.info(\"All tools have finished.\");\n        logger.info(ReportConstants.RUN_SEPARATOR);\n        return runResult;\n    }","cleancode":"public runresult run(rundecision rundecision) throws detectuserfriendlyexception, interruptedexception, integrationexception { final detectconfiguration detectconfiguration = detectcontext.getbean(detectconfiguration.class); final detectconfigurationfactory detectconfigurationfactory = detectcontext.getbean(detectconfigurationfactory.class); final directorymanager directorymanager = detectcontext.getbean(directorymanager.class); final eventsystem eventsystem = detectcontext.getbean(eventsystem.class); final codelocationnamemanager codelocationnamemanager = detectcontext.getbean(codelocationnamemanager.class); final bdiocodelocationcreator bdiocodelocationcreator = detectcontext.getbean(bdiocodelocationcreator.class); final connectionmanager connectionmanager = detectcontext.getbean(connectionmanager.class); final detectinfo detectinfo = detectcontext.getbean(detectinfo.class); final runresult runresult = new runresult(); final runoptions runoptions = detectconfigurationfactory.createrunoptions(); final detecttoolfilter detecttoolfilter = runoptions.getdetecttoolfilter(); if (rundecision.willrunblackduck()) { logger.info(\"black duck tools will run.\"); final connectivitymanager connectivitymanager = detectcontext.getbean(connectivitymanager.class); if (connectivitymanager.getphonehomemanager().ispresent()) { connectivitymanager.getphonehomemanager().get().startphonehome(); } detectorenvironment detectorenvironment = new detectorenvironment(directorymanager.getsourcedirectory(), collections.emptyset(), 0, null, false); detectorfactory detectorfactory = detectcontext.getbean(detectorfactory.class); logger.info(reportconstants.run_separator); if (detecttoolfilter.shouldinclude(detecttool.docker)) { logger.info(\"will include the docker tool.\"); toolrunner toolrunner = new toolrunner(eventsystem, detectorfactory.createdockerdetector(detectorenvironment)); toolrunner.run(runresult); logger.info(\"docker actions finished.\"); } else { logger.info(\"docker tool will not be run.\"); } logger.info(reportconstants.run_separator); if (detecttoolfilter.shouldinclude(detecttool.bazel)) { logger.info(\"will include the bazel tool.\"); toolrunner toolrunner = new toolrunner(eventsystem, detectorfactory.createbazeldetector(detectorenvironment)); toolrunner.run(runresult); logger.info(\"bazel actions finished.\"); } else { logger.info(\"bazel tool will not be run.\"); } logger.info(reportconstants.run_separator); if (detecttoolfilter.shouldinclude(detecttool.detector)) { logger.info(\"will include the detector tool.\"); final string projectbomtool = detectconfiguration.getproperty(detectproperty.detect_project_detector, propertyauthority.none); final searchoptions searchoptions = detectconfigurationfactory.createsearchoptions(directorymanager.getsourcedirectory()); final detectortool detectortool = new detectortool(detectcontext); final detectortoolresult detectortoolresult = detectortool.performdetectors(searchoptions, projectbomtool); runresult.addtoolnameversionifpresent(detecttool.detector, detectortoolresult.bomtoolprojectnameversion); runresult.adddetectcodelocations(detectortoolresult.bomtoolcodelocations); runresult.addapplicabledetectors(detectortoolresult.applicabledetectortypes); if (detectortoolresult.faileddetectortypes.size() > 0) { eventsystem.publishevent(event.exitcode, new exitcoderequest(exitcodetype.failure_detector, \"a detector failed.\")); } logger.info(\"detector actions finished.\"); } else { logger.info(\"detector tool will not be run.\"); } logger.info(reportconstants.run_separator); logger.info(\"completed code location tools.\"); logger.info(\"determining project info.\"); final projectnameversionoptions projectnameversionoptions = detectconfigurationfactory.createprojectnameversionoptions(directorymanager.getsourcedirectory().getname()); final projectnameversiondecider projectnameversiondecider = new projectnameversiondecider(projectnameversionoptions); final nameversion projectnameversion = projectnameversiondecider.decideprojectnameversion(runoptions.getpreferredtools(), runresult.getdetecttoolprojectinfo()); logger.info(\"project name: \" + projectnameversion.getname()); logger.info(\"project version: \" + projectnameversion.getversion()); optional<projectversionwrapper> projectversionwrapper = optional.empty(); if (connectivitymanager.isdetectonline() && connectivitymanager.getblackduckservicesfactory().ispresent()) { final blackduckservicesfactory blackduckservicesfactory = connectivitymanager.getblackduckservicesfactory().get(); logger.info(\"getting or creating project.\"); final detectprojectserviceoptions options = detectconfigurationfactory.createdetectprojectserviceoptions(); final detectprojectmappingservice detectprojectmappingservice = new detectprojectmappingservice(blackduckservicesfactory.createblackduckservice()); final detectprojectservice detectprojectservice = new detectprojectservice(blackduckservicesfactory, options, detectprojectmappingservice); projectversionwrapper = optional.of(detectprojectservice.createorupdatehubproject(projectnameversion, options.getapplicationid())); if (projectversionwrapper.ispresent() && runoptions.shouldunmapcodelocations()) { logger.info(\"unmapping code locations.\"); final detectcodelocationunmapservice detectcodelocationunmapservice = new detectcodelocationunmapservice(blackduckservicesfactory.createblackduckservice(), blackduckservicesfactory.createcodelocationservice()); detectcodelocationunmapservice.unmapcodelocations(projectversionwrapper.get().getprojectversionview()); } else { logger.debug(\"will not unmap code locations: project view was not present, or should not unmap code locations.\"); } } else { logger.debug(\"detect is not online, and will not create the project.\"); } logger.info(\"completed project and version actions.\"); logger.info(\"processing detect code locations.\"); final codelocationwaitdata codelocationwaitdata = new codelocationwaitdata(); final bdiomanager bdiomanager = new bdiomanager(detectinfo, new simplebdiofactory(), new integrationescapeutil(), codelocationnamemanager, detectconfiguration, bdiocodelocationcreator, directorymanager, eventsystem); final bdioresult bdioresult = bdiomanager.createbdiofiles(runoptions.getaggregatename(), projectnameversion, runresult.getdetectcodelocations()); if (bdioresult.getuploadtargets().size() > 0) { logger.info(\"created \" + bdioresult.getuploadtargets().size() + \" bdio files.\"); bdioresult.getuploadtargets().foreach(it -> eventsystem.publishevent(event.outputfileofinterest, it.getuploadfile())); if (connectivitymanager.isdetectonline() && connectivitymanager.getblackduckservicesfactory().ispresent()) { logger.info(\"uploading bdio files.\"); final blackduckservicesfactory blackduckservicesfactory = connectivitymanager.getblackduckservicesfactory().get(); final detectbdiouploadservice detectbdiouploadservice = new detectbdiouploadservice(detectconfiguration, blackduckservicesfactory.createbdiouploadservice(), eventsystem); final codelocationcreationdata<uploadbatchoutput> uploadbatchoutputcodelocationcreationdata = detectbdiouploadservice.uploadbdiofiles(bdioresult.getuploadtargets()); codelocationwaitdata.setfrombdiocodelocationcreationdata(uploadbatchoutputcodelocationcreationdata); } } else { logger.debug(\"did not create any bdio files.\"); } logger.info(\"completed detect code location processing.\"); logger.info(reportconstants.run_separator); if (detecttoolfilter.shouldinclude(detecttool.signature_scan)) { logger.info(\"will include the signature scanner tool.\"); final blackducksignaturescanneroptions blackducksignaturescanneroptions = detectconfigurationfactory.createblackducksignaturescanneroptions(); final blackducksignaturescannertool blackducksignaturescannertool = new blackducksignaturescannertool(blackducksignaturescanneroptions, detectcontext); final signaturescannertoolresult signaturescannertoolresult = blackducksignaturescannertool.runscantool(projectnameversion, runresult.getdockertar()); if (signaturescannertoolresult.getresult() == result.success && signaturescannertoolresult.getcreationdata().ispresent()) { codelocationwaitdata.setfromsignaturescannercodelocationcreationdata(signaturescannertoolresult.getcreationdata().get()); } logger.info(\"signature scanner actions finished.\"); } else { logger.info(\"signature scan tool will not be run.\"); } logger.info(reportconstants.run_separator); if (detecttoolfilter.shouldinclude(detecttool.binary_scan)) { logger.info(\"will include the binary scanner tool.\"); if (connectivitymanager.isdetectonline() && connectivitymanager.getblackduckservicesfactory().ispresent()) { final blackduckservicesfactory blackduckservicesfactory = connectivitymanager.getblackduckservicesfactory().get(); final blackduckbinaryscannertool blackduckbinaryscanner = new blackduckbinaryscannertool(eventsystem, codelocationnamemanager, detectconfiguration, blackduckservicesfactory); binaryscantoolresult result = blackduckbinaryscanner.performbinaryscanactions(projectnameversion); if (result.issuccessful()) { codelocationwaitdata.setfrombinaryscan(result.getnotificationtaskrange(), result.getcodelocationnames()); } } logger.info(\"binary scanner actions finished.\"); } else { logger.info(\"binary scan tool will not be run.\"); } logger.info(reportconstants.run_separator); if (projectversionwrapper.ispresent() && connectivitymanager.isdetectonline() && connectivitymanager.getblackduckservicesfactory().ispresent()) { final blackduckservicesfactory blackduckservicesfactory = connectivitymanager.getblackduckservicesfactory().get(); logger.info(\"will perform black duck post actions.\"); final blackduckreportoptions blackduckreportoptions = detectconfigurationfactory.createreportoptions(); final policycheckoptions policycheckoptions = detectconfigurationfactory.createpolicycheckoptions(); final long timeoutinseconds = detectconfigurationfactory.gettimeoutinseconds(); final blackduckpostactions blackduckpostactions = new blackduckpostactions(blackduckservicesfactory, eventsystem); blackduckpostactions.perform(blackduckreportoptions, policycheckoptions, codelocationwaitdata, projectversionwrapper.get(), timeoutinseconds); final boolean hasatleastonebdio = !bdioresult.getuploadtargets().isempty(); final boolean shouldhavescanned = detecttoolfilter.shouldinclude(detecttool.signature_scan); if (hasatleastonebdio || shouldhavescanned) { final optional<string> componentslink = projectversionwrapper.get().getprojectversionview().getfirstlink(projectversionview.components_link); if (componentslink.ispresent()) { logger.info(string.format(\"to see your results, follow the url: %s\", componentslink.get())); } } logger.info(\"black duck actions have finished.\"); } else { logger.debug(\"will not perform post actions: detect is not online.\"); } } else { logger.info(\"black duck tools will not be run.\"); } if (rundecision.willrunpolaris()) { logger.info(reportconstants.run_separator); if (detecttoolfilter.shouldinclude(detecttool.polaris)) { logger.info(\"will include the polaris tool.\"); final polaristool polaristool = new polaristool(eventsystem, directorymanager, new executablerunner(), connectionmanager, detectconfiguration); polaristool.runpolaris(new slf4jintlogger(logger), directorymanager.getsourcedirectory()); logger.info(\"polaris actions finished.\"); } else { logger.info(\"polaris cli tool will not be run.\"); } } else { logger.info(\"polaris tools will not be run.\"); } logger.info(\"all tools have finished.\"); logger.info(reportconstants.run_separator); return runresult; }","comment":"\/\/todo: better way for run manager to get dependencies so he can be tested. (and better ways of creating his objects)","repo":"selaliadobor-wt\/synopsys-detect","code_context_2":"public RunResult run(RunDecision runDecision) throws DetectUserFriendlyException, InterruptedException, IntegrationException {\n\/\/TODO: Better way for run manager to get dependencies so he can be tested. (And better ways of creating his objects)\nfinal DetectConfiguration detectConfiguration = detectContext.getBean(DetectConfiguration.class);\nfinal DetectConfigurationFactory detectConfigurationFactory = detectContext.getBean(DetectConfigurationFactory.class);","code_context_10":"public RunResult run(RunDecision runDecision) throws DetectUserFriendlyException, InterruptedException, IntegrationException {\n\/\/TODO: Better way for run manager to get dependencies so he can be tested. (And better ways of creating his objects)\nfinal DetectConfiguration detectConfiguration = detectContext.getBean(DetectConfiguration.class);\nfinal DetectConfigurationFactory detectConfigurationFactory = detectContext.getBean(DetectConfigurationFactory.class);\nfinal DirectoryManager directoryManager = detectContext.getBean(DirectoryManager.class);\nfinal EventSystem eventSystem = detectContext.getBean(EventSystem.class);\nfinal CodeLocationNameManager codeLocationNameManager = detectContext.getBean(CodeLocationNameManager.class);\nfinal BdioCodeLocationCreator bdioCodeLocationCreator = detectContext.getBean(BdioCodeLocationCreator.class);\nfinal ConnectionManager connectionManager = detectContext.getBean(ConnectionManager.class);\nfinal DetectInfo detectInfo = detectContext.getBean(DetectInfo.class);\nfinal RunResult runResult = new RunResult();\nfinal RunOptions runOptions = detectConfigurationFactory.createRunOptions();","code_context_20":"public RunResult run(RunDecision runDecision) throws DetectUserFriendlyException, InterruptedException, IntegrationException {\n\/\/TODO: Better way for run manager to get dependencies so he can be tested. (And better ways of creating his objects)\nfinal DetectConfiguration detectConfiguration = detectContext.getBean(DetectConfiguration.class);\nfinal DetectConfigurationFactory detectConfigurationFactory = detectContext.getBean(DetectConfigurationFactory.class);\nfinal DirectoryManager directoryManager = detectContext.getBean(DirectoryManager.class);\nfinal EventSystem eventSystem = detectContext.getBean(EventSystem.class);\nfinal CodeLocationNameManager codeLocationNameManager = detectContext.getBean(CodeLocationNameManager.class);\nfinal BdioCodeLocationCreator bdioCodeLocationCreator = detectContext.getBean(BdioCodeLocationCreator.class);\nfinal ConnectionManager connectionManager = detectContext.getBean(ConnectionManager.class);\nfinal DetectInfo detectInfo = detectContext.getBean(DetectInfo.class);\nfinal RunResult runResult = new RunResult();\nfinal RunOptions runOptions = detectConfigurationFactory.createRunOptions();\nfinal DetectToolFilter detectToolFilter = runOptions.getDetectToolFilter();\nif (runDecision.willRunBlackduck()) {\nlogger.info(\"Black Duck tools will run.\");\nfinal ConnectivityManager connectivityManager = detectContext.getBean(ConnectivityManager.class);\nif (connectivityManager.getPhoneHomeManager().isPresent()) {\nconnectivityManager.getPhoneHomeManager().get().startPhoneHome();\n}\nDetectorEnvironment detectorEnvironment = new DetectorEnvironment(directoryManager.getSourceDirectory(), Collections.emptySet(), 0, null, false);\nDetectorFactory detectorFactory = detectContext.getBean(DetectorFactory.class);\nlogger.info(ReportConstants.RUN_SEPARATOR);","label":[1,0,0,0]}
{"id":18139,"original_code":"public float getBending_damping() throws IOException\n\t{\n\t\tif ((__io__pointersize == 8)) {\n\t\t\treturn __io__block.readFloat(__io__address + 160);\n\t\t} else {\n\t\t\treturn __io__block.readFloat(__io__address + 156);\n\t\t}\n\t}","code":"public float getBending_damping() throws IOException\n\t{\n\t\tif ((__io__pointersize == 8)) {\n\t\t\treturn __io__block.readFloat(__io__address + 160);\n\t\t} else {\n\t\t\treturn __io__block.readFloat(__io__address + 156);\n\t\t}\n\t}","cleancode":"public float getbending_damping() throws ioexception { if ((__io__pointersize == 8)) { return __io__block.readfloat(__io__address + 160); } else { return __io__block.readfloat(__io__address + 156); } }","comment":"\/** * get method for struct member 'bending_damping'. * <h3>field documentation<\/h3> * <h4>blender source code:<\/h4> * <p> xxx various hair stuff should really be separate, this struct is a horrible mess already damping of bending springs. <\/p> * @see #__dna__field__bending_damping *\/","repo":"sirivus\/studioonline","code_context_2":"public float getBending_damping() throws IOException\n{\nif ((__io__pointersize == 8)) {\nreturn __io__block.readFloat(__io__address + 160);\n} else {\nreturn __io__block.readFloat(__io__address + 156);\n}\n}","code_context_10":"public float getBending_damping() throws IOException\n{\nif ((__io__pointersize == 8)) {\nreturn __io__block.readFloat(__io__address + 160);\n} else {\nreturn __io__block.readFloat(__io__address + 156);\n}\n}","code_context_20":"public float getBending_damping() throws IOException\n{\nif ((__io__pointersize == 8)) {\nreturn __io__block.readFloat(__io__address + 160);\n} else {\nreturn __io__block.readFloat(__io__address + 156);\n}\n}","label":[1,0,0,0]}
{"id":18140,"original_code":"public void setBending_damping(float bending_damping) throws IOException\n\t{\n\t\tif ((__io__pointersize == 8)) {\n\t\t\t__io__block.writeFloat(__io__address + 160, bending_damping);\n\t\t} else {\n\t\t\t__io__block.writeFloat(__io__address + 156, bending_damping);\n\t\t}\n\t}","code":"public void setBending_damping(float bending_damping) throws IOException\n\t{\n\t\tif ((__io__pointersize == 8)) {\n\t\t\t__io__block.writeFloat(__io__address + 160, bending_damping);\n\t\t} else {\n\t\t\t__io__block.writeFloat(__io__address + 156, bending_damping);\n\t\t}\n\t}","cleancode":"public void setbending_damping(float bending_damping) throws ioexception { if ((__io__pointersize == 8)) { __io__block.writefloat(__io__address + 160, bending_damping); } else { __io__block.writefloat(__io__address + 156, bending_damping); } }","comment":"\/** * set method for struct member 'bending_damping'. * <h3>field documentation<\/h3> * <h4>blender source code:<\/h4> * <p> xxx various hair stuff should really be separate, this struct is a horrible mess already damping of bending springs. <\/p> * @see #__dna__field__bending_damping *\/","repo":"sirivus\/studioonline","code_context_2":"public void setBending_damping(float bending_damping) throws IOException\n{\nif ((__io__pointersize == 8)) {\n__io__block.writeFloat(__io__address + 160, bending_damping);\n} else {\n__io__block.writeFloat(__io__address + 156, bending_damping);\n}\n}","code_context_10":"public void setBending_damping(float bending_damping) throws IOException\n{\nif ((__io__pointersize == 8)) {\n__io__block.writeFloat(__io__address + 160, bending_damping);\n} else {\n__io__block.writeFloat(__io__address + 156, bending_damping);\n}\n}","code_context_20":"public void setBending_damping(float bending_damping) throws IOException\n{\nif ((__io__pointersize == 8)) {\n__io__block.writeFloat(__io__address + 160, bending_damping);\n} else {\n__io__block.writeFloat(__io__address + 156, bending_damping);\n}\n}","label":[1,0,0,0]}
{"id":18263,"original_code":"public static <T> VectorModel minimize(LossDefinition<T> lossDefinition,\n                                           Collection<Observation<T>> observations,\n                                           int dimensionality,\n                                           double learningRate,\n                                           int numRepetitions,\n                                           double minStepSize) {\n        final Random random = new Random();\n        \/\/ Repeat the optimization multiple times and keep the best model.\n        VectorModel bestModel = null;\n        double bestLoss = Double.NaN;\n        for (int repetition = 0; repetition < numRepetitions; repetition++) {\n            logger.info(\"Performing repetition {}\/{}.\", repetition + 1, numRepetitions);\n            \/\/ Generate an initial model.\n            final double[] parameters = new double[dimensionality];\n            for (int dimension = 0; dimension < parameters.length; dimension++) {\n                parameters[dimension] = random.nextGaussian() * 10; \/\/ TODO: It might be important to allow a meaningful customization of the initial weights.\n            }\n            final VectorModel model = new VectorModel(parameters);\n            \/\/ Repeatedly go against the gradient until convergence.\n            double stepSize;\n            double lastLoss = Double.NaN;\n            long nextLogMillis = System.currentTimeMillis() + 30_000L;\n            long round = 1L;\n            do {\n                \/\/ Calculate the gradient of the current model.\n                final double[] gradient = lossDefinition.calculateGradient(model, observations);\n                \/\/ Update the model and calculate the width of the update step.\n                for (int i = 0; i < gradient.length; i++) {\n                    gradient[i] *= -learningRate;\n                }\n                model.add(gradient);\n                stepSize = calculateEuclidianDistance(gradient);\n                \/\/ Adapt the learning rate (Bold Driver):\n                \/\/ If we we are getting better, increase the learning rate by 5%. Otherwise, decrease it by 50%.\n                double loss = lossDefinition.calculateLoss(model, observations);\n                if (!Double.isNaN(lastLoss)) {\n                    if (lastLoss >= loss) learningRate *= 1.05;\n                    else learningRate *= .5;\n                }\n                lastLoss = loss;\n                if (System.currentTimeMillis() >= nextLogMillis) {\n                    logger.info(\"Current loss after {} rounds: {}\", round, loss);\n                    nextLogMillis += 30_000L;\n                }\n                round++;\n            } while (stepSize > minStepSize);\n            \/\/ Update the best model.\n            double loss = lossDefinition.calculateLoss(model, observations);\n            logger.info(\"Final loss after {} rounds: {}\", round, loss);\n            if (bestModel == null || bestLoss < loss) {\n                bestModel = model;\n                bestLoss = loss;\n            }\n        }\n        return bestModel;\n    }","code":"public static <T> VectorModel minimize(LossDefinition<T> lossDefinition,\n                                           Collection<Observation<T>> observations,\n                                           int dimensionality,\n                                           double learningRate,\n                                           int numRepetitions,\n                                           double minStepSize) {\n        final Random random = new Random();\n       \n        VectorModel bestModel = null;\n        double bestLoss = Double.NaN;\n        for (int repetition = 0; repetition < numRepetitions; repetition++) {\n            logger.info(\"Performing repetition {}\/{}.\", repetition + 1, numRepetitions);\n           \n            final double[] parameters = new double[dimensionality];\n            for (int dimension = 0; dimension < parameters.length; dimension++) {\n                parameters[dimension] = random.nextGaussian() * 10;\n            }\n            final VectorModel model = new VectorModel(parameters);\n           \n            double stepSize;\n            double lastLoss = Double.NaN;\n            long nextLogMillis = System.currentTimeMillis() + 30_000L;\n            long round = 1L;\n            do {\n               \n                final double[] gradient = lossDefinition.calculateGradient(model, observations);\n               \n                for (int i = 0; i < gradient.length; i++) {\n                    gradient[i] *= -learningRate;\n                }\n                model.add(gradient);\n                stepSize = calculateEuclidianDistance(gradient);\n               \n               \n                double loss = lossDefinition.calculateLoss(model, observations);\n                if (!Double.isNaN(lastLoss)) {\n                    if (lastLoss >= loss) learningRate *= 1.05;\n                    else learningRate *= .5;\n                }\n                lastLoss = loss;\n                if (System.currentTimeMillis() >= nextLogMillis) {\n                    logger.info(\"Current loss after {} rounds: {}\", round, loss);\n                    nextLogMillis += 30_000L;\n                }\n                round++;\n            } while (stepSize > minStepSize);\n           \n            double loss = lossDefinition.calculateLoss(model, observations);\n            logger.info(\"Final loss after {} rounds: {}\", round, loss);\n            if (bestModel == null || bestLoss < loss) {\n                bestModel = model;\n                bestLoss = loss;\n            }\n        }\n        return bestModel;\n    }","cleancode":"public static <t> vectormodel minimize(lossdefinition<t> lossdefinition, collection<observation<t>> observations, int dimensionality, double learningrate, int numrepetitions, double minstepsize) { final random random = new random(); vectormodel bestmodel = null; double bestloss = double.nan; for (int repetition = 0; repetition < numrepetitions; repetition++) { logger.info(\"performing repetition {}\/{}.\", repetition + 1, numrepetitions); final double[] parameters = new double[dimensionality]; for (int dimension = 0; dimension < parameters.length; dimension++) { parameters[dimension] = random.nextgaussian() * 10; } final vectormodel model = new vectormodel(parameters); double stepsize; double lastloss = double.nan; long nextlogmillis = system.currenttimemillis() + 30_000l; long round = 1l; do { final double[] gradient = lossdefinition.calculategradient(model, observations); for (int i = 0; i < gradient.length; i++) { gradient[i] *= -learningrate; } model.add(gradient); stepsize = calculateeuclidiandistance(gradient); double loss = lossdefinition.calculateloss(model, observations); if (!double.isnan(lastloss)) { if (lastloss >= loss) learningrate *= 1.05; else learningrate *= .5; } lastloss = loss; if (system.currenttimemillis() >= nextlogmillis) { logger.info(\"current loss after {} rounds: {}\", round, loss); nextlogmillis += 30_000l; } round++; } while (stepsize > minstepsize); double loss = lossdefinition.calculateloss(model, observations); logger.info(\"final loss after {} rounds: {}\", round, loss); if (bestmodel == null || bestloss < loss) { bestmodel = model; bestloss = loss; } } return bestmodel; }","comment":"\/** * minimize a loss function. * * @param lossdefinition defines the type of loss function * @param observations defines the data on which to calculate the loss * @param dimensionality the number of dimensions of the loss functions parameter vector * @param learningrate the learning rate for the minimization * @param numrepetitions how often to restart from a random * @return a {@link vectormodel} that represents the best discovered minimum *\/\n\/\/ repeat the optimization multiple times and keep the best model.\n\/\/ generate an initial model.\n\/\/ todo: it might be important to allow a meaningful customization of the initial weights.\n\/\/ repeatedly go against the gradient until convergence.\n\/\/ calculate the gradient of the current model.\n\/\/ update the model and calculate the width of the update step.\n\/\/ adapt the learning rate (bold driver): \/\/ if we we are getting better, increase the learning rate by 5%. otherwise, decrease it by 50%.\n\/\/ update the best model.","repo":"stratosphere\/metadata-store","code_context_2":"public static <T> VectorModel minimize(LossDefinition<T> lossDefinition,\nCollection<Observation<T>> observations,\nint dimensionality,\ndouble learningRate,\nint numRepetitions,\ndouble minStepSize) {\nfinal Random random = new Random();\n\/\/ Repeat the optimization multiple times and keep the best model.\nVectorModel bestModel = null;\ndouble bestLoss = Double.NaN;\nfor (int repetition = 0; repetition < numRepetitions; repetition++) {\nlogger.info(\"Performing repetition {}\/{}.\", repetition + 1, numRepetitions);\n\/\/ Generate an initial model.\nfinal double[] parameters = new double[dimensionality];\nfor (int dimension = 0; dimension < parameters.length; dimension++) {\nparameters[dimension] = random.nextGaussian() * 10; \/\/ TODO: It might be important to allow a meaningful customization of the initial weights.\n}\nfinal VectorModel model = new VectorModel(parameters);\n\/\/ Repeatedly go against the gradient until convergence.\ndouble stepSize;\ndouble lastLoss = Double.NaN;\nlong nextLogMillis = System.currentTimeMillis() + 30_000L;\nlong round = 1L;\ndo {\n\/\/ Calculate the gradient of the current model.\nfinal double[] gradient = lossDefinition.calculateGradient(model, observations);\n\/\/ Update the model and calculate the width of the update step.\nfor (int i = 0; i < gradient.length; i++) {\ngradient[i] *= -learningRate;\n}\nmodel.add(gradient);\nstepSize = calculateEuclidianDistance(gradient);\n\/\/ Adapt the learning rate (Bold Driver):\n\/\/ If we we are getting better, increase the learning rate by 5%. Otherwise, decrease it by 50%.\ndouble loss = lossDefinition.calculateLoss(model, observations);\nif (!Double.isNaN(lastLoss)) {\nif (lastLoss >= loss) learningRate *= 1.05;\nelse learningRate *= .5;\n}\nlastLoss = loss;\nif (System.currentTimeMillis() >= nextLogMillis) {\nlogger.info(\"Current loss after {} rounds: {}\", round, loss);\nnextLogMillis += 30_000L;\n}\nround++;\n} while (stepSize > minStepSize);\n\/\/ Update the best model.\ndouble loss = lossDefinition.calculateLoss(model, observations);\nlogger.info(\"Final loss after {} rounds: {}\", round, loss);\nif (bestModel == null || bestLoss < loss) {\nbestModel = model;\nbestLoss = loss;\n}\n}\nreturn bestModel;\n}\n\ndouble minStepSize) {\nfinal Random random = new Random();\n\/\/ Repeat the optimization multiple times and keep the best model.\nVectorModel bestModel = null;\ndouble bestLoss = Double.NaN;\n\nfor (int repetition = 0; repetition < numRepetitions; repetition++) {\nlogger.info(\"Performing repetition {}\/{}.\", repetition + 1, numRepetitions);\n\/\/ Generate an initial model.\nfinal double[] parameters = new double[dimensionality];\nfor (int dimension = 0; dimension < parameters.length; dimension++) {\n\nfinal double[] parameters = new double[dimensionality];\nfor (int dimension = 0; dimension < parameters.length; dimension++) {\nparameters[dimension] = random.nextGaussian() * 10; \/\/ TODO: It might be important to allow a meaningful customization of the initial weights.\n}\nfinal VectorModel model = new VectorModel(parameters);\n\n}\nfinal VectorModel model = new VectorModel(parameters);\n\/\/ Repeatedly go against the gradient until convergence.\ndouble stepSize;\ndouble lastLoss = Double.NaN;\n\nlong round = 1L;\ndo {\n\/\/ Calculate the gradient of the current model.\nfinal double[] gradient = lossDefinition.calculateGradient(model, observations);\n\/\/ Update the model and calculate the width of the update step.\n\n\/\/ Calculate the gradient of the current model.\nfinal double[] gradient = lossDefinition.calculateGradient(model, observations);\n\/\/ Update the model and calculate the width of the update step.\nfor (int i = 0; i < gradient.length; i++) {\ngradient[i] *= -learningRate;\n\nmodel.add(gradient);\nstepSize = calculateEuclidianDistance(gradient);\n\/\/ Adapt the learning rate (Bold Driver):\n\/\/ If we we are getting better, increase the learning rate by 5%. Otherwise, decrease it by 50%.\ndouble loss = lossDefinition.calculateLoss(model, observations);\nif (!Double.isNaN(lastLoss)) {\n\nround++;\n} while (stepSize > minStepSize);\n\/\/ Update the best model.\ndouble loss = lossDefinition.calculateLoss(model, observations);\nlogger.info(\"Final loss after {} rounds: {}\", round, loss);","code_context_10":"public static <T> VectorModel minimize(LossDefinition<T> lossDefinition,\nCollection<Observation<T>> observations,\nint dimensionality,\ndouble learningRate,\nint numRepetitions,\ndouble minStepSize) {\nfinal Random random = new Random();\n\/\/ Repeat the optimization multiple times and keep the best model.\nVectorModel bestModel = null;\ndouble bestLoss = Double.NaN;\nfor (int repetition = 0; repetition < numRepetitions; repetition++) {\nlogger.info(\"Performing repetition {}\/{}.\", repetition + 1, numRepetitions);\n\/\/ Generate an initial model.\nfinal double[] parameters = new double[dimensionality];\nfor (int dimension = 0; dimension < parameters.length; dimension++) {\nparameters[dimension] = random.nextGaussian() * 10; \/\/ TODO: It might be important to allow a meaningful customization of the initial weights.\n}\nfinal VectorModel model = new VectorModel(parameters);\n\/\/ Repeatedly go against the gradient until convergence.\ndouble stepSize;\ndouble lastLoss = Double.NaN;\nlong nextLogMillis = System.currentTimeMillis() + 30_000L;\nlong round = 1L;\ndo {\n\/\/ Calculate the gradient of the current model.\nfinal double[] gradient = lossDefinition.calculateGradient(model, observations);\n\/\/ Update the model and calculate the width of the update step.\nfor (int i = 0; i < gradient.length; i++) {\ngradient[i] *= -learningRate;\n}\nmodel.add(gradient);\nstepSize = calculateEuclidianDistance(gradient);\n\/\/ Adapt the learning rate (Bold Driver):\n\/\/ If we we are getting better, increase the learning rate by 5%. Otherwise, decrease it by 50%.\ndouble loss = lossDefinition.calculateLoss(model, observations);\nif (!Double.isNaN(lastLoss)) {\nif (lastLoss >= loss) learningRate *= 1.05;\nelse learningRate *= .5;\n}\nlastLoss = loss;\nif (System.currentTimeMillis() >= nextLogMillis) {\nlogger.info(\"Current loss after {} rounds: {}\", round, loss);\nnextLogMillis += 30_000L;\n}\nround++;\n} while (stepSize > minStepSize);\n\/\/ Update the best model.\ndouble loss = lossDefinition.calculateLoss(model, observations);\nlogger.info(\"Final loss after {} rounds: {}\", round, loss);\nif (bestModel == null || bestLoss < loss) {\nbestModel = model;\nbestLoss = loss;\n}\n}\nreturn bestModel;\n}\n\npublic static <T> VectorModel minimize(LossDefinition<T> lossDefinition,\nCollection<Observation<T>> observations,\nint dimensionality,\ndouble learningRate,\nint numRepetitions,\ndouble minStepSize) {\nfinal Random random = new Random();\n\/\/ Repeat the optimization multiple times and keep the best model.\nVectorModel bestModel = null;\ndouble bestLoss = Double.NaN;\nfor (int repetition = 0; repetition < numRepetitions; repetition++) {\nlogger.info(\"Performing repetition {}\/{}.\", repetition + 1, numRepetitions);\n\/\/ Generate an initial model.\nfinal double[] parameters = new double[dimensionality];\nfor (int dimension = 0; dimension < parameters.length; dimension++) {\nparameters[dimension] = random.nextGaussian() * 10; \/\/ TODO: It might be important to allow a meaningful customization of the initial weights.\n}\nfinal VectorModel model = new VectorModel(parameters);\n\nint dimensionality,\ndouble learningRate,\nint numRepetitions,\ndouble minStepSize) {\nfinal Random random = new Random();\n\/\/ Repeat the optimization multiple times and keep the best model.\nVectorModel bestModel = null;\ndouble bestLoss = Double.NaN;\nfor (int repetition = 0; repetition < numRepetitions; repetition++) {\nlogger.info(\"Performing repetition {}\/{}.\", repetition + 1, numRepetitions);\n\/\/ Generate an initial model.\nfinal double[] parameters = new double[dimensionality];\nfor (int dimension = 0; dimension < parameters.length; dimension++) {\nparameters[dimension] = random.nextGaussian() * 10; \/\/ TODO: It might be important to allow a meaningful customization of the initial weights.\n}\nfinal VectorModel model = new VectorModel(parameters);\n\/\/ Repeatedly go against the gradient until convergence.\ndouble stepSize;\ndouble lastLoss = Double.NaN;\nlong nextLogMillis = System.currentTimeMillis() + 30_000L;\nlong round = 1L;\n\ndouble minStepSize) {\nfinal Random random = new Random();\n\/\/ Repeat the optimization multiple times and keep the best model.\nVectorModel bestModel = null;\ndouble bestLoss = Double.NaN;\nfor (int repetition = 0; repetition < numRepetitions; repetition++) {\nlogger.info(\"Performing repetition {}\/{}.\", repetition + 1, numRepetitions);\n\/\/ Generate an initial model.\nfinal double[] parameters = new double[dimensionality];\nfor (int dimension = 0; dimension < parameters.length; dimension++) {\nparameters[dimension] = random.nextGaussian() * 10; \/\/ TODO: It might be important to allow a meaningful customization of the initial weights.\n}\nfinal VectorModel model = new VectorModel(parameters);\n\/\/ Repeatedly go against the gradient until convergence.\ndouble stepSize;\ndouble lastLoss = Double.NaN;\nlong nextLogMillis = System.currentTimeMillis() + 30_000L;\nlong round = 1L;\ndo {\n\/\/ Calculate the gradient of the current model.\nfinal double[] gradient = lossDefinition.calculateGradient(model, observations);\n\nVectorModel bestModel = null;\ndouble bestLoss = Double.NaN;\nfor (int repetition = 0; repetition < numRepetitions; repetition++) {\nlogger.info(\"Performing repetition {}\/{}.\", repetition + 1, numRepetitions);\n\/\/ Generate an initial model.\nfinal double[] parameters = new double[dimensionality];\nfor (int dimension = 0; dimension < parameters.length; dimension++) {\nparameters[dimension] = random.nextGaussian() * 10; \/\/ TODO: It might be important to allow a meaningful customization of the initial weights.\n}\nfinal VectorModel model = new VectorModel(parameters);\n\/\/ Repeatedly go against the gradient until convergence.\ndouble stepSize;\ndouble lastLoss = Double.NaN;\nlong nextLogMillis = System.currentTimeMillis() + 30_000L;\nlong round = 1L;\ndo {\n\/\/ Calculate the gradient of the current model.\nfinal double[] gradient = lossDefinition.calculateGradient(model, observations);\n\/\/ Update the model and calculate the width of the update step.\nfor (int i = 0; i < gradient.length; i++) {\ngradient[i] *= -learningRate;\n\nfor (int dimension = 0; dimension < parameters.length; dimension++) {\nparameters[dimension] = random.nextGaussian() * 10; \/\/ TODO: It might be important to allow a meaningful customization of the initial weights.\n}\nfinal VectorModel model = new VectorModel(parameters);\n\/\/ Repeatedly go against the gradient until convergence.\ndouble stepSize;\ndouble lastLoss = Double.NaN;\nlong nextLogMillis = System.currentTimeMillis() + 30_000L;\nlong round = 1L;\ndo {\n\/\/ Calculate the gradient of the current model.\nfinal double[] gradient = lossDefinition.calculateGradient(model, observations);\n\/\/ Update the model and calculate the width of the update step.\nfor (int i = 0; i < gradient.length; i++) {\ngradient[i] *= -learningRate;\n}\nmodel.add(gradient);\nstepSize = calculateEuclidianDistance(gradient);\n\/\/ Adapt the learning rate (Bold Driver):\n\/\/ If we we are getting better, increase the learning rate by 5%. Otherwise, decrease it by 50%.\ndouble loss = lossDefinition.calculateLoss(model, observations);\n\n}\nfinal VectorModel model = new VectorModel(parameters);\n\/\/ Repeatedly go against the gradient until convergence.\ndouble stepSize;\ndouble lastLoss = Double.NaN;\nlong nextLogMillis = System.currentTimeMillis() + 30_000L;\nlong round = 1L;\ndo {\n\/\/ Calculate the gradient of the current model.\nfinal double[] gradient = lossDefinition.calculateGradient(model, observations);\n\/\/ Update the model and calculate the width of the update step.\nfor (int i = 0; i < gradient.length; i++) {\ngradient[i] *= -learningRate;\n}\nmodel.add(gradient);\nstepSize = calculateEuclidianDistance(gradient);\n\/\/ Adapt the learning rate (Bold Driver):\n\/\/ If we we are getting better, increase the learning rate by 5%. Otherwise, decrease it by 50%.\ndouble loss = lossDefinition.calculateLoss(model, observations);\nif (!Double.isNaN(lastLoss)) {\nif (lastLoss >= loss) learningRate *= 1.05;\n\nlong round = 1L;\ndo {\n\/\/ Calculate the gradient of the current model.\nfinal double[] gradient = lossDefinition.calculateGradient(model, observations);\n\/\/ Update the model and calculate the width of the update step.\nfor (int i = 0; i < gradient.length; i++) {\ngradient[i] *= -learningRate;\n}\nmodel.add(gradient);\nstepSize = calculateEuclidianDistance(gradient);\n\/\/ Adapt the learning rate (Bold Driver):\n\/\/ If we we are getting better, increase the learning rate by 5%. Otherwise, decrease it by 50%.\ndouble loss = lossDefinition.calculateLoss(model, observations);\nif (!Double.isNaN(lastLoss)) {\nif (lastLoss >= loss) learningRate *= 1.05;\nelse learningRate *= .5;\n}\nlastLoss = loss;\nif (System.currentTimeMillis() >= nextLogMillis) {\nlogger.info(\"Current loss after {} rounds: {}\", round, loss);\nnextLogMillis += 30_000L;\n}\n\nif (lastLoss >= loss) learningRate *= 1.05;\nelse learningRate *= .5;\n}\nlastLoss = loss;\nif (System.currentTimeMillis() >= nextLogMillis) {\nlogger.info(\"Current loss after {} rounds: {}\", round, loss);\nnextLogMillis += 30_000L;\n}\nround++;\n} while (stepSize > minStepSize);\n\/\/ Update the best model.\ndouble loss = lossDefinition.calculateLoss(model, observations);\nlogger.info(\"Final loss after {} rounds: {}\", round, loss);\nif (bestModel == null || bestLoss < loss) {\nbestModel = model;\nbestLoss = loss;\n}\n}\nreturn bestModel;\n}","code_context_20":"public static <T> VectorModel minimize(LossDefinition<T> lossDefinition,\nCollection<Observation<T>> observations,\nint dimensionality,\ndouble learningRate,\nint numRepetitions,\ndouble minStepSize) {\nfinal Random random = new Random();\n\/\/ Repeat the optimization multiple times and keep the best model.\nVectorModel bestModel = null;\ndouble bestLoss = Double.NaN;\nfor (int repetition = 0; repetition < numRepetitions; repetition++) {\nlogger.info(\"Performing repetition {}\/{}.\", repetition + 1, numRepetitions);\n\/\/ Generate an initial model.\nfinal double[] parameters = new double[dimensionality];\nfor (int dimension = 0; dimension < parameters.length; dimension++) {\nparameters[dimension] = random.nextGaussian() * 10; \/\/ TODO: It might be important to allow a meaningful customization of the initial weights.\n}\nfinal VectorModel model = new VectorModel(parameters);\n\/\/ Repeatedly go against the gradient until convergence.\ndouble stepSize;\ndouble lastLoss = Double.NaN;\nlong nextLogMillis = System.currentTimeMillis() + 30_000L;\nlong round = 1L;\ndo {\n\/\/ Calculate the gradient of the current model.\nfinal double[] gradient = lossDefinition.calculateGradient(model, observations);\n\/\/ Update the model and calculate the width of the update step.\nfor (int i = 0; i < gradient.length; i++) {\ngradient[i] *= -learningRate;\n}\nmodel.add(gradient);\nstepSize = calculateEuclidianDistance(gradient);\n\/\/ Adapt the learning rate (Bold Driver):\n\/\/ If we we are getting better, increase the learning rate by 5%. Otherwise, decrease it by 50%.\ndouble loss = lossDefinition.calculateLoss(model, observations);\nif (!Double.isNaN(lastLoss)) {\nif (lastLoss >= loss) learningRate *= 1.05;\nelse learningRate *= .5;\n}\nlastLoss = loss;\nif (System.currentTimeMillis() >= nextLogMillis) {\nlogger.info(\"Current loss after {} rounds: {}\", round, loss);\nnextLogMillis += 30_000L;\n}\nround++;\n} while (stepSize > minStepSize);\n\/\/ Update the best model.\ndouble loss = lossDefinition.calculateLoss(model, observations);\nlogger.info(\"Final loss after {} rounds: {}\", round, loss);\nif (bestModel == null || bestLoss < loss) {\nbestModel = model;\nbestLoss = loss;\n}\n}\nreturn bestModel;\n}\n\npublic static <T> VectorModel minimize(LossDefinition<T> lossDefinition,\nCollection<Observation<T>> observations,\nint dimensionality,\ndouble learningRate,\nint numRepetitions,\ndouble minStepSize) {\nfinal Random random = new Random();\n\/\/ Repeat the optimization multiple times and keep the best model.\nVectorModel bestModel = null;\ndouble bestLoss = Double.NaN;\nfor (int repetition = 0; repetition < numRepetitions; repetition++) {\nlogger.info(\"Performing repetition {}\/{}.\", repetition + 1, numRepetitions);\n\/\/ Generate an initial model.\nfinal double[] parameters = new double[dimensionality];\nfor (int dimension = 0; dimension < parameters.length; dimension++) {\nparameters[dimension] = random.nextGaussian() * 10; \/\/ TODO: It might be important to allow a meaningful customization of the initial weights.\n}\nfinal VectorModel model = new VectorModel(parameters);\n\/\/ Repeatedly go against the gradient until convergence.\ndouble stepSize;\ndouble lastLoss = Double.NaN;\nlong nextLogMillis = System.currentTimeMillis() + 30_000L;\nlong round = 1L;\ndo {\n\/\/ Calculate the gradient of the current model.\nfinal double[] gradient = lossDefinition.calculateGradient(model, observations);\n\/\/ Update the model and calculate the width of the update step.\nfor (int i = 0; i < gradient.length; i++) {\n\npublic static <T> VectorModel minimize(LossDefinition<T> lossDefinition,\nCollection<Observation<T>> observations,\nint dimensionality,\ndouble learningRate,\nint numRepetitions,\ndouble minStepSize) {\nfinal Random random = new Random();\n\/\/ Repeat the optimization multiple times and keep the best model.\nVectorModel bestModel = null;\ndouble bestLoss = Double.NaN;\nfor (int repetition = 0; repetition < numRepetitions; repetition++) {\nlogger.info(\"Performing repetition {}\/{}.\", repetition + 1, numRepetitions);\n\/\/ Generate an initial model.\nfinal double[] parameters = new double[dimensionality];\nfor (int dimension = 0; dimension < parameters.length; dimension++) {\nparameters[dimension] = random.nextGaussian() * 10; \/\/ TODO: It might be important to allow a meaningful customization of the initial weights.\n}\nfinal VectorModel model = new VectorModel(parameters);\n\/\/ Repeatedly go against the gradient until convergence.\ndouble stepSize;\ndouble lastLoss = Double.NaN;\nlong nextLogMillis = System.currentTimeMillis() + 30_000L;\nlong round = 1L;\ndo {\n\/\/ Calculate the gradient of the current model.\nfinal double[] gradient = lossDefinition.calculateGradient(model, observations);\n\/\/ Update the model and calculate the width of the update step.\nfor (int i = 0; i < gradient.length; i++) {\ngradient[i] *= -learningRate;\n}\nmodel.add(gradient);\nstepSize = calculateEuclidianDistance(gradient);\n\/\/ Adapt the learning rate (Bold Driver):\n\npublic static <T> VectorModel minimize(LossDefinition<T> lossDefinition,\nCollection<Observation<T>> observations,\nint dimensionality,\ndouble learningRate,\nint numRepetitions,\ndouble minStepSize) {\nfinal Random random = new Random();\n\/\/ Repeat the optimization multiple times and keep the best model.\nVectorModel bestModel = null;\ndouble bestLoss = Double.NaN;\nfor (int repetition = 0; repetition < numRepetitions; repetition++) {\nlogger.info(\"Performing repetition {}\/{}.\", repetition + 1, numRepetitions);\n\/\/ Generate an initial model.\nfinal double[] parameters = new double[dimensionality];\nfor (int dimension = 0; dimension < parameters.length; dimension++) {\nparameters[dimension] = random.nextGaussian() * 10; \/\/ TODO: It might be important to allow a meaningful customization of the initial weights.\n}\nfinal VectorModel model = new VectorModel(parameters);\n\/\/ Repeatedly go against the gradient until convergence.\ndouble stepSize;\ndouble lastLoss = Double.NaN;\nlong nextLogMillis = System.currentTimeMillis() + 30_000L;\nlong round = 1L;\ndo {\n\/\/ Calculate the gradient of the current model.\nfinal double[] gradient = lossDefinition.calculateGradient(model, observations);\n\/\/ Update the model and calculate the width of the update step.\nfor (int i = 0; i < gradient.length; i++) {\ngradient[i] *= -learningRate;\n}\nmodel.add(gradient);\nstepSize = calculateEuclidianDistance(gradient);\n\/\/ Adapt the learning rate (Bold Driver):\n\/\/ If we we are getting better, increase the learning rate by 5%. Otherwise, decrease it by 50%.\ndouble loss = lossDefinition.calculateLoss(model, observations);\nif (!Double.isNaN(lastLoss)) {\n\npublic static <T> VectorModel minimize(LossDefinition<T> lossDefinition,\nCollection<Observation<T>> observations,\nint dimensionality,\ndouble learningRate,\nint numRepetitions,\ndouble minStepSize) {\nfinal Random random = new Random();\n\/\/ Repeat the optimization multiple times and keep the best model.\nVectorModel bestModel = null;\ndouble bestLoss = Double.NaN;\nfor (int repetition = 0; repetition < numRepetitions; repetition++) {\nlogger.info(\"Performing repetition {}\/{}.\", repetition + 1, numRepetitions);\n\/\/ Generate an initial model.\nfinal double[] parameters = new double[dimensionality];\nfor (int dimension = 0; dimension < parameters.length; dimension++) {\nparameters[dimension] = random.nextGaussian() * 10; \/\/ TODO: It might be important to allow a meaningful customization of the initial weights.\n}\nfinal VectorModel model = new VectorModel(parameters);\n\/\/ Repeatedly go against the gradient until convergence.\ndouble stepSize;\ndouble lastLoss = Double.NaN;\nlong nextLogMillis = System.currentTimeMillis() + 30_000L;\nlong round = 1L;\ndo {\n\/\/ Calculate the gradient of the current model.\nfinal double[] gradient = lossDefinition.calculateGradient(model, observations);\n\/\/ Update the model and calculate the width of the update step.\nfor (int i = 0; i < gradient.length; i++) {\ngradient[i] *= -learningRate;\n}\nmodel.add(gradient);\nstepSize = calculateEuclidianDistance(gradient);\n\/\/ Adapt the learning rate (Bold Driver):\n\/\/ If we we are getting better, increase the learning rate by 5%. Otherwise, decrease it by 50%.\ndouble loss = lossDefinition.calculateLoss(model, observations);\nif (!Double.isNaN(lastLoss)) {\nif (lastLoss >= loss) learningRate *= 1.05;\nelse learningRate *= .5;\n}\n\nint numRepetitions,\ndouble minStepSize) {\nfinal Random random = new Random();\n\/\/ Repeat the optimization multiple times and keep the best model.\nVectorModel bestModel = null;\ndouble bestLoss = Double.NaN;\nfor (int repetition = 0; repetition < numRepetitions; repetition++) {\nlogger.info(\"Performing repetition {}\/{}.\", repetition + 1, numRepetitions);\n\/\/ Generate an initial model.\nfinal double[] parameters = new double[dimensionality];\nfor (int dimension = 0; dimension < parameters.length; dimension++) {\nparameters[dimension] = random.nextGaussian() * 10; \/\/ TODO: It might be important to allow a meaningful customization of the initial weights.\n}\nfinal VectorModel model = new VectorModel(parameters);\n\/\/ Repeatedly go against the gradient until convergence.\ndouble stepSize;\ndouble lastLoss = Double.NaN;\nlong nextLogMillis = System.currentTimeMillis() + 30_000L;\nlong round = 1L;\ndo {\n\/\/ Calculate the gradient of the current model.\nfinal double[] gradient = lossDefinition.calculateGradient(model, observations);\n\/\/ Update the model and calculate the width of the update step.\nfor (int i = 0; i < gradient.length; i++) {\ngradient[i] *= -learningRate;\n}\nmodel.add(gradient);\nstepSize = calculateEuclidianDistance(gradient);\n\/\/ Adapt the learning rate (Bold Driver):\n\/\/ If we we are getting better, increase the learning rate by 5%. Otherwise, decrease it by 50%.\ndouble loss = lossDefinition.calculateLoss(model, observations);\nif (!Double.isNaN(lastLoss)) {\nif (lastLoss >= loss) learningRate *= 1.05;\nelse learningRate *= .5;\n}\nlastLoss = loss;\nif (System.currentTimeMillis() >= nextLogMillis) {\nlogger.info(\"Current loss after {} rounds: {}\", round, loss);\nnextLogMillis += 30_000L;\n}\nround++;\n\nfinal Random random = new Random();\n\/\/ Repeat the optimization multiple times and keep the best model.\nVectorModel bestModel = null;\ndouble bestLoss = Double.NaN;\nfor (int repetition = 0; repetition < numRepetitions; repetition++) {\nlogger.info(\"Performing repetition {}\/{}.\", repetition + 1, numRepetitions);\n\/\/ Generate an initial model.\nfinal double[] parameters = new double[dimensionality];\nfor (int dimension = 0; dimension < parameters.length; dimension++) {\nparameters[dimension] = random.nextGaussian() * 10; \/\/ TODO: It might be important to allow a meaningful customization of the initial weights.\n}\nfinal VectorModel model = new VectorModel(parameters);\n\/\/ Repeatedly go against the gradient until convergence.\ndouble stepSize;\ndouble lastLoss = Double.NaN;\nlong nextLogMillis = System.currentTimeMillis() + 30_000L;\nlong round = 1L;\ndo {\n\/\/ Calculate the gradient of the current model.\nfinal double[] gradient = lossDefinition.calculateGradient(model, observations);\n\/\/ Update the model and calculate the width of the update step.\nfor (int i = 0; i < gradient.length; i++) {\ngradient[i] *= -learningRate;\n}\nmodel.add(gradient);\nstepSize = calculateEuclidianDistance(gradient);\n\/\/ Adapt the learning rate (Bold Driver):\n\/\/ If we we are getting better, increase the learning rate by 5%. Otherwise, decrease it by 50%.\ndouble loss = lossDefinition.calculateLoss(model, observations);\nif (!Double.isNaN(lastLoss)) {\nif (lastLoss >= loss) learningRate *= 1.05;\nelse learningRate *= .5;\n}\nlastLoss = loss;\nif (System.currentTimeMillis() >= nextLogMillis) {\nlogger.info(\"Current loss after {} rounds: {}\", round, loss);\nnextLogMillis += 30_000L;\n}\nround++;\n} while (stepSize > minStepSize);\n\/\/ Update the best model.\n\n\/\/ Generate an initial model.\nfinal double[] parameters = new double[dimensionality];\nfor (int dimension = 0; dimension < parameters.length; dimension++) {\nparameters[dimension] = random.nextGaussian() * 10; \/\/ TODO: It might be important to allow a meaningful customization of the initial weights.\n}\nfinal VectorModel model = new VectorModel(parameters);\n\/\/ Repeatedly go against the gradient until convergence.\ndouble stepSize;\ndouble lastLoss = Double.NaN;\nlong nextLogMillis = System.currentTimeMillis() + 30_000L;\nlong round = 1L;\ndo {\n\/\/ Calculate the gradient of the current model.\nfinal double[] gradient = lossDefinition.calculateGradient(model, observations);\n\/\/ Update the model and calculate the width of the update step.\nfor (int i = 0; i < gradient.length; i++) {\ngradient[i] *= -learningRate;\n}\nmodel.add(gradient);\nstepSize = calculateEuclidianDistance(gradient);\n\/\/ Adapt the learning rate (Bold Driver):\n\/\/ If we we are getting better, increase the learning rate by 5%. Otherwise, decrease it by 50%.\ndouble loss = lossDefinition.calculateLoss(model, observations);\nif (!Double.isNaN(lastLoss)) {\nif (lastLoss >= loss) learningRate *= 1.05;\nelse learningRate *= .5;\n}\nlastLoss = loss;\nif (System.currentTimeMillis() >= nextLogMillis) {\nlogger.info(\"Current loss after {} rounds: {}\", round, loss);\nnextLogMillis += 30_000L;\n}\nround++;\n} while (stepSize > minStepSize);\n\/\/ Update the best model.\ndouble loss = lossDefinition.calculateLoss(model, observations);\nlogger.info(\"Final loss after {} rounds: {}\", round, loss);\nif (bestModel == null || bestLoss < loss) {\nbestModel = model;\nbestLoss = loss;\n}\n}\n\n\/\/ Update the model and calculate the width of the update step.\nfor (int i = 0; i < gradient.length; i++) {\ngradient[i] *= -learningRate;\n}\nmodel.add(gradient);\nstepSize = calculateEuclidianDistance(gradient);\n\/\/ Adapt the learning rate (Bold Driver):\n\/\/ If we we are getting better, increase the learning rate by 5%. Otherwise, decrease it by 50%.\ndouble loss = lossDefinition.calculateLoss(model, observations);\nif (!Double.isNaN(lastLoss)) {\nif (lastLoss >= loss) learningRate *= 1.05;\nelse learningRate *= .5;\n}\nlastLoss = loss;\nif (System.currentTimeMillis() >= nextLogMillis) {\nlogger.info(\"Current loss after {} rounds: {}\", round, loss);\nnextLogMillis += 30_000L;\n}\nround++;\n} while (stepSize > minStepSize);\n\/\/ Update the best model.\ndouble loss = lossDefinition.calculateLoss(model, observations);\nlogger.info(\"Final loss after {} rounds: {}\", round, loss);\nif (bestModel == null || bestLoss < loss) {\nbestModel = model;\nbestLoss = loss;\n}\n}\nreturn bestModel;\n}","label":[1,0,0,0]}
{"id":18305,"original_code":"public Session getSession(String sessionId) {\n\t\t\/\/ TODO lock sessions to prevent fetching an expired session?\n\t\tSession session = sessions.get(sessionId);\n\t\tif (session == null) {\n\t\t\tString msg = String.format(\"Session: %s does not exist.\", sessionId);\n\t\t\tLOG.error(msg);\n\t\t\tthrow new SqlGatewayException(msg);\n\t\t}\n\t\tsession.touch();\n\t\treturn session;\n\t}","code":"public Session getSession(String sessionId) {\n\t\n\t\tSession session = sessions.get(sessionId);\n\t\tif (session == null) {\n\t\t\tString msg = String.format(\"Session: %s does not exist.\", sessionId);\n\t\t\tLOG.error(msg);\n\t\t\tthrow new SqlGatewayException(msg);\n\t\t}\n\t\tsession.touch();\n\t\treturn session;\n\t}","cleancode":"public session getsession(string sessionid) { session session = sessions.get(sessionid); if (session == null) { string msg = string.format(\"session: %s does not exist.\", sessionid); log.error(msg); throw new sqlgatewayexception(msg); } session.touch(); return session; }","comment":"\/\/ todo lock sessions to prevent fetching an expired session?","repo":"romainr\/flink-sql-gateway","code_context_2":"public Session getSession(String sessionId) {\n\/\/ TODO lock sessions to prevent fetching an expired session?\nSession session = sessions.get(sessionId);\nif (session == null) {","code_context_10":"public Session getSession(String sessionId) {\n\/\/ TODO lock sessions to prevent fetching an expired session?\nSession session = sessions.get(sessionId);\nif (session == null) {\nString msg = String.format(\"Session: %s does not exist.\", sessionId);\nLOG.error(msg);\nthrow new SqlGatewayException(msg);\n}\nsession.touch();\nreturn session;\n}","code_context_20":"public Session getSession(String sessionId) {\n\/\/ TODO lock sessions to prevent fetching an expired session?\nSession session = sessions.get(sessionId);\nif (session == null) {\nString msg = String.format(\"Session: %s does not exist.\", sessionId);\nLOG.error(msg);\nthrow new SqlGatewayException(msg);\n}\nsession.touch();\nreturn session;\n}","label":[0,1,0,0]}
{"id":34775,"original_code":"public void sendHandshakeRecord(TlsHandshakeMessage handshakeMessage) {\n        TlsPlaintextRecord record = new TlsPlaintextRecord(TlsConstants.HANDSHAKE, version);\n        TlsHandshakeFragment fragment = new HandshakeFragment(handshakeMessage);\n        record.setFragment(fragment);\n        byte[] encoded = record.encode();\n        ByteBuffer buffer = ByteBuffer.wrap(encoded);\n        connectionManager.write(buffer, new CompletionHandler<Integer, ConnectionManager>() {\n            @Override\n            public void completed(Integer result, ConnectionManager attachment) {\n                \/\/ Nothing to do here\n            }\n            @Override\n            public void failed(Throwable exc, ConnectionManager attachment) {\n                \/\/ TODO handle sending errors back to handshake engine. Callback?\n                connectionManager.close();\n            }\n        });\n    }","code":"public void sendHandshakeRecord(TlsHandshakeMessage handshakeMessage) {\n        TlsPlaintextRecord record = new TlsPlaintextRecord(TlsConstants.HANDSHAKE, version);\n        TlsHandshakeFragment fragment = new HandshakeFragment(handshakeMessage);\n        record.setFragment(fragment);\n        byte[] encoded = record.encode();\n        ByteBuffer buffer = ByteBuffer.wrap(encoded);\n        connectionManager.write(buffer, new CompletionHandler<Integer, ConnectionManager>() {\n            @Override\n            public void completed(Integer result, ConnectionManager attachment) {\n               \n            }\n            @Override\n            public void failed(Throwable exc, ConnectionManager attachment) {\n               \n                connectionManager.close();\n            }\n        });\n    }","cleancode":"public void sendhandshakerecord(tlshandshakemessage handshakemessage) { tlsplaintextrecord record = new tlsplaintextrecord(tlsconstants.handshake, version); tlshandshakefragment fragment = new handshakefragment(handshakemessage); record.setfragment(fragment); byte[] encoded = record.encode(); bytebuffer buffer = bytebuffer.wrap(encoded); connectionmanager.write(buffer, new completionhandler<integer, connectionmanager>() { @override public void completed(integer result, connectionmanager attachment) { } @override public void failed(throwable exc, connectionmanager attachment) { connectionmanager.close(); } }); }","comment":"\/\/ nothing to do here\n\/\/ todo handle sending errors back to handshake engine. callback?","repo":"swbrenneis\/secomm-tls-java","code_context_2":"@Override\npublic void completed(Integer result, ConnectionManager attachment) {\n\/\/ Nothing to do here\n}\n@Override\n\n@Override\npublic void failed(Throwable exc, ConnectionManager attachment) {\n\/\/ TODO handle sending errors back to handshake engine. Callback?\nconnectionManager.close();\n}","code_context_10":"public void sendHandshakeRecord(TlsHandshakeMessage handshakeMessage) {\nTlsPlaintextRecord record = new TlsPlaintextRecord(TlsConstants.HANDSHAKE, version);\nTlsHandshakeFragment fragment = new HandshakeFragment(handshakeMessage);\nrecord.setFragment(fragment);\nbyte[] encoded = record.encode();\nByteBuffer buffer = ByteBuffer.wrap(encoded);\nconnectionManager.write(buffer, new CompletionHandler<Integer, ConnectionManager>() {\n@Override\npublic void completed(Integer result, ConnectionManager attachment) {\n\/\/ Nothing to do here\n}\n@Override\npublic void failed(Throwable exc, ConnectionManager attachment) {\n\/\/ TODO handle sending errors back to handshake engine. Callback?\nconnectionManager.close();\n}\n});\n}\n\nrecord.setFragment(fragment);\nbyte[] encoded = record.encode();\nByteBuffer buffer = ByteBuffer.wrap(encoded);\nconnectionManager.write(buffer, new CompletionHandler<Integer, ConnectionManager>() {\n@Override\npublic void completed(Integer result, ConnectionManager attachment) {\n\/\/ Nothing to do here\n}\n@Override\npublic void failed(Throwable exc, ConnectionManager attachment) {\n\/\/ TODO handle sending errors back to handshake engine. Callback?\nconnectionManager.close();\n}\n});\n}","code_context_20":"public void sendHandshakeRecord(TlsHandshakeMessage handshakeMessage) {\nTlsPlaintextRecord record = new TlsPlaintextRecord(TlsConstants.HANDSHAKE, version);\nTlsHandshakeFragment fragment = new HandshakeFragment(handshakeMessage);\nrecord.setFragment(fragment);\nbyte[] encoded = record.encode();\nByteBuffer buffer = ByteBuffer.wrap(encoded);\nconnectionManager.write(buffer, new CompletionHandler<Integer, ConnectionManager>() {\n@Override\npublic void completed(Integer result, ConnectionManager attachment) {\n\/\/ Nothing to do here\n}\n@Override\npublic void failed(Throwable exc, ConnectionManager attachment) {\n\/\/ TODO handle sending errors back to handshake engine. Callback?\nconnectionManager.close();\n}\n});\n}\n\npublic void sendHandshakeRecord(TlsHandshakeMessage handshakeMessage) {\nTlsPlaintextRecord record = new TlsPlaintextRecord(TlsConstants.HANDSHAKE, version);\nTlsHandshakeFragment fragment = new HandshakeFragment(handshakeMessage);\nrecord.setFragment(fragment);\nbyte[] encoded = record.encode();\nByteBuffer buffer = ByteBuffer.wrap(encoded);\nconnectionManager.write(buffer, new CompletionHandler<Integer, ConnectionManager>() {\n@Override\npublic void completed(Integer result, ConnectionManager attachment) {\n\/\/ Nothing to do here\n}\n@Override\npublic void failed(Throwable exc, ConnectionManager attachment) {\n\/\/ TODO handle sending errors back to handshake engine. Callback?\nconnectionManager.close();\n}\n});\n}","label":[0,1,0,0]}
{"id":34776,"original_code":"public void sendAlertRecord(AlertFragment alertFragment) {\n        TlsPlaintextRecord record = new TlsPlaintextRecord(TlsConstants.ALERT, version);\n        record.setFragment(alertFragment);\n        byte[] encoded = record.encode();\n        ByteBuffer buffer = ByteBuffer.wrap(encoded);\n        connectionManager.write(buffer, new CompletionHandler<Integer, ConnectionManager>() {\n            @Override\n            public void completed(Integer result, ConnectionManager attachment) {\n            }\n            @Override\n            public void failed(Throwable exc, ConnectionManager attachment) {\n                \/\/ TODO handle sending errors back to handshake engine. Callback?\n                connectionManager.close();\n            }\n        });\n    }","code":"public void sendAlertRecord(AlertFragment alertFragment) {\n        TlsPlaintextRecord record = new TlsPlaintextRecord(TlsConstants.ALERT, version);\n        record.setFragment(alertFragment);\n        byte[] encoded = record.encode();\n        ByteBuffer buffer = ByteBuffer.wrap(encoded);\n        connectionManager.write(buffer, new CompletionHandler<Integer, ConnectionManager>() {\n            @Override\n            public void completed(Integer result, ConnectionManager attachment) {\n            }\n            @Override\n            public void failed(Throwable exc, ConnectionManager attachment) {\n               \n                connectionManager.close();\n            }\n        });\n    }","cleancode":"public void sendalertrecord(alertfragment alertfragment) { tlsplaintextrecord record = new tlsplaintextrecord(tlsconstants.alert, version); record.setfragment(alertfragment); byte[] encoded = record.encode(); bytebuffer buffer = bytebuffer.wrap(encoded); connectionmanager.write(buffer, new completionhandler<integer, connectionmanager>() { @override public void completed(integer result, connectionmanager attachment) { } @override public void failed(throwable exc, connectionmanager attachment) { connectionmanager.close(); } }); }","comment":"\/\/ todo handle sending errors back to handshake engine. callback?","repo":"swbrenneis\/secomm-tls-java","code_context_2":"@Override\npublic void failed(Throwable exc, ConnectionManager attachment) {\n\/\/ TODO handle sending errors back to handshake engine. Callback?\nconnectionManager.close();\n}","code_context_10":"TlsPlaintextRecord record = new TlsPlaintextRecord(TlsConstants.ALERT, version);\nrecord.setFragment(alertFragment);\nbyte[] encoded = record.encode();\nByteBuffer buffer = ByteBuffer.wrap(encoded);\nconnectionManager.write(buffer, new CompletionHandler<Integer, ConnectionManager>() {\n@Override\npublic void completed(Integer result, ConnectionManager attachment) {\n}\n@Override\npublic void failed(Throwable exc, ConnectionManager attachment) {\n\/\/ TODO handle sending errors back to handshake engine. Callback?\nconnectionManager.close();\n}\n});\n}","code_context_20":"public void sendAlertRecord(AlertFragment alertFragment) {\nTlsPlaintextRecord record = new TlsPlaintextRecord(TlsConstants.ALERT, version);\nrecord.setFragment(alertFragment);\nbyte[] encoded = record.encode();\nByteBuffer buffer = ByteBuffer.wrap(encoded);\nconnectionManager.write(buffer, new CompletionHandler<Integer, ConnectionManager>() {\n@Override\npublic void completed(Integer result, ConnectionManager attachment) {\n}\n@Override\npublic void failed(Throwable exc, ConnectionManager attachment) {\n\/\/ TODO handle sending errors back to handshake engine. Callback?\nconnectionManager.close();\n}\n});\n}","label":[0,1,0,0]}
{"id":2041,"original_code":"public String getPrimaryKeyColumn(String tableName) {\n\t\t\/\/ FIXME: Currently working for PostgreSQL only\n\t\tif (this.dbSystem.equals(\"POSTGRESQL\")) {\n\t\t\tString sqlPrimaryKey = \"SELECT a.attname FROM pg_index i JOIN pg_attribute a ON a.attrelid = i.indrelid AND a.attnum = ANY(i.indkey) WHERE i.indrelid = '\" + tableName + \"'::regclass AND i.indisprimary;\";\n\t\t\treturn (String) findSingletonValue(sqlPrimaryKey);\n\t\t}\n\t\telse   \/\/ TODO: Handle other JDBC sources\n\t\t\treturn null;\n\t}","code":"public String getPrimaryKeyColumn(String tableName) {\n\t\n\t\tif (this.dbSystem.equals(\"POSTGRESQL\")) {\n\t\t\tString sqlPrimaryKey = \"SELECT a.attname FROM pg_index i JOIN pg_attribute a ON a.attrelid = i.indrelid AND a.attnum = ANY(i.indkey) WHERE i.indrelid = '\" + tableName + \"'::regclass AND i.indisprimary;\";\n\t\t\treturn (String) findSingletonValue(sqlPrimaryKey);\n\t\t}\n\t\telse  \n\t\t\treturn null;\n\t}","cleancode":"public string getprimarykeycolumn(string tablename) { if (this.dbsystem.equals(\"postgresql\")) { string sqlprimarykey = \"select a.attname from pg_index i join pg_attribute a on a.attrelid = i.indrelid and a.attnum = any(i.indkey) where i.indrelid = '\" + tablename + \"'::regclass and i.indisprimary;\"; return (string) findsingletonvalue(sqlprimarykey); } else return null; }","comment":"\/** * assuming that primary key is a single attribute (column) for the given table name, this method can retrieve it. * @param tablename the name of the table in the dbms. * @return the name of the primary key column. *\/\n\/\/ fixme: currently working for postgresql only\n\/\/ todo: handle other jdbc sources","repo":"smartdatalake\/simsearch","code_context_2":"public String getPrimaryKeyColumn(String tableName) {\n\/\/ FIXME: Currently working for PostgreSQL only\nif (this.dbSystem.equals(\"POSTGRESQL\")) {\nString sqlPrimaryKey = \"SELECT a.attname FROM pg_index i JOIN pg_attribute a ON a.attrelid = i.indrelid AND a.attnum = ANY(i.indkey) WHERE i.indrelid = '\" + tableName + \"'::regclass AND i.indisprimary;\";\nreturn (String) findSingletonValue(sqlPrimaryKey);\n}\nelse \/\/ TODO: Handle other JDBC sources\nreturn null;\n}\n\npublic String getPrimaryKeyColumn(String tableName) {\n\/\/ FIXME: Currently working for PostgreSQL only\nif (this.dbSystem.equals(\"POSTGRESQL\")) {\nString sqlPrimaryKey = \"SELECT a.attname FROM pg_index i JOIN pg_attribute a ON a.attrelid = i.indrelid AND a.attnum = ANY(i.indkey) WHERE i.indrelid = '\" + tableName + \"'::regclass AND i.indisprimary;\";\n\nreturn (String) findSingletonValue(sqlPrimaryKey);\n}\nelse \/\/ TODO: Handle other JDBC sources\nreturn null;\n}","code_context_10":"public String getPrimaryKeyColumn(String tableName) {\n\/\/ FIXME: Currently working for PostgreSQL only\nif (this.dbSystem.equals(\"POSTGRESQL\")) {\nString sqlPrimaryKey = \"SELECT a.attname FROM pg_index i JOIN pg_attribute a ON a.attrelid = i.indrelid AND a.attnum = ANY(i.indkey) WHERE i.indrelid = '\" + tableName + \"'::regclass AND i.indisprimary;\";\nreturn (String) findSingletonValue(sqlPrimaryKey);\n}\nelse \/\/ TODO: Handle other JDBC sources\nreturn null;\n}\n\npublic String getPrimaryKeyColumn(String tableName) {\n\/\/ FIXME: Currently working for PostgreSQL only\nif (this.dbSystem.equals(\"POSTGRESQL\")) {\nString sqlPrimaryKey = \"SELECT a.attname FROM pg_index i JOIN pg_attribute a ON a.attrelid = i.indrelid AND a.attnum = ANY(i.indkey) WHERE i.indrelid = '\" + tableName + \"'::regclass AND i.indisprimary;\";\nreturn (String) findSingletonValue(sqlPrimaryKey);\n}\nelse \/\/ TODO: Handle other JDBC sources\nreturn null;\n}\n\npublic String getPrimaryKeyColumn(String tableName) {\n\/\/ FIXME: Currently working for PostgreSQL only\nif (this.dbSystem.equals(\"POSTGRESQL\")) {\nString sqlPrimaryKey = \"SELECT a.attname FROM pg_index i JOIN pg_attribute a ON a.attrelid = i.indrelid AND a.attnum = ANY(i.indkey) WHERE i.indrelid = '\" + tableName + \"'::regclass AND i.indisprimary;\";\nreturn (String) findSingletonValue(sqlPrimaryKey);\n}\nelse \/\/ TODO: Handle other JDBC sources\nreturn null;\n}","code_context_20":"public String getPrimaryKeyColumn(String tableName) {\n\/\/ FIXME: Currently working for PostgreSQL only\nif (this.dbSystem.equals(\"POSTGRESQL\")) {\nString sqlPrimaryKey = \"SELECT a.attname FROM pg_index i JOIN pg_attribute a ON a.attrelid = i.indrelid AND a.attnum = ANY(i.indkey) WHERE i.indrelid = '\" + tableName + \"'::regclass AND i.indisprimary;\";\nreturn (String) findSingletonValue(sqlPrimaryKey);\n}\nelse \/\/ TODO: Handle other JDBC sources\nreturn null;\n}\n\npublic String getPrimaryKeyColumn(String tableName) {\n\/\/ FIXME: Currently working for PostgreSQL only\nif (this.dbSystem.equals(\"POSTGRESQL\")) {\nString sqlPrimaryKey = \"SELECT a.attname FROM pg_index i JOIN pg_attribute a ON a.attrelid = i.indrelid AND a.attnum = ANY(i.indkey) WHERE i.indrelid = '\" + tableName + \"'::regclass AND i.indisprimary;\";\nreturn (String) findSingletonValue(sqlPrimaryKey);\n}\nelse \/\/ TODO: Handle other JDBC sources\nreturn null;\n}\n\npublic String getPrimaryKeyColumn(String tableName) {\n\/\/ FIXME: Currently working for PostgreSQL only\nif (this.dbSystem.equals(\"POSTGRESQL\")) {\nString sqlPrimaryKey = \"SELECT a.attname FROM pg_index i JOIN pg_attribute a ON a.attrelid = i.indrelid AND a.attnum = ANY(i.indkey) WHERE i.indrelid = '\" + tableName + \"'::regclass AND i.indisprimary;\";\nreturn (String) findSingletonValue(sqlPrimaryKey);\n}\nelse \/\/ TODO: Handle other JDBC sources\nreturn null;\n}","label":[1,1,0,0]}
{"id":18449,"original_code":"public static BufferedImage getPDFPageImage(File pdfFile, int pageNumber) throws Exception {\n        PDDocument document = null;\n        BufferedImage pageImage = null;\n        try {\n            document = PDDocument.load(pdfFile);\n            if (document.isEncrypted()) {\n                throw new Exception(\"Cannot read an encrypted PDF file.\");\n            }\n            \/\/ TODO: what is this code for?\n            \/*\n            PDPageTree pages = document.getPages();\n            PDPage page = pages.get(pageNumber - 1);\n            if (page.getContents() != null) {\n                PDResources resources = page.getResources();\n                Iterable<COSName> names = resources.getXObjectNames();\n                for (COSName name : names) {\n                    PDXObject xobj = resources.getXObject(name);\n                    if (xobj instanceof PDImageXObject) {\n                        PDImageXObject ximage = (PDImageXObject) xobj;\n                        BufferedImage bi = ximage.getImage();\n                        if (bi.getType() <= 0) {\n                            BufferedImage bi2 = new BufferedImage(bi.getWidth(), bi.getHeight(),\n                                BufferedImage.TYPE_INT_RGB);\n                            bi2.getGraphics().drawImage(bi, 0, 0, null);\n                            return bi2;\n                        }\n                        return bi;\n                    }\n                }\n            }\n            *\/\n            PDFRenderer pdfRenderer = new PDFRenderer(document);\n            pageImage = pdfRenderer.renderImageWithDPI(pageNumber - 1, 400);\n        } catch (Exception e) {\n            if (document != null) {\n                document.close();\n            }\n            throw e;\n        }\n        if (document != null) {\n            document.close();\n        }\n        return pageImage;\n    }","code":"public static BufferedImage getPDFPageImage(File pdfFile, int pageNumber) throws Exception {\n        PDDocument document = null;\n        BufferedImage pageImage = null;\n        try {\n            document = PDDocument.load(pdfFile);\n            if (document.isEncrypted()) {\n                throw new Exception(\"Cannot read an encrypted PDF file.\");\n            }\n           \n           \n            PDFRenderer pdfRenderer = new PDFRenderer(document);\n            pageImage = pdfRenderer.renderImageWithDPI(pageNumber - 1, 400);\n        } catch (Exception e) {\n            if (document != null) {\n                document.close();\n            }\n            throw e;\n        }\n        if (document != null) {\n            document.close();\n        }\n        return pageImage;\n    }","cleancode":"public static bufferedimage getpdfpageimage(file pdffile, int pagenumber) throws exception { pddocument document = null; bufferedimage pageimage = null; try { document = pddocument.load(pdffile); if (document.isencrypted()) { throw new exception(\"cannot read an encrypted pdf file.\"); } pdfrenderer pdfrenderer = new pdfrenderer(document); pageimage = pdfrenderer.renderimagewithdpi(pagenumber - 1, 400); } catch (exception e) { if (document != null) { document.close(); } throw e; } if (document != null) { document.close(); } return pageimage; }","comment":"\/\/ todo: what is this code for? \/* pdpagetree pages = document.getpages(); pdpage page = pages.get(pagenumber - 1); if (page.getcontents() != null) { pdresources resources = page.getresources(); iterable<cosname> names = resources.getxobjectnames(); for (cosname name : names) { pdxobject xobj = resources.getxobject(name); if (xobj instanceof pdimagexobject) { pdimagexobject ximage = (pdimagexobject) xobj; bufferedimage bi = ximage.getimage(); if (bi.gettype() <= 0) { bufferedimage bi2 = new bufferedimage(bi.getwidth(), bi.getheight(), bufferedimage.type_int_rgb); bi2.getgraphics().drawimage(bi, 0, 0, null); return bi2; } return bi; } } } *\/","repo":"rquast\/formreturn","code_context_2":"throw new Exception(\"Cannot read an encrypted PDF file.\");\n}\n\/\/ TODO: what is this code for?\n\/*\nPDPageTree pages = document.getPages();\nPDPage page = pages.get(pageNumber - 1);\nif (page.getContents() != null) {\nPDResources resources = page.getResources();\nIterable<COSName> names = resources.getXObjectNames();\nfor (COSName name : names) {\nPDXObject xobj = resources.getXObject(name);\nif (xobj instanceof PDImageXObject) {\nPDImageXObject ximage = (PDImageXObject) xobj;\nBufferedImage bi = ximage.getImage();\nif (bi.getType() <= 0) {\nBufferedImage bi2 = new BufferedImage(bi.getWidth(), bi.getHeight(),\nBufferedImage.TYPE_INT_RGB);\nbi2.getGraphics().drawImage(bi, 0, 0, null);\nreturn bi2;\n}\nreturn bi;\n}\n}\n}\n*\/\nPDFRenderer pdfRenderer = new PDFRenderer(document);\npageImage = pdfRenderer.renderImageWithDPI(pageNumber - 1, 400);","code_context_10":"public static BufferedImage getPDFPageImage(File pdfFile, int pageNumber) throws Exception {\nPDDocument document = null;\nBufferedImage pageImage = null;\ntry {\ndocument = PDDocument.load(pdfFile);\nif (document.isEncrypted()) {\nthrow new Exception(\"Cannot read an encrypted PDF file.\");\n}\n\/\/ TODO: what is this code for?\n\/*\nPDPageTree pages = document.getPages();\nPDPage page = pages.get(pageNumber - 1);\nif (page.getContents() != null) {\nPDResources resources = page.getResources();\nIterable<COSName> names = resources.getXObjectNames();\nfor (COSName name : names) {\nPDXObject xobj = resources.getXObject(name);\nif (xobj instanceof PDImageXObject) {\nPDImageXObject ximage = (PDImageXObject) xobj;\nBufferedImage bi = ximage.getImage();\nif (bi.getType() <= 0) {\nBufferedImage bi2 = new BufferedImage(bi.getWidth(), bi.getHeight(),\nBufferedImage.TYPE_INT_RGB);\nbi2.getGraphics().drawImage(bi, 0, 0, null);\nreturn bi2;\n}\nreturn bi;\n}\n}\n}\n*\/\nPDFRenderer pdfRenderer = new PDFRenderer(document);\npageImage = pdfRenderer.renderImageWithDPI(pageNumber - 1, 400);\n} catch (Exception e) {\nif (document != null) {\ndocument.close();\n}\nthrow e;\n}\nif (document != null) {\ndocument.close();","code_context_20":"public static BufferedImage getPDFPageImage(File pdfFile, int pageNumber) throws Exception {\nPDDocument document = null;\nBufferedImage pageImage = null;\ntry {\ndocument = PDDocument.load(pdfFile);\nif (document.isEncrypted()) {\nthrow new Exception(\"Cannot read an encrypted PDF file.\");\n}\n\/\/ TODO: what is this code for?\n\/*\nPDPageTree pages = document.getPages();\nPDPage page = pages.get(pageNumber - 1);\nif (page.getContents() != null) {\nPDResources resources = page.getResources();\nIterable<COSName> names = resources.getXObjectNames();\nfor (COSName name : names) {\nPDXObject xobj = resources.getXObject(name);\nif (xobj instanceof PDImageXObject) {\nPDImageXObject ximage = (PDImageXObject) xobj;\nBufferedImage bi = ximage.getImage();\nif (bi.getType() <= 0) {\nBufferedImage bi2 = new BufferedImage(bi.getWidth(), bi.getHeight(),\nBufferedImage.TYPE_INT_RGB);\nbi2.getGraphics().drawImage(bi, 0, 0, null);\nreturn bi2;\n}\nreturn bi;\n}\n}\n}\n*\/\nPDFRenderer pdfRenderer = new PDFRenderer(document);\npageImage = pdfRenderer.renderImageWithDPI(pageNumber - 1, 400);\n} catch (Exception e) {\nif (document != null) {\ndocument.close();\n}\nthrow e;\n}\nif (document != null) {\ndocument.close();\n}\nreturn pageImage;\n}","label":[0,0,0,0]}
{"id":10298,"original_code":"@Override\n  public void close() {\n    \/\/ Stop the thread.\n    interrupt();\n    \/\/ After the interrupt, the run() method will stop Tun2Socks, and then complete.\n    \/\/ We need to wait until that is finished before closing the TUN device.\n    try {\n      join();\n    } catch (InterruptedException e) {\n      \/\/ This is weird: the calling thread has _also_ been interrupted.\n      LogWrapper.report(e);\n    }\n    try {\n      tunFd.close();\n    } catch (IOException e) {\n      LogWrapper.report(e);\n    }\n  }","code":"@Override\n  public void close() {\n   \n    interrupt();\n   \n   \n    try {\n      join();\n    } catch (InterruptedException e) {\n     \n      LogWrapper.report(e);\n    }\n    try {\n      tunFd.close();\n    } catch (IOException e) {\n      LogWrapper.report(e);\n    }\n  }","cleancode":"@override public void close() { interrupt(); try { join(); } catch (interruptedexception e) { logwrapper.report(e); } try { tunfd.close(); } catch (ioexception e) { logwrapper.report(e); } }","comment":"\/\/ stop the thread.\n\/\/ after the interrupt, the run() method will stop tun2socks, and then complete. \/\/ we need to wait until that is finished before closing the tun device.\n\/\/ this is weird: the calling thread has _also_ been interrupted.","repo":"superhero75\/Intra","code_context_2":"@Override\npublic void close() {\n\/\/ Stop the thread.\ninterrupt();\n\/\/ After the interrupt, the run() method will stop Tun2Socks, and then complete.\n\n\/\/ Stop the thread.\ninterrupt();\n\/\/ After the interrupt, the run() method will stop Tun2Socks, and then complete.\n\/\/ We need to wait until that is finished before closing the TUN device.\ntry {\njoin();\n\njoin();\n} catch (InterruptedException e) {\n\/\/ This is weird: the calling thread has _also_ been interrupted.\nLogWrapper.report(e);\n}","code_context_10":"@Override\npublic void close() {\n\/\/ Stop the thread.\ninterrupt();\n\/\/ After the interrupt, the run() method will stop Tun2Socks, and then complete.\n\/\/ We need to wait until that is finished before closing the TUN device.\ntry {\njoin();\n} catch (InterruptedException e) {\n\/\/ This is weird: the calling thread has _also_ been interrupted.\nLogWrapper.report(e);\n}\ntry {\n\n@Override\npublic void close() {\n\/\/ Stop the thread.\ninterrupt();\n\/\/ After the interrupt, the run() method will stop Tun2Socks, and then complete.\n\/\/ We need to wait until that is finished before closing the TUN device.\ntry {\njoin();\n} catch (InterruptedException e) {\n\/\/ This is weird: the calling thread has _also_ been interrupted.\nLogWrapper.report(e);\n}\ntry {\ntunFd.close();\n} catch (IOException e) {\nLogWrapper.report(e);\n\n@Override\npublic void close() {\n\/\/ Stop the thread.\ninterrupt();\n\/\/ After the interrupt, the run() method will stop Tun2Socks, and then complete.\n\/\/ We need to wait until that is finished before closing the TUN device.\ntry {\njoin();\n} catch (InterruptedException e) {\n\/\/ This is weird: the calling thread has _also_ been interrupted.\nLogWrapper.report(e);\n}\ntry {\ntunFd.close();\n} catch (IOException e) {\nLogWrapper.report(e);\n}\n}","code_context_20":"@Override\npublic void close() {\n\/\/ Stop the thread.\ninterrupt();\n\/\/ After the interrupt, the run() method will stop Tun2Socks, and then complete.\n\/\/ We need to wait until that is finished before closing the TUN device.\ntry {\njoin();\n} catch (InterruptedException e) {\n\/\/ This is weird: the calling thread has _also_ been interrupted.\nLogWrapper.report(e);\n}\ntry {\ntunFd.close();\n} catch (IOException e) {\nLogWrapper.report(e);\n}\n}\n\n@Override\npublic void close() {\n\/\/ Stop the thread.\ninterrupt();\n\/\/ After the interrupt, the run() method will stop Tun2Socks, and then complete.\n\/\/ We need to wait until that is finished before closing the TUN device.\ntry {\njoin();\n} catch (InterruptedException e) {\n\/\/ This is weird: the calling thread has _also_ been interrupted.\nLogWrapper.report(e);\n}\ntry {\ntunFd.close();\n} catch (IOException e) {\nLogWrapper.report(e);\n}\n}\n\n@Override\npublic void close() {\n\/\/ Stop the thread.\ninterrupt();\n\/\/ After the interrupt, the run() method will stop Tun2Socks, and then complete.\n\/\/ We need to wait until that is finished before closing the TUN device.\ntry {\njoin();\n} catch (InterruptedException e) {\n\/\/ This is weird: the calling thread has _also_ been interrupted.\nLogWrapper.report(e);\n}\ntry {\ntunFd.close();\n} catch (IOException e) {\nLogWrapper.report(e);\n}\n}","label":[0,0,1,0]}
{"id":10520,"original_code":"@Override\n    public Builder setPath(Path absolutePath, Path ideallyRelative) throws IOException {\n      \/\/ TODO(plamenko): this check should not be necessary, but otherwise some tests fail due to\n      \/\/ FileHashLoader throwing NoSuchFileException which doesn't get correctly propagated.\n      if (inputSizeLimit != Long.MAX_VALUE) {\n        sizeLimiter.add(fileHashLoader.getSize(absolutePath));\n      }\n      super.setPath(absolutePath, ideallyRelative);\n      return this;\n    }","code":"@Override\n    public Builder setPath(Path absolutePath, Path ideallyRelative) throws IOException {\n     \n     \n      if (inputSizeLimit != Long.MAX_VALUE) {\n        sizeLimiter.add(fileHashLoader.getSize(absolutePath));\n      }\n      super.setPath(absolutePath, ideallyRelative);\n      return this;\n    }","cleancode":"@override public builder setpath(path absolutepath, path ideallyrelative) throws ioexception { if (inputsizelimit != long.max_value) { sizelimiter.add(filehashloader.getsize(absolutepath)); } super.setpath(absolutepath, ideallyrelative); return this; }","comment":"\/\/ todo(plamenko): this check should not be necessary, but otherwise some tests fail due to \/\/ filehashloader throwing nosuchfileexception which doesn't get correctly propagated.","repo":"stefb965\/buck","code_context_2":"@Override\npublic Builder setPath(Path absolutePath, Path ideallyRelative) throws IOException {\n\/\/ TODO(plamenko): this check should not be necessary, but otherwise some tests fail due to\n\/\/ FileHashLoader throwing NoSuchFileException which doesn't get correctly propagated.\nif (inputSizeLimit != Long.MAX_VALUE) {\nsizeLimiter.add(fileHashLoader.getSize(absolutePath));","code_context_10":"@Override\npublic Builder setPath(Path absolutePath, Path ideallyRelative) throws IOException {\n\/\/ TODO(plamenko): this check should not be necessary, but otherwise some tests fail due to\n\/\/ FileHashLoader throwing NoSuchFileException which doesn't get correctly propagated.\nif (inputSizeLimit != Long.MAX_VALUE) {\nsizeLimiter.add(fileHashLoader.getSize(absolutePath));\n}\nsuper.setPath(absolutePath, ideallyRelative);\nreturn this;\n}","code_context_20":"@Override\npublic Builder setPath(Path absolutePath, Path ideallyRelative) throws IOException {\n\/\/ TODO(plamenko): this check should not be necessary, but otherwise some tests fail due to\n\/\/ FileHashLoader throwing NoSuchFileException which doesn't get correctly propagated.\nif (inputSizeLimit != Long.MAX_VALUE) {\nsizeLimiter.add(fileHashLoader.getSize(absolutePath));\n}\nsuper.setPath(absolutePath, ideallyRelative);\nreturn this;\n}","label":[0,0,1,0]}
{"id":18792,"original_code":"@Test\n  public void testallocateContainerDistributesAllocation() throws Exception {\n    \/* This is a lame test, we should really be testing something like\n    z-score or make sure that we don't have 3sigma kind of events. Too lazy\n    to write all that code. This test very lamely tests if we have more than\n    5 separate nodes  from the list of 10 datanodes that got allocated a\n    container.\n     *\/\n    Set<UUID> pipelineList = new TreeSet<>();\n    for (int x = 0; x < 30; x++) {\n      ContainerInfo containerInfo = containerManager.allocateContainer(\n          replicationType, replicationFactor, OzoneConsts.OZONE);\n      Assert.assertNotNull(containerInfo);\n      Assert.assertNotNull(containerInfo.getPipelineID());\n      pipelineList.add(pipelineManager.getPipeline(\n          containerInfo.getPipelineID()).getFirstNode()\n          .getUuid());\n    }\n    Assert.assertTrue(pipelineList.size() >= 1);\n  }","code":"@Test\n  public void testallocateContainerDistributesAllocation() throws Exception {\n   \n    Set<UUID> pipelineList = new TreeSet<>();\n    for (int x = 0; x < 30; x++) {\n      ContainerInfo containerInfo = containerManager.allocateContainer(\n          replicationType, replicationFactor, OzoneConsts.OZONE);\n      Assert.assertNotNull(containerInfo);\n      Assert.assertNotNull(containerInfo.getPipelineID());\n      pipelineList.add(pipelineManager.getPipeline(\n          containerInfo.getPipelineID()).getFirstNode()\n          .getUuid());\n    }\n    Assert.assertTrue(pipelineList.size() >= 1);\n  }","cleancode":"@test public void testallocatecontainerdistributesallocation() throws exception { set<uuid> pipelinelist = new treeset<>(); for (int x = 0; x < 30; x++) { containerinfo containerinfo = containermanager.allocatecontainer( replicationtype, replicationfactor, ozoneconsts.ozone); assert.assertnotnull(containerinfo); assert.assertnotnull(containerinfo.getpipelineid()); pipelinelist.add(pipelinemanager.getpipeline( containerinfo.getpipelineid()).getfirstnode() .getuuid()); } assert.asserttrue(pipelinelist.size() >= 1); }","comment":"\/* this is a lame test, we should really be testing something like z-score or make sure that we don't have 3sigma kind of events. too lazy to write all that code. this test very lamely tests if we have more than 5 separate nodes from the list of 10 datanodes that got allocated a container. *\/","repo":"smengcl\/hadoop-ozone","code_context_2":"@Test\npublic void testallocateContainerDistributesAllocation() throws Exception {\n\/* This is a lame test, we should really be testing something like\nz-score or make sure that we don't have 3sigma kind of events. Too lazy\nto write all that code. This test very lamely tests if we have more than\n5 separate nodes from the list of 10 datanodes that got allocated a\ncontainer.\n*\/\nSet<UUID> pipelineList = new TreeSet<>();\nfor (int x = 0; x < 30; x++) {","code_context_10":"@Test\npublic void testallocateContainerDistributesAllocation() throws Exception {\n\/* This is a lame test, we should really be testing something like\nz-score or make sure that we don't have 3sigma kind of events. Too lazy\nto write all that code. This test very lamely tests if we have more than\n5 separate nodes from the list of 10 datanodes that got allocated a\ncontainer.\n*\/\nSet<UUID> pipelineList = new TreeSet<>();\nfor (int x = 0; x < 30; x++) {\nContainerInfo containerInfo = containerManager.allocateContainer(\nreplicationType, replicationFactor, OzoneConsts.OZONE);\nAssert.assertNotNull(containerInfo);\nAssert.assertNotNull(containerInfo.getPipelineID());\npipelineList.add(pipelineManager.getPipeline(\ncontainerInfo.getPipelineID()).getFirstNode()\n.getUuid());\n}","code_context_20":"@Test\npublic void testallocateContainerDistributesAllocation() throws Exception {\n\/* This is a lame test, we should really be testing something like\nz-score or make sure that we don't have 3sigma kind of events. Too lazy\nto write all that code. This test very lamely tests if we have more than\n5 separate nodes from the list of 10 datanodes that got allocated a\ncontainer.\n*\/\nSet<UUID> pipelineList = new TreeSet<>();\nfor (int x = 0; x < 30; x++) {\nContainerInfo containerInfo = containerManager.allocateContainer(\nreplicationType, replicationFactor, OzoneConsts.OZONE);\nAssert.assertNotNull(containerInfo);\nAssert.assertNotNull(containerInfo.getPipelineID());\npipelineList.add(pipelineManager.getPipeline(\ncontainerInfo.getPipelineID()).getFirstNode()\n.getUuid());\n}\nAssert.assertTrue(pipelineList.size() >= 1);\n}","label":[1,0,0,0]}
{"id":10608,"original_code":"@BeforeClass\n    public static void createInput() throws IOException {\n        \/\/ TODO: set up your sample input object here.\n        input = null;\n    }","code":"@BeforeClass\n    public static void createInput() throws IOException {\n       \n        input = null;\n    }","cleancode":"@beforeclass public static void createinput() throws ioexception { input = null; }","comment":"\/\/ todo: set up your sample input object here.","repo":"rt-di\/usageserver","code_context_2":"@BeforeClass\npublic static void createInput() throws IOException {\n\/\/ TODO: set up your sample input object here.\ninput = null;\n}","code_context_10":"@BeforeClass\npublic static void createInput() throws IOException {\n\/\/ TODO: set up your sample input object here.\ninput = null;\n}","code_context_20":"@BeforeClass\npublic static void createInput() throws IOException {\n\/\/ TODO: set up your sample input object here.\ninput = null;\n}","label":[0,1,0,0]}
{"id":18984,"original_code":"private void newNoMatchStopsRadioButtonActionPerformed(java.awt.event.ActionEvent evt) {\/\/GEN-FIRST:event_newNoMatchStopsRadioButtonActionPerformed\n        \/\/ TODO change text on button to add\n        updateStopCategory(gtfsUploadNoConflict, 0);\n        dontuploadAllBtn.setEnabled(true);\n    }","code":"private void newNoMatchStopsRadioButtonActionPerformed(java.awt.event.ActionEvent evt) {       \n        updateStopCategory(gtfsUploadNoConflict, 0);\n        dontuploadAllBtn.setEnabled(true);\n    }","cleancode":"private void newnomatchstopsradiobuttonactionperformed(java.awt.event.actionevent evt) { updatestopcategory(gtfsuploadnoconflict, 0); dontuploadallbtn.setenabled(true); }","comment":"\/\/gen-first:event_newnomatchstopsradiobuttonactionperformed\n\/\/ todo change text on button to add","repo":"reubot\/gtfs-osm-sync","code_context_2":"private void newNoMatchStopsRadioButtonActionPerformed(java.awt.event.ActionEvent evt) {\/\/GEN-FIRST:event_newNoMatchStopsRadioButtonActionPerformed\n\/\/ TODO change text on button to add\nupdateStopCategory(gtfsUploadNoConflict, 0);\n\nprivate void newNoMatchStopsRadioButtonActionPerformed(java.awt.event.ActionEvent evt) {\/\/GEN-FIRST:event_newNoMatchStopsRadioButtonActionPerformed\n\/\/ TODO change text on button to add\nupdateStopCategory(gtfsUploadNoConflict, 0);\ndontuploadAllBtn.setEnabled(true);","code_context_10":"private void newNoMatchStopsRadioButtonActionPerformed(java.awt.event.ActionEvent evt) {\/\/GEN-FIRST:event_newNoMatchStopsRadioButtonActionPerformed\n\/\/ TODO change text on button to add\nupdateStopCategory(gtfsUploadNoConflict, 0);\ndontuploadAllBtn.setEnabled(true);\n}\n\nprivate void newNoMatchStopsRadioButtonActionPerformed(java.awt.event.ActionEvent evt) {\/\/GEN-FIRST:event_newNoMatchStopsRadioButtonActionPerformed\n\/\/ TODO change text on button to add\nupdateStopCategory(gtfsUploadNoConflict, 0);\ndontuploadAllBtn.setEnabled(true);\n}","code_context_20":"private void newNoMatchStopsRadioButtonActionPerformed(java.awt.event.ActionEvent evt) {\/\/GEN-FIRST:event_newNoMatchStopsRadioButtonActionPerformed\n\/\/ TODO change text on button to add\nupdateStopCategory(gtfsUploadNoConflict, 0);\ndontuploadAllBtn.setEnabled(true);\n}\n\nprivate void newNoMatchStopsRadioButtonActionPerformed(java.awt.event.ActionEvent evt) {\/\/GEN-FIRST:event_newNoMatchStopsRadioButtonActionPerformed\n\/\/ TODO change text on button to add\nupdateStopCategory(gtfsUploadNoConflict, 0);\ndontuploadAllBtn.setEnabled(true);\n}","label":[0,1,0,0]}
{"id":19409,"original_code":"private static int offsetToLine(String text, int offset) {\n    return offsetToLine(text, 0, offset);\n  }","code":"private static int offsetToLine(String text, int offset) {\n    return offsetToLine(text, 0, offset);\n  }","cleancode":"private static int offsettoline(string text, int offset) { return offsettoline(text, 0, offset); }","comment":"\/\/ todo: optimize","repo":"sylviawan\/oop_assignment1","code_context_2":"private static int offsetToLine(String text, int offset) {\nreturn offsetToLine(text, 0, offset);\n}","code_context_10":"private static int offsetToLine(String text, int offset) {\nreturn offsetToLine(text, 0, offset);\n}","code_context_20":"private static int offsetToLine(String text, int offset) {\nreturn offsetToLine(text, 0, offset);\n}","label":[1,0,0,0]}
{"id":19410,"original_code":"private static int offsetToLine(String text, int start, int offset) {\n    int line = 0;\n    while (offset >= start) {\n      offset = text.lastIndexOf('\\n', offset-1);\n      line++;\n    }\n    return line - 1;\n  }","code":"private static int offsetToLine(String text, int start, int offset) {\n    int line = 0;\n    while (offset >= start) {\n      offset = text.lastIndexOf('\\n', offset-1);\n      line++;\n    }\n    return line - 1;\n  }","cleancode":"private static int offsettoline(string text, int start, int offset) { int line = 0; while (offset >= start) { offset = text.lastindexof('\\n', offset-1); line++; } return line - 1; }","comment":"\/\/ todo: optimize","repo":"sylviawan\/oop_assignment1","code_context_2":"private static int offsetToLine(String text, int start, int offset) {\nint line = 0;\nwhile (offset >= start) {\noffset = text.lastIndexOf('\\n', offset-1);\nline++;\n}\nreturn line - 1;\n}","code_context_10":"private static int offsetToLine(String text, int start, int offset) {\nint line = 0;\nwhile (offset >= start) {\noffset = text.lastIndexOf('\\n', offset-1);\nline++;\n}\nreturn line - 1;\n}","code_context_20":"private static int offsetToLine(String text, int start, int offset) {\nint line = 0;\nwhile (offset >= start) {\noffset = text.lastIndexOf('\\n', offset-1);\nline++;\n}\nreturn line - 1;\n}","label":[1,0,0,0]}
{"id":19420,"original_code":"@Test(dataProvider = \"collectionsAndVersion\")\n   public void testIteration(CollectionOp op, ProtocolVersion version) throws IOException {\n      Map<String, String> dataIn = new HashMap<>();\n      dataIn.put(\"aKey\", \"aValue\");\n      dataIn.put(\"bKey\", \"bValue\");\n      RemoteCache<Object, Object> cacheToUse;\n      RemoteCacheManager temporaryManager;\n      if (version != ProtocolVersion.DEFAULT_PROTOCOL_VERSION) {\n         String servers = HotRodClientTestingUtil.getServersString(hotrodServers);\n         org.infinispan.client.hotrod.configuration.ConfigurationBuilder clientBuilder =\n               new org.infinispan.client.hotrod.configuration.ConfigurationBuilder();\n         \/\/ Set the version on the manager to connect with\n         clientBuilder.version(version);\n         clientBuilder.addServers(servers);\n         temporaryManager = new RemoteCacheManager(clientBuilder.build());\n         cacheToUse = temporaryManager.getCache();\n      } else {\n         temporaryManager = null;\n         cacheToUse = remoteCache;\n      }\n      try {\n         \/\/ putAll doesn't work in older versions (so we use new client) - that is a different issue completely\n         remoteCache.putAll(dataIn);\n         CloseableIteratorCollection<?> collection = op.function.apply(cacheToUse);\n         \/\/ If we don't support it we should get an exception\n         if (version.compareTo(op.minimumVersionForIteration()) < 0) {\n            Exceptions.expectException(UnsupportedOperationException.class, () -> {\n               try (CloseableIterator<?> iter = collection.iterator()) {\n               }\n            });\n         } else {\n            try (CloseableIterator<?> iter = collection.iterator()) {\n               assertTrue(iter.hasNext());\n               assertNotNull(iter.next());\n               assertTrue(iter.hasNext());\n            }\n         }\n      } finally {\n         if (temporaryManager != null) {\n            temporaryManager.close();\n         }\n      }\n   }","code":"@Test(dataProvider = \"collectionsAndVersion\")\n   public void testIteration(CollectionOp op, ProtocolVersion version) throws IOException {\n      Map<String, String> dataIn = new HashMap<>();\n      dataIn.put(\"aKey\", \"aValue\");\n      dataIn.put(\"bKey\", \"bValue\");\n      RemoteCache<Object, Object> cacheToUse;\n      RemoteCacheManager temporaryManager;\n      if (version != ProtocolVersion.DEFAULT_PROTOCOL_VERSION) {\n         String servers = HotRodClientTestingUtil.getServersString(hotrodServers);\n         org.infinispan.client.hotrod.configuration.ConfigurationBuilder clientBuilder =\n               new org.infinispan.client.hotrod.configuration.ConfigurationBuilder();\n        \n         clientBuilder.version(version);\n         clientBuilder.addServers(servers);\n         temporaryManager = new RemoteCacheManager(clientBuilder.build());\n         cacheToUse = temporaryManager.getCache();\n      } else {\n         temporaryManager = null;\n         cacheToUse = remoteCache;\n      }\n      try {\n        \n         remoteCache.putAll(dataIn);\n         CloseableIteratorCollection<?> collection = op.function.apply(cacheToUse);\n        \n         if (version.compareTo(op.minimumVersionForIteration()) < 0) {\n            Exceptions.expectException(UnsupportedOperationException.class, () -> {\n               try (CloseableIterator<?> iter = collection.iterator()) {\n               }\n            });\n         } else {\n            try (CloseableIterator<?> iter = collection.iterator()) {\n               assertTrue(iter.hasNext());\n               assertNotNull(iter.next());\n               assertTrue(iter.hasNext());\n            }\n         }\n      } finally {\n         if (temporaryManager != null) {\n            temporaryManager.close();\n         }\n      }\n   }","cleancode":"@test(dataprovider = \"collectionsandversion\") public void testiteration(collectionop op, protocolversion version) throws ioexception { map<string, string> datain = new hashmap<>(); datain.put(\"akey\", \"avalue\"); datain.put(\"bkey\", \"bvalue\"); remotecache<object, object> cachetouse; remotecachemanager temporarymanager; if (version != protocolversion.default_protocol_version) { string servers = hotrodclienttestingutil.getserversstring(hotrodservers); org.infinispan.client.hotrod.configuration.configurationbuilder clientbuilder = new org.infinispan.client.hotrod.configuration.configurationbuilder(); clientbuilder.version(version); clientbuilder.addservers(servers); temporarymanager = new remotecachemanager(clientbuilder.build()); cachetouse = temporarymanager.getcache(); } else { temporarymanager = null; cachetouse = remotecache; } try { remotecache.putall(datain); closeableiteratorcollection<?> collection = op.function.apply(cachetouse); if (version.compareto(op.minimumversionforiteration()) < 0) { exceptions.expectexception(unsupportedoperationexception.class, () -> { try (closeableiterator<?> iter = collection.iterator()) { } }); } else { try (closeableiterator<?> iter = collection.iterator()) { asserttrue(iter.hasnext()); assertnotnull(iter.next()); asserttrue(iter.hasnext()); } } } finally { if (temporarymanager != null) { temporarymanager.close(); } } }","comment":"\/\/ set the version on the manager to connect with\n\/\/ putall doesn't work in older versions (so we use new client) - that is a different issue completely\n\/\/ if we don't support it we should get an exception","repo":"shawkins\/infinispan-1","code_context_2":"org.infinispan.client.hotrod.configuration.ConfigurationBuilder clientBuilder =\nnew org.infinispan.client.hotrod.configuration.ConfigurationBuilder();\n\/\/ Set the version on the manager to connect with\nclientBuilder.version(version);\nclientBuilder.addServers(servers);\n\n}\ntry {\n\/\/ putAll doesn't work in older versions (so we use new client) - that is a different issue completely\nremoteCache.putAll(dataIn);\nCloseableIteratorCollection<?> collection = op.function.apply(cacheToUse);\n\nremoteCache.putAll(dataIn);\nCloseableIteratorCollection<?> collection = op.function.apply(cacheToUse);\n\/\/ If we don't support it we should get an exception\nif (version.compareTo(op.minimumVersionForIteration()) < 0) {\nExceptions.expectException(UnsupportedOperationException.class, () -> {","code_context_10":"public void testIteration(CollectionOp op, ProtocolVersion version) throws IOException {\nMap<String, String> dataIn = new HashMap<>();\ndataIn.put(\"aKey\", \"aValue\");\ndataIn.put(\"bKey\", \"bValue\");\nRemoteCache<Object, Object> cacheToUse;\nRemoteCacheManager temporaryManager;\nif (version != ProtocolVersion.DEFAULT_PROTOCOL_VERSION) {\nString servers = HotRodClientTestingUtil.getServersString(hotrodServers);\norg.infinispan.client.hotrod.configuration.ConfigurationBuilder clientBuilder =\nnew org.infinispan.client.hotrod.configuration.ConfigurationBuilder();\n\/\/ Set the version on the manager to connect with\nclientBuilder.version(version);\nclientBuilder.addServers(servers);\ntemporaryManager = new RemoteCacheManager(clientBuilder.build());\ncacheToUse = temporaryManager.getCache();\n} else {\ntemporaryManager = null;\ncacheToUse = remoteCache;\n}\ntry {\n\/\/ putAll doesn't work in older versions (so we use new client) - that is a different issue completely\n\n\/\/ Set the version on the manager to connect with\nclientBuilder.version(version);\nclientBuilder.addServers(servers);\ntemporaryManager = new RemoteCacheManager(clientBuilder.build());\ncacheToUse = temporaryManager.getCache();\n} else {\ntemporaryManager = null;\ncacheToUse = remoteCache;\n}\ntry {\n\/\/ putAll doesn't work in older versions (so we use new client) - that is a different issue completely\nremoteCache.putAll(dataIn);\nCloseableIteratorCollection<?> collection = op.function.apply(cacheToUse);\n\/\/ If we don't support it we should get an exception\nif (version.compareTo(op.minimumVersionForIteration()) < 0) {\nExceptions.expectException(UnsupportedOperationException.class, () -> {\ntry (CloseableIterator<?> iter = collection.iterator()) {\n}\n});\n} else {\ntry (CloseableIterator<?> iter = collection.iterator()) {\n\ntemporaryManager = new RemoteCacheManager(clientBuilder.build());\ncacheToUse = temporaryManager.getCache();\n} else {\ntemporaryManager = null;\ncacheToUse = remoteCache;\n}\ntry {\n\/\/ putAll doesn't work in older versions (so we use new client) - that is a different issue completely\nremoteCache.putAll(dataIn);\nCloseableIteratorCollection<?> collection = op.function.apply(cacheToUse);\n\/\/ If we don't support it we should get an exception\nif (version.compareTo(op.minimumVersionForIteration()) < 0) {\nExceptions.expectException(UnsupportedOperationException.class, () -> {\ntry (CloseableIterator<?> iter = collection.iterator()) {\n}\n});\n} else {\ntry (CloseableIterator<?> iter = collection.iterator()) {\nassertTrue(iter.hasNext());\nassertNotNull(iter.next());\nassertTrue(iter.hasNext());","code_context_20":"@Test(dataProvider = \"collectionsAndVersion\")\npublic void testIteration(CollectionOp op, ProtocolVersion version) throws IOException {\nMap<String, String> dataIn = new HashMap<>();\ndataIn.put(\"aKey\", \"aValue\");\ndataIn.put(\"bKey\", \"bValue\");\nRemoteCache<Object, Object> cacheToUse;\nRemoteCacheManager temporaryManager;\nif (version != ProtocolVersion.DEFAULT_PROTOCOL_VERSION) {\nString servers = HotRodClientTestingUtil.getServersString(hotrodServers);\norg.infinispan.client.hotrod.configuration.ConfigurationBuilder clientBuilder =\nnew org.infinispan.client.hotrod.configuration.ConfigurationBuilder();\n\/\/ Set the version on the manager to connect with\nclientBuilder.version(version);\nclientBuilder.addServers(servers);\ntemporaryManager = new RemoteCacheManager(clientBuilder.build());\ncacheToUse = temporaryManager.getCache();\n} else {\ntemporaryManager = null;\ncacheToUse = remoteCache;\n}\ntry {\n\/\/ putAll doesn't work in older versions (so we use new client) - that is a different issue completely\nremoteCache.putAll(dataIn);\nCloseableIteratorCollection<?> collection = op.function.apply(cacheToUse);\n\/\/ If we don't support it we should get an exception\nif (version.compareTo(op.minimumVersionForIteration()) < 0) {\nExceptions.expectException(UnsupportedOperationException.class, () -> {\ntry (CloseableIterator<?> iter = collection.iterator()) {\n}\n});\n} else {\ntry (CloseableIterator<?> iter = collection.iterator()) {\n\npublic void testIteration(CollectionOp op, ProtocolVersion version) throws IOException {\nMap<String, String> dataIn = new HashMap<>();\ndataIn.put(\"aKey\", \"aValue\");\ndataIn.put(\"bKey\", \"bValue\");\nRemoteCache<Object, Object> cacheToUse;\nRemoteCacheManager temporaryManager;\nif (version != ProtocolVersion.DEFAULT_PROTOCOL_VERSION) {\nString servers = HotRodClientTestingUtil.getServersString(hotrodServers);\norg.infinispan.client.hotrod.configuration.ConfigurationBuilder clientBuilder =\nnew org.infinispan.client.hotrod.configuration.ConfigurationBuilder();\n\/\/ Set the version on the manager to connect with\nclientBuilder.version(version);\nclientBuilder.addServers(servers);\ntemporaryManager = new RemoteCacheManager(clientBuilder.build());\ncacheToUse = temporaryManager.getCache();\n} else {\ntemporaryManager = null;\ncacheToUse = remoteCache;\n}\ntry {\n\/\/ putAll doesn't work in older versions (so we use new client) - that is a different issue completely\nremoteCache.putAll(dataIn);\nCloseableIteratorCollection<?> collection = op.function.apply(cacheToUse);\n\/\/ If we don't support it we should get an exception\nif (version.compareTo(op.minimumVersionForIteration()) < 0) {\nExceptions.expectException(UnsupportedOperationException.class, () -> {\ntry (CloseableIterator<?> iter = collection.iterator()) {\n}\n});\n} else {\ntry (CloseableIterator<?> iter = collection.iterator()) {\nassertTrue(iter.hasNext());\nassertNotNull(iter.next());\nassertTrue(iter.hasNext());\n}\n}\n} finally {\nif (temporaryManager != null) {\ntemporaryManager.close();\n}\n}\n\ndataIn.put(\"bKey\", \"bValue\");\nRemoteCache<Object, Object> cacheToUse;\nRemoteCacheManager temporaryManager;\nif (version != ProtocolVersion.DEFAULT_PROTOCOL_VERSION) {\nString servers = HotRodClientTestingUtil.getServersString(hotrodServers);\norg.infinispan.client.hotrod.configuration.ConfigurationBuilder clientBuilder =\nnew org.infinispan.client.hotrod.configuration.ConfigurationBuilder();\n\/\/ Set the version on the manager to connect with\nclientBuilder.version(version);\nclientBuilder.addServers(servers);\ntemporaryManager = new RemoteCacheManager(clientBuilder.build());\ncacheToUse = temporaryManager.getCache();\n} else {\ntemporaryManager = null;\ncacheToUse = remoteCache;\n}\ntry {\n\/\/ putAll doesn't work in older versions (so we use new client) - that is a different issue completely\nremoteCache.putAll(dataIn);\nCloseableIteratorCollection<?> collection = op.function.apply(cacheToUse);\n\/\/ If we don't support it we should get an exception\nif (version.compareTo(op.minimumVersionForIteration()) < 0) {\nExceptions.expectException(UnsupportedOperationException.class, () -> {\ntry (CloseableIterator<?> iter = collection.iterator()) {\n}\n});\n} else {\ntry (CloseableIterator<?> iter = collection.iterator()) {\nassertTrue(iter.hasNext());\nassertNotNull(iter.next());\nassertTrue(iter.hasNext());\n}\n}\n} finally {\nif (temporaryManager != null) {\ntemporaryManager.close();\n}\n}\n}","label":[0,0,1,0]}
{"id":11310,"original_code":"public static int insertWMFromFile(String species,\n                                       String wmname,\n                                       String wmversion,\n                                       String wmtype,\n                                       String wmfile) throws SQLException, NotFoundException, UnknownRoleException, FileNotFoundException, ParseException, IOException {\n        WeightMatrix matrix;\n        System.err.println(\"name \" + wmname + \" version \" + wmversion + \" type \" + wmtype);\n        if (wmtype.matches(\".*TAMO.*\")) {\n            matrix = PWMParser.readTamoMatrix(wmfile);\n        } else if (wmtype.matches(\".*MEME.*\")) {\n            matrix = PWMParser.readMemeMatrix(wmfile);\n        } else if (wmtype.matches(\".*SEQ.*\")) { \n            matrix = PWMParser.readAlignedSequenceMatrix(wmfile);\n        } else if (wmtype.matches(\".*TRANSFAC.*\")) {\n          \/\/TODO add a method to read a single transfac matrix\n          matrix = PWMParser.readTRANSFACFreqMatrices(wmfile, wmversion).get(0);\n        } else if (wmtype.matches(\".*PRIORITY.*\")) {\n          matrix = PWMParser.parsePriorityBestOutput(wmfile);\n        } else if (wmtype.matches(\".*UniProbe.*\")) {\n            matrix = PWMParser.readUniProbeFile(wmfile);\n        } else if (wmtype.toUpperCase().matches(\".*GIMME.*\")) {\n            matrix = PWMParser.readGimmeMotifsMatrices(wmfile,wmversion,wmtype).get(0);\n        } else {\n            System.err.println(\"Didn't see a program I recognize in the type.  defaulting to reading TAMO format\");\n            matrix = PWMParser.readTamoMatrix(wmfile);\n        }\n        matrix.name = wmname;\n        matrix.version = wmversion;\n        matrix.type = wmtype;\n        matrix.speciesid = (new Species(species)).getDBID();\n        return insertMatrixIntoDB(matrix);\n    }","code":"public static int insertWMFromFile(String species,\n                                       String wmname,\n                                       String wmversion,\n                                       String wmtype,\n                                       String wmfile) throws SQLException, NotFoundException, UnknownRoleException, FileNotFoundException, ParseException, IOException {\n        WeightMatrix matrix;\n        System.err.println(\"name \" + wmname + \" version \" + wmversion + \" type \" + wmtype);\n        if (wmtype.matches(\".*TAMO.*\")) {\n            matrix = PWMParser.readTamoMatrix(wmfile);\n        } else if (wmtype.matches(\".*MEME.*\")) {\n            matrix = PWMParser.readMemeMatrix(wmfile);\n        } else if (wmtype.matches(\".*SEQ.*\")) { \n            matrix = PWMParser.readAlignedSequenceMatrix(wmfile);\n        } else if (wmtype.matches(\".*TRANSFAC.*\")) {\n         \n          matrix = PWMParser.readTRANSFACFreqMatrices(wmfile, wmversion).get(0);\n        } else if (wmtype.matches(\".*PRIORITY.*\")) {\n          matrix = PWMParser.parsePriorityBestOutput(wmfile);\n        } else if (wmtype.matches(\".*UniProbe.*\")) {\n            matrix = PWMParser.readUniProbeFile(wmfile);\n        } else if (wmtype.toUpperCase().matches(\".*GIMME.*\")) {\n            matrix = PWMParser.readGimmeMotifsMatrices(wmfile,wmversion,wmtype).get(0);\n        } else {\n            System.err.println(\"Didn't see a program I recognize in the type.  defaulting to reading TAMO format\");\n            matrix = PWMParser.readTamoMatrix(wmfile);\n        }\n        matrix.name = wmname;\n        matrix.version = wmversion;\n        matrix.type = wmtype;\n        matrix.speciesid = (new Species(species)).getDBID();\n        return insertMatrixIntoDB(matrix);\n    }","cleancode":"public static int insertwmfromfile(string species, string wmname, string wmversion, string wmtype, string wmfile) throws sqlexception, notfoundexception, unknownroleexception, filenotfoundexception, parseexception, ioexception { weightmatrix matrix; system.err.println(\"name \" + wmname + \" version \" + wmversion + \" type \" + wmtype); if (wmtype.matches(\".*tamo.*\")) { matrix = pwmparser.readtamomatrix(wmfile); } else if (wmtype.matches(\".*meme.*\")) { matrix = pwmparser.readmemematrix(wmfile); } else if (wmtype.matches(\".*seq.*\")) { matrix = pwmparser.readalignedsequencematrix(wmfile); } else if (wmtype.matches(\".*transfac.*\")) { matrix = pwmparser.readtransfacfreqmatrices(wmfile, wmversion).get(0); } else if (wmtype.matches(\".*priority.*\")) { matrix = pwmparser.parseprioritybestoutput(wmfile); } else if (wmtype.matches(\".*uniprobe.*\")) { matrix = pwmparser.readuniprobefile(wmfile); } else if (wmtype.touppercase().matches(\".*gimme.*\")) { matrix = pwmparser.readgimmemotifsmatrices(wmfile,wmversion,wmtype).get(0); } else { system.err.println(\"didn't see a program i recognize in the type. defaulting to reading tamo format\"); matrix = pwmparser.readtamomatrix(wmfile); } matrix.name = wmname; matrix.version = wmversion; matrix.type = wmtype; matrix.speciesid = (new species(species)).getdbid(); return insertmatrixintodb(matrix); }","comment":"\/* reads a weight matrix from the specified file, inserts it into the database with the specified name and version, and returns its dbid. this means that the file may contain only a single weight matrix*\/\n\/\/todo add a method to read a single transfac matrix","repo":"seqcode\/seqcode-core","code_context_2":"public static int insertWMFromFile(String species,\nString wmname,\nString wmversion,\nString wmtype,\nString wmfile) throws SQLException, NotFoundException, UnknownRoleException, FileNotFoundException, ParseException, IOException {\nWeightMatrix matrix;\nSystem.err.println(\"name \" + wmname + \" version \" + wmversion + \" type \" + wmtype);\nif (wmtype.matches(\".*TAMO.*\")) {\nmatrix = PWMParser.readTamoMatrix(wmfile);\n} else if (wmtype.matches(\".*MEME.*\")) {\nmatrix = PWMParser.readMemeMatrix(wmfile);\n} else if (wmtype.matches(\".*SEQ.*\")) {\nmatrix = PWMParser.readAlignedSequenceMatrix(wmfile);\n} else if (wmtype.matches(\".*TRANSFAC.*\")) {\n\/\/TODO add a method to read a single transfac matrix\nmatrix = PWMParser.readTRANSFACFreqMatrices(wmfile, wmversion).get(0);\n} else if (wmtype.matches(\".*PRIORITY.*\")) {\nmatrix = PWMParser.parsePriorityBestOutput(wmfile);\n} else if (wmtype.matches(\".*UniProbe.*\")) {\nmatrix = PWMParser.readUniProbeFile(wmfile);\n} else if (wmtype.toUpperCase().matches(\".*GIMME.*\")) {\nmatrix = PWMParser.readGimmeMotifsMatrices(wmfile,wmversion,wmtype).get(0);\n} else {\nSystem.err.println(\"Didn't see a program I recognize in the type. defaulting to reading TAMO format\");\nmatrix = PWMParser.readTamoMatrix(wmfile);\n}\nmatrix.name = wmname;\nmatrix.version = wmversion;\nmatrix.type = wmtype;\nmatrix.speciesid = (new Species(species)).getDBID();\nreturn insertMatrixIntoDB(matrix);\n}\n\nmatrix = PWMParser.readAlignedSequenceMatrix(wmfile);\n} else if (wmtype.matches(\".*TRANSFAC.*\")) {\n\/\/TODO add a method to read a single transfac matrix\nmatrix = PWMParser.readTRANSFACFreqMatrices(wmfile, wmversion).get(0);\n} else if (wmtype.matches(\".*PRIORITY.*\")) {","code_context_10":"public static int insertWMFromFile(String species,\nString wmname,\nString wmversion,\nString wmtype,\nString wmfile) throws SQLException, NotFoundException, UnknownRoleException, FileNotFoundException, ParseException, IOException {\nWeightMatrix matrix;\nSystem.err.println(\"name \" + wmname + \" version \" + wmversion + \" type \" + wmtype);\nif (wmtype.matches(\".*TAMO.*\")) {\nmatrix = PWMParser.readTamoMatrix(wmfile);\n} else if (wmtype.matches(\".*MEME.*\")) {\nmatrix = PWMParser.readMemeMatrix(wmfile);\n} else if (wmtype.matches(\".*SEQ.*\")) {\nmatrix = PWMParser.readAlignedSequenceMatrix(wmfile);\n} else if (wmtype.matches(\".*TRANSFAC.*\")) {\n\/\/TODO add a method to read a single transfac matrix\nmatrix = PWMParser.readTRANSFACFreqMatrices(wmfile, wmversion).get(0);\n} else if (wmtype.matches(\".*PRIORITY.*\")) {\nmatrix = PWMParser.parsePriorityBestOutput(wmfile);\n} else if (wmtype.matches(\".*UniProbe.*\")) {\nmatrix = PWMParser.readUniProbeFile(wmfile);\n} else if (wmtype.toUpperCase().matches(\".*GIMME.*\")) {\nmatrix = PWMParser.readGimmeMotifsMatrices(wmfile,wmversion,wmtype).get(0);\n} else {\nSystem.err.println(\"Didn't see a program I recognize in the type. defaulting to reading TAMO format\");\nmatrix = PWMParser.readTamoMatrix(wmfile);\n}\nmatrix.name = wmname;\nmatrix.version = wmversion;\nmatrix.type = wmtype;\nmatrix.speciesid = (new Species(species)).getDBID();\nreturn insertMatrixIntoDB(matrix);\n}\n\nString wmfile) throws SQLException, NotFoundException, UnknownRoleException, FileNotFoundException, ParseException, IOException {\nWeightMatrix matrix;\nSystem.err.println(\"name \" + wmname + \" version \" + wmversion + \" type \" + wmtype);\nif (wmtype.matches(\".*TAMO.*\")) {\nmatrix = PWMParser.readTamoMatrix(wmfile);\n} else if (wmtype.matches(\".*MEME.*\")) {\nmatrix = PWMParser.readMemeMatrix(wmfile);\n} else if (wmtype.matches(\".*SEQ.*\")) {\nmatrix = PWMParser.readAlignedSequenceMatrix(wmfile);\n} else if (wmtype.matches(\".*TRANSFAC.*\")) {\n\/\/TODO add a method to read a single transfac matrix\nmatrix = PWMParser.readTRANSFACFreqMatrices(wmfile, wmversion).get(0);\n} else if (wmtype.matches(\".*PRIORITY.*\")) {\nmatrix = PWMParser.parsePriorityBestOutput(wmfile);\n} else if (wmtype.matches(\".*UniProbe.*\")) {\nmatrix = PWMParser.readUniProbeFile(wmfile);\n} else if (wmtype.toUpperCase().matches(\".*GIMME.*\")) {\nmatrix = PWMParser.readGimmeMotifsMatrices(wmfile,wmversion,wmtype).get(0);\n} else {\nSystem.err.println(\"Didn't see a program I recognize in the type. defaulting to reading TAMO format\");\nmatrix = PWMParser.readTamoMatrix(wmfile);","code_context_20":"public static int insertWMFromFile(String species,\nString wmname,\nString wmversion,\nString wmtype,\nString wmfile) throws SQLException, NotFoundException, UnknownRoleException, FileNotFoundException, ParseException, IOException {\nWeightMatrix matrix;\nSystem.err.println(\"name \" + wmname + \" version \" + wmversion + \" type \" + wmtype);\nif (wmtype.matches(\".*TAMO.*\")) {\nmatrix = PWMParser.readTamoMatrix(wmfile);\n} else if (wmtype.matches(\".*MEME.*\")) {\nmatrix = PWMParser.readMemeMatrix(wmfile);\n} else if (wmtype.matches(\".*SEQ.*\")) {\nmatrix = PWMParser.readAlignedSequenceMatrix(wmfile);\n} else if (wmtype.matches(\".*TRANSFAC.*\")) {\n\/\/TODO add a method to read a single transfac matrix\nmatrix = PWMParser.readTRANSFACFreqMatrices(wmfile, wmversion).get(0);\n} else if (wmtype.matches(\".*PRIORITY.*\")) {\nmatrix = PWMParser.parsePriorityBestOutput(wmfile);\n} else if (wmtype.matches(\".*UniProbe.*\")) {\nmatrix = PWMParser.readUniProbeFile(wmfile);\n} else if (wmtype.toUpperCase().matches(\".*GIMME.*\")) {\nmatrix = PWMParser.readGimmeMotifsMatrices(wmfile,wmversion,wmtype).get(0);\n} else {\nSystem.err.println(\"Didn't see a program I recognize in the type. defaulting to reading TAMO format\");\nmatrix = PWMParser.readTamoMatrix(wmfile);\n}\nmatrix.name = wmname;\nmatrix.version = wmversion;\nmatrix.type = wmtype;\nmatrix.speciesid = (new Species(species)).getDBID();\nreturn insertMatrixIntoDB(matrix);\n}\n\npublic static int insertWMFromFile(String species,\nString wmname,\nString wmversion,\nString wmtype,\nString wmfile) throws SQLException, NotFoundException, UnknownRoleException, FileNotFoundException, ParseException, IOException {\nWeightMatrix matrix;\nSystem.err.println(\"name \" + wmname + \" version \" + wmversion + \" type \" + wmtype);\nif (wmtype.matches(\".*TAMO.*\")) {\nmatrix = PWMParser.readTamoMatrix(wmfile);\n} else if (wmtype.matches(\".*MEME.*\")) {\nmatrix = PWMParser.readMemeMatrix(wmfile);\n} else if (wmtype.matches(\".*SEQ.*\")) {\nmatrix = PWMParser.readAlignedSequenceMatrix(wmfile);\n} else if (wmtype.matches(\".*TRANSFAC.*\")) {\n\/\/TODO add a method to read a single transfac matrix\nmatrix = PWMParser.readTRANSFACFreqMatrices(wmfile, wmversion).get(0);\n} else if (wmtype.matches(\".*PRIORITY.*\")) {\nmatrix = PWMParser.parsePriorityBestOutput(wmfile);\n} else if (wmtype.matches(\".*UniProbe.*\")) {\nmatrix = PWMParser.readUniProbeFile(wmfile);\n} else if (wmtype.toUpperCase().matches(\".*GIMME.*\")) {\nmatrix = PWMParser.readGimmeMotifsMatrices(wmfile,wmversion,wmtype).get(0);\n} else {\nSystem.err.println(\"Didn't see a program I recognize in the type. defaulting to reading TAMO format\");\nmatrix = PWMParser.readTamoMatrix(wmfile);\n}\nmatrix.name = wmname;\nmatrix.version = wmversion;\nmatrix.type = wmtype;\nmatrix.speciesid = (new Species(species)).getDBID();\nreturn insertMatrixIntoDB(matrix);\n}","label":[0,1,0,0]}
{"id":11311,"original_code":"public static int insertWMFromFile(String species, String wmname, String wmversion, String wmtype, String wmfile, String bgFreq) \n  throws SQLException, NotFoundException, UnknownRoleException, FileNotFoundException, ParseException, IOException {\n    WeightMatrix matrix;\n    if (wmtype.matches(\".*TAMO.*\")) {\n      matrix = PWMParser.readTamoMatrix(wmfile);\n    } else if (wmtype.matches(\".*MEME.*\")) {\n      matrix = PWMParser.readMemeMatrix(wmfile);\n    } else if (wmtype.matches(\".*SEQ.*\")) { \n      matrix = PWMParser.readAlignedSequenceMatrix(wmfile);\n    } else if (wmtype.matches(\".*TRANSFAC.*\")) {\n      \/\/TODO add a method to read a single transfac matrix\n      matrix = PWMParser.readTRANSFACFreqMatrices(wmfile, wmversion).get(0);\n    } else if (wmtype.matches(\".*PRIORITY.*\")) {\n      matrix = PWMParser.parsePriorityBestOutput(wmfile);\n    } else if (wmtype.toUpperCase().matches(\".*GIMME.*\")) {\n        matrix = PWMParser.readGimmeMotifsMatrices(wmfile,wmversion,wmtype).get(0);\n    } else {\n      System.err.println(\"Didn't see a program I recognize in the type.  defaulting to reading TAMO format\");\n      matrix = PWMParser.readTamoMatrix(wmfile);\n    }\n    matrix.name = wmname;\n    matrix.version = wmversion;\n    matrix.type = wmtype;\n    matrix.speciesid = (new Species(species)).getDBID();\n    return insertMatrixIntoDB(matrix);\n }","code":"public static int insertWMFromFile(String species, String wmname, String wmversion, String wmtype, String wmfile, String bgFreq) \n  throws SQLException, NotFoundException, UnknownRoleException, FileNotFoundException, ParseException, IOException {\n    WeightMatrix matrix;\n    if (wmtype.matches(\".*TAMO.*\")) {\n      matrix = PWMParser.readTamoMatrix(wmfile);\n    } else if (wmtype.matches(\".*MEME.*\")) {\n      matrix = PWMParser.readMemeMatrix(wmfile);\n    } else if (wmtype.matches(\".*SEQ.*\")) { \n      matrix = PWMParser.readAlignedSequenceMatrix(wmfile);\n    } else if (wmtype.matches(\".*TRANSFAC.*\")) {\n     \n      matrix = PWMParser.readTRANSFACFreqMatrices(wmfile, wmversion).get(0);\n    } else if (wmtype.matches(\".*PRIORITY.*\")) {\n      matrix = PWMParser.parsePriorityBestOutput(wmfile);\n    } else if (wmtype.toUpperCase().matches(\".*GIMME.*\")) {\n        matrix = PWMParser.readGimmeMotifsMatrices(wmfile,wmversion,wmtype).get(0);\n    } else {\n      System.err.println(\"Didn't see a program I recognize in the type.  defaulting to reading TAMO format\");\n      matrix = PWMParser.readTamoMatrix(wmfile);\n    }\n    matrix.name = wmname;\n    matrix.version = wmversion;\n    matrix.type = wmtype;\n    matrix.speciesid = (new Species(species)).getDBID();\n    return insertMatrixIntoDB(matrix);\n }","cleancode":"public static int insertwmfromfile(string species, string wmname, string wmversion, string wmtype, string wmfile, string bgfreq) throws sqlexception, notfoundexception, unknownroleexception, filenotfoundexception, parseexception, ioexception { weightmatrix matrix; if (wmtype.matches(\".*tamo.*\")) { matrix = pwmparser.readtamomatrix(wmfile); } else if (wmtype.matches(\".*meme.*\")) { matrix = pwmparser.readmemematrix(wmfile); } else if (wmtype.matches(\".*seq.*\")) { matrix = pwmparser.readalignedsequencematrix(wmfile); } else if (wmtype.matches(\".*transfac.*\")) { matrix = pwmparser.readtransfacfreqmatrices(wmfile, wmversion).get(0); } else if (wmtype.matches(\".*priority.*\")) { matrix = pwmparser.parseprioritybestoutput(wmfile); } else if (wmtype.touppercase().matches(\".*gimme.*\")) { matrix = pwmparser.readgimmemotifsmatrices(wmfile,wmversion,wmtype).get(0); } else { system.err.println(\"didn't see a program i recognize in the type. defaulting to reading tamo format\"); matrix = pwmparser.readtamomatrix(wmfile); } matrix.name = wmname; matrix.version = wmversion; matrix.type = wmtype; matrix.speciesid = (new species(species)).getdbid(); return insertmatrixintodb(matrix); }","comment":"\/* reads a weight matrix from the specified file, inserts it into the database with the specified name and version, and returns its dbid. this means that the file may contain only a single weight matrix*\/\n\/\/todo add a method to read a single transfac matrix","repo":"seqcode\/seqcode-core","code_context_2":"public static int insertWMFromFile(String species, String wmname, String wmversion, String wmtype, String wmfile, String bgFreq)\nthrows SQLException, NotFoundException, UnknownRoleException, FileNotFoundException, ParseException, IOException {\nWeightMatrix matrix;\nif (wmtype.matches(\".*TAMO.*\")) {\nmatrix = PWMParser.readTamoMatrix(wmfile);\n} else if (wmtype.matches(\".*MEME.*\")) {\nmatrix = PWMParser.readMemeMatrix(wmfile);\n} else if (wmtype.matches(\".*SEQ.*\")) {\nmatrix = PWMParser.readAlignedSequenceMatrix(wmfile);\n} else if (wmtype.matches(\".*TRANSFAC.*\")) {\n\/\/TODO add a method to read a single transfac matrix\nmatrix = PWMParser.readTRANSFACFreqMatrices(wmfile, wmversion).get(0);\n} else if (wmtype.matches(\".*PRIORITY.*\")) {\nmatrix = PWMParser.parsePriorityBestOutput(wmfile);\n} else if (wmtype.toUpperCase().matches(\".*GIMME.*\")) {\nmatrix = PWMParser.readGimmeMotifsMatrices(wmfile,wmversion,wmtype).get(0);\n} else {\nSystem.err.println(\"Didn't see a program I recognize in the type. defaulting to reading TAMO format\");\nmatrix = PWMParser.readTamoMatrix(wmfile);\n}\nmatrix.name = wmname;\nmatrix.version = wmversion;\nmatrix.type = wmtype;\nmatrix.speciesid = (new Species(species)).getDBID();\nreturn insertMatrixIntoDB(matrix);\n}\n\nmatrix = PWMParser.readAlignedSequenceMatrix(wmfile);\n} else if (wmtype.matches(\".*TRANSFAC.*\")) {\n\/\/TODO add a method to read a single transfac matrix\nmatrix = PWMParser.readTRANSFACFreqMatrices(wmfile, wmversion).get(0);\n} else if (wmtype.matches(\".*PRIORITY.*\")) {","code_context_10":"public static int insertWMFromFile(String species, String wmname, String wmversion, String wmtype, String wmfile, String bgFreq)\nthrows SQLException, NotFoundException, UnknownRoleException, FileNotFoundException, ParseException, IOException {\nWeightMatrix matrix;\nif (wmtype.matches(\".*TAMO.*\")) {\nmatrix = PWMParser.readTamoMatrix(wmfile);\n} else if (wmtype.matches(\".*MEME.*\")) {\nmatrix = PWMParser.readMemeMatrix(wmfile);\n} else if (wmtype.matches(\".*SEQ.*\")) {\nmatrix = PWMParser.readAlignedSequenceMatrix(wmfile);\n} else if (wmtype.matches(\".*TRANSFAC.*\")) {\n\/\/TODO add a method to read a single transfac matrix\nmatrix = PWMParser.readTRANSFACFreqMatrices(wmfile, wmversion).get(0);\n} else if (wmtype.matches(\".*PRIORITY.*\")) {\nmatrix = PWMParser.parsePriorityBestOutput(wmfile);\n} else if (wmtype.toUpperCase().matches(\".*GIMME.*\")) {\nmatrix = PWMParser.readGimmeMotifsMatrices(wmfile,wmversion,wmtype).get(0);\n} else {\nSystem.err.println(\"Didn't see a program I recognize in the type. defaulting to reading TAMO format\");\nmatrix = PWMParser.readTamoMatrix(wmfile);\n}\nmatrix.name = wmname;\nmatrix.version = wmversion;\nmatrix.type = wmtype;\nmatrix.speciesid = (new Species(species)).getDBID();\nreturn insertMatrixIntoDB(matrix);\n}\n\npublic static int insertWMFromFile(String species, String wmname, String wmversion, String wmtype, String wmfile, String bgFreq)\nthrows SQLException, NotFoundException, UnknownRoleException, FileNotFoundException, ParseException, IOException {\nWeightMatrix matrix;\nif (wmtype.matches(\".*TAMO.*\")) {\nmatrix = PWMParser.readTamoMatrix(wmfile);\n} else if (wmtype.matches(\".*MEME.*\")) {\nmatrix = PWMParser.readMemeMatrix(wmfile);\n} else if (wmtype.matches(\".*SEQ.*\")) {\nmatrix = PWMParser.readAlignedSequenceMatrix(wmfile);\n} else if (wmtype.matches(\".*TRANSFAC.*\")) {\n\/\/TODO add a method to read a single transfac matrix\nmatrix = PWMParser.readTRANSFACFreqMatrices(wmfile, wmversion).get(0);\n} else if (wmtype.matches(\".*PRIORITY.*\")) {\nmatrix = PWMParser.parsePriorityBestOutput(wmfile);\n} else if (wmtype.toUpperCase().matches(\".*GIMME.*\")) {\nmatrix = PWMParser.readGimmeMotifsMatrices(wmfile,wmversion,wmtype).get(0);\n} else {\nSystem.err.println(\"Didn't see a program I recognize in the type. defaulting to reading TAMO format\");\nmatrix = PWMParser.readTamoMatrix(wmfile);\n}\nmatrix.name = wmname;","code_context_20":"public static int insertWMFromFile(String species, String wmname, String wmversion, String wmtype, String wmfile, String bgFreq)\nthrows SQLException, NotFoundException, UnknownRoleException, FileNotFoundException, ParseException, IOException {\nWeightMatrix matrix;\nif (wmtype.matches(\".*TAMO.*\")) {\nmatrix = PWMParser.readTamoMatrix(wmfile);\n} else if (wmtype.matches(\".*MEME.*\")) {\nmatrix = PWMParser.readMemeMatrix(wmfile);\n} else if (wmtype.matches(\".*SEQ.*\")) {\nmatrix = PWMParser.readAlignedSequenceMatrix(wmfile);\n} else if (wmtype.matches(\".*TRANSFAC.*\")) {\n\/\/TODO add a method to read a single transfac matrix\nmatrix = PWMParser.readTRANSFACFreqMatrices(wmfile, wmversion).get(0);\n} else if (wmtype.matches(\".*PRIORITY.*\")) {\nmatrix = PWMParser.parsePriorityBestOutput(wmfile);\n} else if (wmtype.toUpperCase().matches(\".*GIMME.*\")) {\nmatrix = PWMParser.readGimmeMotifsMatrices(wmfile,wmversion,wmtype).get(0);\n} else {\nSystem.err.println(\"Didn't see a program I recognize in the type. defaulting to reading TAMO format\");\nmatrix = PWMParser.readTamoMatrix(wmfile);\n}\nmatrix.name = wmname;\nmatrix.version = wmversion;\nmatrix.type = wmtype;\nmatrix.speciesid = (new Species(species)).getDBID();\nreturn insertMatrixIntoDB(matrix);\n}\n\npublic static int insertWMFromFile(String species, String wmname, String wmversion, String wmtype, String wmfile, String bgFreq)\nthrows SQLException, NotFoundException, UnknownRoleException, FileNotFoundException, ParseException, IOException {\nWeightMatrix matrix;\nif (wmtype.matches(\".*TAMO.*\")) {\nmatrix = PWMParser.readTamoMatrix(wmfile);\n} else if (wmtype.matches(\".*MEME.*\")) {\nmatrix = PWMParser.readMemeMatrix(wmfile);\n} else if (wmtype.matches(\".*SEQ.*\")) {\nmatrix = PWMParser.readAlignedSequenceMatrix(wmfile);\n} else if (wmtype.matches(\".*TRANSFAC.*\")) {\n\/\/TODO add a method to read a single transfac matrix\nmatrix = PWMParser.readTRANSFACFreqMatrices(wmfile, wmversion).get(0);\n} else if (wmtype.matches(\".*PRIORITY.*\")) {\nmatrix = PWMParser.parsePriorityBestOutput(wmfile);\n} else if (wmtype.toUpperCase().matches(\".*GIMME.*\")) {\nmatrix = PWMParser.readGimmeMotifsMatrices(wmfile,wmversion,wmtype).get(0);\n} else {\nSystem.err.println(\"Didn't see a program I recognize in the type. defaulting to reading TAMO format\");\nmatrix = PWMParser.readTamoMatrix(wmfile);\n}\nmatrix.name = wmname;\nmatrix.version = wmversion;\nmatrix.type = wmtype;\nmatrix.speciesid = (new Species(species)).getDBID();\nreturn insertMatrixIntoDB(matrix);\n}","label":[0,1,0,0]}
{"id":19634,"original_code":"@Override\n    public MergerToken createSetNotNullToDb(DbEntity entity, DbAttribute column) {\n        return new SetNotNullToDb(entity, column) {\n            @Override\n            public List<String> createSql(DbAdapter adapter) {\n                \/*\n                 * TODO: we generate this query as in ingres db documentation,\n                 * but unfortunately ingres don't support it\n                 *\/\n                StringBuilder sqlBuffer = new StringBuilder();\n                QuotingStrategy context = adapter.getQuotingStrategy();\n                sqlBuffer.append(\"ALTER TABLE \");\n                sqlBuffer.append(getEntity().getFullyQualifiedName());\n                sqlBuffer.append(\" ALTER COLUMN \");\n                sqlBuffer.append(context.quotedName(getColumn()));\n                sqlBuffer.append(\" \");\n                sqlBuffer.append(adapter.externalTypesForJdbcType(getColumn().getType())[0]);\n                if (adapter.typeSupportsLength(getColumn().getType()) && getColumn().getMaxLength() > 0) {\n                    sqlBuffer.append(\"(\");\n                    sqlBuffer.append(getColumn().getMaxLength());\n                    sqlBuffer.append(\")\");\n                }\n                sqlBuffer.append(\" NOT NULL\");\n                return Collections.singletonList(sqlBuffer.toString());\n            }\n        };\n    }","code":"@Override\n    public MergerToken createSetNotNullToDb(DbEntity entity, DbAttribute column) {\n        return new SetNotNullToDb(entity, column) {\n            @Override\n            public List<String> createSql(DbAdapter adapter) {\n               \n                StringBuilder sqlBuffer = new StringBuilder();\n                QuotingStrategy context = adapter.getQuotingStrategy();\n                sqlBuffer.append(\"ALTER TABLE \");\n                sqlBuffer.append(getEntity().getFullyQualifiedName());\n                sqlBuffer.append(\" ALTER COLUMN \");\n                sqlBuffer.append(context.quotedName(getColumn()));\n                sqlBuffer.append(\" \");\n                sqlBuffer.append(adapter.externalTypesForJdbcType(getColumn().getType())[0]);\n                if (adapter.typeSupportsLength(getColumn().getType()) && getColumn().getMaxLength() > 0) {\n                    sqlBuffer.append(\"(\");\n                    sqlBuffer.append(getColumn().getMaxLength());\n                    sqlBuffer.append(\")\");\n                }\n                sqlBuffer.append(\" NOT NULL\");\n                return Collections.singletonList(sqlBuffer.toString());\n            }\n        };\n    }","cleancode":"@override public mergertoken createsetnotnulltodb(dbentity entity, dbattribute column) { return new setnotnulltodb(entity, column) { @override public list<string> createsql(dbadapter adapter) { stringbuilder sqlbuffer = new stringbuilder(); quotingstrategy context = adapter.getquotingstrategy(); sqlbuffer.append(\"alter table \"); sqlbuffer.append(getentity().getfullyqualifiedname()); sqlbuffer.append(\" alter column \"); sqlbuffer.append(context.quotedname(getcolumn())); sqlbuffer.append(\" \"); sqlbuffer.append(adapter.externaltypesforjdbctype(getcolumn().gettype())[0]); if (adapter.typesupportslength(getcolumn().gettype()) && getcolumn().getmaxlength() > 0) { sqlbuffer.append(\"(\"); sqlbuffer.append(getcolumn().getmaxlength()); sqlbuffer.append(\")\"); } sqlbuffer.append(\" not null\"); return collections.singletonlist(sqlbuffer.tostring()); } }; }","comment":"\/* * todo: we generate this query as in ingres db documentation, * but unfortunately ingres don't support it *\/","repo":"rohankumardubey\/cayenne","code_context_2":"@Override\npublic List<String> createSql(DbAdapter adapter) {\n\/*\n* TODO: we generate this query as in ingres db documentation,\n* but unfortunately ingres don't support it\n*\/\nStringBuilder sqlBuffer = new StringBuilder();\nQuotingStrategy context = adapter.getQuotingStrategy();","code_context_10":"@Override\npublic MergerToken createSetNotNullToDb(DbEntity entity, DbAttribute column) {\nreturn new SetNotNullToDb(entity, column) {\n@Override\npublic List<String> createSql(DbAdapter adapter) {\n\/*\n* TODO: we generate this query as in ingres db documentation,\n* but unfortunately ingres don't support it\n*\/\nStringBuilder sqlBuffer = new StringBuilder();\nQuotingStrategy context = adapter.getQuotingStrategy();\nsqlBuffer.append(\"ALTER TABLE \");\nsqlBuffer.append(getEntity().getFullyQualifiedName());\nsqlBuffer.append(\" ALTER COLUMN \");\nsqlBuffer.append(context.quotedName(getColumn()));\nsqlBuffer.append(\" \");\nsqlBuffer.append(adapter.externalTypesForJdbcType(getColumn().getType())[0]);\nif (adapter.typeSupportsLength(getColumn().getType()) && getColumn().getMaxLength() > 0) {\nsqlBuffer.append(\"(\");","code_context_20":"@Override\npublic MergerToken createSetNotNullToDb(DbEntity entity, DbAttribute column) {\nreturn new SetNotNullToDb(entity, column) {\n@Override\npublic List<String> createSql(DbAdapter adapter) {\n\/*\n* TODO: we generate this query as in ingres db documentation,\n* but unfortunately ingres don't support it\n*\/\nStringBuilder sqlBuffer = new StringBuilder();\nQuotingStrategy context = adapter.getQuotingStrategy();\nsqlBuffer.append(\"ALTER TABLE \");\nsqlBuffer.append(getEntity().getFullyQualifiedName());\nsqlBuffer.append(\" ALTER COLUMN \");\nsqlBuffer.append(context.quotedName(getColumn()));\nsqlBuffer.append(\" \");\nsqlBuffer.append(adapter.externalTypesForJdbcType(getColumn().getType())[0]);\nif (adapter.typeSupportsLength(getColumn().getType()) && getColumn().getMaxLength() > 0) {\nsqlBuffer.append(\"(\");\nsqlBuffer.append(getColumn().getMaxLength());\nsqlBuffer.append(\")\");\n}\nsqlBuffer.append(\" NOT NULL\");\nreturn Collections.singletonList(sqlBuffer.toString());\n}\n};\n}","label":[0,0,1,0]}
{"id":19696,"original_code":"public static CDI<Object> current()\n    {\n        if (INSTANCE == null)\n        {\n            INSTANCE = ServiceLoader.load(CDIProvider.class).iterator().next().getCDI();\n        }\n        return INSTANCE; \/\/X TODO implement!\n    }","code":"public static CDI<Object> current()\n    {\n        if (INSTANCE == null)\n        {\n            INSTANCE = ServiceLoader.load(CDIProvider.class).iterator().next().getCDI();\n        }\n        return INSTANCE;\n    }","cleancode":"public static cdi<object> current() { if (instance == null) { instance = serviceloader.load(cdiprovider.class).iterator().next().getcdi(); } return instance; }","comment":"\/\/x todo implement!","repo":"salyh\/geronimo-specs","code_context_2":"INSTANCE = ServiceLoader.load(CDIProvider.class).iterator().next().getCDI();\n}\nreturn INSTANCE; \/\/X TODO implement!\n}","code_context_10":"public static CDI<Object> current()\n{\nif (INSTANCE == null)\n{\nINSTANCE = ServiceLoader.load(CDIProvider.class).iterator().next().getCDI();\n}\nreturn INSTANCE; \/\/X TODO implement!\n}","code_context_20":"public static CDI<Object> current()\n{\nif (INSTANCE == null)\n{\nINSTANCE = ServiceLoader.load(CDIProvider.class).iterator().next().getCDI();\n}\nreturn INSTANCE; \/\/X TODO implement!\n}","label":[0,1,0,0]}
{"id":19697,"original_code":"public static void setCDIProvider(CDIProvider provider)\n    {\n        \/\/X TODO implement!\n        if (provider == null)\n        {\n            INSTANCE = null;\n        }\n        else\n        {\n            INSTANCE = provider.getCDI();\n        }\n    }","code":"public static void setCDIProvider(CDIProvider provider)\n    {\n       \n        if (provider == null)\n        {\n            INSTANCE = null;\n        }\n        else\n        {\n            INSTANCE = provider.getCDI();\n        }\n    }","cleancode":"public static void setcdiprovider(cdiprovider provider) { if (provider == null) { instance = null; } else { instance = provider.getcdi(); } }","comment":"\/** * <p>a container or an application can set this manually. if not * we will use the {@link java.util.serviceloader} and use the * first service we find.<\/p> * * todo: clarify if this is per 'application' or general? * * @param provider to use *\/\n\/\/x todo implement!","repo":"salyh\/geronimo-specs","code_context_2":"public static void setCDIProvider(CDIProvider provider)\n{\n\/\/X TODO implement!\nif (provider == null)\n{\nINSTANCE = null;\n}\nelse\n{\nINSTANCE = provider.getCDI();\n}\n}\n\npublic static void setCDIProvider(CDIProvider provider)\n{\n\/\/X TODO implement!\nif (provider == null)\n{","code_context_10":"public static void setCDIProvider(CDIProvider provider)\n{\n\/\/X TODO implement!\nif (provider == null)\n{\nINSTANCE = null;\n}\nelse\n{\nINSTANCE = provider.getCDI();\n}\n}\n\npublic static void setCDIProvider(CDIProvider provider)\n{\n\/\/X TODO implement!\nif (provider == null)\n{\nINSTANCE = null;\n}\nelse\n{\nINSTANCE = provider.getCDI();\n}\n}","code_context_20":"public static void setCDIProvider(CDIProvider provider)\n{\n\/\/X TODO implement!\nif (provider == null)\n{\nINSTANCE = null;\n}\nelse\n{\nINSTANCE = provider.getCDI();\n}\n}\n\npublic static void setCDIProvider(CDIProvider provider)\n{\n\/\/X TODO implement!\nif (provider == null)\n{\nINSTANCE = null;\n}\nelse\n{\nINSTANCE = provider.getCDI();\n}\n}","label":[1,1,0,0]}
{"id":19886,"original_code":"@Override\n    @Committing\n    @PureWithSideEffects\n    @SuppressWarnings(\"UseSpecificCatch\")\n    public void run() {\n        try {\n            final @Nonnull String address = getSocket().getInetAddress().getHostAddress();\n            Log.debugging(\"Received a request from $.\", address);\n            final @Nonnull Time start = TimeBuilder.build();\n            @Nullable Encryption<Signature<Compression<Pack>>> encryptedMethod = null;\n            @Nullable Signature<Compression<Pack>> signedMethod = null;\n            @Nullable Method<?> method = null;\n            @Nullable Reply<?> reply = null;\n            try {\n                try {\n                    final @Nonnull Pack pack = Pack.loadFrom(getSocket());\n                    final @Nonnull Request request = pack.unpack(RequestConverter.INSTANCE, null);\n                    encryptedMethod = request.getEncryption();\n                    final @Nullable HostIdentifier recipient = encryptedMethod.getRecipient();\n                    if (recipient == null) { throw RequestExceptionBuilder.withCode(RequestErrorCode.RECIPIENT).withMessage(\"The recipient may not be null.\").build(); }\n                    final @Nonnull Host host = Host.of(recipient);\n                    signedMethod = encryptedMethod.getObject();\n                    final @Nonnull SemanticType type = signedMethod.getObject().getObject().getType();\n                    Log.debugging(\"Executing the method $ on host $.\", type.getAddress(), recipient);\n                    final @Nonnull InternalIdentifier subject;\n                    if (type.equals(OpenAccount.TYPE)) { subject = recipient; } else { subject = signedMethod.getSubject(); }\n                    final @Nonnull Account account = Account.with(host, subject.resolve());\n                    method = MethodIndex.get(signedMethod, account);\n                    reply = method.executeOnHost();\n                    Database.commit();\n                } catch (@Nonnull InternalException exception) {\n                    throw RequestExceptionBuilder.withCode(RequestErrorCode.INTERNAL).withMessage(\"An internal problem occurred.\").withCause(exception).build();\n                } catch (@Nonnull ExternalException exception) {\n                    throw RequestExceptionBuilder.withCode(RequestErrorCode.EXTERNAL).withMessage(\"An external problem occurred.\").withCause(exception).build();\n                }\n            } catch (@Nonnull RequestException exception) {\n                Database.rollback();\n                Log.warning(\"A request error occurred:\", exception);\n                reply = RequestExceptionReplyBuilder.withRequestException(exception.isDecoded() ? RequestExceptionBuilder.withCode(RequestErrorCode.REQUEST).withMessage(\"Another server responded with a request error.\").withCause(exception).build() : exception).build();\n            }\n            if (reply == null) { reply = EmptyReplyBuilder.build(); }\n            final @Nonnull Compression<Pack> compressedReply = CompressionBuilder.withObject(reply.pack()).build();\n            \/\/ The reply.pack() statement maps the semantic type of the reply converter, which results in a concurrent update if the client unpacks the response with the same database. The following commit prevents this. However, it is a suboptimal fix for this problem.\n            try { Database.commit(); } catch (@Nonnull DatabaseException exception) { Database.rollback(); }\n            final @Nonnull Signature<Compression<Pack>> signedReply;\n            if (encryptedMethod != null && signedMethod != null) {\n                signedReply = HostSignatureCreator.sign(compressedReply, CompressionConverterBuilder.withObjectConverter(PackConverter.INSTANCE).build()).about(signedMethod.getSubject()).as(encryptedMethod.getRecipient());\n            } else {\n                signedReply = SignatureBuilder.withObjectConverter(CompressionConverterBuilder.withObjectConverter(PackConverter.INSTANCE).build()).withObject(compressedReply).withSubject(HostIdentifier.DIGITALID).build();\n            }\n            final @Nonnull Encryption<Signature<Compression<Pack>>> encryptedReply;\n            if (encryptedMethod instanceof RequestEncryption) {\n                encryptedReply = ResponseEncryptionBuilder.withObject(signedReply).withSymmetricKey(((RequestEncryption) encryptedMethod).getSymmetricKey()).build();\n            } else {\n                encryptedReply = EncryptionBuilder.withObject(signedReply).build();\n            }\n            final @Nonnull Response response = ResponseBuilder.withEncryption(encryptedReply).build();\n            response.pack().storeTo(getSocket());\n            Log.information(method + \" from \" + address + \" handled in \" + start.ago().getValue() + \" ms.\");\n        } catch (@Nonnull NetworkException exception) {\n            Log.warning(\"Could not send a response.\", exception);\n        } catch (@Nonnull Throwable throwable) {\n            Log.warning(\"Something went wrong.\", throwable);\n        } finally {\n            try {\n                if (!getSocket().isClosed()) { getSocket().close(); }\n            } catch (@Nonnull IOException exception) {\n                Log.warning(\"Could not close the socket.\", exception);\n            }\n        }\n    }","code":"@Override\n    @Committing\n    @PureWithSideEffects\n    @SuppressWarnings(\"UseSpecificCatch\")\n    public void run() {\n        try {\n            final @Nonnull String address = getSocket().getInetAddress().getHostAddress();\n            Log.debugging(\"Received a request from $.\", address);\n            final @Nonnull Time start = TimeBuilder.build();\n            @Nullable Encryption<Signature<Compression<Pack>>> encryptedMethod = null;\n            @Nullable Signature<Compression<Pack>> signedMethod = null;\n            @Nullable Method<?> method = null;\n            @Nullable Reply<?> reply = null;\n            try {\n                try {\n                    final @Nonnull Pack pack = Pack.loadFrom(getSocket());\n                    final @Nonnull Request request = pack.unpack(RequestConverter.INSTANCE, null);\n                    encryptedMethod = request.getEncryption();\n                    final @Nullable HostIdentifier recipient = encryptedMethod.getRecipient();\n                    if (recipient == null) { throw RequestExceptionBuilder.withCode(RequestErrorCode.RECIPIENT).withMessage(\"The recipient may not be null.\").build(); }\n                    final @Nonnull Host host = Host.of(recipient);\n                    signedMethod = encryptedMethod.getObject();\n                    final @Nonnull SemanticType type = signedMethod.getObject().getObject().getType();\n                    Log.debugging(\"Executing the method $ on host $.\", type.getAddress(), recipient);\n                    final @Nonnull InternalIdentifier subject;\n                    if (type.equals(OpenAccount.TYPE)) { subject = recipient; } else { subject = signedMethod.getSubject(); }\n                    final @Nonnull Account account = Account.with(host, subject.resolve());\n                    method = MethodIndex.get(signedMethod, account);\n                    reply = method.executeOnHost();\n                    Database.commit();\n                } catch (@Nonnull InternalException exception) {\n                    throw RequestExceptionBuilder.withCode(RequestErrorCode.INTERNAL).withMessage(\"An internal problem occurred.\").withCause(exception).build();\n                } catch (@Nonnull ExternalException exception) {\n                    throw RequestExceptionBuilder.withCode(RequestErrorCode.EXTERNAL).withMessage(\"An external problem occurred.\").withCause(exception).build();\n                }\n            } catch (@Nonnull RequestException exception) {\n                Database.rollback();\n                Log.warning(\"A request error occurred:\", exception);\n                reply = RequestExceptionReplyBuilder.withRequestException(exception.isDecoded() ? RequestExceptionBuilder.withCode(RequestErrorCode.REQUEST).withMessage(\"Another server responded with a request error.\").withCause(exception).build() : exception).build();\n            }\n            if (reply == null) { reply = EmptyReplyBuilder.build(); }\n            final @Nonnull Compression<Pack> compressedReply = CompressionBuilder.withObject(reply.pack()).build();\n           \n            try { Database.commit(); } catch (@Nonnull DatabaseException exception) { Database.rollback(); }\n            final @Nonnull Signature<Compression<Pack>> signedReply;\n            if (encryptedMethod != null && signedMethod != null) {\n                signedReply = HostSignatureCreator.sign(compressedReply, CompressionConverterBuilder.withObjectConverter(PackConverter.INSTANCE).build()).about(signedMethod.getSubject()).as(encryptedMethod.getRecipient());\n            } else {\n                signedReply = SignatureBuilder.withObjectConverter(CompressionConverterBuilder.withObjectConverter(PackConverter.INSTANCE).build()).withObject(compressedReply).withSubject(HostIdentifier.DIGITALID).build();\n            }\n            final @Nonnull Encryption<Signature<Compression<Pack>>> encryptedReply;\n            if (encryptedMethod instanceof RequestEncryption) {\n                encryptedReply = ResponseEncryptionBuilder.withObject(signedReply).withSymmetricKey(((RequestEncryption) encryptedMethod).getSymmetricKey()).build();\n            } else {\n                encryptedReply = EncryptionBuilder.withObject(signedReply).build();\n            }\n            final @Nonnull Response response = ResponseBuilder.withEncryption(encryptedReply).build();\n            response.pack().storeTo(getSocket());\n            Log.information(method + \" from \" + address + \" handled in \" + start.ago().getValue() + \" ms.\");\n        } catch (@Nonnull NetworkException exception) {\n            Log.warning(\"Could not send a response.\", exception);\n        } catch (@Nonnull Throwable throwable) {\n            Log.warning(\"Something went wrong.\", throwable);\n        } finally {\n            try {\n                if (!getSocket().isClosed()) { getSocket().close(); }\n            } catch (@Nonnull IOException exception) {\n                Log.warning(\"Could not close the socket.\", exception);\n            }\n        }\n    }","cleancode":"@override @committing @purewithsideeffects @suppresswarnings(\"usespecificcatch\") public void run() { try { final @nonnull string address = getsocket().getinetaddress().gethostaddress(); log.debugging(\"received a request from $.\", address); final @nonnull time start = timebuilder.build(); @nullable encryption<signature<compression<pack>>> encryptedmethod = null; @nullable signature<compression<pack>> signedmethod = null; @nullable method<?> method = null; @nullable reply<?> reply = null; try { try { final @nonnull pack pack = pack.loadfrom(getsocket()); final @nonnull request request = pack.unpack(requestconverter.instance, null); encryptedmethod = request.getencryption(); final @nullable hostidentifier recipient = encryptedmethod.getrecipient(); if (recipient == null) { throw requestexceptionbuilder.withcode(requesterrorcode.recipient).withmessage(\"the recipient may not be null.\").build(); } final @nonnull host host = host.of(recipient); signedmethod = encryptedmethod.getobject(); final @nonnull semantictype type = signedmethod.getobject().getobject().gettype(); log.debugging(\"executing the method $ on host $.\", type.getaddress(), recipient); final @nonnull internalidentifier subject; if (type.equals(openaccount.type)) { subject = recipient; } else { subject = signedmethod.getsubject(); } final @nonnull account account = account.with(host, subject.resolve()); method = methodindex.get(signedmethod, account); reply = method.executeonhost(); database.commit(); } catch (@nonnull internalexception exception) { throw requestexceptionbuilder.withcode(requesterrorcode.internal).withmessage(\"an internal problem occurred.\").withcause(exception).build(); } catch (@nonnull externalexception exception) { throw requestexceptionbuilder.withcode(requesterrorcode.external).withmessage(\"an external problem occurred.\").withcause(exception).build(); } } catch (@nonnull requestexception exception) { database.rollback(); log.warning(\"a request error occurred:\", exception); reply = requestexceptionreplybuilder.withrequestexception(exception.isdecoded() ? requestexceptionbuilder.withcode(requesterrorcode.request).withmessage(\"another server responded with a request error.\").withcause(exception).build() : exception).build(); } if (reply == null) { reply = emptyreplybuilder.build(); } final @nonnull compression<pack> compressedreply = compressionbuilder.withobject(reply.pack()).build(); try { database.commit(); } catch (@nonnull databaseexception exception) { database.rollback(); } final @nonnull signature<compression<pack>> signedreply; if (encryptedmethod != null && signedmethod != null) { signedreply = hostsignaturecreator.sign(compressedreply, compressionconverterbuilder.withobjectconverter(packconverter.instance).build()).about(signedmethod.getsubject()).as(encryptedmethod.getrecipient()); } else { signedreply = signaturebuilder.withobjectconverter(compressionconverterbuilder.withobjectconverter(packconverter.instance).build()).withobject(compressedreply).withsubject(hostidentifier.digitalid).build(); } final @nonnull encryption<signature<compression<pack>>> encryptedreply; if (encryptedmethod instanceof requestencryption) { encryptedreply = responseencryptionbuilder.withobject(signedreply).withsymmetrickey(((requestencryption) encryptedmethod).getsymmetrickey()).build(); } else { encryptedreply = encryptionbuilder.withobject(signedreply).build(); } final @nonnull response response = responsebuilder.withencryption(encryptedreply).build(); response.pack().storeto(getsocket()); log.information(method + \" from \" + address + \" handled in \" + start.ago().getvalue() + \" ms.\"); } catch (@nonnull networkexception exception) { log.warning(\"could not send a response.\", exception); } catch (@nonnull throwable throwable) { log.warning(\"something went wrong.\", throwable); } finally { try { if (!getsocket().isclosed()) { getsocket().close(); } } catch (@nonnull ioexception exception) { log.warning(\"could not close the socket.\", exception); } } }","comment":"\/** * asynchronous method to handle the incoming request. *\/\n\/\/ the reply.pack() statement maps the semantic type of the reply converter, which results in a concurrent update if the client unpacks the response with the same database. the following commit prevents this. however, it is a suboptimal fix for this problem.","repo":"stephaniestroka\/digitalid-core","code_context_2":"@Override\n@Committing\n@PureWithSideEffects\n@SuppressWarnings(\"UseSpecificCatch\")\npublic void run() {\ntry {\nfinal @Nonnull String address = getSocket().getInetAddress().getHostAddress();\nLog.debugging(\"Received a request from $.\", address);\nfinal @Nonnull Time start = TimeBuilder.build();\n@Nullable Encryption<Signature<Compression<Pack>>> encryptedMethod = null;\n@Nullable Signature<Compression<Pack>> signedMethod = null;\n@Nullable Method<?> method = null;\n@Nullable Reply<?> reply = null;\ntry {\ntry {\nfinal @Nonnull Pack pack = Pack.loadFrom(getSocket());\nfinal @Nonnull Request request = pack.unpack(RequestConverter.INSTANCE, null);\nencryptedMethod = request.getEncryption();\nfinal @Nullable HostIdentifier recipient = encryptedMethod.getRecipient();\nif (recipient == null) { throw RequestExceptionBuilder.withCode(RequestErrorCode.RECIPIENT).withMessage(\"The recipient may not be null.\").build(); }\nfinal @Nonnull Host host = Host.of(recipient);\nsignedMethod = encryptedMethod.getObject();\nfinal @Nonnull SemanticType type = signedMethod.getObject().getObject().getType();\nLog.debugging(\"Executing the method $ on host $.\", type.getAddress(), recipient);\nfinal @Nonnull InternalIdentifier subject;\nif (type.equals(OpenAccount.TYPE)) { subject = recipient; } else { subject = signedMethod.getSubject(); }\nfinal @Nonnull Account account = Account.with(host, subject.resolve());\nmethod = MethodIndex.get(signedMethod, account);\nreply = method.executeOnHost();\nDatabase.commit();\n} catch (@Nonnull InternalException exception) {\nthrow RequestExceptionBuilder.withCode(RequestErrorCode.INTERNAL).withMessage(\"An internal problem occurred.\").withCause(exception).build();\n} catch (@Nonnull ExternalException exception) {\nthrow RequestExceptionBuilder.withCode(RequestErrorCode.EXTERNAL).withMessage(\"An external problem occurred.\").withCause(exception).build();\n}\n} catch (@Nonnull RequestException exception) {\nDatabase.rollback();\nLog.warning(\"A request error occurred:\", exception);\nreply = RequestExceptionReplyBuilder.withRequestException(exception.isDecoded() ? RequestExceptionBuilder.withCode(RequestErrorCode.REQUEST).withMessage(\"Another server responded with a request error.\").withCause(exception).build() : exception).build();\n}\nif (reply == null) { reply = EmptyReplyBuilder.build(); }\nfinal @Nonnull Compression<Pack> compressedReply = CompressionBuilder.withObject(reply.pack()).build();\n\/\/ The reply.pack() statement maps the semantic type of the reply converter, which results in a concurrent update if the client unpacks the response with the same database. The following commit prevents this. However, it is a suboptimal fix for this problem.\ntry { Database.commit(); } catch (@Nonnull DatabaseException exception) { Database.rollback(); }\nfinal @Nonnull Signature<Compression<Pack>> signedReply;\nif (encryptedMethod != null && signedMethod != null) {\nsignedReply = HostSignatureCreator.sign(compressedReply, CompressionConverterBuilder.withObjectConverter(PackConverter.INSTANCE).build()).about(signedMethod.getSubject()).as(encryptedMethod.getRecipient());\n} else {\nsignedReply = SignatureBuilder.withObjectConverter(CompressionConverterBuilder.withObjectConverter(PackConverter.INSTANCE).build()).withObject(compressedReply).withSubject(HostIdentifier.DIGITALID).build();\n}\nfinal @Nonnull Encryption<Signature<Compression<Pack>>> encryptedReply;\nif (encryptedMethod instanceof RequestEncryption) {\nencryptedReply = ResponseEncryptionBuilder.withObject(signedReply).withSymmetricKey(((RequestEncryption) encryptedMethod).getSymmetricKey()).build();\n} else {\nencryptedReply = EncryptionBuilder.withObject(signedReply).build();\n}\nfinal @Nonnull Response response = ResponseBuilder.withEncryption(encryptedReply).build();\nresponse.pack().storeTo(getSocket());\nLog.information(method + \" from \" + address + \" handled in \" + start.ago().getValue() + \" ms.\");\n} catch (@Nonnull NetworkException exception) {\nLog.warning(\"Could not send a response.\", exception);\n} catch (@Nonnull Throwable throwable) {\nLog.warning(\"Something went wrong.\", throwable);\n} finally {\ntry {\nif (!getSocket().isClosed()) { getSocket().close(); }\n} catch (@Nonnull IOException exception) {\nLog.warning(\"Could not close the socket.\", exception);\n}\n}\n}\n\nif (reply == null) { reply = EmptyReplyBuilder.build(); }\nfinal @Nonnull Compression<Pack> compressedReply = CompressionBuilder.withObject(reply.pack()).build();\n\/\/ The reply.pack() statement maps the semantic type of the reply converter, which results in a concurrent update if the client unpacks the response with the same database. The following commit prevents this. However, it is a suboptimal fix for this problem.\ntry { Database.commit(); } catch (@Nonnull DatabaseException exception) { Database.rollback(); }\nfinal @Nonnull Signature<Compression<Pack>> signedReply;","code_context_10":"@Override\n@Committing\n@PureWithSideEffects\n@SuppressWarnings(\"UseSpecificCatch\")\npublic void run() {\ntry {\nfinal @Nonnull String address = getSocket().getInetAddress().getHostAddress();\nLog.debugging(\"Received a request from $.\", address);\nfinal @Nonnull Time start = TimeBuilder.build();\n@Nullable Encryption<Signature<Compression<Pack>>> encryptedMethod = null;\n@Nullable Signature<Compression<Pack>> signedMethod = null;\n@Nullable Method<?> method = null;\n@Nullable Reply<?> reply = null;\ntry {\ntry {\nfinal @Nonnull Pack pack = Pack.loadFrom(getSocket());\nfinal @Nonnull Request request = pack.unpack(RequestConverter.INSTANCE, null);\nencryptedMethod = request.getEncryption();\nfinal @Nullable HostIdentifier recipient = encryptedMethod.getRecipient();\nif (recipient == null) { throw RequestExceptionBuilder.withCode(RequestErrorCode.RECIPIENT).withMessage(\"The recipient may not be null.\").build(); }\nfinal @Nonnull Host host = Host.of(recipient);\nsignedMethod = encryptedMethod.getObject();\nfinal @Nonnull SemanticType type = signedMethod.getObject().getObject().getType();\nLog.debugging(\"Executing the method $ on host $.\", type.getAddress(), recipient);\nfinal @Nonnull InternalIdentifier subject;\nif (type.equals(OpenAccount.TYPE)) { subject = recipient; } else { subject = signedMethod.getSubject(); }\nfinal @Nonnull Account account = Account.with(host, subject.resolve());\nmethod = MethodIndex.get(signedMethod, account);\nreply = method.executeOnHost();\nDatabase.commit();\n} catch (@Nonnull InternalException exception) {\nthrow RequestExceptionBuilder.withCode(RequestErrorCode.INTERNAL).withMessage(\"An internal problem occurred.\").withCause(exception).build();\n} catch (@Nonnull ExternalException exception) {\nthrow RequestExceptionBuilder.withCode(RequestErrorCode.EXTERNAL).withMessage(\"An external problem occurred.\").withCause(exception).build();\n}\n} catch (@Nonnull RequestException exception) {\nDatabase.rollback();\nLog.warning(\"A request error occurred:\", exception);\nreply = RequestExceptionReplyBuilder.withRequestException(exception.isDecoded() ? RequestExceptionBuilder.withCode(RequestErrorCode.REQUEST).withMessage(\"Another server responded with a request error.\").withCause(exception).build() : exception).build();\n}\nif (reply == null) { reply = EmptyReplyBuilder.build(); }\nfinal @Nonnull Compression<Pack> compressedReply = CompressionBuilder.withObject(reply.pack()).build();\n\/\/ The reply.pack() statement maps the semantic type of the reply converter, which results in a concurrent update if the client unpacks the response with the same database. The following commit prevents this. However, it is a suboptimal fix for this problem.\ntry { Database.commit(); } catch (@Nonnull DatabaseException exception) { Database.rollback(); }\nfinal @Nonnull Signature<Compression<Pack>> signedReply;\nif (encryptedMethod != null && signedMethod != null) {\nsignedReply = HostSignatureCreator.sign(compressedReply, CompressionConverterBuilder.withObjectConverter(PackConverter.INSTANCE).build()).about(signedMethod.getSubject()).as(encryptedMethod.getRecipient());\n} else {\nsignedReply = SignatureBuilder.withObjectConverter(CompressionConverterBuilder.withObjectConverter(PackConverter.INSTANCE).build()).withObject(compressedReply).withSubject(HostIdentifier.DIGITALID).build();\n}\nfinal @Nonnull Encryption<Signature<Compression<Pack>>> encryptedReply;\nif (encryptedMethod instanceof RequestEncryption) {\nencryptedReply = ResponseEncryptionBuilder.withObject(signedReply).withSymmetricKey(((RequestEncryption) encryptedMethod).getSymmetricKey()).build();\n} else {\nencryptedReply = EncryptionBuilder.withObject(signedReply).build();\n}\nfinal @Nonnull Response response = ResponseBuilder.withEncryption(encryptedReply).build();\nresponse.pack().storeTo(getSocket());\nLog.information(method + \" from \" + address + \" handled in \" + start.ago().getValue() + \" ms.\");\n} catch (@Nonnull NetworkException exception) {\nLog.warning(\"Could not send a response.\", exception);\n} catch (@Nonnull Throwable throwable) {\nLog.warning(\"Something went wrong.\", throwable);\n} finally {\ntry {\nif (!getSocket().isClosed()) { getSocket().close(); }\n} catch (@Nonnull IOException exception) {\nLog.warning(\"Could not close the socket.\", exception);\n}\n}\n}\n\n} catch (@Nonnull ExternalException exception) {\nthrow RequestExceptionBuilder.withCode(RequestErrorCode.EXTERNAL).withMessage(\"An external problem occurred.\").withCause(exception).build();\n}\n} catch (@Nonnull RequestException exception) {\nDatabase.rollback();\nLog.warning(\"A request error occurred:\", exception);\nreply = RequestExceptionReplyBuilder.withRequestException(exception.isDecoded() ? RequestExceptionBuilder.withCode(RequestErrorCode.REQUEST).withMessage(\"Another server responded with a request error.\").withCause(exception).build() : exception).build();\n}\nif (reply == null) { reply = EmptyReplyBuilder.build(); }\nfinal @Nonnull Compression<Pack> compressedReply = CompressionBuilder.withObject(reply.pack()).build();\n\/\/ The reply.pack() statement maps the semantic type of the reply converter, which results in a concurrent update if the client unpacks the response with the same database. The following commit prevents this. However, it is a suboptimal fix for this problem.\ntry { Database.commit(); } catch (@Nonnull DatabaseException exception) { Database.rollback(); }\nfinal @Nonnull Signature<Compression<Pack>> signedReply;\nif (encryptedMethod != null && signedMethod != null) {\nsignedReply = HostSignatureCreator.sign(compressedReply, CompressionConverterBuilder.withObjectConverter(PackConverter.INSTANCE).build()).about(signedMethod.getSubject()).as(encryptedMethod.getRecipient());\n} else {\nsignedReply = SignatureBuilder.withObjectConverter(CompressionConverterBuilder.withObjectConverter(PackConverter.INSTANCE).build()).withObject(compressedReply).withSubject(HostIdentifier.DIGITALID).build();\n}\nfinal @Nonnull Encryption<Signature<Compression<Pack>>> encryptedReply;\nif (encryptedMethod instanceof RequestEncryption) {\nencryptedReply = ResponseEncryptionBuilder.withObject(signedReply).withSymmetricKey(((RequestEncryption) encryptedMethod).getSymmetricKey()).build();","code_context_20":"@Override\n@Committing\n@PureWithSideEffects\n@SuppressWarnings(\"UseSpecificCatch\")\npublic void run() {\ntry {\nfinal @Nonnull String address = getSocket().getInetAddress().getHostAddress();\nLog.debugging(\"Received a request from $.\", address);\nfinal @Nonnull Time start = TimeBuilder.build();\n@Nullable Encryption<Signature<Compression<Pack>>> encryptedMethod = null;\n@Nullable Signature<Compression<Pack>> signedMethod = null;\n@Nullable Method<?> method = null;\n@Nullable Reply<?> reply = null;\ntry {\ntry {\nfinal @Nonnull Pack pack = Pack.loadFrom(getSocket());\nfinal @Nonnull Request request = pack.unpack(RequestConverter.INSTANCE, null);\nencryptedMethod = request.getEncryption();\nfinal @Nullable HostIdentifier recipient = encryptedMethod.getRecipient();\nif (recipient == null) { throw RequestExceptionBuilder.withCode(RequestErrorCode.RECIPIENT).withMessage(\"The recipient may not be null.\").build(); }\nfinal @Nonnull Host host = Host.of(recipient);\nsignedMethod = encryptedMethod.getObject();\nfinal @Nonnull SemanticType type = signedMethod.getObject().getObject().getType();\nLog.debugging(\"Executing the method $ on host $.\", type.getAddress(), recipient);\nfinal @Nonnull InternalIdentifier subject;\nif (type.equals(OpenAccount.TYPE)) { subject = recipient; } else { subject = signedMethod.getSubject(); }\nfinal @Nonnull Account account = Account.with(host, subject.resolve());\nmethod = MethodIndex.get(signedMethod, account);\nreply = method.executeOnHost();\nDatabase.commit();\n} catch (@Nonnull InternalException exception) {\nthrow RequestExceptionBuilder.withCode(RequestErrorCode.INTERNAL).withMessage(\"An internal problem occurred.\").withCause(exception).build();\n} catch (@Nonnull ExternalException exception) {\nthrow RequestExceptionBuilder.withCode(RequestErrorCode.EXTERNAL).withMessage(\"An external problem occurred.\").withCause(exception).build();\n}\n} catch (@Nonnull RequestException exception) {\nDatabase.rollback();\nLog.warning(\"A request error occurred:\", exception);\nreply = RequestExceptionReplyBuilder.withRequestException(exception.isDecoded() ? RequestExceptionBuilder.withCode(RequestErrorCode.REQUEST).withMessage(\"Another server responded with a request error.\").withCause(exception).build() : exception).build();\n}\nif (reply == null) { reply = EmptyReplyBuilder.build(); }\nfinal @Nonnull Compression<Pack> compressedReply = CompressionBuilder.withObject(reply.pack()).build();\n\/\/ The reply.pack() statement maps the semantic type of the reply converter, which results in a concurrent update if the client unpacks the response with the same database. The following commit prevents this. However, it is a suboptimal fix for this problem.\ntry { Database.commit(); } catch (@Nonnull DatabaseException exception) { Database.rollback(); }\nfinal @Nonnull Signature<Compression<Pack>> signedReply;\nif (encryptedMethod != null && signedMethod != null) {\nsignedReply = HostSignatureCreator.sign(compressedReply, CompressionConverterBuilder.withObjectConverter(PackConverter.INSTANCE).build()).about(signedMethod.getSubject()).as(encryptedMethod.getRecipient());\n} else {\nsignedReply = SignatureBuilder.withObjectConverter(CompressionConverterBuilder.withObjectConverter(PackConverter.INSTANCE).build()).withObject(compressedReply).withSubject(HostIdentifier.DIGITALID).build();\n}\nfinal @Nonnull Encryption<Signature<Compression<Pack>>> encryptedReply;\nif (encryptedMethod instanceof RequestEncryption) {\nencryptedReply = ResponseEncryptionBuilder.withObject(signedReply).withSymmetricKey(((RequestEncryption) encryptedMethod).getSymmetricKey()).build();\n} else {\nencryptedReply = EncryptionBuilder.withObject(signedReply).build();\n}\nfinal @Nonnull Response response = ResponseBuilder.withEncryption(encryptedReply).build();\nresponse.pack().storeTo(getSocket());\nLog.information(method + \" from \" + address + \" handled in \" + start.ago().getValue() + \" ms.\");\n} catch (@Nonnull NetworkException exception) {\nLog.warning(\"Could not send a response.\", exception);\n} catch (@Nonnull Throwable throwable) {\nLog.warning(\"Something went wrong.\", throwable);\n} finally {\ntry {\nif (!getSocket().isClosed()) { getSocket().close(); }\n} catch (@Nonnull IOException exception) {\nLog.warning(\"Could not close the socket.\", exception);\n}\n}\n}\n\nfinal @Nonnull SemanticType type = signedMethod.getObject().getObject().getType();\nLog.debugging(\"Executing the method $ on host $.\", type.getAddress(), recipient);\nfinal @Nonnull InternalIdentifier subject;\nif (type.equals(OpenAccount.TYPE)) { subject = recipient; } else { subject = signedMethod.getSubject(); }\nfinal @Nonnull Account account = Account.with(host, subject.resolve());\nmethod = MethodIndex.get(signedMethod, account);\nreply = method.executeOnHost();\nDatabase.commit();\n} catch (@Nonnull InternalException exception) {\nthrow RequestExceptionBuilder.withCode(RequestErrorCode.INTERNAL).withMessage(\"An internal problem occurred.\").withCause(exception).build();\n} catch (@Nonnull ExternalException exception) {\nthrow RequestExceptionBuilder.withCode(RequestErrorCode.EXTERNAL).withMessage(\"An external problem occurred.\").withCause(exception).build();\n}\n} catch (@Nonnull RequestException exception) {\nDatabase.rollback();\nLog.warning(\"A request error occurred:\", exception);\nreply = RequestExceptionReplyBuilder.withRequestException(exception.isDecoded() ? RequestExceptionBuilder.withCode(RequestErrorCode.REQUEST).withMessage(\"Another server responded with a request error.\").withCause(exception).build() : exception).build();\n}\nif (reply == null) { reply = EmptyReplyBuilder.build(); }\nfinal @Nonnull Compression<Pack> compressedReply = CompressionBuilder.withObject(reply.pack()).build();\n\/\/ The reply.pack() statement maps the semantic type of the reply converter, which results in a concurrent update if the client unpacks the response with the same database. The following commit prevents this. However, it is a suboptimal fix for this problem.\ntry { Database.commit(); } catch (@Nonnull DatabaseException exception) { Database.rollback(); }\nfinal @Nonnull Signature<Compression<Pack>> signedReply;\nif (encryptedMethod != null && signedMethod != null) {\nsignedReply = HostSignatureCreator.sign(compressedReply, CompressionConverterBuilder.withObjectConverter(PackConverter.INSTANCE).build()).about(signedMethod.getSubject()).as(encryptedMethod.getRecipient());\n} else {\nsignedReply = SignatureBuilder.withObjectConverter(CompressionConverterBuilder.withObjectConverter(PackConverter.INSTANCE).build()).withObject(compressedReply).withSubject(HostIdentifier.DIGITALID).build();\n}\nfinal @Nonnull Encryption<Signature<Compression<Pack>>> encryptedReply;\nif (encryptedMethod instanceof RequestEncryption) {\nencryptedReply = ResponseEncryptionBuilder.withObject(signedReply).withSymmetricKey(((RequestEncryption) encryptedMethod).getSymmetricKey()).build();\n} else {\nencryptedReply = EncryptionBuilder.withObject(signedReply).build();\n}\nfinal @Nonnull Response response = ResponseBuilder.withEncryption(encryptedReply).build();\nresponse.pack().storeTo(getSocket());\nLog.information(method + \" from \" + address + \" handled in \" + start.ago().getValue() + \" ms.\");\n} catch (@Nonnull NetworkException exception) {\nLog.warning(\"Could not send a response.\", exception);\n} catch (@Nonnull Throwable throwable) {\nLog.warning(\"Something went wrong.\", throwable);","label":[1,0,0,0]}
{"id":3591,"original_code":"public static void popupManager(final View view, final SoundObject soundObject){\n        \/\/ Declare PopupMenu and assign it to the design created in longclick.xml\n        PopupMenu popup = new PopupMenu(view.getContext(), view);\n        popup.getMenuInflater().inflate(R.menu.longclick, popup.getMenu());\n        \/\/ Handle user clicks on the popupmenu\n        popup.setOnMenuItemClickListener(new PopupMenu.OnMenuItemClickListener() {\n            @Override\n            public boolean onMenuItemClick(MenuItem item) {\n                \/\/ Check if the user wants to share a sound or set a sound as system audio\n                if (item.getItemId() == R.id.action_send || item.getItemId() == R.id.action_ringtone){\n                    \/\/ Define a filename on the given information from the SoundObject AND add the .mp3 tag to it\n                    final String fileName = soundObject.getItemName() + \".mp3\";\n                    \/\/ Get the path to the users external storage\n                    File storage = Environment.getExternalStorageDirectory();\n                    \/\/ Define the directory path to the soundboard apps folder\n                    \/\/ Change my_soundboard to whatever you want as your folder but keep the slash\n                    \/\/ TODO: When changing the path be sure to also modify the path in filepaths.xml (res\/xml\/filepaths.xml)\n                    File directory = new File(storage.getAbsolutePath() + \"\/my_soundboard\/\");\n                    \/\/ Creates the directory if it doesn't exist\n                    \/\/ mkdirs() gives back a boolean. You can use it to do some processes as well but we don't really need it.\n                    directory.mkdirs();\n                    \/\/ Finally define the file by giving over the directory and the filename\n                    final File file = new File(directory, fileName);\n                    \/\/ Define an InputStream that will read the data from your sound-raw.mp3 file into a buffer\n                    InputStream in = view.getContext().getResources().openRawResource(soundObject.getItemID());\n                    try{\n                        \/\/ Log the name of the sound that is being saved\n                        Log.i(LOG_TAG, \"Saving sound \" + soundObject.getItemName());\n                        \/\/ Define an OutputStream\/FileOutputStream that will write the buffer data into the sound.mp3 on the external storage\n                        OutputStream out = new FileOutputStream(file);\n                        \/\/ Define a buffer of 1kb (you can make it a little bit bigger but 1kb will be adequate)\n                        byte[] buffer = new byte[1024];\n                        int len;\n                        \/\/ Write the data to the sound.mp3 file while reading it from the sound-raw.mp3\n                        \/\/ if (int) InputStream.read() returns -1 stream is at the end of file\n                        while ((len = in.read(buffer, 0, buffer.length)) != -1){\n                            out.write(buffer, 0 , len);\n                        }\n                        \/\/ Close both streams\n                        in.close();\n                        out.close();\n                    } catch (IOException e){\n                        \/\/ Log error if process failed\n                        Log.e(LOG_TAG, \"Failed to save file: \" + e.getMessage());\n                    }\n                    \/\/ Send a sound via WhatsApp or the like\n                    if (item.getItemId() == R.id.action_send){\n                        try{\n                            \/\/ Check if the users device Android version is 5.1 or higher\n                            \/\/ If it is you'll have to use FileProvider to get the sharing function to work properly\n                            if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.LOLLIPOP_MR1){\n                                final String AUTHORITY = view.getContext().getPackageName() + \".fileprovider\";\n                                Uri contentUri = FileProvider.getUriForFile(view.getContext(), AUTHORITY, file);\n                                final Intent shareIntent = new Intent(Intent.ACTION_SEND);\n                                final Intent intent = new Intent(Intent.ACTION_SEND);\n                                intent.putExtra(Intent.EXTRA_STREAM, contentUri);\n                                \/\/ Define the intent to be of type audio\/mp3\n                                intent.setType(\"audio\/mp3\");\n                                \/\/ Start a new chooser dialog where the user can choose an app to share the sound\n                                view.getContext().startActivity(Intent.createChooser(intent, \"Share sound via...\"));\n                            }\n                            else {\n                                final Intent intent = new Intent(Intent.ACTION_SEND);\n                                \/\/ Uri refers to a name or location\n                                \/\/ .parse() analyzes a given uri string and creates a Uri from it\n                                \/\/ Define a \"link\" (Uri) to the saved file\n                                Uri fileUri = Uri.parse(file.getAbsolutePath());\n                                intent.putExtra(Intent.EXTRA_STREAM, fileUri);\n                                \/\/ Define the intent to be of type audio\/mp3\n                                intent.setType(\"audio\/mp3\");\n                                \/\/ Start a new chooser dialog where the user can choose an app to share the sound\n                                view.getContext().startActivity(Intent.createChooser(intent, \"Share sound via...\"));\n                            }\n                        } catch (Exception e){\n                            \/\/ Log error if process failed\n                            Log.e(LOG_TAG, \"Failed to share sound: \" + e.getMessage());\n                        }\n                    }\n                    \/\/ Save as ringtone, alarm or notification\n\/\/                    if (item.getItemId() == R.id.action_ringtone) {\n\/\/\n\/\/                        \/\/ Create a little popup like dialog that gives the user the choice between the 3 types\n\/\/                        \/\/ THEME_HOLO_LIGHT was deprecated in API 23 but to support older APIs you should use it\n\/\/                        AlertDialog.Builder builder = new AlertDialog.Builder(view.getContext(), AlertDialog.THEME_HOLO_LIGHT);\n\/\/                        builder.setTitle(\"Save as...\");\n\/\/                        builder.setItems(new CharSequence[]{\"Ringtone\", \"Notification\", \"Alarm\"}, new DialogInterface.OnClickListener(){\n\/\/\n\/\/                            @Override\n\/\/                            public void onClick(DialogInterface dialog, int which){\n\/\/\n\/\/                                \/\/ Decide on the users choice which information will be send to a method that handles the settings for all kinds of system audio\n\/\/\/\/                                switch (which) {\n\/\/\/\/\n\/\/\/\/                                    \/\/ Ringtone\n\/\/\/\/                                    case 0:\n\/\/\/\/                                        changeSystemAudio(context, RingtoneManager.TYPE_RINGTONE, file);\n\/\/\/\/                                        break;\n\/\/\/\/                                    \/\/ Notification\n\/\/\/\/                                    case 1:\n\/\/\/\/                                        changeSystemAudio(context, RingtoneManager.TYPE_NOTIFICATION, file);\n\/\/\/\/                                        break;\n\/\/\/\/                                    \/\/ Alarmton\n\/\/\/\/                                    case 2:\n\/\/\/\/                                        changeSystemAudio(context, RingtoneManager.TYPE_ALARM, file);\n\/\/\/\/                                        break;\n\/\/\/\/                                    default:\n\/\/\/\/                                }\n\/\/                            }\n\/\/                        });\n\/\/                        builder.create();\n\/\/                        builder.show();\n\/\/                    }\n                }\n                \/\/ Add sound to favorites \/ Remove sound from favorites\n\/\/                if (item.getItemId() == R.id.action_favorite) {\n\/\/\n\/\/                    DatabaseHandler databaseHandler = DatabaseHandler\n\/\/                            .getInstance(context.getApplicationContext());\n\/\/\n\/\/                    \/\/ Identify the current activity\n\/\/                    if (context instanceof FavoriteActivity) {\n\/\/                        databaseHandler.removeFavorite(context, soundObject);\n\/\/                    } else {\n\/\/                        databaseHandler.addFavorite(soundObject);\n\/\/                    }\n\/\/                }\n                return true;\n            }\n        });\n        popup.show();\n    }","code":"public static void popupManager(final View view, final SoundObject soundObject){\n       \n        PopupMenu popup = new PopupMenu(view.getContext(), view);\n        popup.getMenuInflater().inflate(R.menu.longclick, popup.getMenu());\n       \n        popup.setOnMenuItemClickListener(new PopupMenu.OnMenuItemClickListener() {\n            @Override\n            public boolean onMenuItemClick(MenuItem item) {\n               \n                if (item.getItemId() == R.id.action_send || item.getItemId() == R.id.action_ringtone){\n                   \n                    final String fileName = soundObject.getItemName() + \".mp3\";\n                   \n                    File storage = Environment.getExternalStorageDirectory();\n                   \n                   \n                   \n                    File directory = new File(storage.getAbsolutePath() + \"\/my_soundboard\/\");\n                   \n                   \n                    directory.mkdirs();\n                   \n                    final File file = new File(directory, fileName);\n                   \n                    InputStream in = view.getContext().getResources().openRawResource(soundObject.getItemID());\n                    try{\n                       \n                        Log.i(LOG_TAG, \"Saving sound \" + soundObject.getItemName());\n                       \n                        OutputStream out = new FileOutputStream(file);\n                       \n                        byte[] buffer = new byte[1024];\n                        int len;\n                       \n                       \n                        while ((len = in.read(buffer, 0, buffer.length)) != -1){\n                            out.write(buffer, 0 , len);\n                        }\n                       \n                        in.close();\n                        out.close();\n                    } catch (IOException e){\n                       \n                        Log.e(LOG_TAG, \"Failed to save file: \" + e.getMessage());\n                    }\n                   \n                    if (item.getItemId() == R.id.action_send){\n                        try{\n                           \n                           \n                            if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.LOLLIPOP_MR1){\n                                final String AUTHORITY = view.getContext().getPackageName() + \".fileprovider\";\n                                Uri contentUri = FileProvider.getUriForFile(view.getContext(), AUTHORITY, file);\n                                final Intent shareIntent = new Intent(Intent.ACTION_SEND);\n                                final Intent intent = new Intent(Intent.ACTION_SEND);\n                                intent.putExtra(Intent.EXTRA_STREAM, contentUri);\n                               \n                                intent.setType(\"audio\/mp3\");\n                               \n                                view.getContext().startActivity(Intent.createChooser(intent, \"Share sound via...\"));\n                            }\n                            else {\n                                final Intent intent = new Intent(Intent.ACTION_SEND);\n                               \n                               \n                               \n                                Uri fileUri = Uri.parse(file.getAbsolutePath());\n                                intent.putExtra(Intent.EXTRA_STREAM, fileUri);\n                               \n                                intent.setType(\"audio\/mp3\");\n                               \n                                view.getContext().startActivity(Intent.createChooser(intent, \"Share sound via...\"));\n                            }\n                        } catch (Exception e){\n                           \n                            Log.e(LOG_TAG, \"Failed to share sound: \" + e.getMessage());\n                        }\n                    }\n                   \n                }\n               \n                return true;\n            }\n        });\n        popup.show();\n    }","cleancode":"public static void popupmanager(final view view, final soundobject soundobject){ popupmenu popup = new popupmenu(view.getcontext(), view); popup.getmenuinflater().inflate(r.menu.longclick, popup.getmenu()); popup.setonmenuitemclicklistener(new popupmenu.onmenuitemclicklistener() { @override public boolean onmenuitemclick(menuitem item) { if (item.getitemid() == r.id.action_send || item.getitemid() == r.id.action_ringtone){ final string filename = soundobject.getitemname() + \".mp3\"; file storage = environment.getexternalstoragedirectory(); file directory = new file(storage.getabsolutepath() + \"\/my_soundboard\/\"); directory.mkdirs(); final file file = new file(directory, filename); inputstream in = view.getcontext().getresources().openrawresource(soundobject.getitemid()); try{ log.i(log_tag, \"saving sound \" + soundobject.getitemname()); outputstream out = new fileoutputstream(file); byte[] buffer = new byte[1024]; int len; while ((len = in.read(buffer, 0, buffer.length)) != -1){ out.write(buffer, 0 , len); } in.close(); out.close(); } catch (ioexception e){ log.e(log_tag, \"failed to save file: \" + e.getmessage()); } if (item.getitemid() == r.id.action_send){ try{ if (build.version.sdk_int >= build.version_codes.lollipop_mr1){ final string authority = view.getcontext().getpackagename() + \".fileprovider\"; uri contenturi = fileprovider.geturiforfile(view.getcontext(), authority, file); final intent shareintent = new intent(intent.action_send); final intent intent = new intent(intent.action_send); intent.putextra(intent.extra_stream, contenturi); intent.settype(\"audio\/mp3\"); view.getcontext().startactivity(intent.createchooser(intent, \"share sound via...\")); } else { final intent intent = new intent(intent.action_send); uri fileuri = uri.parse(file.getabsolutepath()); intent.putextra(intent.extra_stream, fileuri); intent.settype(\"audio\/mp3\"); view.getcontext().startactivity(intent.createchooser(intent, \"share sound via...\")); } } catch (exception e){ log.e(log_tag, \"failed to share sound: \" + e.getmessage()); } } } return true; } }); popup.show(); }","comment":"\/\/ creates a popupmenu at the pressed sound button and handles the users input\n\/\/ declare popupmenu and assign it to the design created in longclick.xml\n\/\/ handle user clicks on the popupmenu\n\/\/ check if the user wants to share a sound or set a sound as system audio\n\/\/ define a filename on the given information from the soundobject and add the .mp3 tag to it\n\/\/ get the path to the users external storage\n\/\/ define the directory path to the soundboard apps folder \/\/ change my_soundboard to whatever you want as your folder but keep the slash \/\/ todo: when changing the path be sure to also modify the path in filepaths.xml (res\/xml\/filepaths.xml)\n\/\/ creates the directory if it doesn't exist \/\/ mkdirs() gives back a boolean. you can use it to do some processes as well but we don't really need it.\n\/\/ finally define the file by giving over the directory and the filename\n\/\/ define an inputstream that will read the data from your sound-raw.mp3 file into a buffer\n\/\/ log the name of the sound that is being saved\n\/\/ define an outputstream\/fileoutputstream that will write the buffer data into the sound.mp3 on the external storage\n\/\/ define a buffer of 1kb (you can make it a little bit bigger but 1kb will be adequate)\n\/\/ write the data to the sound.mp3 file while reading it from the sound-raw.mp3 \/\/ if (int) inputstream.read() returns -1 stream is at the end of file\n\/\/ close both streams\n\/\/ log error if process failed\n\/\/ send a sound via whatsapp or the like\n\/\/ check if the users device android version is 5.1 or higher \/\/ if it is you'll have to use fileprovider to get the sharing function to work properly\n\/\/ define the intent to be of type audio\/mp3\n\/\/ start a new chooser dialog where the user can choose an app to share the sound\n\/\/ uri refers to a name or location \/\/ .parse() analyzes a given uri string and creates a uri from it \/\/ define a \"link\" (uri) to the saved file\n\/\/ define the intent to be of type audio\/mp3\n\/\/ start a new chooser dialog where the user can choose an app to share the sound\n\/\/ log error if process failed\n\/\/ save as ringtone, alarm or notification \/\/ if (item.getitemid() == r.id.action_ringtone) { \/\/ \/\/ \/\/ create a little popup like dialog that gives the user the choice between the 3 types \/\/ \/\/ theme_holo_light was deprecated in api 23 but to support older apis you should use it \/\/ alertdialog.builder builder = new alertdialog.builder(view.getcontext(), alertdialog.theme_holo_light); \/\/ builder.settitle(\"save as...\"); \/\/ builder.setitems(new charsequence[]{\"ringtone\", \"notification\", \"alarm\"}, new dialoginterface.onclicklistener(){ \/\/ \/\/ @override \/\/ public void onclick(dialoginterface dialog, int which){ \/\/ \/\/ \/\/ decide on the users choice which information will be send to a method that handles the settings for all kinds of system audio \/\/\/\/ switch (which) { \/\/\/\/ \/\/\/\/ \/\/ ringtone \/\/\/\/ case 0: \/\/\/\/ changesystemaudio(context, ringtonemanager.type_ringtone, file); \/\/\/\/ break; \/\/\/\/ \/\/ notification \/\/\/\/ case 1: \/\/\/\/ changesystemaudio(context, ringtonemanager.type_notification, file); \/\/\/\/ break; \/\/\/\/ \/\/ alarmton \/\/\/\/ case 2: \/\/\/\/ changesystemaudio(context, ringtonemanager.type_alarm, file); \/\/\/\/ break; \/\/\/\/ default: \/\/\/\/ } \/\/ } \/\/ }); \/\/ builder.create(); \/\/ builder.show(); \/\/ }\n\/\/ add sound to favorites \/ remove sound from favorites \/\/ if (item.getitemid() == r.id.action_favorite) { \/\/ \/\/ databasehandler databasehandler = databasehandler \/\/ .getinstance(context.getapplicationcontext()); \/\/ \/\/ \/\/ identify the current activity \/\/ if (context instanceof favoriteactivity) { \/\/ databasehandler.removefavorite(context, soundobject); \/\/ } else { \/\/ databasehandler.addfavorite(soundobject); \/\/ } \/\/ }","repo":"scubedcombd\/Sacred_Games_Soundboard","code_context_2":"public static void popupManager(final View view, final SoundObject soundObject){\n\/\/ Declare PopupMenu and assign it to the design created in longclick.xml\nPopupMenu popup = new PopupMenu(view.getContext(), view);\npopup.getMenuInflater().inflate(R.menu.longclick, popup.getMenu());\n\/\/ Handle user clicks on the popupmenu\npopup.setOnMenuItemClickListener(new PopupMenu.OnMenuItemClickListener() {\n@Override\npublic boolean onMenuItemClick(MenuItem item) {\n\/\/ Check if the user wants to share a sound or set a sound as system audio\nif (item.getItemId() == R.id.action_send || item.getItemId() == R.id.action_ringtone){\n\/\/ Define a filename on the given information from the SoundObject AND add the .mp3 tag to it\nfinal String fileName = soundObject.getItemName() + \".mp3\";\n\/\/ Get the path to the users external storage\nFile storage = Environment.getExternalStorageDirectory();\n\/\/ Define the directory path to the soundboard apps folder\n\/\/ Change my_soundboard to whatever you want as your folder but keep the slash\n\/\/ TODO: When changing the path be sure to also modify the path in filepaths.xml (res\/xml\/filepaths.xml)\nFile directory = new File(storage.getAbsolutePath() + \"\/my_soundboard\/\");\n\/\/ Creates the directory if it doesn't exist\n\/\/ mkdirs() gives back a boolean. You can use it to do some processes as well but we don't really need it.\ndirectory.mkdirs();\n\/\/ Finally define the file by giving over the directory and the filename\nfinal File file = new File(directory, fileName);\n\/\/ Define an InputStream that will read the data from your sound-raw.mp3 file into a buffer\nInputStream in = view.getContext().getResources().openRawResource(soundObject.getItemID());\ntry{\n\/\/ Log the name of the sound that is being saved\nLog.i(LOG_TAG, \"Saving sound \" + soundObject.getItemName());\n\/\/ Define an OutputStream\/FileOutputStream that will write the buffer data into the sound.mp3 on the external storage\nOutputStream out = new FileOutputStream(file);\n\/\/ Define a buffer of 1kb (you can make it a little bit bigger but 1kb will be adequate)\nbyte[] buffer = new byte[1024];\nint len;\n\/\/ Write the data to the sound.mp3 file while reading it from the sound-raw.mp3\n\/\/ if (int) InputStream.read() returns -1 stream is at the end of file\nwhile ((len = in.read(buffer, 0, buffer.length)) != -1){\nout.write(buffer, 0 , len);\n}\n\/\/ Close both streams\nin.close();\nout.close();\n} catch (IOException e){\n\/\/ Log error if process failed\nLog.e(LOG_TAG, \"Failed to save file: \" + e.getMessage());\n}\n\/\/ Send a sound via WhatsApp or the like\nif (item.getItemId() == R.id.action_send){\ntry{\n\/\/ Check if the users device Android version is 5.1 or higher\n\/\/ If it is you'll have to use FileProvider to get the sharing function to work properly\nif (Build.VERSION.SDK_INT >= Build.VERSION_CODES.LOLLIPOP_MR1){\nfinal String AUTHORITY = view.getContext().getPackageName() + \".fileprovider\";\nUri contentUri = FileProvider.getUriForFile(view.getContext(), AUTHORITY, file);\nfinal Intent shareIntent = new Intent(Intent.ACTION_SEND);\nfinal Intent intent = new Intent(Intent.ACTION_SEND);\nintent.putExtra(Intent.EXTRA_STREAM, contentUri);\n\/\/ Define the intent to be of type audio\/mp3\nintent.setType(\"audio\/mp3\");\n\/\/ Start a new chooser dialog where the user can choose an app to share the sound\nview.getContext().startActivity(Intent.createChooser(intent, \"Share sound via...\"));\n}\nelse {\nfinal Intent intent = new Intent(Intent.ACTION_SEND);\n\/\/ Uri refers to a name or location\n\/\/ .parse() analyzes a given uri string and creates a Uri from it\n\/\/ Define a \"link\" (Uri) to the saved file\nUri fileUri = Uri.parse(file.getAbsolutePath());\nintent.putExtra(Intent.EXTRA_STREAM, fileUri);\n\/\/ Define the intent to be of type audio\/mp3\nintent.setType(\"audio\/mp3\");\n\/\/ Start a new chooser dialog where the user can choose an app to share the sound\nview.getContext().startActivity(Intent.createChooser(intent, \"Share sound via...\"));\n}\n} catch (Exception e){\n\/\/ Log error if process failed\nLog.e(LOG_TAG, \"Failed to share sound: \" + e.getMessage());\n}\n}\n\/\/ Save as ringtone, alarm or notification\n\/\/ if (item.getItemId() == R.id.action_ringtone) {\n\/\/\n\/\/ \/\/ Create a little popup like dialog that gives the user the choice between the 3 types\n\/\/ \/\/ THEME_HOLO_LIGHT was deprecated in API 23 but to support older APIs you should use it\n\/\/ AlertDialog.Builder builder = new AlertDialog.Builder(view.getContext(), AlertDialog.THEME_HOLO_LIGHT);\n\/\/ builder.setTitle(\"Save as...\");\n\/\/ builder.setItems(new CharSequence[]{\"Ringtone\", \"Notification\", \"Alarm\"}, new DialogInterface.OnClickListener(){\n\/\/\n\/\/ @Override\n\/\/ public void onClick(DialogInterface dialog, int which){\n\/\/\n\/\/ \/\/ Decide on the users choice which information will be send to a method that handles the settings for all kinds of system audio\n\/\/\/\/ switch (which) {\n\/\/\/\/\n\/\/\/\/ \/\/ Ringtone\n\/\/\/\/ case 0:\n\/\/\/\/ changeSystemAudio(context, RingtoneManager.TYPE_RINGTONE, file);\n\/\/\/\/ break;\n\/\/\/\/ \/\/ Notification\n\/\/\/\/ case 1:\n\/\/\/\/ changeSystemAudio(context, RingtoneManager.TYPE_NOTIFICATION, file);\n\/\/\/\/ break;\n\/\/\/\/ \/\/ Alarmton\n\/\/\/\/ case 2:\n\/\/\/\/ changeSystemAudio(context, RingtoneManager.TYPE_ALARM, file);\n\/\/\/\/ break;\n\/\/\/\/ default:\n\/\/\/\/ }\n\/\/ }\n\/\/ });\n\/\/ builder.create();\n\/\/ builder.show();\n\/\/ }\n}\n\/\/ Add sound to favorites \/ Remove sound from favorites\n\/\/ if (item.getItemId() == R.id.action_favorite) {\n\/\/\n\/\/ DatabaseHandler databaseHandler = DatabaseHandler\n\/\/ .getInstance(context.getApplicationContext());\n\/\/\n\/\/ \/\/ Identify the current activity\n\/\/ if (context instanceof FavoriteActivity) {\n\/\/ databaseHandler.removeFavorite(context, soundObject);\n\/\/ } else {\n\/\/ databaseHandler.addFavorite(soundObject);\n\/\/ }\n\/\/ }\nreturn true;\n}\n});\npopup.show();\n}\n\npublic static void popupManager(final View view, final SoundObject soundObject){\n\/\/ Declare PopupMenu and assign it to the design created in longclick.xml\nPopupMenu popup = new PopupMenu(view.getContext(), view);\npopup.getMenuInflater().inflate(R.menu.longclick, popup.getMenu());\n\nPopupMenu popup = new PopupMenu(view.getContext(), view);\npopup.getMenuInflater().inflate(R.menu.longclick, popup.getMenu());\n\/\/ Handle user clicks on the popupmenu\npopup.setOnMenuItemClickListener(new PopupMenu.OnMenuItemClickListener() {\n@Override\n\n@Override\npublic boolean onMenuItemClick(MenuItem item) {\n\/\/ Check if the user wants to share a sound or set a sound as system audio\nif (item.getItemId() == R.id.action_send || item.getItemId() == R.id.action_ringtone){\n\/\/ Define a filename on the given information from the SoundObject AND add the .mp3 tag to it\n\n\/\/ Check if the user wants to share a sound or set a sound as system audio\nif (item.getItemId() == R.id.action_send || item.getItemId() == R.id.action_ringtone){\n\/\/ Define a filename on the given information from the SoundObject AND add the .mp3 tag to it\nfinal String fileName = soundObject.getItemName() + \".mp3\";\n\/\/ Get the path to the users external storage\n\n\/\/ Define a filename on the given information from the SoundObject AND add the .mp3 tag to it\nfinal String fileName = soundObject.getItemName() + \".mp3\";\n\/\/ Get the path to the users external storage\nFile storage = Environment.getExternalStorageDirectory();\n\/\/ Define the directory path to the soundboard apps folder\n\n\/\/ Get the path to the users external storage\nFile storage = Environment.getExternalStorageDirectory();\n\/\/ Define the directory path to the soundboard apps folder\n\/\/ Change my_soundboard to whatever you want as your folder but keep the slash\n\/\/ TODO: When changing the path be sure to also modify the path in filepaths.xml (res\/xml\/filepaths.xml)\nFile directory = new File(storage.getAbsolutePath() + \"\/my_soundboard\/\");\n\/\/ Creates the directory if it doesn't exist\n\n\/\/ TODO: When changing the path be sure to also modify the path in filepaths.xml (res\/xml\/filepaths.xml)\nFile directory = new File(storage.getAbsolutePath() + \"\/my_soundboard\/\");\n\/\/ Creates the directory if it doesn't exist\n\/\/ mkdirs() gives back a boolean. You can use it to do some processes as well but we don't really need it.\ndirectory.mkdirs();\n\/\/ Finally define the file by giving over the directory and the filename\n\n\/\/ mkdirs() gives back a boolean. You can use it to do some processes as well but we don't really need it.\ndirectory.mkdirs();\n\/\/ Finally define the file by giving over the directory and the filename\nfinal File file = new File(directory, fileName);\n\/\/ Define an InputStream that will read the data from your sound-raw.mp3 file into a buffer\n\n\/\/ Finally define the file by giving over the directory and the filename\nfinal File file = new File(directory, fileName);\n\/\/ Define an InputStream that will read the data from your sound-raw.mp3 file into a buffer\nInputStream in = view.getContext().getResources().openRawResource(soundObject.getItemID());\ntry{\n\nInputStream in = view.getContext().getResources().openRawResource(soundObject.getItemID());\ntry{\n\/\/ Log the name of the sound that is being saved\nLog.i(LOG_TAG, \"Saving sound \" + soundObject.getItemName());\n\/\/ Define an OutputStream\/FileOutputStream that will write the buffer data into the sound.mp3 on the external storage\n\n\/\/ Log the name of the sound that is being saved\nLog.i(LOG_TAG, \"Saving sound \" + soundObject.getItemName());\n\/\/ Define an OutputStream\/FileOutputStream that will write the buffer data into the sound.mp3 on the external storage\nOutputStream out = new FileOutputStream(file);\n\/\/ Define a buffer of 1kb (you can make it a little bit bigger but 1kb will be adequate)\n\n\/\/ Define an OutputStream\/FileOutputStream that will write the buffer data into the sound.mp3 on the external storage\nOutputStream out = new FileOutputStream(file);\n\/\/ Define a buffer of 1kb (you can make it a little bit bigger but 1kb will be adequate)\nbyte[] buffer = new byte[1024];\nint len;\n\nbyte[] buffer = new byte[1024];\nint len;\n\/\/ Write the data to the sound.mp3 file while reading it from the sound-raw.mp3\n\/\/ if (int) InputStream.read() returns -1 stream is at the end of file\nwhile ((len = in.read(buffer, 0, buffer.length)) != -1){\nout.write(buffer, 0 , len);\n\nout.write(buffer, 0 , len);\n}\n\/\/ Close both streams\nin.close();\nout.close();\n\nout.close();\n} catch (IOException e){\n\/\/ Log error if process failed\nLog.e(LOG_TAG, \"Failed to save file: \" + e.getMessage());\n}\n\nLog.e(LOG_TAG, \"Failed to save file: \" + e.getMessage());\n}\n\/\/ Send a sound via WhatsApp or the like\nif (item.getItemId() == R.id.action_send){\ntry{\n\nif (item.getItemId() == R.id.action_send){\ntry{\n\/\/ Check if the users device Android version is 5.1 or higher\n\/\/ If it is you'll have to use FileProvider to get the sharing function to work properly\nif (Build.VERSION.SDK_INT >= Build.VERSION_CODES.LOLLIPOP_MR1){\nfinal String AUTHORITY = view.getContext().getPackageName() + \".fileprovider\";\n\nfinal Intent intent = new Intent(Intent.ACTION_SEND);\nintent.putExtra(Intent.EXTRA_STREAM, contentUri);\n\/\/ Define the intent to be of type audio\/mp3\nintent.setType(\"audio\/mp3\");\n\/\/ Start a new chooser dialog where the user can choose an app to share the sound\n\n\/\/ Define the intent to be of type audio\/mp3\nintent.setType(\"audio\/mp3\");\n\/\/ Start a new chooser dialog where the user can choose an app to share the sound\nview.getContext().startActivity(Intent.createChooser(intent, \"Share sound via...\"));\n}\n\nelse {\nfinal Intent intent = new Intent(Intent.ACTION_SEND);\n\/\/ Uri refers to a name or location\n\/\/ .parse() analyzes a given uri string and creates a Uri from it\n\/\/ Define a \"link\" (Uri) to the saved file\nUri fileUri = Uri.parse(file.getAbsolutePath());\nintent.putExtra(Intent.EXTRA_STREAM, fileUri);\n\nfinal Intent intent = new Intent(Intent.ACTION_SEND);\nintent.putExtra(Intent.EXTRA_STREAM, contentUri);\n\/\/ Define the intent to be of type audio\/mp3\nintent.setType(\"audio\/mp3\");\n\/\/ Start a new chooser dialog where the user can choose an app to share the sound\n\n\/\/ Define the intent to be of type audio\/mp3\nintent.setType(\"audio\/mp3\");\n\/\/ Start a new chooser dialog where the user can choose an app to share the sound\nview.getContext().startActivity(Intent.createChooser(intent, \"Share sound via...\"));\n}\n\nout.close();\n} catch (IOException e){\n\/\/ Log error if process failed\nLog.e(LOG_TAG, \"Failed to save file: \" + e.getMessage());\n}\n\n}\n}\n\/\/ Save as ringtone, alarm or notification\n\/\/ if (item.getItemId() == R.id.action_ringtone) {\n\/\/\n\/\/ \/\/ Create a little popup like dialog that gives the user the choice between the 3 types\n\/\/ \/\/ THEME_HOLO_LIGHT was deprecated in API 23 but to support older APIs you should use it\n\/\/ AlertDialog.Builder builder = new AlertDialog.Builder(view.getContext(), AlertDialog.THEME_HOLO_LIGHT);\n\/\/ builder.setTitle(\"Save as...\");\n\/\/ builder.setItems(new CharSequence[]{\"Ringtone\", \"Notification\", \"Alarm\"}, new DialogInterface.OnClickListener(){\n\/\/\n\/\/ @Override\n\/\/ public void onClick(DialogInterface dialog, int which){\n\/\/\n\/\/ \/\/ Decide on the users choice which information will be send to a method that handles the settings for all kinds of system audio\n\/\/\/\/ switch (which) {\n\/\/\/\/\n\/\/\/\/ \/\/ Ringtone\n\/\/\/\/ case 0:\n\/\/\/\/ changeSystemAudio(context, RingtoneManager.TYPE_RINGTONE, file);\n\/\/\/\/ break;\n\/\/\/\/ \/\/ Notification\n\/\/\/\/ case 1:\n\/\/\/\/ changeSystemAudio(context, RingtoneManager.TYPE_NOTIFICATION, file);\n\/\/\/\/ break;\n\/\/\/\/ \/\/ Alarmton\n\/\/\/\/ case 2:\n\/\/\/\/ changeSystemAudio(context, RingtoneManager.TYPE_ALARM, file);\n\/\/\/\/ break;\n\/\/\/\/ default:\n\/\/\/\/ }\n\/\/ }\n\/\/ });\n\/\/ builder.create();\n\/\/ builder.show();\n\/\/ }\n}\n\/\/ Add sound to favorites \/ Remove sound from favorites\n\n\/\/ }\n}\n\/\/ Add sound to favorites \/ Remove sound from favorites\n\/\/ if (item.getItemId() == R.id.action_favorite) {\n\/\/\n\/\/ DatabaseHandler databaseHandler = DatabaseHandler\n\/\/ .getInstance(context.getApplicationContext());\n\/\/\n\/\/ \/\/ Identify the current activity\n\/\/ if (context instanceof FavoriteActivity) {\n\/\/ databaseHandler.removeFavorite(context, soundObject);\n\/\/ } else {\n\/\/ databaseHandler.addFavorite(soundObject);\n\/\/ }\n\/\/ }\nreturn true;\n}","code_context_10":"public static void popupManager(final View view, final SoundObject soundObject){\n\/\/ Declare PopupMenu and assign it to the design created in longclick.xml\nPopupMenu popup = new PopupMenu(view.getContext(), view);\npopup.getMenuInflater().inflate(R.menu.longclick, popup.getMenu());\n\/\/ Handle user clicks on the popupmenu\npopup.setOnMenuItemClickListener(new PopupMenu.OnMenuItemClickListener() {\n@Override\npublic boolean onMenuItemClick(MenuItem item) {\n\/\/ Check if the user wants to share a sound or set a sound as system audio\nif (item.getItemId() == R.id.action_send || item.getItemId() == R.id.action_ringtone){\n\/\/ Define a filename on the given information from the SoundObject AND add the .mp3 tag to it\nfinal String fileName = soundObject.getItemName() + \".mp3\";\n\/\/ Get the path to the users external storage\nFile storage = Environment.getExternalStorageDirectory();\n\/\/ Define the directory path to the soundboard apps folder\n\/\/ Change my_soundboard to whatever you want as your folder but keep the slash\n\/\/ TODO: When changing the path be sure to also modify the path in filepaths.xml (res\/xml\/filepaths.xml)\nFile directory = new File(storage.getAbsolutePath() + \"\/my_soundboard\/\");\n\/\/ Creates the directory if it doesn't exist\n\/\/ mkdirs() gives back a boolean. You can use it to do some processes as well but we don't really need it.\ndirectory.mkdirs();\n\/\/ Finally define the file by giving over the directory and the filename\nfinal File file = new File(directory, fileName);\n\/\/ Define an InputStream that will read the data from your sound-raw.mp3 file into a buffer\nInputStream in = view.getContext().getResources().openRawResource(soundObject.getItemID());\ntry{\n\/\/ Log the name of the sound that is being saved\nLog.i(LOG_TAG, \"Saving sound \" + soundObject.getItemName());\n\/\/ Define an OutputStream\/FileOutputStream that will write the buffer data into the sound.mp3 on the external storage\nOutputStream out = new FileOutputStream(file);\n\/\/ Define a buffer of 1kb (you can make it a little bit bigger but 1kb will be adequate)\nbyte[] buffer = new byte[1024];\nint len;\n\/\/ Write the data to the sound.mp3 file while reading it from the sound-raw.mp3\n\/\/ if (int) InputStream.read() returns -1 stream is at the end of file\nwhile ((len = in.read(buffer, 0, buffer.length)) != -1){\nout.write(buffer, 0 , len);\n}\n\/\/ Close both streams\nin.close();\nout.close();\n} catch (IOException e){\n\/\/ Log error if process failed\nLog.e(LOG_TAG, \"Failed to save file: \" + e.getMessage());\n}\n\/\/ Send a sound via WhatsApp or the like\nif (item.getItemId() == R.id.action_send){\ntry{\n\/\/ Check if the users device Android version is 5.1 or higher\n\/\/ If it is you'll have to use FileProvider to get the sharing function to work properly\nif (Build.VERSION.SDK_INT >= Build.VERSION_CODES.LOLLIPOP_MR1){\nfinal String AUTHORITY = view.getContext().getPackageName() + \".fileprovider\";\nUri contentUri = FileProvider.getUriForFile(view.getContext(), AUTHORITY, file);\nfinal Intent shareIntent = new Intent(Intent.ACTION_SEND);\nfinal Intent intent = new Intent(Intent.ACTION_SEND);\nintent.putExtra(Intent.EXTRA_STREAM, contentUri);\n\/\/ Define the intent to be of type audio\/mp3\nintent.setType(\"audio\/mp3\");\n\/\/ Start a new chooser dialog where the user can choose an app to share the sound\nview.getContext().startActivity(Intent.createChooser(intent, \"Share sound via...\"));\n}\nelse {\nfinal Intent intent = new Intent(Intent.ACTION_SEND);\n\/\/ Uri refers to a name or location\n\/\/ .parse() analyzes a given uri string and creates a Uri from it\n\/\/ Define a \"link\" (Uri) to the saved file\nUri fileUri = Uri.parse(file.getAbsolutePath());\nintent.putExtra(Intent.EXTRA_STREAM, fileUri);\n\/\/ Define the intent to be of type audio\/mp3\nintent.setType(\"audio\/mp3\");\n\/\/ Start a new chooser dialog where the user can choose an app to share the sound\nview.getContext().startActivity(Intent.createChooser(intent, \"Share sound via...\"));\n}\n} catch (Exception e){\n\/\/ Log error if process failed\nLog.e(LOG_TAG, \"Failed to share sound: \" + e.getMessage());\n}\n}\n\/\/ Save as ringtone, alarm or notification\n\/\/ if (item.getItemId() == R.id.action_ringtone) {\n\/\/\n\/\/ \/\/ Create a little popup like dialog that gives the user the choice between the 3 types\n\/\/ \/\/ THEME_HOLO_LIGHT was deprecated in API 23 but to support older APIs you should use it\n\/\/ AlertDialog.Builder builder = new AlertDialog.Builder(view.getContext(), AlertDialog.THEME_HOLO_LIGHT);\n\/\/ builder.setTitle(\"Save as...\");\n\/\/ builder.setItems(new CharSequence[]{\"Ringtone\", \"Notification\", \"Alarm\"}, new DialogInterface.OnClickListener(){\n\/\/\n\/\/ @Override\n\/\/ public void onClick(DialogInterface dialog, int which){\n\/\/\n\/\/ \/\/ Decide on the users choice which information will be send to a method that handles the settings for all kinds of system audio\n\/\/\/\/ switch (which) {\n\/\/\/\/\n\/\/\/\/ \/\/ Ringtone\n\/\/\/\/ case 0:\n\/\/\/\/ changeSystemAudio(context, RingtoneManager.TYPE_RINGTONE, file);\n\/\/\/\/ break;\n\/\/\/\/ \/\/ Notification\n\/\/\/\/ case 1:\n\/\/\/\/ changeSystemAudio(context, RingtoneManager.TYPE_NOTIFICATION, file);\n\/\/\/\/ break;\n\/\/\/\/ \/\/ Alarmton\n\/\/\/\/ case 2:\n\/\/\/\/ changeSystemAudio(context, RingtoneManager.TYPE_ALARM, file);\n\/\/\/\/ break;\n\/\/\/\/ default:\n\/\/\/\/ }\n\/\/ }\n\/\/ });\n\/\/ builder.create();\n\/\/ builder.show();\n\/\/ }\n}\n\/\/ Add sound to favorites \/ Remove sound from favorites\n\/\/ if (item.getItemId() == R.id.action_favorite) {\n\/\/\n\/\/ DatabaseHandler databaseHandler = DatabaseHandler\n\/\/ .getInstance(context.getApplicationContext());\n\/\/\n\/\/ \/\/ Identify the current activity\n\/\/ if (context instanceof FavoriteActivity) {\n\/\/ databaseHandler.removeFavorite(context, soundObject);\n\/\/ } else {\n\/\/ databaseHandler.addFavorite(soundObject);\n\/\/ }\n\/\/ }\nreturn true;\n}\n});\npopup.show();\n}\n\npublic static void popupManager(final View view, final SoundObject soundObject){\n\/\/ Declare PopupMenu and assign it to the design created in longclick.xml\nPopupMenu popup = new PopupMenu(view.getContext(), view);\npopup.getMenuInflater().inflate(R.menu.longclick, popup.getMenu());\n\/\/ Handle user clicks on the popupmenu\npopup.setOnMenuItemClickListener(new PopupMenu.OnMenuItemClickListener() {\n@Override\npublic boolean onMenuItemClick(MenuItem item) {\n\/\/ Check if the user wants to share a sound or set a sound as system audio\nif (item.getItemId() == R.id.action_send || item.getItemId() == R.id.action_ringtone){\n\/\/ Define a filename on the given information from the SoundObject AND add the .mp3 tag to it\nfinal String fileName = soundObject.getItemName() + \".mp3\";\n\npublic static void popupManager(final View view, final SoundObject soundObject){\n\/\/ Declare PopupMenu and assign it to the design created in longclick.xml\nPopupMenu popup = new PopupMenu(view.getContext(), view);\npopup.getMenuInflater().inflate(R.menu.longclick, popup.getMenu());\n\/\/ Handle user clicks on the popupmenu\npopup.setOnMenuItemClickListener(new PopupMenu.OnMenuItemClickListener() {\n@Override\npublic boolean onMenuItemClick(MenuItem item) {\n\/\/ Check if the user wants to share a sound or set a sound as system audio\nif (item.getItemId() == R.id.action_send || item.getItemId() == R.id.action_ringtone){\n\/\/ Define a filename on the given information from the SoundObject AND add the .mp3 tag to it\nfinal String fileName = soundObject.getItemName() + \".mp3\";\n\/\/ Get the path to the users external storage\nFile storage = Environment.getExternalStorageDirectory();\n\/\/ Define the directory path to the soundboard apps folder\n\npublic static void popupManager(final View view, final SoundObject soundObject){\n\/\/ Declare PopupMenu and assign it to the design created in longclick.xml\nPopupMenu popup = new PopupMenu(view.getContext(), view);\npopup.getMenuInflater().inflate(R.menu.longclick, popup.getMenu());\n\/\/ Handle user clicks on the popupmenu\npopup.setOnMenuItemClickListener(new PopupMenu.OnMenuItemClickListener() {\n@Override\npublic boolean onMenuItemClick(MenuItem item) {\n\/\/ Check if the user wants to share a sound or set a sound as system audio\nif (item.getItemId() == R.id.action_send || item.getItemId() == R.id.action_ringtone){\n\/\/ Define a filename on the given information from the SoundObject AND add the .mp3 tag to it\nfinal String fileName = soundObject.getItemName() + \".mp3\";\n\/\/ Get the path to the users external storage\nFile storage = Environment.getExternalStorageDirectory();\n\/\/ Define the directory path to the soundboard apps folder\n\/\/ Change my_soundboard to whatever you want as your folder but keep the slash\n\/\/ TODO: When changing the path be sure to also modify the path in filepaths.xml (res\/xml\/filepaths.xml)\nFile directory = new File(storage.getAbsolutePath() + \"\/my_soundboard\/\");\n\/\/ Creates the directory if it doesn't exist\n\npublic static void popupManager(final View view, final SoundObject soundObject){\n\/\/ Declare PopupMenu and assign it to the design created in longclick.xml\nPopupMenu popup = new PopupMenu(view.getContext(), view);\npopup.getMenuInflater().inflate(R.menu.longclick, popup.getMenu());\n\/\/ Handle user clicks on the popupmenu\npopup.setOnMenuItemClickListener(new PopupMenu.OnMenuItemClickListener() {\n@Override\npublic boolean onMenuItemClick(MenuItem item) {\n\/\/ Check if the user wants to share a sound or set a sound as system audio\nif (item.getItemId() == R.id.action_send || item.getItemId() == R.id.action_ringtone){\n\/\/ Define a filename on the given information from the SoundObject AND add the .mp3 tag to it\nfinal String fileName = soundObject.getItemName() + \".mp3\";\n\/\/ Get the path to the users external storage\nFile storage = Environment.getExternalStorageDirectory();\n\/\/ Define the directory path to the soundboard apps folder\n\/\/ Change my_soundboard to whatever you want as your folder but keep the slash\n\/\/ TODO: When changing the path be sure to also modify the path in filepaths.xml (res\/xml\/filepaths.xml)\nFile directory = new File(storage.getAbsolutePath() + \"\/my_soundboard\/\");\n\/\/ Creates the directory if it doesn't exist\n\/\/ mkdirs() gives back a boolean. You can use it to do some processes as well but we don't really need it.\ndirectory.mkdirs();\n\nPopupMenu popup = new PopupMenu(view.getContext(), view);\npopup.getMenuInflater().inflate(R.menu.longclick, popup.getMenu());\n\/\/ Handle user clicks on the popupmenu\npopup.setOnMenuItemClickListener(new PopupMenu.OnMenuItemClickListener() {\n@Override\npublic boolean onMenuItemClick(MenuItem item) {\n\/\/ Check if the user wants to share a sound or set a sound as system audio\nif (item.getItemId() == R.id.action_send || item.getItemId() == R.id.action_ringtone){\n\/\/ Define a filename on the given information from the SoundObject AND add the .mp3 tag to it\nfinal String fileName = soundObject.getItemName() + \".mp3\";\n\/\/ Get the path to the users external storage\nFile storage = Environment.getExternalStorageDirectory();\n\/\/ Define the directory path to the soundboard apps folder\n\/\/ Change my_soundboard to whatever you want as your folder but keep the slash\n\/\/ TODO: When changing the path be sure to also modify the path in filepaths.xml (res\/xml\/filepaths.xml)\nFile directory = new File(storage.getAbsolutePath() + \"\/my_soundboard\/\");\n\/\/ Creates the directory if it doesn't exist\n\/\/ mkdirs() gives back a boolean. You can use it to do some processes as well but we don't really need it.\ndirectory.mkdirs();\n\/\/ Finally define the file by giving over the directory and the filename\nfinal File file = new File(directory, fileName);\n\n\/\/ Handle user clicks on the popupmenu\npopup.setOnMenuItemClickListener(new PopupMenu.OnMenuItemClickListener() {\n@Override\npublic boolean onMenuItemClick(MenuItem item) {\n\/\/ Check if the user wants to share a sound or set a sound as system audio\nif (item.getItemId() == R.id.action_send || item.getItemId() == R.id.action_ringtone){\n\/\/ Define a filename on the given information from the SoundObject AND add the .mp3 tag to it\nfinal String fileName = soundObject.getItemName() + \".mp3\";\n\/\/ Get the path to the users external storage\nFile storage = Environment.getExternalStorageDirectory();\n\/\/ Define the directory path to the soundboard apps folder\n\/\/ Change my_soundboard to whatever you want as your folder but keep the slash\n\/\/ TODO: When changing the path be sure to also modify the path in filepaths.xml (res\/xml\/filepaths.xml)\nFile directory = new File(storage.getAbsolutePath() + \"\/my_soundboard\/\");\n\/\/ Creates the directory if it doesn't exist\n\/\/ mkdirs() gives back a boolean. You can use it to do some processes as well but we don't really need it.\ndirectory.mkdirs();\n\/\/ Finally define the file by giving over the directory and the filename\nfinal File file = new File(directory, fileName);\n\/\/ Define an InputStream that will read the data from your sound-raw.mp3 file into a buffer\nInputStream in = view.getContext().getResources().openRawResource(soundObject.getItemID());\ntry{\n\/\/ Log the name of the sound that is being saved\n\n\/\/ Check if the user wants to share a sound or set a sound as system audio\nif (item.getItemId() == R.id.action_send || item.getItemId() == R.id.action_ringtone){\n\/\/ Define a filename on the given information from the SoundObject AND add the .mp3 tag to it\nfinal String fileName = soundObject.getItemName() + \".mp3\";\n\/\/ Get the path to the users external storage\nFile storage = Environment.getExternalStorageDirectory();\n\/\/ Define the directory path to the soundboard apps folder\n\/\/ Change my_soundboard to whatever you want as your folder but keep the slash\n\/\/ TODO: When changing the path be sure to also modify the path in filepaths.xml (res\/xml\/filepaths.xml)\nFile directory = new File(storage.getAbsolutePath() + \"\/my_soundboard\/\");\n\/\/ Creates the directory if it doesn't exist\n\/\/ mkdirs() gives back a boolean. You can use it to do some processes as well but we don't really need it.\ndirectory.mkdirs();\n\/\/ Finally define the file by giving over the directory and the filename\nfinal File file = new File(directory, fileName);\n\/\/ Define an InputStream that will read the data from your sound-raw.mp3 file into a buffer\nInputStream in = view.getContext().getResources().openRawResource(soundObject.getItemID());\ntry{\n\/\/ Log the name of the sound that is being saved\nLog.i(LOG_TAG, \"Saving sound \" + soundObject.getItemName());\n\/\/ Define an OutputStream\/FileOutputStream that will write the buffer data into the sound.mp3 on the external storage\nOutputStream out = new FileOutputStream(file);\n\nfinal String fileName = soundObject.getItemName() + \".mp3\";\n\/\/ Get the path to the users external storage\nFile storage = Environment.getExternalStorageDirectory();\n\/\/ Define the directory path to the soundboard apps folder\n\/\/ Change my_soundboard to whatever you want as your folder but keep the slash\n\/\/ TODO: When changing the path be sure to also modify the path in filepaths.xml (res\/xml\/filepaths.xml)\nFile directory = new File(storage.getAbsolutePath() + \"\/my_soundboard\/\");\n\/\/ Creates the directory if it doesn't exist\n\/\/ mkdirs() gives back a boolean. You can use it to do some processes as well but we don't really need it.\ndirectory.mkdirs();\n\/\/ Finally define the file by giving over the directory and the filename\nfinal File file = new File(directory, fileName);\n\/\/ Define an InputStream that will read the data from your sound-raw.mp3 file into a buffer\nInputStream in = view.getContext().getResources().openRawResource(soundObject.getItemID());\ntry{\n\/\/ Log the name of the sound that is being saved\nLog.i(LOG_TAG, \"Saving sound \" + soundObject.getItemName());\n\/\/ Define an OutputStream\/FileOutputStream that will write the buffer data into the sound.mp3 on the external storage\nOutputStream out = new FileOutputStream(file);\n\/\/ Define a buffer of 1kb (you can make it a little bit bigger but 1kb will be adequate)\nbyte[] buffer = new byte[1024];\n\nFile storage = Environment.getExternalStorageDirectory();\n\/\/ Define the directory path to the soundboard apps folder\n\/\/ Change my_soundboard to whatever you want as your folder but keep the slash\n\/\/ TODO: When changing the path be sure to also modify the path in filepaths.xml (res\/xml\/filepaths.xml)\nFile directory = new File(storage.getAbsolutePath() + \"\/my_soundboard\/\");\n\/\/ Creates the directory if it doesn't exist\n\/\/ mkdirs() gives back a boolean. You can use it to do some processes as well but we don't really need it.\ndirectory.mkdirs();\n\/\/ Finally define the file by giving over the directory and the filename\nfinal File file = new File(directory, fileName);\n\/\/ Define an InputStream that will read the data from your sound-raw.mp3 file into a buffer\nInputStream in = view.getContext().getResources().openRawResource(soundObject.getItemID());\ntry{\n\/\/ Log the name of the sound that is being saved\nLog.i(LOG_TAG, \"Saving sound \" + soundObject.getItemName());\n\/\/ Define an OutputStream\/FileOutputStream that will write the buffer data into the sound.mp3 on the external storage\nOutputStream out = new FileOutputStream(file);\n\/\/ Define a buffer of 1kb (you can make it a little bit bigger but 1kb will be adequate)\nbyte[] buffer = new byte[1024];\nint len;\n\/\/ Write the data to the sound.mp3 file while reading it from the sound-raw.mp3\n\n\/\/ TODO: When changing the path be sure to also modify the path in filepaths.xml (res\/xml\/filepaths.xml)\nFile directory = new File(storage.getAbsolutePath() + \"\/my_soundboard\/\");\n\/\/ Creates the directory if it doesn't exist\n\/\/ mkdirs() gives back a boolean. You can use it to do some processes as well but we don't really need it.\ndirectory.mkdirs();\n\/\/ Finally define the file by giving over the directory and the filename\nfinal File file = new File(directory, fileName);\n\/\/ Define an InputStream that will read the data from your sound-raw.mp3 file into a buffer\nInputStream in = view.getContext().getResources().openRawResource(soundObject.getItemID());\ntry{\n\/\/ Log the name of the sound that is being saved\nLog.i(LOG_TAG, \"Saving sound \" + soundObject.getItemName());\n\/\/ Define an OutputStream\/FileOutputStream that will write the buffer data into the sound.mp3 on the external storage\nOutputStream out = new FileOutputStream(file);\n\/\/ Define a buffer of 1kb (you can make it a little bit bigger but 1kb will be adequate)\nbyte[] buffer = new byte[1024];\nint len;\n\/\/ Write the data to the sound.mp3 file while reading it from the sound-raw.mp3\n\/\/ if (int) InputStream.read() returns -1 stream is at the end of file\nwhile ((len = in.read(buffer, 0, buffer.length)) != -1){\nout.write(buffer, 0 , len);\n\n\/\/ Creates the directory if it doesn't exist\n\/\/ mkdirs() gives back a boolean. You can use it to do some processes as well but we don't really need it.\ndirectory.mkdirs();\n\/\/ Finally define the file by giving over the directory and the filename\nfinal File file = new File(directory, fileName);\n\/\/ Define an InputStream that will read the data from your sound-raw.mp3 file into a buffer\nInputStream in = view.getContext().getResources().openRawResource(soundObject.getItemID());\ntry{\n\/\/ Log the name of the sound that is being saved\nLog.i(LOG_TAG, \"Saving sound \" + soundObject.getItemName());\n\/\/ Define an OutputStream\/FileOutputStream that will write the buffer data into the sound.mp3 on the external storage\nOutputStream out = new FileOutputStream(file);\n\/\/ Define a buffer of 1kb (you can make it a little bit bigger but 1kb will be adequate)\nbyte[] buffer = new byte[1024];\nint len;\n\/\/ Write the data to the sound.mp3 file while reading it from the sound-raw.mp3\n\/\/ if (int) InputStream.read() returns -1 stream is at the end of file\nwhile ((len = in.read(buffer, 0, buffer.length)) != -1){\nout.write(buffer, 0 , len);\n}\n\/\/ Close both streams\n\ndirectory.mkdirs();\n\/\/ Finally define the file by giving over the directory and the filename\nfinal File file = new File(directory, fileName);\n\/\/ Define an InputStream that will read the data from your sound-raw.mp3 file into a buffer\nInputStream in = view.getContext().getResources().openRawResource(soundObject.getItemID());\ntry{\n\/\/ Log the name of the sound that is being saved\nLog.i(LOG_TAG, \"Saving sound \" + soundObject.getItemName());\n\/\/ Define an OutputStream\/FileOutputStream that will write the buffer data into the sound.mp3 on the external storage\nOutputStream out = new FileOutputStream(file);\n\/\/ Define a buffer of 1kb (you can make it a little bit bigger but 1kb will be adequate)\nbyte[] buffer = new byte[1024];\nint len;\n\/\/ Write the data to the sound.mp3 file while reading it from the sound-raw.mp3\n\/\/ if (int) InputStream.read() returns -1 stream is at the end of file\nwhile ((len = in.read(buffer, 0, buffer.length)) != -1){\nout.write(buffer, 0 , len);\n}\n\/\/ Close both streams\nin.close();\nout.close();\n\n\/\/ Define an InputStream that will read the data from your sound-raw.mp3 file into a buffer\nInputStream in = view.getContext().getResources().openRawResource(soundObject.getItemID());\ntry{\n\/\/ Log the name of the sound that is being saved\nLog.i(LOG_TAG, \"Saving sound \" + soundObject.getItemName());\n\/\/ Define an OutputStream\/FileOutputStream that will write the buffer data into the sound.mp3 on the external storage\nOutputStream out = new FileOutputStream(file);\n\/\/ Define a buffer of 1kb (you can make it a little bit bigger but 1kb will be adequate)\nbyte[] buffer = new byte[1024];\nint len;\n\/\/ Write the data to the sound.mp3 file while reading it from the sound-raw.mp3\n\/\/ if (int) InputStream.read() returns -1 stream is at the end of file\nwhile ((len = in.read(buffer, 0, buffer.length)) != -1){\nout.write(buffer, 0 , len);\n}\n\/\/ Close both streams\nin.close();\nout.close();\n} catch (IOException e){\n\/\/ Log error if process failed\nLog.e(LOG_TAG, \"Failed to save file: \" + e.getMessage());\n}\n\n\/\/ Define an OutputStream\/FileOutputStream that will write the buffer data into the sound.mp3 on the external storage\nOutputStream out = new FileOutputStream(file);\n\/\/ Define a buffer of 1kb (you can make it a little bit bigger but 1kb will be adequate)\nbyte[] buffer = new byte[1024];\nint len;\n\/\/ Write the data to the sound.mp3 file while reading it from the sound-raw.mp3\n\/\/ if (int) InputStream.read() returns -1 stream is at the end of file\nwhile ((len = in.read(buffer, 0, buffer.length)) != -1){\nout.write(buffer, 0 , len);\n}\n\/\/ Close both streams\nin.close();\nout.close();\n} catch (IOException e){\n\/\/ Log error if process failed\nLog.e(LOG_TAG, \"Failed to save file: \" + e.getMessage());\n}\n\/\/ Send a sound via WhatsApp or the like\nif (item.getItemId() == R.id.action_send){\ntry{\n\/\/ Check if the users device Android version is 5.1 or higher\n\nint len;\n\/\/ Write the data to the sound.mp3 file while reading it from the sound-raw.mp3\n\/\/ if (int) InputStream.read() returns -1 stream is at the end of file\nwhile ((len = in.read(buffer, 0, buffer.length)) != -1){\nout.write(buffer, 0 , len);\n}\n\/\/ Close both streams\nin.close();\nout.close();\n} catch (IOException e){\n\/\/ Log error if process failed\nLog.e(LOG_TAG, \"Failed to save file: \" + e.getMessage());\n}\n\/\/ Send a sound via WhatsApp or the like\nif (item.getItemId() == R.id.action_send){\ntry{\n\/\/ Check if the users device Android version is 5.1 or higher\n\/\/ If it is you'll have to use FileProvider to get the sharing function to work properly\nif (Build.VERSION.SDK_INT >= Build.VERSION_CODES.LOLLIPOP_MR1){\nfinal String AUTHORITY = view.getContext().getPackageName() + \".fileprovider\";\nUri contentUri = FileProvider.getUriForFile(view.getContext(), AUTHORITY, file);\n\nwhile ((len = in.read(buffer, 0, buffer.length)) != -1){\nout.write(buffer, 0 , len);\n}\n\/\/ Close both streams\nin.close();\nout.close();\n} catch (IOException e){\n\/\/ Log error if process failed\nLog.e(LOG_TAG, \"Failed to save file: \" + e.getMessage());\n}\n\/\/ Send a sound via WhatsApp or the like\nif (item.getItemId() == R.id.action_send){\ntry{\n\/\/ Check if the users device Android version is 5.1 or higher\n\/\/ If it is you'll have to use FileProvider to get the sharing function to work properly\nif (Build.VERSION.SDK_INT >= Build.VERSION_CODES.LOLLIPOP_MR1){\nfinal String AUTHORITY = view.getContext().getPackageName() + \".fileprovider\";\nUri contentUri = FileProvider.getUriForFile(view.getContext(), AUTHORITY, file);\nfinal Intent shareIntent = new Intent(Intent.ACTION_SEND);\nfinal Intent intent = new Intent(Intent.ACTION_SEND);\nintent.putExtra(Intent.EXTRA_STREAM, contentUri);\n\n\/\/ Close both streams\nin.close();\nout.close();\n} catch (IOException e){\n\/\/ Log error if process failed\nLog.e(LOG_TAG, \"Failed to save file: \" + e.getMessage());\n}\n\/\/ Send a sound via WhatsApp or the like\nif (item.getItemId() == R.id.action_send){\ntry{\n\/\/ Check if the users device Android version is 5.1 or higher\n\/\/ If it is you'll have to use FileProvider to get the sharing function to work properly\nif (Build.VERSION.SDK_INT >= Build.VERSION_CODES.LOLLIPOP_MR1){\nfinal String AUTHORITY = view.getContext().getPackageName() + \".fileprovider\";\nUri contentUri = FileProvider.getUriForFile(view.getContext(), AUTHORITY, file);\nfinal Intent shareIntent = new Intent(Intent.ACTION_SEND);\nfinal Intent intent = new Intent(Intent.ACTION_SEND);\nintent.putExtra(Intent.EXTRA_STREAM, contentUri);\n\/\/ Define the intent to be of type audio\/mp3\nintent.setType(\"audio\/mp3\");\n\/\/ Start a new chooser dialog where the user can choose an app to share the sound\nview.getContext().startActivity(Intent.createChooser(intent, \"Share sound via...\"));\n\nif (item.getItemId() == R.id.action_send){\ntry{\n\/\/ Check if the users device Android version is 5.1 or higher\n\/\/ If it is you'll have to use FileProvider to get the sharing function to work properly\nif (Build.VERSION.SDK_INT >= Build.VERSION_CODES.LOLLIPOP_MR1){\nfinal String AUTHORITY = view.getContext().getPackageName() + \".fileprovider\";\nUri contentUri = FileProvider.getUriForFile(view.getContext(), AUTHORITY, file);\nfinal Intent shareIntent = new Intent(Intent.ACTION_SEND);\nfinal Intent intent = new Intent(Intent.ACTION_SEND);\nintent.putExtra(Intent.EXTRA_STREAM, contentUri);\n\/\/ Define the intent to be of type audio\/mp3\nintent.setType(\"audio\/mp3\");\n\/\/ Start a new chooser dialog where the user can choose an app to share the sound\nview.getContext().startActivity(Intent.createChooser(intent, \"Share sound via...\"));\n}\nelse {\nfinal Intent intent = new Intent(Intent.ACTION_SEND);\n\/\/ Uri refers to a name or location\n\/\/ .parse() analyzes a given uri string and creates a Uri from it\n\/\/ Define a \"link\" (Uri) to the saved file\nUri fileUri = Uri.parse(file.getAbsolutePath());\n\n\/\/ Check if the users device Android version is 5.1 or higher\n\/\/ If it is you'll have to use FileProvider to get the sharing function to work properly\nif (Build.VERSION.SDK_INT >= Build.VERSION_CODES.LOLLIPOP_MR1){\nfinal String AUTHORITY = view.getContext().getPackageName() + \".fileprovider\";\nUri contentUri = FileProvider.getUriForFile(view.getContext(), AUTHORITY, file);\nfinal Intent shareIntent = new Intent(Intent.ACTION_SEND);\nfinal Intent intent = new Intent(Intent.ACTION_SEND);\nintent.putExtra(Intent.EXTRA_STREAM, contentUri);\n\/\/ Define the intent to be of type audio\/mp3\nintent.setType(\"audio\/mp3\");\n\/\/ Start a new chooser dialog where the user can choose an app to share the sound\nview.getContext().startActivity(Intent.createChooser(intent, \"Share sound via...\"));\n}\nelse {\nfinal Intent intent = new Intent(Intent.ACTION_SEND);\n\/\/ Uri refers to a name or location\n\/\/ .parse() analyzes a given uri string and creates a Uri from it\n\/\/ Define a \"link\" (Uri) to the saved file\nUri fileUri = Uri.parse(file.getAbsolutePath());\nintent.putExtra(Intent.EXTRA_STREAM, fileUri);\n\/\/ Define the intent to be of type audio\/mp3\n\nfinal Intent shareIntent = new Intent(Intent.ACTION_SEND);\nfinal Intent intent = new Intent(Intent.ACTION_SEND);\nintent.putExtra(Intent.EXTRA_STREAM, contentUri);\n\/\/ Define the intent to be of type audio\/mp3\nintent.setType(\"audio\/mp3\");\n\/\/ Start a new chooser dialog where the user can choose an app to share the sound\nview.getContext().startActivity(Intent.createChooser(intent, \"Share sound via...\"));\n}\nelse {\nfinal Intent intent = new Intent(Intent.ACTION_SEND);\n\/\/ Uri refers to a name or location\n\/\/ .parse() analyzes a given uri string and creates a Uri from it\n\/\/ Define a \"link\" (Uri) to the saved file\nUri fileUri = Uri.parse(file.getAbsolutePath());\nintent.putExtra(Intent.EXTRA_STREAM, fileUri);\n\/\/ Define the intent to be of type audio\/mp3\nintent.setType(\"audio\/mp3\");\n\/\/ Start a new chooser dialog where the user can choose an app to share the sound\nview.getContext().startActivity(Intent.createChooser(intent, \"Share sound via...\"));\n}\n} catch (Exception e){\n\/\/ Log error if process failed\nLog.e(LOG_TAG, \"Failed to share sound: \" + e.getMessage());\n\nif (item.getItemId() == R.id.action_send){\ntry{\n\/\/ Check if the users device Android version is 5.1 or higher\n\/\/ If it is you'll have to use FileProvider to get the sharing function to work properly\nif (Build.VERSION.SDK_INT >= Build.VERSION_CODES.LOLLIPOP_MR1){\nfinal String AUTHORITY = view.getContext().getPackageName() + \".fileprovider\";\nUri contentUri = FileProvider.getUriForFile(view.getContext(), AUTHORITY, file);\nfinal Intent shareIntent = new Intent(Intent.ACTION_SEND);\nfinal Intent intent = new Intent(Intent.ACTION_SEND);\nintent.putExtra(Intent.EXTRA_STREAM, contentUri);\n\/\/ Define the intent to be of type audio\/mp3\nintent.setType(\"audio\/mp3\");\n\/\/ Start a new chooser dialog where the user can choose an app to share the sound\nview.getContext().startActivity(Intent.createChooser(intent, \"Share sound via...\"));\n}\nelse {\nfinal Intent intent = new Intent(Intent.ACTION_SEND);\n\/\/ Uri refers to a name or location\n\/\/ .parse() analyzes a given uri string and creates a Uri from it\n\/\/ Define a \"link\" (Uri) to the saved file\nUri fileUri = Uri.parse(file.getAbsolutePath());\n\n\/\/ Check if the users device Android version is 5.1 or higher\n\/\/ If it is you'll have to use FileProvider to get the sharing function to work properly\nif (Build.VERSION.SDK_INT >= Build.VERSION_CODES.LOLLIPOP_MR1){\nfinal String AUTHORITY = view.getContext().getPackageName() + \".fileprovider\";\nUri contentUri = FileProvider.getUriForFile(view.getContext(), AUTHORITY, file);\nfinal Intent shareIntent = new Intent(Intent.ACTION_SEND);\nfinal Intent intent = new Intent(Intent.ACTION_SEND);\nintent.putExtra(Intent.EXTRA_STREAM, contentUri);\n\/\/ Define the intent to be of type audio\/mp3\nintent.setType(\"audio\/mp3\");\n\/\/ Start a new chooser dialog where the user can choose an app to share the sound\nview.getContext().startActivity(Intent.createChooser(intent, \"Share sound via...\"));\n}\nelse {\nfinal Intent intent = new Intent(Intent.ACTION_SEND);\n\/\/ Uri refers to a name or location\n\/\/ .parse() analyzes a given uri string and creates a Uri from it\n\/\/ Define a \"link\" (Uri) to the saved file\nUri fileUri = Uri.parse(file.getAbsolutePath());\nintent.putExtra(Intent.EXTRA_STREAM, fileUri);\n\/\/ Define the intent to be of type audio\/mp3\n\nint len;\n\/\/ Write the data to the sound.mp3 file while reading it from the sound-raw.mp3\n\/\/ if (int) InputStream.read() returns -1 stream is at the end of file\nwhile ((len = in.read(buffer, 0, buffer.length)) != -1){\nout.write(buffer, 0 , len);\n}\n\/\/ Close both streams\nin.close();\nout.close();\n} catch (IOException e){\n\/\/ Log error if process failed\nLog.e(LOG_TAG, \"Failed to save file: \" + e.getMessage());\n}\n\/\/ Send a sound via WhatsApp or the like\nif (item.getItemId() == R.id.action_send){\ntry{\n\/\/ Check if the users device Android version is 5.1 or higher\n\/\/ If it is you'll have to use FileProvider to get the sharing function to work properly\nif (Build.VERSION.SDK_INT >= Build.VERSION_CODES.LOLLIPOP_MR1){\nfinal String AUTHORITY = view.getContext().getPackageName() + \".fileprovider\";\nUri contentUri = FileProvider.getUriForFile(view.getContext(), AUTHORITY, file);\n\n\/\/ Define the intent to be of type audio\/mp3\nintent.setType(\"audio\/mp3\");\n\/\/ Start a new chooser dialog where the user can choose an app to share the sound\nview.getContext().startActivity(Intent.createChooser(intent, \"Share sound via...\"));\n}\n} catch (Exception e){\n\/\/ Log error if process failed\nLog.e(LOG_TAG, \"Failed to share sound: \" + e.getMessage());\n}\n}\n\/\/ Save as ringtone, alarm or notification\n\/\/ if (item.getItemId() == R.id.action_ringtone) {\n\/\/\n\/\/ \/\/ Create a little popup like dialog that gives the user the choice between the 3 types\n\/\/ \/\/ THEME_HOLO_LIGHT was deprecated in API 23 but to support older APIs you should use it\n\/\/ AlertDialog.Builder builder = new AlertDialog.Builder(view.getContext(), AlertDialog.THEME_HOLO_LIGHT);\n\/\/ builder.setTitle(\"Save as...\");\n\/\/ builder.setItems(new CharSequence[]{\"Ringtone\", \"Notification\", \"Alarm\"}, new DialogInterface.OnClickListener(){\n\/\/\n\/\/ @Override\n\/\/ public void onClick(DialogInterface dialog, int which){\n\/\/\n\/\/ \/\/ Decide on the users choice which information will be send to a method that handles the settings for all kinds of system audio\n\/\/\/\/ switch (which) {\n\/\/\/\/\n\/\/\/\/ \/\/ Ringtone\n\/\/\/\/ case 0:\n\/\/\/\/ changeSystemAudio(context, RingtoneManager.TYPE_RINGTONE, file);\n\/\/\/\/ break;\n\/\/\/\/ \/\/ Notification\n\/\/\/\/ case 1:\n\/\/\/\/ changeSystemAudio(context, RingtoneManager.TYPE_NOTIFICATION, file);\n\/\/\/\/ break;\n\/\/\/\/ \/\/ Alarmton\n\/\/\/\/ case 2:\n\/\/\/\/ changeSystemAudio(context, RingtoneManager.TYPE_ALARM, file);\n\/\/\/\/ break;\n\/\/\/\/ default:\n\/\/\/\/ }\n\/\/ }\n\/\/ });\n\/\/ builder.create();\n\/\/ builder.show();\n\/\/ }\n}\n\/\/ Add sound to favorites \/ Remove sound from favorites\n\/\/ if (item.getItemId() == R.id.action_favorite) {\n\/\/\n\/\/ DatabaseHandler databaseHandler = DatabaseHandler\n\/\/ .getInstance(context.getApplicationContext());\n\/\/\n\/\/ \/\/ Identify the current activity\n\/\/ if (context instanceof FavoriteActivity) {\n\/\/ databaseHandler.removeFavorite(context, soundObject);\n\n\/\/\/\/ changeSystemAudio(context, RingtoneManager.TYPE_ALARM, file);\n\/\/\/\/ break;\n\/\/\/\/ default:\n\/\/\/\/ }\n\/\/ }\n\/\/ });\n\/\/ builder.create();\n\/\/ builder.show();\n\/\/ }\n}\n\/\/ Add sound to favorites \/ Remove sound from favorites\n\/\/ if (item.getItemId() == R.id.action_favorite) {\n\/\/\n\/\/ DatabaseHandler databaseHandler = DatabaseHandler\n\/\/ .getInstance(context.getApplicationContext());\n\/\/\n\/\/ \/\/ Identify the current activity\n\/\/ if (context instanceof FavoriteActivity) {\n\/\/ databaseHandler.removeFavorite(context, soundObject);\n\/\/ } else {\n\/\/ databaseHandler.addFavorite(soundObject);\n\/\/ }\n\/\/ }\nreturn true;\n}\n});\npopup.show();\n}","code_context_20":"public static void popupManager(final View view, final SoundObject soundObject){\n\/\/ Declare PopupMenu and assign it to the design created in longclick.xml\nPopupMenu popup = new PopupMenu(view.getContext(), view);\npopup.getMenuInflater().inflate(R.menu.longclick, popup.getMenu());\n\/\/ Handle user clicks on the popupmenu\npopup.setOnMenuItemClickListener(new PopupMenu.OnMenuItemClickListener() {\n@Override\npublic boolean onMenuItemClick(MenuItem item) {\n\/\/ Check if the user wants to share a sound or set a sound as system audio\nif (item.getItemId() == R.id.action_send || item.getItemId() == R.id.action_ringtone){\n\/\/ Define a filename on the given information from the SoundObject AND add the .mp3 tag to it\nfinal String fileName = soundObject.getItemName() + \".mp3\";\n\/\/ Get the path to the users external storage\nFile storage = Environment.getExternalStorageDirectory();\n\/\/ Define the directory path to the soundboard apps folder\n\/\/ Change my_soundboard to whatever you want as your folder but keep the slash\n\/\/ TODO: When changing the path be sure to also modify the path in filepaths.xml (res\/xml\/filepaths.xml)\nFile directory = new File(storage.getAbsolutePath() + \"\/my_soundboard\/\");\n\/\/ Creates the directory if it doesn't exist\n\/\/ mkdirs() gives back a boolean. You can use it to do some processes as well but we don't really need it.\ndirectory.mkdirs();\n\/\/ Finally define the file by giving over the directory and the filename\nfinal File file = new File(directory, fileName);\n\/\/ Define an InputStream that will read the data from your sound-raw.mp3 file into a buffer\nInputStream in = view.getContext().getResources().openRawResource(soundObject.getItemID());\ntry{\n\/\/ Log the name of the sound that is being saved\nLog.i(LOG_TAG, \"Saving sound \" + soundObject.getItemName());\n\/\/ Define an OutputStream\/FileOutputStream that will write the buffer data into the sound.mp3 on the external storage\nOutputStream out = new FileOutputStream(file);\n\/\/ Define a buffer of 1kb (you can make it a little bit bigger but 1kb will be adequate)\nbyte[] buffer = new byte[1024];\nint len;\n\/\/ Write the data to the sound.mp3 file while reading it from the sound-raw.mp3\n\/\/ if (int) InputStream.read() returns -1 stream is at the end of file\nwhile ((len = in.read(buffer, 0, buffer.length)) != -1){\nout.write(buffer, 0 , len);\n}\n\/\/ Close both streams\nin.close();\nout.close();\n} catch (IOException e){\n\/\/ Log error if process failed\nLog.e(LOG_TAG, \"Failed to save file: \" + e.getMessage());\n}\n\/\/ Send a sound via WhatsApp or the like\nif (item.getItemId() == R.id.action_send){\ntry{\n\/\/ Check if the users device Android version is 5.1 or higher\n\/\/ If it is you'll have to use FileProvider to get the sharing function to work properly\nif (Build.VERSION.SDK_INT >= Build.VERSION_CODES.LOLLIPOP_MR1){\nfinal String AUTHORITY = view.getContext().getPackageName() + \".fileprovider\";\nUri contentUri = FileProvider.getUriForFile(view.getContext(), AUTHORITY, file);\nfinal Intent shareIntent = new Intent(Intent.ACTION_SEND);\nfinal Intent intent = new Intent(Intent.ACTION_SEND);\nintent.putExtra(Intent.EXTRA_STREAM, contentUri);\n\/\/ Define the intent to be of type audio\/mp3\nintent.setType(\"audio\/mp3\");\n\/\/ Start a new chooser dialog where the user can choose an app to share the sound\nview.getContext().startActivity(Intent.createChooser(intent, \"Share sound via...\"));\n}\nelse {\nfinal Intent intent = new Intent(Intent.ACTION_SEND);\n\/\/ Uri refers to a name or location\n\/\/ .parse() analyzes a given uri string and creates a Uri from it\n\/\/ Define a \"link\" (Uri) to the saved file\nUri fileUri = Uri.parse(file.getAbsolutePath());\nintent.putExtra(Intent.EXTRA_STREAM, fileUri);\n\/\/ Define the intent to be of type audio\/mp3\nintent.setType(\"audio\/mp3\");\n\/\/ Start a new chooser dialog where the user can choose an app to share the sound\nview.getContext().startActivity(Intent.createChooser(intent, \"Share sound via...\"));\n}\n} catch (Exception e){\n\/\/ Log error if process failed\nLog.e(LOG_TAG, \"Failed to share sound: \" + e.getMessage());\n}\n}\n\/\/ Save as ringtone, alarm or notification\n\/\/ if (item.getItemId() == R.id.action_ringtone) {\n\/\/\n\/\/ \/\/ Create a little popup like dialog that gives the user the choice between the 3 types\n\/\/ \/\/ THEME_HOLO_LIGHT was deprecated in API 23 but to support older APIs you should use it\n\/\/ AlertDialog.Builder builder = new AlertDialog.Builder(view.getContext(), AlertDialog.THEME_HOLO_LIGHT);\n\/\/ builder.setTitle(\"Save as...\");\n\/\/ builder.setItems(new CharSequence[]{\"Ringtone\", \"Notification\", \"Alarm\"}, new DialogInterface.OnClickListener(){\n\/\/\n\/\/ @Override\n\/\/ public void onClick(DialogInterface dialog, int which){\n\/\/\n\/\/ \/\/ Decide on the users choice which information will be send to a method that handles the settings for all kinds of system audio\n\/\/\/\/ switch (which) {\n\/\/\/\/\n\/\/\/\/ \/\/ Ringtone\n\/\/\/\/ case 0:\n\/\/\/\/ changeSystemAudio(context, RingtoneManager.TYPE_RINGTONE, file);\n\/\/\/\/ break;\n\/\/\/\/ \/\/ Notification\n\/\/\/\/ case 1:\n\/\/\/\/ changeSystemAudio(context, RingtoneManager.TYPE_NOTIFICATION, file);\n\/\/\/\/ break;\n\/\/\/\/ \/\/ Alarmton\n\/\/\/\/ case 2:\n\/\/\/\/ changeSystemAudio(context, RingtoneManager.TYPE_ALARM, file);\n\/\/\/\/ break;\n\/\/\/\/ default:\n\/\/\/\/ }\n\/\/ }\n\/\/ });\n\/\/ builder.create();\n\/\/ builder.show();\n\/\/ }\n}\n\/\/ Add sound to favorites \/ Remove sound from favorites\n\/\/ if (item.getItemId() == R.id.action_favorite) {\n\/\/\n\/\/ DatabaseHandler databaseHandler = DatabaseHandler\n\/\/ .getInstance(context.getApplicationContext());\n\/\/\n\/\/ \/\/ Identify the current activity\n\/\/ if (context instanceof FavoriteActivity) {\n\/\/ databaseHandler.removeFavorite(context, soundObject);\n\/\/ } else {\n\/\/ databaseHandler.addFavorite(soundObject);\n\/\/ }\n\/\/ }\nreturn true;\n}\n});\npopup.show();\n}\n\npublic static void popupManager(final View view, final SoundObject soundObject){\n\/\/ Declare PopupMenu and assign it to the design created in longclick.xml\nPopupMenu popup = new PopupMenu(view.getContext(), view);\npopup.getMenuInflater().inflate(R.menu.longclick, popup.getMenu());\n\/\/ Handle user clicks on the popupmenu\npopup.setOnMenuItemClickListener(new PopupMenu.OnMenuItemClickListener() {\n@Override\npublic boolean onMenuItemClick(MenuItem item) {\n\/\/ Check if the user wants to share a sound or set a sound as system audio\nif (item.getItemId() == R.id.action_send || item.getItemId() == R.id.action_ringtone){\n\/\/ Define a filename on the given information from the SoundObject AND add the .mp3 tag to it\nfinal String fileName = soundObject.getItemName() + \".mp3\";\n\/\/ Get the path to the users external storage\nFile storage = Environment.getExternalStorageDirectory();\n\/\/ Define the directory path to the soundboard apps folder\n\/\/ Change my_soundboard to whatever you want as your folder but keep the slash\n\/\/ TODO: When changing the path be sure to also modify the path in filepaths.xml (res\/xml\/filepaths.xml)\nFile directory = new File(storage.getAbsolutePath() + \"\/my_soundboard\/\");\n\/\/ Creates the directory if it doesn't exist\n\/\/ mkdirs() gives back a boolean. You can use it to do some processes as well but we don't really need it.\ndirectory.mkdirs();\n\/\/ Finally define the file by giving over the directory and the filename\n\npublic static void popupManager(final View view, final SoundObject soundObject){\n\/\/ Declare PopupMenu and assign it to the design created in longclick.xml\nPopupMenu popup = new PopupMenu(view.getContext(), view);\npopup.getMenuInflater().inflate(R.menu.longclick, popup.getMenu());\n\/\/ Handle user clicks on the popupmenu\npopup.setOnMenuItemClickListener(new PopupMenu.OnMenuItemClickListener() {\n@Override\npublic boolean onMenuItemClick(MenuItem item) {\n\/\/ Check if the user wants to share a sound or set a sound as system audio\nif (item.getItemId() == R.id.action_send || item.getItemId() == R.id.action_ringtone){\n\/\/ Define a filename on the given information from the SoundObject AND add the .mp3 tag to it\nfinal String fileName = soundObject.getItemName() + \".mp3\";\n\/\/ Get the path to the users external storage\nFile storage = Environment.getExternalStorageDirectory();\n\/\/ Define the directory path to the soundboard apps folder\n\/\/ Change my_soundboard to whatever you want as your folder but keep the slash\n\/\/ TODO: When changing the path be sure to also modify the path in filepaths.xml (res\/xml\/filepaths.xml)\nFile directory = new File(storage.getAbsolutePath() + \"\/my_soundboard\/\");\n\/\/ Creates the directory if it doesn't exist\n\/\/ mkdirs() gives back a boolean. You can use it to do some processes as well but we don't really need it.\ndirectory.mkdirs();\n\/\/ Finally define the file by giving over the directory and the filename\nfinal File file = new File(directory, fileName);\n\/\/ Define an InputStream that will read the data from your sound-raw.mp3 file into a buffer\nInputStream in = view.getContext().getResources().openRawResource(soundObject.getItemID());\n\npublic static void popupManager(final View view, final SoundObject soundObject){\n\/\/ Declare PopupMenu and assign it to the design created in longclick.xml\nPopupMenu popup = new PopupMenu(view.getContext(), view);\npopup.getMenuInflater().inflate(R.menu.longclick, popup.getMenu());\n\/\/ Handle user clicks on the popupmenu\npopup.setOnMenuItemClickListener(new PopupMenu.OnMenuItemClickListener() {\n@Override\npublic boolean onMenuItemClick(MenuItem item) {\n\/\/ Check if the user wants to share a sound or set a sound as system audio\nif (item.getItemId() == R.id.action_send || item.getItemId() == R.id.action_ringtone){\n\/\/ Define a filename on the given information from the SoundObject AND add the .mp3 tag to it\nfinal String fileName = soundObject.getItemName() + \".mp3\";\n\/\/ Get the path to the users external storage\nFile storage = Environment.getExternalStorageDirectory();\n\/\/ Define the directory path to the soundboard apps folder\n\/\/ Change my_soundboard to whatever you want as your folder but keep the slash\n\/\/ TODO: When changing the path be sure to also modify the path in filepaths.xml (res\/xml\/filepaths.xml)\nFile directory = new File(storage.getAbsolutePath() + \"\/my_soundboard\/\");\n\/\/ Creates the directory if it doesn't exist\n\/\/ mkdirs() gives back a boolean. You can use it to do some processes as well but we don't really need it.\ndirectory.mkdirs();\n\/\/ Finally define the file by giving over the directory and the filename\nfinal File file = new File(directory, fileName);\n\/\/ Define an InputStream that will read the data from your sound-raw.mp3 file into a buffer\nInputStream in = view.getContext().getResources().openRawResource(soundObject.getItemID());\ntry{\n\/\/ Log the name of the sound that is being saved\nLog.i(LOG_TAG, \"Saving sound \" + soundObject.getItemName());\n\/\/ Define an OutputStream\/FileOutputStream that will write the buffer data into the sound.mp3 on the external storage\n\npublic static void popupManager(final View view, final SoundObject soundObject){\n\/\/ Declare PopupMenu and assign it to the design created in longclick.xml\nPopupMenu popup = new PopupMenu(view.getContext(), view);\npopup.getMenuInflater().inflate(R.menu.longclick, popup.getMenu());\n\/\/ Handle user clicks on the popupmenu\npopup.setOnMenuItemClickListener(new PopupMenu.OnMenuItemClickListener() {\n@Override\npublic boolean onMenuItemClick(MenuItem item) {\n\/\/ Check if the user wants to share a sound or set a sound as system audio\nif (item.getItemId() == R.id.action_send || item.getItemId() == R.id.action_ringtone){\n\/\/ Define a filename on the given information from the SoundObject AND add the .mp3 tag to it\nfinal String fileName = soundObject.getItemName() + \".mp3\";\n\/\/ Get the path to the users external storage\nFile storage = Environment.getExternalStorageDirectory();\n\/\/ Define the directory path to the soundboard apps folder\n\/\/ Change my_soundboard to whatever you want as your folder but keep the slash\n\/\/ TODO: When changing the path be sure to also modify the path in filepaths.xml (res\/xml\/filepaths.xml)\nFile directory = new File(storage.getAbsolutePath() + \"\/my_soundboard\/\");\n\/\/ Creates the directory if it doesn't exist\n\/\/ mkdirs() gives back a boolean. You can use it to do some processes as well but we don't really need it.\ndirectory.mkdirs();\n\/\/ Finally define the file by giving over the directory and the filename\nfinal File file = new File(directory, fileName);\n\/\/ Define an InputStream that will read the data from your sound-raw.mp3 file into a buffer\nInputStream in = view.getContext().getResources().openRawResource(soundObject.getItemID());\ntry{\n\/\/ Log the name of the sound that is being saved\nLog.i(LOG_TAG, \"Saving sound \" + soundObject.getItemName());\n\/\/ Define an OutputStream\/FileOutputStream that will write the buffer data into the sound.mp3 on the external storage\nOutputStream out = new FileOutputStream(file);\n\/\/ Define a buffer of 1kb (you can make it a little bit bigger but 1kb will be adequate)\n\npublic static void popupManager(final View view, final SoundObject soundObject){\n\/\/ Declare PopupMenu and assign it to the design created in longclick.xml\nPopupMenu popup = new PopupMenu(view.getContext(), view);\npopup.getMenuInflater().inflate(R.menu.longclick, popup.getMenu());\n\/\/ Handle user clicks on the popupmenu\npopup.setOnMenuItemClickListener(new PopupMenu.OnMenuItemClickListener() {\n@Override\npublic boolean onMenuItemClick(MenuItem item) {\n\/\/ Check if the user wants to share a sound or set a sound as system audio\nif (item.getItemId() == R.id.action_send || item.getItemId() == R.id.action_ringtone){\n\/\/ Define a filename on the given information from the SoundObject AND add the .mp3 tag to it\nfinal String fileName = soundObject.getItemName() + \".mp3\";\n\/\/ Get the path to the users external storage\nFile storage = Environment.getExternalStorageDirectory();\n\/\/ Define the directory path to the soundboard apps folder\n\/\/ Change my_soundboard to whatever you want as your folder but keep the slash\n\/\/ TODO: When changing the path be sure to also modify the path in filepaths.xml (res\/xml\/filepaths.xml)\nFile directory = new File(storage.getAbsolutePath() + \"\/my_soundboard\/\");\n\/\/ Creates the directory if it doesn't exist\n\/\/ mkdirs() gives back a boolean. You can use it to do some processes as well but we don't really need it.\ndirectory.mkdirs();\n\/\/ Finally define the file by giving over the directory and the filename\nfinal File file = new File(directory, fileName);\n\/\/ Define an InputStream that will read the data from your sound-raw.mp3 file into a buffer\nInputStream in = view.getContext().getResources().openRawResource(soundObject.getItemID());\ntry{\n\/\/ Log the name of the sound that is being saved\nLog.i(LOG_TAG, \"Saving sound \" + soundObject.getItemName());\n\/\/ Define an OutputStream\/FileOutputStream that will write the buffer data into the sound.mp3 on the external storage\nOutputStream out = new FileOutputStream(file);\n\/\/ Define a buffer of 1kb (you can make it a little bit bigger but 1kb will be adequate)\nbyte[] buffer = new byte[1024];\nint len;\n\npublic static void popupManager(final View view, final SoundObject soundObject){\n\/\/ Declare PopupMenu and assign it to the design created in longclick.xml\nPopupMenu popup = new PopupMenu(view.getContext(), view);\npopup.getMenuInflater().inflate(R.menu.longclick, popup.getMenu());\n\/\/ Handle user clicks on the popupmenu\npopup.setOnMenuItemClickListener(new PopupMenu.OnMenuItemClickListener() {\n@Override\npublic boolean onMenuItemClick(MenuItem item) {\n\/\/ Check if the user wants to share a sound or set a sound as system audio\nif (item.getItemId() == R.id.action_send || item.getItemId() == R.id.action_ringtone){\n\/\/ Define a filename on the given information from the SoundObject AND add the .mp3 tag to it\nfinal String fileName = soundObject.getItemName() + \".mp3\";\n\/\/ Get the path to the users external storage\nFile storage = Environment.getExternalStorageDirectory();\n\/\/ Define the directory path to the soundboard apps folder\n\/\/ Change my_soundboard to whatever you want as your folder but keep the slash\n\/\/ TODO: When changing the path be sure to also modify the path in filepaths.xml (res\/xml\/filepaths.xml)\nFile directory = new File(storage.getAbsolutePath() + \"\/my_soundboard\/\");\n\/\/ Creates the directory if it doesn't exist\n\/\/ mkdirs() gives back a boolean. You can use it to do some processes as well but we don't really need it.\ndirectory.mkdirs();\n\/\/ Finally define the file by giving over the directory and the filename\nfinal File file = new File(directory, fileName);\n\/\/ Define an InputStream that will read the data from your sound-raw.mp3 file into a buffer\nInputStream in = view.getContext().getResources().openRawResource(soundObject.getItemID());\ntry{\n\/\/ Log the name of the sound that is being saved\nLog.i(LOG_TAG, \"Saving sound \" + soundObject.getItemName());\n\/\/ Define an OutputStream\/FileOutputStream that will write the buffer data into the sound.mp3 on the external storage\nOutputStream out = new FileOutputStream(file);\n\/\/ Define a buffer of 1kb (you can make it a little bit bigger but 1kb will be adequate)\nbyte[] buffer = new byte[1024];\nint len;\n\/\/ Write the data to the sound.mp3 file while reading it from the sound-raw.mp3\n\/\/ if (int) InputStream.read() returns -1 stream is at the end of file\nwhile ((len = in.read(buffer, 0, buffer.length)) != -1){\nout.write(buffer, 0 , len);\n\npublic static void popupManager(final View view, final SoundObject soundObject){\n\/\/ Declare PopupMenu and assign it to the design created in longclick.xml\nPopupMenu popup = new PopupMenu(view.getContext(), view);\npopup.getMenuInflater().inflate(R.menu.longclick, popup.getMenu());\n\/\/ Handle user clicks on the popupmenu\npopup.setOnMenuItemClickListener(new PopupMenu.OnMenuItemClickListener() {\n@Override\npublic boolean onMenuItemClick(MenuItem item) {\n\/\/ Check if the user wants to share a sound or set a sound as system audio\nif (item.getItemId() == R.id.action_send || item.getItemId() == R.id.action_ringtone){\n\/\/ Define a filename on the given information from the SoundObject AND add the .mp3 tag to it\nfinal String fileName = soundObject.getItemName() + \".mp3\";\n\/\/ Get the path to the users external storage\nFile storage = Environment.getExternalStorageDirectory();\n\/\/ Define the directory path to the soundboard apps folder\n\/\/ Change my_soundboard to whatever you want as your folder but keep the slash\n\/\/ TODO: When changing the path be sure to also modify the path in filepaths.xml (res\/xml\/filepaths.xml)\nFile directory = new File(storage.getAbsolutePath() + \"\/my_soundboard\/\");\n\/\/ Creates the directory if it doesn't exist\n\/\/ mkdirs() gives back a boolean. You can use it to do some processes as well but we don't really need it.\ndirectory.mkdirs();\n\/\/ Finally define the file by giving over the directory and the filename\nfinal File file = new File(directory, fileName);\n\/\/ Define an InputStream that will read the data from your sound-raw.mp3 file into a buffer\nInputStream in = view.getContext().getResources().openRawResource(soundObject.getItemID());\ntry{\n\/\/ Log the name of the sound that is being saved\nLog.i(LOG_TAG, \"Saving sound \" + soundObject.getItemName());\n\/\/ Define an OutputStream\/FileOutputStream that will write the buffer data into the sound.mp3 on the external storage\nOutputStream out = new FileOutputStream(file);\n\/\/ Define a buffer of 1kb (you can make it a little bit bigger but 1kb will be adequate)\nbyte[] buffer = new byte[1024];\nint len;\n\/\/ Write the data to the sound.mp3 file while reading it from the sound-raw.mp3\n\/\/ if (int) InputStream.read() returns -1 stream is at the end of file\nwhile ((len = in.read(buffer, 0, buffer.length)) != -1){\nout.write(buffer, 0 , len);\n}\n\/\/ Close both streams\nin.close();\n\n\/\/ Declare PopupMenu and assign it to the design created in longclick.xml\nPopupMenu popup = new PopupMenu(view.getContext(), view);\npopup.getMenuInflater().inflate(R.menu.longclick, popup.getMenu());\n\/\/ Handle user clicks on the popupmenu\npopup.setOnMenuItemClickListener(new PopupMenu.OnMenuItemClickListener() {\n@Override\npublic boolean onMenuItemClick(MenuItem item) {\n\/\/ Check if the user wants to share a sound or set a sound as system audio\nif (item.getItemId() == R.id.action_send || item.getItemId() == R.id.action_ringtone){\n\/\/ Define a filename on the given information from the SoundObject AND add the .mp3 tag to it\nfinal String fileName = soundObject.getItemName() + \".mp3\";\n\/\/ Get the path to the users external storage\nFile storage = Environment.getExternalStorageDirectory();\n\/\/ Define the directory path to the soundboard apps folder\n\/\/ Change my_soundboard to whatever you want as your folder but keep the slash\n\/\/ TODO: When changing the path be sure to also modify the path in filepaths.xml (res\/xml\/filepaths.xml)\nFile directory = new File(storage.getAbsolutePath() + \"\/my_soundboard\/\");\n\/\/ Creates the directory if it doesn't exist\n\/\/ mkdirs() gives back a boolean. You can use it to do some processes as well but we don't really need it.\ndirectory.mkdirs();\n\/\/ Finally define the file by giving over the directory and the filename\nfinal File file = new File(directory, fileName);\n\/\/ Define an InputStream that will read the data from your sound-raw.mp3 file into a buffer\nInputStream in = view.getContext().getResources().openRawResource(soundObject.getItemID());\ntry{\n\/\/ Log the name of the sound that is being saved\nLog.i(LOG_TAG, \"Saving sound \" + soundObject.getItemName());\n\/\/ Define an OutputStream\/FileOutputStream that will write the buffer data into the sound.mp3 on the external storage\nOutputStream out = new FileOutputStream(file);\n\/\/ Define a buffer of 1kb (you can make it a little bit bigger but 1kb will be adequate)\nbyte[] buffer = new byte[1024];\nint len;\n\/\/ Write the data to the sound.mp3 file while reading it from the sound-raw.mp3\n\/\/ if (int) InputStream.read() returns -1 stream is at the end of file\nwhile ((len = in.read(buffer, 0, buffer.length)) != -1){\nout.write(buffer, 0 , len);\n}\n\/\/ Close both streams\nin.close();\nout.close();\n} catch (IOException e){\n\npopup.getMenuInflater().inflate(R.menu.longclick, popup.getMenu());\n\/\/ Handle user clicks on the popupmenu\npopup.setOnMenuItemClickListener(new PopupMenu.OnMenuItemClickListener() {\n@Override\npublic boolean onMenuItemClick(MenuItem item) {\n\/\/ Check if the user wants to share a sound or set a sound as system audio\nif (item.getItemId() == R.id.action_send || item.getItemId() == R.id.action_ringtone){\n\/\/ Define a filename on the given information from the SoundObject AND add the .mp3 tag to it\nfinal String fileName = soundObject.getItemName() + \".mp3\";\n\/\/ Get the path to the users external storage\nFile storage = Environment.getExternalStorageDirectory();\n\/\/ Define the directory path to the soundboard apps folder\n\/\/ Change my_soundboard to whatever you want as your folder but keep the slash\n\/\/ TODO: When changing the path be sure to also modify the path in filepaths.xml (res\/xml\/filepaths.xml)\nFile directory = new File(storage.getAbsolutePath() + \"\/my_soundboard\/\");\n\/\/ Creates the directory if it doesn't exist\n\/\/ mkdirs() gives back a boolean. You can use it to do some processes as well but we don't really need it.\ndirectory.mkdirs();\n\/\/ Finally define the file by giving over the directory and the filename\nfinal File file = new File(directory, fileName);\n\/\/ Define an InputStream that will read the data from your sound-raw.mp3 file into a buffer\nInputStream in = view.getContext().getResources().openRawResource(soundObject.getItemID());\ntry{\n\/\/ Log the name of the sound that is being saved\nLog.i(LOG_TAG, \"Saving sound \" + soundObject.getItemName());\n\/\/ Define an OutputStream\/FileOutputStream that will write the buffer data into the sound.mp3 on the external storage\nOutputStream out = new FileOutputStream(file);\n\/\/ Define a buffer of 1kb (you can make it a little bit bigger but 1kb will be adequate)\nbyte[] buffer = new byte[1024];\nint len;\n\/\/ Write the data to the sound.mp3 file while reading it from the sound-raw.mp3\n\/\/ if (int) InputStream.read() returns -1 stream is at the end of file\nwhile ((len = in.read(buffer, 0, buffer.length)) != -1){\nout.write(buffer, 0 , len);\n}\n\/\/ Close both streams\nin.close();\nout.close();\n} catch (IOException e){\n\/\/ Log error if process failed\nLog.e(LOG_TAG, \"Failed to save file: \" + e.getMessage());\n\n@Override\npublic boolean onMenuItemClick(MenuItem item) {\n\/\/ Check if the user wants to share a sound or set a sound as system audio\nif (item.getItemId() == R.id.action_send || item.getItemId() == R.id.action_ringtone){\n\/\/ Define a filename on the given information from the SoundObject AND add the .mp3 tag to it\nfinal String fileName = soundObject.getItemName() + \".mp3\";\n\/\/ Get the path to the users external storage\nFile storage = Environment.getExternalStorageDirectory();\n\/\/ Define the directory path to the soundboard apps folder\n\/\/ Change my_soundboard to whatever you want as your folder but keep the slash\n\/\/ TODO: When changing the path be sure to also modify the path in filepaths.xml (res\/xml\/filepaths.xml)\nFile directory = new File(storage.getAbsolutePath() + \"\/my_soundboard\/\");\n\/\/ Creates the directory if it doesn't exist\n\/\/ mkdirs() gives back a boolean. You can use it to do some processes as well but we don't really need it.\ndirectory.mkdirs();\n\/\/ Finally define the file by giving over the directory and the filename\nfinal File file = new File(directory, fileName);\n\/\/ Define an InputStream that will read the data from your sound-raw.mp3 file into a buffer\nInputStream in = view.getContext().getResources().openRawResource(soundObject.getItemID());\ntry{\n\/\/ Log the name of the sound that is being saved\nLog.i(LOG_TAG, \"Saving sound \" + soundObject.getItemName());\n\/\/ Define an OutputStream\/FileOutputStream that will write the buffer data into the sound.mp3 on the external storage\nOutputStream out = new FileOutputStream(file);\n\/\/ Define a buffer of 1kb (you can make it a little bit bigger but 1kb will be adequate)\nbyte[] buffer = new byte[1024];\nint len;\n\/\/ Write the data to the sound.mp3 file while reading it from the sound-raw.mp3\n\/\/ if (int) InputStream.read() returns -1 stream is at the end of file\nwhile ((len = in.read(buffer, 0, buffer.length)) != -1){\nout.write(buffer, 0 , len);\n}\n\/\/ Close both streams\nin.close();\nout.close();\n} catch (IOException e){\n\/\/ Log error if process failed\nLog.e(LOG_TAG, \"Failed to save file: \" + e.getMessage());\n}\n\/\/ Send a sound via WhatsApp or the like\nif (item.getItemId() == R.id.action_send){\n\n\/\/ Check if the user wants to share a sound or set a sound as system audio\nif (item.getItemId() == R.id.action_send || item.getItemId() == R.id.action_ringtone){\n\/\/ Define a filename on the given information from the SoundObject AND add the .mp3 tag to it\nfinal String fileName = soundObject.getItemName() + \".mp3\";\n\/\/ Get the path to the users external storage\nFile storage = Environment.getExternalStorageDirectory();\n\/\/ Define the directory path to the soundboard apps folder\n\/\/ Change my_soundboard to whatever you want as your folder but keep the slash\n\/\/ TODO: When changing the path be sure to also modify the path in filepaths.xml (res\/xml\/filepaths.xml)\nFile directory = new File(storage.getAbsolutePath() + \"\/my_soundboard\/\");\n\/\/ Creates the directory if it doesn't exist\n\/\/ mkdirs() gives back a boolean. You can use it to do some processes as well but we don't really need it.\ndirectory.mkdirs();\n\/\/ Finally define the file by giving over the directory and the filename\nfinal File file = new File(directory, fileName);\n\/\/ Define an InputStream that will read the data from your sound-raw.mp3 file into a buffer\nInputStream in = view.getContext().getResources().openRawResource(soundObject.getItemID());\ntry{\n\/\/ Log the name of the sound that is being saved\nLog.i(LOG_TAG, \"Saving sound \" + soundObject.getItemName());\n\/\/ Define an OutputStream\/FileOutputStream that will write the buffer data into the sound.mp3 on the external storage\nOutputStream out = new FileOutputStream(file);\n\/\/ Define a buffer of 1kb (you can make it a little bit bigger but 1kb will be adequate)\nbyte[] buffer = new byte[1024];\nint len;\n\/\/ Write the data to the sound.mp3 file while reading it from the sound-raw.mp3\n\/\/ if (int) InputStream.read() returns -1 stream is at the end of file\nwhile ((len = in.read(buffer, 0, buffer.length)) != -1){\nout.write(buffer, 0 , len);\n}\n\/\/ Close both streams\nin.close();\nout.close();\n} catch (IOException e){\n\/\/ Log error if process failed\nLog.e(LOG_TAG, \"Failed to save file: \" + e.getMessage());\n}\n\/\/ Send a sound via WhatsApp or the like\nif (item.getItemId() == R.id.action_send){\ntry{\n\/\/ Check if the users device Android version is 5.1 or higher\n\n\/\/ Define a filename on the given information from the SoundObject AND add the .mp3 tag to it\nfinal String fileName = soundObject.getItemName() + \".mp3\";\n\/\/ Get the path to the users external storage\nFile storage = Environment.getExternalStorageDirectory();\n\/\/ Define the directory path to the soundboard apps folder\n\/\/ Change my_soundboard to whatever you want as your folder but keep the slash\n\/\/ TODO: When changing the path be sure to also modify the path in filepaths.xml (res\/xml\/filepaths.xml)\nFile directory = new File(storage.getAbsolutePath() + \"\/my_soundboard\/\");\n\/\/ Creates the directory if it doesn't exist\n\/\/ mkdirs() gives back a boolean. You can use it to do some processes as well but we don't really need it.\ndirectory.mkdirs();\n\/\/ Finally define the file by giving over the directory and the filename\nfinal File file = new File(directory, fileName);\n\/\/ Define an InputStream that will read the data from your sound-raw.mp3 file into a buffer\nInputStream in = view.getContext().getResources().openRawResource(soundObject.getItemID());\ntry{\n\/\/ Log the name of the sound that is being saved\nLog.i(LOG_TAG, \"Saving sound \" + soundObject.getItemName());\n\/\/ Define an OutputStream\/FileOutputStream that will write the buffer data into the sound.mp3 on the external storage\nOutputStream out = new FileOutputStream(file);\n\/\/ Define a buffer of 1kb (you can make it a little bit bigger but 1kb will be adequate)\nbyte[] buffer = new byte[1024];\nint len;\n\/\/ Write the data to the sound.mp3 file while reading it from the sound-raw.mp3\n\/\/ if (int) InputStream.read() returns -1 stream is at the end of file\nwhile ((len = in.read(buffer, 0, buffer.length)) != -1){\nout.write(buffer, 0 , len);\n}\n\/\/ Close both streams\nin.close();\nout.close();\n} catch (IOException e){\n\/\/ Log error if process failed\nLog.e(LOG_TAG, \"Failed to save file: \" + e.getMessage());\n}\n\/\/ Send a sound via WhatsApp or the like\nif (item.getItemId() == R.id.action_send){\ntry{\n\/\/ Check if the users device Android version is 5.1 or higher\n\/\/ If it is you'll have to use FileProvider to get the sharing function to work properly\nif (Build.VERSION.SDK_INT >= Build.VERSION_CODES.LOLLIPOP_MR1){\n\nFile storage = Environment.getExternalStorageDirectory();\n\/\/ Define the directory path to the soundboard apps folder\n\/\/ Change my_soundboard to whatever you want as your folder but keep the slash\n\/\/ TODO: When changing the path be sure to also modify the path in filepaths.xml (res\/xml\/filepaths.xml)\nFile directory = new File(storage.getAbsolutePath() + \"\/my_soundboard\/\");\n\/\/ Creates the directory if it doesn't exist\n\/\/ mkdirs() gives back a boolean. You can use it to do some processes as well but we don't really need it.\ndirectory.mkdirs();\n\/\/ Finally define the file by giving over the directory and the filename\nfinal File file = new File(directory, fileName);\n\/\/ Define an InputStream that will read the data from your sound-raw.mp3 file into a buffer\nInputStream in = view.getContext().getResources().openRawResource(soundObject.getItemID());\ntry{\n\/\/ Log the name of the sound that is being saved\nLog.i(LOG_TAG, \"Saving sound \" + soundObject.getItemName());\n\/\/ Define an OutputStream\/FileOutputStream that will write the buffer data into the sound.mp3 on the external storage\nOutputStream out = new FileOutputStream(file);\n\/\/ Define a buffer of 1kb (you can make it a little bit bigger but 1kb will be adequate)\nbyte[] buffer = new byte[1024];\nint len;\n\/\/ Write the data to the sound.mp3 file while reading it from the sound-raw.mp3\n\/\/ if (int) InputStream.read() returns -1 stream is at the end of file\nwhile ((len = in.read(buffer, 0, buffer.length)) != -1){\nout.write(buffer, 0 , len);\n}\n\/\/ Close both streams\nin.close();\nout.close();\n} catch (IOException e){\n\/\/ Log error if process failed\nLog.e(LOG_TAG, \"Failed to save file: \" + e.getMessage());\n}\n\/\/ Send a sound via WhatsApp or the like\nif (item.getItemId() == R.id.action_send){\ntry{\n\/\/ Check if the users device Android version is 5.1 or higher\n\/\/ If it is you'll have to use FileProvider to get the sharing function to work properly\nif (Build.VERSION.SDK_INT >= Build.VERSION_CODES.LOLLIPOP_MR1){\nfinal String AUTHORITY = view.getContext().getPackageName() + \".fileprovider\";\nUri contentUri = FileProvider.getUriForFile(view.getContext(), AUTHORITY, file);\nfinal Intent shareIntent = new Intent(Intent.ACTION_SEND);\nfinal Intent intent = new Intent(Intent.ACTION_SEND);\n\n\/\/ Creates the directory if it doesn't exist\n\/\/ mkdirs() gives back a boolean. You can use it to do some processes as well but we don't really need it.\ndirectory.mkdirs();\n\/\/ Finally define the file by giving over the directory and the filename\nfinal File file = new File(directory, fileName);\n\/\/ Define an InputStream that will read the data from your sound-raw.mp3 file into a buffer\nInputStream in = view.getContext().getResources().openRawResource(soundObject.getItemID());\ntry{\n\/\/ Log the name of the sound that is being saved\nLog.i(LOG_TAG, \"Saving sound \" + soundObject.getItemName());\n\/\/ Define an OutputStream\/FileOutputStream that will write the buffer data into the sound.mp3 on the external storage\nOutputStream out = new FileOutputStream(file);\n\/\/ Define a buffer of 1kb (you can make it a little bit bigger but 1kb will be adequate)\nbyte[] buffer = new byte[1024];\nint len;\n\/\/ Write the data to the sound.mp3 file while reading it from the sound-raw.mp3\n\/\/ if (int) InputStream.read() returns -1 stream is at the end of file\nwhile ((len = in.read(buffer, 0, buffer.length)) != -1){\nout.write(buffer, 0 , len);\n}\n\/\/ Close both streams\nin.close();\nout.close();\n} catch (IOException e){\n\/\/ Log error if process failed\nLog.e(LOG_TAG, \"Failed to save file: \" + e.getMessage());\n}\n\/\/ Send a sound via WhatsApp or the like\nif (item.getItemId() == R.id.action_send){\ntry{\n\/\/ Check if the users device Android version is 5.1 or higher\n\/\/ If it is you'll have to use FileProvider to get the sharing function to work properly\nif (Build.VERSION.SDK_INT >= Build.VERSION_CODES.LOLLIPOP_MR1){\nfinal String AUTHORITY = view.getContext().getPackageName() + \".fileprovider\";\nUri contentUri = FileProvider.getUriForFile(view.getContext(), AUTHORITY, file);\nfinal Intent shareIntent = new Intent(Intent.ACTION_SEND);\nfinal Intent intent = new Intent(Intent.ACTION_SEND);\nintent.putExtra(Intent.EXTRA_STREAM, contentUri);\n\/\/ Define the intent to be of type audio\/mp3\nintent.setType(\"audio\/mp3\");\n\/\/ Start a new chooser dialog where the user can choose an app to share the sound\n\nfinal File file = new File(directory, fileName);\n\/\/ Define an InputStream that will read the data from your sound-raw.mp3 file into a buffer\nInputStream in = view.getContext().getResources().openRawResource(soundObject.getItemID());\ntry{\n\/\/ Log the name of the sound that is being saved\nLog.i(LOG_TAG, \"Saving sound \" + soundObject.getItemName());\n\/\/ Define an OutputStream\/FileOutputStream that will write the buffer data into the sound.mp3 on the external storage\nOutputStream out = new FileOutputStream(file);\n\/\/ Define a buffer of 1kb (you can make it a little bit bigger but 1kb will be adequate)\nbyte[] buffer = new byte[1024];\nint len;\n\/\/ Write the data to the sound.mp3 file while reading it from the sound-raw.mp3\n\/\/ if (int) InputStream.read() returns -1 stream is at the end of file\nwhile ((len = in.read(buffer, 0, buffer.length)) != -1){\nout.write(buffer, 0 , len);\n}\n\/\/ Close both streams\nin.close();\nout.close();\n} catch (IOException e){\n\/\/ Log error if process failed\nLog.e(LOG_TAG, \"Failed to save file: \" + e.getMessage());\n}\n\/\/ Send a sound via WhatsApp or the like\nif (item.getItemId() == R.id.action_send){\ntry{\n\/\/ Check if the users device Android version is 5.1 or higher\n\/\/ If it is you'll have to use FileProvider to get the sharing function to work properly\nif (Build.VERSION.SDK_INT >= Build.VERSION_CODES.LOLLIPOP_MR1){\nfinal String AUTHORITY = view.getContext().getPackageName() + \".fileprovider\";\nUri contentUri = FileProvider.getUriForFile(view.getContext(), AUTHORITY, file);\nfinal Intent shareIntent = new Intent(Intent.ACTION_SEND);\nfinal Intent intent = new Intent(Intent.ACTION_SEND);\nintent.putExtra(Intent.EXTRA_STREAM, contentUri);\n\/\/ Define the intent to be of type audio\/mp3\nintent.setType(\"audio\/mp3\");\n\/\/ Start a new chooser dialog where the user can choose an app to share the sound\nview.getContext().startActivity(Intent.createChooser(intent, \"Share sound via...\"));\n}\nelse {\nfinal Intent intent = new Intent(Intent.ACTION_SEND);\n\ntry{\n\/\/ Log the name of the sound that is being saved\nLog.i(LOG_TAG, \"Saving sound \" + soundObject.getItemName());\n\/\/ Define an OutputStream\/FileOutputStream that will write the buffer data into the sound.mp3 on the external storage\nOutputStream out = new FileOutputStream(file);\n\/\/ Define a buffer of 1kb (you can make it a little bit bigger but 1kb will be adequate)\nbyte[] buffer = new byte[1024];\nint len;\n\/\/ Write the data to the sound.mp3 file while reading it from the sound-raw.mp3\n\/\/ if (int) InputStream.read() returns -1 stream is at the end of file\nwhile ((len = in.read(buffer, 0, buffer.length)) != -1){\nout.write(buffer, 0 , len);\n}\n\/\/ Close both streams\nin.close();\nout.close();\n} catch (IOException e){\n\/\/ Log error if process failed\nLog.e(LOG_TAG, \"Failed to save file: \" + e.getMessage());\n}\n\/\/ Send a sound via WhatsApp or the like\nif (item.getItemId() == R.id.action_send){\ntry{\n\/\/ Check if the users device Android version is 5.1 or higher\n\/\/ If it is you'll have to use FileProvider to get the sharing function to work properly\nif (Build.VERSION.SDK_INT >= Build.VERSION_CODES.LOLLIPOP_MR1){\nfinal String AUTHORITY = view.getContext().getPackageName() + \".fileprovider\";\nUri contentUri = FileProvider.getUriForFile(view.getContext(), AUTHORITY, file);\nfinal Intent shareIntent = new Intent(Intent.ACTION_SEND);\nfinal Intent intent = new Intent(Intent.ACTION_SEND);\nintent.putExtra(Intent.EXTRA_STREAM, contentUri);\n\/\/ Define the intent to be of type audio\/mp3\nintent.setType(\"audio\/mp3\");\n\/\/ Start a new chooser dialog where the user can choose an app to share the sound\nview.getContext().startActivity(Intent.createChooser(intent, \"Share sound via...\"));\n}\nelse {\nfinal Intent intent = new Intent(Intent.ACTION_SEND);\n\/\/ Uri refers to a name or location\n\/\/ .parse() analyzes a given uri string and creates a Uri from it\n\/\/ Define a \"link\" (Uri) to the saved file\n\n\/\/ Define an OutputStream\/FileOutputStream that will write the buffer data into the sound.mp3 on the external storage\nOutputStream out = new FileOutputStream(file);\n\/\/ Define a buffer of 1kb (you can make it a little bit bigger but 1kb will be adequate)\nbyte[] buffer = new byte[1024];\nint len;\n\/\/ Write the data to the sound.mp3 file while reading it from the sound-raw.mp3\n\/\/ if (int) InputStream.read() returns -1 stream is at the end of file\nwhile ((len = in.read(buffer, 0, buffer.length)) != -1){\nout.write(buffer, 0 , len);\n}\n\/\/ Close both streams\nin.close();\nout.close();\n} catch (IOException e){\n\/\/ Log error if process failed\nLog.e(LOG_TAG, \"Failed to save file: \" + e.getMessage());\n}\n\/\/ Send a sound via WhatsApp or the like\nif (item.getItemId() == R.id.action_send){\ntry{\n\/\/ Check if the users device Android version is 5.1 or higher\n\/\/ If it is you'll have to use FileProvider to get the sharing function to work properly\nif (Build.VERSION.SDK_INT >= Build.VERSION_CODES.LOLLIPOP_MR1){\nfinal String AUTHORITY = view.getContext().getPackageName() + \".fileprovider\";\nUri contentUri = FileProvider.getUriForFile(view.getContext(), AUTHORITY, file);\nfinal Intent shareIntent = new Intent(Intent.ACTION_SEND);\nfinal Intent intent = new Intent(Intent.ACTION_SEND);\nintent.putExtra(Intent.EXTRA_STREAM, contentUri);\n\/\/ Define the intent to be of type audio\/mp3\nintent.setType(\"audio\/mp3\");\n\/\/ Start a new chooser dialog where the user can choose an app to share the sound\nview.getContext().startActivity(Intent.createChooser(intent, \"Share sound via...\"));\n}\nelse {\nfinal Intent intent = new Intent(Intent.ACTION_SEND);\n\/\/ Uri refers to a name or location\n\/\/ .parse() analyzes a given uri string and creates a Uri from it\n\/\/ Define a \"link\" (Uri) to the saved file\nUri fileUri = Uri.parse(file.getAbsolutePath());\nintent.putExtra(Intent.EXTRA_STREAM, fileUri);\n\/\/ Define the intent to be of type audio\/mp3\nintent.setType(\"audio\/mp3\");\n\nout.write(buffer, 0 , len);\n}\n\/\/ Close both streams\nin.close();\nout.close();\n} catch (IOException e){\n\/\/ Log error if process failed\nLog.e(LOG_TAG, \"Failed to save file: \" + e.getMessage());\n}\n\/\/ Send a sound via WhatsApp or the like\nif (item.getItemId() == R.id.action_send){\ntry{\n\/\/ Check if the users device Android version is 5.1 or higher\n\/\/ If it is you'll have to use FileProvider to get the sharing function to work properly\nif (Build.VERSION.SDK_INT >= Build.VERSION_CODES.LOLLIPOP_MR1){\nfinal String AUTHORITY = view.getContext().getPackageName() + \".fileprovider\";\nUri contentUri = FileProvider.getUriForFile(view.getContext(), AUTHORITY, file);\nfinal Intent shareIntent = new Intent(Intent.ACTION_SEND);\nfinal Intent intent = new Intent(Intent.ACTION_SEND);\nintent.putExtra(Intent.EXTRA_STREAM, contentUri);\n\/\/ Define the intent to be of type audio\/mp3\nintent.setType(\"audio\/mp3\");\n\/\/ Start a new chooser dialog where the user can choose an app to share the sound\nview.getContext().startActivity(Intent.createChooser(intent, \"Share sound via...\"));\n}\nelse {\nfinal Intent intent = new Intent(Intent.ACTION_SEND);\n\/\/ Uri refers to a name or location\n\/\/ .parse() analyzes a given uri string and creates a Uri from it\n\/\/ Define a \"link\" (Uri) to the saved file\nUri fileUri = Uri.parse(file.getAbsolutePath());\nintent.putExtra(Intent.EXTRA_STREAM, fileUri);\n\/\/ Define the intent to be of type audio\/mp3\nintent.setType(\"audio\/mp3\");\n\/\/ Start a new chooser dialog where the user can choose an app to share the sound\nview.getContext().startActivity(Intent.createChooser(intent, \"Share sound via...\"));\n}\n} catch (Exception e){\n\/\/ Log error if process failed\nLog.e(LOG_TAG, \"Failed to share sound: \" + e.getMessage());\n}\n\n\/\/ Close both streams\nin.close();\nout.close();\n} catch (IOException e){\n\/\/ Log error if process failed\nLog.e(LOG_TAG, \"Failed to save file: \" + e.getMessage());\n}\n\/\/ Send a sound via WhatsApp or the like\nif (item.getItemId() == R.id.action_send){\ntry{\n\/\/ Check if the users device Android version is 5.1 or higher\n\/\/ If it is you'll have to use FileProvider to get the sharing function to work properly\nif (Build.VERSION.SDK_INT >= Build.VERSION_CODES.LOLLIPOP_MR1){\nfinal String AUTHORITY = view.getContext().getPackageName() + \".fileprovider\";\nUri contentUri = FileProvider.getUriForFile(view.getContext(), AUTHORITY, file);\nfinal Intent shareIntent = new Intent(Intent.ACTION_SEND);\nfinal Intent intent = new Intent(Intent.ACTION_SEND);\nintent.putExtra(Intent.EXTRA_STREAM, contentUri);\n\/\/ Define the intent to be of type audio\/mp3\nintent.setType(\"audio\/mp3\");\n\/\/ Start a new chooser dialog where the user can choose an app to share the sound\nview.getContext().startActivity(Intent.createChooser(intent, \"Share sound via...\"));\n}\nelse {\nfinal Intent intent = new Intent(Intent.ACTION_SEND);\n\/\/ Uri refers to a name or location\n\/\/ .parse() analyzes a given uri string and creates a Uri from it\n\/\/ Define a \"link\" (Uri) to the saved file\nUri fileUri = Uri.parse(file.getAbsolutePath());\nintent.putExtra(Intent.EXTRA_STREAM, fileUri);\n\/\/ Define the intent to be of type audio\/mp3\nintent.setType(\"audio\/mp3\");\n\/\/ Start a new chooser dialog where the user can choose an app to share the sound\nview.getContext().startActivity(Intent.createChooser(intent, \"Share sound via...\"));\n}\n} catch (Exception e){\n\/\/ Log error if process failed\nLog.e(LOG_TAG, \"Failed to share sound: \" + e.getMessage());\n}\n}\n\/\/ Save as ringtone, alarm or notification\n\nLog.e(LOG_TAG, \"Failed to save file: \" + e.getMessage());\n}\n\/\/ Send a sound via WhatsApp or the like\nif (item.getItemId() == R.id.action_send){\ntry{\n\/\/ Check if the users device Android version is 5.1 or higher\n\/\/ If it is you'll have to use FileProvider to get the sharing function to work properly\nif (Build.VERSION.SDK_INT >= Build.VERSION_CODES.LOLLIPOP_MR1){\nfinal String AUTHORITY = view.getContext().getPackageName() + \".fileprovider\";\nUri contentUri = FileProvider.getUriForFile(view.getContext(), AUTHORITY, file);\nfinal Intent shareIntent = new Intent(Intent.ACTION_SEND);\nfinal Intent intent = new Intent(Intent.ACTION_SEND);\nintent.putExtra(Intent.EXTRA_STREAM, contentUri);\n\/\/ Define the intent to be of type audio\/mp3\nintent.setType(\"audio\/mp3\");\n\/\/ Start a new chooser dialog where the user can choose an app to share the sound\nview.getContext().startActivity(Intent.createChooser(intent, \"Share sound via...\"));\n}\nelse {\nfinal Intent intent = new Intent(Intent.ACTION_SEND);\n\/\/ Uri refers to a name or location\n\/\/ .parse() analyzes a given uri string and creates a Uri from it\n\/\/ Define a \"link\" (Uri) to the saved file\nUri fileUri = Uri.parse(file.getAbsolutePath());\nintent.putExtra(Intent.EXTRA_STREAM, fileUri);\n\/\/ Define the intent to be of type audio\/mp3\nintent.setType(\"audio\/mp3\");\n\/\/ Start a new chooser dialog where the user can choose an app to share the sound\nview.getContext().startActivity(Intent.createChooser(intent, \"Share sound via...\"));\n}\n} catch (Exception e){\n\/\/ Log error if process failed\nLog.e(LOG_TAG, \"Failed to share sound: \" + e.getMessage());\n}\n}\n\/\/ Save as ringtone, alarm or notification\n\/\/ if (item.getItemId() == R.id.action_ringtone) {\n\/\/\n\/\/ \/\/ Create a little popup like dialog that gives the user the choice between the 3 types\n\/\/ \/\/ THEME_HOLO_LIGHT was deprecated in API 23 but to support older APIs you should use it\n\/\/ AlertDialog.Builder builder = new AlertDialog.Builder(view.getContext(), AlertDialog.THEME_HOLO_LIGHT);\n\/\/ builder.setTitle(\"Save as...\");\n\/\/ builder.setItems(new CharSequence[]{\"Ringtone\", \"Notification\", \"Alarm\"}, new DialogInterface.OnClickListener(){\n\nout.write(buffer, 0 , len);\n}\n\/\/ Close both streams\nin.close();\nout.close();\n} catch (IOException e){\n\/\/ Log error if process failed\nLog.e(LOG_TAG, \"Failed to save file: \" + e.getMessage());\n}\n\/\/ Send a sound via WhatsApp or the like\nif (item.getItemId() == R.id.action_send){\ntry{\n\/\/ Check if the users device Android version is 5.1 or higher\n\/\/ If it is you'll have to use FileProvider to get the sharing function to work properly\nif (Build.VERSION.SDK_INT >= Build.VERSION_CODES.LOLLIPOP_MR1){\nfinal String AUTHORITY = view.getContext().getPackageName() + \".fileprovider\";\nUri contentUri = FileProvider.getUriForFile(view.getContext(), AUTHORITY, file);\nfinal Intent shareIntent = new Intent(Intent.ACTION_SEND);\nfinal Intent intent = new Intent(Intent.ACTION_SEND);\nintent.putExtra(Intent.EXTRA_STREAM, contentUri);\n\/\/ Define the intent to be of type audio\/mp3\nintent.setType(\"audio\/mp3\");\n\/\/ Start a new chooser dialog where the user can choose an app to share the sound\nview.getContext().startActivity(Intent.createChooser(intent, \"Share sound via...\"));\n}\nelse {\nfinal Intent intent = new Intent(Intent.ACTION_SEND);\n\/\/ Uri refers to a name or location\n\/\/ .parse() analyzes a given uri string and creates a Uri from it\n\/\/ Define a \"link\" (Uri) to the saved file\nUri fileUri = Uri.parse(file.getAbsolutePath());\nintent.putExtra(Intent.EXTRA_STREAM, fileUri);\n\/\/ Define the intent to be of type audio\/mp3\nintent.setType(\"audio\/mp3\");\n\/\/ Start a new chooser dialog where the user can choose an app to share the sound\nview.getContext().startActivity(Intent.createChooser(intent, \"Share sound via...\"));\n}\n} catch (Exception e){\n\/\/ Log error if process failed\nLog.e(LOG_TAG, \"Failed to share sound: \" + e.getMessage());\n}\n\n\/\/ Close both streams\nin.close();\nout.close();\n} catch (IOException e){\n\/\/ Log error if process failed\nLog.e(LOG_TAG, \"Failed to save file: \" + e.getMessage());\n}\n\/\/ Send a sound via WhatsApp or the like\nif (item.getItemId() == R.id.action_send){\ntry{\n\/\/ Check if the users device Android version is 5.1 or higher\n\/\/ If it is you'll have to use FileProvider to get the sharing function to work properly\nif (Build.VERSION.SDK_INT >= Build.VERSION_CODES.LOLLIPOP_MR1){\nfinal String AUTHORITY = view.getContext().getPackageName() + \".fileprovider\";\nUri contentUri = FileProvider.getUriForFile(view.getContext(), AUTHORITY, file);\nfinal Intent shareIntent = new Intent(Intent.ACTION_SEND);\nfinal Intent intent = new Intent(Intent.ACTION_SEND);\nintent.putExtra(Intent.EXTRA_STREAM, contentUri);\n\/\/ Define the intent to be of type audio\/mp3\nintent.setType(\"audio\/mp3\");\n\/\/ Start a new chooser dialog where the user can choose an app to share the sound\nview.getContext().startActivity(Intent.createChooser(intent, \"Share sound via...\"));\n}\nelse {\nfinal Intent intent = new Intent(Intent.ACTION_SEND);\n\/\/ Uri refers to a name or location\n\/\/ .parse() analyzes a given uri string and creates a Uri from it\n\/\/ Define a \"link\" (Uri) to the saved file\nUri fileUri = Uri.parse(file.getAbsolutePath());\nintent.putExtra(Intent.EXTRA_STREAM, fileUri);\n\/\/ Define the intent to be of type audio\/mp3\nintent.setType(\"audio\/mp3\");\n\/\/ Start a new chooser dialog where the user can choose an app to share the sound\nview.getContext().startActivity(Intent.createChooser(intent, \"Share sound via...\"));\n}\n} catch (Exception e){\n\/\/ Log error if process failed\nLog.e(LOG_TAG, \"Failed to share sound: \" + e.getMessage());\n}\n}\n\/\/ Save as ringtone, alarm or notification\n\nfinal File file = new File(directory, fileName);\n\/\/ Define an InputStream that will read the data from your sound-raw.mp3 file into a buffer\nInputStream in = view.getContext().getResources().openRawResource(soundObject.getItemID());\ntry{\n\/\/ Log the name of the sound that is being saved\nLog.i(LOG_TAG, \"Saving sound \" + soundObject.getItemName());\n\/\/ Define an OutputStream\/FileOutputStream that will write the buffer data into the sound.mp3 on the external storage\nOutputStream out = new FileOutputStream(file);\n\/\/ Define a buffer of 1kb (you can make it a little bit bigger but 1kb will be adequate)\nbyte[] buffer = new byte[1024];\nint len;\n\/\/ Write the data to the sound.mp3 file while reading it from the sound-raw.mp3\n\/\/ if (int) InputStream.read() returns -1 stream is at the end of file\nwhile ((len = in.read(buffer, 0, buffer.length)) != -1){\nout.write(buffer, 0 , len);\n}\n\/\/ Close both streams\nin.close();\nout.close();\n} catch (IOException e){\n\/\/ Log error if process failed\nLog.e(LOG_TAG, \"Failed to save file: \" + e.getMessage());\n}\n\/\/ Send a sound via WhatsApp or the like\nif (item.getItemId() == R.id.action_send){\ntry{\n\/\/ Check if the users device Android version is 5.1 or higher\n\/\/ If it is you'll have to use FileProvider to get the sharing function to work properly\nif (Build.VERSION.SDK_INT >= Build.VERSION_CODES.LOLLIPOP_MR1){\nfinal String AUTHORITY = view.getContext().getPackageName() + \".fileprovider\";\nUri contentUri = FileProvider.getUriForFile(view.getContext(), AUTHORITY, file);\nfinal Intent shareIntent = new Intent(Intent.ACTION_SEND);\nfinal Intent intent = new Intent(Intent.ACTION_SEND);\nintent.putExtra(Intent.EXTRA_STREAM, contentUri);\n\/\/ Define the intent to be of type audio\/mp3\nintent.setType(\"audio\/mp3\");\n\/\/ Start a new chooser dialog where the user can choose an app to share the sound\nview.getContext().startActivity(Intent.createChooser(intent, \"Share sound via...\"));\n}\nelse {\nfinal Intent intent = new Intent(Intent.ACTION_SEND);\n\n\/\/ Start a new chooser dialog where the user can choose an app to share the sound\nview.getContext().startActivity(Intent.createChooser(intent, \"Share sound via...\"));\n}\nelse {\nfinal Intent intent = new Intent(Intent.ACTION_SEND);\n\/\/ Uri refers to a name or location\n\/\/ .parse() analyzes a given uri string and creates a Uri from it\n\/\/ Define a \"link\" (Uri) to the saved file\nUri fileUri = Uri.parse(file.getAbsolutePath());\nintent.putExtra(Intent.EXTRA_STREAM, fileUri);\n\/\/ Define the intent to be of type audio\/mp3\nintent.setType(\"audio\/mp3\");\n\/\/ Start a new chooser dialog where the user can choose an app to share the sound\nview.getContext().startActivity(Intent.createChooser(intent, \"Share sound via...\"));\n}\n} catch (Exception e){\n\/\/ Log error if process failed\nLog.e(LOG_TAG, \"Failed to share sound: \" + e.getMessage());\n}\n}\n\/\/ Save as ringtone, alarm or notification\n\/\/ if (item.getItemId() == R.id.action_ringtone) {\n\/\/\n\/\/ \/\/ Create a little popup like dialog that gives the user the choice between the 3 types\n\/\/ \/\/ THEME_HOLO_LIGHT was deprecated in API 23 but to support older APIs you should use it\n\/\/ AlertDialog.Builder builder = new AlertDialog.Builder(view.getContext(), AlertDialog.THEME_HOLO_LIGHT);\n\/\/ builder.setTitle(\"Save as...\");\n\/\/ builder.setItems(new CharSequence[]{\"Ringtone\", \"Notification\", \"Alarm\"}, new DialogInterface.OnClickListener(){\n\/\/\n\/\/ @Override\n\/\/ public void onClick(DialogInterface dialog, int which){\n\/\/\n\/\/ \/\/ Decide on the users choice which information will be send to a method that handles the settings for all kinds of system audio\n\/\/\/\/ switch (which) {\n\/\/\/\/\n\/\/\/\/ \/\/ Ringtone\n\/\/\/\/ case 0:\n\/\/\/\/ changeSystemAudio(context, RingtoneManager.TYPE_RINGTONE, file);\n\/\/\/\/ break;\n\/\/\/\/ \/\/ Notification\n\/\/\/\/ case 1:\n\/\/\/\/ changeSystemAudio(context, RingtoneManager.TYPE_NOTIFICATION, file);\n\/\/\/\/ break;\n\/\/\/\/ \/\/ Alarmton\n\/\/\/\/ case 2:\n\/\/\/\/ changeSystemAudio(context, RingtoneManager.TYPE_ALARM, file);\n\/\/\/\/ break;\n\/\/\/\/ default:\n\/\/\/\/ }\n\/\/ }\n\/\/ });\n\/\/ builder.create();\n\/\/ builder.show();\n\/\/ }\n}\n\/\/ Add sound to favorites \/ Remove sound from favorites\n\/\/ if (item.getItemId() == R.id.action_favorite) {\n\/\/\n\/\/ DatabaseHandler databaseHandler = DatabaseHandler\n\/\/ .getInstance(context.getApplicationContext());\n\/\/\n\/\/ \/\/ Identify the current activity\n\/\/ if (context instanceof FavoriteActivity) {\n\/\/ databaseHandler.removeFavorite(context, soundObject);\n\/\/ } else {\n\/\/ databaseHandler.addFavorite(soundObject);\n\/\/ }\n\/\/ }\nreturn true;\n}\n});\npopup.show();\n}\n\n\/\/\/\/ \/\/ Ringtone\n\/\/\/\/ case 0:\n\/\/\/\/ changeSystemAudio(context, RingtoneManager.TYPE_RINGTONE, file);\n\/\/\/\/ break;\n\/\/\/\/ \/\/ Notification\n\/\/\/\/ case 1:\n\/\/\/\/ changeSystemAudio(context, RingtoneManager.TYPE_NOTIFICATION, file);\n\/\/\/\/ break;\n\/\/\/\/ \/\/ Alarmton\n\/\/\/\/ case 2:\n\/\/\/\/ changeSystemAudio(context, RingtoneManager.TYPE_ALARM, file);\n\/\/\/\/ break;\n\/\/\/\/ default:\n\/\/\/\/ }\n\/\/ }\n\/\/ });\n\/\/ builder.create();\n\/\/ builder.show();\n\/\/ }\n}\n\/\/ Add sound to favorites \/ Remove sound from favorites\n\/\/ if (item.getItemId() == R.id.action_favorite) {\n\/\/\n\/\/ DatabaseHandler databaseHandler = DatabaseHandler\n\/\/ .getInstance(context.getApplicationContext());\n\/\/\n\/\/ \/\/ Identify the current activity\n\/\/ if (context instanceof FavoriteActivity) {\n\/\/ databaseHandler.removeFavorite(context, soundObject);\n\/\/ } else {\n\/\/ databaseHandler.addFavorite(soundObject);\n\/\/ }\n\/\/ }\nreturn true;\n}\n});\npopup.show();\n}","label":[1,0,0,0]}
{"id":3789,"original_code":"private void addNoteAsFingerMarker(byte[] dat) {\n\t\tfinal int command = dat[0] & 0xf0;\n\t\tfinal int channel = dat[0] & 0x0f;\n\t\tint note = dat[1];\n\t\tfinal int velocity = dat[2];\n\t\t\/\/ if (type == NOTE_ON || type == NOTE_OFF) \n\t\tif ((command & 0x80) == 0x80) {\n\t\t\t\/\/ only show if channel switch is on\n\t\t\tif (GuitarChannel.isChannelEnabled(chanTog, channel)) {\n\t\t\t\tGuitarChannel guitarchannel = GuitarChannel.get(gchannels,\n\t\t\t\t\t\tchannel);\n\t\t\t\tif (command == NOTEON && velocity != 0) {\n\t\t\t\t\tprintMessage(dat);\n\t\t\t\t\tguitarchannel.noteOn(note);\n\t\t\t\t} else \/* if (command == NOTEOFF || velocity == 0) *\/{\n\t\t\t\t\tguitarchannel.noteOff(note);\n\t\t\t\t}\n\t\t\t}\n\t\t\t\/\/ update progress slider periodically\n\t\t\tif (noteCount % 30 == 0) {\n\t\t\t\t\/\/ need to figure out why this doesn't work\n\t\t\t\t\/\/ float percent = sequencer.getTickPosition() \/\n\t\t\t\t\/\/ sequence.getTickLength() * 100;\n\t\t\t\tGuitarView.getProgSlide().setValue(sequencer.getTickPosition());\n\t\t\t\t\/\/ GuitarView.getProgSlide().setValueLabel(String.format(\"%d\",\n\t\t\t\t\/\/ percent));\n\t\t\t\t\/\/ GuitarView.myTextarea.append(String.format(\"%d\", percent) +\n\t\t\t\t\/\/ \"\\n\");\n\t\t\t}\n\t\t\tnoteCount++;\n\t\t}\n\t}","code":"private void addNoteAsFingerMarker(byte[] dat) {\n\t\tfinal int command = dat[0] & 0xf0;\n\t\tfinal int channel = dat[0] & 0x0f;\n\t\tint note = dat[1];\n\t\tfinal int velocity = dat[2];\n\t\n\t\tif ((command & 0x80) == 0x80) {\n\t\t\n\t\t\tif (GuitarChannel.isChannelEnabled(chanTog, channel)) {\n\t\t\t\tGuitarChannel guitarchannel = GuitarChannel.get(gchannels,\n\t\t\t\t\t\tchannel);\n\t\t\t\tif (command == NOTEON && velocity != 0) {\n\t\t\t\t\tprintMessage(dat);\n\t\t\t\t\tguitarchannel.noteOn(note);\n\t\t\t\t} else{\n\t\t\t\t\tguitarchannel.noteOff(note);\n\t\t\t\t}\n\t\t\t}\n\t\t\n\t\t\tif (noteCount % 30 == 0) {\n\t\t\t\n\t\t\t\n\t\t\t\n\t\t\t\tGuitarView.getProgSlide().setValue(sequencer.getTickPosition());\n\t\t\t\n\t\t\t\n\t\t\t\n\t\t\t\n\t\t\t}\n\t\t\tnoteCount++;\n\t\t}\n\t}","cleancode":"private void addnoteasfingermarker(byte[] dat) { final int command = dat[0] & 0xf0; final int channel = dat[0] & 0x0f; int note = dat[1]; final int velocity = dat[2]; if ((command & 0x80) == 0x80) { if (guitarchannel.ischannelenabled(chantog, channel)) { guitarchannel guitarchannel = guitarchannel.get(gchannels, channel); if (command == noteon && velocity != 0) { printmessage(dat); guitarchannel.noteon(note); } else{ guitarchannel.noteoff(note); } } if (notecount % 30 == 0) { guitarview.getprogslide().setvalue(sequencer.gettickposition()); } notecount++; } }","comment":"\/\/ if (type == note_on || type == note_off)\n\/\/ only show if channel switch is on\n\/* if (command == noteoff || velocity == 0) *\/\n\/\/ update progress slider periodically\n\/\/ need to figure out why this doesn't work \/\/ float percent = sequencer.gettickposition() \/ \/\/ sequence.getticklength() * 100;\n\/\/ guitarview.getprogslide().setvaluelabel(string.format(\"%d\", \/\/ percent)); \/\/ guitarview.mytextarea.append(string.format(\"%d\", percent) + \/\/ \"\\n\");","repo":"rsampson\/GuitarView","code_context_2":"int note = dat[1];\nfinal int velocity = dat[2];\n\/\/ if (type == NOTE_ON || type == NOTE_OFF)\nif ((command & 0x80) == 0x80) {\n\/\/ only show if channel switch is on\n\n\/\/ if (type == NOTE_ON || type == NOTE_OFF)\nif ((command & 0x80) == 0x80) {\n\/\/ only show if channel switch is on\nif (GuitarChannel.isChannelEnabled(chanTog, channel)) {\nGuitarChannel guitarchannel = GuitarChannel.get(gchannels,\n\nprintMessage(dat);\nguitarchannel.noteOn(note);\n} else \/* if (command == NOTEOFF || velocity == 0) *\/{\nguitarchannel.noteOff(note);\n}\n\n}\n}\n\/\/ update progress slider periodically\nif (noteCount % 30 == 0) {\n\/\/ need to figure out why this doesn't work\n\n\/\/ update progress slider periodically\nif (noteCount % 30 == 0) {\n\/\/ need to figure out why this doesn't work\n\/\/ float percent = sequencer.getTickPosition() \/\n\/\/ sequence.getTickLength() * 100;\nGuitarView.getProgSlide().setValue(sequencer.getTickPosition());\n\/\/ GuitarView.getProgSlide().setValueLabel(String.format(\"%d\",\n\n\/\/ sequence.getTickLength() * 100;\nGuitarView.getProgSlide().setValue(sequencer.getTickPosition());\n\/\/ GuitarView.getProgSlide().setValueLabel(String.format(\"%d\",\n\/\/ percent));\n\/\/ GuitarView.myTextarea.append(String.format(\"%d\", percent) +\n\/\/ \"\\n\");\n}\nnoteCount++;","code_context_10":"private void addNoteAsFingerMarker(byte[] dat) {\nfinal int command = dat[0] & 0xf0;\nfinal int channel = dat[0] & 0x0f;\nint note = dat[1];\nfinal int velocity = dat[2];\n\/\/ if (type == NOTE_ON || type == NOTE_OFF)\nif ((command & 0x80) == 0x80) {\n\/\/ only show if channel switch is on\nif (GuitarChannel.isChannelEnabled(chanTog, channel)) {\nGuitarChannel guitarchannel = GuitarChannel.get(gchannels,\nchannel);\nif (command == NOTEON && velocity != 0) {\nprintMessage(dat);\nguitarchannel.noteOn(note);\n} else \/* if (command == NOTEOFF || velocity == 0) *\/{\nguitarchannel.noteOff(note);\n\nprivate void addNoteAsFingerMarker(byte[] dat) {\nfinal int command = dat[0] & 0xf0;\nfinal int channel = dat[0] & 0x0f;\nint note = dat[1];\nfinal int velocity = dat[2];\n\/\/ if (type == NOTE_ON || type == NOTE_OFF)\nif ((command & 0x80) == 0x80) {\n\/\/ only show if channel switch is on\nif (GuitarChannel.isChannelEnabled(chanTog, channel)) {\nGuitarChannel guitarchannel = GuitarChannel.get(gchannels,\nchannel);\nif (command == NOTEON && velocity != 0) {\nprintMessage(dat);\nguitarchannel.noteOn(note);\n} else \/* if (command == NOTEOFF || velocity == 0) *\/{\nguitarchannel.noteOff(note);\n}\n}\n\nfinal int velocity = dat[2];\n\/\/ if (type == NOTE_ON || type == NOTE_OFF)\nif ((command & 0x80) == 0x80) {\n\/\/ only show if channel switch is on\nif (GuitarChannel.isChannelEnabled(chanTog, channel)) {\nGuitarChannel guitarchannel = GuitarChannel.get(gchannels,\nchannel);\nif (command == NOTEON && velocity != 0) {\nprintMessage(dat);\nguitarchannel.noteOn(note);\n} else \/* if (command == NOTEOFF || velocity == 0) *\/{\nguitarchannel.noteOff(note);\n}\n}\n\/\/ update progress slider periodically\nif (noteCount % 30 == 0) {\n\/\/ need to figure out why this doesn't work\n\/\/ float percent = sequencer.getTickPosition() \/\n\/\/ sequence.getTickLength() * 100;\nGuitarView.getProgSlide().setValue(sequencer.getTickPosition());\n\/\/ GuitarView.getProgSlide().setValueLabel(String.format(\"%d\",\n\nif (GuitarChannel.isChannelEnabled(chanTog, channel)) {\nGuitarChannel guitarchannel = GuitarChannel.get(gchannels,\nchannel);\nif (command == NOTEON && velocity != 0) {\nprintMessage(dat);\nguitarchannel.noteOn(note);\n} else \/* if (command == NOTEOFF || velocity == 0) *\/{\nguitarchannel.noteOff(note);\n}\n}\n\/\/ update progress slider periodically\nif (noteCount % 30 == 0) {\n\/\/ need to figure out why this doesn't work\n\/\/ float percent = sequencer.getTickPosition() \/\n\/\/ sequence.getTickLength() * 100;\nGuitarView.getProgSlide().setValue(sequencer.getTickPosition());\n\/\/ GuitarView.getProgSlide().setValueLabel(String.format(\"%d\",\n\/\/ percent));\n\/\/ GuitarView.myTextarea.append(String.format(\"%d\", percent) +\n\/\/ \"\\n\");\n}\n\nchannel);\nif (command == NOTEON && velocity != 0) {\nprintMessage(dat);\nguitarchannel.noteOn(note);\n} else \/* if (command == NOTEOFF || velocity == 0) *\/{\nguitarchannel.noteOff(note);\n}\n}\n\/\/ update progress slider periodically\nif (noteCount % 30 == 0) {\n\/\/ need to figure out why this doesn't work\n\/\/ float percent = sequencer.getTickPosition() \/\n\/\/ sequence.getTickLength() * 100;\nGuitarView.getProgSlide().setValue(sequencer.getTickPosition());\n\/\/ GuitarView.getProgSlide().setValueLabel(String.format(\"%d\",\n\/\/ percent));\n\/\/ GuitarView.myTextarea.append(String.format(\"%d\", percent) +\n\/\/ \"\\n\");\n}\nnoteCount++;\n}\n}\n\n} else \/* if (command == NOTEOFF || velocity == 0) *\/{\nguitarchannel.noteOff(note);\n}\n}\n\/\/ update progress slider periodically\nif (noteCount % 30 == 0) {\n\/\/ need to figure out why this doesn't work\n\/\/ float percent = sequencer.getTickPosition() \/\n\/\/ sequence.getTickLength() * 100;\nGuitarView.getProgSlide().setValue(sequencer.getTickPosition());\n\/\/ GuitarView.getProgSlide().setValueLabel(String.format(\"%d\",\n\/\/ percent));\n\/\/ GuitarView.myTextarea.append(String.format(\"%d\", percent) +\n\/\/ \"\\n\");\n}\nnoteCount++;\n}\n}","code_context_20":"private void addNoteAsFingerMarker(byte[] dat) {\nfinal int command = dat[0] & 0xf0;\nfinal int channel = dat[0] & 0x0f;\nint note = dat[1];\nfinal int velocity = dat[2];\n\/\/ if (type == NOTE_ON || type == NOTE_OFF)\nif ((command & 0x80) == 0x80) {\n\/\/ only show if channel switch is on\nif (GuitarChannel.isChannelEnabled(chanTog, channel)) {\nGuitarChannel guitarchannel = GuitarChannel.get(gchannels,\nchannel);\nif (command == NOTEON && velocity != 0) {\nprintMessage(dat);\nguitarchannel.noteOn(note);\n} else \/* if (command == NOTEOFF || velocity == 0) *\/{\nguitarchannel.noteOff(note);\n}\n}\n\/\/ update progress slider periodically\nif (noteCount % 30 == 0) {\n\/\/ need to figure out why this doesn't work\n\/\/ float percent = sequencer.getTickPosition() \/\n\/\/ sequence.getTickLength() * 100;\nGuitarView.getProgSlide().setValue(sequencer.getTickPosition());\n\/\/ GuitarView.getProgSlide().setValueLabel(String.format(\"%d\",\n\/\/ percent));\n\nprivate void addNoteAsFingerMarker(byte[] dat) {\nfinal int command = dat[0] & 0xf0;\nfinal int channel = dat[0] & 0x0f;\nint note = dat[1];\nfinal int velocity = dat[2];\n\/\/ if (type == NOTE_ON || type == NOTE_OFF)\nif ((command & 0x80) == 0x80) {\n\/\/ only show if channel switch is on\nif (GuitarChannel.isChannelEnabled(chanTog, channel)) {\nGuitarChannel guitarchannel = GuitarChannel.get(gchannels,\nchannel);\nif (command == NOTEON && velocity != 0) {\nprintMessage(dat);\nguitarchannel.noteOn(note);\n} else \/* if (command == NOTEOFF || velocity == 0) *\/{\nguitarchannel.noteOff(note);\n}\n}\n\/\/ update progress slider periodically\nif (noteCount % 30 == 0) {\n\/\/ need to figure out why this doesn't work\n\/\/ float percent = sequencer.getTickPosition() \/\n\/\/ sequence.getTickLength() * 100;\nGuitarView.getProgSlide().setValue(sequencer.getTickPosition());\n\/\/ GuitarView.getProgSlide().setValueLabel(String.format(\"%d\",\n\/\/ percent));\n\/\/ GuitarView.myTextarea.append(String.format(\"%d\", percent) +\n\/\/ \"\\n\");\n\nprivate void addNoteAsFingerMarker(byte[] dat) {\nfinal int command = dat[0] & 0xf0;\nfinal int channel = dat[0] & 0x0f;\nint note = dat[1];\nfinal int velocity = dat[2];\n\/\/ if (type == NOTE_ON || type == NOTE_OFF)\nif ((command & 0x80) == 0x80) {\n\/\/ only show if channel switch is on\nif (GuitarChannel.isChannelEnabled(chanTog, channel)) {\nGuitarChannel guitarchannel = GuitarChannel.get(gchannels,\nchannel);\nif (command == NOTEON && velocity != 0) {\nprintMessage(dat);\nguitarchannel.noteOn(note);\n} else \/* if (command == NOTEOFF || velocity == 0) *\/{\nguitarchannel.noteOff(note);\n}\n}\n\/\/ update progress slider periodically\nif (noteCount % 30 == 0) {\n\/\/ need to figure out why this doesn't work\n\/\/ float percent = sequencer.getTickPosition() \/\n\/\/ sequence.getTickLength() * 100;\nGuitarView.getProgSlide().setValue(sequencer.getTickPosition());\n\/\/ GuitarView.getProgSlide().setValueLabel(String.format(\"%d\",\n\/\/ percent));\n\/\/ GuitarView.myTextarea.append(String.format(\"%d\", percent) +\n\/\/ \"\\n\");\n}\nnoteCount++;\n}\n}\n\nprivate void addNoteAsFingerMarker(byte[] dat) {\nfinal int command = dat[0] & 0xf0;\nfinal int channel = dat[0] & 0x0f;\nint note = dat[1];\nfinal int velocity = dat[2];\n\/\/ if (type == NOTE_ON || type == NOTE_OFF)\nif ((command & 0x80) == 0x80) {\n\/\/ only show if channel switch is on\nif (GuitarChannel.isChannelEnabled(chanTog, channel)) {\nGuitarChannel guitarchannel = GuitarChannel.get(gchannels,\nchannel);\nif (command == NOTEON && velocity != 0) {\nprintMessage(dat);\nguitarchannel.noteOn(note);\n} else \/* if (command == NOTEOFF || velocity == 0) *\/{\nguitarchannel.noteOff(note);\n}\n}\n\/\/ update progress slider periodically\nif (noteCount % 30 == 0) {\n\/\/ need to figure out why this doesn't work\n\/\/ float percent = sequencer.getTickPosition() \/\n\/\/ sequence.getTickLength() * 100;\nGuitarView.getProgSlide().setValue(sequencer.getTickPosition());\n\/\/ GuitarView.getProgSlide().setValueLabel(String.format(\"%d\",\n\/\/ percent));\n\/\/ GuitarView.myTextarea.append(String.format(\"%d\", percent) +\n\/\/ \"\\n\");\n}\nnoteCount++;\n}\n}\n\nprivate void addNoteAsFingerMarker(byte[] dat) {\nfinal int command = dat[0] & 0xf0;\nfinal int channel = dat[0] & 0x0f;\nint note = dat[1];\nfinal int velocity = dat[2];\n\/\/ if (type == NOTE_ON || type == NOTE_OFF)\nif ((command & 0x80) == 0x80) {\n\/\/ only show if channel switch is on\nif (GuitarChannel.isChannelEnabled(chanTog, channel)) {\nGuitarChannel guitarchannel = GuitarChannel.get(gchannels,\nchannel);\nif (command == NOTEON && velocity != 0) {\nprintMessage(dat);\nguitarchannel.noteOn(note);\n} else \/* if (command == NOTEOFF || velocity == 0) *\/{\nguitarchannel.noteOff(note);\n}\n}\n\/\/ update progress slider periodically\nif (noteCount % 30 == 0) {\n\/\/ need to figure out why this doesn't work\n\/\/ float percent = sequencer.getTickPosition() \/\n\/\/ sequence.getTickLength() * 100;\nGuitarView.getProgSlide().setValue(sequencer.getTickPosition());\n\/\/ GuitarView.getProgSlide().setValueLabel(String.format(\"%d\",\n\/\/ percent));\n\/\/ GuitarView.myTextarea.append(String.format(\"%d\", percent) +\n\/\/ \"\\n\");\n}\nnoteCount++;\n}\n}\n\nfinal int velocity = dat[2];\n\/\/ if (type == NOTE_ON || type == NOTE_OFF)\nif ((command & 0x80) == 0x80) {\n\/\/ only show if channel switch is on\nif (GuitarChannel.isChannelEnabled(chanTog, channel)) {\nGuitarChannel guitarchannel = GuitarChannel.get(gchannels,\nchannel);\nif (command == NOTEON && velocity != 0) {\nprintMessage(dat);\nguitarchannel.noteOn(note);\n} else \/* if (command == NOTEOFF || velocity == 0) *\/{\nguitarchannel.noteOff(note);\n}\n}\n\/\/ update progress slider periodically\nif (noteCount % 30 == 0) {\n\/\/ need to figure out why this doesn't work\n\/\/ float percent = sequencer.getTickPosition() \/\n\/\/ sequence.getTickLength() * 100;\nGuitarView.getProgSlide().setValue(sequencer.getTickPosition());\n\/\/ GuitarView.getProgSlide().setValueLabel(String.format(\"%d\",\n\/\/ percent));\n\/\/ GuitarView.myTextarea.append(String.format(\"%d\", percent) +\n\/\/ \"\\n\");\n}\nnoteCount++;\n}\n}","label":[0,0,1,0]}
{"id":3880,"original_code":"@Test\n    public void shouldReturnExpectedResponseWhenGetRequestMadeOverSslWithTlsVersion_1_3() throws Exception {\n        \/\/ The following is a bad practice: conditionally running this test only if 'TLSv1.3' is supported by the JDK\n        if (new HashSet<>(asList(SslUtils.enabledProtocols())).contains(TLS_v1_3)) {\n            makeRequestAndAssert(buildHttpClient(TLS_v1_3));\n        } else {\n            assertThat(true).isTrue();\n        }\n    }","code":"@Test\n    public void shouldReturnExpectedResponseWhenGetRequestMadeOverSslWithTlsVersion_1_3() throws Exception {\n       \n        if (new HashSet<>(asList(SslUtils.enabledProtocols())).contains(TLS_v1_3)) {\n            makeRequestAndAssert(buildHttpClient(TLS_v1_3));\n        } else {\n            assertThat(true).isTrue();\n        }\n    }","cleancode":"@test public void shouldreturnexpectedresponsewhengetrequestmadeoversslwithtlsversion_1_3() throws exception { if (new hashset<>(aslist(sslutils.enabledprotocols())).contains(tls_v1_3)) { makerequestandassert(buildhttpclient(tls_v1_3)); } else { assertthat(true).istrue(); } }","comment":"\/\/ the following is a bad practice: conditionally running this test only if 'tlsv1.3' is supported by the jdk","repo":"rohankumardubey\/stubby4j","code_context_2":"@Test\npublic void shouldReturnExpectedResponseWhenGetRequestMadeOverSslWithTlsVersion_1_3() throws Exception {\n\/\/ The following is a bad practice: conditionally running this test only if 'TLSv1.3' is supported by the JDK\nif (new HashSet<>(asList(SslUtils.enabledProtocols())).contains(TLS_v1_3)) {\nmakeRequestAndAssert(buildHttpClient(TLS_v1_3));","code_context_10":"@Test\npublic void shouldReturnExpectedResponseWhenGetRequestMadeOverSslWithTlsVersion_1_3() throws Exception {\n\/\/ The following is a bad practice: conditionally running this test only if 'TLSv1.3' is supported by the JDK\nif (new HashSet<>(asList(SslUtils.enabledProtocols())).contains(TLS_v1_3)) {\nmakeRequestAndAssert(buildHttpClient(TLS_v1_3));\n} else {\nassertThat(true).isTrue();\n}\n}","code_context_20":"@Test\npublic void shouldReturnExpectedResponseWhenGetRequestMadeOverSslWithTlsVersion_1_3() throws Exception {\n\/\/ The following is a bad practice: conditionally running this test only if 'TLSv1.3' is supported by the JDK\nif (new HashSet<>(asList(SslUtils.enabledProtocols())).contains(TLS_v1_3)) {\nmakeRequestAndAssert(buildHttpClient(TLS_v1_3));\n} else {\nassertThat(true).isTrue();\n}\n}","label":[0,0,0,1]}
{"id":12261,"original_code":"public void register() {\n        if (!isRegistered) {\n            VirtualFileManager.getInstance().addAsyncFileListener((@NotNull List<? extends VFileEvent> events) -> {\n                for (VFileEvent event : events) {\n                    if (event instanceof VFileDeleteEvent) {\n                        \/\/ TODO run configuration icon change\n                        System.out.println(\"deleted : \" + event.getFile());\n                    }\n                }\n                return null;\n            }, () -> {});\n            isRegistered = true;\n        }\n    }","code":"public void register() {\n        if (!isRegistered) {\n            VirtualFileManager.getInstance().addAsyncFileListener((@NotNull List<? extends VFileEvent> events) -> {\n                for (VFileEvent event : events) {\n                    if (event instanceof VFileDeleteEvent) {\n                       \n                        System.out.println(\"deleted : \" + event.getFile());\n                    }\n                }\n                return null;\n            }, () -> {});\n            isRegistered = true;\n        }\n    }","cleancode":"public void register() { if (!isregistered) { virtualfilemanager.getinstance().addasyncfilelistener((@notnull list<? extends vfileevent> events) -> { for (vfileevent event : events) { if (event instanceof vfiledeleteevent) { system.out.println(\"deleted : \" + event.getfile()); } } return null; }, () -> {}); isregistered = true; } }","comment":"\/\/ todo run configuration icon change","repo":"soungminjoo\/httpflow-intellij-plugin","code_context_2":"for (VFileEvent event : events) {\nif (event instanceof VFileDeleteEvent) {\n\/\/ TODO run configuration icon change\nSystem.out.println(\"deleted : \" + event.getFile());\n}","code_context_10":"public void register() {\nif (!isRegistered) {\nVirtualFileManager.getInstance().addAsyncFileListener((@NotNull List<? extends VFileEvent> events) -> {\nfor (VFileEvent event : events) {\nif (event instanceof VFileDeleteEvent) {\n\/\/ TODO run configuration icon change\nSystem.out.println(\"deleted : \" + event.getFile());\n}\n}\nreturn null;\n}, () -> {});\nisRegistered = true;\n}\n}","code_context_20":"public void register() {\nif (!isRegistered) {\nVirtualFileManager.getInstance().addAsyncFileListener((@NotNull List<? extends VFileEvent> events) -> {\nfor (VFileEvent event : events) {\nif (event instanceof VFileDeleteEvent) {\n\/\/ TODO run configuration icon change\nSystem.out.println(\"deleted : \" + event.getFile());\n}\n}\nreturn null;\n}, () -> {});\nisRegistered = true;\n}\n}","label":[0,1,0,0]}
{"id":20616,"original_code":"private void setBandInfo(DataChoice dataChoice, AddeImageInfo aii) {\n        BandInfo bi = (BandInfo) dataChoice.getId();\n        List<BandInfo> bandInfos =\n            (List<BandInfo>) getProperty(PROP_BANDINFO, (Object) null);\n        boolean hasBand = true;\n        \/\/If this data source has been changed after we have create a display \n        \/\/then the possibility exists that the bandinfo contained by the incoming\n        \/\/data choice might not be valid. If it isn't then default to the first \n        \/\/one in the list\n        if (bandInfos != null) {\n            hasBand = bandInfos.contains(bi);\n            if ( !hasBand) {\n                \/\/                                System.err.println(\"has band = \" + bandInfos.contains(bi));\n            }\n            if ( !hasBand && (bandInfos.size() > 0)) {\n                bi = bandInfos.get(0);\n            } else {\n                \/\/Not sure what to do here.\n            }\n        }\n        aii.setBand(\"\" + bi.getBandNumber());\n        aii.setUnit(bi.getPreferredUnit());\n    }","code":"private void setBandInfo(DataChoice dataChoice, AddeImageInfo aii) {\n        BandInfo bi = (BandInfo) dataChoice.getId();\n        List<BandInfo> bandInfos =\n            (List<BandInfo>) getProperty(PROP_BANDINFO, (Object) null);\n        boolean hasBand = true;\n       \n       \n       \n       \n        if (bandInfos != null) {\n            hasBand = bandInfos.contains(bi);\n            if ( !hasBand) {\n               \n            }\n            if ( !hasBand && (bandInfos.size() > 0)) {\n                bi = bandInfos.get(0);\n            } else {\n               \n            }\n        }\n        aii.setBand(\"\" + bi.getBandNumber());\n        aii.setUnit(bi.getPreferredUnit());\n    }","cleancode":"private void setbandinfo(datachoice datachoice, addeimageinfo aii) { bandinfo bi = (bandinfo) datachoice.getid(); list<bandinfo> bandinfos = (list<bandinfo>) getproperty(prop_bandinfo, (object) null); boolean hasband = true; if (bandinfos != null) { hasband = bandinfos.contains(bi); if ( !hasband) { } if ( !hasband && (bandinfos.size() > 0)) { bi = bandinfos.get(0); } else { } } aii.setband(\"\" + bi.getbandnumber()); aii.setunit(bi.getpreferredunit()); }","comment":"\/** * set the band information on the data choice * * @param datachoice the data choice * @param aii the addeimageinfo with the image stuff *\/\n\/\/if this data source has been changed after we have create a display \/\/then the possibility exists that the bandinfo contained by the incoming \/\/data choice might not be valid. if it isn't then default to the first \/\/one in the list\n\/\/ system.err.println(\"has band = \" + bandinfos.contains(bi));\n\/\/not sure what to do here.","repo":"slclark\/IDV","code_context_2":"private void setBandInfo(DataChoice dataChoice, AddeImageInfo aii) {\nBandInfo bi = (BandInfo) dataChoice.getId();\nList<BandInfo> bandInfos =\n(List<BandInfo>) getProperty(PROP_BANDINFO, (Object) null);\nboolean hasBand = true;\n\/\/If this data source has been changed after we have create a display\n\/\/then the possibility exists that the bandinfo contained by the incoming\n\/\/data choice might not be valid. If it isn't then default to the first\n\/\/one in the list\nif (bandInfos != null) {\nhasBand = bandInfos.contains(bi);\nif ( !hasBand) {\n\/\/ System.err.println(\"has band = \" + bandInfos.contains(bi));\n}\nif ( !hasBand && (bandInfos.size() > 0)) {\nbi = bandInfos.get(0);\n} else {\n\/\/Not sure what to do here.\n}\n}\naii.setBand(\"\" + bi.getBandNumber());\naii.setUnit(bi.getPreferredUnit());\n}\n\n(List<BandInfo>) getProperty(PROP_BANDINFO, (Object) null);\nboolean hasBand = true;\n\/\/If this data source has been changed after we have create a display\n\/\/then the possibility exists that the bandinfo contained by the incoming\n\/\/data choice might not be valid. If it isn't then default to the first\n\/\/one in the list\nif (bandInfos != null) {\nhasBand = bandInfos.contains(bi);\n\nhasBand = bandInfos.contains(bi);\nif ( !hasBand) {\n\/\/ System.err.println(\"has band = \" + bandInfos.contains(bi));\n}\nif ( !hasBand && (bandInfos.size() > 0)) {\n\nbi = bandInfos.get(0);\n} else {\n\/\/Not sure what to do here.\n}\n}","code_context_10":"private void setBandInfo(DataChoice dataChoice, AddeImageInfo aii) {\nBandInfo bi = (BandInfo) dataChoice.getId();\nList<BandInfo> bandInfos =\n(List<BandInfo>) getProperty(PROP_BANDINFO, (Object) null);\nboolean hasBand = true;\n\/\/If this data source has been changed after we have create a display\n\/\/then the possibility exists that the bandinfo contained by the incoming\n\/\/data choice might not be valid. If it isn't then default to the first\n\/\/one in the list\nif (bandInfos != null) {\nhasBand = bandInfos.contains(bi);\nif ( !hasBand) {\n\/\/ System.err.println(\"has band = \" + bandInfos.contains(bi));\n}\nif ( !hasBand && (bandInfos.size() > 0)) {\nbi = bandInfos.get(0);\n} else {\n\/\/Not sure what to do here.\n}\n}\naii.setBand(\"\" + bi.getBandNumber());\naii.setUnit(bi.getPreferredUnit());\n}\n\nprivate void setBandInfo(DataChoice dataChoice, AddeImageInfo aii) {\nBandInfo bi = (BandInfo) dataChoice.getId();\nList<BandInfo> bandInfos =\n(List<BandInfo>) getProperty(PROP_BANDINFO, (Object) null);\nboolean hasBand = true;\n\/\/If this data source has been changed after we have create a display\n\/\/then the possibility exists that the bandinfo contained by the incoming\n\/\/data choice might not be valid. If it isn't then default to the first\n\/\/one in the list\nif (bandInfos != null) {\nhasBand = bandInfos.contains(bi);\nif ( !hasBand) {\n\/\/ System.err.println(\"has band = \" + bandInfos.contains(bi));\n}\nif ( !hasBand && (bandInfos.size() > 0)) {\nbi = bandInfos.get(0);\n} else {\n\/\/Not sure what to do here.\n}\n\nList<BandInfo> bandInfos =\n(List<BandInfo>) getProperty(PROP_BANDINFO, (Object) null);\nboolean hasBand = true;\n\/\/If this data source has been changed after we have create a display\n\/\/then the possibility exists that the bandinfo contained by the incoming\n\/\/data choice might not be valid. If it isn't then default to the first\n\/\/one in the list\nif (bandInfos != null) {\nhasBand = bandInfos.contains(bi);\nif ( !hasBand) {\n\/\/ System.err.println(\"has band = \" + bandInfos.contains(bi));\n}\nif ( !hasBand && (bandInfos.size() > 0)) {\nbi = bandInfos.get(0);\n} else {\n\/\/Not sure what to do here.\n}\n}\naii.setBand(\"\" + bi.getBandNumber());\naii.setUnit(bi.getPreferredUnit());\n}\n\n\/\/data choice might not be valid. If it isn't then default to the first\n\/\/one in the list\nif (bandInfos != null) {\nhasBand = bandInfos.contains(bi);\nif ( !hasBand) {\n\/\/ System.err.println(\"has band = \" + bandInfos.contains(bi));\n}\nif ( !hasBand && (bandInfos.size() > 0)) {\nbi = bandInfos.get(0);\n} else {\n\/\/Not sure what to do here.\n}\n}\naii.setBand(\"\" + bi.getBandNumber());\naii.setUnit(bi.getPreferredUnit());\n}","code_context_20":"private void setBandInfo(DataChoice dataChoice, AddeImageInfo aii) {\nBandInfo bi = (BandInfo) dataChoice.getId();\nList<BandInfo> bandInfos =\n(List<BandInfo>) getProperty(PROP_BANDINFO, (Object) null);\nboolean hasBand = true;\n\/\/If this data source has been changed after we have create a display\n\/\/then the possibility exists that the bandinfo contained by the incoming\n\/\/data choice might not be valid. If it isn't then default to the first\n\/\/one in the list\nif (bandInfos != null) {\nhasBand = bandInfos.contains(bi);\nif ( !hasBand) {\n\/\/ System.err.println(\"has band = \" + bandInfos.contains(bi));\n}\nif ( !hasBand && (bandInfos.size() > 0)) {\nbi = bandInfos.get(0);\n} else {\n\/\/Not sure what to do here.\n}\n}\naii.setBand(\"\" + bi.getBandNumber());\naii.setUnit(bi.getPreferredUnit());\n}\n\nprivate void setBandInfo(DataChoice dataChoice, AddeImageInfo aii) {\nBandInfo bi = (BandInfo) dataChoice.getId();\nList<BandInfo> bandInfos =\n(List<BandInfo>) getProperty(PROP_BANDINFO, (Object) null);\nboolean hasBand = true;\n\/\/If this data source has been changed after we have create a display\n\/\/then the possibility exists that the bandinfo contained by the incoming\n\/\/data choice might not be valid. If it isn't then default to the first\n\/\/one in the list\nif (bandInfos != null) {\nhasBand = bandInfos.contains(bi);\nif ( !hasBand) {\n\/\/ System.err.println(\"has band = \" + bandInfos.contains(bi));\n}\nif ( !hasBand && (bandInfos.size() > 0)) {\nbi = bandInfos.get(0);\n} else {\n\/\/Not sure what to do here.\n}\n}\naii.setBand(\"\" + bi.getBandNumber());\naii.setUnit(bi.getPreferredUnit());\n}\n\nprivate void setBandInfo(DataChoice dataChoice, AddeImageInfo aii) {\nBandInfo bi = (BandInfo) dataChoice.getId();\nList<BandInfo> bandInfos =\n(List<BandInfo>) getProperty(PROP_BANDINFO, (Object) null);\nboolean hasBand = true;\n\/\/If this data source has been changed after we have create a display\n\/\/then the possibility exists that the bandinfo contained by the incoming\n\/\/data choice might not be valid. If it isn't then default to the first\n\/\/one in the list\nif (bandInfos != null) {\nhasBand = bandInfos.contains(bi);\nif ( !hasBand) {\n\/\/ System.err.println(\"has band = \" + bandInfos.contains(bi));\n}\nif ( !hasBand && (bandInfos.size() > 0)) {\nbi = bandInfos.get(0);\n} else {\n\/\/Not sure what to do here.\n}\n}\naii.setBand(\"\" + bi.getBandNumber());\naii.setUnit(bi.getPreferredUnit());\n}\n\nprivate void setBandInfo(DataChoice dataChoice, AddeImageInfo aii) {\nBandInfo bi = (BandInfo) dataChoice.getId();\nList<BandInfo> bandInfos =\n(List<BandInfo>) getProperty(PROP_BANDINFO, (Object) null);\nboolean hasBand = true;\n\/\/If this data source has been changed after we have create a display\n\/\/then the possibility exists that the bandinfo contained by the incoming\n\/\/data choice might not be valid. If it isn't then default to the first\n\/\/one in the list\nif (bandInfos != null) {\nhasBand = bandInfos.contains(bi);\nif ( !hasBand) {\n\/\/ System.err.println(\"has band = \" + bandInfos.contains(bi));\n}\nif ( !hasBand && (bandInfos.size() > 0)) {\nbi = bandInfos.get(0);\n} else {\n\/\/Not sure what to do here.\n}\n}\naii.setBand(\"\" + bi.getBandNumber());\naii.setUnit(bi.getPreferredUnit());\n}","label":[0,1,0,0]}
{"id":20666,"original_code":"public List<DijkstraNode> getNeighbors() {\n        \/\/ TODO\n        \/\/ Check if on edge of map - breaks if we're on the pixel right next\n        \/\/ to the edge.\n        List<DijkstraNode> neighborNodeList = new ArrayList<DijkstraNode>();\n        Coordinate currentCoordinate = this.getPosition();\n        int currentX = currentCoordinate.getX();\n        int currentY = currentCoordinate.getY();\n        \/\/ since we're on a grid, treat our graph as such and determine neighbors like that\n        Coordinate coordinateLeft = new Coordinate(currentX - 1, currentY);\n        Coordinate coordinateUpLeft = new Coordinate(currentX - 1, currentY + 1);\n        Coordinate coordinateUp = new Coordinate(currentX, currentY + 1);\n        Coordinate coordinateUpRight = new Coordinate(currentX + 1, currentY + 1);\n        Coordinate coordinateRight = new Coordinate(currentX + 1, currentY);\n        Coordinate coordinateDownRight = new Coordinate(currentX + 1, currentY - 1);\n        Coordinate coordinateDown = new Coordinate(currentX, currentY - 1);\n        Coordinate coordinateDownLeft = new Coordinate(currentX - 1, currentY - 1);\n        DijkstraNode nodeLeft = new DijkstraNode(coordinateLeft);\n        DijkstraNode nodeUpLeft = new DijkstraNode(coordinateUpLeft);\n        DijkstraNode nodeUp = new DijkstraNode(coordinateUp);\n        DijkstraNode nodeUpRight = new DijkstraNode(coordinateUpRight);\n        DijkstraNode nodeRight = new DijkstraNode(coordinateRight);\n        DijkstraNode nodeDownRight = new DijkstraNode(coordinateDownRight);\n        DijkstraNode nodeDown = new DijkstraNode(coordinateDown);\n        DijkstraNode nodeDownLeft = new DijkstraNode(coordinateDownLeft);\n        neighborNodeList.add(nodeLeft);\n        neighborNodeList.add(nodeUpLeft);\n        neighborNodeList.add(nodeUp);\n        neighborNodeList.add(nodeUpRight);\n        neighborNodeList.add(nodeRight);\n        neighborNodeList.add(nodeDownRight);\n        neighborNodeList.add(nodeDown);\n        neighborNodeList.add(nodeDownLeft);\n        return neighborNodeList;\n    }","code":"public List<DijkstraNode> getNeighbors() {\n       \n       \n       \n        List<DijkstraNode> neighborNodeList = new ArrayList<DijkstraNode>();\n        Coordinate currentCoordinate = this.getPosition();\n        int currentX = currentCoordinate.getX();\n        int currentY = currentCoordinate.getY();\n       \n        Coordinate coordinateLeft = new Coordinate(currentX - 1, currentY);\n        Coordinate coordinateUpLeft = new Coordinate(currentX - 1, currentY + 1);\n        Coordinate coordinateUp = new Coordinate(currentX, currentY + 1);\n        Coordinate coordinateUpRight = new Coordinate(currentX + 1, currentY + 1);\n        Coordinate coordinateRight = new Coordinate(currentX + 1, currentY);\n        Coordinate coordinateDownRight = new Coordinate(currentX + 1, currentY - 1);\n        Coordinate coordinateDown = new Coordinate(currentX, currentY - 1);\n        Coordinate coordinateDownLeft = new Coordinate(currentX - 1, currentY - 1);\n        DijkstraNode nodeLeft = new DijkstraNode(coordinateLeft);\n        DijkstraNode nodeUpLeft = new DijkstraNode(coordinateUpLeft);\n        DijkstraNode nodeUp = new DijkstraNode(coordinateUp);\n        DijkstraNode nodeUpRight = new DijkstraNode(coordinateUpRight);\n        DijkstraNode nodeRight = new DijkstraNode(coordinateRight);\n        DijkstraNode nodeDownRight = new DijkstraNode(coordinateDownRight);\n        DijkstraNode nodeDown = new DijkstraNode(coordinateDown);\n        DijkstraNode nodeDownLeft = new DijkstraNode(coordinateDownLeft);\n        neighborNodeList.add(nodeLeft);\n        neighborNodeList.add(nodeUpLeft);\n        neighborNodeList.add(nodeUp);\n        neighborNodeList.add(nodeUpRight);\n        neighborNodeList.add(nodeRight);\n        neighborNodeList.add(nodeDownRight);\n        neighborNodeList.add(nodeDown);\n        neighborNodeList.add(nodeDownLeft);\n        return neighborNodeList;\n    }","cleancode":"public list<dijkstranode> getneighbors() { list<dijkstranode> neighbornodelist = new arraylist<dijkstranode>(); coordinate currentcoordinate = this.getposition(); int currentx = currentcoordinate.getx(); int currenty = currentcoordinate.gety(); coordinate coordinateleft = new coordinate(currentx - 1, currenty); coordinate coordinateupleft = new coordinate(currentx - 1, currenty + 1); coordinate coordinateup = new coordinate(currentx, currenty + 1); coordinate coordinateupright = new coordinate(currentx + 1, currenty + 1); coordinate coordinateright = new coordinate(currentx + 1, currenty); coordinate coordinatedownright = new coordinate(currentx + 1, currenty - 1); coordinate coordinatedown = new coordinate(currentx, currenty - 1); coordinate coordinatedownleft = new coordinate(currentx - 1, currenty - 1); dijkstranode nodeleft = new dijkstranode(coordinateleft); dijkstranode nodeupleft = new dijkstranode(coordinateupleft); dijkstranode nodeup = new dijkstranode(coordinateup); dijkstranode nodeupright = new dijkstranode(coordinateupright); dijkstranode noderight = new dijkstranode(coordinateright); dijkstranode nodedownright = new dijkstranode(coordinatedownright); dijkstranode nodedown = new dijkstranode(coordinatedown); dijkstranode nodedownleft = new dijkstranode(coordinatedownleft); neighbornodelist.add(nodeleft); neighbornodelist.add(nodeupleft); neighbornodelist.add(nodeup); neighbornodelist.add(nodeupright); neighbornodelist.add(noderight); neighbornodelist.add(nodedownright); neighbornodelist.add(nodedown); neighbornodelist.add(nodedownleft); return neighbornodelist; }","comment":"\/** * finds neighbors of a given node * @return list of nodes neighboring the current node *\/\n\/\/ todo \/\/ check if on edge of map - breaks if we're on the pixel right next \/\/ to the edge.\n\/\/ since we're on a grid, treat our graph as such and determine neighbors like that","repo":"sapols\/JPL-CUSeniorProjects","code_context_2":"public List<DijkstraNode> getNeighbors() {\n\/\/ TODO\n\/\/ Check if on edge of map - breaks if we're on the pixel right next\n\/\/ to the edge.\nList<DijkstraNode> neighborNodeList = new ArrayList<DijkstraNode>();\nCoordinate currentCoordinate = this.getPosition();\nint currentX = currentCoordinate.getX();\nint currentY = currentCoordinate.getY();\n\/\/ since we're on a grid, treat our graph as such and determine neighbors like that\nCoordinate coordinateLeft = new Coordinate(currentX - 1, currentY);\nCoordinate coordinateUpLeft = new Coordinate(currentX - 1, currentY + 1);\nCoordinate coordinateUp = new Coordinate(currentX, currentY + 1);\nCoordinate coordinateUpRight = new Coordinate(currentX + 1, currentY + 1);\nCoordinate coordinateRight = new Coordinate(currentX + 1, currentY);\nCoordinate coordinateDownRight = new Coordinate(currentX + 1, currentY - 1);\nCoordinate coordinateDown = new Coordinate(currentX, currentY - 1);\nCoordinate coordinateDownLeft = new Coordinate(currentX - 1, currentY - 1);\nDijkstraNode nodeLeft = new DijkstraNode(coordinateLeft);\nDijkstraNode nodeUpLeft = new DijkstraNode(coordinateUpLeft);\nDijkstraNode nodeUp = new DijkstraNode(coordinateUp);\nDijkstraNode nodeUpRight = new DijkstraNode(coordinateUpRight);\nDijkstraNode nodeRight = new DijkstraNode(coordinateRight);\nDijkstraNode nodeDownRight = new DijkstraNode(coordinateDownRight);\nDijkstraNode nodeDown = new DijkstraNode(coordinateDown);\nDijkstraNode nodeDownLeft = new DijkstraNode(coordinateDownLeft);\nneighborNodeList.add(nodeLeft);\nneighborNodeList.add(nodeUpLeft);\nneighborNodeList.add(nodeUp);\nneighborNodeList.add(nodeUpRight);\nneighborNodeList.add(nodeRight);\nneighborNodeList.add(nodeDownRight);\nneighborNodeList.add(nodeDown);\nneighborNodeList.add(nodeDownLeft);\nreturn neighborNodeList;\n}\n\npublic List<DijkstraNode> getNeighbors() {\n\/\/ TODO\n\/\/ Check if on edge of map - breaks if we're on the pixel right next\n\/\/ to the edge.\nList<DijkstraNode> neighborNodeList = new ArrayList<DijkstraNode>();\nCoordinate currentCoordinate = this.getPosition();\n\nint currentX = currentCoordinate.getX();\nint currentY = currentCoordinate.getY();\n\/\/ since we're on a grid, treat our graph as such and determine neighbors like that\nCoordinate coordinateLeft = new Coordinate(currentX - 1, currentY);\nCoordinate coordinateUpLeft = new Coordinate(currentX - 1, currentY + 1);","code_context_10":"public List<DijkstraNode> getNeighbors() {\n\/\/ TODO\n\/\/ Check if on edge of map - breaks if we're on the pixel right next\n\/\/ to the edge.\nList<DijkstraNode> neighborNodeList = new ArrayList<DijkstraNode>();\nCoordinate currentCoordinate = this.getPosition();\nint currentX = currentCoordinate.getX();\nint currentY = currentCoordinate.getY();\n\/\/ since we're on a grid, treat our graph as such and determine neighbors like that\nCoordinate coordinateLeft = new Coordinate(currentX - 1, currentY);\nCoordinate coordinateUpLeft = new Coordinate(currentX - 1, currentY + 1);\nCoordinate coordinateUp = new Coordinate(currentX, currentY + 1);\nCoordinate coordinateUpRight = new Coordinate(currentX + 1, currentY + 1);\nCoordinate coordinateRight = new Coordinate(currentX + 1, currentY);\nCoordinate coordinateDownRight = new Coordinate(currentX + 1, currentY - 1);\nCoordinate coordinateDown = new Coordinate(currentX, currentY - 1);\nCoordinate coordinateDownLeft = new Coordinate(currentX - 1, currentY - 1);\nDijkstraNode nodeLeft = new DijkstraNode(coordinateLeft);\nDijkstraNode nodeUpLeft = new DijkstraNode(coordinateUpLeft);\nDijkstraNode nodeUp = new DijkstraNode(coordinateUp);\nDijkstraNode nodeUpRight = new DijkstraNode(coordinateUpRight);\nDijkstraNode nodeRight = new DijkstraNode(coordinateRight);\nDijkstraNode nodeDownRight = new DijkstraNode(coordinateDownRight);\nDijkstraNode nodeDown = new DijkstraNode(coordinateDown);\nDijkstraNode nodeDownLeft = new DijkstraNode(coordinateDownLeft);\nneighborNodeList.add(nodeLeft);\nneighborNodeList.add(nodeUpLeft);\nneighborNodeList.add(nodeUp);\nneighborNodeList.add(nodeUpRight);\nneighborNodeList.add(nodeRight);\nneighborNodeList.add(nodeDownRight);\nneighborNodeList.add(nodeDown);\nneighborNodeList.add(nodeDownLeft);\nreturn neighborNodeList;\n}\n\npublic List<DijkstraNode> getNeighbors() {\n\/\/ TODO\n\/\/ Check if on edge of map - breaks if we're on the pixel right next\n\/\/ to the edge.\nList<DijkstraNode> neighborNodeList = new ArrayList<DijkstraNode>();\nCoordinate currentCoordinate = this.getPosition();\nint currentX = currentCoordinate.getX();\nint currentY = currentCoordinate.getY();\n\/\/ since we're on a grid, treat our graph as such and determine neighbors like that\nCoordinate coordinateLeft = new Coordinate(currentX - 1, currentY);\nCoordinate coordinateUpLeft = new Coordinate(currentX - 1, currentY + 1);\nCoordinate coordinateUp = new Coordinate(currentX, currentY + 1);\nCoordinate coordinateUpRight = new Coordinate(currentX + 1, currentY + 1);\nCoordinate coordinateRight = new Coordinate(currentX + 1, currentY);\n\npublic List<DijkstraNode> getNeighbors() {\n\/\/ TODO\n\/\/ Check if on edge of map - breaks if we're on the pixel right next\n\/\/ to the edge.\nList<DijkstraNode> neighborNodeList = new ArrayList<DijkstraNode>();\nCoordinate currentCoordinate = this.getPosition();\nint currentX = currentCoordinate.getX();\nint currentY = currentCoordinate.getY();\n\/\/ since we're on a grid, treat our graph as such and determine neighbors like that\nCoordinate coordinateLeft = new Coordinate(currentX - 1, currentY);\nCoordinate coordinateUpLeft = new Coordinate(currentX - 1, currentY + 1);\nCoordinate coordinateUp = new Coordinate(currentX, currentY + 1);\nCoordinate coordinateUpRight = new Coordinate(currentX + 1, currentY + 1);\nCoordinate coordinateRight = new Coordinate(currentX + 1, currentY);\nCoordinate coordinateDownRight = new Coordinate(currentX + 1, currentY - 1);\nCoordinate coordinateDown = new Coordinate(currentX, currentY - 1);\nCoordinate coordinateDownLeft = new Coordinate(currentX - 1, currentY - 1);\nDijkstraNode nodeLeft = new DijkstraNode(coordinateLeft);\nDijkstraNode nodeUpLeft = new DijkstraNode(coordinateUpLeft);","code_context_20":"public List<DijkstraNode> getNeighbors() {\n\/\/ TODO\n\/\/ Check if on edge of map - breaks if we're on the pixel right next\n\/\/ to the edge.\nList<DijkstraNode> neighborNodeList = new ArrayList<DijkstraNode>();\nCoordinate currentCoordinate = this.getPosition();\nint currentX = currentCoordinate.getX();\nint currentY = currentCoordinate.getY();\n\/\/ since we're on a grid, treat our graph as such and determine neighbors like that\nCoordinate coordinateLeft = new Coordinate(currentX - 1, currentY);\nCoordinate coordinateUpLeft = new Coordinate(currentX - 1, currentY + 1);\nCoordinate coordinateUp = new Coordinate(currentX, currentY + 1);\nCoordinate coordinateUpRight = new Coordinate(currentX + 1, currentY + 1);\nCoordinate coordinateRight = new Coordinate(currentX + 1, currentY);\nCoordinate coordinateDownRight = new Coordinate(currentX + 1, currentY - 1);\nCoordinate coordinateDown = new Coordinate(currentX, currentY - 1);\nCoordinate coordinateDownLeft = new Coordinate(currentX - 1, currentY - 1);\nDijkstraNode nodeLeft = new DijkstraNode(coordinateLeft);\nDijkstraNode nodeUpLeft = new DijkstraNode(coordinateUpLeft);\nDijkstraNode nodeUp = new DijkstraNode(coordinateUp);\nDijkstraNode nodeUpRight = new DijkstraNode(coordinateUpRight);\nDijkstraNode nodeRight = new DijkstraNode(coordinateRight);\nDijkstraNode nodeDownRight = new DijkstraNode(coordinateDownRight);\nDijkstraNode nodeDown = new DijkstraNode(coordinateDown);\nDijkstraNode nodeDownLeft = new DijkstraNode(coordinateDownLeft);\nneighborNodeList.add(nodeLeft);\nneighborNodeList.add(nodeUpLeft);\nneighborNodeList.add(nodeUp);\nneighborNodeList.add(nodeUpRight);\nneighborNodeList.add(nodeRight);\nneighborNodeList.add(nodeDownRight);\nneighborNodeList.add(nodeDown);\nneighborNodeList.add(nodeDownLeft);\nreturn neighborNodeList;\n}\n\npublic List<DijkstraNode> getNeighbors() {\n\/\/ TODO\n\/\/ Check if on edge of map - breaks if we're on the pixel right next\n\/\/ to the edge.\nList<DijkstraNode> neighborNodeList = new ArrayList<DijkstraNode>();\nCoordinate currentCoordinate = this.getPosition();\nint currentX = currentCoordinate.getX();\nint currentY = currentCoordinate.getY();\n\/\/ since we're on a grid, treat our graph as such and determine neighbors like that\nCoordinate coordinateLeft = new Coordinate(currentX - 1, currentY);\nCoordinate coordinateUpLeft = new Coordinate(currentX - 1, currentY + 1);\nCoordinate coordinateUp = new Coordinate(currentX, currentY + 1);\nCoordinate coordinateUpRight = new Coordinate(currentX + 1, currentY + 1);\nCoordinate coordinateRight = new Coordinate(currentX + 1, currentY);\nCoordinate coordinateDownRight = new Coordinate(currentX + 1, currentY - 1);\nCoordinate coordinateDown = new Coordinate(currentX, currentY - 1);\nCoordinate coordinateDownLeft = new Coordinate(currentX - 1, currentY - 1);\nDijkstraNode nodeLeft = new DijkstraNode(coordinateLeft);\nDijkstraNode nodeUpLeft = new DijkstraNode(coordinateUpLeft);\nDijkstraNode nodeUp = new DijkstraNode(coordinateUp);\nDijkstraNode nodeUpRight = new DijkstraNode(coordinateUpRight);\nDijkstraNode nodeRight = new DijkstraNode(coordinateRight);\nDijkstraNode nodeDownRight = new DijkstraNode(coordinateDownRight);\nDijkstraNode nodeDown = new DijkstraNode(coordinateDown);\n\npublic List<DijkstraNode> getNeighbors() {\n\/\/ TODO\n\/\/ Check if on edge of map - breaks if we're on the pixel right next\n\/\/ to the edge.\nList<DijkstraNode> neighborNodeList = new ArrayList<DijkstraNode>();\nCoordinate currentCoordinate = this.getPosition();\nint currentX = currentCoordinate.getX();\nint currentY = currentCoordinate.getY();\n\/\/ since we're on a grid, treat our graph as such and determine neighbors like that\nCoordinate coordinateLeft = new Coordinate(currentX - 1, currentY);\nCoordinate coordinateUpLeft = new Coordinate(currentX - 1, currentY + 1);\nCoordinate coordinateUp = new Coordinate(currentX, currentY + 1);\nCoordinate coordinateUpRight = new Coordinate(currentX + 1, currentY + 1);\nCoordinate coordinateRight = new Coordinate(currentX + 1, currentY);\nCoordinate coordinateDownRight = new Coordinate(currentX + 1, currentY - 1);\nCoordinate coordinateDown = new Coordinate(currentX, currentY - 1);\nCoordinate coordinateDownLeft = new Coordinate(currentX - 1, currentY - 1);\nDijkstraNode nodeLeft = new DijkstraNode(coordinateLeft);\nDijkstraNode nodeUpLeft = new DijkstraNode(coordinateUpLeft);\nDijkstraNode nodeUp = new DijkstraNode(coordinateUp);\nDijkstraNode nodeUpRight = new DijkstraNode(coordinateUpRight);\nDijkstraNode nodeRight = new DijkstraNode(coordinateRight);\nDijkstraNode nodeDownRight = new DijkstraNode(coordinateDownRight);\nDijkstraNode nodeDown = new DijkstraNode(coordinateDown);\nDijkstraNode nodeDownLeft = new DijkstraNode(coordinateDownLeft);\nneighborNodeList.add(nodeLeft);\nneighborNodeList.add(nodeUpLeft);\nneighborNodeList.add(nodeUp);\nneighborNodeList.add(nodeUpRight);","label":[0,1,0,0]}
{"id":12757,"original_code":"protected Entry getSpreadEntry(Request request, ServiceInput dpi,\n                                   Entry sample, String climstartYear,\n                                   String climendYear)\n            throws Exception {\n        Entry sprdEntry = null;\n        \/\/System.err.println(\"Creating spread\");\n        \/\/String statName = \"mean\";\n        String statName = \"ens01\";  \/\/ per Marty hoerling - just use the spread of one member\n        \/\/ Find the mean\n        List<Entry> mean = findStatisticEntry(request, sample, statName);\n        if ((mean == null) || mean.isEmpty()) {\n            \/\/System.err.println(\"Couldn't find \" + statName);\n            \/\/ TODO: Should we just exit if no mean?\n            sprdEntry = sample;\n        } else if (mean.size() > 1) {\n            System.err.println(\"found too many\");\n        } else {\n            sprdEntry = mean.get(0);\n            \/\/System.err.println(\"found mean: \" + sprdEntry);\n        }\n        \/\/sprdEntry = sample;\n        \/\/ Now make the spread from the mean\n        String stail =\n            getOutputHandler().getStorageManager().getFileTail(sprdEntry);\n        sprdEntry = makeStatistic(request, sprdEntry, dpi, stail, \"smegma\",\n                                  climstartYear, climendYear);\n        return sprdEntry;\n    }","code":"protected Entry getSpreadEntry(Request request, ServiceInput dpi,\n                                   Entry sample, String climstartYear,\n                                   String climendYear)\n            throws Exception {\n        Entry sprdEntry = null;\n       \n       \n        String statName = \"ens01\"; \n       \n        List<Entry> mean = findStatisticEntry(request, sample, statName);\n        if ((mean == null) || mean.isEmpty()) {\n           \n           \n            sprdEntry = sample;\n        } else if (mean.size() > 1) {\n            System.err.println(\"found too many\");\n        } else {\n            sprdEntry = mean.get(0);\n           \n        }\n       \n       \n        String stail =\n            getOutputHandler().getStorageManager().getFileTail(sprdEntry);\n        sprdEntry = makeStatistic(request, sprdEntry, dpi, stail, \"smegma\",\n                                  climstartYear, climendYear);\n        return sprdEntry;\n    }","cleancode":"protected entry getspreadentry(request request, serviceinput dpi, entry sample, string climstartyear, string climendyear) throws exception { entry sprdentry = null; string statname = \"ens01\"; list<entry> mean = findstatisticentry(request, sample, statname); if ((mean == null) || mean.isempty()) { sprdentry = sample; } else if (mean.size() > 1) { system.err.println(\"found too many\"); } else { sprdentry = mean.get(0); } string stail = getoutputhandler().getstoragemanager().getfiletail(sprdentry); sprdentry = makestatistic(request, sprdentry, dpi, stail, \"smegma\", climstartyear, climendyear); return sprdentry; }","comment":"\/** * get the spread (smegma) entry for the climatology * * @param request the request * @param dpi the input * @param sample a sample grid * @param climstartyear starting year for climatology * @param climendyear ending year for climatology * * @return an entry or null * * @throws exception problems *\/\n\/\/system.err.println(\"creating spread\"); \/\/string statname = \"mean\";\n\/\/ per marty hoerling - just use the spread of one member\n\/\/ find the mean\n\/\/system.err.println(\"couldn't find \" + statname); \/\/ todo: should we just exit if no mean?\n\/\/system.err.println(\"found mean: \" + sprdentry);\n\/\/sprdentry = sample; \/\/ now make the spread from the mean","repo":"suvarchal\/ramadda","code_context_2":"protected Entry getSpreadEntry(Request request, ServiceInput dpi,\nEntry sample, String climstartYear,\nString climendYear)\nthrows Exception {\nEntry sprdEntry = null;\n\/\/System.err.println(\"Creating spread\");\n\/\/String statName = \"mean\";\nString statName = \"ens01\"; \/\/ per Marty hoerling - just use the spread of one member\n\/\/ Find the mean\nList<Entry> mean = findStatisticEntry(request, sample, statName);\nif ((mean == null) || mean.isEmpty()) {\n\/\/System.err.println(\"Couldn't find \" + statName);\n\/\/ TODO: Should we just exit if no mean?\nsprdEntry = sample;\n} else if (mean.size() > 1) {\nSystem.err.println(\"found too many\");\n} else {\nsprdEntry = mean.get(0);\n\/\/System.err.println(\"found mean: \" + sprdEntry);\n}\n\/\/sprdEntry = sample;\n\/\/ Now make the spread from the mean\nString stail =\ngetOutputHandler().getStorageManager().getFileTail(sprdEntry);\nsprdEntry = makeStatistic(request, sprdEntry, dpi, stail, \"smegma\",\nclimstartYear, climendYear);\nreturn sprdEntry;\n}\n\nthrows Exception {\nEntry sprdEntry = null;\n\/\/System.err.println(\"Creating spread\");\n\/\/String statName = \"mean\";\nString statName = \"ens01\"; \/\/ per Marty hoerling - just use the spread of one member\n\/\/ Find the mean\n\n\/\/System.err.println(\"Creating spread\");\n\/\/String statName = \"mean\";\nString statName = \"ens01\"; \/\/ per Marty hoerling - just use the spread of one member\n\/\/ Find the mean\nList<Entry> mean = findStatisticEntry(request, sample, statName);\n\n\/\/String statName = \"mean\";\nString statName = \"ens01\"; \/\/ per Marty hoerling - just use the spread of one member\n\/\/ Find the mean\nList<Entry> mean = findStatisticEntry(request, sample, statName);\nif ((mean == null) || mean.isEmpty()) {\n\nList<Entry> mean = findStatisticEntry(request, sample, statName);\nif ((mean == null) || mean.isEmpty()) {\n\/\/System.err.println(\"Couldn't find \" + statName);\n\/\/ TODO: Should we just exit if no mean?\nsprdEntry = sample;\n} else if (mean.size() > 1) {\n\n} else {\nsprdEntry = mean.get(0);\n\/\/System.err.println(\"found mean: \" + sprdEntry);\n}\n\/\/sprdEntry = sample;\n\n\/\/System.err.println(\"found mean: \" + sprdEntry);\n}\n\/\/sprdEntry = sample;\n\/\/ Now make the spread from the mean\nString stail =\ngetOutputHandler().getStorageManager().getFileTail(sprdEntry);","code_context_10":"protected Entry getSpreadEntry(Request request, ServiceInput dpi,\nEntry sample, String climstartYear,\nString climendYear)\nthrows Exception {\nEntry sprdEntry = null;\n\/\/System.err.println(\"Creating spread\");\n\/\/String statName = \"mean\";\nString statName = \"ens01\"; \/\/ per Marty hoerling - just use the spread of one member\n\/\/ Find the mean\nList<Entry> mean = findStatisticEntry(request, sample, statName);\nif ((mean == null) || mean.isEmpty()) {\n\/\/System.err.println(\"Couldn't find \" + statName);\n\/\/ TODO: Should we just exit if no mean?\nsprdEntry = sample;\n} else if (mean.size() > 1) {\nSystem.err.println(\"found too many\");\n} else {\nsprdEntry = mean.get(0);\n\/\/System.err.println(\"found mean: \" + sprdEntry);\n}\n\/\/sprdEntry = sample;\n\/\/ Now make the spread from the mean\nString stail =\ngetOutputHandler().getStorageManager().getFileTail(sprdEntry);\nsprdEntry = makeStatistic(request, sprdEntry, dpi, stail, \"smegma\",\nclimstartYear, climendYear);\nreturn sprdEntry;\n}\n\nprotected Entry getSpreadEntry(Request request, ServiceInput dpi,\nEntry sample, String climstartYear,\nString climendYear)\nthrows Exception {\nEntry sprdEntry = null;\n\/\/System.err.println(\"Creating spread\");\n\/\/String statName = \"mean\";\nString statName = \"ens01\"; \/\/ per Marty hoerling - just use the spread of one member\n\/\/ Find the mean\nList<Entry> mean = findStatisticEntry(request, sample, statName);\nif ((mean == null) || mean.isEmpty()) {\n\/\/System.err.println(\"Couldn't find \" + statName);\n\/\/ TODO: Should we just exit if no mean?\nsprdEntry = sample;\n} else if (mean.size() > 1) {\nSystem.err.println(\"found too many\");\n} else {\n\nprotected Entry getSpreadEntry(Request request, ServiceInput dpi,\nEntry sample, String climstartYear,\nString climendYear)\nthrows Exception {\nEntry sprdEntry = null;\n\/\/System.err.println(\"Creating spread\");\n\/\/String statName = \"mean\";\nString statName = \"ens01\"; \/\/ per Marty hoerling - just use the spread of one member\n\/\/ Find the mean\nList<Entry> mean = findStatisticEntry(request, sample, statName);\nif ((mean == null) || mean.isEmpty()) {\n\/\/System.err.println(\"Couldn't find \" + statName);\n\/\/ TODO: Should we just exit if no mean?\nsprdEntry = sample;\n} else if (mean.size() > 1) {\nSystem.err.println(\"found too many\");\n} else {\nsprdEntry = mean.get(0);\n\nprotected Entry getSpreadEntry(Request request, ServiceInput dpi,\nEntry sample, String climstartYear,\nString climendYear)\nthrows Exception {\nEntry sprdEntry = null;\n\/\/System.err.println(\"Creating spread\");\n\/\/String statName = \"mean\";\nString statName = \"ens01\"; \/\/ per Marty hoerling - just use the spread of one member\n\/\/ Find the mean\nList<Entry> mean = findStatisticEntry(request, sample, statName);\nif ((mean == null) || mean.isEmpty()) {\n\/\/System.err.println(\"Couldn't find \" + statName);\n\/\/ TODO: Should we just exit if no mean?\nsprdEntry = sample;\n} else if (mean.size() > 1) {\nSystem.err.println(\"found too many\");\n} else {\nsprdEntry = mean.get(0);\n\/\/System.err.println(\"found mean: \" + sprdEntry);\n\nEntry sample, String climstartYear,\nString climendYear)\nthrows Exception {\nEntry sprdEntry = null;\n\/\/System.err.println(\"Creating spread\");\n\/\/String statName = \"mean\";\nString statName = \"ens01\"; \/\/ per Marty hoerling - just use the spread of one member\n\/\/ Find the mean\nList<Entry> mean = findStatisticEntry(request, sample, statName);\nif ((mean == null) || mean.isEmpty()) {\n\/\/System.err.println(\"Couldn't find \" + statName);\n\/\/ TODO: Should we just exit if no mean?\nsprdEntry = sample;\n} else if (mean.size() > 1) {\nSystem.err.println(\"found too many\");\n} else {\nsprdEntry = mean.get(0);\n\/\/System.err.println(\"found mean: \" + sprdEntry);\n}\n\/\/sprdEntry = sample;\n\/\/ Now make the spread from the mean\nString stail =\n\n\/\/ Find the mean\nList<Entry> mean = findStatisticEntry(request, sample, statName);\nif ((mean == null) || mean.isEmpty()) {\n\/\/System.err.println(\"Couldn't find \" + statName);\n\/\/ TODO: Should we just exit if no mean?\nsprdEntry = sample;\n} else if (mean.size() > 1) {\nSystem.err.println(\"found too many\");\n} else {\nsprdEntry = mean.get(0);\n\/\/System.err.println(\"found mean: \" + sprdEntry);\n}\n\/\/sprdEntry = sample;\n\/\/ Now make the spread from the mean\nString stail =\ngetOutputHandler().getStorageManager().getFileTail(sprdEntry);\nsprdEntry = makeStatistic(request, sprdEntry, dpi, stail, \"smegma\",\nclimstartYear, climendYear);\nreturn sprdEntry;\n}\n\nif ((mean == null) || mean.isEmpty()) {\n\/\/System.err.println(\"Couldn't find \" + statName);\n\/\/ TODO: Should we just exit if no mean?\nsprdEntry = sample;\n} else if (mean.size() > 1) {\nSystem.err.println(\"found too many\");\n} else {\nsprdEntry = mean.get(0);\n\/\/System.err.println(\"found mean: \" + sprdEntry);\n}\n\/\/sprdEntry = sample;\n\/\/ Now make the spread from the mean\nString stail =\ngetOutputHandler().getStorageManager().getFileTail(sprdEntry);\nsprdEntry = makeStatistic(request, sprdEntry, dpi, stail, \"smegma\",\nclimstartYear, climendYear);\nreturn sprdEntry;\n}","code_context_20":"protected Entry getSpreadEntry(Request request, ServiceInput dpi,\nEntry sample, String climstartYear,\nString climendYear)\nthrows Exception {\nEntry sprdEntry = null;\n\/\/System.err.println(\"Creating spread\");\n\/\/String statName = \"mean\";\nString statName = \"ens01\"; \/\/ per Marty hoerling - just use the spread of one member\n\/\/ Find the mean\nList<Entry> mean = findStatisticEntry(request, sample, statName);\nif ((mean == null) || mean.isEmpty()) {\n\/\/System.err.println(\"Couldn't find \" + statName);\n\/\/ TODO: Should we just exit if no mean?\nsprdEntry = sample;\n} else if (mean.size() > 1) {\nSystem.err.println(\"found too many\");\n} else {\nsprdEntry = mean.get(0);\n\/\/System.err.println(\"found mean: \" + sprdEntry);\n}\n\/\/sprdEntry = sample;\n\/\/ Now make the spread from the mean\nString stail =\ngetOutputHandler().getStorageManager().getFileTail(sprdEntry);\nsprdEntry = makeStatistic(request, sprdEntry, dpi, stail, \"smegma\",\nclimstartYear, climendYear);\nreturn sprdEntry;\n}\n\nprotected Entry getSpreadEntry(Request request, ServiceInput dpi,\nEntry sample, String climstartYear,\nString climendYear)\nthrows Exception {\nEntry sprdEntry = null;\n\/\/System.err.println(\"Creating spread\");\n\/\/String statName = \"mean\";\nString statName = \"ens01\"; \/\/ per Marty hoerling - just use the spread of one member\n\/\/ Find the mean\nList<Entry> mean = findStatisticEntry(request, sample, statName);\nif ((mean == null) || mean.isEmpty()) {\n\/\/System.err.println(\"Couldn't find \" + statName);\n\/\/ TODO: Should we just exit if no mean?\nsprdEntry = sample;\n} else if (mean.size() > 1) {\nSystem.err.println(\"found too many\");\n} else {\nsprdEntry = mean.get(0);\n\/\/System.err.println(\"found mean: \" + sprdEntry);\n}\n\/\/sprdEntry = sample;\n\/\/ Now make the spread from the mean\nString stail =\ngetOutputHandler().getStorageManager().getFileTail(sprdEntry);\nsprdEntry = makeStatistic(request, sprdEntry, dpi, stail, \"smegma\",\nclimstartYear, climendYear);\nreturn sprdEntry;\n\nprotected Entry getSpreadEntry(Request request, ServiceInput dpi,\nEntry sample, String climstartYear,\nString climendYear)\nthrows Exception {\nEntry sprdEntry = null;\n\/\/System.err.println(\"Creating spread\");\n\/\/String statName = \"mean\";\nString statName = \"ens01\"; \/\/ per Marty hoerling - just use the spread of one member\n\/\/ Find the mean\nList<Entry> mean = findStatisticEntry(request, sample, statName);\nif ((mean == null) || mean.isEmpty()) {\n\/\/System.err.println(\"Couldn't find \" + statName);\n\/\/ TODO: Should we just exit if no mean?\nsprdEntry = sample;\n} else if (mean.size() > 1) {\nSystem.err.println(\"found too many\");\n} else {\nsprdEntry = mean.get(0);\n\/\/System.err.println(\"found mean: \" + sprdEntry);\n}\n\/\/sprdEntry = sample;\n\/\/ Now make the spread from the mean\nString stail =\ngetOutputHandler().getStorageManager().getFileTail(sprdEntry);\nsprdEntry = makeStatistic(request, sprdEntry, dpi, stail, \"smegma\",\nclimstartYear, climendYear);\nreturn sprdEntry;\n}\n\nprotected Entry getSpreadEntry(Request request, ServiceInput dpi,\nEntry sample, String climstartYear,\nString climendYear)\nthrows Exception {\nEntry sprdEntry = null;\n\/\/System.err.println(\"Creating spread\");\n\/\/String statName = \"mean\";\nString statName = \"ens01\"; \/\/ per Marty hoerling - just use the spread of one member\n\/\/ Find the mean\nList<Entry> mean = findStatisticEntry(request, sample, statName);\nif ((mean == null) || mean.isEmpty()) {\n\/\/System.err.println(\"Couldn't find \" + statName);\n\/\/ TODO: Should we just exit if no mean?\nsprdEntry = sample;\n} else if (mean.size() > 1) {\nSystem.err.println(\"found too many\");\n} else {\nsprdEntry = mean.get(0);\n\/\/System.err.println(\"found mean: \" + sprdEntry);\n}\n\/\/sprdEntry = sample;\n\/\/ Now make the spread from the mean\nString stail =\ngetOutputHandler().getStorageManager().getFileTail(sprdEntry);\nsprdEntry = makeStatistic(request, sprdEntry, dpi, stail, \"smegma\",\nclimstartYear, climendYear);\nreturn sprdEntry;\n}\n\nprotected Entry getSpreadEntry(Request request, ServiceInput dpi,\nEntry sample, String climstartYear,\nString climendYear)\nthrows Exception {\nEntry sprdEntry = null;\n\/\/System.err.println(\"Creating spread\");\n\/\/String statName = \"mean\";\nString statName = \"ens01\"; \/\/ per Marty hoerling - just use the spread of one member\n\/\/ Find the mean\nList<Entry> mean = findStatisticEntry(request, sample, statName);\nif ((mean == null) || mean.isEmpty()) {\n\/\/System.err.println(\"Couldn't find \" + statName);\n\/\/ TODO: Should we just exit if no mean?\nsprdEntry = sample;\n} else if (mean.size() > 1) {\nSystem.err.println(\"found too many\");\n} else {\nsprdEntry = mean.get(0);\n\/\/System.err.println(\"found mean: \" + sprdEntry);\n}\n\/\/sprdEntry = sample;\n\/\/ Now make the spread from the mean\nString stail =\ngetOutputHandler().getStorageManager().getFileTail(sprdEntry);\nsprdEntry = makeStatistic(request, sprdEntry, dpi, stail, \"smegma\",\nclimstartYear, climendYear);\nreturn sprdEntry;\n}\n\nprotected Entry getSpreadEntry(Request request, ServiceInput dpi,\nEntry sample, String climstartYear,\nString climendYear)\nthrows Exception {\nEntry sprdEntry = null;\n\/\/System.err.println(\"Creating spread\");\n\/\/String statName = \"mean\";\nString statName = \"ens01\"; \/\/ per Marty hoerling - just use the spread of one member\n\/\/ Find the mean\nList<Entry> mean = findStatisticEntry(request, sample, statName);\nif ((mean == null) || mean.isEmpty()) {\n\/\/System.err.println(\"Couldn't find \" + statName);\n\/\/ TODO: Should we just exit if no mean?\nsprdEntry = sample;\n} else if (mean.size() > 1) {\nSystem.err.println(\"found too many\");\n} else {\nsprdEntry = mean.get(0);\n\/\/System.err.println(\"found mean: \" + sprdEntry);\n}\n\/\/sprdEntry = sample;\n\/\/ Now make the spread from the mean\nString stail =\ngetOutputHandler().getStorageManager().getFileTail(sprdEntry);\nsprdEntry = makeStatistic(request, sprdEntry, dpi, stail, \"smegma\",\nclimstartYear, climendYear);\nreturn sprdEntry;\n}\n\nprotected Entry getSpreadEntry(Request request, ServiceInput dpi,\nEntry sample, String climstartYear,\nString climendYear)\nthrows Exception {\nEntry sprdEntry = null;\n\/\/System.err.println(\"Creating spread\");\n\/\/String statName = \"mean\";\nString statName = \"ens01\"; \/\/ per Marty hoerling - just use the spread of one member\n\/\/ Find the mean\nList<Entry> mean = findStatisticEntry(request, sample, statName);\nif ((mean == null) || mean.isEmpty()) {\n\/\/System.err.println(\"Couldn't find \" + statName);\n\/\/ TODO: Should we just exit if no mean?\nsprdEntry = sample;\n} else if (mean.size() > 1) {\nSystem.err.println(\"found too many\");\n} else {\nsprdEntry = mean.get(0);\n\/\/System.err.println(\"found mean: \" + sprdEntry);\n}\n\/\/sprdEntry = sample;\n\/\/ Now make the spread from the mean\nString stail =\ngetOutputHandler().getStorageManager().getFileTail(sprdEntry);\nsprdEntry = makeStatistic(request, sprdEntry, dpi, stail, \"smegma\",\nclimstartYear, climendYear);\nreturn sprdEntry;\n}","label":[1,0,0,0]}
{"id":13239,"original_code":"private static void displayExceptionPrivate(JFrame aFrame, Throwable aE) {\n\t\tStringWriter tempStringWriter = new StringWriter();\n\t\tPrintWriter tempPrintWriter = new PrintWriter(tempStringWriter);\n\t\taE.printStackTrace(tempPrintWriter);\n\t\ttempPrintWriter.close();\n\t\tfinal JDialog tempDialog = new JDialog(aFrame, \"Error: \" + aE.getMessage());\n\t\ttempDialog.setModal(true);\n\t\tDimension tempScreen = Toolkit.getDefaultToolkit().getScreenSize();\n\t\ttempDialog.setSize(tempScreen.width \/ 2, tempScreen.height \/ 2);\n\t\ttempDialog.setLocation(tempScreen.width \/ 4, tempScreen.height \/ 4);\n\t\ttempDialog.getContentPane().setLayout(new BorderLayout());\n\t\tScrollPane tempScrollPane = new ScrollPane();\n\t\tJEditorPane tempEditorPane = new JEditorPane();\n\t\t\/\/ TODO Replace by Font.MONOSPACED with JDK 6\n\t\ttempEditorPane.setFont(new Font(\"Monospaced\", 0, aFrame.getFont().getSize()));\n\t\ttempEditorPane.setText(tempStringWriter.toString());\n\t\ttempScrollPane.add(tempEditorPane);\n\t\ttempDialog.getContentPane().add(tempScrollPane, BorderLayout.CENTER);\n\t\tAction tempActionListener = new AbstractAction(\"OK\") {\n\t\t\t@Override\n\t\t\tpublic void actionPerformed(ActionEvent aE) {\n\t\t\t\ttempDialog.dispose();\n\t\t\t}\n\t\t};\n\t\ttempDialog.getContentPane().add(createButtons(new Action[] { tempActionListener }), BorderLayout.SOUTH);\n\t\ttempDialog.setDefaultCloseOperation(JDialog.DISPOSE_ON_CLOSE);\n\t\ttempDialog.setVisible(true);\n\t}","code":"private static void displayExceptionPrivate(JFrame aFrame, Throwable aE) {\n\t\tStringWriter tempStringWriter = new StringWriter();\n\t\tPrintWriter tempPrintWriter = new PrintWriter(tempStringWriter);\n\t\taE.printStackTrace(tempPrintWriter);\n\t\ttempPrintWriter.close();\n\t\tfinal JDialog tempDialog = new JDialog(aFrame, \"Error: \" + aE.getMessage());\n\t\ttempDialog.setModal(true);\n\t\tDimension tempScreen = Toolkit.getDefaultToolkit().getScreenSize();\n\t\ttempDialog.setSize(tempScreen.width \/ 2, tempScreen.height \/ 2);\n\t\ttempDialog.setLocation(tempScreen.width \/ 4, tempScreen.height \/ 4);\n\t\ttempDialog.getContentPane().setLayout(new BorderLayout());\n\t\tScrollPane tempScrollPane = new ScrollPane();\n\t\tJEditorPane tempEditorPane = new JEditorPane();\n\t\n\t\ttempEditorPane.setFont(new Font(\"Monospaced\", 0, aFrame.getFont().getSize()));\n\t\ttempEditorPane.setText(tempStringWriter.toString());\n\t\ttempScrollPane.add(tempEditorPane);\n\t\ttempDialog.getContentPane().add(tempScrollPane, BorderLayout.CENTER);\n\t\tAction tempActionListener = new AbstractAction(\"OK\") {\n\t\t\t@Override\n\t\t\tpublic void actionPerformed(ActionEvent aE) {\n\t\t\t\ttempDialog.dispose();\n\t\t\t}\n\t\t};\n\t\ttempDialog.getContentPane().add(createButtons(new Action[] { tempActionListener }), BorderLayout.SOUTH);\n\t\ttempDialog.setDefaultCloseOperation(JDialog.DISPOSE_ON_CLOSE);\n\t\ttempDialog.setVisible(true);\n\t}","cleancode":"private static void displayexceptionprivate(jframe aframe, throwable ae) { stringwriter tempstringwriter = new stringwriter(); printwriter tempprintwriter = new printwriter(tempstringwriter); ae.printstacktrace(tempprintwriter); tempprintwriter.close(); final jdialog tempdialog = new jdialog(aframe, \"error: \" + ae.getmessage()); tempdialog.setmodal(true); dimension tempscreen = toolkit.getdefaulttoolkit().getscreensize(); tempdialog.setsize(tempscreen.width \/ 2, tempscreen.height \/ 2); tempdialog.setlocation(tempscreen.width \/ 4, tempscreen.height \/ 4); tempdialog.getcontentpane().setlayout(new borderlayout()); scrollpane tempscrollpane = new scrollpane(); jeditorpane tempeditorpane = new jeditorpane(); tempeditorpane.setfont(new font(\"monospaced\", 0, aframe.getfont().getsize())); tempeditorpane.settext(tempstringwriter.tostring()); tempscrollpane.add(tempeditorpane); tempdialog.getcontentpane().add(tempscrollpane, borderlayout.center); action tempactionlistener = new abstractaction(\"ok\") { @override public void actionperformed(actionevent ae) { tempdialog.dispose(); } }; tempdialog.getcontentpane().add(createbuttons(new action[] { tempactionlistener }), borderlayout.south); tempdialog.setdefaultcloseoperation(jdialog.dispose_on_close); tempdialog.setvisible(true); }","comment":"\/\/ todo replace by font.monospaced with jdk 6","repo":"rscadrde\/projekt-task-capturing","code_context_2":"ScrollPane tempScrollPane = new ScrollPane();\nJEditorPane tempEditorPane = new JEditorPane();\n\/\/ TODO Replace by Font.MONOSPACED with JDK 6\ntempEditorPane.setFont(new Font(\"Monospaced\", 0, aFrame.getFont().getSize()));\ntempEditorPane.setText(tempStringWriter.toString());","code_context_10":"aE.printStackTrace(tempPrintWriter);\ntempPrintWriter.close();\nfinal JDialog tempDialog = new JDialog(aFrame, \"Error: \" + aE.getMessage());\ntempDialog.setModal(true);\nDimension tempScreen = Toolkit.getDefaultToolkit().getScreenSize();\ntempDialog.setSize(tempScreen.width \/ 2, tempScreen.height \/ 2);\ntempDialog.setLocation(tempScreen.width \/ 4, tempScreen.height \/ 4);\ntempDialog.getContentPane().setLayout(new BorderLayout());\nScrollPane tempScrollPane = new ScrollPane();\nJEditorPane tempEditorPane = new JEditorPane();\n\/\/ TODO Replace by Font.MONOSPACED with JDK 6\ntempEditorPane.setFont(new Font(\"Monospaced\", 0, aFrame.getFont().getSize()));\ntempEditorPane.setText(tempStringWriter.toString());\ntempScrollPane.add(tempEditorPane);\ntempDialog.getContentPane().add(tempScrollPane, BorderLayout.CENTER);\nAction tempActionListener = new AbstractAction(\"OK\") {\n@Override\npublic void actionPerformed(ActionEvent aE) {\ntempDialog.dispose();\n}\n};","code_context_20":"private static void displayExceptionPrivate(JFrame aFrame, Throwable aE) {\nStringWriter tempStringWriter = new StringWriter();\nPrintWriter tempPrintWriter = new PrintWriter(tempStringWriter);\naE.printStackTrace(tempPrintWriter);\ntempPrintWriter.close();\nfinal JDialog tempDialog = new JDialog(aFrame, \"Error: \" + aE.getMessage());\ntempDialog.setModal(true);\nDimension tempScreen = Toolkit.getDefaultToolkit().getScreenSize();\ntempDialog.setSize(tempScreen.width \/ 2, tempScreen.height \/ 2);\ntempDialog.setLocation(tempScreen.width \/ 4, tempScreen.height \/ 4);\ntempDialog.getContentPane().setLayout(new BorderLayout());\nScrollPane tempScrollPane = new ScrollPane();\nJEditorPane tempEditorPane = new JEditorPane();\n\/\/ TODO Replace by Font.MONOSPACED with JDK 6\ntempEditorPane.setFont(new Font(\"Monospaced\", 0, aFrame.getFont().getSize()));\ntempEditorPane.setText(tempStringWriter.toString());\ntempScrollPane.add(tempEditorPane);\ntempDialog.getContentPane().add(tempScrollPane, BorderLayout.CENTER);\nAction tempActionListener = new AbstractAction(\"OK\") {\n@Override\npublic void actionPerformed(ActionEvent aE) {\ntempDialog.dispose();\n}\n};\ntempDialog.getContentPane().add(createButtons(new Action[] { tempActionListener }), BorderLayout.SOUTH);\ntempDialog.setDefaultCloseOperation(JDialog.DISPOSE_ON_CLOSE);\ntempDialog.setVisible(true);\n}","label":[1,0,0,0]}
{"id":13240,"original_code":"private static void displayTextPrivate(JFrame aFrame, String aTitle, String aText, boolean aModalFlag, List<Action> anActions) {\n\t\tfinal JDialog tempDialog = new JDialog(aFrame, aTitle);\n\t\ttempDialog.setModal(aModalFlag);\n\t\tDimension tempScreen = Toolkit.getDefaultToolkit().getScreenSize();\n\t\ttempDialog.setSize(tempScreen.width * 4 \/ 10, tempScreen.height * 4 \/ 5);\n\t\ttempDialog.setLocation(tempScreen.width \/ 4, tempScreen.height \/ 10);\n\t\ttempDialog.getContentPane().setLayout(new BorderLayout());\n\t\tScrollPane tempScrollPane = new ScrollPane();\n\t\tJEditorPane tempEditorPane = new JEditorPane();\n\t\t\/\/ TODO Replace by Font.MONOSPACED with JDK 6\n\t\ttempEditorPane.setFont(new Font(\"Monospaced\", 0, aFrame.getFont().getSize()));\n\t\ttempEditorPane.setText(aText);\n\t\ttempScrollPane.add(tempEditorPane);\n\t\ttempDialog.getContentPane().add(tempScrollPane, BorderLayout.CENTER);\n\t\tAction tempActionListener = new AbstractAction(\"OK\") {\n\t\t\t@Override\n\t\t\tpublic void actionPerformed(ActionEvent aE) {\n\t\t\t\ttempDialog.dispose();\n\t\t\t}\n\t\t};\n\t\tList<Action> tempActions = new ArrayList<Action>();\n\t\ttempActions.add(tempActionListener);\n\t\tif (anActions != null) {\n\t\t\ttempActions.addAll(anActions);\n\t\t}\n\t\ttempDialog.getContentPane().add(createButtons(tempActions.toArray(new Action[tempActions.size()])), BorderLayout.SOUTH);\n\t\ttempDialog.setDefaultCloseOperation(JDialog.DISPOSE_ON_CLOSE);\n\t\ttempDialog.setAlwaysOnTop(false);\n\t\ttempDialog.setVisible(true);\n\t}","code":"private static void displayTextPrivate(JFrame aFrame, String aTitle, String aText, boolean aModalFlag, List<Action> anActions) {\n\t\tfinal JDialog tempDialog = new JDialog(aFrame, aTitle);\n\t\ttempDialog.setModal(aModalFlag);\n\t\tDimension tempScreen = Toolkit.getDefaultToolkit().getScreenSize();\n\t\ttempDialog.setSize(tempScreen.width * 4 \/ 10, tempScreen.height * 4 \/ 5);\n\t\ttempDialog.setLocation(tempScreen.width \/ 4, tempScreen.height \/ 10);\n\t\ttempDialog.getContentPane().setLayout(new BorderLayout());\n\t\tScrollPane tempScrollPane = new ScrollPane();\n\t\tJEditorPane tempEditorPane = new JEditorPane();\n\t\n\t\ttempEditorPane.setFont(new Font(\"Monospaced\", 0, aFrame.getFont().getSize()));\n\t\ttempEditorPane.setText(aText);\n\t\ttempScrollPane.add(tempEditorPane);\n\t\ttempDialog.getContentPane().add(tempScrollPane, BorderLayout.CENTER);\n\t\tAction tempActionListener = new AbstractAction(\"OK\") {\n\t\t\t@Override\n\t\t\tpublic void actionPerformed(ActionEvent aE) {\n\t\t\t\ttempDialog.dispose();\n\t\t\t}\n\t\t};\n\t\tList<Action> tempActions = new ArrayList<Action>();\n\t\ttempActions.add(tempActionListener);\n\t\tif (anActions != null) {\n\t\t\ttempActions.addAll(anActions);\n\t\t}\n\t\ttempDialog.getContentPane().add(createButtons(tempActions.toArray(new Action[tempActions.size()])), BorderLayout.SOUTH);\n\t\ttempDialog.setDefaultCloseOperation(JDialog.DISPOSE_ON_CLOSE);\n\t\ttempDialog.setAlwaysOnTop(false);\n\t\ttempDialog.setVisible(true);\n\t}","cleancode":"private static void displaytextprivate(jframe aframe, string atitle, string atext, boolean amodalflag, list<action> anactions) { final jdialog tempdialog = new jdialog(aframe, atitle); tempdialog.setmodal(amodalflag); dimension tempscreen = toolkit.getdefaulttoolkit().getscreensize(); tempdialog.setsize(tempscreen.width * 4 \/ 10, tempscreen.height * 4 \/ 5); tempdialog.setlocation(tempscreen.width \/ 4, tempscreen.height \/ 10); tempdialog.getcontentpane().setlayout(new borderlayout()); scrollpane tempscrollpane = new scrollpane(); jeditorpane tempeditorpane = new jeditorpane(); tempeditorpane.setfont(new font(\"monospaced\", 0, aframe.getfont().getsize())); tempeditorpane.settext(atext); tempscrollpane.add(tempeditorpane); tempdialog.getcontentpane().add(tempscrollpane, borderlayout.center); action tempactionlistener = new abstractaction(\"ok\") { @override public void actionperformed(actionevent ae) { tempdialog.dispose(); } }; list<action> tempactions = new arraylist<action>(); tempactions.add(tempactionlistener); if (anactions != null) { tempactions.addall(anactions); } tempdialog.getcontentpane().add(createbuttons(tempactions.toarray(new action[tempactions.size()])), borderlayout.south); tempdialog.setdefaultcloseoperation(jdialog.dispose_on_close); tempdialog.setalwaysontop(false); tempdialog.setvisible(true); }","comment":"\/\/ todo replace by font.monospaced with jdk 6","repo":"rscadrde\/projekt-task-capturing","code_context_2":"ScrollPane tempScrollPane = new ScrollPane();\nJEditorPane tempEditorPane = new JEditorPane();\n\/\/ TODO Replace by Font.MONOSPACED with JDK 6\ntempEditorPane.setFont(new Font(\"Monospaced\", 0, aFrame.getFont().getSize()));\ntempEditorPane.setText(aText);","code_context_10":"private static void displayTextPrivate(JFrame aFrame, String aTitle, String aText, boolean aModalFlag, List<Action> anActions) {\nfinal JDialog tempDialog = new JDialog(aFrame, aTitle);\ntempDialog.setModal(aModalFlag);\nDimension tempScreen = Toolkit.getDefaultToolkit().getScreenSize();\ntempDialog.setSize(tempScreen.width * 4 \/ 10, tempScreen.height * 4 \/ 5);\ntempDialog.setLocation(tempScreen.width \/ 4, tempScreen.height \/ 10);\ntempDialog.getContentPane().setLayout(new BorderLayout());\nScrollPane tempScrollPane = new ScrollPane();\nJEditorPane tempEditorPane = new JEditorPane();\n\/\/ TODO Replace by Font.MONOSPACED with JDK 6\ntempEditorPane.setFont(new Font(\"Monospaced\", 0, aFrame.getFont().getSize()));\ntempEditorPane.setText(aText);\ntempScrollPane.add(tempEditorPane);\ntempDialog.getContentPane().add(tempScrollPane, BorderLayout.CENTER);\nAction tempActionListener = new AbstractAction(\"OK\") {\n@Override\npublic void actionPerformed(ActionEvent aE) {\ntempDialog.dispose();\n}\n};","code_context_20":"private static void displayTextPrivate(JFrame aFrame, String aTitle, String aText, boolean aModalFlag, List<Action> anActions) {\nfinal JDialog tempDialog = new JDialog(aFrame, aTitle);\ntempDialog.setModal(aModalFlag);\nDimension tempScreen = Toolkit.getDefaultToolkit().getScreenSize();\ntempDialog.setSize(tempScreen.width * 4 \/ 10, tempScreen.height * 4 \/ 5);\ntempDialog.setLocation(tempScreen.width \/ 4, tempScreen.height \/ 10);\ntempDialog.getContentPane().setLayout(new BorderLayout());\nScrollPane tempScrollPane = new ScrollPane();\nJEditorPane tempEditorPane = new JEditorPane();\n\/\/ TODO Replace by Font.MONOSPACED with JDK 6\ntempEditorPane.setFont(new Font(\"Monospaced\", 0, aFrame.getFont().getSize()));\ntempEditorPane.setText(aText);\ntempScrollPane.add(tempEditorPane);\ntempDialog.getContentPane().add(tempScrollPane, BorderLayout.CENTER);\nAction tempActionListener = new AbstractAction(\"OK\") {\n@Override\npublic void actionPerformed(ActionEvent aE) {\ntempDialog.dispose();\n}\n};\nList<Action> tempActions = new ArrayList<Action>();\ntempActions.add(tempActionListener);\nif (anActions != null) {\ntempActions.addAll(anActions);\n}\ntempDialog.getContentPane().add(createButtons(tempActions.toArray(new Action[tempActions.size()])), BorderLayout.SOUTH);\ntempDialog.setDefaultCloseOperation(JDialog.DISPOSE_ON_CLOSE);\ntempDialog.setAlwaysOnTop(false);\ntempDialog.setVisible(true);\n}","label":[1,0,0,0]}
{"id":21707,"original_code":"private synchronized Bitmap getBitmapFromEntryIfNeeded(String entryName, boolean recycle)\n  {\n    Bitmap bitmap = null;\n    ImageState status = imageState.get(entryName);\n    if (status == null || status.equals(ImageState.UNKNOWN))\n    {\n      ZipEntry entry = mZip.getEntry(entryName);\n      try\n      {\n        File file = extract(entry, entry.getName());\n        BitmapFactory.decodeFile(file.getPath(), bounds);\n        if (bounds.outWidth == -1)\n        {\n          \/\/ TODO: Error\n        }\n        int width = bounds.outWidth;\n        int height = bounds.outHeight;\n        boolean landscape = height > width;\n        int maxHeight = getMaxHeight(landscape);\n        int maxWidth = getMaxWidth(landscape);\n        boolean withinBounds = width <= maxWidth && height <= maxHeight;\n        if (withinBounds)\n        {\n          imageState.put(entryName, ImageState.ORIGINAL);\n        }\n        else\n        {\n          bitmap = resampleAndSave(entryName, width, height);\n        }\n      }\n      catch (Exception e)\n      {\n        e.printStackTrace();\n      }\n    }\n    if (bitmap != null && recycle)\n    {\n      bitmap.recycle();\n      return null;\n    }\n    else\n    {\n      return bitmap;\n    }\n  }","code":"private synchronized Bitmap getBitmapFromEntryIfNeeded(String entryName, boolean recycle)\n  {\n    Bitmap bitmap = null;\n    ImageState status = imageState.get(entryName);\n    if (status == null || status.equals(ImageState.UNKNOWN))\n    {\n      ZipEntry entry = mZip.getEntry(entryName);\n      try\n      {\n        File file = extract(entry, entry.getName());\n        BitmapFactory.decodeFile(file.getPath(), bounds);\n        if (bounds.outWidth == -1)\n        {\n         \n        }\n        int width = bounds.outWidth;\n        int height = bounds.outHeight;\n        boolean landscape = height > width;\n        int maxHeight = getMaxHeight(landscape);\n        int maxWidth = getMaxWidth(landscape);\n        boolean withinBounds = width <= maxWidth && height <= maxHeight;\n        if (withinBounds)\n        {\n          imageState.put(entryName, ImageState.ORIGINAL);\n        }\n        else\n        {\n          bitmap = resampleAndSave(entryName, width, height);\n        }\n      }\n      catch (Exception e)\n      {\n        e.printStackTrace();\n      }\n    }\n    if (bitmap != null && recycle)\n    {\n      bitmap.recycle();\n      return null;\n    }\n    else\n    {\n      return bitmap;\n    }\n  }","cleancode":"private synchronized bitmap getbitmapfromentryifneeded(string entryname, boolean recycle) { bitmap bitmap = null; imagestate status = imagestate.get(entryname); if (status == null || status.equals(imagestate.unknown)) { zipentry entry = mzip.getentry(entryname); try { file file = extract(entry, entry.getname()); bitmapfactory.decodefile(file.getpath(), bounds); if (bounds.outwidth == -1) { } int width = bounds.outwidth; int height = bounds.outheight; boolean landscape = height > width; int maxheight = getmaxheight(landscape); int maxwidth = getmaxwidth(landscape); boolean withinbounds = width <= maxwidth && height <= maxheight; if (withinbounds) { imagestate.put(entryname, imagestate.original); } else { bitmap = resampleandsave(entryname, width, height); } } catch (exception e) { e.printstacktrace(); } } if (bitmap != null && recycle) { bitmap.recycle(); return null; } else { return bitmap; } }","comment":"\/\/ todo: error","repo":"remco138\/ocrmangareaderforandroid","code_context_2":"if (bounds.outWidth == -1)\n{\n\/\/ TODO: Error\n}\nint width = bounds.outWidth;","code_context_10":"ImageState status = imageState.get(entryName);\nif (status == null || status.equals(ImageState.UNKNOWN))\n{\nZipEntry entry = mZip.getEntry(entryName);\ntry\n{\nFile file = extract(entry, entry.getName());\nBitmapFactory.decodeFile(file.getPath(), bounds);\nif (bounds.outWidth == -1)\n{\n\/\/ TODO: Error\n}\nint width = bounds.outWidth;\nint height = bounds.outHeight;\nboolean landscape = height > width;\nint maxHeight = getMaxHeight(landscape);\nint maxWidth = getMaxWidth(landscape);\nboolean withinBounds = width <= maxWidth && height <= maxHeight;\nif (withinBounds)\n{\nimageState.put(entryName, ImageState.ORIGINAL);","code_context_20":"private synchronized Bitmap getBitmapFromEntryIfNeeded(String entryName, boolean recycle)\n{\nBitmap bitmap = null;\nImageState status = imageState.get(entryName);\nif (status == null || status.equals(ImageState.UNKNOWN))\n{\nZipEntry entry = mZip.getEntry(entryName);\ntry\n{\nFile file = extract(entry, entry.getName());\nBitmapFactory.decodeFile(file.getPath(), bounds);\nif (bounds.outWidth == -1)\n{\n\/\/ TODO: Error\n}\nint width = bounds.outWidth;\nint height = bounds.outHeight;\nboolean landscape = height > width;\nint maxHeight = getMaxHeight(landscape);\nint maxWidth = getMaxWidth(landscape);\nboolean withinBounds = width <= maxWidth && height <= maxHeight;\nif (withinBounds)\n{\nimageState.put(entryName, ImageState.ORIGINAL);\n}\nelse\n{\nbitmap = resampleAndSave(entryName, width, height);\n}\n}\ncatch (Exception e)\n{\ne.printStackTrace();\n}","label":[0,0,1,0]}
{"id":13922,"original_code":"public void setSimpleTag() {\n    \/* TODO: clear previously-set field and avoid memory leak *\/\n    t = Tag.SIMPLE_TAG;\n  }","code":"public void setSimpleTag() {\n   \n    t = Tag.SIMPLE_TAG;\n  }","cleancode":"public void setsimpletag() { t = tag.simple_tag; }","comment":"\/* todo: clear previously-set field and avoid memory leak *\/","repo":"syntakker\/atd","code_context_2":"public void setSimpleTag() {\n\/* TODO: clear previously-set field and avoid memory leak *\/\nt = Tag.SIMPLE_TAG;\n}","code_context_10":"public void setSimpleTag() {\n\/* TODO: clear previously-set field and avoid memory leak *\/\nt = Tag.SIMPLE_TAG;\n}","code_context_20":"public void setSimpleTag() {\n\/* TODO: clear previously-set field and avoid memory leak *\/\nt = Tag.SIMPLE_TAG;\n}","label":[0,1,0,0]}
{"id":22202,"original_code":"public EasySource getInnerText(char open, char close) {\n\t\tStringBuffer code = new StringBuffer();\n\t\tint brace_counter = 0;\n\t\twhile (true) {\n\t\t\tif (pos >= src.length) {\n\t\t\t\treturn null;\n\t\t\t}\n\t\t\tchar c = src[pos];\n\t\t\tif (c == open) { \/\/ TODO: what about open and close inside strings ?\n\t\t\t\tbrace_counter++;\n\t\t\t\t\/\/ code.appendInPlace(parse(rs, hook).src);\n\t\t\t\t\/\/ code.appendInPlace(close);\n\t\t\t}\n\t\t\tif (c == close) \/\/|| src[pos] == close)\n\t\t\t{\n\t\t\t\tif (brace_counter > 0)\n\t\t\t\t\tbrace_counter--;\n\t\t\t\telse {\n\t\t\t\t\tpos++;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tcode.append(c); \/\/ TODO: optimize\n\t\t\tpos++;\n\t\t}\n\t\treturn new EasySource(code.toString().toCharArray());\n\t}","code":"public EasySource getInnerText(char open, char close) {\n\t\tStringBuffer code = new StringBuffer();\n\t\tint brace_counter = 0;\n\t\twhile (true) {\n\t\t\tif (pos >= src.length) {\n\t\t\t\treturn null;\n\t\t\t}\n\t\t\tchar c = src[pos];\n\t\t\tif (c == open) {\n\t\t\t\tbrace_counter++;\n\t\t\t\n\t\t\t\n\t\t\t}\n\t\t\tif (c == close)\n\t\t\t{\n\t\t\t\tif (brace_counter > 0)\n\t\t\t\t\tbrace_counter--;\n\t\t\t\telse {\n\t\t\t\t\tpos++;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tcode.append(c);\n\t\t\tpos++;\n\t\t}\n\t\treturn new EasySource(code.toString().toCharArray());\n\t}","cleancode":"public easysource getinnertext(char open, char close) { stringbuffer code = new stringbuffer(); int brace_counter = 0; while (true) { if (pos >= src.length) { return null; } char c = src[pos]; if (c == open) { brace_counter++; } if (c == close) { if (brace_counter > 0) brace_counter--; else { pos++; break; } } code.append(c); pos++; } return new easysource(code.tostring().tochararray()); }","comment":"\/\/ todo: what about open and close inside strings ?\n\/\/ code.appendinplace(parse(rs, hook).src); \/\/ code.appendinplace(close);\n\/\/|| src[pos] == close)\n\/\/ todo: optimize","repo":"rhulha\/EasyLang","code_context_2":"}\nchar c = src[pos];\nif (c == open) { \/\/ TODO: what about open and close inside strings ?\nbrace_counter++;\n\/\/ code.appendInPlace(parse(rs, hook).src);\n\nif (c == open) { \/\/ TODO: what about open and close inside strings ?\nbrace_counter++;\n\/\/ code.appendInPlace(parse(rs, hook).src);\n\/\/ code.appendInPlace(close);\n}\nif (c == close) \/\/|| src[pos] == close)\n\n\/\/ code.appendInPlace(close);\n}\nif (c == close) \/\/|| src[pos] == close)\n{\nif (brace_counter > 0)\n\n}\n}\ncode.append(c); \/\/ TODO: optimize\npos++;\n}","code_context_10":"public EasySource getInnerText(char open, char close) {\nStringBuffer code = new StringBuffer();\nint brace_counter = 0;\nwhile (true) {\nif (pos >= src.length) {\nreturn null;\n}\nchar c = src[pos];\nif (c == open) { \/\/ TODO: what about open and close inside strings ?\nbrace_counter++;\n\/\/ code.appendInPlace(parse(rs, hook).src);\n\/\/ code.appendInPlace(close);\n}\nif (c == close) \/\/|| src[pos] == close)\n{\nif (brace_counter > 0)\nbrace_counter--;\nelse {\npos++;\n\npublic EasySource getInnerText(char open, char close) {\nStringBuffer code = new StringBuffer();\nint brace_counter = 0;\nwhile (true) {\nif (pos >= src.length) {\nreturn null;\n}\nchar c = src[pos];\nif (c == open) { \/\/ TODO: what about open and close inside strings ?\nbrace_counter++;\n\/\/ code.appendInPlace(parse(rs, hook).src);\n\/\/ code.appendInPlace(close);\n}\nif (c == close) \/\/|| src[pos] == close)\n{\nif (brace_counter > 0)\nbrace_counter--;\nelse {\npos++;\nbreak;\n}\n}\n\nwhile (true) {\nif (pos >= src.length) {\nreturn null;\n}\nchar c = src[pos];\nif (c == open) { \/\/ TODO: what about open and close inside strings ?\nbrace_counter++;\n\/\/ code.appendInPlace(parse(rs, hook).src);\n\/\/ code.appendInPlace(close);\n}\nif (c == close) \/\/|| src[pos] == close)\n{\nif (brace_counter > 0)\nbrace_counter--;\nelse {\npos++;\nbreak;\n}\n}\ncode.append(c); \/\/ TODO: optimize\npos++;\n\n}\nif (c == close) \/\/|| src[pos] == close)\n{\nif (brace_counter > 0)\nbrace_counter--;\nelse {\npos++;\nbreak;\n}\n}\ncode.append(c); \/\/ TODO: optimize\npos++;\n}\nreturn new EasySource(code.toString().toCharArray());\n}","code_context_20":"public EasySource getInnerText(char open, char close) {\nStringBuffer code = new StringBuffer();\nint brace_counter = 0;\nwhile (true) {\nif (pos >= src.length) {\nreturn null;\n}\nchar c = src[pos];\nif (c == open) { \/\/ TODO: what about open and close inside strings ?\nbrace_counter++;\n\/\/ code.appendInPlace(parse(rs, hook).src);\n\/\/ code.appendInPlace(close);\n}\nif (c == close) \/\/|| src[pos] == close)\n{\nif (brace_counter > 0)\nbrace_counter--;\nelse {\npos++;\nbreak;\n}\n}\ncode.append(c); \/\/ TODO: optimize\npos++;\n}\nreturn new EasySource(code.toString().toCharArray());\n}\n\npublic EasySource getInnerText(char open, char close) {\nStringBuffer code = new StringBuffer();\nint brace_counter = 0;\nwhile (true) {\nif (pos >= src.length) {\nreturn null;\n}\nchar c = src[pos];\nif (c == open) { \/\/ TODO: what about open and close inside strings ?\nbrace_counter++;\n\/\/ code.appendInPlace(parse(rs, hook).src);\n\/\/ code.appendInPlace(close);\n}\nif (c == close) \/\/|| src[pos] == close)\n{\nif (brace_counter > 0)\nbrace_counter--;\nelse {\npos++;\nbreak;\n}\n}\ncode.append(c); \/\/ TODO: optimize\npos++;\n}\nreturn new EasySource(code.toString().toCharArray());\n}\n\npublic EasySource getInnerText(char open, char close) {\nStringBuffer code = new StringBuffer();\nint brace_counter = 0;\nwhile (true) {\nif (pos >= src.length) {\nreturn null;\n}\nchar c = src[pos];\nif (c == open) { \/\/ TODO: what about open and close inside strings ?\nbrace_counter++;\n\/\/ code.appendInPlace(parse(rs, hook).src);\n\/\/ code.appendInPlace(close);\n}\nif (c == close) \/\/|| src[pos] == close)\n{\nif (brace_counter > 0)\nbrace_counter--;\nelse {\npos++;\nbreak;\n}\n}\ncode.append(c); \/\/ TODO: optimize\npos++;\n}\nreturn new EasySource(code.toString().toCharArray());\n}\n\nint brace_counter = 0;\nwhile (true) {\nif (pos >= src.length) {\nreturn null;\n}\nchar c = src[pos];\nif (c == open) { \/\/ TODO: what about open and close inside strings ?\nbrace_counter++;\n\/\/ code.appendInPlace(parse(rs, hook).src);\n\/\/ code.appendInPlace(close);\n}\nif (c == close) \/\/|| src[pos] == close)\n{\nif (brace_counter > 0)\nbrace_counter--;\nelse {\npos++;\nbreak;\n}\n}\ncode.append(c); \/\/ TODO: optimize\npos++;\n}\nreturn new EasySource(code.toString().toCharArray());\n}","label":[1,0,0,0]}
{"id":14027,"original_code":"public void finalizeReports(String currentSessionId) {\n    \/\/ TODO: Need to implement procedure to skip finalizing the current session when this is\n    \/\/  called on app start, but keep the current session when called at crash time. Currently\n    \/\/  this only works when called at app start.\n    List<File> sessionDirectories = capAndGetOpenSessions(currentSessionId);\n    for (File sessionDirectory : sessionDirectories) {\n      final List<File> eventFiles =\n          getFilesInDirectory(\n              sessionDirectory, (f, name) -> name.startsWith(EVENT_FILE_NAME_PREFIX));\n      Collections.sort(eventFiles);\n      \/\/ TODO: Fix nulls\n      \/\/ Only process the session if it has associated events\n      if (!eventFiles.isEmpty()) {\n        final List<Event> events = new ArrayList<>();\n        boolean isHighPriorityReport = false;\n        for (File eventFile : eventFiles) {\n          final Event event = TRANSFORM.eventFromJson(readTextFile(eventFile));\n          isHighPriorityReport =\n              isHighPriorityReport || isHighPriorityEventFile(eventFile.getName());\n          events.add(event);\n        }\n        \/\/ FIXME: If we fail to parse the events, we'll need to bail.\n        String userId = null;\n        final File userFile = new File(sessionDirectory, USER_FILE_NAME);\n        if (userFile.exists()) {\n          userId = readTextFile(userFile);\n        }\n        CrashlyticsReport report =\n            TRANSFORM.reportFromJson(readTextFile(new File(sessionDirectory, REPORT_FILE_NAME)));\n        final String sessionId = report.getSession().getIdentifier();\n        if (userId != null) {\n          report = report.withUserId(userId);\n        }\n        final File outputDirectory =\n            prepareDirectory(isHighPriorityReport ? priorityReportsDirectory : reportsDirectory);\n        writeTextFile(\n            new File(outputDirectory, sessionId),\n            TRANSFORM.reportToJson(report.withEvents(ImmutableList.from(events))));\n      }\n      recursiveDelete(sessionDirectory);\n    }\n    capFinalizedReports();\n  }","code":"public void finalizeReports(String currentSessionId) {\n   \n   \n   \n    List<File> sessionDirectories = capAndGetOpenSessions(currentSessionId);\n    for (File sessionDirectory : sessionDirectories) {\n      final List<File> eventFiles =\n          getFilesInDirectory(\n              sessionDirectory, (f, name) -> name.startsWith(EVENT_FILE_NAME_PREFIX));\n      Collections.sort(eventFiles);\n     \n     \n      if (!eventFiles.isEmpty()) {\n        final List<Event> events = new ArrayList<>();\n        boolean isHighPriorityReport = false;\n        for (File eventFile : eventFiles) {\n          final Event event = TRANSFORM.eventFromJson(readTextFile(eventFile));\n          isHighPriorityReport =\n              isHighPriorityReport || isHighPriorityEventFile(eventFile.getName());\n          events.add(event);\n        }\n       \n        String userId = null;\n        final File userFile = new File(sessionDirectory, USER_FILE_NAME);\n        if (userFile.exists()) {\n          userId = readTextFile(userFile);\n        }\n        CrashlyticsReport report =\n            TRANSFORM.reportFromJson(readTextFile(new File(sessionDirectory, REPORT_FILE_NAME)));\n        final String sessionId = report.getSession().getIdentifier();\n        if (userId != null) {\n          report = report.withUserId(userId);\n        }\n        final File outputDirectory =\n            prepareDirectory(isHighPriorityReport ? priorityReportsDirectory : reportsDirectory);\n        writeTextFile(\n            new File(outputDirectory, sessionId),\n            TRANSFORM.reportToJson(report.withEvents(ImmutableList.from(events))));\n      }\n      recursiveDelete(sessionDirectory);\n    }\n    capFinalizedReports();\n  }","cleancode":"public void finalizereports(string currentsessionid) { list<file> sessiondirectories = capandgetopensessions(currentsessionid); for (file sessiondirectory : sessiondirectories) { final list<file> eventfiles = getfilesindirectory( sessiondirectory, (f, name) -> name.startswith(event_file_name_prefix)); collections.sort(eventfiles); if (!eventfiles.isempty()) { final list<event> events = new arraylist<>(); boolean ishighpriorityreport = false; for (file eventfile : eventfiles) { final event event = transform.eventfromjson(readtextfile(eventfile)); ishighpriorityreport = ishighpriorityreport || ishighpriorityeventfile(eventfile.getname()); events.add(event); } string userid = null; final file userfile = new file(sessiondirectory, user_file_name); if (userfile.exists()) { userid = readtextfile(userfile); } crashlyticsreport report = transform.reportfromjson(readtextfile(new file(sessiondirectory, report_file_name))); final string sessionid = report.getsession().getidentifier(); if (userid != null) { report = report.withuserid(userid); } final file outputdirectory = preparedirectory(ishighpriorityreport ? priorityreportsdirectory : reportsdirectory); writetextfile( new file(outputdirectory, sessionid), transform.reporttojson(report.withevents(immutablelist.from(events)))); } recursivedelete(sessiondirectory); } capfinalizedreports(); }","comment":"\/\/ todo: deal with potential runtime exceptions\n\/\/ todo: need to implement procedure to skip finalizing the current session when this is \/\/ called on app start, but keep the current session when called at crash time. currently \/\/ this only works when called at app start.\n\/\/ todo: fix nulls \/\/ only process the session if it has associated events\n\/\/ fixme: if we fail to parse the events, we'll need to bail.","repo":"sevax88\/firebase-android-sdk","code_context_2":"public void finalizeReports(String currentSessionId) {\n\/\/ TODO: Need to implement procedure to skip finalizing the current session when this is\n\/\/ called on app start, but keep the current session when called at crash time. Currently\n\/\/ this only works when called at app start.\nList<File> sessionDirectories = capAndGetOpenSessions(currentSessionId);\nfor (File sessionDirectory : sessionDirectories) {\nfinal List<File> eventFiles =\ngetFilesInDirectory(\nsessionDirectory, (f, name) -> name.startsWith(EVENT_FILE_NAME_PREFIX));\nCollections.sort(eventFiles);\n\/\/ TODO: Fix nulls\n\/\/ Only process the session if it has associated events\nif (!eventFiles.isEmpty()) {\nfinal List<Event> events = new ArrayList<>();\nboolean isHighPriorityReport = false;\nfor (File eventFile : eventFiles) {\nfinal Event event = TRANSFORM.eventFromJson(readTextFile(eventFile));\nisHighPriorityReport =\nisHighPriorityReport || isHighPriorityEventFile(eventFile.getName());\nevents.add(event);\n}\n\/\/ FIXME: If we fail to parse the events, we'll need to bail.\nString userId = null;\nfinal File userFile = new File(sessionDirectory, USER_FILE_NAME);\nif (userFile.exists()) {\nuserId = readTextFile(userFile);\n}\nCrashlyticsReport report =\nTRANSFORM.reportFromJson(readTextFile(new File(sessionDirectory, REPORT_FILE_NAME)));\nfinal String sessionId = report.getSession().getIdentifier();\nif (userId != null) {\nreport = report.withUserId(userId);\n}\nfinal File outputDirectory =\nprepareDirectory(isHighPriorityReport ? priorityReportsDirectory : reportsDirectory);\nwriteTextFile(\nnew File(outputDirectory, sessionId),\nTRANSFORM.reportToJson(report.withEvents(ImmutableList.from(events))));\n}\nrecursiveDelete(sessionDirectory);\n}\ncapFinalizedReports();\n}\n\npublic void finalizeReports(String currentSessionId) {\n\/\/ TODO: Need to implement procedure to skip finalizing the current session when this is\n\/\/ called on app start, but keep the current session when called at crash time. Currently\n\/\/ this only works when called at app start.\nList<File> sessionDirectories = capAndGetOpenSessions(currentSessionId);\nfor (File sessionDirectory : sessionDirectories) {\n\nsessionDirectory, (f, name) -> name.startsWith(EVENT_FILE_NAME_PREFIX));\nCollections.sort(eventFiles);\n\/\/ TODO: Fix nulls\n\/\/ Only process the session if it has associated events\nif (!eventFiles.isEmpty()) {\nfinal List<Event> events = new ArrayList<>();\n\nevents.add(event);\n}\n\/\/ FIXME: If we fail to parse the events, we'll need to bail.\nString userId = null;\nfinal File userFile = new File(sessionDirectory, USER_FILE_NAME);","code_context_10":"public void finalizeReports(String currentSessionId) {\n\/\/ TODO: Need to implement procedure to skip finalizing the current session when this is\n\/\/ called on app start, but keep the current session when called at crash time. Currently\n\/\/ this only works when called at app start.\nList<File> sessionDirectories = capAndGetOpenSessions(currentSessionId);\nfor (File sessionDirectory : sessionDirectories) {\nfinal List<File> eventFiles =\ngetFilesInDirectory(\nsessionDirectory, (f, name) -> name.startsWith(EVENT_FILE_NAME_PREFIX));\nCollections.sort(eventFiles);\n\/\/ TODO: Fix nulls\n\/\/ Only process the session if it has associated events\nif (!eventFiles.isEmpty()) {\nfinal List<Event> events = new ArrayList<>();\nboolean isHighPriorityReport = false;\nfor (File eventFile : eventFiles) {\nfinal Event event = TRANSFORM.eventFromJson(readTextFile(eventFile));\nisHighPriorityReport =\nisHighPriorityReport || isHighPriorityEventFile(eventFile.getName());\nevents.add(event);\n}\n\/\/ FIXME: If we fail to parse the events, we'll need to bail.\nString userId = null;\nfinal File userFile = new File(sessionDirectory, USER_FILE_NAME);\nif (userFile.exists()) {\nuserId = readTextFile(userFile);\n}\nCrashlyticsReport report =\nTRANSFORM.reportFromJson(readTextFile(new File(sessionDirectory, REPORT_FILE_NAME)));\nfinal String sessionId = report.getSession().getIdentifier();\nif (userId != null) {\nreport = report.withUserId(userId);\n}\nfinal File outputDirectory =\nprepareDirectory(isHighPriorityReport ? priorityReportsDirectory : reportsDirectory);\nwriteTextFile(\nnew File(outputDirectory, sessionId),\nTRANSFORM.reportToJson(report.withEvents(ImmutableList.from(events))));\n}\nrecursiveDelete(sessionDirectory);\n}\ncapFinalizedReports();\n}\n\npublic void finalizeReports(String currentSessionId) {\n\/\/ TODO: Need to implement procedure to skip finalizing the current session when this is\n\/\/ called on app start, but keep the current session when called at crash time. Currently\n\/\/ this only works when called at app start.\nList<File> sessionDirectories = capAndGetOpenSessions(currentSessionId);\nfor (File sessionDirectory : sessionDirectories) {\nfinal List<File> eventFiles =\ngetFilesInDirectory(\nsessionDirectory, (f, name) -> name.startsWith(EVENT_FILE_NAME_PREFIX));\nCollections.sort(eventFiles);\n\/\/ TODO: Fix nulls\n\/\/ Only process the session if it has associated events\nif (!eventFiles.isEmpty()) {\nfinal List<Event> events = new ArrayList<>();\n\npublic void finalizeReports(String currentSessionId) {\n\/\/ TODO: Need to implement procedure to skip finalizing the current session when this is\n\/\/ called on app start, but keep the current session when called at crash time. Currently\n\/\/ this only works when called at app start.\nList<File> sessionDirectories = capAndGetOpenSessions(currentSessionId);\nfor (File sessionDirectory : sessionDirectories) {\nfinal List<File> eventFiles =\ngetFilesInDirectory(\nsessionDirectory, (f, name) -> name.startsWith(EVENT_FILE_NAME_PREFIX));\nCollections.sort(eventFiles);\n\/\/ TODO: Fix nulls\n\/\/ Only process the session if it has associated events\nif (!eventFiles.isEmpty()) {\nfinal List<Event> events = new ArrayList<>();\nboolean isHighPriorityReport = false;\nfor (File eventFile : eventFiles) {\nfinal Event event = TRANSFORM.eventFromJson(readTextFile(eventFile));\nisHighPriorityReport =\nisHighPriorityReport || isHighPriorityEventFile(eventFile.getName());\nevents.add(event);\n}\n\/\/ FIXME: If we fail to parse the events, we'll need to bail.\n\n\/\/ Only process the session if it has associated events\nif (!eventFiles.isEmpty()) {\nfinal List<Event> events = new ArrayList<>();\nboolean isHighPriorityReport = false;\nfor (File eventFile : eventFiles) {\nfinal Event event = TRANSFORM.eventFromJson(readTextFile(eventFile));\nisHighPriorityReport =\nisHighPriorityReport || isHighPriorityEventFile(eventFile.getName());\nevents.add(event);\n}\n\/\/ FIXME: If we fail to parse the events, we'll need to bail.\nString userId = null;\nfinal File userFile = new File(sessionDirectory, USER_FILE_NAME);\nif (userFile.exists()) {\nuserId = readTextFile(userFile);\n}\nCrashlyticsReport report =\nTRANSFORM.reportFromJson(readTextFile(new File(sessionDirectory, REPORT_FILE_NAME)));\nfinal String sessionId = report.getSession().getIdentifier();\nif (userId != null) {\nreport = report.withUserId(userId);","code_context_20":"public void finalizeReports(String currentSessionId) {\n\/\/ TODO: Need to implement procedure to skip finalizing the current session when this is\n\/\/ called on app start, but keep the current session when called at crash time. Currently\n\/\/ this only works when called at app start.\nList<File> sessionDirectories = capAndGetOpenSessions(currentSessionId);\nfor (File sessionDirectory : sessionDirectories) {\nfinal List<File> eventFiles =\ngetFilesInDirectory(\nsessionDirectory, (f, name) -> name.startsWith(EVENT_FILE_NAME_PREFIX));\nCollections.sort(eventFiles);\n\/\/ TODO: Fix nulls\n\/\/ Only process the session if it has associated events\nif (!eventFiles.isEmpty()) {\nfinal List<Event> events = new ArrayList<>();\nboolean isHighPriorityReport = false;\nfor (File eventFile : eventFiles) {\nfinal Event event = TRANSFORM.eventFromJson(readTextFile(eventFile));\nisHighPriorityReport =\nisHighPriorityReport || isHighPriorityEventFile(eventFile.getName());\nevents.add(event);\n}\n\/\/ FIXME: If we fail to parse the events, we'll need to bail.\nString userId = null;\nfinal File userFile = new File(sessionDirectory, USER_FILE_NAME);\nif (userFile.exists()) {\nuserId = readTextFile(userFile);\n}\nCrashlyticsReport report =\nTRANSFORM.reportFromJson(readTextFile(new File(sessionDirectory, REPORT_FILE_NAME)));\nfinal String sessionId = report.getSession().getIdentifier();\nif (userId != null) {\nreport = report.withUserId(userId);\n}\nfinal File outputDirectory =\nprepareDirectory(isHighPriorityReport ? priorityReportsDirectory : reportsDirectory);\nwriteTextFile(\nnew File(outputDirectory, sessionId),\nTRANSFORM.reportToJson(report.withEvents(ImmutableList.from(events))));\n}\nrecursiveDelete(sessionDirectory);\n}\ncapFinalizedReports();\n}\n\npublic void finalizeReports(String currentSessionId) {\n\/\/ TODO: Need to implement procedure to skip finalizing the current session when this is\n\/\/ called on app start, but keep the current session when called at crash time. Currently\n\/\/ this only works when called at app start.\nList<File> sessionDirectories = capAndGetOpenSessions(currentSessionId);\nfor (File sessionDirectory : sessionDirectories) {\nfinal List<File> eventFiles =\ngetFilesInDirectory(\nsessionDirectory, (f, name) -> name.startsWith(EVENT_FILE_NAME_PREFIX));\nCollections.sort(eventFiles);\n\/\/ TODO: Fix nulls\n\/\/ Only process the session if it has associated events\nif (!eventFiles.isEmpty()) {\nfinal List<Event> events = new ArrayList<>();\nboolean isHighPriorityReport = false;\nfor (File eventFile : eventFiles) {\nfinal Event event = TRANSFORM.eventFromJson(readTextFile(eventFile));\nisHighPriorityReport =\nisHighPriorityReport || isHighPriorityEventFile(eventFile.getName());\nevents.add(event);\n}\n\/\/ FIXME: If we fail to parse the events, we'll need to bail.\nString userId = null;\nfinal File userFile = new File(sessionDirectory, USER_FILE_NAME);\n\npublic void finalizeReports(String currentSessionId) {\n\/\/ TODO: Need to implement procedure to skip finalizing the current session when this is\n\/\/ called on app start, but keep the current session when called at crash time. Currently\n\/\/ this only works when called at app start.\nList<File> sessionDirectories = capAndGetOpenSessions(currentSessionId);\nfor (File sessionDirectory : sessionDirectories) {\nfinal List<File> eventFiles =\ngetFilesInDirectory(\nsessionDirectory, (f, name) -> name.startsWith(EVENT_FILE_NAME_PREFIX));\nCollections.sort(eventFiles);\n\/\/ TODO: Fix nulls\n\/\/ Only process the session if it has associated events\nif (!eventFiles.isEmpty()) {\nfinal List<Event> events = new ArrayList<>();\nboolean isHighPriorityReport = false;\nfor (File eventFile : eventFiles) {\nfinal Event event = TRANSFORM.eventFromJson(readTextFile(eventFile));\nisHighPriorityReport =\nisHighPriorityReport || isHighPriorityEventFile(eventFile.getName());\nevents.add(event);\n}\n\/\/ FIXME: If we fail to parse the events, we'll need to bail.\nString userId = null;\nfinal File userFile = new File(sessionDirectory, USER_FILE_NAME);\nif (userFile.exists()) {\nuserId = readTextFile(userFile);\n}\nCrashlyticsReport report =\nTRANSFORM.reportFromJson(readTextFile(new File(sessionDirectory, REPORT_FILE_NAME)));\nfinal String sessionId = report.getSession().getIdentifier();\nif (userId != null) {\nreport = report.withUserId(userId);\n\n\/\/ TODO: Need to implement procedure to skip finalizing the current session when this is\n\/\/ called on app start, but keep the current session when called at crash time. Currently\n\/\/ this only works when called at app start.\nList<File> sessionDirectories = capAndGetOpenSessions(currentSessionId);\nfor (File sessionDirectory : sessionDirectories) {\nfinal List<File> eventFiles =\ngetFilesInDirectory(\nsessionDirectory, (f, name) -> name.startsWith(EVENT_FILE_NAME_PREFIX));\nCollections.sort(eventFiles);\n\/\/ TODO: Fix nulls\n\/\/ Only process the session if it has associated events\nif (!eventFiles.isEmpty()) {\nfinal List<Event> events = new ArrayList<>();\nboolean isHighPriorityReport = false;\nfor (File eventFile : eventFiles) {\nfinal Event event = TRANSFORM.eventFromJson(readTextFile(eventFile));\nisHighPriorityReport =\nisHighPriorityReport || isHighPriorityEventFile(eventFile.getName());\nevents.add(event);\n}\n\/\/ FIXME: If we fail to parse the events, we'll need to bail.\nString userId = null;\nfinal File userFile = new File(sessionDirectory, USER_FILE_NAME);\nif (userFile.exists()) {\nuserId = readTextFile(userFile);\n}\nCrashlyticsReport report =\nTRANSFORM.reportFromJson(readTextFile(new File(sessionDirectory, REPORT_FILE_NAME)));\nfinal String sessionId = report.getSession().getIdentifier();\nif (userId != null) {\nreport = report.withUserId(userId);\n}\nfinal File outputDirectory =\nprepareDirectory(isHighPriorityReport ? priorityReportsDirectory : reportsDirectory);\nwriteTextFile(\nnew File(outputDirectory, sessionId),\nTRANSFORM.reportToJson(report.withEvents(ImmutableList.from(events))));\n}\nrecursiveDelete(sessionDirectory);\n}\ncapFinalizedReports();","label":[0,1,1,0]}
{"id":30415,"original_code":"private Optional<List<Relation>> processDefaultRelation(final Relation relation,\n            final List<Long> parents)\n    {\n        final List<Relation> createdRelations = new ArrayList<>();\n        final List<RelationMember> members = new ArrayList<>();\n        boolean isModified = false;\n        for (final RelationMember member : relation.getMembers())\n        {\n            switch (member.getMemberType())\n            {\n                case Way:\n                    final List<Way> slicedWays = this.changeSet\n                            .getCreatedWays(member.getMemberId());\n                    if (slicedWays != null && !slicedWays.isEmpty())\n                    {\n                        isModified = true;\n                        slicedWays.forEach(way -> members\n                                .add(this.store.createRelationMember(member, way.getId())));\n                    }\n                    else\n                    {\n                        \/\/ Either the way is not sliced or way is outside of the supplied bound\n                        members.add(member);\n                    }\n                    break;\n                case Relation:\n                    parents.add(relation.getId());\n                    final Relation subRelation = this.store.getRelation(member.getMemberId());\n                    \/\/ Check if we have the sub-relation in the store\n                    if (subRelation == null)\n                    {\n                        \/\/ Put the member back into the relation. Missing members will be handled\n                        \/\/ on a case by case basis\n                        members.add(member);\n                        break;\n                    }\n                    final Optional<List<Relation>> slicedMembers;\n                    if (!parents.contains(subRelation.getId()))\n                    {\n                        slicedMembers = sliceRelation(subRelation, parents);\n                    }\n                    else\n                    {\n                        logger.error(\"Relation {} has a loop! Parent tree: {}\", subRelation.getId(),\n                                parents);\n                        slicedMembers = Optional.empty();\n                    }\n                    if (slicedMembers.isPresent())\n                    {\n                        isModified = true;\n                        slicedMembers.get().forEach(slicedRelation ->\n                        {\n                            members.add(this.store.createRelationMember(member,\n                                    slicedRelation.getId()));\n                        });\n                    }\n                    else\n                    {\n                        members.add(member);\n                    }\n                    break;\n                default:\n                    \/\/ Here we are not checking the bound, because we are assuming all data\n                    \/\/ outside of bound has already been filtered out and doesn't exist in the\n                    \/\/ PbfMemoryStore\n                    members.add(member);\n                    break;\n            }\n        }\n        if (isModified)\n        {\n            \/\/ Modified by way slicing or relation slicing\n            this.changeSet.addModifiedRelation(relation);\n        }\n        \/\/ Group entities by country\n        final Map<String, List<RelationMember>> countryEntityMap = members.stream()\n                .collect(Collectors.groupingBy(member ->\n                {\n                    final Entity entity = this.store.getEntity(member);\n                    if (Objects.isNull(entity))\n                    {\n                        return ISOCountryTag.COUNTRY_MISSING;\n                    }\n                    else\n                    {\n                        final Optional<Tag> countryCodeTag = entity.getTags().stream()\n                                .filter(tag -> tag.getKey().equals(ISOCountryTag.KEY)).findFirst();\n                        if (countryCodeTag.isPresent())\n                        {\n                            return countryCodeTag.get().getValue();\n                        }\n                        else\n                        {\n                            return ISOCountryTag.COUNTRY_MISSING;\n                        }\n                    }\n                }));\n        final List<RelationMember> memberWithoutCountry;\n        if (countryEntityMap.containsKey(ISOCountryTag.COUNTRY_MISSING))\n        {\n            memberWithoutCountry = countryEntityMap.remove(ISOCountryTag.COUNTRY_MISSING);\n        }\n        else\n        {\n            memberWithoutCountry = Collections.emptyList();\n        }\n        final int countryCount = countryEntityMap.size();\n        if (countryCount == 0)\n        {\n            relation.getTags().add(new Tag(ISOCountryTag.KEY, ISOCountryTag.COUNTRY_MISSING));\n            return Optional.empty();\n        }\n        else if (countryCount == 1)\n        {\n            \/\/ One country code found, assign it\n            relation.getTags()\n                    .add(new Tag(ISOCountryTag.KEY, countryEntityMap.keySet().iterator().next()));\n            return Optional.empty();\n        }\n        else\n        {\n            \/\/ Muliple country codes found, implies relation crosses countries. As a 2 dimensional\n            \/\/ feature, relation sliced should not have more than one piece for each country. For\n            \/\/ now, for features without a country code (nodes and feature not covered by any\n            \/\/ boundary), we put a copy for every sliced piece to ensure integrity.\n            RuntimeCounter.relationSliced();\n            this.changeSet.addDeletedRelation(relation);\n            final CountrySlicingIdentifierFactory relationIdFactory = new CountrySlicingIdentifierFactory(\n                    relation.getId());\n            countryEntityMap.entrySet().forEach(entry ->\n            {\n                final List<RelationMember> candidateMembers = new ArrayList<>();\n                candidateMembers.addAll(entry.getValue());\n                candidateMembers.addAll(memberWithoutCountry);\n                if (!candidateMembers.isEmpty())\n                {\n                    final Relation relationToAdd = this.store.createRelation(relation,\n                            relationIdFactory.nextIdentifier(), candidateMembers);\n                    \/\/ TODO Consider sharing CountryCode Tag objects\n                    relationToAdd.getTags().add(new Tag(ISOCountryTag.KEY, entry.getKey()));\n                    createdRelations.add(relationToAdd);\n                    this.changeSet.addCreatedRelation(relationToAdd);\n                }\n            });\n        }\n        return Optional.of(createdRelations);\n    }","code":"private Optional<List<Relation>> processDefaultRelation(final Relation relation,\n            final List<Long> parents)\n    {\n        final List<Relation> createdRelations = new ArrayList<>();\n        final List<RelationMember> members = new ArrayList<>();\n        boolean isModified = false;\n        for (final RelationMember member : relation.getMembers())\n        {\n            switch (member.getMemberType())\n            {\n                case Way:\n                    final List<Way> slicedWays = this.changeSet\n                            .getCreatedWays(member.getMemberId());\n                    if (slicedWays != null && !slicedWays.isEmpty())\n                    {\n                        isModified = true;\n                        slicedWays.forEach(way -> members\n                                .add(this.store.createRelationMember(member, way.getId())));\n                    }\n                    else\n                    {\n                       \n                        members.add(member);\n                    }\n                    break;\n                case Relation:\n                    parents.add(relation.getId());\n                    final Relation subRelation = this.store.getRelation(member.getMemberId());\n                   \n                    if (subRelation == null)\n                    {\n                       \n                       \n                        members.add(member);\n                        break;\n                    }\n                    final Optional<List<Relation>> slicedMembers;\n                    if (!parents.contains(subRelation.getId()))\n                    {\n                        slicedMembers = sliceRelation(subRelation, parents);\n                    }\n                    else\n                    {\n                        logger.error(\"Relation {} has a loop! Parent tree: {}\", subRelation.getId(),\n                                parents);\n                        slicedMembers = Optional.empty();\n                    }\n                    if (slicedMembers.isPresent())\n                    {\n                        isModified = true;\n                        slicedMembers.get().forEach(slicedRelation ->\n                        {\n                            members.add(this.store.createRelationMember(member,\n                                    slicedRelation.getId()));\n                        });\n                    }\n                    else\n                    {\n                        members.add(member);\n                    }\n                    break;\n                default:\n                   \n                   \n                   \n                    members.add(member);\n                    break;\n            }\n        }\n        if (isModified)\n        {\n           \n            this.changeSet.addModifiedRelation(relation);\n        }\n       \n        final Map<String, List<RelationMember>> countryEntityMap = members.stream()\n                .collect(Collectors.groupingBy(member ->\n                {\n                    final Entity entity = this.store.getEntity(member);\n                    if (Objects.isNull(entity))\n                    {\n                        return ISOCountryTag.COUNTRY_MISSING;\n                    }\n                    else\n                    {\n                        final Optional<Tag> countryCodeTag = entity.getTags().stream()\n                                .filter(tag -> tag.getKey().equals(ISOCountryTag.KEY)).findFirst();\n                        if (countryCodeTag.isPresent())\n                        {\n                            return countryCodeTag.get().getValue();\n                        }\n                        else\n                        {\n                            return ISOCountryTag.COUNTRY_MISSING;\n                        }\n                    }\n                }));\n        final List<RelationMember> memberWithoutCountry;\n        if (countryEntityMap.containsKey(ISOCountryTag.COUNTRY_MISSING))\n        {\n            memberWithoutCountry = countryEntityMap.remove(ISOCountryTag.COUNTRY_MISSING);\n        }\n        else\n        {\n            memberWithoutCountry = Collections.emptyList();\n        }\n        final int countryCount = countryEntityMap.size();\n        if (countryCount == 0)\n        {\n            relation.getTags().add(new Tag(ISOCountryTag.KEY, ISOCountryTag.COUNTRY_MISSING));\n            return Optional.empty();\n        }\n        else if (countryCount == 1)\n        {\n           \n            relation.getTags()\n                    .add(new Tag(ISOCountryTag.KEY, countryEntityMap.keySet().iterator().next()));\n            return Optional.empty();\n        }\n        else\n        {\n           \n           \n           \n           \n            RuntimeCounter.relationSliced();\n            this.changeSet.addDeletedRelation(relation);\n            final CountrySlicingIdentifierFactory relationIdFactory = new CountrySlicingIdentifierFactory(\n                    relation.getId());\n            countryEntityMap.entrySet().forEach(entry ->\n            {\n                final List<RelationMember> candidateMembers = new ArrayList<>();\n                candidateMembers.addAll(entry.getValue());\n                candidateMembers.addAll(memberWithoutCountry);\n                if (!candidateMembers.isEmpty())\n                {\n                    final Relation relationToAdd = this.store.createRelation(relation,\n                            relationIdFactory.nextIdentifier(), candidateMembers);\n                   \n                    relationToAdd.getTags().add(new Tag(ISOCountryTag.KEY, entry.getKey()));\n                    createdRelations.add(relationToAdd);\n                    this.changeSet.addCreatedRelation(relationToAdd);\n                }\n            });\n        }\n        return Optional.of(createdRelations);\n    }","cleancode":"private optional<list<relation>> processdefaultrelation(final relation relation, final list<long> parents) { final list<relation> createdrelations = new arraylist<>(); final list<relationmember> members = new arraylist<>(); boolean ismodified = false; for (final relationmember member : relation.getmembers()) { switch (member.getmembertype()) { case way: final list<way> slicedways = this.changeset .getcreatedways(member.getmemberid()); if (slicedways != null && !slicedways.isempty()) { ismodified = true; slicedways.foreach(way -> members .add(this.store.createrelationmember(member, way.getid()))); } else { members.add(member); } break; case relation: parents.add(relation.getid()); final relation subrelation = this.store.getrelation(member.getmemberid()); if (subrelation == null) { members.add(member); break; } final optional<list<relation>> slicedmembers; if (!parents.contains(subrelation.getid())) { slicedmembers = slicerelation(subrelation, parents); } else { logger.error(\"relation {} has a loop! parent tree: {}\", subrelation.getid(), parents); slicedmembers = optional.empty(); } if (slicedmembers.ispresent()) { ismodified = true; slicedmembers.get().foreach(slicedrelation -> { members.add(this.store.createrelationmember(member, slicedrelation.getid())); }); } else { members.add(member); } break; default: members.add(member); break; } } if (ismodified) { this.changeset.addmodifiedrelation(relation); } final map<string, list<relationmember>> countryentitymap = members.stream() .collect(collectors.groupingby(member -> { final entity entity = this.store.getentity(member); if (objects.isnull(entity)) { return isocountrytag.country_missing; } else { final optional<tag> countrycodetag = entity.gettags().stream() .filter(tag -> tag.getkey().equals(isocountrytag.key)).findfirst(); if (countrycodetag.ispresent()) { return countrycodetag.get().getvalue(); } else { return isocountrytag.country_missing; } } })); final list<relationmember> memberwithoutcountry; if (countryentitymap.containskey(isocountrytag.country_missing)) { memberwithoutcountry = countryentitymap.remove(isocountrytag.country_missing); } else { memberwithoutcountry = collections.emptylist(); } final int countrycount = countryentitymap.size(); if (countrycount == 0) { relation.gettags().add(new tag(isocountrytag.key, isocountrytag.country_missing)); return optional.empty(); } else if (countrycount == 1) { relation.gettags() .add(new tag(isocountrytag.key, countryentitymap.keyset().iterator().next())); return optional.empty(); } else { runtimecounter.relationsliced(); this.changeset.adddeletedrelation(relation); final countryslicingidentifierfactory relationidfactory = new countryslicingidentifierfactory( relation.getid()); countryentitymap.entryset().foreach(entry -> { final list<relationmember> candidatemembers = new arraylist<>(); candidatemembers.addall(entry.getvalue()); candidatemembers.addall(memberwithoutcountry); if (!candidatemembers.isempty()) { final relation relationtoadd = this.store.createrelation(relation, relationidfactory.nextidentifier(), candidatemembers); relationtoadd.gettags().add(new tag(isocountrytag.key, entry.getkey())); createdrelations.add(relationtoadd); this.changeset.addcreatedrelation(relationtoadd); } }); } return optional.of(createdrelations); }","comment":"\/** * assign country codes for {@link relation}s. this is assuming all {@link way}s crossing * borders got cut and new {@link way}s were generated to fill the polygon. all we need to do * here is group them by country and split the members. * * @param relation * the {@link relation} to process. * @return all {@link relation}s produced after splitting the given {@link relation}. *\/\n\/\/ either the way is not sliced or way is outside of the supplied bound\n\/\/ check if we have the sub-relation in the store\n\/\/ put the member back into the relation. missing members will be handled \/\/ on a case by case basis\n\/\/ here we are not checking the bound, because we are assuming all data \/\/ outside of bound has already been filtered out and doesn't exist in the \/\/ pbfmemorystore\n\/\/ modified by way slicing or relation slicing\n\/\/ group entities by country\n\/\/ one country code found, assign it\n\/\/ muliple country codes found, implies relation crosses countries. as a 2 dimensional \/\/ feature, relation sliced should not have more than one piece for each country. for \/\/ now, for features without a country code (nodes and feature not covered by any \/\/ boundary), we put a copy for every sliced piece to ensure integrity.\n\/\/ todo consider sharing countrycode tag objects","repo":"savannahostrowski\/atlas","code_context_2":"private Optional<List<Relation>> processDefaultRelation(final Relation relation,\nfinal List<Long> parents)\n{\nfinal List<Relation> createdRelations = new ArrayList<>();\nfinal List<RelationMember> members = new ArrayList<>();\nboolean isModified = false;\nfor (final RelationMember member : relation.getMembers())\n{\nswitch (member.getMemberType())\n{\ncase Way:\nfinal List<Way> slicedWays = this.changeSet\n.getCreatedWays(member.getMemberId());\nif (slicedWays != null && !slicedWays.isEmpty())\n{\nisModified = true;\nslicedWays.forEach(way -> members\n.add(this.store.createRelationMember(member, way.getId())));\n}\nelse\n{\n\/\/ Either the way is not sliced or way is outside of the supplied bound\nmembers.add(member);\n}\nbreak;\ncase Relation:\nparents.add(relation.getId());\nfinal Relation subRelation = this.store.getRelation(member.getMemberId());\n\/\/ Check if we have the sub-relation in the store\nif (subRelation == null)\n{\n\/\/ Put the member back into the relation. Missing members will be handled\n\/\/ on a case by case basis\nmembers.add(member);\nbreak;\n}\nfinal Optional<List<Relation>> slicedMembers;\nif (!parents.contains(subRelation.getId()))\n{\nslicedMembers = sliceRelation(subRelation, parents);\n}\nelse\n{\nlogger.error(\"Relation {} has a loop! Parent tree: {}\", subRelation.getId(),\nparents);\nslicedMembers = Optional.empty();\n}\nif (slicedMembers.isPresent())\n{\nisModified = true;\nslicedMembers.get().forEach(slicedRelation ->\n{\nmembers.add(this.store.createRelationMember(member,\nslicedRelation.getId()));\n});\n}\nelse\n{\nmembers.add(member);\n}\nbreak;\ndefault:\n\/\/ Here we are not checking the bound, because we are assuming all data\n\/\/ outside of bound has already been filtered out and doesn't exist in the\n\/\/ PbfMemoryStore\nmembers.add(member);\nbreak;\n}\n}\nif (isModified)\n{\n\/\/ Modified by way slicing or relation slicing\nthis.changeSet.addModifiedRelation(relation);\n}\n\/\/ Group entities by country\nfinal Map<String, List<RelationMember>> countryEntityMap = members.stream()\n.collect(Collectors.groupingBy(member ->\n{\nfinal Entity entity = this.store.getEntity(member);\nif (Objects.isNull(entity))\n{\nreturn ISOCountryTag.COUNTRY_MISSING;\n}\nelse\n{\nfinal Optional<Tag> countryCodeTag = entity.getTags().stream()\n.filter(tag -> tag.getKey().equals(ISOCountryTag.KEY)).findFirst();\nif (countryCodeTag.isPresent())\n{\nreturn countryCodeTag.get().getValue();\n}\nelse\n{\nreturn ISOCountryTag.COUNTRY_MISSING;\n}\n}\n}));\nfinal List<RelationMember> memberWithoutCountry;\nif (countryEntityMap.containsKey(ISOCountryTag.COUNTRY_MISSING))\n{\nmemberWithoutCountry = countryEntityMap.remove(ISOCountryTag.COUNTRY_MISSING);\n}\nelse\n{\nmemberWithoutCountry = Collections.emptyList();\n}\nfinal int countryCount = countryEntityMap.size();\nif (countryCount == 0)\n{\nrelation.getTags().add(new Tag(ISOCountryTag.KEY, ISOCountryTag.COUNTRY_MISSING));\nreturn Optional.empty();\n}\nelse if (countryCount == 1)\n{\n\/\/ One country code found, assign it\nrelation.getTags()\n.add(new Tag(ISOCountryTag.KEY, countryEntityMap.keySet().iterator().next()));\nreturn Optional.empty();\n}\nelse\n{\n\/\/ Muliple country codes found, implies relation crosses countries. As a 2 dimensional\n\/\/ feature, relation sliced should not have more than one piece for each country. For\n\/\/ now, for features without a country code (nodes and feature not covered by any\n\/\/ boundary), we put a copy for every sliced piece to ensure integrity.\nRuntimeCounter.relationSliced();\nthis.changeSet.addDeletedRelation(relation);\nfinal CountrySlicingIdentifierFactory relationIdFactory = new CountrySlicingIdentifierFactory(\nrelation.getId());\ncountryEntityMap.entrySet().forEach(entry ->\n{\nfinal List<RelationMember> candidateMembers = new ArrayList<>();\ncandidateMembers.addAll(entry.getValue());\ncandidateMembers.addAll(memberWithoutCountry);\nif (!candidateMembers.isEmpty())\n{\nfinal Relation relationToAdd = this.store.createRelation(relation,\nrelationIdFactory.nextIdentifier(), candidateMembers);\n\/\/ TODO Consider sharing CountryCode Tag objects\nrelationToAdd.getTags().add(new Tag(ISOCountryTag.KEY, entry.getKey()));\ncreatedRelations.add(relationToAdd);\nthis.changeSet.addCreatedRelation(relationToAdd);\n}\n});\n}\nreturn Optional.of(createdRelations);\n}\n\nelse\n{\n\/\/ Either the way is not sliced or way is outside of the supplied bound\nmembers.add(member);\n}\n\nparents.add(relation.getId());\nfinal Relation subRelation = this.store.getRelation(member.getMemberId());\n\/\/ Check if we have the sub-relation in the store\nif (subRelation == null)\n{\n\nif (subRelation == null)\n{\n\/\/ Put the member back into the relation. Missing members will be handled\n\/\/ on a case by case basis\nmembers.add(member);\nbreak;\n\nbreak;\ndefault:\n\/\/ Here we are not checking the bound, because we are assuming all data\n\/\/ outside of bound has already been filtered out and doesn't exist in the\n\/\/ PbfMemoryStore\nmembers.add(member);\nbreak;\n\nif (isModified)\n{\n\/\/ Modified by way slicing or relation slicing\nthis.changeSet.addModifiedRelation(relation);\n}\n\nthis.changeSet.addModifiedRelation(relation);\n}\n\/\/ Group entities by country\nfinal Map<String, List<RelationMember>> countryEntityMap = members.stream()\n.collect(Collectors.groupingBy(member ->\n\nelse if (countryCount == 1)\n{\n\/\/ One country code found, assign it\nrelation.getTags()\n.add(new Tag(ISOCountryTag.KEY, countryEntityMap.keySet().iterator().next()));\n\nelse\n{\n\/\/ Muliple country codes found, implies relation crosses countries. As a 2 dimensional\n\/\/ feature, relation sliced should not have more than one piece for each country. For\n\/\/ now, for features without a country code (nodes and feature not covered by any\n\/\/ boundary), we put a copy for every sliced piece to ensure integrity.\nRuntimeCounter.relationSliced();\nthis.changeSet.addDeletedRelation(relation);\n\nfinal Relation relationToAdd = this.store.createRelation(relation,\nrelationIdFactory.nextIdentifier(), candidateMembers);\n\/\/ TODO Consider sharing CountryCode Tag objects\nrelationToAdd.getTags().add(new Tag(ISOCountryTag.KEY, entry.getKey()));\ncreatedRelations.add(relationToAdd);","code_context_10":"private Optional<List<Relation>> processDefaultRelation(final Relation relation,\nfinal List<Long> parents)\n{\nfinal List<Relation> createdRelations = new ArrayList<>();\nfinal List<RelationMember> members = new ArrayList<>();\nboolean isModified = false;\nfor (final RelationMember member : relation.getMembers())\n{\nswitch (member.getMemberType())\n{\ncase Way:\nfinal List<Way> slicedWays = this.changeSet\n.getCreatedWays(member.getMemberId());\nif (slicedWays != null && !slicedWays.isEmpty())\n{\nisModified = true;\nslicedWays.forEach(way -> members\n.add(this.store.createRelationMember(member, way.getId())));\n}\nelse\n{\n\/\/ Either the way is not sliced or way is outside of the supplied bound\nmembers.add(member);\n}\nbreak;\ncase Relation:\nparents.add(relation.getId());\nfinal Relation subRelation = this.store.getRelation(member.getMemberId());\n\/\/ Check if we have the sub-relation in the store\nif (subRelation == null)\n{\n\/\/ Put the member back into the relation. Missing members will be handled\n\/\/ on a case by case basis\nmembers.add(member);\nbreak;\n}\nfinal Optional<List<Relation>> slicedMembers;\nif (!parents.contains(subRelation.getId()))\n{\nslicedMembers = sliceRelation(subRelation, parents);\n}\nelse\n{\nlogger.error(\"Relation {} has a loop! Parent tree: {}\", subRelation.getId(),\nparents);\nslicedMembers = Optional.empty();\n}\nif (slicedMembers.isPresent())\n{\nisModified = true;\nslicedMembers.get().forEach(slicedRelation ->\n{\nmembers.add(this.store.createRelationMember(member,\nslicedRelation.getId()));\n});\n}\nelse\n{\nmembers.add(member);\n}\nbreak;\ndefault:\n\/\/ Here we are not checking the bound, because we are assuming all data\n\/\/ outside of bound has already been filtered out and doesn't exist in the\n\/\/ PbfMemoryStore\nmembers.add(member);\nbreak;\n}\n}\nif (isModified)\n{\n\/\/ Modified by way slicing or relation slicing\nthis.changeSet.addModifiedRelation(relation);\n}\n\/\/ Group entities by country\nfinal Map<String, List<RelationMember>> countryEntityMap = members.stream()\n.collect(Collectors.groupingBy(member ->\n{\nfinal Entity entity = this.store.getEntity(member);\nif (Objects.isNull(entity))\n{\nreturn ISOCountryTag.COUNTRY_MISSING;\n}\nelse\n{\nfinal Optional<Tag> countryCodeTag = entity.getTags().stream()\n.filter(tag -> tag.getKey().equals(ISOCountryTag.KEY)).findFirst();\nif (countryCodeTag.isPresent())\n{\nreturn countryCodeTag.get().getValue();\n}\nelse\n{\nreturn ISOCountryTag.COUNTRY_MISSING;\n}\n}\n}));\nfinal List<RelationMember> memberWithoutCountry;\nif (countryEntityMap.containsKey(ISOCountryTag.COUNTRY_MISSING))\n{\nmemberWithoutCountry = countryEntityMap.remove(ISOCountryTag.COUNTRY_MISSING);\n}\nelse\n{\nmemberWithoutCountry = Collections.emptyList();\n}\nfinal int countryCount = countryEntityMap.size();\nif (countryCount == 0)\n{\nrelation.getTags().add(new Tag(ISOCountryTag.KEY, ISOCountryTag.COUNTRY_MISSING));\nreturn Optional.empty();\n}\nelse if (countryCount == 1)\n{\n\/\/ One country code found, assign it\nrelation.getTags()\n.add(new Tag(ISOCountryTag.KEY, countryEntityMap.keySet().iterator().next()));\nreturn Optional.empty();\n}\nelse\n{\n\/\/ Muliple country codes found, implies relation crosses countries. As a 2 dimensional\n\/\/ feature, relation sliced should not have more than one piece for each country. For\n\/\/ now, for features without a country code (nodes and feature not covered by any\n\/\/ boundary), we put a copy for every sliced piece to ensure integrity.\nRuntimeCounter.relationSliced();\nthis.changeSet.addDeletedRelation(relation);\nfinal CountrySlicingIdentifierFactory relationIdFactory = new CountrySlicingIdentifierFactory(\nrelation.getId());\ncountryEntityMap.entrySet().forEach(entry ->\n{\nfinal List<RelationMember> candidateMembers = new ArrayList<>();\ncandidateMembers.addAll(entry.getValue());\ncandidateMembers.addAll(memberWithoutCountry);\nif (!candidateMembers.isEmpty())\n{\nfinal Relation relationToAdd = this.store.createRelation(relation,\nrelationIdFactory.nextIdentifier(), candidateMembers);\n\/\/ TODO Consider sharing CountryCode Tag objects\nrelationToAdd.getTags().add(new Tag(ISOCountryTag.KEY, entry.getKey()));\ncreatedRelations.add(relationToAdd);\nthis.changeSet.addCreatedRelation(relationToAdd);\n}\n});\n}\nreturn Optional.of(createdRelations);\n}\n\nfinal List<Way> slicedWays = this.changeSet\n.getCreatedWays(member.getMemberId());\nif (slicedWays != null && !slicedWays.isEmpty())\n{\nisModified = true;\nslicedWays.forEach(way -> members\n.add(this.store.createRelationMember(member, way.getId())));\n}\nelse\n{\n\/\/ Either the way is not sliced or way is outside of the supplied bound\nmembers.add(member);\n}\nbreak;\ncase Relation:\nparents.add(relation.getId());\nfinal Relation subRelation = this.store.getRelation(member.getMemberId());\n\/\/ Check if we have the sub-relation in the store\nif (subRelation == null)\n{\n\/\/ Put the member back into the relation. Missing members will be handled\n\n}\nelse\n{\n\/\/ Either the way is not sliced or way is outside of the supplied bound\nmembers.add(member);\n}\nbreak;\ncase Relation:\nparents.add(relation.getId());\nfinal Relation subRelation = this.store.getRelation(member.getMemberId());\n\/\/ Check if we have the sub-relation in the store\nif (subRelation == null)\n{\n\/\/ Put the member back into the relation. Missing members will be handled\n\/\/ on a case by case basis\nmembers.add(member);\nbreak;\n}\nfinal Optional<List<Relation>> slicedMembers;\nif (!parents.contains(subRelation.getId()))\n{\n\n\/\/ Either the way is not sliced or way is outside of the supplied bound\nmembers.add(member);\n}\nbreak;\ncase Relation:\nparents.add(relation.getId());\nfinal Relation subRelation = this.store.getRelation(member.getMemberId());\n\/\/ Check if we have the sub-relation in the store\nif (subRelation == null)\n{\n\/\/ Put the member back into the relation. Missing members will be handled\n\/\/ on a case by case basis\nmembers.add(member);\nbreak;\n}\nfinal Optional<List<Relation>> slicedMembers;\nif (!parents.contains(subRelation.getId()))\n{\nslicedMembers = sliceRelation(subRelation, parents);\n}\nelse\n{\n\nmembers.add(this.store.createRelationMember(member,\nslicedRelation.getId()));\n});\n}\nelse\n{\nmembers.add(member);\n}\nbreak;\ndefault:\n\/\/ Here we are not checking the bound, because we are assuming all data\n\/\/ outside of bound has already been filtered out and doesn't exist in the\n\/\/ PbfMemoryStore\nmembers.add(member);\nbreak;\n}\n}\nif (isModified)\n{\n\/\/ Modified by way slicing or relation slicing\nthis.changeSet.addModifiedRelation(relation);\n}\n\/\/ Group entities by country\n\ndefault:\n\/\/ Here we are not checking the bound, because we are assuming all data\n\/\/ outside of bound has already been filtered out and doesn't exist in the\n\/\/ PbfMemoryStore\nmembers.add(member);\nbreak;\n}\n}\nif (isModified)\n{\n\/\/ Modified by way slicing or relation slicing\nthis.changeSet.addModifiedRelation(relation);\n}\n\/\/ Group entities by country\nfinal Map<String, List<RelationMember>> countryEntityMap = members.stream()\n.collect(Collectors.groupingBy(member ->\n{\nfinal Entity entity = this.store.getEntity(member);\nif (Objects.isNull(entity))\n{\nreturn ISOCountryTag.COUNTRY_MISSING;\n\n\/\/ PbfMemoryStore\nmembers.add(member);\nbreak;\n}\n}\nif (isModified)\n{\n\/\/ Modified by way slicing or relation slicing\nthis.changeSet.addModifiedRelation(relation);\n}\n\/\/ Group entities by country\nfinal Map<String, List<RelationMember>> countryEntityMap = members.stream()\n.collect(Collectors.groupingBy(member ->\n{\nfinal Entity entity = this.store.getEntity(member);\nif (Objects.isNull(entity))\n{\nreturn ISOCountryTag.COUNTRY_MISSING;\n}\nelse\n{\n\nmemberWithoutCountry = Collections.emptyList();\n}\nfinal int countryCount = countryEntityMap.size();\nif (countryCount == 0)\n{\nrelation.getTags().add(new Tag(ISOCountryTag.KEY, ISOCountryTag.COUNTRY_MISSING));\nreturn Optional.empty();\n}\nelse if (countryCount == 1)\n{\n\/\/ One country code found, assign it\nrelation.getTags()\n.add(new Tag(ISOCountryTag.KEY, countryEntityMap.keySet().iterator().next()));\nreturn Optional.empty();\n}\nelse\n{\n\/\/ Muliple country codes found, implies relation crosses countries. As a 2 dimensional\n\/\/ feature, relation sliced should not have more than one piece for each country. For\n\/\/ now, for features without a country code (nodes and feature not covered by any\n\/\/ boundary), we put a copy for every sliced piece to ensure integrity.\n\n}\nelse if (countryCount == 1)\n{\n\/\/ One country code found, assign it\nrelation.getTags()\n.add(new Tag(ISOCountryTag.KEY, countryEntityMap.keySet().iterator().next()));\nreturn Optional.empty();\n}\nelse\n{\n\/\/ Muliple country codes found, implies relation crosses countries. As a 2 dimensional\n\/\/ feature, relation sliced should not have more than one piece for each country. For\n\/\/ now, for features without a country code (nodes and feature not covered by any\n\/\/ boundary), we put a copy for every sliced piece to ensure integrity.\nRuntimeCounter.relationSliced();\nthis.changeSet.addDeletedRelation(relation);\nfinal CountrySlicingIdentifierFactory relationIdFactory = new CountrySlicingIdentifierFactory(\nrelation.getId());\ncountryEntityMap.entrySet().forEach(entry ->\n{\nfinal List<RelationMember> candidateMembers = new ArrayList<>();\ncandidateMembers.addAll(entry.getValue());\ncandidateMembers.addAll(memberWithoutCountry);\nif (!candidateMembers.isEmpty())\n\nrelation.getId());\ncountryEntityMap.entrySet().forEach(entry ->\n{\nfinal List<RelationMember> candidateMembers = new ArrayList<>();\ncandidateMembers.addAll(entry.getValue());\ncandidateMembers.addAll(memberWithoutCountry);\nif (!candidateMembers.isEmpty())\n{\nfinal Relation relationToAdd = this.store.createRelation(relation,\nrelationIdFactory.nextIdentifier(), candidateMembers);\n\/\/ TODO Consider sharing CountryCode Tag objects\nrelationToAdd.getTags().add(new Tag(ISOCountryTag.KEY, entry.getKey()));\ncreatedRelations.add(relationToAdd);\nthis.changeSet.addCreatedRelation(relationToAdd);\n}\n});\n}\nreturn Optional.of(createdRelations);\n}","code_context_20":"private Optional<List<Relation>> processDefaultRelation(final Relation relation,\nfinal List<Long> parents)\n{\nfinal List<Relation> createdRelations = new ArrayList<>();\nfinal List<RelationMember> members = new ArrayList<>();\nboolean isModified = false;\nfor (final RelationMember member : relation.getMembers())\n{\nswitch (member.getMemberType())\n{\ncase Way:\nfinal List<Way> slicedWays = this.changeSet\n.getCreatedWays(member.getMemberId());\nif (slicedWays != null && !slicedWays.isEmpty())\n{\nisModified = true;\nslicedWays.forEach(way -> members\n.add(this.store.createRelationMember(member, way.getId())));\n}\nelse\n{\n\/\/ Either the way is not sliced or way is outside of the supplied bound\nmembers.add(member);\n}\nbreak;\ncase Relation:\nparents.add(relation.getId());\nfinal Relation subRelation = this.store.getRelation(member.getMemberId());\n\/\/ Check if we have the sub-relation in the store\nif (subRelation == null)\n{\n\/\/ Put the member back into the relation. Missing members will be handled\n\/\/ on a case by case basis\nmembers.add(member);\nbreak;\n}\nfinal Optional<List<Relation>> slicedMembers;\nif (!parents.contains(subRelation.getId()))\n{\nslicedMembers = sliceRelation(subRelation, parents);\n}\nelse\n{\nlogger.error(\"Relation {} has a loop! Parent tree: {}\", subRelation.getId(),\nparents);\nslicedMembers = Optional.empty();\n}\nif (slicedMembers.isPresent())\n{\nisModified = true;\nslicedMembers.get().forEach(slicedRelation ->\n{\nmembers.add(this.store.createRelationMember(member,\nslicedRelation.getId()));\n});\n}\nelse\n{\nmembers.add(member);\n}\nbreak;\ndefault:\n\/\/ Here we are not checking the bound, because we are assuming all data\n\/\/ outside of bound has already been filtered out and doesn't exist in the\n\/\/ PbfMemoryStore\nmembers.add(member);\nbreak;\n}\n}\nif (isModified)\n{\n\/\/ Modified by way slicing or relation slicing\nthis.changeSet.addModifiedRelation(relation);\n}\n\/\/ Group entities by country\nfinal Map<String, List<RelationMember>> countryEntityMap = members.stream()\n.collect(Collectors.groupingBy(member ->\n{\nfinal Entity entity = this.store.getEntity(member);\nif (Objects.isNull(entity))\n{\nreturn ISOCountryTag.COUNTRY_MISSING;\n}\nelse\n{\nfinal Optional<Tag> countryCodeTag = entity.getTags().stream()\n.filter(tag -> tag.getKey().equals(ISOCountryTag.KEY)).findFirst();\nif (countryCodeTag.isPresent())\n{\nreturn countryCodeTag.get().getValue();\n}\nelse\n{\nreturn ISOCountryTag.COUNTRY_MISSING;\n}\n}\n}));\nfinal List<RelationMember> memberWithoutCountry;\nif (countryEntityMap.containsKey(ISOCountryTag.COUNTRY_MISSING))\n{\nmemberWithoutCountry = countryEntityMap.remove(ISOCountryTag.COUNTRY_MISSING);\n}\nelse\n{\nmemberWithoutCountry = Collections.emptyList();\n}\nfinal int countryCount = countryEntityMap.size();\nif (countryCount == 0)\n{\nrelation.getTags().add(new Tag(ISOCountryTag.KEY, ISOCountryTag.COUNTRY_MISSING));\nreturn Optional.empty();\n}\nelse if (countryCount == 1)\n{\n\/\/ One country code found, assign it\nrelation.getTags()\n.add(new Tag(ISOCountryTag.KEY, countryEntityMap.keySet().iterator().next()));\nreturn Optional.empty();\n}\nelse\n{\n\/\/ Muliple country codes found, implies relation crosses countries. As a 2 dimensional\n\/\/ feature, relation sliced should not have more than one piece for each country. For\n\/\/ now, for features without a country code (nodes and feature not covered by any\n\/\/ boundary), we put a copy for every sliced piece to ensure integrity.\nRuntimeCounter.relationSliced();\nthis.changeSet.addDeletedRelation(relation);\nfinal CountrySlicingIdentifierFactory relationIdFactory = new CountrySlicingIdentifierFactory(\nrelation.getId());\ncountryEntityMap.entrySet().forEach(entry ->\n{\nfinal List<RelationMember> candidateMembers = new ArrayList<>();\ncandidateMembers.addAll(entry.getValue());\ncandidateMembers.addAll(memberWithoutCountry);\nif (!candidateMembers.isEmpty())\n{\nfinal Relation relationToAdd = this.store.createRelation(relation,\nrelationIdFactory.nextIdentifier(), candidateMembers);\n\/\/ TODO Consider sharing CountryCode Tag objects\nrelationToAdd.getTags().add(new Tag(ISOCountryTag.KEY, entry.getKey()));\ncreatedRelations.add(relationToAdd);\nthis.changeSet.addCreatedRelation(relationToAdd);\n}\n});\n}\nreturn Optional.of(createdRelations);\n}\n\nfinal List<Long> parents)\n{\nfinal List<Relation> createdRelations = new ArrayList<>();\nfinal List<RelationMember> members = new ArrayList<>();\nboolean isModified = false;\nfor (final RelationMember member : relation.getMembers())\n{\nswitch (member.getMemberType())\n{\ncase Way:\nfinal List<Way> slicedWays = this.changeSet\n.getCreatedWays(member.getMemberId());\nif (slicedWays != null && !slicedWays.isEmpty())\n{\nisModified = true;\nslicedWays.forEach(way -> members\n.add(this.store.createRelationMember(member, way.getId())));\n}\nelse\n{\n\/\/ Either the way is not sliced or way is outside of the supplied bound\nmembers.add(member);\n}\nbreak;\ncase Relation:\nparents.add(relation.getId());\nfinal Relation subRelation = this.store.getRelation(member.getMemberId());\n\/\/ Check if we have the sub-relation in the store\nif (subRelation == null)\n{\n\/\/ Put the member back into the relation. Missing members will be handled\n\/\/ on a case by case basis\nmembers.add(member);\nbreak;\n}\nfinal Optional<List<Relation>> slicedMembers;\nif (!parents.contains(subRelation.getId()))\n{\nslicedMembers = sliceRelation(subRelation, parents);\n}\nelse\n\nswitch (member.getMemberType())\n{\ncase Way:\nfinal List<Way> slicedWays = this.changeSet\n.getCreatedWays(member.getMemberId());\nif (slicedWays != null && !slicedWays.isEmpty())\n{\nisModified = true;\nslicedWays.forEach(way -> members\n.add(this.store.createRelationMember(member, way.getId())));\n}\nelse\n{\n\/\/ Either the way is not sliced or way is outside of the supplied bound\nmembers.add(member);\n}\nbreak;\ncase Relation:\nparents.add(relation.getId());\nfinal Relation subRelation = this.store.getRelation(member.getMemberId());\n\/\/ Check if we have the sub-relation in the store\nif (subRelation == null)\n{\n\/\/ Put the member back into the relation. Missing members will be handled\n\/\/ on a case by case basis\nmembers.add(member);\nbreak;\n}\nfinal Optional<List<Relation>> slicedMembers;\nif (!parents.contains(subRelation.getId()))\n{\nslicedMembers = sliceRelation(subRelation, parents);\n}\nelse\n{\nlogger.error(\"Relation {} has a loop! Parent tree: {}\", subRelation.getId(),\nparents);\nslicedMembers = Optional.empty();\n}\nif (slicedMembers.isPresent())\n{\n\nfinal List<Way> slicedWays = this.changeSet\n.getCreatedWays(member.getMemberId());\nif (slicedWays != null && !slicedWays.isEmpty())\n{\nisModified = true;\nslicedWays.forEach(way -> members\n.add(this.store.createRelationMember(member, way.getId())));\n}\nelse\n{\n\/\/ Either the way is not sliced or way is outside of the supplied bound\nmembers.add(member);\n}\nbreak;\ncase Relation:\nparents.add(relation.getId());\nfinal Relation subRelation = this.store.getRelation(member.getMemberId());\n\/\/ Check if we have the sub-relation in the store\nif (subRelation == null)\n{\n\/\/ Put the member back into the relation. Missing members will be handled\n\/\/ on a case by case basis\nmembers.add(member);\nbreak;\n}\nfinal Optional<List<Relation>> slicedMembers;\nif (!parents.contains(subRelation.getId()))\n{\nslicedMembers = sliceRelation(subRelation, parents);\n}\nelse\n{\nlogger.error(\"Relation {} has a loop! Parent tree: {}\", subRelation.getId(),\nparents);\nslicedMembers = Optional.empty();\n}\nif (slicedMembers.isPresent())\n{\nisModified = true;\nslicedMembers.get().forEach(slicedRelation ->\n{\nmembers.add(this.store.createRelationMember(member,\n\n{\nlogger.error(\"Relation {} has a loop! Parent tree: {}\", subRelation.getId(),\nparents);\nslicedMembers = Optional.empty();\n}\nif (slicedMembers.isPresent())\n{\nisModified = true;\nslicedMembers.get().forEach(slicedRelation ->\n{\nmembers.add(this.store.createRelationMember(member,\nslicedRelation.getId()));\n});\n}\nelse\n{\nmembers.add(member);\n}\nbreak;\ndefault:\n\/\/ Here we are not checking the bound, because we are assuming all data\n\/\/ outside of bound has already been filtered out and doesn't exist in the\n\/\/ PbfMemoryStore\nmembers.add(member);\nbreak;\n}\n}\nif (isModified)\n{\n\/\/ Modified by way slicing or relation slicing\nthis.changeSet.addModifiedRelation(relation);\n}\n\/\/ Group entities by country\nfinal Map<String, List<RelationMember>> countryEntityMap = members.stream()\n.collect(Collectors.groupingBy(member ->\n{\nfinal Entity entity = this.store.getEntity(member);\nif (Objects.isNull(entity))\n{\nreturn ISOCountryTag.COUNTRY_MISSING;\n}\nelse\n{\n\n{\nmembers.add(this.store.createRelationMember(member,\nslicedRelation.getId()));\n});\n}\nelse\n{\nmembers.add(member);\n}\nbreak;\ndefault:\n\/\/ Here we are not checking the bound, because we are assuming all data\n\/\/ outside of bound has already been filtered out and doesn't exist in the\n\/\/ PbfMemoryStore\nmembers.add(member);\nbreak;\n}\n}\nif (isModified)\n{\n\/\/ Modified by way slicing or relation slicing\nthis.changeSet.addModifiedRelation(relation);\n}\n\/\/ Group entities by country\nfinal Map<String, List<RelationMember>> countryEntityMap = members.stream()\n.collect(Collectors.groupingBy(member ->\n{\nfinal Entity entity = this.store.getEntity(member);\nif (Objects.isNull(entity))\n{\nreturn ISOCountryTag.COUNTRY_MISSING;\n}\nelse\n{\nfinal Optional<Tag> countryCodeTag = entity.getTags().stream()\n.filter(tag -> tag.getKey().equals(ISOCountryTag.KEY)).findFirst();\nif (countryCodeTag.isPresent())\n{\nreturn countryCodeTag.get().getValue();\n}\nelse\n\n});\n}\nelse\n{\nmembers.add(member);\n}\nbreak;\ndefault:\n\/\/ Here we are not checking the bound, because we are assuming all data\n\/\/ outside of bound has already been filtered out and doesn't exist in the\n\/\/ PbfMemoryStore\nmembers.add(member);\nbreak;\n}\n}\nif (isModified)\n{\n\/\/ Modified by way slicing or relation slicing\nthis.changeSet.addModifiedRelation(relation);\n}\n\/\/ Group entities by country\nfinal Map<String, List<RelationMember>> countryEntityMap = members.stream()\n.collect(Collectors.groupingBy(member ->\n{\nfinal Entity entity = this.store.getEntity(member);\nif (Objects.isNull(entity))\n{\nreturn ISOCountryTag.COUNTRY_MISSING;\n}\nelse\n{\nfinal Optional<Tag> countryCodeTag = entity.getTags().stream()\n.filter(tag -> tag.getKey().equals(ISOCountryTag.KEY)).findFirst();\nif (countryCodeTag.isPresent())\n{\nreturn countryCodeTag.get().getValue();\n}\nelse\n{\nreturn ISOCountryTag.COUNTRY_MISSING;\n}\n\n}\n}\n}));\nfinal List<RelationMember> memberWithoutCountry;\nif (countryEntityMap.containsKey(ISOCountryTag.COUNTRY_MISSING))\n{\nmemberWithoutCountry = countryEntityMap.remove(ISOCountryTag.COUNTRY_MISSING);\n}\nelse\n{\nmemberWithoutCountry = Collections.emptyList();\n}\nfinal int countryCount = countryEntityMap.size();\nif (countryCount == 0)\n{\nrelation.getTags().add(new Tag(ISOCountryTag.KEY, ISOCountryTag.COUNTRY_MISSING));\nreturn Optional.empty();\n}\nelse if (countryCount == 1)\n{\n\/\/ One country code found, assign it\nrelation.getTags()\n.add(new Tag(ISOCountryTag.KEY, countryEntityMap.keySet().iterator().next()));\nreturn Optional.empty();\n}\nelse\n{\n\/\/ Muliple country codes found, implies relation crosses countries. As a 2 dimensional\n\/\/ feature, relation sliced should not have more than one piece for each country. For\n\/\/ now, for features without a country code (nodes and feature not covered by any\n\/\/ boundary), we put a copy for every sliced piece to ensure integrity.\nRuntimeCounter.relationSliced();\nthis.changeSet.addDeletedRelation(relation);\nfinal CountrySlicingIdentifierFactory relationIdFactory = new CountrySlicingIdentifierFactory(\nrelation.getId());\ncountryEntityMap.entrySet().forEach(entry ->\n{\nfinal List<RelationMember> candidateMembers = new ArrayList<>();\ncandidateMembers.addAll(entry.getValue());\ncandidateMembers.addAll(memberWithoutCountry);\nif (!candidateMembers.isEmpty())\n\n}\nelse\n{\nmemberWithoutCountry = Collections.emptyList();\n}\nfinal int countryCount = countryEntityMap.size();\nif (countryCount == 0)\n{\nrelation.getTags().add(new Tag(ISOCountryTag.KEY, ISOCountryTag.COUNTRY_MISSING));\nreturn Optional.empty();\n}\nelse if (countryCount == 1)\n{\n\/\/ One country code found, assign it\nrelation.getTags()\n.add(new Tag(ISOCountryTag.KEY, countryEntityMap.keySet().iterator().next()));\nreturn Optional.empty();\n}\nelse\n{\n\/\/ Muliple country codes found, implies relation crosses countries. As a 2 dimensional\n\/\/ feature, relation sliced should not have more than one piece for each country. For\n\/\/ now, for features without a country code (nodes and feature not covered by any\n\/\/ boundary), we put a copy for every sliced piece to ensure integrity.\nRuntimeCounter.relationSliced();\nthis.changeSet.addDeletedRelation(relation);\nfinal CountrySlicingIdentifierFactory relationIdFactory = new CountrySlicingIdentifierFactory(\nrelation.getId());\ncountryEntityMap.entrySet().forEach(entry ->\n{\nfinal List<RelationMember> candidateMembers = new ArrayList<>();\ncandidateMembers.addAll(entry.getValue());\ncandidateMembers.addAll(memberWithoutCountry);\nif (!candidateMembers.isEmpty())\n{\nfinal Relation relationToAdd = this.store.createRelation(relation,\nrelationIdFactory.nextIdentifier(), candidateMembers);\n\/\/ TODO Consider sharing CountryCode Tag objects\nrelationToAdd.getTags().add(new Tag(ISOCountryTag.KEY, entry.getKey()));\ncreatedRelations.add(relationToAdd);\nthis.changeSet.addCreatedRelation(relationToAdd);\n}\n});\n}\n\n}\nelse\n{\n\/\/ Muliple country codes found, implies relation crosses countries. As a 2 dimensional\n\/\/ feature, relation sliced should not have more than one piece for each country. For\n\/\/ now, for features without a country code (nodes and feature not covered by any\n\/\/ boundary), we put a copy for every sliced piece to ensure integrity.\nRuntimeCounter.relationSliced();\nthis.changeSet.addDeletedRelation(relation);\nfinal CountrySlicingIdentifierFactory relationIdFactory = new CountrySlicingIdentifierFactory(\nrelation.getId());\ncountryEntityMap.entrySet().forEach(entry ->\n{\nfinal List<RelationMember> candidateMembers = new ArrayList<>();\ncandidateMembers.addAll(entry.getValue());\ncandidateMembers.addAll(memberWithoutCountry);\nif (!candidateMembers.isEmpty())\n{\nfinal Relation relationToAdd = this.store.createRelation(relation,\nrelationIdFactory.nextIdentifier(), candidateMembers);\n\/\/ TODO Consider sharing CountryCode Tag objects\nrelationToAdd.getTags().add(new Tag(ISOCountryTag.KEY, entry.getKey()));\ncreatedRelations.add(relationToAdd);\nthis.changeSet.addCreatedRelation(relationToAdd);\n}\n});\n}\nreturn Optional.of(createdRelations);\n}","label":[1,0,0,0]}
{"id":14066,"original_code":"@JsonGetter(\"accessToken\")\n    public String getAccessToken ( ) { \n        return this.accessToken;\n    }","code":"@JsonGetter(\"accessToken\")\n    public String getAccessToken ( ) { \n        return this.accessToken;\n    }","cleancode":"@jsongetter(\"accesstoken\") public string getaccesstoken ( ) { return this.accesstoken; }","comment":"\/** getter * todo: write general description for this method *\/","repo":"serkaneren78\/konkod-android-sdk","code_context_2":"@JsonGetter(\"accessToken\")\npublic String getAccessToken ( ) {\nreturn this.accessToken;\n}","code_context_10":"@JsonGetter(\"accessToken\")\npublic String getAccessToken ( ) {\nreturn this.accessToken;\n}","code_context_20":"@JsonGetter(\"accessToken\")\npublic String getAccessToken ( ) {\nreturn this.accessToken;\n}","label":[0,0,0,0]}
{"id":14067,"original_code":"@JsonSetter(\"accessToken\")\n    public void setAccessToken (String value) { \n        this.accessToken = value;\n        notifyObservers(this.accessToken);\n    }","code":"@JsonSetter(\"accessToken\")\n    public void setAccessToken (String value) { \n        this.accessToken = value;\n        notifyObservers(this.accessToken);\n    }","cleancode":"@jsonsetter(\"accesstoken\") public void setaccesstoken (string value) { this.accesstoken = value; notifyobservers(this.accesstoken); }","comment":"\/** setter * todo: write general description for this method *\/","repo":"serkaneren78\/konkod-android-sdk","code_context_2":"@JsonSetter(\"accessToken\")\npublic void setAccessToken (String value) {\nthis.accessToken = value;\nnotifyObservers(this.accessToken);\n}","code_context_10":"@JsonSetter(\"accessToken\")\npublic void setAccessToken (String value) {\nthis.accessToken = value;\nnotifyObservers(this.accessToken);\n}","code_context_20":"@JsonSetter(\"accessToken\")\npublic void setAccessToken (String value) {\nthis.accessToken = value;\nnotifyObservers(this.accessToken);\n}","label":[0,0,0,0]}
{"id":14068,"original_code":"@JsonGetter(\"tokeType\")\n    public String getTokeType ( ) { \n        return this.tokeType;\n    }","code":"@JsonGetter(\"tokeType\")\n    public String getTokeType ( ) { \n        return this.tokeType;\n    }","cleancode":"@jsongetter(\"toketype\") public string gettoketype ( ) { return this.toketype; }","comment":"\/** getter * todo: write general description for this method *\/","repo":"serkaneren78\/konkod-android-sdk","code_context_2":"@JsonGetter(\"tokeType\")\npublic String getTokeType ( ) {\nreturn this.tokeType;\n}","code_context_10":"@JsonGetter(\"tokeType\")\npublic String getTokeType ( ) {\nreturn this.tokeType;\n}","code_context_20":"@JsonGetter(\"tokeType\")\npublic String getTokeType ( ) {\nreturn this.tokeType;\n}","label":[0,0,0,0]}
{"id":14069,"original_code":"@JsonSetter(\"tokeType\")\n    public void setTokeType (String value) { \n        this.tokeType = value;\n        notifyObservers(this.tokeType);\n    }","code":"@JsonSetter(\"tokeType\")\n    public void setTokeType (String value) { \n        this.tokeType = value;\n        notifyObservers(this.tokeType);\n    }","cleancode":"@jsonsetter(\"toketype\") public void settoketype (string value) { this.toketype = value; notifyobservers(this.toketype); }","comment":"\/** setter * todo: write general description for this method *\/","repo":"serkaneren78\/konkod-android-sdk","code_context_2":"@JsonSetter(\"tokeType\")\npublic void setTokeType (String value) {\nthis.tokeType = value;\nnotifyObservers(this.tokeType);\n}","code_context_10":"@JsonSetter(\"tokeType\")\npublic void setTokeType (String value) {\nthis.tokeType = value;\nnotifyObservers(this.tokeType);\n}","code_context_20":"@JsonSetter(\"tokeType\")\npublic void setTokeType (String value) {\nthis.tokeType = value;\nnotifyObservers(this.tokeType);\n}","label":[0,0,0,0]}
{"id":14070,"original_code":"@JsonGetter(\"expiresIn\")\n    public Long getExpiresIn ( ) { \n        return this.expiresIn;\n    }","code":"@JsonGetter(\"expiresIn\")\n    public Long getExpiresIn ( ) { \n        return this.expiresIn;\n    }","cleancode":"@jsongetter(\"expiresin\") public long getexpiresin ( ) { return this.expiresin; }","comment":"\/** getter * todo: write general description for this method *\/","repo":"serkaneren78\/konkod-android-sdk","code_context_2":"@JsonGetter(\"expiresIn\")\npublic Long getExpiresIn ( ) {\nreturn this.expiresIn;\n}","code_context_10":"@JsonGetter(\"expiresIn\")\npublic Long getExpiresIn ( ) {\nreturn this.expiresIn;\n}","code_context_20":"@JsonGetter(\"expiresIn\")\npublic Long getExpiresIn ( ) {\nreturn this.expiresIn;\n}","label":[0,0,0,0]}
{"id":14071,"original_code":"@JsonSetter(\"expiresIn\")\n    public void setExpiresIn (Long value) { \n        this.expiresIn = value;\n        notifyObservers(this.expiresIn);\n    }","code":"@JsonSetter(\"expiresIn\")\n    public void setExpiresIn (Long value) { \n        this.expiresIn = value;\n        notifyObservers(this.expiresIn);\n    }","cleancode":"@jsonsetter(\"expiresin\") public void setexpiresin (long value) { this.expiresin = value; notifyobservers(this.expiresin); }","comment":"\/** setter * todo: write general description for this method *\/","repo":"serkaneren78\/konkod-android-sdk","code_context_2":"@JsonSetter(\"expiresIn\")\npublic void setExpiresIn (Long value) {\nthis.expiresIn = value;\nnotifyObservers(this.expiresIn);\n}","code_context_10":"@JsonSetter(\"expiresIn\")\npublic void setExpiresIn (Long value) {\nthis.expiresIn = value;\nnotifyObservers(this.expiresIn);\n}","code_context_20":"@JsonSetter(\"expiresIn\")\npublic void setExpiresIn (Long value) {\nthis.expiresIn = value;\nnotifyObservers(this.expiresIn);\n}","label":[0,0,0,0]}
{"id":30633,"original_code":"public static SourceFileModule resolve(File rootDir, File dir, String target) throws IOException, JSONException {\n        \/\/ NOTE(Zhen): Ignore CoreModule for now to enable a more flexible semantic modeling\n        \/\/ if (NodejsRequiredCoreModule.isCoreModule(target)) return NodejsRequiredCoreModule.make(target);\n        if (target.startsWith(\".\/\") || target.startsWith(\"\/\") || target.startsWith(\"..\/\")) {\n            SourceFileModule module = loadAsFile(rootDir, new File(dir, target));\n            if (module != null) return module;\n            module = loadAsDirectory(rootDir, new File(dir, target));\n            if (module != null) return module;\n        }\n        \/\/ NOTE(Zhen): it is not very useful to throw exception...\n        return loadNodeModules(rootDir, dir, target);\n    }","code":"public static SourceFileModule resolve(File rootDir, File dir, String target) throws IOException, JSONException {\n       \n       \n        if (target.startsWith(\".\/\") || target.startsWith(\"\/\") || target.startsWith(\"..\/\")) {\n            SourceFileModule module = loadAsFile(rootDir, new File(dir, target));\n            if (module != null) return module;\n            module = loadAsDirectory(rootDir, new File(dir, target));\n            if (module != null) return module;\n        }\n       \n        return loadNodeModules(rootDir, dir, target);\n    }","cleancode":"public static sourcefilemodule resolve(file rootdir, file dir, string target) throws ioexception, jsonexception { if (target.startswith(\".\/\") || target.startswith(\"\/\") || target.startswith(\"..\/\")) { sourcefilemodule module = loadasfile(rootdir, new file(dir, target)); if (module != null) return module; module = loadasdirectory(rootdir, new file(dir, target)); if (module != null) return module; } return loadnodemodules(rootdir, dir, target); }","comment":"\/** * implements the nodejs require.resolve algorithm, see * https:\/\/nodejs.org\/api\/modules.html#modules_all_together * * <p>require(x) from module at path y 1. if x is a core module, a. return the core module b. stop * 2. if x begins with '.\/' or '\/' or '..\/' a. load_as_file(y + x) b. load_as_directory(y + x) 3. * load_node_modules(x, dirname(y)) 4. throw \"not found\" * * @param dir y in the pseudo algorithm * @param target x in the pseudo algorithm *\/\n\/\/ note(zhen): ignore coremodule for now to enable a more flexible semantic modeling \/\/ if (nodejsrequiredcoremodule.iscoremodule(target)) return nodejsrequiredcoremodule.make(target);\n\/\/ note(zhen): it is not very useful to throw exception...","repo":"semantic-graph\/js2graph","code_context_2":"public static SourceFileModule resolve(File rootDir, File dir, String target) throws IOException, JSONException {\n\/\/ NOTE(Zhen): Ignore CoreModule for now to enable a more flexible semantic modeling\n\/\/ if (NodejsRequiredCoreModule.isCoreModule(target)) return NodejsRequiredCoreModule.make(target);\nif (target.startsWith(\".\/\") || target.startsWith(\"\/\") || target.startsWith(\"..\/\")) {\nSourceFileModule module = loadAsFile(rootDir, new File(dir, target));\nif (module != null) return module;\nmodule = loadAsDirectory(rootDir, new File(dir, target));\nif (module != null) return module;\n}\n\/\/ NOTE(Zhen): it is not very useful to throw exception...\nreturn loadNodeModules(rootDir, dir, target);\n}\n\npublic static SourceFileModule resolve(File rootDir, File dir, String target) throws IOException, JSONException {\n\/\/ NOTE(Zhen): Ignore CoreModule for now to enable a more flexible semantic modeling\n\/\/ if (NodejsRequiredCoreModule.isCoreModule(target)) return NodejsRequiredCoreModule.make(target);\nif (target.startsWith(\".\/\") || target.startsWith(\"\/\") || target.startsWith(\"..\/\")) {\nSourceFileModule module = loadAsFile(rootDir, new File(dir, target));\n\nif (module != null) return module;\n}\n\/\/ NOTE(Zhen): it is not very useful to throw exception...\nreturn loadNodeModules(rootDir, dir, target);\n}","code_context_10":"public static SourceFileModule resolve(File rootDir, File dir, String target) throws IOException, JSONException {\n\/\/ NOTE(Zhen): Ignore CoreModule for now to enable a more flexible semantic modeling\n\/\/ if (NodejsRequiredCoreModule.isCoreModule(target)) return NodejsRequiredCoreModule.make(target);\nif (target.startsWith(\".\/\") || target.startsWith(\"\/\") || target.startsWith(\"..\/\")) {\nSourceFileModule module = loadAsFile(rootDir, new File(dir, target));\nif (module != null) return module;\nmodule = loadAsDirectory(rootDir, new File(dir, target));\nif (module != null) return module;\n}\n\/\/ NOTE(Zhen): it is not very useful to throw exception...\nreturn loadNodeModules(rootDir, dir, target);\n}\n\npublic static SourceFileModule resolve(File rootDir, File dir, String target) throws IOException, JSONException {\n\/\/ NOTE(Zhen): Ignore CoreModule for now to enable a more flexible semantic modeling\n\/\/ if (NodejsRequiredCoreModule.isCoreModule(target)) return NodejsRequiredCoreModule.make(target);\nif (target.startsWith(\".\/\") || target.startsWith(\"\/\") || target.startsWith(\"..\/\")) {\nSourceFileModule module = loadAsFile(rootDir, new File(dir, target));\nif (module != null) return module;\nmodule = loadAsDirectory(rootDir, new File(dir, target));\nif (module != null) return module;\n}\n\/\/ NOTE(Zhen): it is not very useful to throw exception...\nreturn loadNodeModules(rootDir, dir, target);\n}\n\npublic static SourceFileModule resolve(File rootDir, File dir, String target) throws IOException, JSONException {\n\/\/ NOTE(Zhen): Ignore CoreModule for now to enable a more flexible semantic modeling\n\/\/ if (NodejsRequiredCoreModule.isCoreModule(target)) return NodejsRequiredCoreModule.make(target);\nif (target.startsWith(\".\/\") || target.startsWith(\"\/\") || target.startsWith(\"..\/\")) {\nSourceFileModule module = loadAsFile(rootDir, new File(dir, target));\nif (module != null) return module;\nmodule = loadAsDirectory(rootDir, new File(dir, target));\nif (module != null) return module;\n}\n\/\/ NOTE(Zhen): it is not very useful to throw exception...\nreturn loadNodeModules(rootDir, dir, target);\n}","code_context_20":"public static SourceFileModule resolve(File rootDir, File dir, String target) throws IOException, JSONException {\n\/\/ NOTE(Zhen): Ignore CoreModule for now to enable a more flexible semantic modeling\n\/\/ if (NodejsRequiredCoreModule.isCoreModule(target)) return NodejsRequiredCoreModule.make(target);\nif (target.startsWith(\".\/\") || target.startsWith(\"\/\") || target.startsWith(\"..\/\")) {\nSourceFileModule module = loadAsFile(rootDir, new File(dir, target));\nif (module != null) return module;\nmodule = loadAsDirectory(rootDir, new File(dir, target));\nif (module != null) return module;\n}\n\/\/ NOTE(Zhen): it is not very useful to throw exception...\nreturn loadNodeModules(rootDir, dir, target);\n}\n\npublic static SourceFileModule resolve(File rootDir, File dir, String target) throws IOException, JSONException {\n\/\/ NOTE(Zhen): Ignore CoreModule for now to enable a more flexible semantic modeling\n\/\/ if (NodejsRequiredCoreModule.isCoreModule(target)) return NodejsRequiredCoreModule.make(target);\nif (target.startsWith(\".\/\") || target.startsWith(\"\/\") || target.startsWith(\"..\/\")) {\nSourceFileModule module = loadAsFile(rootDir, new File(dir, target));\nif (module != null) return module;\nmodule = loadAsDirectory(rootDir, new File(dir, target));\nif (module != null) return module;\n}\n\/\/ NOTE(Zhen): it is not very useful to throw exception...\nreturn loadNodeModules(rootDir, dir, target);\n}\n\npublic static SourceFileModule resolve(File rootDir, File dir, String target) throws IOException, JSONException {\n\/\/ NOTE(Zhen): Ignore CoreModule for now to enable a more flexible semantic modeling\n\/\/ if (NodejsRequiredCoreModule.isCoreModule(target)) return NodejsRequiredCoreModule.make(target);\nif (target.startsWith(\".\/\") || target.startsWith(\"\/\") || target.startsWith(\"..\/\")) {\nSourceFileModule module = loadAsFile(rootDir, new File(dir, target));\nif (module != null) return module;\nmodule = loadAsDirectory(rootDir, new File(dir, target));\nif (module != null) return module;\n}\n\/\/ NOTE(Zhen): it is not very useful to throw exception...\nreturn loadNodeModules(rootDir, dir, target);\n}","label":[1,0,0,0]}
{"id":22463,"original_code":"private String prepareHeadersAndBodyForService(HttpServletRequest request, String method, String url,\n                                                   List<String> clientRequestHeaders, Interactor.Interaction interaction,\n                                                   String clientRequestContentType,\n                                                   InteractionManipulations interactionManipulations) throws IOException {\n        Enumeration<String> hdrs = request.getHeaderNames();\n        ServletInputStream is = request.getInputStream();\n        Object clientRequestBody = null;\n        \/\/if (is.available() > 0) {\n            if (isText(clientRequestContentType)) {\n                clientRequestBody = null;\n                String characterEncoding = request.getCharacterEncoding();\n                if (characterEncoding == null) {\n                    characterEncoding = \"utf-8\";\n                }\n                try (Scanner scanner = new Scanner(is, characterEncoding)) {\n                    if(scanner.hasNext()) {\n                        clientRequestBody = scanner.useDelimiter(\"\\\\A\").next();\n                    }\n                }\n                if (shouldHavePrettyPrintedTextBodies() && clientRequestBody != null) {\n                    clientRequestBody = prettifyDocOrNot((String) clientRequestBody);\n                }\n            } else if(is.available() > 0){\n                byte[] targetArray = new byte[is.available()];\n                is.read(targetArray);\n                clientRequestBody = targetArray;\n            }\n        \/\/}\n        while (hdrs.hasMoreElements()) {\n            \/\/ TODO - make this cater for multiple lines with the same name\n            String hdrName = hdrs.nextElement();\n            String hdrVal = request.getHeader(hdrName);\n            hdrVal = interactionManipulations.headerReplacement(hdrName, hdrVal);\n            final String fullHeader = (getLowerCaseHeaders() ? hdrName.toLowerCase() : hdrName) + \": \" + hdrVal;\n            clientRequestHeaders.add(fullHeader);\n            interactionManipulations.changeSingleHeaderForRequestToService(method, fullHeader, clientRequestHeaders);\n        }\n        interactionManipulations.changeAnyHeadersForRequestToService(clientRequestHeaders);\n        if (clientRequestBody instanceof String) {\n            clientRequestBody = interactionManipulations.changeBodyForRequestToService((String) clientRequestBody);\n        }\n        if (clientRequestBody == null) {\n            clientRequestBody = \"\";\n        }\n        interaction.noteClientRequestHeadersAndBody(clientRequestHeaders, clientRequestBody, clientRequestContentType);\n        return interactionManipulations.changeUrlForRequestToService(url);\n    }","code":"private String prepareHeadersAndBodyForService(HttpServletRequest request, String method, String url,\n                                                   List<String> clientRequestHeaders, Interactor.Interaction interaction,\n                                                   String clientRequestContentType,\n                                                   InteractionManipulations interactionManipulations) throws IOException {\n        Enumeration<String> hdrs = request.getHeaderNames();\n        ServletInputStream is = request.getInputStream();\n        Object clientRequestBody = null;\n       \n            if (isText(clientRequestContentType)) {\n                clientRequestBody = null;\n                String characterEncoding = request.getCharacterEncoding();\n                if (characterEncoding == null) {\n                    characterEncoding = \"utf-8\";\n                }\n                try (Scanner scanner = new Scanner(is, characterEncoding)) {\n                    if(scanner.hasNext()) {\n                        clientRequestBody = scanner.useDelimiter(\"\\\\A\").next();\n                    }\n                }\n                if (shouldHavePrettyPrintedTextBodies() && clientRequestBody != null) {\n                    clientRequestBody = prettifyDocOrNot((String) clientRequestBody);\n                }\n            } else if(is.available() > 0){\n                byte[] targetArray = new byte[is.available()];\n                is.read(targetArray);\n                clientRequestBody = targetArray;\n            }\n       \n        while (hdrs.hasMoreElements()) {\n           \n            String hdrName = hdrs.nextElement();\n            String hdrVal = request.getHeader(hdrName);\n            hdrVal = interactionManipulations.headerReplacement(hdrName, hdrVal);\n            final String fullHeader = (getLowerCaseHeaders() ? hdrName.toLowerCase() : hdrName) + \": \" + hdrVal;\n            clientRequestHeaders.add(fullHeader);\n            interactionManipulations.changeSingleHeaderForRequestToService(method, fullHeader, clientRequestHeaders);\n        }\n        interactionManipulations.changeAnyHeadersForRequestToService(clientRequestHeaders);\n        if (clientRequestBody instanceof String) {\n            clientRequestBody = interactionManipulations.changeBodyForRequestToService((String) clientRequestBody);\n        }\n        if (clientRequestBody == null) {\n            clientRequestBody = \"\";\n        }\n        interaction.noteClientRequestHeadersAndBody(clientRequestHeaders, clientRequestBody, clientRequestContentType);\n        return interactionManipulations.changeUrlForRequestToService(url);\n    }","cleancode":"private string prepareheadersandbodyforservice(httpservletrequest request, string method, string url, list<string> clientrequestheaders, interactor.interaction interaction, string clientrequestcontenttype, interactionmanipulations interactionmanipulations) throws ioexception { enumeration<string> hdrs = request.getheadernames(); servletinputstream is = request.getinputstream(); object clientrequestbody = null; if (istext(clientrequestcontenttype)) { clientrequestbody = null; string characterencoding = request.getcharacterencoding(); if (characterencoding == null) { characterencoding = \"utf-8\"; } try (scanner scanner = new scanner(is, characterencoding)) { if(scanner.hasnext()) { clientrequestbody = scanner.usedelimiter(\"\\\\a\").next(); } } if (shouldhaveprettyprintedtextbodies() && clientrequestbody != null) { clientrequestbody = prettifydocornot((string) clientrequestbody); } } else if(is.available() > 0){ byte[] targetarray = new byte[is.available()]; is.read(targetarray); clientrequestbody = targetarray; } while (hdrs.hasmoreelements()) { string hdrname = hdrs.nextelement(); string hdrval = request.getheader(hdrname); hdrval = interactionmanipulations.headerreplacement(hdrname, hdrval); final string fullheader = (getlowercaseheaders() ? hdrname.tolowercase() : hdrname) + \": \" + hdrval; clientrequestheaders.add(fullheader); interactionmanipulations.changesingleheaderforrequesttoservice(method, fullheader, clientrequestheaders); } interactionmanipulations.changeanyheadersforrequesttoservice(clientrequestheaders); if (clientrequestbody instanceof string) { clientrequestbody = interactionmanipulations.changebodyforrequesttoservice((string) clientrequestbody); } if (clientrequestbody == null) { clientrequestbody = \"\"; } interaction.noteclientrequestheadersandbody(clientrequestheaders, clientrequestbody, clientrequestcontenttype); return interactionmanipulations.changeurlforrequesttoservice(url); }","comment":"\/\/if (is.available() > 0) {\n\/\/}\n\/\/ todo - make this cater for multiple lines with the same name","repo":"rogerfsg\/servirtium","code_context_2":"ServletInputStream is = request.getInputStream();\nObject clientRequestBody = null;\n\/\/if (is.available() > 0) {\nif (isText(clientRequestContentType)) {\nclientRequestBody = null;\n\nclientRequestBody = targetArray;\n}\n\/\/}\nwhile (hdrs.hasMoreElements()) {\n\/\/ TODO - make this cater for multiple lines with the same name\n\n\/\/}\nwhile (hdrs.hasMoreElements()) {\n\/\/ TODO - make this cater for multiple lines with the same name\nString hdrName = hdrs.nextElement();\nString hdrVal = request.getHeader(hdrName);","code_context_10":"private String prepareHeadersAndBodyForService(HttpServletRequest request, String method, String url,\nList<String> clientRequestHeaders, Interactor.Interaction interaction,\nString clientRequestContentType,\nInteractionManipulations interactionManipulations) throws IOException {\nEnumeration<String> hdrs = request.getHeaderNames();\nServletInputStream is = request.getInputStream();\nObject clientRequestBody = null;\n\/\/if (is.available() > 0) {\nif (isText(clientRequestContentType)) {\nclientRequestBody = null;\nString characterEncoding = request.getCharacterEncoding();\nif (characterEncoding == null) {\ncharacterEncoding = \"utf-8\";\n}\ntry (Scanner scanner = new Scanner(is, characterEncoding)) {\nif(scanner.hasNext()) {\nclientRequestBody = scanner.useDelimiter(\"\\\\A\").next();\n}\n\n}\n}\nif (shouldHavePrettyPrintedTextBodies() && clientRequestBody != null) {\nclientRequestBody = prettifyDocOrNot((String) clientRequestBody);\n}\n} else if(is.available() > 0){\nbyte[] targetArray = new byte[is.available()];\nis.read(targetArray);\nclientRequestBody = targetArray;\n}\n\/\/}\nwhile (hdrs.hasMoreElements()) {\n\/\/ TODO - make this cater for multiple lines with the same name\nString hdrName = hdrs.nextElement();\nString hdrVal = request.getHeader(hdrName);\nhdrVal = interactionManipulations.headerReplacement(hdrName, hdrVal);\nfinal String fullHeader = (getLowerCaseHeaders() ? hdrName.toLowerCase() : hdrName) + \": \" + hdrVal;\nclientRequestHeaders.add(fullHeader);\ninteractionManipulations.changeSingleHeaderForRequestToService(method, fullHeader, clientRequestHeaders);\n}\ninteractionManipulations.changeAnyHeadersForRequestToService(clientRequestHeaders);\n\nif (shouldHavePrettyPrintedTextBodies() && clientRequestBody != null) {\nclientRequestBody = prettifyDocOrNot((String) clientRequestBody);\n}\n} else if(is.available() > 0){\nbyte[] targetArray = new byte[is.available()];\nis.read(targetArray);\nclientRequestBody = targetArray;\n}\n\/\/}\nwhile (hdrs.hasMoreElements()) {\n\/\/ TODO - make this cater for multiple lines with the same name\nString hdrName = hdrs.nextElement();\nString hdrVal = request.getHeader(hdrName);\nhdrVal = interactionManipulations.headerReplacement(hdrName, hdrVal);\nfinal String fullHeader = (getLowerCaseHeaders() ? hdrName.toLowerCase() : hdrName) + \": \" + hdrVal;\nclientRequestHeaders.add(fullHeader);\ninteractionManipulations.changeSingleHeaderForRequestToService(method, fullHeader, clientRequestHeaders);\n}\ninteractionManipulations.changeAnyHeadersForRequestToService(clientRequestHeaders);\nif (clientRequestBody instanceof String) {\nclientRequestBody = interactionManipulations.changeBodyForRequestToService((String) clientRequestBody);","code_context_20":"private String prepareHeadersAndBodyForService(HttpServletRequest request, String method, String url,\nList<String> clientRequestHeaders, Interactor.Interaction interaction,\nString clientRequestContentType,\nInteractionManipulations interactionManipulations) throws IOException {\nEnumeration<String> hdrs = request.getHeaderNames();\nServletInputStream is = request.getInputStream();\nObject clientRequestBody = null;\n\/\/if (is.available() > 0) {\nif (isText(clientRequestContentType)) {\nclientRequestBody = null;\nString characterEncoding = request.getCharacterEncoding();\nif (characterEncoding == null) {\ncharacterEncoding = \"utf-8\";\n}\ntry (Scanner scanner = new Scanner(is, characterEncoding)) {\nif(scanner.hasNext()) {\nclientRequestBody = scanner.useDelimiter(\"\\\\A\").next();\n}\n}\nif (shouldHavePrettyPrintedTextBodies() && clientRequestBody != null) {\nclientRequestBody = prettifyDocOrNot((String) clientRequestBody);\n}\n} else if(is.available() > 0){\nbyte[] targetArray = new byte[is.available()];\nis.read(targetArray);\nclientRequestBody = targetArray;\n}\n\/\/}\n\n\/\/if (is.available() > 0) {\nif (isText(clientRequestContentType)) {\nclientRequestBody = null;\nString characterEncoding = request.getCharacterEncoding();\nif (characterEncoding == null) {\ncharacterEncoding = \"utf-8\";\n}\ntry (Scanner scanner = new Scanner(is, characterEncoding)) {\nif(scanner.hasNext()) {\nclientRequestBody = scanner.useDelimiter(\"\\\\A\").next();\n}\n}\nif (shouldHavePrettyPrintedTextBodies() && clientRequestBody != null) {\nclientRequestBody = prettifyDocOrNot((String) clientRequestBody);\n}\n} else if(is.available() > 0){\nbyte[] targetArray = new byte[is.available()];\nis.read(targetArray);\nclientRequestBody = targetArray;\n}\n\/\/}\nwhile (hdrs.hasMoreElements()) {\n\/\/ TODO - make this cater for multiple lines with the same name\nString hdrName = hdrs.nextElement();\nString hdrVal = request.getHeader(hdrName);\nhdrVal = interactionManipulations.headerReplacement(hdrName, hdrVal);\nfinal String fullHeader = (getLowerCaseHeaders() ? hdrName.toLowerCase() : hdrName) + \": \" + hdrVal;\nclientRequestHeaders.add(fullHeader);\ninteractionManipulations.changeSingleHeaderForRequestToService(method, fullHeader, clientRequestHeaders);\n}\ninteractionManipulations.changeAnyHeadersForRequestToService(clientRequestHeaders);\nif (clientRequestBody instanceof String) {\nclientRequestBody = interactionManipulations.changeBodyForRequestToService((String) clientRequestBody);\n}\nif (clientRequestBody == null) {\nclientRequestBody = \"\";\n}\ninteraction.noteClientRequestHeadersAndBody(clientRequestHeaders, clientRequestBody, clientRequestContentType);\nreturn interactionManipulations.changeUrlForRequestToService(url);\n}\n\nclientRequestBody = null;\nString characterEncoding = request.getCharacterEncoding();\nif (characterEncoding == null) {\ncharacterEncoding = \"utf-8\";\n}\ntry (Scanner scanner = new Scanner(is, characterEncoding)) {\nif(scanner.hasNext()) {\nclientRequestBody = scanner.useDelimiter(\"\\\\A\").next();\n}\n}\nif (shouldHavePrettyPrintedTextBodies() && clientRequestBody != null) {\nclientRequestBody = prettifyDocOrNot((String) clientRequestBody);\n}\n} else if(is.available() > 0){\nbyte[] targetArray = new byte[is.available()];\nis.read(targetArray);\nclientRequestBody = targetArray;\n}\n\/\/}\nwhile (hdrs.hasMoreElements()) {\n\/\/ TODO - make this cater for multiple lines with the same name\nString hdrName = hdrs.nextElement();\nString hdrVal = request.getHeader(hdrName);\nhdrVal = interactionManipulations.headerReplacement(hdrName, hdrVal);\nfinal String fullHeader = (getLowerCaseHeaders() ? hdrName.toLowerCase() : hdrName) + \": \" + hdrVal;\nclientRequestHeaders.add(fullHeader);\ninteractionManipulations.changeSingleHeaderForRequestToService(method, fullHeader, clientRequestHeaders);\n}\ninteractionManipulations.changeAnyHeadersForRequestToService(clientRequestHeaders);\nif (clientRequestBody instanceof String) {\nclientRequestBody = interactionManipulations.changeBodyForRequestToService((String) clientRequestBody);\n}\nif (clientRequestBody == null) {\nclientRequestBody = \"\";\n}\ninteraction.noteClientRequestHeadersAndBody(clientRequestHeaders, clientRequestBody, clientRequestContentType);\nreturn interactionManipulations.changeUrlForRequestToService(url);\n}","label":[1,0,0,0]}
{"id":14278,"original_code":"private void doWelcome(Session session) {\n        if (! session.isInteractive()) {\n            return;\n        }\n        File confDir = getConfigDirectory();\n        File welcomeFile = new File(confDir, \".welcome\");\n        if (welcomeFile.exists()) {\n            return;\n        }\n        \/*\n         * Create the welcome file since we are going to welcome them!\n         *\/\n        try {\n            welcomeFile.createNewFile();\n        }\n        catch (IOException e) {\n            System.err.println(\"WARNING: Failed to create \" + welcomeFile \n                + \": \" + e.getMessage());\n            return;\n        }\n        \/*\n         * Here's a hack.  The \".welcome\" file is a recent change to jsqsh, and\n         * we don't want to do the whole welcome thing if an existing jsqsh user\n         * already has a ~\/.jsqsh but doesn't have a .welcome file in it. To avoid\n         * this, check to see if drivers.xml is older than the date at which this\n         * comment was written and don't do the setup activities.\n         *\/\n        File driversFile = new File(confDir, \"drivers.xml\");\n        if (driversFile.exists())\n        {\n            long lastModified = driversFile.lastModified();\n            \/*\n             * Directory was created prior to \"now\" (when I am typing this comment),\n             * so pretend the welcome was done\n             *\/\n            if (lastModified < 1392411017075L) {\n                return;\n            }\n        }\n        HelpTopic welcome = helpManager.getTopic(\"welcome\");\n        System.out.println(welcome.getHelp());\n        session.out.println();\n        session.out.println(\"You will now enter the jsqsh setup wizard.\");\n        try {\n            getConsole().readline(\"Hit enter to continue: \", false);\n            Command command = session.getCommandManager().getCommand(\"\\\\setup\");\n            command.execute(session, new String [] { });\n        }\n        catch (Exception e) {\n            \/* NOT SURE WHAT TO DO HERE *\/\n            e.printStackTrace();\n        }\n    }","code":"private void doWelcome(Session session) {\n        if (! session.isInteractive()) {\n            return;\n        }\n        File confDir = getConfigDirectory();\n        File welcomeFile = new File(confDir, \".welcome\");\n        if (welcomeFile.exists()) {\n            return;\n        }\n       \n        try {\n            welcomeFile.createNewFile();\n        }\n        catch (IOException e) {\n            System.err.println(\"WARNING: Failed to create \" + welcomeFile \n                + \": \" + e.getMessage());\n            return;\n        }\n       \n        File driversFile = new File(confDir, \"drivers.xml\");\n        if (driversFile.exists())\n        {\n            long lastModified = driversFile.lastModified();\n           \n            if (lastModified < 1392411017075L) {\n                return;\n            }\n        }\n        HelpTopic welcome = helpManager.getTopic(\"welcome\");\n        System.out.println(welcome.getHelp());\n        session.out.println();\n        session.out.println(\"You will now enter the jsqsh setup wizard.\");\n        try {\n            getConsole().readline(\"Hit enter to continue: \", false);\n            Command command = session.getCommandManager().getCommand(\"\\\\setup\");\n            command.execute(session, new String [] { });\n        }\n        catch (Exception e) {\n           \n            e.printStackTrace();\n        }\n    }","cleancode":"private void dowelcome(session session) { if (! session.isinteractive()) { return; } file confdir = getconfigdirectory(); file welcomefile = new file(confdir, \".welcome\"); if (welcomefile.exists()) { return; } try { welcomefile.createnewfile(); } catch (ioexception e) { system.err.println(\"warning: failed to create \" + welcomefile + \": \" + e.getmessage()); return; } file driversfile = new file(confdir, \"drivers.xml\"); if (driversfile.exists()) { long lastmodified = driversfile.lastmodified(); if (lastmodified < 1392411017075l) { return; } } helptopic welcome = helpmanager.gettopic(\"welcome\"); system.out.println(welcome.gethelp()); session.out.println(); session.out.println(\"you will now enter the jsqsh setup wizard.\"); try { getconsole().readline(\"hit enter to continue: \", false); command command = session.getcommandmanager().getcommand(\"\\\\setup\"); command.execute(session, new string [] { }); } catch (exception e) { e.printstacktrace(); } }","comment":"\/** * do all of the \"welcome to the wonderful world of jsqsh activities\" *\/\n\/* * create the welcome file since we are going to welcome them! *\/\n\/* * here's a hack. the \".welcome\" file is a recent change to jsqsh, and * we don't want to do the whole welcome thing if an existing jsqsh user * already has a ~\/.jsqsh but doesn't have a .welcome file in it. to avoid * this, check to see if drivers.xml is older than the date at which this * comment was written and don't do the setup activities. *\/\n\/* * directory was created prior to \"now\" (when i am typing this comment), * so pretend the welcome was done *\/\n\/* not sure what to do here *\/","repo":"scottwakeling\/jsqsh","code_context_2":"private void doWelcome(Session session) {\nif (! session.isInteractive()) {\nreturn;\n}\nFile confDir = getConfigDirectory();\nFile welcomeFile = new File(confDir, \".welcome\");\nif (welcomeFile.exists()) {\nreturn;\n}\n\/*\n* Create the welcome file since we are going to welcome them!\n*\/\ntry {\nwelcomeFile.createNewFile();\n}\ncatch (IOException e) {\nSystem.err.println(\"WARNING: Failed to create \" + welcomeFile\n+ \": \" + e.getMessage());\nreturn;\n}\n\/*\n* Here's a hack. The \".welcome\" file is a recent change to jsqsh, and\n* we don't want to do the whole welcome thing if an existing jsqsh user\n* already has a ~\/.jsqsh but doesn't have a .welcome file in it. To avoid\n* this, check to see if drivers.xml is older than the date at which this\n* comment was written and don't do the setup activities.\n*\/\nFile driversFile = new File(confDir, \"drivers.xml\");\nif (driversFile.exists())\n{\nlong lastModified = driversFile.lastModified();\n\/*\n* Directory was created prior to \"now\" (when I am typing this comment),\n* so pretend the welcome was done\n*\/\nif (lastModified < 1392411017075L) {\nreturn;\n}\n}\nHelpTopic welcome = helpManager.getTopic(\"welcome\");\nSystem.out.println(welcome.getHelp());\nsession.out.println();\nsession.out.println(\"You will now enter the jsqsh setup wizard.\");\ntry {\ngetConsole().readline(\"Hit enter to continue: \", false);\nCommand command = session.getCommandManager().getCommand(\"\\\\setup\");\ncommand.execute(session, new String [] { });\n}\ncatch (Exception e) {\n\/* NOT SURE WHAT TO DO HERE *\/\ne.printStackTrace();\n}\n}\n\nreturn;\n}\n\/*\n* Create the welcome file since we are going to welcome them!\n*\/\ntry {\nwelcomeFile.createNewFile();\n\nreturn;\n}\n\/*\n* Create the welcome file since we are going to welcome them!\n*\/\ntry {\nwelcomeFile.createNewFile();\n}\ncatch (IOException e) {\nSystem.err.println(\"WARNING: Failed to create \" + welcomeFile\n+ \": \" + e.getMessage());\n\nreturn;\n}\n\/*\n* Create the welcome file since we are going to welcome them!\n*\/\ntry {\nwelcomeFile.createNewFile();\n}\n\n}\ncatch (Exception e) {\n\/* NOT SURE WHAT TO DO HERE *\/\ne.printStackTrace();\n}","code_context_10":"private void doWelcome(Session session) {\nif (! session.isInteractive()) {\nreturn;\n}\nFile confDir = getConfigDirectory();\nFile welcomeFile = new File(confDir, \".welcome\");\nif (welcomeFile.exists()) {\nreturn;\n}\n\/*\n* Create the welcome file since we are going to welcome them!\n*\/\ntry {\nwelcomeFile.createNewFile();\n}\ncatch (IOException e) {\nSystem.err.println(\"WARNING: Failed to create \" + welcomeFile\n+ \": \" + e.getMessage());\nreturn;\n}\n\/*\n* Here's a hack. The \".welcome\" file is a recent change to jsqsh, and\n* we don't want to do the whole welcome thing if an existing jsqsh user\n* already has a ~\/.jsqsh but doesn't have a .welcome file in it. To avoid\n* this, check to see if drivers.xml is older than the date at which this\n* comment was written and don't do the setup activities.\n*\/\nFile driversFile = new File(confDir, \"drivers.xml\");\nif (driversFile.exists())\n{\nlong lastModified = driversFile.lastModified();\n\/*\n* Directory was created prior to \"now\" (when I am typing this comment),\n* so pretend the welcome was done\n*\/\nif (lastModified < 1392411017075L) {\nreturn;\n}\n}\nHelpTopic welcome = helpManager.getTopic(\"welcome\");\nSystem.out.println(welcome.getHelp());\nsession.out.println();\nsession.out.println(\"You will now enter the jsqsh setup wizard.\");\ntry {\ngetConsole().readline(\"Hit enter to continue: \", false);\nCommand command = session.getCommandManager().getCommand(\"\\\\setup\");\ncommand.execute(session, new String [] { });\n}\ncatch (Exception e) {\n\/* NOT SURE WHAT TO DO HERE *\/\ne.printStackTrace();\n}\n}\n\nprivate void doWelcome(Session session) {\nif (! session.isInteractive()) {\nreturn;\n}\nFile confDir = getConfigDirectory();\nFile welcomeFile = new File(confDir, \".welcome\");\nif (welcomeFile.exists()) {\nreturn;\n}\n\/*\n* Create the welcome file since we are going to welcome them!\n*\/\ntry {\nwelcomeFile.createNewFile();\n}\ncatch (IOException e) {\nSystem.err.println(\"WARNING: Failed to create \" + welcomeFile\n+ \": \" + e.getMessage());\nreturn;\n}\n\/*\n* Here's a hack. The \".welcome\" file is a recent change to jsqsh, and\n\nprivate void doWelcome(Session session) {\nif (! session.isInteractive()) {\nreturn;\n}\nFile confDir = getConfigDirectory();\nFile welcomeFile = new File(confDir, \".welcome\");\nif (welcomeFile.exists()) {\nreturn;\n}\n\/*\n* Create the welcome file since we are going to welcome them!\n*\/\ntry {\nwelcomeFile.createNewFile();\n}\ncatch (IOException e) {\nSystem.err.println(\"WARNING: Failed to create \" + welcomeFile\n+ \": \" + e.getMessage());\nreturn;\n}\n\/*\n* Here's a hack. The \".welcome\" file is a recent change to jsqsh, and\n* we don't want to do the whole welcome thing if an existing jsqsh user\n* already has a ~\/.jsqsh but doesn't have a .welcome file in it. To avoid\n* this, check to see if drivers.xml is older than the date at which this\n* comment was written and don't do the setup activities.\n\nprivate void doWelcome(Session session) {\nif (! session.isInteractive()) {\nreturn;\n}\nFile confDir = getConfigDirectory();\nFile welcomeFile = new File(confDir, \".welcome\");\nif (welcomeFile.exists()) {\nreturn;\n}\n\/*\n* Create the welcome file since we are going to welcome them!\n*\/\ntry {\nwelcomeFile.createNewFile();\n}\ncatch (IOException e) {\nSystem.err.println(\"WARNING: Failed to create \" + welcomeFile\n+ \": \" + e.getMessage());\nreturn;\n}\n\/*\n* Here's a hack. The \".welcome\" file is a recent change to jsqsh, and\n* we don't want to do the whole welcome thing if an existing jsqsh user\n\nHelpTopic welcome = helpManager.getTopic(\"welcome\");\nSystem.out.println(welcome.getHelp());\nsession.out.println();\nsession.out.println(\"You will now enter the jsqsh setup wizard.\");\ntry {\ngetConsole().readline(\"Hit enter to continue: \", false);\nCommand command = session.getCommandManager().getCommand(\"\\\\setup\");\ncommand.execute(session, new String [] { });\n}\ncatch (Exception e) {\n\/* NOT SURE WHAT TO DO HERE *\/\ne.printStackTrace();\n}\n}","code_context_20":"private void doWelcome(Session session) {\nif (! session.isInteractive()) {\nreturn;\n}\nFile confDir = getConfigDirectory();\nFile welcomeFile = new File(confDir, \".welcome\");\nif (welcomeFile.exists()) {\nreturn;\n}\n\/*\n* Create the welcome file since we are going to welcome them!\n*\/\ntry {\nwelcomeFile.createNewFile();\n}\ncatch (IOException e) {\nSystem.err.println(\"WARNING: Failed to create \" + welcomeFile\n+ \": \" + e.getMessage());\nreturn;\n}\n\/*\n* Here's a hack. The \".welcome\" file is a recent change to jsqsh, and\n* we don't want to do the whole welcome thing if an existing jsqsh user\n* already has a ~\/.jsqsh but doesn't have a .welcome file in it. To avoid\n* this, check to see if drivers.xml is older than the date at which this\n* comment was written and don't do the setup activities.\n*\/\nFile driversFile = new File(confDir, \"drivers.xml\");\nif (driversFile.exists())\n{\nlong lastModified = driversFile.lastModified();\n\/*\n* Directory was created prior to \"now\" (when I am typing this comment),\n* so pretend the welcome was done\n*\/\nif (lastModified < 1392411017075L) {\nreturn;\n}\n}\nHelpTopic welcome = helpManager.getTopic(\"welcome\");\nSystem.out.println(welcome.getHelp());\nsession.out.println();\nsession.out.println(\"You will now enter the jsqsh setup wizard.\");\ntry {\ngetConsole().readline(\"Hit enter to continue: \", false);\nCommand command = session.getCommandManager().getCommand(\"\\\\setup\");\ncommand.execute(session, new String [] { });\n}\ncatch (Exception e) {\n\/* NOT SURE WHAT TO DO HERE *\/\ne.printStackTrace();\n}\n}\n\nprivate void doWelcome(Session session) {\nif (! session.isInteractive()) {\nreturn;\n}\nFile confDir = getConfigDirectory();\nFile welcomeFile = new File(confDir, \".welcome\");\nif (welcomeFile.exists()) {\nreturn;\n}\n\/*\n* Create the welcome file since we are going to welcome them!\n*\/\ntry {\nwelcomeFile.createNewFile();\n}\ncatch (IOException e) {\nSystem.err.println(\"WARNING: Failed to create \" + welcomeFile\n+ \": \" + e.getMessage());\nreturn;\n}\n\/*\n* Here's a hack. The \".welcome\" file is a recent change to jsqsh, and\n* we don't want to do the whole welcome thing if an existing jsqsh user\n* already has a ~\/.jsqsh but doesn't have a .welcome file in it. To avoid\n* this, check to see if drivers.xml is older than the date at which this\n* comment was written and don't do the setup activities.\n*\/\nFile driversFile = new File(confDir, \"drivers.xml\");\nif (driversFile.exists())\n{\nlong lastModified = driversFile.lastModified();\n\/*\n\nprivate void doWelcome(Session session) {\nif (! session.isInteractive()) {\nreturn;\n}\nFile confDir = getConfigDirectory();\nFile welcomeFile = new File(confDir, \".welcome\");\nif (welcomeFile.exists()) {\nreturn;\n}\n\/*\n* Create the welcome file since we are going to welcome them!\n*\/\ntry {\nwelcomeFile.createNewFile();\n}\ncatch (IOException e) {\nSystem.err.println(\"WARNING: Failed to create \" + welcomeFile\n+ \": \" + e.getMessage());\nreturn;\n}\n\/*\n* Here's a hack. The \".welcome\" file is a recent change to jsqsh, and\n* we don't want to do the whole welcome thing if an existing jsqsh user\n* already has a ~\/.jsqsh but doesn't have a .welcome file in it. To avoid\n* this, check to see if drivers.xml is older than the date at which this\n* comment was written and don't do the setup activities.\n*\/\nFile driversFile = new File(confDir, \"drivers.xml\");\nif (driversFile.exists())\n{\nlong lastModified = driversFile.lastModified();\n\/*\n* Directory was created prior to \"now\" (when I am typing this comment),\n* so pretend the welcome was done\n*\/\nif (lastModified < 1392411017075L) {\n\nprivate void doWelcome(Session session) {\nif (! session.isInteractive()) {\nreturn;\n}\nFile confDir = getConfigDirectory();\nFile welcomeFile = new File(confDir, \".welcome\");\nif (welcomeFile.exists()) {\nreturn;\n}\n\/*\n* Create the welcome file since we are going to welcome them!\n*\/\ntry {\nwelcomeFile.createNewFile();\n}\ncatch (IOException e) {\nSystem.err.println(\"WARNING: Failed to create \" + welcomeFile\n+ \": \" + e.getMessage());\nreturn;\n}\n\/*\n* Here's a hack. The \".welcome\" file is a recent change to jsqsh, and\n* we don't want to do the whole welcome thing if an existing jsqsh user\n* already has a ~\/.jsqsh but doesn't have a .welcome file in it. To avoid\n* this, check to see if drivers.xml is older than the date at which this\n* comment was written and don't do the setup activities.\n*\/\nFile driversFile = new File(confDir, \"drivers.xml\");\nif (driversFile.exists())\n{\nlong lastModified = driversFile.lastModified();\n\/*\n* Directory was created prior to \"now\" (when I am typing this comment),\n\n{\nlong lastModified = driversFile.lastModified();\n\/*\n* Directory was created prior to \"now\" (when I am typing this comment),\n* so pretend the welcome was done\n*\/\nif (lastModified < 1392411017075L) {\nreturn;\n}\n}\nHelpTopic welcome = helpManager.getTopic(\"welcome\");\nSystem.out.println(welcome.getHelp());\nsession.out.println();\nsession.out.println(\"You will now enter the jsqsh setup wizard.\");\ntry {\ngetConsole().readline(\"Hit enter to continue: \", false);\nCommand command = session.getCommandManager().getCommand(\"\\\\setup\");\ncommand.execute(session, new String [] { });\n}\ncatch (Exception e) {\n\/* NOT SURE WHAT TO DO HERE *\/\ne.printStackTrace();\n}\n}","label":[1,0,0,0]}
{"id":14375,"original_code":"private void networkNameMouseClicked(java.awt.event.MouseEvent evt) {\/\/GEN-FIRST:event_networkNameMouseClicked\n        \/\/ TODO add your handling code here:\n    \/\/    jTextField1.setText(\"\");\n    }","code":"private void networkNameMouseClicked(java.awt.event.MouseEvent evt) {       \n   \n    }","cleancode":"private void networknamemouseclicked(java.awt.event.mouseevent evt) { }","comment":"\/\/gen-first:event_networknamemouseclicked\n\/\/ todo add your handling code here: \/\/ jtextfield1.settext(\"\");","repo":"rohit-khokle\/Medicare","code_context_2":"private void networkNameMouseClicked(java.awt.event.MouseEvent evt) {\/\/GEN-FIRST:event_networkNameMouseClicked\n\/\/ TODO add your handling code here:\n\/\/ jTextField1.setText(\"\");\n\nprivate void networkNameMouseClicked(java.awt.event.MouseEvent evt) {\/\/GEN-FIRST:event_networkNameMouseClicked\n\/\/ TODO add your handling code here:\n\/\/ jTextField1.setText(\"\");\n}","code_context_10":"private void networkNameMouseClicked(java.awt.event.MouseEvent evt) {\/\/GEN-FIRST:event_networkNameMouseClicked\n\/\/ TODO add your handling code here:\n\/\/ jTextField1.setText(\"\");\n}\n\nprivate void networkNameMouseClicked(java.awt.event.MouseEvent evt) {\/\/GEN-FIRST:event_networkNameMouseClicked\n\/\/ TODO add your handling code here:\n\/\/ jTextField1.setText(\"\");\n}","code_context_20":"private void networkNameMouseClicked(java.awt.event.MouseEvent evt) {\/\/GEN-FIRST:event_networkNameMouseClicked\n\/\/ TODO add your handling code here:\n\/\/ jTextField1.setText(\"\");\n}\n\nprivate void networkNameMouseClicked(java.awt.event.MouseEvent evt) {\/\/GEN-FIRST:event_networkNameMouseClicked\n\/\/ TODO add your handling code here:\n\/\/ jTextField1.setText(\"\");\n}","label":[0,1,0,0]}
{"id":22631,"original_code":"public static ExchangeUnitAuxiliaryInputStatistics getAuxiliaryStatisticsWithVPra(KepProblemData<ExchangeUnit,DonorEdge> kepProblemData){\n\t\tAuxiliaryInputStatistics<ExchangeUnit,DonorEdge> regular = getAuxiliaryStatistics(kepProblemData);\n\t\tList<Donor> donors = new ArrayList<Donor>();\n\t\tList<Receiver> receivers = new ArrayList<Receiver>();\n\t\tfor(ExchangeUnit unit: kepProblemData.getGraph().getVertices()){\n\t\t\tfor(Donor donor: unit.getDonor()){\n\t\t\t\tdonors.add(donor);\n\t\t\t}\n\t\t\tif(!kepProblemData.getRootNodes().contains(unit)){\n\t\t\t\treceivers.add(unit.getReceiver());\n\t\t\t}\n\t\t}\t\t\n\t\tImmutableMap.Builder<Receiver,Double> builder = ImmutableMap.<Receiver,Double>builder();\n\t\tfor(Receiver receiver: receivers){\n\t\t\tint count = 0;\n\t\t\tfor(Donor donor: donors){\n\t\t\t\tif(!receiver.getTissueTypeSensitivity().isCompatible(donor.getTissueType())){\n\t\t\t\t\tcount++;\n\t\t\t\t}\n\t\t\t}\n\t\t\tbuilder.put(receiver, 100*count\/(double)donors.size());\n\t\t}\n\t\treturn new ExchangeUnitAuxiliaryInputStatistics(\n\t\t\t\tregular.getDonorPowerPostPreference(), \n\t\t\t\tregular.getReceiverPowerPostPreference(),\n\t\t\t\tbuilder.build()) ;\n\t}","code":"public static ExchangeUnitAuxiliaryInputStatistics getAuxiliaryStatisticsWithVPra(KepProblemData<ExchangeUnit,DonorEdge> kepProblemData){\n\t\tAuxiliaryInputStatistics<ExchangeUnit,DonorEdge> regular = getAuxiliaryStatistics(kepProblemData);\n\t\tList<Donor> donors = new ArrayList<Donor>();\n\t\tList<Receiver> receivers = new ArrayList<Receiver>();\n\t\tfor(ExchangeUnit unit: kepProblemData.getGraph().getVertices()){\n\t\t\tfor(Donor donor: unit.getDonor()){\n\t\t\t\tdonors.add(donor);\n\t\t\t}\n\t\t\tif(!kepProblemData.getRootNodes().contains(unit)){\n\t\t\t\treceivers.add(unit.getReceiver());\n\t\t\t}\n\t\t}\t\t\n\t\tImmutableMap.Builder<Receiver,Double> builder = ImmutableMap.<Receiver,Double>builder();\n\t\tfor(Receiver receiver: receivers){\n\t\t\tint count = 0;\n\t\t\tfor(Donor donor: donors){\n\t\t\t\tif(!receiver.getTissueTypeSensitivity().isCompatible(donor.getTissueType())){\n\t\t\t\t\tcount++;\n\t\t\t\t}\n\t\t\t}\n\t\t\tbuilder.put(receiver, 100*count\/(double)donors.size());\n\t\t}\n\t\treturn new ExchangeUnitAuxiliaryInputStatistics(\n\t\t\t\tregular.getDonorPowerPostPreference(), \n\t\t\t\tregular.getReceiverPowerPostPreference(),\n\t\t\t\tbuilder.build()) ;\n\t}","cleancode":"public static exchangeunitauxiliaryinputstatistics getauxiliarystatisticswithvpra(kepproblemdata<exchangeunit,donoredge> kepproblemdata){ auxiliaryinputstatistics<exchangeunit,donoredge> regular = getauxiliarystatistics(kepproblemdata); list<donor> donors = new arraylist<donor>(); list<receiver> receivers = new arraylist<receiver>(); for(exchangeunit unit: kepproblemdata.getgraph().getvertices()){ for(donor donor: unit.getdonor()){ donors.add(donor); } if(!kepproblemdata.getrootnodes().contains(unit)){ receivers.add(unit.getreceiver()); } } immutablemap.builder<receiver,double> builder = immutablemap.<receiver,double>builder(); for(receiver receiver: receivers){ int count = 0; for(donor donor: donors){ if(!receiver.gettissuetypesensitivity().iscompatible(donor.gettissuetype())){ count++; } } builder.put(receiver, 100*count\/(double)donors.size()); } return new exchangeunitauxiliaryinputstatistics( regular.getdonorpowerpostpreference(), regular.getreceiverpowerpostpreference(), builder.build()) ; }","comment":"\/\/ todo(ross): this should take in a list of who we are comparing againt, not just use the current pool...","repo":"rma350\/kidneyExchange","code_context_2":"public static ExchangeUnitAuxiliaryInputStatistics getAuxiliaryStatisticsWithVPra(KepProblemData<ExchangeUnit,DonorEdge> kepProblemData){\nAuxiliaryInputStatistics<ExchangeUnit,DonorEdge> regular = getAuxiliaryStatistics(kepProblemData);\nList<Donor> donors = new ArrayList<Donor>();\nList<Receiver> receivers = new ArrayList<Receiver>();\nfor(ExchangeUnit unit: kepProblemData.getGraph().getVertices()){\nfor(Donor donor: unit.getDonor()){\ndonors.add(donor);\n}\nif(!kepProblemData.getRootNodes().contains(unit)){\nreceivers.add(unit.getReceiver());\n}\n}\nImmutableMap.Builder<Receiver,Double> builder = ImmutableMap.<Receiver,Double>builder();\nfor(Receiver receiver: receivers){\nint count = 0;\nfor(Donor donor: donors){\nif(!receiver.getTissueTypeSensitivity().isCompatible(donor.getTissueType())){\ncount++;\n}\n}\nbuilder.put(receiver, 100*count\/(double)donors.size());\n}\nreturn new ExchangeUnitAuxiliaryInputStatistics(\nregular.getDonorPowerPostPreference(),\nregular.getReceiverPowerPostPreference(),\nbuilder.build()) ;\n}","code_context_10":"public static ExchangeUnitAuxiliaryInputStatistics getAuxiliaryStatisticsWithVPra(KepProblemData<ExchangeUnit,DonorEdge> kepProblemData){\nAuxiliaryInputStatistics<ExchangeUnit,DonorEdge> regular = getAuxiliaryStatistics(kepProblemData);\nList<Donor> donors = new ArrayList<Donor>();\nList<Receiver> receivers = new ArrayList<Receiver>();\nfor(ExchangeUnit unit: kepProblemData.getGraph().getVertices()){\nfor(Donor donor: unit.getDonor()){\ndonors.add(donor);\n}\nif(!kepProblemData.getRootNodes().contains(unit)){\nreceivers.add(unit.getReceiver());\n}\n}\nImmutableMap.Builder<Receiver,Double> builder = ImmutableMap.<Receiver,Double>builder();\nfor(Receiver receiver: receivers){\nint count = 0;\nfor(Donor donor: donors){\nif(!receiver.getTissueTypeSensitivity().isCompatible(donor.getTissueType())){\ncount++;\n}\n}\nbuilder.put(receiver, 100*count\/(double)donors.size());\n}\nreturn new ExchangeUnitAuxiliaryInputStatistics(\nregular.getDonorPowerPostPreference(),\nregular.getReceiverPowerPostPreference(),\nbuilder.build()) ;\n}","code_context_20":"public static ExchangeUnitAuxiliaryInputStatistics getAuxiliaryStatisticsWithVPra(KepProblemData<ExchangeUnit,DonorEdge> kepProblemData){\nAuxiliaryInputStatistics<ExchangeUnit,DonorEdge> regular = getAuxiliaryStatistics(kepProblemData);\nList<Donor> donors = new ArrayList<Donor>();\nList<Receiver> receivers = new ArrayList<Receiver>();\nfor(ExchangeUnit unit: kepProblemData.getGraph().getVertices()){\nfor(Donor donor: unit.getDonor()){\ndonors.add(donor);\n}\nif(!kepProblemData.getRootNodes().contains(unit)){\nreceivers.add(unit.getReceiver());\n}\n}\nImmutableMap.Builder<Receiver,Double> builder = ImmutableMap.<Receiver,Double>builder();\nfor(Receiver receiver: receivers){\nint count = 0;\nfor(Donor donor: donors){\nif(!receiver.getTissueTypeSensitivity().isCompatible(donor.getTissueType())){\ncount++;\n}\n}\nbuilder.put(receiver, 100*count\/(double)donors.size());\n}\nreturn new ExchangeUnitAuxiliaryInputStatistics(\nregular.getDonorPowerPostPreference(),\nregular.getReceiverPowerPostPreference(),\nbuilder.build()) ;\n}","label":[1,0,0,0]}
{"id":14588,"original_code":"public void testSolve() {\n        RealMatrixImpl m = new RealMatrixImpl(testData);\n        RealMatrix mInv = new RealMatrixImpl(testDataInv);\n        \/\/ being a bit slothful here -- actually testing that X = A^-1 * B\n        assertClose(\"inverse-operate\",mInv.operate(testVector),\n            m.solve(testVector),normTolerance);\n        try {\n            m.solve(testVector2);\n            fail(\"expecting IllegalArgumentException\");\n        } catch (IllegalArgumentException ex) {\n            ;\n        }       \n        RealMatrix bs = new RealMatrixImpl(bigSingular);\n        try {\n            bs.solve(bs);\n            fail(\"Expecting InvalidMatrixException\");\n        } catch (InvalidMatrixException ex) {\n            ;\n        }\n        try {\n            m.solve(bs);\n            fail(\"Expecting IllegalArgumentException\");\n        } catch (IllegalArgumentException ex) {\n            ;\n        }\n        try {\n            new RealMatrixImpl(testData2).solve(bs);\n            fail(\"Expecting illegalArgumentException\");\n        } catch (IllegalArgumentException ex) {\n            ;\n        } \n        try {\n            (new RealMatrixImpl(testData2)).luDecompose();\n            fail(\"Expecting InvalidMatrixException\");\n        } catch (InvalidMatrixException ex) {\n            ;\n        }  \n    }","code":"public void testSolve() {\n        RealMatrixImpl m = new RealMatrixImpl(testData);\n        RealMatrix mInv = new RealMatrixImpl(testDataInv);\n       \n        assertClose(\"inverse-operate\",mInv.operate(testVector),\n            m.solve(testVector),normTolerance);\n        try {\n            m.solve(testVector2);\n            fail(\"expecting IllegalArgumentException\");\n        } catch (IllegalArgumentException ex) {\n            ;\n        }       \n        RealMatrix bs = new RealMatrixImpl(bigSingular);\n        try {\n            bs.solve(bs);\n            fail(\"Expecting InvalidMatrixException\");\n        } catch (InvalidMatrixException ex) {\n            ;\n        }\n        try {\n            m.solve(bs);\n            fail(\"Expecting IllegalArgumentException\");\n        } catch (IllegalArgumentException ex) {\n            ;\n        }\n        try {\n            new RealMatrixImpl(testData2).solve(bs);\n            fail(\"Expecting illegalArgumentException\");\n        } catch (IllegalArgumentException ex) {\n            ;\n        } \n        try {\n            (new RealMatrixImpl(testData2)).luDecompose();\n            fail(\"Expecting InvalidMatrixException\");\n        } catch (InvalidMatrixException ex) {\n            ;\n        }  \n    }","cleancode":"public void testsolve() { realmatriximpl m = new realmatriximpl(testdata); realmatrix minv = new realmatriximpl(testdatainv); assertclose(\"inverse-operate\",minv.operate(testvector), m.solve(testvector),normtolerance); try { m.solve(testvector2); fail(\"expecting illegalargumentexception\"); } catch (illegalargumentexception ex) { ; } realmatrix bs = new realmatriximpl(bigsingular); try { bs.solve(bs); fail(\"expecting invalidmatrixexception\"); } catch (invalidmatrixexception ex) { ; } try { m.solve(bs); fail(\"expecting illegalargumentexception\"); } catch (illegalargumentexception ex) { ; } try { new realmatriximpl(testdata2).solve(bs); fail(\"expecting illegalargumentexception\"); } catch (illegalargumentexception ex) { ; } try { (new realmatriximpl(testdata2)).ludecompose(); fail(\"expecting invalidmatrixexception\"); } catch (invalidmatrixexception ex) { ; } }","comment":"\/** test solve *\/\n\/\/ being a bit slothful here -- actually testing that x = a^-1 * b","repo":"svenpopping\/acfl-replication-package","code_context_2":"public void testSolve() {\nRealMatrixImpl m = new RealMatrixImpl(testData);\nRealMatrix mInv = new RealMatrixImpl(testDataInv);\n\/\/ being a bit slothful here -- actually testing that X = A^-1 * B\nassertClose(\"inverse-operate\",mInv.operate(testVector),\nm.solve(testVector),normTolerance);\ntry {\nm.solve(testVector2);\nfail(\"expecting IllegalArgumentException\");\n} catch (IllegalArgumentException ex) {\n;\n}\nRealMatrix bs = new RealMatrixImpl(bigSingular);\ntry {\nbs.solve(bs);\nfail(\"Expecting InvalidMatrixException\");\n} catch (InvalidMatrixException ex) {\n;\n}\ntry {\nm.solve(bs);\nfail(\"Expecting IllegalArgumentException\");\n} catch (IllegalArgumentException ex) {\n;\n}\ntry {\nnew RealMatrixImpl(testData2).solve(bs);\nfail(\"Expecting illegalArgumentException\");\n} catch (IllegalArgumentException ex) {\n;\n}\ntry {\n(new RealMatrixImpl(testData2)).luDecompose();\nfail(\"Expecting InvalidMatrixException\");\n} catch (InvalidMatrixException ex) {\n;\n}\n}\n\nRealMatrixImpl m = new RealMatrixImpl(testData);\nRealMatrix mInv = new RealMatrixImpl(testDataInv);\n\/\/ being a bit slothful here -- actually testing that X = A^-1 * B\nassertClose(\"inverse-operate\",mInv.operate(testVector),\nm.solve(testVector),normTolerance);","code_context_10":"public void testSolve() {\nRealMatrixImpl m = new RealMatrixImpl(testData);\nRealMatrix mInv = new RealMatrixImpl(testDataInv);\n\/\/ being a bit slothful here -- actually testing that X = A^-1 * B\nassertClose(\"inverse-operate\",mInv.operate(testVector),\nm.solve(testVector),normTolerance);\ntry {\nm.solve(testVector2);\nfail(\"expecting IllegalArgumentException\");\n} catch (IllegalArgumentException ex) {\n;\n}\nRealMatrix bs = new RealMatrixImpl(bigSingular);\ntry {\nbs.solve(bs);\nfail(\"Expecting InvalidMatrixException\");\n} catch (InvalidMatrixException ex) {\n;\n}\ntry {\nm.solve(bs);\nfail(\"Expecting IllegalArgumentException\");\n} catch (IllegalArgumentException ex) {\n;\n}\ntry {\nnew RealMatrixImpl(testData2).solve(bs);\nfail(\"Expecting illegalArgumentException\");\n} catch (IllegalArgumentException ex) {\n;\n}\ntry {\n(new RealMatrixImpl(testData2)).luDecompose();\nfail(\"Expecting InvalidMatrixException\");\n} catch (InvalidMatrixException ex) {\n;\n}\n}\n\npublic void testSolve() {\nRealMatrixImpl m = new RealMatrixImpl(testData);\nRealMatrix mInv = new RealMatrixImpl(testDataInv);\n\/\/ being a bit slothful here -- actually testing that X = A^-1 * B\nassertClose(\"inverse-operate\",mInv.operate(testVector),\nm.solve(testVector),normTolerance);\ntry {\nm.solve(testVector2);\nfail(\"expecting IllegalArgumentException\");\n} catch (IllegalArgumentException ex) {\n;\n}\nRealMatrix bs = new RealMatrixImpl(bigSingular);\ntry {","code_context_20":"public void testSolve() {\nRealMatrixImpl m = new RealMatrixImpl(testData);\nRealMatrix mInv = new RealMatrixImpl(testDataInv);\n\/\/ being a bit slothful here -- actually testing that X = A^-1 * B\nassertClose(\"inverse-operate\",mInv.operate(testVector),\nm.solve(testVector),normTolerance);\ntry {\nm.solve(testVector2);\nfail(\"expecting IllegalArgumentException\");\n} catch (IllegalArgumentException ex) {\n;\n}\nRealMatrix bs = new RealMatrixImpl(bigSingular);\ntry {\nbs.solve(bs);\nfail(\"Expecting InvalidMatrixException\");\n} catch (InvalidMatrixException ex) {\n;\n}\ntry {\nm.solve(bs);\nfail(\"Expecting IllegalArgumentException\");\n} catch (IllegalArgumentException ex) {\n;\n}\ntry {\nnew RealMatrixImpl(testData2).solve(bs);\nfail(\"Expecting illegalArgumentException\");\n} catch (IllegalArgumentException ex) {\n;\n}\ntry {\n(new RealMatrixImpl(testData2)).luDecompose();\nfail(\"Expecting InvalidMatrixException\");\n} catch (InvalidMatrixException ex) {\n;\n}\n}\n\npublic void testSolve() {\nRealMatrixImpl m = new RealMatrixImpl(testData);\nRealMatrix mInv = new RealMatrixImpl(testDataInv);\n\/\/ being a bit slothful here -- actually testing that X = A^-1 * B\nassertClose(\"inverse-operate\",mInv.operate(testVector),\nm.solve(testVector),normTolerance);\ntry {\nm.solve(testVector2);\nfail(\"expecting IllegalArgumentException\");\n} catch (IllegalArgumentException ex) {\n;\n}\nRealMatrix bs = new RealMatrixImpl(bigSingular);\ntry {\nbs.solve(bs);\nfail(\"Expecting InvalidMatrixException\");\n} catch (InvalidMatrixException ex) {\n;\n}\ntry {\nm.solve(bs);\nfail(\"Expecting IllegalArgumentException\");\n} catch (IllegalArgumentException ex) {\n;","label":[1,0,0,0]}
{"id":31003,"original_code":"public static CompositeValue create(ICPPClassType classType, IASTNode point, int nestingLevel) {\n\t\tSet<ICPPClassType> recursionProtectionSet = fCreateInProgress.get();\n\t\tif (!recursionProtectionSet.add(classType)) {\n\t\t\treturn new CompositeValue(null, ICPPEvaluation.EMPTY_ARRAY);\n\t\t}\n\t\ttry {\n\t\t\tif (sDEBUG && nestingLevel > 0) {\n\t\t\t\tSystem.out.println(\"CompositeValue.create(\" + ASTTypeUtil.getType(classType) + \", \" + nestingLevel + \")\");  \/\/$NON-NLS-1$\/\/$NON-NLS-2$ \/\/$NON-NLS-3$\n\t\t\t\tSystem.out.flush();\n\t\t\t}\n\t\t\tActivationRecord record = new ActivationRecord();\n\t\t\tICPPEvaluation[] values = new ICPPEvaluation[ClassTypeHelper.getFields(classType, point).length];\n\t\t\t\/\/ Recursively create all the base class member variables.\n\t\t\tICPPBase[] bases = ClassTypeHelper.getBases(classType, point);\n\t\t\tfor (ICPPBase base : bases) {\n\t\t\t\tIBinding baseClass = base.getBaseClass();\n\t\t\t\tif (baseClass instanceof ICPPClassType) {\n\t\t\t\t\tICPPClassType baseClassType = (ICPPClassType) baseClass;\n\t\t\t\t\tICPPField[] baseFields = ClassTypeHelper.getDeclaredFields(baseClassType, point);\n\t\t\t\t\tIValue compValue = CompositeValue.create(baseClassType, point, nestingLevel + 1);\n\t\t\t\t\tfor (ICPPField baseField : baseFields) {\n\t\t\t\t\t\tint fieldPos = CPPASTFieldReference.getFieldPosition(baseField);\n\t\t\t\t\t\tif (fieldPos == -1) {\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t}\n\t\t\t\t\t\trecord.update(baseField, compValue.getSubValue(fieldPos));\n\t\t\t\t\t\t\/\/ TODO(nathanridge): This won't work with multiple inheritance, since 'fieldPos'\n\t\t\t\t\t\t\/\/ is a field position in the base class' hierarchy, while values[] expects\n\t\t\t\t\t\t\/\/ as index a field position in classType's hierarchy.\n\t\t\t\t\t\tvalues[fieldPos] = compValue.getSubValue(fieldPos);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tICPPField[] fields = ClassTypeHelper.getDeclaredFields(classType, point);\n\t\t\tfor (ICPPField field : fields) {\n\t\t\t\tif (field.isStatic())\n\t\t\t\t\tcontinue;\n\t\t\t\tfinal ICPPEvaluation value = EvalUtil.getVariableValue(field, record, point);\n\t\t\t\tint fieldPos = CPPASTFieldReference.getFieldPosition(field);\n\t\t\t\tif (fieldPos == -1) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\trecord.update(field, value);\n\t\t\t\tvalues[fieldPos] = value;\n\t\t\t}\n\t\t\treturn new CompositeValue(null, values);\n\t\t} finally {\n\t\t\trecursionProtectionSet.remove(classType);\n\t\t}\n\t}","code":"public static CompositeValue create(ICPPClassType classType, IASTNode point, int nestingLevel) {\n\t\tSet<ICPPClassType> recursionProtectionSet = fCreateInProgress.get();\n\t\tif (!recursionProtectionSet.add(classType)) {\n\t\t\treturn new CompositeValue(null, ICPPEvaluation.EMPTY_ARRAY);\n\t\t}\n\t\ttry {\n\t\t\tif (sDEBUG && nestingLevel > 0) {\n\t\t\t\tSystem.out.println(\"CompositeValue.create(\" + ASTTypeUtil.getType(classType) + \", \" + nestingLevel + \")\"); \n\t\t\t\tSystem.out.flush();\n\t\t\t}\n\t\t\tActivationRecord record = new ActivationRecord();\n\t\t\tICPPEvaluation[] values = new ICPPEvaluation[ClassTypeHelper.getFields(classType, point).length];\n\t\t\n\t\t\tICPPBase[] bases = ClassTypeHelper.getBases(classType, point);\n\t\t\tfor (ICPPBase base : bases) {\n\t\t\t\tIBinding baseClass = base.getBaseClass();\n\t\t\t\tif (baseClass instanceof ICPPClassType) {\n\t\t\t\t\tICPPClassType baseClassType = (ICPPClassType) baseClass;\n\t\t\t\t\tICPPField[] baseFields = ClassTypeHelper.getDeclaredFields(baseClassType, point);\n\t\t\t\t\tIValue compValue = CompositeValue.create(baseClassType, point, nestingLevel + 1);\n\t\t\t\t\tfor (ICPPField baseField : baseFields) {\n\t\t\t\t\t\tint fieldPos = CPPASTFieldReference.getFieldPosition(baseField);\n\t\t\t\t\t\tif (fieldPos == -1) {\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t}\n\t\t\t\t\t\trecord.update(baseField, compValue.getSubValue(fieldPos));\n\t\t\t\t\t\n\t\t\t\t\t\n\t\t\t\t\t\n\t\t\t\t\t\tvalues[fieldPos] = compValue.getSubValue(fieldPos);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tICPPField[] fields = ClassTypeHelper.getDeclaredFields(classType, point);\n\t\t\tfor (ICPPField field : fields) {\n\t\t\t\tif (field.isStatic())\n\t\t\t\t\tcontinue;\n\t\t\t\tfinal ICPPEvaluation value = EvalUtil.getVariableValue(field, record, point);\n\t\t\t\tint fieldPos = CPPASTFieldReference.getFieldPosition(field);\n\t\t\t\tif (fieldPos == -1) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\trecord.update(field, value);\n\t\t\t\tvalues[fieldPos] = value;\n\t\t\t}\n\t\t\treturn new CompositeValue(null, values);\n\t\t} finally {\n\t\t\trecursionProtectionSet.remove(classType);\n\t\t}\n\t}","cleancode":"public static compositevalue create(icppclasstype classtype, iastnode point, int nestinglevel) { set<icppclasstype> recursionprotectionset = fcreateinprogress.get(); if (!recursionprotectionset.add(classtype)) { return new compositevalue(null, icppevaluation.empty_array); } try { if (sdebug && nestinglevel > 0) { system.out.println(\"compositevalue.create(\" + asttypeutil.gettype(classtype) + \", \" + nestinglevel + \")\"); system.out.flush(); } activationrecord record = new activationrecord(); icppevaluation[] values = new icppevaluation[classtypehelper.getfields(classtype, point).length]; icppbase[] bases = classtypehelper.getbases(classtype, point); for (icppbase base : bases) { ibinding baseclass = base.getbaseclass(); if (baseclass instanceof icppclasstype) { icppclasstype baseclasstype = (icppclasstype) baseclass; icppfield[] basefields = classtypehelper.getdeclaredfields(baseclasstype, point); ivalue compvalue = compositevalue.create(baseclasstype, point, nestinglevel + 1); for (icppfield basefield : basefields) { int fieldpos = cppastfieldreference.getfieldposition(basefield); if (fieldpos == -1) { continue; } record.update(basefield, compvalue.getsubvalue(fieldpos)); values[fieldpos] = compvalue.getsubvalue(fieldpos); } } } icppfield[] fields = classtypehelper.getdeclaredfields(classtype, point); for (icppfield field : fields) { if (field.isstatic()) continue; final icppevaluation value = evalutil.getvariablevalue(field, record, point); int fieldpos = cppastfieldreference.getfieldposition(field); if (fieldpos == -1) { continue; } record.update(field, value); values[fieldpos] = value; } return new compositevalue(null, values); } finally { recursionprotectionset.remove(classtype); } }","comment":"\/** * creates a value representing an instance of a class type, with the values of the fields * determined by the default member initializers only. constructors are not considered * when determining the values of the fields. *\/\n\/\/$non-nls-1$\/\/$non-nls-2$ \/\/$non-nls-3$\n\/\/ recursively create all the base class member variables.\n\/\/ todo(nathanridge): this won't work with multiple inheritance, since 'fieldpos' \/\/ is a field position in the base class' hierarchy, while values[] expects \/\/ as index a field position in classtype's hierarchy.","repo":"seemoo-lab\/polypyus_pdom","code_context_2":"public static CompositeValue create(ICPPClassType classType, IASTNode point, int nestingLevel) {\nSet<ICPPClassType> recursionProtectionSet = fCreateInProgress.get();\nif (!recursionProtectionSet.add(classType)) {\nreturn new CompositeValue(null, ICPPEvaluation.EMPTY_ARRAY);\n}\ntry {\nif (sDEBUG && nestingLevel > 0) {\nSystem.out.println(\"CompositeValue.create(\" + ASTTypeUtil.getType(classType) + \", \" + nestingLevel + \")\"); \/\/$NON-NLS-1$\/\/$NON-NLS-2$ \/\/$NON-NLS-3$\nSystem.out.flush();\n}\nActivationRecord record = new ActivationRecord();\nICPPEvaluation[] values = new ICPPEvaluation[ClassTypeHelper.getFields(classType, point).length];\n\/\/ Recursively create all the base class member variables.\nICPPBase[] bases = ClassTypeHelper.getBases(classType, point);\nfor (ICPPBase base : bases) {\nIBinding baseClass = base.getBaseClass();\nif (baseClass instanceof ICPPClassType) {\nICPPClassType baseClassType = (ICPPClassType) baseClass;\nICPPField[] baseFields = ClassTypeHelper.getDeclaredFields(baseClassType, point);\nIValue compValue = CompositeValue.create(baseClassType, point, nestingLevel + 1);\nfor (ICPPField baseField : baseFields) {\nint fieldPos = CPPASTFieldReference.getFieldPosition(baseField);\nif (fieldPos == -1) {\ncontinue;\n}\nrecord.update(baseField, compValue.getSubValue(fieldPos));\n\/\/ TODO(nathanridge): This won't work with multiple inheritance, since 'fieldPos'\n\/\/ is a field position in the base class' hierarchy, while values[] expects\n\/\/ as index a field position in classType's hierarchy.\nvalues[fieldPos] = compValue.getSubValue(fieldPos);\n}\n}\n}\nICPPField[] fields = ClassTypeHelper.getDeclaredFields(classType, point);\nfor (ICPPField field : fields) {\nif (field.isStatic())\ncontinue;\nfinal ICPPEvaluation value = EvalUtil.getVariableValue(field, record, point);\nint fieldPos = CPPASTFieldReference.getFieldPosition(field);\nif (fieldPos == -1) {\ncontinue;\n}\nrecord.update(field, value);\nvalues[fieldPos] = value;\n}\nreturn new CompositeValue(null, values);\n} finally {\nrecursionProtectionSet.remove(classType);\n}\n}\n\ntry {\nif (sDEBUG && nestingLevel > 0) {\nSystem.out.println(\"CompositeValue.create(\" + ASTTypeUtil.getType(classType) + \", \" + nestingLevel + \")\"); \/\/$NON-NLS-1$\/\/$NON-NLS-2$ \/\/$NON-NLS-3$\nSystem.out.flush();\n}\n\nActivationRecord record = new ActivationRecord();\nICPPEvaluation[] values = new ICPPEvaluation[ClassTypeHelper.getFields(classType, point).length];\n\/\/ Recursively create all the base class member variables.\nICPPBase[] bases = ClassTypeHelper.getBases(classType, point);\nfor (ICPPBase base : bases) {\n\n}\nrecord.update(baseField, compValue.getSubValue(fieldPos));\n\/\/ TODO(nathanridge): This won't work with multiple inheritance, since 'fieldPos'\n\/\/ is a field position in the base class' hierarchy, while values[] expects\n\/\/ as index a field position in classType's hierarchy.\nvalues[fieldPos] = compValue.getSubValue(fieldPos);\n}","code_context_10":"public static CompositeValue create(ICPPClassType classType, IASTNode point, int nestingLevel) {\nSet<ICPPClassType> recursionProtectionSet = fCreateInProgress.get();\nif (!recursionProtectionSet.add(classType)) {\nreturn new CompositeValue(null, ICPPEvaluation.EMPTY_ARRAY);\n}\ntry {\nif (sDEBUG && nestingLevel > 0) {\nSystem.out.println(\"CompositeValue.create(\" + ASTTypeUtil.getType(classType) + \", \" + nestingLevel + \")\"); \/\/$NON-NLS-1$\/\/$NON-NLS-2$ \/\/$NON-NLS-3$\nSystem.out.flush();\n}\nActivationRecord record = new ActivationRecord();\nICPPEvaluation[] values = new ICPPEvaluation[ClassTypeHelper.getFields(classType, point).length];\n\/\/ Recursively create all the base class member variables.\nICPPBase[] bases = ClassTypeHelper.getBases(classType, point);\nfor (ICPPBase base : bases) {\nIBinding baseClass = base.getBaseClass();\nif (baseClass instanceof ICPPClassType) {\nICPPClassType baseClassType = (ICPPClassType) baseClass;\nICPPField[] baseFields = ClassTypeHelper.getDeclaredFields(baseClassType, point);\nIValue compValue = CompositeValue.create(baseClassType, point, nestingLevel + 1);\nfor (ICPPField baseField : baseFields) {\nint fieldPos = CPPASTFieldReference.getFieldPosition(baseField);\nif (fieldPos == -1) {\ncontinue;\n}\nrecord.update(baseField, compValue.getSubValue(fieldPos));\n\/\/ TODO(nathanridge): This won't work with multiple inheritance, since 'fieldPos'\n\/\/ is a field position in the base class' hierarchy, while values[] expects\n\/\/ as index a field position in classType's hierarchy.\nvalues[fieldPos] = compValue.getSubValue(fieldPos);\n}\n}\n}\nICPPField[] fields = ClassTypeHelper.getDeclaredFields(classType, point);\nfor (ICPPField field : fields) {\nif (field.isStatic())\ncontinue;\nfinal ICPPEvaluation value = EvalUtil.getVariableValue(field, record, point);\nint fieldPos = CPPASTFieldReference.getFieldPosition(field);\nif (fieldPos == -1) {\ncontinue;\n}\nrecord.update(field, value);\nvalues[fieldPos] = value;\n}\nreturn new CompositeValue(null, values);\n} finally {\nrecursionProtectionSet.remove(classType);\n}\n}\n\npublic static CompositeValue create(ICPPClassType classType, IASTNode point, int nestingLevel) {\nSet<ICPPClassType> recursionProtectionSet = fCreateInProgress.get();\nif (!recursionProtectionSet.add(classType)) {\nreturn new CompositeValue(null, ICPPEvaluation.EMPTY_ARRAY);\n}\ntry {\nif (sDEBUG && nestingLevel > 0) {\nSystem.out.println(\"CompositeValue.create(\" + ASTTypeUtil.getType(classType) + \", \" + nestingLevel + \")\"); \/\/$NON-NLS-1$\/\/$NON-NLS-2$ \/\/$NON-NLS-3$\nSystem.out.flush();\n}\nActivationRecord record = new ActivationRecord();\nICPPEvaluation[] values = new ICPPEvaluation[ClassTypeHelper.getFields(classType, point).length];\n\/\/ Recursively create all the base class member variables.\nICPPBase[] bases = ClassTypeHelper.getBases(classType, point);\nfor (ICPPBase base : bases) {\nIBinding baseClass = base.getBaseClass();\nif (baseClass instanceof ICPPClassType) {\nICPPClassType baseClassType = (ICPPClassType) baseClass;\n\nif (!recursionProtectionSet.add(classType)) {\nreturn new CompositeValue(null, ICPPEvaluation.EMPTY_ARRAY);\n}\ntry {\nif (sDEBUG && nestingLevel > 0) {\nSystem.out.println(\"CompositeValue.create(\" + ASTTypeUtil.getType(classType) + \", \" + nestingLevel + \")\"); \/\/$NON-NLS-1$\/\/$NON-NLS-2$ \/\/$NON-NLS-3$\nSystem.out.flush();\n}\nActivationRecord record = new ActivationRecord();\nICPPEvaluation[] values = new ICPPEvaluation[ClassTypeHelper.getFields(classType, point).length];\n\/\/ Recursively create all the base class member variables.\nICPPBase[] bases = ClassTypeHelper.getBases(classType, point);\nfor (ICPPBase base : bases) {\nIBinding baseClass = base.getBaseClass();\nif (baseClass instanceof ICPPClassType) {\nICPPClassType baseClassType = (ICPPClassType) baseClass;\nICPPField[] baseFields = ClassTypeHelper.getDeclaredFields(baseClassType, point);\nIValue compValue = CompositeValue.create(baseClassType, point, nestingLevel + 1);\nfor (ICPPField baseField : baseFields) {\nint fieldPos = CPPASTFieldReference.getFieldPosition(baseField);\nif (fieldPos == -1) {\n\nif (baseClass instanceof ICPPClassType) {\nICPPClassType baseClassType = (ICPPClassType) baseClass;\nICPPField[] baseFields = ClassTypeHelper.getDeclaredFields(baseClassType, point);\nIValue compValue = CompositeValue.create(baseClassType, point, nestingLevel + 1);\nfor (ICPPField baseField : baseFields) {\nint fieldPos = CPPASTFieldReference.getFieldPosition(baseField);\nif (fieldPos == -1) {\ncontinue;\n}\nrecord.update(baseField, compValue.getSubValue(fieldPos));\n\/\/ TODO(nathanridge): This won't work with multiple inheritance, since 'fieldPos'\n\/\/ is a field position in the base class' hierarchy, while values[] expects\n\/\/ as index a field position in classType's hierarchy.\nvalues[fieldPos] = compValue.getSubValue(fieldPos);\n}\n}\n}\nICPPField[] fields = ClassTypeHelper.getDeclaredFields(classType, point);\nfor (ICPPField field : fields) {\nif (field.isStatic())\ncontinue;\nfinal ICPPEvaluation value = EvalUtil.getVariableValue(field, record, point);\nint fieldPos = CPPASTFieldReference.getFieldPosition(field);","code_context_20":"public static CompositeValue create(ICPPClassType classType, IASTNode point, int nestingLevel) {\nSet<ICPPClassType> recursionProtectionSet = fCreateInProgress.get();\nif (!recursionProtectionSet.add(classType)) {\nreturn new CompositeValue(null, ICPPEvaluation.EMPTY_ARRAY);\n}\ntry {\nif (sDEBUG && nestingLevel > 0) {\nSystem.out.println(\"CompositeValue.create(\" + ASTTypeUtil.getType(classType) + \", \" + nestingLevel + \")\"); \/\/$NON-NLS-1$\/\/$NON-NLS-2$ \/\/$NON-NLS-3$\nSystem.out.flush();\n}\nActivationRecord record = new ActivationRecord();\nICPPEvaluation[] values = new ICPPEvaluation[ClassTypeHelper.getFields(classType, point).length];\n\/\/ Recursively create all the base class member variables.\nICPPBase[] bases = ClassTypeHelper.getBases(classType, point);\nfor (ICPPBase base : bases) {\nIBinding baseClass = base.getBaseClass();\nif (baseClass instanceof ICPPClassType) {\nICPPClassType baseClassType = (ICPPClassType) baseClass;\nICPPField[] baseFields = ClassTypeHelper.getDeclaredFields(baseClassType, point);\nIValue compValue = CompositeValue.create(baseClassType, point, nestingLevel + 1);\nfor (ICPPField baseField : baseFields) {\nint fieldPos = CPPASTFieldReference.getFieldPosition(baseField);\nif (fieldPos == -1) {\ncontinue;\n}\nrecord.update(baseField, compValue.getSubValue(fieldPos));\n\/\/ TODO(nathanridge): This won't work with multiple inheritance, since 'fieldPos'\n\/\/ is a field position in the base class' hierarchy, while values[] expects\n\/\/ as index a field position in classType's hierarchy.\nvalues[fieldPos] = compValue.getSubValue(fieldPos);\n}\n}\n}\nICPPField[] fields = ClassTypeHelper.getDeclaredFields(classType, point);\nfor (ICPPField field : fields) {\nif (field.isStatic())\ncontinue;\nfinal ICPPEvaluation value = EvalUtil.getVariableValue(field, record, point);\nint fieldPos = CPPASTFieldReference.getFieldPosition(field);\nif (fieldPos == -1) {\ncontinue;\n}\nrecord.update(field, value);\nvalues[fieldPos] = value;\n}\nreturn new CompositeValue(null, values);\n} finally {\nrecursionProtectionSet.remove(classType);\n}\n}\n\npublic static CompositeValue create(ICPPClassType classType, IASTNode point, int nestingLevel) {\nSet<ICPPClassType> recursionProtectionSet = fCreateInProgress.get();\nif (!recursionProtectionSet.add(classType)) {\nreturn new CompositeValue(null, ICPPEvaluation.EMPTY_ARRAY);\n}\ntry {\nif (sDEBUG && nestingLevel > 0) {\nSystem.out.println(\"CompositeValue.create(\" + ASTTypeUtil.getType(classType) + \", \" + nestingLevel + \")\"); \/\/$NON-NLS-1$\/\/$NON-NLS-2$ \/\/$NON-NLS-3$\nSystem.out.flush();\n}\nActivationRecord record = new ActivationRecord();\nICPPEvaluation[] values = new ICPPEvaluation[ClassTypeHelper.getFields(classType, point).length];\n\/\/ Recursively create all the base class member variables.\nICPPBase[] bases = ClassTypeHelper.getBases(classType, point);\nfor (ICPPBase base : bases) {\nIBinding baseClass = base.getBaseClass();\nif (baseClass instanceof ICPPClassType) {\nICPPClassType baseClassType = (ICPPClassType) baseClass;\nICPPField[] baseFields = ClassTypeHelper.getDeclaredFields(baseClassType, point);\nIValue compValue = CompositeValue.create(baseClassType, point, nestingLevel + 1);\nfor (ICPPField baseField : baseFields) {\nint fieldPos = CPPASTFieldReference.getFieldPosition(baseField);\nif (fieldPos == -1) {\ncontinue;\n}\nrecord.update(baseField, compValue.getSubValue(fieldPos));\n\/\/ TODO(nathanridge): This won't work with multiple inheritance, since 'fieldPos'\n\/\/ is a field position in the base class' hierarchy, while values[] expects\n\npublic static CompositeValue create(ICPPClassType classType, IASTNode point, int nestingLevel) {\nSet<ICPPClassType> recursionProtectionSet = fCreateInProgress.get();\nif (!recursionProtectionSet.add(classType)) {\nreturn new CompositeValue(null, ICPPEvaluation.EMPTY_ARRAY);\n}\ntry {\nif (sDEBUG && nestingLevel > 0) {\nSystem.out.println(\"CompositeValue.create(\" + ASTTypeUtil.getType(classType) + \", \" + nestingLevel + \")\"); \/\/$NON-NLS-1$\/\/$NON-NLS-2$ \/\/$NON-NLS-3$\nSystem.out.flush();\n}\nActivationRecord record = new ActivationRecord();\nICPPEvaluation[] values = new ICPPEvaluation[ClassTypeHelper.getFields(classType, point).length];\n\/\/ Recursively create all the base class member variables.\nICPPBase[] bases = ClassTypeHelper.getBases(classType, point);\nfor (ICPPBase base : bases) {\nIBinding baseClass = base.getBaseClass();\nif (baseClass instanceof ICPPClassType) {\nICPPClassType baseClassType = (ICPPClassType) baseClass;\nICPPField[] baseFields = ClassTypeHelper.getDeclaredFields(baseClassType, point);\nIValue compValue = CompositeValue.create(baseClassType, point, nestingLevel + 1);\nfor (ICPPField baseField : baseFields) {\nint fieldPos = CPPASTFieldReference.getFieldPosition(baseField);\nif (fieldPos == -1) {\ncontinue;\n}\nrecord.update(baseField, compValue.getSubValue(fieldPos));\n\/\/ TODO(nathanridge): This won't work with multiple inheritance, since 'fieldPos'\n\/\/ is a field position in the base class' hierarchy, while values[] expects\n\/\/ as index a field position in classType's hierarchy.\nvalues[fieldPos] = compValue.getSubValue(fieldPos);\n}\n}\n}\n\nif (sDEBUG && nestingLevel > 0) {\nSystem.out.println(\"CompositeValue.create(\" + ASTTypeUtil.getType(classType) + \", \" + nestingLevel + \")\"); \/\/$NON-NLS-1$\/\/$NON-NLS-2$ \/\/$NON-NLS-3$\nSystem.out.flush();\n}\nActivationRecord record = new ActivationRecord();\nICPPEvaluation[] values = new ICPPEvaluation[ClassTypeHelper.getFields(classType, point).length];\n\/\/ Recursively create all the base class member variables.\nICPPBase[] bases = ClassTypeHelper.getBases(classType, point);\nfor (ICPPBase base : bases) {\nIBinding baseClass = base.getBaseClass();\nif (baseClass instanceof ICPPClassType) {\nICPPClassType baseClassType = (ICPPClassType) baseClass;\nICPPField[] baseFields = ClassTypeHelper.getDeclaredFields(baseClassType, point);\nIValue compValue = CompositeValue.create(baseClassType, point, nestingLevel + 1);\nfor (ICPPField baseField : baseFields) {\nint fieldPos = CPPASTFieldReference.getFieldPosition(baseField);\nif (fieldPos == -1) {\ncontinue;\n}\nrecord.update(baseField, compValue.getSubValue(fieldPos));\n\/\/ TODO(nathanridge): This won't work with multiple inheritance, since 'fieldPos'\n\/\/ is a field position in the base class' hierarchy, while values[] expects\n\/\/ as index a field position in classType's hierarchy.\nvalues[fieldPos] = compValue.getSubValue(fieldPos);\n}\n}\n}\nICPPField[] fields = ClassTypeHelper.getDeclaredFields(classType, point);\nfor (ICPPField field : fields) {\nif (field.isStatic())\ncontinue;\nfinal ICPPEvaluation value = EvalUtil.getVariableValue(field, record, point);\nint fieldPos = CPPASTFieldReference.getFieldPosition(field);\nif (fieldPos == -1) {\ncontinue;\n}\nrecord.update(field, value);\nvalues[fieldPos] = value;\n}\nreturn new CompositeValue(null, values);\n} finally {\nrecursionProtectionSet.remove(classType);\n}","label":[0,0,1,0]}
{"id":22978,"original_code":"private void checkPins(List<X509Certificate> chain) throws CertificateException {\n        PinSet pinSet = mNetworkSecurityConfig.getPins();\n        if (pinSet.pins.isEmpty()\n                || System.currentTimeMillis() > pinSet.expirationTime\n                || !isPinningEnforced(chain)) {\n            return;\n        }\n        Set<String> pinAlgorithms = pinSet.getPinAlgorithms();\n        Map<String, MessageDigest> digestMap = new ArrayMap<String, MessageDigest>(\n                pinAlgorithms.size());\n        for (int i = chain.size() - 1; i >= 0 ; i--) {\n            X509Certificate cert = chain.get(i);\n            byte[] encodedSPKI = cert.getPublicKey().getEncoded();\n            for (String algorithm : pinAlgorithms) {\n                MessageDigest md = digestMap.get(algorithm);\n                if (md == null) {\n                    try {\n                        md = MessageDigest.getInstance(algorithm);\n                    } catch (GeneralSecurityException e) {\n                        throw new RuntimeException(e);\n                    }\n                    digestMap.put(algorithm, md);\n                }\n                if (pinSet.pins.contains(new Pin(algorithm, md.digest(encodedSPKI)))) {\n                    return;\n                }\n            }\n        }\n        \/\/ TODO: Throw a subclass of CertificateException which indicates a pinning failure.\n        throw new CertificateException(\"Pin verification failed\");\n    }","code":"private void checkPins(List<X509Certificate> chain) throws CertificateException {\n        PinSet pinSet = mNetworkSecurityConfig.getPins();\n        if (pinSet.pins.isEmpty()\n                || System.currentTimeMillis() > pinSet.expirationTime\n                || !isPinningEnforced(chain)) {\n            return;\n        }\n        Set<String> pinAlgorithms = pinSet.getPinAlgorithms();\n        Map<String, MessageDigest> digestMap = new ArrayMap<String, MessageDigest>(\n                pinAlgorithms.size());\n        for (int i = chain.size() - 1; i >= 0 ; i--) {\n            X509Certificate cert = chain.get(i);\n            byte[] encodedSPKI = cert.getPublicKey().getEncoded();\n            for (String algorithm : pinAlgorithms) {\n                MessageDigest md = digestMap.get(algorithm);\n                if (md == null) {\n                    try {\n                        md = MessageDigest.getInstance(algorithm);\n                    } catch (GeneralSecurityException e) {\n                        throw new RuntimeException(e);\n                    }\n                    digestMap.put(algorithm, md);\n                }\n                if (pinSet.pins.contains(new Pin(algorithm, md.digest(encodedSPKI)))) {\n                    return;\n                }\n            }\n        }\n       \n        throw new CertificateException(\"Pin verification failed\");\n    }","cleancode":"private void checkpins(list<x509certificate> chain) throws certificateexception { pinset pinset = mnetworksecurityconfig.getpins(); if (pinset.pins.isempty() || system.currenttimemillis() > pinset.expirationtime || !ispinningenforced(chain)) { return; } set<string> pinalgorithms = pinset.getpinalgorithms(); map<string, messagedigest> digestmap = new arraymap<string, messagedigest>( pinalgorithms.size()); for (int i = chain.size() - 1; i >= 0 ; i--) { x509certificate cert = chain.get(i); byte[] encodedspki = cert.getpublickey().getencoded(); for (string algorithm : pinalgorithms) { messagedigest md = digestmap.get(algorithm); if (md == null) { try { md = messagedigest.getinstance(algorithm); } catch (generalsecurityexception e) { throw new runtimeexception(e); } digestmap.put(algorithm, md); } if (pinset.pins.contains(new pin(algorithm, md.digest(encodedspki)))) { return; } } } throw new certificateexception(\"pin verification failed\"); }","comment":"\/\/ todo: throw a subclass of certificateexception which indicates a pinning failure.","repo":"rio-31\/android_frameworks_base-1","code_context_2":"}\n}\n\/\/ TODO: Throw a subclass of CertificateException which indicates a pinning failure.\nthrow new CertificateException(\"Pin verification failed\");\n}","code_context_10":"} catch (GeneralSecurityException e) {\nthrow new RuntimeException(e);\n}\ndigestMap.put(algorithm, md);\n}\nif (pinSet.pins.contains(new Pin(algorithm, md.digest(encodedSPKI)))) {\nreturn;\n}\n}\n}\n\/\/ TODO: Throw a subclass of CertificateException which indicates a pinning failure.\nthrow new CertificateException(\"Pin verification failed\");\n}","code_context_20":"Map<String, MessageDigest> digestMap = new ArrayMap<String, MessageDigest>(\npinAlgorithms.size());\nfor (int i = chain.size() - 1; i >= 0 ; i--) {\nX509Certificate cert = chain.get(i);\nbyte[] encodedSPKI = cert.getPublicKey().getEncoded();\nfor (String algorithm : pinAlgorithms) {\nMessageDigest md = digestMap.get(algorithm);\nif (md == null) {\ntry {\nmd = MessageDigest.getInstance(algorithm);\n} catch (GeneralSecurityException e) {\nthrow new RuntimeException(e);\n}\ndigestMap.put(algorithm, md);\n}\nif (pinSet.pins.contains(new Pin(algorithm, md.digest(encodedSPKI)))) {\nreturn;\n}\n}\n}\n\/\/ TODO: Throw a subclass of CertificateException which indicates a pinning failure.\nthrow new CertificateException(\"Pin verification failed\");\n}","label":[0,1,0,0]}
{"id":23034,"original_code":"private static boolean isOnline(){\n\t\ttry{\n\t\t\tnew URL(\"http:\/\/74.125.230.174\").openConnection().connect(); \/\/Confused? Copy the URL and paste it in your browser.\n\t\t\treturn true;\n\t\t}catch (IOException e) {\n\t\t\treturn false;\n\t\t}\n\t}","code":"private static boolean isOnline(){\n\t\ttry{\n\t\t\tnew URL(\"http:\/\/74.125.230.174\").openConnection().connect();\n\t\t\treturn true;\n\t\t}catch (IOException e) {\n\t\t\treturn false;\n\t\t}\n\t}","cleancode":"private static boolean isonline(){ try{ new url(\"http:\/\/74.125.230.174\").openconnection().connect(); return true; }catch (ioexception e) { return false; } }","comment":"\/\/confused? copy the url and paste it in your browser.","repo":"scottkillen-vault\/Bunyan","code_context_2":"private static boolean isOnline(){\ntry{\nnew URL(\"http:\/\/74.125.230.174\").openConnection().connect(); \/\/Confused? Copy the URL and paste it in your browser.\nreturn true;\n}catch (IOException e) {","code_context_10":"private static boolean isOnline(){\ntry{\nnew URL(\"http:\/\/74.125.230.174\").openConnection().connect(); \/\/Confused? Copy the URL and paste it in your browser.\nreturn true;\n}catch (IOException e) {\nreturn false;\n}\n}","code_context_20":"private static boolean isOnline(){\ntry{\nnew URL(\"http:\/\/74.125.230.174\").openConnection().connect(); \/\/Confused? Copy the URL and paste it in your browser.\nreturn true;\n}catch (IOException e) {\nreturn false;\n}\n}","label":[1,0,0,0]}
{"id":31253,"original_code":"private void verifyAllComponents()\n    {\n        \/\/ check root component has no generics\n        if (!this.components.get(this.topname).getGenerics().isEmpty())\n            genericError(String.format(\"top component %s cannot contain generics\", this.topname));\n        \/\/ verify all components\n        for (Component component : this.components.values())\n        {\n            this.currentComponent = component.name;\n            this.verifyPortArch(component.ast);\n            this.verifyIdentifiers(component.ast);\n            this.verifyConstantExpressions(component.ast);\n            this.verifyTypes(component.ast);\n        }\n    }","code":"private void verifyAllComponents()\n    {\n       \n        if (!this.components.get(this.topname).getGenerics().isEmpty())\n            genericError(String.format(\"top component %s cannot contain generics\", this.topname));\n       \n        for (Component component : this.components.values())\n        {\n            this.currentComponent = component.name;\n            this.verifyPortArch(component.ast);\n            this.verifyIdentifiers(component.ast);\n            this.verifyConstantExpressions(component.ast);\n            this.verifyTypes(component.ast);\n        }\n    }","cleancode":"private void verifyallcomponents() { if (!this.components.get(this.topname).getgenerics().isempty()) genericerror(string.format(\"top component %s cannot contain generics\", this.topname)); for (component component : this.components.values()) { this.currentcomponent = component.name; this.verifyportarch(component.ast); this.verifyidentifiers(component.ast); this.verifyconstantexpressions(component.ast); this.verifytypes(component.ast); } }","comment":"\/** * verifies semantics of all component definitions: * + check root component has no generics * + check all identifiers used are declared * + check all expressions in declarations use generics or constants * + check types for all expressions are valid * future: * + check width for all expressions - recurse through all instances (would need to do fancy stuff to check using only component definition) *\/\n\/\/ check root component has no generics\n\/\/ verify all components","repo":"reed-foster\/cdl","code_context_2":"private void verifyAllComponents()\n{\n\/\/ check root component has no generics\nif (!this.components.get(this.topname).getGenerics().isEmpty())\ngenericError(String.format(\"top component %s cannot contain generics\", this.topname));\n\/\/ verify all components\nfor (Component component : this.components.values())\n{\nthis.currentComponent = component.name;\nthis.verifyPortArch(component.ast);\nthis.verifyIdentifiers(component.ast);\nthis.verifyConstantExpressions(component.ast);\nthis.verifyTypes(component.ast);\n}\n}\n\nprivate void verifyAllComponents()\n{\n\/\/ check root component has no generics\nif (!this.components.get(this.topname).getGenerics().isEmpty())\ngenericError(String.format(\"top component %s cannot contain generics\", this.topname));\n\nif (!this.components.get(this.topname).getGenerics().isEmpty())\ngenericError(String.format(\"top component %s cannot contain generics\", this.topname));\n\/\/ verify all components\nfor (Component component : this.components.values())\n{","code_context_10":"private void verifyAllComponents()\n{\n\/\/ check root component has no generics\nif (!this.components.get(this.topname).getGenerics().isEmpty())\ngenericError(String.format(\"top component %s cannot contain generics\", this.topname));\n\/\/ verify all components\nfor (Component component : this.components.values())\n{\nthis.currentComponent = component.name;\nthis.verifyPortArch(component.ast);\nthis.verifyIdentifiers(component.ast);\nthis.verifyConstantExpressions(component.ast);\nthis.verifyTypes(component.ast);\n}\n}\n\nprivate void verifyAllComponents()\n{\n\/\/ check root component has no generics\nif (!this.components.get(this.topname).getGenerics().isEmpty())\ngenericError(String.format(\"top component %s cannot contain generics\", this.topname));\n\/\/ verify all components\nfor (Component component : this.components.values())\n{\nthis.currentComponent = component.name;\nthis.verifyPortArch(component.ast);\nthis.verifyIdentifiers(component.ast);\nthis.verifyConstantExpressions(component.ast);\nthis.verifyTypes(component.ast);\n\nprivate void verifyAllComponents()\n{\n\/\/ check root component has no generics\nif (!this.components.get(this.topname).getGenerics().isEmpty())\ngenericError(String.format(\"top component %s cannot contain generics\", this.topname));\n\/\/ verify all components\nfor (Component component : this.components.values())\n{\nthis.currentComponent = component.name;\nthis.verifyPortArch(component.ast);\nthis.verifyIdentifiers(component.ast);\nthis.verifyConstantExpressions(component.ast);\nthis.verifyTypes(component.ast);\n}\n}","code_context_20":"private void verifyAllComponents()\n{\n\/\/ check root component has no generics\nif (!this.components.get(this.topname).getGenerics().isEmpty())\ngenericError(String.format(\"top component %s cannot contain generics\", this.topname));\n\/\/ verify all components\nfor (Component component : this.components.values())\n{\nthis.currentComponent = component.name;\nthis.verifyPortArch(component.ast);\nthis.verifyIdentifiers(component.ast);\nthis.verifyConstantExpressions(component.ast);\nthis.verifyTypes(component.ast);\n}\n}\n\nprivate void verifyAllComponents()\n{\n\/\/ check root component has no generics\nif (!this.components.get(this.topname).getGenerics().isEmpty())\ngenericError(String.format(\"top component %s cannot contain generics\", this.topname));\n\/\/ verify all components\nfor (Component component : this.components.values())\n{\nthis.currentComponent = component.name;\nthis.verifyPortArch(component.ast);\nthis.verifyIdentifiers(component.ast);\nthis.verifyConstantExpressions(component.ast);\nthis.verifyTypes(component.ast);\n}\n}\n\nprivate void verifyAllComponents()\n{\n\/\/ check root component has no generics\nif (!this.components.get(this.topname).getGenerics().isEmpty())\ngenericError(String.format(\"top component %s cannot contain generics\", this.topname));\n\/\/ verify all components\nfor (Component component : this.components.values())\n{\nthis.currentComponent = component.name;\nthis.verifyPortArch(component.ast);\nthis.verifyIdentifiers(component.ast);\nthis.verifyConstantExpressions(component.ast);\nthis.verifyTypes(component.ast);\n}\n}","label":[0,1,0,0]}
{"id":23074,"original_code":"public void testJ5_32_speculative() throws Exception {\n\t\tCppCompositeType J5_struct = createJ5_struct32(vbtManager32);\n\t\tJ5_struct.createLayout(classLayoutChoice, vbtManager32, TaskMonitor.DUMMY);\n\t\tComposite composite = J5_struct.getComposite();\n\t\tCompositeTestUtils.assertExpectedComposite(this, getSpeculatedJ5_32(), composite, true);\n\t}","code":"public void testJ5_32_speculative() throws Exception {\n\t\tCppCompositeType J5_struct = createJ5_struct32(vbtManager32);\n\t\tJ5_struct.createLayout(classLayoutChoice, vbtManager32, TaskMonitor.DUMMY);\n\t\tComposite composite = J5_struct.getComposite();\n\t\tCompositeTestUtils.assertExpectedComposite(this, getSpeculatedJ5_32(), composite, true);\n\t}","cleancode":"public void testj5_32_speculative() throws exception { cppcompositetype j5_struct = createj5_struct32(vbtmanager32); j5_struct.createlayout(classlayoutchoice, vbtmanager32, taskmonitor.dummy); composite composite = j5_struct.getcomposite(); compositetestutils.assertexpectedcomposite(this, getspeculatedj5_32(), composite, true); }","comment":"\/\/ todo: need to work on layout algorithm... believe we can do better, but don't have \/\/ a decision on the best speculative results yet. \/\/ @test","repo":"sigurasg\/ghidra","code_context_2":"public void testJ5_32_speculative() throws Exception {\nCppCompositeType J5_struct = createJ5_struct32(vbtManager32);\nJ5_struct.createLayout(classLayoutChoice, vbtManager32, TaskMonitor.DUMMY);\nComposite composite = J5_struct.getComposite();\nCompositeTestUtils.assertExpectedComposite(this, getSpeculatedJ5_32(), composite, true);\n}","code_context_10":"public void testJ5_32_speculative() throws Exception {\nCppCompositeType J5_struct = createJ5_struct32(vbtManager32);\nJ5_struct.createLayout(classLayoutChoice, vbtManager32, TaskMonitor.DUMMY);\nComposite composite = J5_struct.getComposite();\nCompositeTestUtils.assertExpectedComposite(this, getSpeculatedJ5_32(), composite, true);\n}","code_context_20":"public void testJ5_32_speculative() throws Exception {\nCppCompositeType J5_struct = createJ5_struct32(vbtManager32);\nJ5_struct.createLayout(classLayoutChoice, vbtManager32, TaskMonitor.DUMMY);\nComposite composite = J5_struct.getComposite();\nCompositeTestUtils.assertExpectedComposite(this, getSpeculatedJ5_32(), composite, true);\n}","label":[1,0,0,0]}
{"id":23075,"original_code":"public void testJ5_64_speculative() throws Exception {\n\t\tCppCompositeType J5_struct = createJ5_struct64(vbtManager64);\n\t\tJ5_struct.createLayout(classLayoutChoice, vbtManager64, TaskMonitor.DUMMY);\n\t\tComposite composite = J5_struct.getComposite();\n\t\tCompositeTestUtils.assertExpectedComposite(this, getSpeculatedJ5_64(), composite, true);\n\t}","code":"public void testJ5_64_speculative() throws Exception {\n\t\tCppCompositeType J5_struct = createJ5_struct64(vbtManager64);\n\t\tJ5_struct.createLayout(classLayoutChoice, vbtManager64, TaskMonitor.DUMMY);\n\t\tComposite composite = J5_struct.getComposite();\n\t\tCompositeTestUtils.assertExpectedComposite(this, getSpeculatedJ5_64(), composite, true);\n\t}","cleancode":"public void testj5_64_speculative() throws exception { cppcompositetype j5_struct = createj5_struct64(vbtmanager64); j5_struct.createlayout(classlayoutchoice, vbtmanager64, taskmonitor.dummy); composite composite = j5_struct.getcomposite(); compositetestutils.assertexpectedcomposite(this, getspeculatedj5_64(), composite, true); }","comment":"\/\/ todo: need to work on layout algorithm... believe we can do better, but don't have \/\/ a decision on the best speculative results yet. \/\/ @test","repo":"sigurasg\/ghidra","code_context_2":"public void testJ5_64_speculative() throws Exception {\nCppCompositeType J5_struct = createJ5_struct64(vbtManager64);\nJ5_struct.createLayout(classLayoutChoice, vbtManager64, TaskMonitor.DUMMY);\nComposite composite = J5_struct.getComposite();\nCompositeTestUtils.assertExpectedComposite(this, getSpeculatedJ5_64(), composite, true);\n}","code_context_10":"public void testJ5_64_speculative() throws Exception {\nCppCompositeType J5_struct = createJ5_struct64(vbtManager64);\nJ5_struct.createLayout(classLayoutChoice, vbtManager64, TaskMonitor.DUMMY);\nComposite composite = J5_struct.getComposite();\nCompositeTestUtils.assertExpectedComposite(this, getSpeculatedJ5_64(), composite, true);\n}","code_context_20":"public void testJ5_64_speculative() throws Exception {\nCppCompositeType J5_struct = createJ5_struct64(vbtManager64);\nJ5_struct.createLayout(classLayoutChoice, vbtManager64, TaskMonitor.DUMMY);\nComposite composite = J5_struct.getComposite();\nCompositeTestUtils.assertExpectedComposite(this, getSpeculatedJ5_64(), composite, true);\n}","label":[1,0,0,0]}
{"id":23076,"original_code":"public void testJ6_32_speculative() throws Exception {\n\t\tCppCompositeType J6_struct = createJ6_struct32(vbtManager32);\n\t\tJ6_struct.createLayout(classLayoutChoice, vbtManager32, TaskMonitor.DUMMY);\n\t\tComposite composite = J6_struct.getComposite();\n\t\tCompositeTestUtils.assertExpectedComposite(this, getSpeculatedJ6_32(), composite, true);\n\t}","code":"public void testJ6_32_speculative() throws Exception {\n\t\tCppCompositeType J6_struct = createJ6_struct32(vbtManager32);\n\t\tJ6_struct.createLayout(classLayoutChoice, vbtManager32, TaskMonitor.DUMMY);\n\t\tComposite composite = J6_struct.getComposite();\n\t\tCompositeTestUtils.assertExpectedComposite(this, getSpeculatedJ6_32(), composite, true);\n\t}","cleancode":"public void testj6_32_speculative() throws exception { cppcompositetype j6_struct = createj6_struct32(vbtmanager32); j6_struct.createlayout(classlayoutchoice, vbtmanager32, taskmonitor.dummy); composite composite = j6_struct.getcomposite(); compositetestutils.assertexpectedcomposite(this, getspeculatedj6_32(), composite, true); }","comment":"\/\/ todo: need to work on layout algorithm... believe we can do better, but don't have \/\/ a decision on the best speculative results yet. \/\/ @test","repo":"sigurasg\/ghidra","code_context_2":"public void testJ6_32_speculative() throws Exception {\nCppCompositeType J6_struct = createJ6_struct32(vbtManager32);\nJ6_struct.createLayout(classLayoutChoice, vbtManager32, TaskMonitor.DUMMY);\nComposite composite = J6_struct.getComposite();\nCompositeTestUtils.assertExpectedComposite(this, getSpeculatedJ6_32(), composite, true);\n}","code_context_10":"public void testJ6_32_speculative() throws Exception {\nCppCompositeType J6_struct = createJ6_struct32(vbtManager32);\nJ6_struct.createLayout(classLayoutChoice, vbtManager32, TaskMonitor.DUMMY);\nComposite composite = J6_struct.getComposite();\nCompositeTestUtils.assertExpectedComposite(this, getSpeculatedJ6_32(), composite, true);\n}","code_context_20":"public void testJ6_32_speculative() throws Exception {\nCppCompositeType J6_struct = createJ6_struct32(vbtManager32);\nJ6_struct.createLayout(classLayoutChoice, vbtManager32, TaskMonitor.DUMMY);\nComposite composite = J6_struct.getComposite();\nCompositeTestUtils.assertExpectedComposite(this, getSpeculatedJ6_32(), composite, true);\n}","label":[1,0,0,0]}
{"id":23077,"original_code":"public void testJ6_64_speculative() throws Exception {\n\t\tCppCompositeType J6_struct = createJ6_struct64(vbtManager64);\n\t\tJ6_struct.createLayout(classLayoutChoice, vbtManager64, TaskMonitor.DUMMY);\n\t\tComposite composite = J6_struct.getComposite();\n\t\tCompositeTestUtils.assertExpectedComposite(this, getSpeculatedJ6_64(), composite, true);\n\t}","code":"public void testJ6_64_speculative() throws Exception {\n\t\tCppCompositeType J6_struct = createJ6_struct64(vbtManager64);\n\t\tJ6_struct.createLayout(classLayoutChoice, vbtManager64, TaskMonitor.DUMMY);\n\t\tComposite composite = J6_struct.getComposite();\n\t\tCompositeTestUtils.assertExpectedComposite(this, getSpeculatedJ6_64(), composite, true);\n\t}","cleancode":"public void testj6_64_speculative() throws exception { cppcompositetype j6_struct = createj6_struct64(vbtmanager64); j6_struct.createlayout(classlayoutchoice, vbtmanager64, taskmonitor.dummy); composite composite = j6_struct.getcomposite(); compositetestutils.assertexpectedcomposite(this, getspeculatedj6_64(), composite, true); }","comment":"\/\/ todo: need to work on layout algorithm... believe we can do better, but don't have \/\/ a decision on the best speculative results yet. \/\/ @test","repo":"sigurasg\/ghidra","code_context_2":"public void testJ6_64_speculative() throws Exception {\nCppCompositeType J6_struct = createJ6_struct64(vbtManager64);\nJ6_struct.createLayout(classLayoutChoice, vbtManager64, TaskMonitor.DUMMY);\nComposite composite = J6_struct.getComposite();\nCompositeTestUtils.assertExpectedComposite(this, getSpeculatedJ6_64(), composite, true);\n}","code_context_10":"public void testJ6_64_speculative() throws Exception {\nCppCompositeType J6_struct = createJ6_struct64(vbtManager64);\nJ6_struct.createLayout(classLayoutChoice, vbtManager64, TaskMonitor.DUMMY);\nComposite composite = J6_struct.getComposite();\nCompositeTestUtils.assertExpectedComposite(this, getSpeculatedJ6_64(), composite, true);\n}","code_context_20":"public void testJ6_64_speculative() throws Exception {\nCppCompositeType J6_struct = createJ6_struct64(vbtManager64);\nJ6_struct.createLayout(classLayoutChoice, vbtManager64, TaskMonitor.DUMMY);\nComposite composite = J6_struct.getComposite();\nCompositeTestUtils.assertExpectedComposite(this, getSpeculatedJ6_64(), composite, true);\n}","label":[1,0,0,0]}
{"id":31319,"original_code":"public List<HeatConsumption> findHeatConsumptions() throws IOException {\n        \/\/ TODO convert into model that contains electricity info also\n        return heatRepository.findAll();\n    }","code":"public List<HeatConsumption> findHeatConsumptions() throws IOException {\n       \n        return heatRepository.findAll();\n    }","cleancode":"public list<heatconsumption> findheatconsumptions() throws ioexception { return heatrepository.findall(); }","comment":"\/\/ todo convert into model that contains electricity info also","repo":"renanpelicari\/java-kata","code_context_2":"public List<HeatConsumption> findHeatConsumptions() throws IOException {\n\/\/ TODO convert into model that contains electricity info also\nreturn heatRepository.findAll();\n}","code_context_10":"public List<HeatConsumption> findHeatConsumptions() throws IOException {\n\/\/ TODO convert into model that contains electricity info also\nreturn heatRepository.findAll();\n}","code_context_20":"public List<HeatConsumption> findHeatConsumptions() throws IOException {\n\/\/ TODO convert into model that contains electricity info also\nreturn heatRepository.findAll();\n}","label":[0,1,0,0]}
{"id":31329,"original_code":"public static Document parse(String text, int windowSize, JSONArray spacyEntities, JSONArray dbpediaEntities) {\n\t\tDocument result = new Document();\n\t\tresult._originaltext = text;\n\t\tresult._sentences    = new java.util.ArrayList<Sentence>();\n\t\tList<String> splitSentences = StanfordNLP.splitSentences(text);\n\t\tint lastFoundPosition = -1;\n\t\tint lastSentenceLength = 1;\n\t\tint sentenceCount      = 0;\n\t\tint runningSentinmentScore = 0; \n\t\t\/\/ perform the window parsing - used to do coreref, plus get initial named entities, sentiment, and tokens\n\t\tfor (int sentenceIndex = 0; sentenceIndex < splitSentences.size(); sentenceIndex++) {\n\t\t\tSplitResult sr = getTextWindow(splitSentences, sentenceIndex,windowSize);\n\t\t\tAnnotation sentenceDoc = StanfordNLP.annotateText(sr.text);\n\t\t    List<CoreMap> sentences = sentenceDoc.get(CoreAnnotations.SentencesAnnotation.class);\n\t\t    CoreMap sentence = sentences.get(sr.sentencePositionToUse);\n\t    \tsentenceCount++;\n\t    \tString sentenceText = sentence.get(CoreAnnotations.TextAnnotation.class);\n\t    \tint documentPosition = text.indexOf(sentenceText,lastFoundPosition);\n\t    \tif (documentPosition == -1) { \n\t    \t\tdocumentPosition = lastFoundPosition + lastSentenceLength;\n\t    \t}\n\t    \tjava.util.List<Token> sentenceTokens = Token.extractTokens(sentence, sentenceCount);\n\t    \tSentence s = new Sentence(sentenceText, documentPosition, sentenceCount, sentenceTokens);\n\t    \tTree tree = sentence.get(SentimentCoreAnnotations.SentimentAnnotatedTree.class);\n            int sentiment = RNNCoreAnnotations.getPredictedClass(tree);\n            s.setSentiment(sentiment);\n            runningSentinmentScore += sentiment;\n            List<String> resolvedSentences = Coreference.resolveCoreferences(sentenceDoc);\n            s.setCorefText(resolvedSentences.get(sr.sentencePositionToUse));\n\t    \tresult._sentences.add(s);\n\t    \tlastFoundPosition = documentPosition;\n\t    \tlastSentenceLength = sentenceText.length();\n\t\t}\n\t\tresult._sentimentScore =  ((double) runningSentinmentScore) \/ sentenceCount;\n\t\t\/\/ reparse to get openIE \/ relations items\n\t\tint baseSentenceIndex = -1;\n\t\tfor (Sentence s: result._sentences) {\n\t\t\tAnnotation sentenceDoc = StanfordNLP.annotateText(s.getCorefText());\n\t\t\tbaseSentenceIndex++;\n\t\t\tjava.util.List<Token> sentenceTokens = Token.extractTokens(sentenceDoc.get(CoreAnnotations.SentencesAnnotation.class).get(0), baseSentenceIndex);\n\t\t\tjava.util.List<TripleRelation> triples = TripleRelation.extractTriples(sentenceDoc, baseSentenceIndex);\n\t\t\ttriples = TripleRelation.valiadateTriples(triples, sentenceTokens);\n\t\t\tList<AnnotatedProposition> minieTriplesAP =  StanfordNLP.extractMinIETriples(s.getCorefText());\n\t\t\tjava.util.List<TripleRelation> minetriples = TripleRelation.extractTriples(minieTriplesAP, baseSentenceIndex);\n\t\t\tminetriples = TripleRelation.valiadateTriples(minetriples, sentenceTokens);\n\t\t\tjava.util.List<TripleRelation> combinedTriples = TripleRelation.combine(triples, minetriples);\n\t\t\tcombinedTriples = TripleRelation.reduceTriples(combinedTriples, FilterStyle.FILTER_TO_MAXIMIZE_SUBJ_OBJ_MINIMIZE_RELATION);\n\t\t\t\/\/combinedTriples = TripleRelation.reduceTriples(combinedTriples, FilterStyle.FILTER_TO_MINIMIZE_TERMS);\n\t\t\tTripleRelation.augmentSubjectObjectWithStanfordNER(combinedTriples,s.getNamedEntities());\n\t\t\tTripleRelation.augmentSubjectObjectWithSpacyNER(combinedTriples, spacyEntities, s.getStartPosition(), s.getStartPosition() + s.getOriginalText().length());\n\t\t\tTripleRelation.augmentSubjectObjectWithDBPedia(combinedTriples, dbpediaEntities, s.getStartPosition(), s.getStartPosition() + s.getOriginalText().length());\n\t\t\ts.setTripleRelations(combinedTriples);\n\t\t}\n\t\treturn result;\n\t}","code":"public static Document parse(String text, int windowSize, JSONArray spacyEntities, JSONArray dbpediaEntities) {\n\t\tDocument result = new Document();\n\t\tresult._originaltext = text;\n\t\tresult._sentences    = new java.util.ArrayList<Sentence>();\n\t\tList<String> splitSentences = StanfordNLP.splitSentences(text);\n\t\tint lastFoundPosition = -1;\n\t\tint lastSentenceLength = 1;\n\t\tint sentenceCount      = 0;\n\t\tint runningSentinmentScore = 0; \n\t\n\t\tfor (int sentenceIndex = 0; sentenceIndex < splitSentences.size(); sentenceIndex++) {\n\t\t\tSplitResult sr = getTextWindow(splitSentences, sentenceIndex,windowSize);\n\t\t\tAnnotation sentenceDoc = StanfordNLP.annotateText(sr.text);\n\t\t    List<CoreMap> sentences = sentenceDoc.get(CoreAnnotations.SentencesAnnotation.class);\n\t\t    CoreMap sentence = sentences.get(sr.sentencePositionToUse);\n\t    \tsentenceCount++;\n\t    \tString sentenceText = sentence.get(CoreAnnotations.TextAnnotation.class);\n\t    \tint documentPosition = text.indexOf(sentenceText,lastFoundPosition);\n\t    \tif (documentPosition == -1) { \n\t    \t\tdocumentPosition = lastFoundPosition + lastSentenceLength;\n\t    \t}\n\t    \tjava.util.List<Token> sentenceTokens = Token.extractTokens(sentence, sentenceCount);\n\t    \tSentence s = new Sentence(sentenceText, documentPosition, sentenceCount, sentenceTokens);\n\t    \tTree tree = sentence.get(SentimentCoreAnnotations.SentimentAnnotatedTree.class);\n            int sentiment = RNNCoreAnnotations.getPredictedClass(tree);\n            s.setSentiment(sentiment);\n            runningSentinmentScore += sentiment;\n            List<String> resolvedSentences = Coreference.resolveCoreferences(sentenceDoc);\n            s.setCorefText(resolvedSentences.get(sr.sentencePositionToUse));\n\t    \tresult._sentences.add(s);\n\t    \tlastFoundPosition = documentPosition;\n\t    \tlastSentenceLength = sentenceText.length();\n\t\t}\n\t\tresult._sentimentScore =  ((double) runningSentinmentScore) \/ sentenceCount;\n\t\n\t\tint baseSentenceIndex = -1;\n\t\tfor (Sentence s: result._sentences) {\n\t\t\tAnnotation sentenceDoc = StanfordNLP.annotateText(s.getCorefText());\n\t\t\tbaseSentenceIndex++;\n\t\t\tjava.util.List<Token> sentenceTokens = Token.extractTokens(sentenceDoc.get(CoreAnnotations.SentencesAnnotation.class).get(0), baseSentenceIndex);\n\t\t\tjava.util.List<TripleRelation> triples = TripleRelation.extractTriples(sentenceDoc, baseSentenceIndex);\n\t\t\ttriples = TripleRelation.valiadateTriples(triples, sentenceTokens);\n\t\t\tList<AnnotatedProposition> minieTriplesAP =  StanfordNLP.extractMinIETriples(s.getCorefText());\n\t\t\tjava.util.List<TripleRelation> minetriples = TripleRelation.extractTriples(minieTriplesAP, baseSentenceIndex);\n\t\t\tminetriples = TripleRelation.valiadateTriples(minetriples, sentenceTokens);\n\t\t\tjava.util.List<TripleRelation> combinedTriples = TripleRelation.combine(triples, minetriples);\n\t\t\tcombinedTriples = TripleRelation.reduceTriples(combinedTriples, FilterStyle.FILTER_TO_MAXIMIZE_SUBJ_OBJ_MINIMIZE_RELATION);\n\t\t\n\t\t\tTripleRelation.augmentSubjectObjectWithStanfordNER(combinedTriples,s.getNamedEntities());\n\t\t\tTripleRelation.augmentSubjectObjectWithSpacyNER(combinedTriples, spacyEntities, s.getStartPosition(), s.getStartPosition() + s.getOriginalText().length());\n\t\t\tTripleRelation.augmentSubjectObjectWithDBPedia(combinedTriples, dbpediaEntities, s.getStartPosition(), s.getStartPosition() + s.getOriginalText().length());\n\t\t\ts.setTripleRelations(combinedTriples);\n\t\t}\n\t\treturn result;\n\t}","cleancode":"public static document parse(string text, int windowsize, jsonarray spacyentities, jsonarray dbpediaentities) { document result = new document(); result._originaltext = text; result._sentences = new java.util.arraylist<sentence>(); list<string> splitsentences = stanfordnlp.splitsentences(text); int lastfoundposition = -1; int lastsentencelength = 1; int sentencecount = 0; int runningsentinmentscore = 0; for (int sentenceindex = 0; sentenceindex < splitsentences.size(); sentenceindex++) { splitresult sr = gettextwindow(splitsentences, sentenceindex,windowsize); annotation sentencedoc = stanfordnlp.annotatetext(sr.text); list<coremap> sentences = sentencedoc.get(coreannotations.sentencesannotation.class); coremap sentence = sentences.get(sr.sentencepositiontouse); sentencecount++; string sentencetext = sentence.get(coreannotations.textannotation.class); int documentposition = text.indexof(sentencetext,lastfoundposition); if (documentposition == -1) { documentposition = lastfoundposition + lastsentencelength; } java.util.list<token> sentencetokens = token.extracttokens(sentence, sentencecount); sentence s = new sentence(sentencetext, documentposition, sentencecount, sentencetokens); tree tree = sentence.get(sentimentcoreannotations.sentimentannotatedtree.class); int sentiment = rnncoreannotations.getpredictedclass(tree); s.setsentiment(sentiment); runningsentinmentscore += sentiment; list<string> resolvedsentences = coreference.resolvecoreferences(sentencedoc); s.setcoreftext(resolvedsentences.get(sr.sentencepositiontouse)); result._sentences.add(s); lastfoundposition = documentposition; lastsentencelength = sentencetext.length(); } result._sentimentscore = ((double) runningsentinmentscore) \/ sentencecount; int basesentenceindex = -1; for (sentence s: result._sentences) { annotation sentencedoc = stanfordnlp.annotatetext(s.getcoreftext()); basesentenceindex++; java.util.list<token> sentencetokens = token.extracttokens(sentencedoc.get(coreannotations.sentencesannotation.class).get(0), basesentenceindex); java.util.list<triplerelation> triples = triplerelation.extracttriples(sentencedoc, basesentenceindex); triples = triplerelation.valiadatetriples(triples, sentencetokens); list<annotatedproposition> minietriplesap = stanfordnlp.extractminietriples(s.getcoreftext()); java.util.list<triplerelation> minetriples = triplerelation.extracttriples(minietriplesap, basesentenceindex); minetriples = triplerelation.valiadatetriples(minetriples, sentencetokens); java.util.list<triplerelation> combinedtriples = triplerelation.combine(triples, minetriples); combinedtriples = triplerelation.reducetriples(combinedtriples, filterstyle.filter_to_maximize_subj_obj_minimize_relation); triplerelation.augmentsubjectobjectwithstanfordner(combinedtriples,s.getnamedentities()); triplerelation.augmentsubjectobjectwithspacyner(combinedtriples, spacyentities, s.getstartposition(), s.getstartposition() + s.getoriginaltext().length()); triplerelation.augmentsubjectobjectwithdbpedia(combinedtriples, dbpediaentities, s.getstartposition(), s.getstartposition() + s.getoriginaltext().length()); s.settriplerelations(combinedtriples); } return result; }","comment":"\/** * create a document from the given text. * todo: explain the parsing process * * @param text * @param window * @return *\/\n\/\/ perform the window parsing - used to do coreref, plus get initial named entities, sentiment, and tokens\n\/\/ reparse to get openie \/ relations items\n\/\/combinedtriples = triplerelation.reducetriples(combinedtriples, filterstyle.filter_to_minimize_terms);","repo":"slankas\/OSKE","code_context_2":"public static Document parse(String text, int windowSize, JSONArray spacyEntities, JSONArray dbpediaEntities) {\nDocument result = new Document();\nresult._originaltext = text;\nresult._sentences = new java.util.ArrayList<Sentence>();\nList<String> splitSentences = StanfordNLP.splitSentences(text);\nint lastFoundPosition = -1;\nint lastSentenceLength = 1;\nint sentenceCount = 0;\nint runningSentinmentScore = 0;\n\/\/ perform the window parsing - used to do coreref, plus get initial named entities, sentiment, and tokens\nfor (int sentenceIndex = 0; sentenceIndex < splitSentences.size(); sentenceIndex++) {\nSplitResult sr = getTextWindow(splitSentences, sentenceIndex,windowSize);\nAnnotation sentenceDoc = StanfordNLP.annotateText(sr.text);\nList<CoreMap> sentences = sentenceDoc.get(CoreAnnotations.SentencesAnnotation.class);\nCoreMap sentence = sentences.get(sr.sentencePositionToUse);\nsentenceCount++;\nString sentenceText = sentence.get(CoreAnnotations.TextAnnotation.class);\nint documentPosition = text.indexOf(sentenceText,lastFoundPosition);\nif (documentPosition == -1) {\ndocumentPosition = lastFoundPosition + lastSentenceLength;\n}\njava.util.List<Token> sentenceTokens = Token.extractTokens(sentence, sentenceCount);\nSentence s = new Sentence(sentenceText, documentPosition, sentenceCount, sentenceTokens);\nTree tree = sentence.get(SentimentCoreAnnotations.SentimentAnnotatedTree.class);\nint sentiment = RNNCoreAnnotations.getPredictedClass(tree);\ns.setSentiment(sentiment);\nrunningSentinmentScore += sentiment;\nList<String> resolvedSentences = Coreference.resolveCoreferences(sentenceDoc);\ns.setCorefText(resolvedSentences.get(sr.sentencePositionToUse));\nresult._sentences.add(s);\nlastFoundPosition = documentPosition;\nlastSentenceLength = sentenceText.length();\n}\nresult._sentimentScore = ((double) runningSentinmentScore) \/ sentenceCount;\n\/\/ reparse to get openIE \/ relations items\nint baseSentenceIndex = -1;\nfor (Sentence s: result._sentences) {\nAnnotation sentenceDoc = StanfordNLP.annotateText(s.getCorefText());\nbaseSentenceIndex++;\njava.util.List<Token> sentenceTokens = Token.extractTokens(sentenceDoc.get(CoreAnnotations.SentencesAnnotation.class).get(0), baseSentenceIndex);\njava.util.List<TripleRelation> triples = TripleRelation.extractTriples(sentenceDoc, baseSentenceIndex);\ntriples = TripleRelation.valiadateTriples(triples, sentenceTokens);\nList<AnnotatedProposition> minieTriplesAP = StanfordNLP.extractMinIETriples(s.getCorefText());\njava.util.List<TripleRelation> minetriples = TripleRelation.extractTriples(minieTriplesAP, baseSentenceIndex);\nminetriples = TripleRelation.valiadateTriples(minetriples, sentenceTokens);\njava.util.List<TripleRelation> combinedTriples = TripleRelation.combine(triples, minetriples);\ncombinedTriples = TripleRelation.reduceTriples(combinedTriples, FilterStyle.FILTER_TO_MAXIMIZE_SUBJ_OBJ_MINIMIZE_RELATION);\n\/\/combinedTriples = TripleRelation.reduceTriples(combinedTriples, FilterStyle.FILTER_TO_MINIMIZE_TERMS);\nTripleRelation.augmentSubjectObjectWithStanfordNER(combinedTriples,s.getNamedEntities());\nTripleRelation.augmentSubjectObjectWithSpacyNER(combinedTriples, spacyEntities, s.getStartPosition(), s.getStartPosition() + s.getOriginalText().length());\nTripleRelation.augmentSubjectObjectWithDBPedia(combinedTriples, dbpediaEntities, s.getStartPosition(), s.getStartPosition() + s.getOriginalText().length());\ns.setTripleRelations(combinedTriples);\n}\nreturn result;\n}\n\nint sentenceCount = 0;\nint runningSentinmentScore = 0;\n\/\/ perform the window parsing - used to do coreref, plus get initial named entities, sentiment, and tokens\nfor (int sentenceIndex = 0; sentenceIndex < splitSentences.size(); sentenceIndex++) {\nSplitResult sr = getTextWindow(splitSentences, sentenceIndex,windowSize);\n\n}\nresult._sentimentScore = ((double) runningSentinmentScore) \/ sentenceCount;\n\/\/ reparse to get openIE \/ relations items\nint baseSentenceIndex = -1;\nfor (Sentence s: result._sentences) {\n\njava.util.List<TripleRelation> combinedTriples = TripleRelation.combine(triples, minetriples);\ncombinedTriples = TripleRelation.reduceTriples(combinedTriples, FilterStyle.FILTER_TO_MAXIMIZE_SUBJ_OBJ_MINIMIZE_RELATION);\n\/\/combinedTriples = TripleRelation.reduceTriples(combinedTriples, FilterStyle.FILTER_TO_MINIMIZE_TERMS);\nTripleRelation.augmentSubjectObjectWithStanfordNER(combinedTriples,s.getNamedEntities());\nTripleRelation.augmentSubjectObjectWithSpacyNER(combinedTriples, spacyEntities, s.getStartPosition(), s.getStartPosition() + s.getOriginalText().length());","code_context_10":"public static Document parse(String text, int windowSize, JSONArray spacyEntities, JSONArray dbpediaEntities) {\nDocument result = new Document();\nresult._originaltext = text;\nresult._sentences = new java.util.ArrayList<Sentence>();\nList<String> splitSentences = StanfordNLP.splitSentences(text);\nint lastFoundPosition = -1;\nint lastSentenceLength = 1;\nint sentenceCount = 0;\nint runningSentinmentScore = 0;\n\/\/ perform the window parsing - used to do coreref, plus get initial named entities, sentiment, and tokens\nfor (int sentenceIndex = 0; sentenceIndex < splitSentences.size(); sentenceIndex++) {\nSplitResult sr = getTextWindow(splitSentences, sentenceIndex,windowSize);\nAnnotation sentenceDoc = StanfordNLP.annotateText(sr.text);\nList<CoreMap> sentences = sentenceDoc.get(CoreAnnotations.SentencesAnnotation.class);\nCoreMap sentence = sentences.get(sr.sentencePositionToUse);\nsentenceCount++;\nString sentenceText = sentence.get(CoreAnnotations.TextAnnotation.class);\nint documentPosition = text.indexOf(sentenceText,lastFoundPosition);\nif (documentPosition == -1) {\ndocumentPosition = lastFoundPosition + lastSentenceLength;\n}\njava.util.List<Token> sentenceTokens = Token.extractTokens(sentence, sentenceCount);\nSentence s = new Sentence(sentenceText, documentPosition, sentenceCount, sentenceTokens);\nTree tree = sentence.get(SentimentCoreAnnotations.SentimentAnnotatedTree.class);\nint sentiment = RNNCoreAnnotations.getPredictedClass(tree);\ns.setSentiment(sentiment);\nrunningSentinmentScore += sentiment;\nList<String> resolvedSentences = Coreference.resolveCoreferences(sentenceDoc);\ns.setCorefText(resolvedSentences.get(sr.sentencePositionToUse));\nresult._sentences.add(s);\nlastFoundPosition = documentPosition;\nlastSentenceLength = sentenceText.length();\n}\nresult._sentimentScore = ((double) runningSentinmentScore) \/ sentenceCount;\n\/\/ reparse to get openIE \/ relations items\nint baseSentenceIndex = -1;\nfor (Sentence s: result._sentences) {\nAnnotation sentenceDoc = StanfordNLP.annotateText(s.getCorefText());\nbaseSentenceIndex++;\njava.util.List<Token> sentenceTokens = Token.extractTokens(sentenceDoc.get(CoreAnnotations.SentencesAnnotation.class).get(0), baseSentenceIndex);\njava.util.List<TripleRelation> triples = TripleRelation.extractTriples(sentenceDoc, baseSentenceIndex);\ntriples = TripleRelation.valiadateTriples(triples, sentenceTokens);\nList<AnnotatedProposition> minieTriplesAP = StanfordNLP.extractMinIETriples(s.getCorefText());\njava.util.List<TripleRelation> minetriples = TripleRelation.extractTriples(minieTriplesAP, baseSentenceIndex);\nminetriples = TripleRelation.valiadateTriples(minetriples, sentenceTokens);\njava.util.List<TripleRelation> combinedTriples = TripleRelation.combine(triples, minetriples);\ncombinedTriples = TripleRelation.reduceTriples(combinedTriples, FilterStyle.FILTER_TO_MAXIMIZE_SUBJ_OBJ_MINIMIZE_RELATION);\n\/\/combinedTriples = TripleRelation.reduceTriples(combinedTriples, FilterStyle.FILTER_TO_MINIMIZE_TERMS);\nTripleRelation.augmentSubjectObjectWithStanfordNER(combinedTriples,s.getNamedEntities());\nTripleRelation.augmentSubjectObjectWithSpacyNER(combinedTriples, spacyEntities, s.getStartPosition(), s.getStartPosition() + s.getOriginalText().length());\nTripleRelation.augmentSubjectObjectWithDBPedia(combinedTriples, dbpediaEntities, s.getStartPosition(), s.getStartPosition() + s.getOriginalText().length());\ns.setTripleRelations(combinedTriples);\n}\nreturn result;\n}\n\npublic static Document parse(String text, int windowSize, JSONArray spacyEntities, JSONArray dbpediaEntities) {\nDocument result = new Document();\nresult._originaltext = text;\nresult._sentences = new java.util.ArrayList<Sentence>();\nList<String> splitSentences = StanfordNLP.splitSentences(text);\nint lastFoundPosition = -1;\nint lastSentenceLength = 1;\nint sentenceCount = 0;\nint runningSentinmentScore = 0;\n\/\/ perform the window parsing - used to do coreref, plus get initial named entities, sentiment, and tokens\nfor (int sentenceIndex = 0; sentenceIndex < splitSentences.size(); sentenceIndex++) {\nSplitResult sr = getTextWindow(splitSentences, sentenceIndex,windowSize);\nAnnotation sentenceDoc = StanfordNLP.annotateText(sr.text);\nList<CoreMap> sentences = sentenceDoc.get(CoreAnnotations.SentencesAnnotation.class);\nCoreMap sentence = sentences.get(sr.sentencePositionToUse);\nsentenceCount++;\nString sentenceText = sentence.get(CoreAnnotations.TextAnnotation.class);\nint documentPosition = text.indexOf(sentenceText,lastFoundPosition);\nif (documentPosition == -1) {\ndocumentPosition = lastFoundPosition + lastSentenceLength;\n\nint sentiment = RNNCoreAnnotations.getPredictedClass(tree);\ns.setSentiment(sentiment);\nrunningSentinmentScore += sentiment;\nList<String> resolvedSentences = Coreference.resolveCoreferences(sentenceDoc);\ns.setCorefText(resolvedSentences.get(sr.sentencePositionToUse));\nresult._sentences.add(s);\nlastFoundPosition = documentPosition;\nlastSentenceLength = sentenceText.length();\n}\nresult._sentimentScore = ((double) runningSentinmentScore) \/ sentenceCount;\n\/\/ reparse to get openIE \/ relations items\nint baseSentenceIndex = -1;\nfor (Sentence s: result._sentences) {\nAnnotation sentenceDoc = StanfordNLP.annotateText(s.getCorefText());\nbaseSentenceIndex++;\njava.util.List<Token> sentenceTokens = Token.extractTokens(sentenceDoc.get(CoreAnnotations.SentencesAnnotation.class).get(0), baseSentenceIndex);\njava.util.List<TripleRelation> triples = TripleRelation.extractTriples(sentenceDoc, baseSentenceIndex);\ntriples = TripleRelation.valiadateTriples(triples, sentenceTokens);\nList<AnnotatedProposition> minieTriplesAP = StanfordNLP.extractMinIETriples(s.getCorefText());\njava.util.List<TripleRelation> minetriples = TripleRelation.extractTriples(minieTriplesAP, baseSentenceIndex);\nminetriples = TripleRelation.valiadateTriples(minetriples, sentenceTokens);\n\nAnnotation sentenceDoc = StanfordNLP.annotateText(s.getCorefText());\nbaseSentenceIndex++;\njava.util.List<Token> sentenceTokens = Token.extractTokens(sentenceDoc.get(CoreAnnotations.SentencesAnnotation.class).get(0), baseSentenceIndex);\njava.util.List<TripleRelation> triples = TripleRelation.extractTriples(sentenceDoc, baseSentenceIndex);\ntriples = TripleRelation.valiadateTriples(triples, sentenceTokens);\nList<AnnotatedProposition> minieTriplesAP = StanfordNLP.extractMinIETriples(s.getCorefText());\njava.util.List<TripleRelation> minetriples = TripleRelation.extractTriples(minieTriplesAP, baseSentenceIndex);\nminetriples = TripleRelation.valiadateTriples(minetriples, sentenceTokens);\njava.util.List<TripleRelation> combinedTriples = TripleRelation.combine(triples, minetriples);\ncombinedTriples = TripleRelation.reduceTriples(combinedTriples, FilterStyle.FILTER_TO_MAXIMIZE_SUBJ_OBJ_MINIMIZE_RELATION);\n\/\/combinedTriples = TripleRelation.reduceTriples(combinedTriples, FilterStyle.FILTER_TO_MINIMIZE_TERMS);\nTripleRelation.augmentSubjectObjectWithStanfordNER(combinedTriples,s.getNamedEntities());\nTripleRelation.augmentSubjectObjectWithSpacyNER(combinedTriples, spacyEntities, s.getStartPosition(), s.getStartPosition() + s.getOriginalText().length());\nTripleRelation.augmentSubjectObjectWithDBPedia(combinedTriples, dbpediaEntities, s.getStartPosition(), s.getStartPosition() + s.getOriginalText().length());\ns.setTripleRelations(combinedTriples);\n}\nreturn result;\n}","code_context_20":"public static Document parse(String text, int windowSize, JSONArray spacyEntities, JSONArray dbpediaEntities) {\nDocument result = new Document();\nresult._originaltext = text;\nresult._sentences = new java.util.ArrayList<Sentence>();\nList<String> splitSentences = StanfordNLP.splitSentences(text);\nint lastFoundPosition = -1;\nint lastSentenceLength = 1;\nint sentenceCount = 0;\nint runningSentinmentScore = 0;\n\/\/ perform the window parsing - used to do coreref, plus get initial named entities, sentiment, and tokens\nfor (int sentenceIndex = 0; sentenceIndex < splitSentences.size(); sentenceIndex++) {\nSplitResult sr = getTextWindow(splitSentences, sentenceIndex,windowSize);\nAnnotation sentenceDoc = StanfordNLP.annotateText(sr.text);\nList<CoreMap> sentences = sentenceDoc.get(CoreAnnotations.SentencesAnnotation.class);\nCoreMap sentence = sentences.get(sr.sentencePositionToUse);\nsentenceCount++;\nString sentenceText = sentence.get(CoreAnnotations.TextAnnotation.class);\nint documentPosition = text.indexOf(sentenceText,lastFoundPosition);\nif (documentPosition == -1) {\ndocumentPosition = lastFoundPosition + lastSentenceLength;\n}\njava.util.List<Token> sentenceTokens = Token.extractTokens(sentence, sentenceCount);\nSentence s = new Sentence(sentenceText, documentPosition, sentenceCount, sentenceTokens);\nTree tree = sentence.get(SentimentCoreAnnotations.SentimentAnnotatedTree.class);\nint sentiment = RNNCoreAnnotations.getPredictedClass(tree);\ns.setSentiment(sentiment);\nrunningSentinmentScore += sentiment;\nList<String> resolvedSentences = Coreference.resolveCoreferences(sentenceDoc);\ns.setCorefText(resolvedSentences.get(sr.sentencePositionToUse));\nresult._sentences.add(s);\nlastFoundPosition = documentPosition;\nlastSentenceLength = sentenceText.length();\n}\nresult._sentimentScore = ((double) runningSentinmentScore) \/ sentenceCount;\n\/\/ reparse to get openIE \/ relations items\nint baseSentenceIndex = -1;\nfor (Sentence s: result._sentences) {\nAnnotation sentenceDoc = StanfordNLP.annotateText(s.getCorefText());\nbaseSentenceIndex++;\njava.util.List<Token> sentenceTokens = Token.extractTokens(sentenceDoc.get(CoreAnnotations.SentencesAnnotation.class).get(0), baseSentenceIndex);\njava.util.List<TripleRelation> triples = TripleRelation.extractTriples(sentenceDoc, baseSentenceIndex);\ntriples = TripleRelation.valiadateTriples(triples, sentenceTokens);\nList<AnnotatedProposition> minieTriplesAP = StanfordNLP.extractMinIETriples(s.getCorefText());\njava.util.List<TripleRelation> minetriples = TripleRelation.extractTriples(minieTriplesAP, baseSentenceIndex);\nminetriples = TripleRelation.valiadateTriples(minetriples, sentenceTokens);\njava.util.List<TripleRelation> combinedTriples = TripleRelation.combine(triples, minetriples);\ncombinedTriples = TripleRelation.reduceTriples(combinedTriples, FilterStyle.FILTER_TO_MAXIMIZE_SUBJ_OBJ_MINIMIZE_RELATION);\n\/\/combinedTriples = TripleRelation.reduceTriples(combinedTriples, FilterStyle.FILTER_TO_MINIMIZE_TERMS);\nTripleRelation.augmentSubjectObjectWithStanfordNER(combinedTriples,s.getNamedEntities());\nTripleRelation.augmentSubjectObjectWithSpacyNER(combinedTriples, spacyEntities, s.getStartPosition(), s.getStartPosition() + s.getOriginalText().length());\nTripleRelation.augmentSubjectObjectWithDBPedia(combinedTriples, dbpediaEntities, s.getStartPosition(), s.getStartPosition() + s.getOriginalText().length());\ns.setTripleRelations(combinedTriples);\n}\nreturn result;\n}\n\npublic static Document parse(String text, int windowSize, JSONArray spacyEntities, JSONArray dbpediaEntities) {\nDocument result = new Document();\nresult._originaltext = text;\nresult._sentences = new java.util.ArrayList<Sentence>();\nList<String> splitSentences = StanfordNLP.splitSentences(text);\nint lastFoundPosition = -1;\nint lastSentenceLength = 1;\nint sentenceCount = 0;\nint runningSentinmentScore = 0;\n\/\/ perform the window parsing - used to do coreref, plus get initial named entities, sentiment, and tokens\nfor (int sentenceIndex = 0; sentenceIndex < splitSentences.size(); sentenceIndex++) {\nSplitResult sr = getTextWindow(splitSentences, sentenceIndex,windowSize);\nAnnotation sentenceDoc = StanfordNLP.annotateText(sr.text);\nList<CoreMap> sentences = sentenceDoc.get(CoreAnnotations.SentencesAnnotation.class);\nCoreMap sentence = sentences.get(sr.sentencePositionToUse);\nsentenceCount++;\nString sentenceText = sentence.get(CoreAnnotations.TextAnnotation.class);\nint documentPosition = text.indexOf(sentenceText,lastFoundPosition);\nif (documentPosition == -1) {\ndocumentPosition = lastFoundPosition + lastSentenceLength;\n}\njava.util.List<Token> sentenceTokens = Token.extractTokens(sentence, sentenceCount);\nSentence s = new Sentence(sentenceText, documentPosition, sentenceCount, sentenceTokens);\nTree tree = sentence.get(SentimentCoreAnnotations.SentimentAnnotatedTree.class);\nint sentiment = RNNCoreAnnotations.getPredictedClass(tree);\ns.setSentiment(sentiment);\nrunningSentinmentScore += sentiment;\nList<String> resolvedSentences = Coreference.resolveCoreferences(sentenceDoc);\ns.setCorefText(resolvedSentences.get(sr.sentencePositionToUse));\nresult._sentences.add(s);\n\nCoreMap sentence = sentences.get(sr.sentencePositionToUse);\nsentenceCount++;\nString sentenceText = sentence.get(CoreAnnotations.TextAnnotation.class);\nint documentPosition = text.indexOf(sentenceText,lastFoundPosition);\nif (documentPosition == -1) {\ndocumentPosition = lastFoundPosition + lastSentenceLength;\n}\njava.util.List<Token> sentenceTokens = Token.extractTokens(sentence, sentenceCount);\nSentence s = new Sentence(sentenceText, documentPosition, sentenceCount, sentenceTokens);\nTree tree = sentence.get(SentimentCoreAnnotations.SentimentAnnotatedTree.class);\nint sentiment = RNNCoreAnnotations.getPredictedClass(tree);\ns.setSentiment(sentiment);\nrunningSentinmentScore += sentiment;\nList<String> resolvedSentences = Coreference.resolveCoreferences(sentenceDoc);\ns.setCorefText(resolvedSentences.get(sr.sentencePositionToUse));\nresult._sentences.add(s);\nlastFoundPosition = documentPosition;\nlastSentenceLength = sentenceText.length();\n}\nresult._sentimentScore = ((double) runningSentinmentScore) \/ sentenceCount;\n\/\/ reparse to get openIE \/ relations items\nint baseSentenceIndex = -1;\nfor (Sentence s: result._sentences) {\nAnnotation sentenceDoc = StanfordNLP.annotateText(s.getCorefText());\nbaseSentenceIndex++;\njava.util.List<Token> sentenceTokens = Token.extractTokens(sentenceDoc.get(CoreAnnotations.SentencesAnnotation.class).get(0), baseSentenceIndex);\njava.util.List<TripleRelation> triples = TripleRelation.extractTriples(sentenceDoc, baseSentenceIndex);\ntriples = TripleRelation.valiadateTriples(triples, sentenceTokens);\nList<AnnotatedProposition> minieTriplesAP = StanfordNLP.extractMinIETriples(s.getCorefText());\njava.util.List<TripleRelation> minetriples = TripleRelation.extractTriples(minieTriplesAP, baseSentenceIndex);\nminetriples = TripleRelation.valiadateTriples(minetriples, sentenceTokens);\njava.util.List<TripleRelation> combinedTriples = TripleRelation.combine(triples, minetriples);\ncombinedTriples = TripleRelation.reduceTriples(combinedTriples, FilterStyle.FILTER_TO_MAXIMIZE_SUBJ_OBJ_MINIMIZE_RELATION);\n\/\/combinedTriples = TripleRelation.reduceTriples(combinedTriples, FilterStyle.FILTER_TO_MINIMIZE_TERMS);\nTripleRelation.augmentSubjectObjectWithStanfordNER(combinedTriples,s.getNamedEntities());\nTripleRelation.augmentSubjectObjectWithSpacyNER(combinedTriples, spacyEntities, s.getStartPosition(), s.getStartPosition() + s.getOriginalText().length());\nTripleRelation.augmentSubjectObjectWithDBPedia(combinedTriples, dbpediaEntities, s.getStartPosition(), s.getStartPosition() + s.getOriginalText().length());\ns.setTripleRelations(combinedTriples);\n}\nreturn result;\n}\n\nList<String> resolvedSentences = Coreference.resolveCoreferences(sentenceDoc);\ns.setCorefText(resolvedSentences.get(sr.sentencePositionToUse));\nresult._sentences.add(s);\nlastFoundPosition = documentPosition;\nlastSentenceLength = sentenceText.length();\n}\nresult._sentimentScore = ((double) runningSentinmentScore) \/ sentenceCount;\n\/\/ reparse to get openIE \/ relations items\nint baseSentenceIndex = -1;\nfor (Sentence s: result._sentences) {\nAnnotation sentenceDoc = StanfordNLP.annotateText(s.getCorefText());\nbaseSentenceIndex++;\njava.util.List<Token> sentenceTokens = Token.extractTokens(sentenceDoc.get(CoreAnnotations.SentencesAnnotation.class).get(0), baseSentenceIndex);\njava.util.List<TripleRelation> triples = TripleRelation.extractTriples(sentenceDoc, baseSentenceIndex);\ntriples = TripleRelation.valiadateTriples(triples, sentenceTokens);\nList<AnnotatedProposition> minieTriplesAP = StanfordNLP.extractMinIETriples(s.getCorefText());\njava.util.List<TripleRelation> minetriples = TripleRelation.extractTriples(minieTriplesAP, baseSentenceIndex);\nminetriples = TripleRelation.valiadateTriples(minetriples, sentenceTokens);\njava.util.List<TripleRelation> combinedTriples = TripleRelation.combine(triples, minetriples);\ncombinedTriples = TripleRelation.reduceTriples(combinedTriples, FilterStyle.FILTER_TO_MAXIMIZE_SUBJ_OBJ_MINIMIZE_RELATION);\n\/\/combinedTriples = TripleRelation.reduceTriples(combinedTriples, FilterStyle.FILTER_TO_MINIMIZE_TERMS);\nTripleRelation.augmentSubjectObjectWithStanfordNER(combinedTriples,s.getNamedEntities());\nTripleRelation.augmentSubjectObjectWithSpacyNER(combinedTriples, spacyEntities, s.getStartPosition(), s.getStartPosition() + s.getOriginalText().length());\nTripleRelation.augmentSubjectObjectWithDBPedia(combinedTriples, dbpediaEntities, s.getStartPosition(), s.getStartPosition() + s.getOriginalText().length());\ns.setTripleRelations(combinedTriples);\n}\nreturn result;\n}","label":[0,0,0,0]}
{"id":31468,"original_code":"public static boolean isProvidedUserChoicesForNodeInstance(Map<String, List<Parameter<?>>> userChoices,\n\t        String nodeInstanceName) {\n\t\tif (userChoices == null || userChoices.isEmpty())\n\t\t\treturn false;\n\t\tList<Parameter<?>> paramsForNodeInstance = userChoices.get(nodeInstanceName);\n\t\tif (paramsForNodeInstance == null || paramsForNodeInstance.isEmpty())\n\t\t\treturn false;\n\t\treturn true;\n\t}","code":"public static boolean isProvidedUserChoicesForNodeInstance(Map<String, List<Parameter<?>>> userChoices,\n\t        String nodeInstanceName) {\n\t\tif (userChoices == null || userChoices.isEmpty())\n\t\t\treturn false;\n\t\tList<Parameter<?>> paramsForNodeInstance = userChoices.get(nodeInstanceName);\n\t\tif (paramsForNodeInstance == null || paramsForNodeInstance.isEmpty())\n\t\t\treturn false;\n\t\treturn true;\n\t}","cleancode":"public static boolean isprovideduserchoicesfornodeinstance(map<string, list<parameter<?>>> userchoices, string nodeinstancename) { if (userchoices == null || userchoices.isempty()) return false; list<parameter<?>> paramsfornodeinstance = userchoices.get(nodeinstancename); if (paramsfornodeinstance == null || paramsfornodeinstance.isempty()) return false; return true; }","comment":"\/\/ todo: pull this method up to be used in other factories.","repo":"slipstream\/cimi-mf2c","code_context_2":"public static boolean isProvidedUserChoicesForNodeInstance(Map<String, List<Parameter<?>>> userChoices,\nString nodeInstanceName) {\nif (userChoices == null || userChoices.isEmpty())\nreturn false;\nList<Parameter<?>> paramsForNodeInstance = userChoices.get(nodeInstanceName);\nif (paramsForNodeInstance == null || paramsForNodeInstance.isEmpty())\nreturn false;\nreturn true;\n}","code_context_10":"public static boolean isProvidedUserChoicesForNodeInstance(Map<String, List<Parameter<?>>> userChoices,\nString nodeInstanceName) {\nif (userChoices == null || userChoices.isEmpty())\nreturn false;\nList<Parameter<?>> paramsForNodeInstance = userChoices.get(nodeInstanceName);\nif (paramsForNodeInstance == null || paramsForNodeInstance.isEmpty())\nreturn false;\nreturn true;\n}","code_context_20":"public static boolean isProvidedUserChoicesForNodeInstance(Map<String, List<Parameter<?>>> userChoices,\nString nodeInstanceName) {\nif (userChoices == null || userChoices.isEmpty())\nreturn false;\nList<Parameter<?>> paramsForNodeInstance = userChoices.get(nodeInstanceName);\nif (paramsForNodeInstance == null || paramsForNodeInstance.isEmpty())\nreturn false;\nreturn true;\n}","label":[1,0,0,0]}
{"id":15468,"original_code":"private void handleUpload(HttpServletRequest request, HttpServletResponse resp) throws ServletException, IOException, WsException {\n\t\tcheckPermission(WebswingAction.file_upload);\n\t\ttry {\n\t\t\tString uuid = request.getParameter(\"uuid\");\n\t\t\tif (uuid != null) {\n\t\t\t\tSwingInstance instance = manager.findInstanceBySessionId(uuid);\n\t\t\t\tif (instance != null) {\n\t\t\t\t\tdouble maxMB = instance.getAppConfig().getUploadMaxSize();\n\t\t\t\t\tlong maxsize = (long) (maxMB * 1024 * 1024);\n\t\t\t\t\tPart filePart = request.getPart(\"files[]\"); \/\/ Retrieves <input type=\"file\" name=\"file\">\n\t\t\t\t\tString filename = getFilename(filePart);\n\t\t\t\t\tif (maxsize > 0 && filePart.getSize() > maxsize) {\n\t\t\t\t\t\tresp.setStatus(HttpServletResponse.SC_BAD_REQUEST);\n\t\t\t\t\t\tresp.getWriter().write(String.format(\"File '%s' is too large. (Max. file size is %.1fMB)\", filename, maxMB));\n\t\t\t\t\t} else {\n\t\t\t\t\t\tString tempDir = System.getProperty(Constants.TEMP_DIR_PATH);\n\t\t\t\t\t\tString tempName = UUID.randomUUID().toString();\n\t\t\t\t\t\tInputStream filecontent = filePart.getInputStream();\n\t\t\t\t\t\tFile f = new File(URI.create(tempDir + \"\/\" + tempName));\n\t\t\t\t\t\tFileOutputStream output = new FileOutputStream(f);\n\t\t\t\t\t\tIOUtils.copy(filecontent, output);\n\t\t\t\t\t\toutput.close();\n\t\t\t\t\t\tfilecontent.close();\n\t\t\t\t\t\tlog.info(\"File \" + filename + \" uploaded (size:\" + filePart.getSize() + \") to \" + f.getAbsolutePath());\n\t\t\t\t\t\tUploadEventMsgIn msg = new UploadEventMsgIn();\n\t\t\t\t\t\tmsg.setFileName(filename);\n\t\t\t\t\t\tmsg.setTempFileLocation(f.getAbsolutePath());\n\t\t\t\t\t\tboolean sent = instance.sendToSwing(null, msg);\n\t\t\t\t\t\tif (!sent) {\n\t\t\t\t\t\t\tlog.error(\"Failed to send upload notification to app session. File:\" + filename + \"+ClientID:\" + instance.getClientId());\n\t\t\t\t\t\t\tf.delete();\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tresp.getWriter().write(\"{\\\"files\\\":[{\\\"name\\\":\\\"\" + filename + \"\\\"}]}\"); \/\/ TODO size\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tthrow new Exception(\"Related App instance not found.(\" + uuid + \")\");\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tthrow new Exception(\"UUID not specified in request\");\n\t\t\t}\n\t\t} catch (Exception e) {\n\t\t\tif (e.getCause() instanceof EOFException) {\n\t\t\t\tlog.warn(\"File upload canceled by user: \" + e.getMessage());\n\t\t\t} else {\n\t\t\t\tresp.setStatus(HttpServletResponse.SC_INTERNAL_SERVER_ERROR);\n\t\t\t\tresp.getWriter().write(\"Upload finished with error...\");\n\t\t\t\tlog.error(\"Error while uploading file: \" + e.getMessage(), e);\n\t\t\t}\n\t\t}\n\t}","code":"private void handleUpload(HttpServletRequest request, HttpServletResponse resp) throws ServletException, IOException, WsException {\n\t\tcheckPermission(WebswingAction.file_upload);\n\t\ttry {\n\t\t\tString uuid = request.getParameter(\"uuid\");\n\t\t\tif (uuid != null) {\n\t\t\t\tSwingInstance instance = manager.findInstanceBySessionId(uuid);\n\t\t\t\tif (instance != null) {\n\t\t\t\t\tdouble maxMB = instance.getAppConfig().getUploadMaxSize();\n\t\t\t\t\tlong maxsize = (long) (maxMB * 1024 * 1024);\n\t\t\t\t\tPart filePart = request.getPart(\"files[]\");\n\t\t\t\t\tString filename = getFilename(filePart);\n\t\t\t\t\tif (maxsize > 0 && filePart.getSize() > maxsize) {\n\t\t\t\t\t\tresp.setStatus(HttpServletResponse.SC_BAD_REQUEST);\n\t\t\t\t\t\tresp.getWriter().write(String.format(\"File '%s' is too large. (Max. file size is %.1fMB)\", filename, maxMB));\n\t\t\t\t\t} else {\n\t\t\t\t\t\tString tempDir = System.getProperty(Constants.TEMP_DIR_PATH);\n\t\t\t\t\t\tString tempName = UUID.randomUUID().toString();\n\t\t\t\t\t\tInputStream filecontent = filePart.getInputStream();\n\t\t\t\t\t\tFile f = new File(URI.create(tempDir + \"\/\" + tempName));\n\t\t\t\t\t\tFileOutputStream output = new FileOutputStream(f);\n\t\t\t\t\t\tIOUtils.copy(filecontent, output);\n\t\t\t\t\t\toutput.close();\n\t\t\t\t\t\tfilecontent.close();\n\t\t\t\t\t\tlog.info(\"File \" + filename + \" uploaded (size:\" + filePart.getSize() + \") to \" + f.getAbsolutePath());\n\t\t\t\t\t\tUploadEventMsgIn msg = new UploadEventMsgIn();\n\t\t\t\t\t\tmsg.setFileName(filename);\n\t\t\t\t\t\tmsg.setTempFileLocation(f.getAbsolutePath());\n\t\t\t\t\t\tboolean sent = instance.sendToSwing(null, msg);\n\t\t\t\t\t\tif (!sent) {\n\t\t\t\t\t\t\tlog.error(\"Failed to send upload notification to app session. File:\" + filename + \"+ClientID:\" + instance.getClientId());\n\t\t\t\t\t\t\tf.delete();\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tresp.getWriter().write(\"{\\\"files\\\":[{\\\"name\\\":\\\"\" + filename + \"\\\"}]}\");\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tthrow new Exception(\"Related App instance not found.(\" + uuid + \")\");\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tthrow new Exception(\"UUID not specified in request\");\n\t\t\t}\n\t\t} catch (Exception e) {\n\t\t\tif (e.getCause() instanceof EOFException) {\n\t\t\t\tlog.warn(\"File upload canceled by user: \" + e.getMessage());\n\t\t\t} else {\n\t\t\t\tresp.setStatus(HttpServletResponse.SC_INTERNAL_SERVER_ERROR);\n\t\t\t\tresp.getWriter().write(\"Upload finished with error...\");\n\t\t\t\tlog.error(\"Error while uploading file: \" + e.getMessage(), e);\n\t\t\t}\n\t\t}\n\t}","cleancode":"private void handleupload(httpservletrequest request, httpservletresponse resp) throws servletexception, ioexception, wsexception { checkpermission(webswingaction.file_upload); try { string uuid = request.getparameter(\"uuid\"); if (uuid != null) { swinginstance instance = manager.findinstancebysessionid(uuid); if (instance != null) { double maxmb = instance.getappconfig().getuploadmaxsize(); long maxsize = (long) (maxmb * 1024 * 1024); part filepart = request.getpart(\"files[]\"); string filename = getfilename(filepart); if (maxsize > 0 && filepart.getsize() > maxsize) { resp.setstatus(httpservletresponse.sc_bad_request); resp.getwriter().write(string.format(\"file '%s' is too large. (max. file size is %.1fmb)\", filename, maxmb)); } else { string tempdir = system.getproperty(constants.temp_dir_path); string tempname = uuid.randomuuid().tostring(); inputstream filecontent = filepart.getinputstream(); file f = new file(uri.create(tempdir + \"\/\" + tempname)); fileoutputstream output = new fileoutputstream(f); ioutils.copy(filecontent, output); output.close(); filecontent.close(); log.info(\"file \" + filename + \" uploaded (size:\" + filepart.getsize() + \") to \" + f.getabsolutepath()); uploadeventmsgin msg = new uploadeventmsgin(); msg.setfilename(filename); msg.settempfilelocation(f.getabsolutepath()); boolean sent = instance.sendtoswing(null, msg); if (!sent) { log.error(\"failed to send upload notification to app session. file:\" + filename + \"+clientid:\" + instance.getclientid()); f.delete(); } else { resp.getwriter().write(\"{\\\"files\\\":[{\\\"name\\\":\\\"\" + filename + \"\\\"}]}\"); } } } else { throw new exception(\"related app instance not found.(\" + uuid + \")\"); } } else { throw new exception(\"uuid not specified in request\"); } } catch (exception e) { if (e.getcause() instanceof eofexception) { log.warn(\"file upload canceled by user: \" + e.getmessage()); } else { resp.setstatus(httpservletresponse.sc_internal_server_error); resp.getwriter().write(\"upload finished with error...\"); log.error(\"error while uploading file: \" + e.getmessage(), e); } } }","comment":"\/\/ retrieves <input type=\"file\" name=\"file\">\n\/\/ todo size","repo":"swing-fly\/webswing","code_context_2":"double maxMB = instance.getAppConfig().getUploadMaxSize();\nlong maxsize = (long) (maxMB * 1024 * 1024);\nPart filePart = request.getPart(\"files[]\"); \/\/ Retrieves <input type=\"file\" name=\"file\">\nString filename = getFilename(filePart);\nif (maxsize > 0 && filePart.getSize() > maxsize) {\n\nf.delete();\n} else {\nresp.getWriter().write(\"{\\\"files\\\":[{\\\"name\\\":\\\"\" + filename + \"\\\"}]}\"); \/\/ TODO size\n}\n}","code_context_10":"private void handleUpload(HttpServletRequest request, HttpServletResponse resp) throws ServletException, IOException, WsException {\ncheckPermission(WebswingAction.file_upload);\ntry {\nString uuid = request.getParameter(\"uuid\");\nif (uuid != null) {\nSwingInstance instance = manager.findInstanceBySessionId(uuid);\nif (instance != null) {\ndouble maxMB = instance.getAppConfig().getUploadMaxSize();\nlong maxsize = (long) (maxMB * 1024 * 1024);\nPart filePart = request.getPart(\"files[]\"); \/\/ Retrieves <input type=\"file\" name=\"file\">\nString filename = getFilename(filePart);\nif (maxsize > 0 && filePart.getSize() > maxsize) {\nresp.setStatus(HttpServletResponse.SC_BAD_REQUEST);\nresp.getWriter().write(String.format(\"File '%s' is too large. (Max. file size is %.1fMB)\", filename, maxMB));\n} else {\nString tempDir = System.getProperty(Constants.TEMP_DIR_PATH);\nString tempName = UUID.randomUUID().toString();\nInputStream filecontent = filePart.getInputStream();\nFile f = new File(URI.create(tempDir + \"\/\" + tempName));\nFileOutputStream output = new FileOutputStream(f);\n\nfilecontent.close();\nlog.info(\"File \" + filename + \" uploaded (size:\" + filePart.getSize() + \") to \" + f.getAbsolutePath());\nUploadEventMsgIn msg = new UploadEventMsgIn();\nmsg.setFileName(filename);\nmsg.setTempFileLocation(f.getAbsolutePath());\nboolean sent = instance.sendToSwing(null, msg);\nif (!sent) {\nlog.error(\"Failed to send upload notification to app session. File:\" + filename + \"+ClientID:\" + instance.getClientId());\nf.delete();\n} else {\nresp.getWriter().write(\"{\\\"files\\\":[{\\\"name\\\":\\\"\" + filename + \"\\\"}]}\"); \/\/ TODO size\n}\n}\n} else {\nthrow new Exception(\"Related App instance not found.(\" + uuid + \")\");\n}\n} else {\nthrow new Exception(\"UUID not specified in request\");\n}\n} catch (Exception e) {\nif (e.getCause() instanceof EOFException) {","code_context_20":"private void handleUpload(HttpServletRequest request, HttpServletResponse resp) throws ServletException, IOException, WsException {\ncheckPermission(WebswingAction.file_upload);\ntry {\nString uuid = request.getParameter(\"uuid\");\nif (uuid != null) {\nSwingInstance instance = manager.findInstanceBySessionId(uuid);\nif (instance != null) {\ndouble maxMB = instance.getAppConfig().getUploadMaxSize();\nlong maxsize = (long) (maxMB * 1024 * 1024);\nPart filePart = request.getPart(\"files[]\"); \/\/ Retrieves <input type=\"file\" name=\"file\">\nString filename = getFilename(filePart);\nif (maxsize > 0 && filePart.getSize() > maxsize) {\nresp.setStatus(HttpServletResponse.SC_BAD_REQUEST);\nresp.getWriter().write(String.format(\"File '%s' is too large. (Max. file size is %.1fMB)\", filename, maxMB));\n} else {\nString tempDir = System.getProperty(Constants.TEMP_DIR_PATH);\nString tempName = UUID.randomUUID().toString();\nInputStream filecontent = filePart.getInputStream();\nFile f = new File(URI.create(tempDir + \"\/\" + tempName));\nFileOutputStream output = new FileOutputStream(f);\nIOUtils.copy(filecontent, output);\noutput.close();\nfilecontent.close();\nlog.info(\"File \" + filename + \" uploaded (size:\" + filePart.getSize() + \") to \" + f.getAbsolutePath());\nUploadEventMsgIn msg = new UploadEventMsgIn();\nmsg.setFileName(filename);\nmsg.setTempFileLocation(f.getAbsolutePath());\nboolean sent = instance.sendToSwing(null, msg);\nif (!sent) {\nlog.error(\"Failed to send upload notification to app session. File:\" + filename + \"+ClientID:\" + instance.getClientId());\n\nresp.setStatus(HttpServletResponse.SC_BAD_REQUEST);\nresp.getWriter().write(String.format(\"File '%s' is too large. (Max. file size is %.1fMB)\", filename, maxMB));\n} else {\nString tempDir = System.getProperty(Constants.TEMP_DIR_PATH);\nString tempName = UUID.randomUUID().toString();\nInputStream filecontent = filePart.getInputStream();\nFile f = new File(URI.create(tempDir + \"\/\" + tempName));\nFileOutputStream output = new FileOutputStream(f);\nIOUtils.copy(filecontent, output);\noutput.close();\nfilecontent.close();\nlog.info(\"File \" + filename + \" uploaded (size:\" + filePart.getSize() + \") to \" + f.getAbsolutePath());\nUploadEventMsgIn msg = new UploadEventMsgIn();\nmsg.setFileName(filename);\nmsg.setTempFileLocation(f.getAbsolutePath());\nboolean sent = instance.sendToSwing(null, msg);\nif (!sent) {\nlog.error(\"Failed to send upload notification to app session. File:\" + filename + \"+ClientID:\" + instance.getClientId());\nf.delete();\n} else {\nresp.getWriter().write(\"{\\\"files\\\":[{\\\"name\\\":\\\"\" + filename + \"\\\"}]}\"); \/\/ TODO size\n}\n}\n} else {\nthrow new Exception(\"Related App instance not found.(\" + uuid + \")\");\n}\n} else {\nthrow new Exception(\"UUID not specified in request\");\n}\n} catch (Exception e) {\nif (e.getCause() instanceof EOFException) {\nlog.warn(\"File upload canceled by user: \" + e.getMessage());\n} else {\nresp.setStatus(HttpServletResponse.SC_INTERNAL_SERVER_ERROR);\nresp.getWriter().write(\"Upload finished with error...\");\nlog.error(\"Error while uploading file: \" + e.getMessage(), e);\n}\n}\n}","label":[0,0,0,0]}
{"id":15624,"original_code":"@Override \n    public void enableSupportForSerializationIfApplicable(CancelIndicator cancelIndicator) {\n        if (!IterableExtensions.isNullOrEmpty(targetConfig.protoFiles)) {\n            \/\/ Enable support for proto serialization\n            enabledSerializers.add(SupportedSerializers.PROTO);\n        }\n        for (SupportedSerializers serialization : enabledSerializers) {\n            switch (serialization) {\n                case NATIVE: {\n                    FedNativePythonSerialization pickler = new FedNativePythonSerialization();\n                    code.pr(pickler.generatePreambleForSupport().toString());\n                }\n                case PROTO: {\n                    \/\/ Handle .proto files.\n                    for (String name : targetConfig.protoFiles) {\n                        this.processProtoFile(name, cancelIndicator);\n                        int dotIndex = name.lastIndexOf(\".\");\n                        String rootFilename = dotIndex > 0 ? name.substring(0, dotIndex) : name;\n                        pythonPreamble.pr(\"import \"+rootFilename+\"_pb2 as \"+rootFilename);\n                        protoNames.add(rootFilename);\n                    }\n                }\n                case ROS2: {\n                    \/\/ FIXME: Not supported yet\n                }\n            }\n        }\n    }","code":"@Override \n    public void enableSupportForSerializationIfApplicable(CancelIndicator cancelIndicator) {\n        if (!IterableExtensions.isNullOrEmpty(targetConfig.protoFiles)) {\n           \n            enabledSerializers.add(SupportedSerializers.PROTO);\n        }\n        for (SupportedSerializers serialization : enabledSerializers) {\n            switch (serialization) {\n                case NATIVE: {\n                    FedNativePythonSerialization pickler = new FedNativePythonSerialization();\n                    code.pr(pickler.generatePreambleForSupport().toString());\n                }\n                case PROTO: {\n                   \n                    for (String name : targetConfig.protoFiles) {\n                        this.processProtoFile(name, cancelIndicator);\n                        int dotIndex = name.lastIndexOf(\".\");\n                        String rootFilename = dotIndex > 0 ? name.substring(0, dotIndex) : name;\n                        pythonPreamble.pr(\"import \"+rootFilename+\"_pb2 as \"+rootFilename);\n                        protoNames.add(rootFilename);\n                    }\n                }\n                case ROS2: {\n                   \n                }\n            }\n        }\n    }","cleancode":"@override public void enablesupportforserializationifapplicable(cancelindicator cancelindicator) { if (!iterableextensions.isnullorempty(targetconfig.protofiles)) { enabledserializers.add(supportedserializers.proto); } for (supportedserializers serialization : enabledserializers) { switch (serialization) { case native: { fednativepythonserialization pickler = new fednativepythonserialization(); code.pr(pickler.generatepreambleforsupport().tostring()); } case proto: { for (string name : targetconfig.protofiles) { this.processprotofile(name, cancelindicator); int dotindex = name.lastindexof(\".\"); string rootfilename = dotindex > 0 ? name.substring(0, dotindex) : name; pythonpreamble.pr(\"import \"+rootfilename+\"_pb2 as \"+rootfilename); protonames.add(rootfilename); } } case ros2: { } } } }","comment":"\/** * add necessary code to the source and necessary build supports to * enable the requested serializations in 'enabledserializations' *\/\n\/\/ enable support for proto serialization\n\/\/ handle .proto files.\n\/\/ fixme: not supported yet","repo":"soerendomroes\/lingua-franca","code_context_2":"@Override\npublic void enableSupportForSerializationIfApplicable(CancelIndicator cancelIndicator) {\nif (!IterableExtensions.isNullOrEmpty(targetConfig.protoFiles)) {\n\/\/ Enable support for proto serialization\nenabledSerializers.add(SupportedSerializers.PROTO);\n}\nfor (SupportedSerializers serialization : enabledSerializers) {\nswitch (serialization) {\ncase NATIVE: {\nFedNativePythonSerialization pickler = new FedNativePythonSerialization();\ncode.pr(pickler.generatePreambleForSupport().toString());\n}\ncase PROTO: {\n\/\/ Handle .proto files.\nfor (String name : targetConfig.protoFiles) {\nthis.processProtoFile(name, cancelIndicator);\nint dotIndex = name.lastIndexOf(\".\");\nString rootFilename = dotIndex > 0 ? name.substring(0, dotIndex) : name;\npythonPreamble.pr(\"import \"+rootFilename+\"_pb2 as \"+rootFilename);\nprotoNames.add(rootFilename);\n}\n}\ncase ROS2: {\n\/\/ FIXME: Not supported yet\n}\n}\n}\n}\n\npublic void enableSupportForSerializationIfApplicable(CancelIndicator cancelIndicator) {\nif (!IterableExtensions.isNullOrEmpty(targetConfig.protoFiles)) {\n\/\/ Enable support for proto serialization\nenabledSerializers.add(SupportedSerializers.PROTO);\n}\n\n}\ncase PROTO: {\n\/\/ Handle .proto files.\nfor (String name : targetConfig.protoFiles) {\nthis.processProtoFile(name, cancelIndicator);\n\n}\ncase ROS2: {\n\/\/ FIXME: Not supported yet\n}\n}","code_context_10":"@Override\npublic void enableSupportForSerializationIfApplicable(CancelIndicator cancelIndicator) {\nif (!IterableExtensions.isNullOrEmpty(targetConfig.protoFiles)) {\n\/\/ Enable support for proto serialization\nenabledSerializers.add(SupportedSerializers.PROTO);\n}\nfor (SupportedSerializers serialization : enabledSerializers) {\nswitch (serialization) {\ncase NATIVE: {\nFedNativePythonSerialization pickler = new FedNativePythonSerialization();\ncode.pr(pickler.generatePreambleForSupport().toString());\n}\ncase PROTO: {\n\/\/ Handle .proto files.\nfor (String name : targetConfig.protoFiles) {\nthis.processProtoFile(name, cancelIndicator);\nint dotIndex = name.lastIndexOf(\".\");\nString rootFilename = dotIndex > 0 ? name.substring(0, dotIndex) : name;\npythonPreamble.pr(\"import \"+rootFilename+\"_pb2 as \"+rootFilename);\nprotoNames.add(rootFilename);\n}\n}\ncase ROS2: {\n\/\/ FIXME: Not supported yet\n}\n}\n}\n}\n\n@Override\npublic void enableSupportForSerializationIfApplicable(CancelIndicator cancelIndicator) {\nif (!IterableExtensions.isNullOrEmpty(targetConfig.protoFiles)) {\n\/\/ Enable support for proto serialization\nenabledSerializers.add(SupportedSerializers.PROTO);\n}\nfor (SupportedSerializers serialization : enabledSerializers) {\nswitch (serialization) {\ncase NATIVE: {\nFedNativePythonSerialization pickler = new FedNativePythonSerialization();\ncode.pr(pickler.generatePreambleForSupport().toString());\n}\ncase PROTO: {\n\/\/ Handle .proto files.\n\n\/\/ Enable support for proto serialization\nenabledSerializers.add(SupportedSerializers.PROTO);\n}\nfor (SupportedSerializers serialization : enabledSerializers) {\nswitch (serialization) {\ncase NATIVE: {\nFedNativePythonSerialization pickler = new FedNativePythonSerialization();\ncode.pr(pickler.generatePreambleForSupport().toString());\n}\ncase PROTO: {\n\/\/ Handle .proto files.\nfor (String name : targetConfig.protoFiles) {\nthis.processProtoFile(name, cancelIndicator);\nint dotIndex = name.lastIndexOf(\".\");\nString rootFilename = dotIndex > 0 ? name.substring(0, dotIndex) : name;\npythonPreamble.pr(\"import \"+rootFilename+\"_pb2 as \"+rootFilename);\nprotoNames.add(rootFilename);\n}\n}\ncase ROS2: {\n\/\/ FIXME: Not supported yet\n\n\/\/ Handle .proto files.\nfor (String name : targetConfig.protoFiles) {\nthis.processProtoFile(name, cancelIndicator);\nint dotIndex = name.lastIndexOf(\".\");\nString rootFilename = dotIndex > 0 ? name.substring(0, dotIndex) : name;\npythonPreamble.pr(\"import \"+rootFilename+\"_pb2 as \"+rootFilename);\nprotoNames.add(rootFilename);\n}\n}\ncase ROS2: {\n\/\/ FIXME: Not supported yet\n}\n}\n}\n}","code_context_20":"@Override\npublic void enableSupportForSerializationIfApplicable(CancelIndicator cancelIndicator) {\nif (!IterableExtensions.isNullOrEmpty(targetConfig.protoFiles)) {\n\/\/ Enable support for proto serialization\nenabledSerializers.add(SupportedSerializers.PROTO);\n}\nfor (SupportedSerializers serialization : enabledSerializers) {\nswitch (serialization) {\ncase NATIVE: {\nFedNativePythonSerialization pickler = new FedNativePythonSerialization();\ncode.pr(pickler.generatePreambleForSupport().toString());\n}\ncase PROTO: {\n\/\/ Handle .proto files.\nfor (String name : targetConfig.protoFiles) {\nthis.processProtoFile(name, cancelIndicator);\nint dotIndex = name.lastIndexOf(\".\");\nString rootFilename = dotIndex > 0 ? name.substring(0, dotIndex) : name;\npythonPreamble.pr(\"import \"+rootFilename+\"_pb2 as \"+rootFilename);\nprotoNames.add(rootFilename);\n}\n}\ncase ROS2: {\n\/\/ FIXME: Not supported yet\n}\n}\n}\n}\n\n@Override\npublic void enableSupportForSerializationIfApplicable(CancelIndicator cancelIndicator) {\nif (!IterableExtensions.isNullOrEmpty(targetConfig.protoFiles)) {\n\/\/ Enable support for proto serialization\nenabledSerializers.add(SupportedSerializers.PROTO);\n}\nfor (SupportedSerializers serialization : enabledSerializers) {\nswitch (serialization) {\ncase NATIVE: {\nFedNativePythonSerialization pickler = new FedNativePythonSerialization();\ncode.pr(pickler.generatePreambleForSupport().toString());\n}\ncase PROTO: {\n\/\/ Handle .proto files.\nfor (String name : targetConfig.protoFiles) {\nthis.processProtoFile(name, cancelIndicator);\nint dotIndex = name.lastIndexOf(\".\");\nString rootFilename = dotIndex > 0 ? name.substring(0, dotIndex) : name;\npythonPreamble.pr(\"import \"+rootFilename+\"_pb2 as \"+rootFilename);\nprotoNames.add(rootFilename);\n}\n}\ncase ROS2: {\n\/\/ FIXME: Not supported yet\n\n@Override\npublic void enableSupportForSerializationIfApplicable(CancelIndicator cancelIndicator) {\nif (!IterableExtensions.isNullOrEmpty(targetConfig.protoFiles)) {\n\/\/ Enable support for proto serialization\nenabledSerializers.add(SupportedSerializers.PROTO);\n}\nfor (SupportedSerializers serialization : enabledSerializers) {\nswitch (serialization) {\ncase NATIVE: {\nFedNativePythonSerialization pickler = new FedNativePythonSerialization();\ncode.pr(pickler.generatePreambleForSupport().toString());\n}\ncase PROTO: {\n\/\/ Handle .proto files.\nfor (String name : targetConfig.protoFiles) {\nthis.processProtoFile(name, cancelIndicator);\nint dotIndex = name.lastIndexOf(\".\");\nString rootFilename = dotIndex > 0 ? name.substring(0, dotIndex) : name;\npythonPreamble.pr(\"import \"+rootFilename+\"_pb2 as \"+rootFilename);\nprotoNames.add(rootFilename);\n}\n}\ncase ROS2: {\n\/\/ FIXME: Not supported yet\n}\n}\n}\n}\n\n\/\/ Enable support for proto serialization\nenabledSerializers.add(SupportedSerializers.PROTO);\n}\nfor (SupportedSerializers serialization : enabledSerializers) {\nswitch (serialization) {\ncase NATIVE: {\nFedNativePythonSerialization pickler = new FedNativePythonSerialization();\ncode.pr(pickler.generatePreambleForSupport().toString());\n}\ncase PROTO: {\n\/\/ Handle .proto files.\nfor (String name : targetConfig.protoFiles) {\nthis.processProtoFile(name, cancelIndicator);\nint dotIndex = name.lastIndexOf(\".\");\nString rootFilename = dotIndex > 0 ? name.substring(0, dotIndex) : name;\npythonPreamble.pr(\"import \"+rootFilename+\"_pb2 as \"+rootFilename);\nprotoNames.add(rootFilename);\n}\n}\ncase ROS2: {\n\/\/ FIXME: Not supported yet\n}\n}\n}\n}","label":[0,1,0,0]}
{"id":15626,"original_code":"@Override \n    public void writeDockerFile(File dockerComposeDir, String dockerFileName, String federateName) {\n        if (mainDef == null) {\n            return;\n        }\n        Path srcGenPath = fileConfig.getSrcGenPath();\n        String dockerFile = srcGenPath + File.separator + dockerFileName;\n        CodeBuilder contents = new CodeBuilder();\n        contents.pr(PythonDockerGenerator.generateDockerFileContent(topLevelName, srcGenPath));\n        try {\n            \/\/ If a dockerfile exists, remove it.\n            Files.deleteIfExists(srcGenPath.resolve(dockerFileName));\n            contents.writeToFile(dockerFile);\n        } catch (IOException e) {\n            Exceptions.sneakyThrow(e);\n        }\n        System.out.println(getDockerBuildCommand(dockerFile, dockerComposeDir, federateName));\n    }","code":"@Override \n    public void writeDockerFile(File dockerComposeDir, String dockerFileName, String federateName) {\n        if (mainDef == null) {\n            return;\n        }\n        Path srcGenPath = fileConfig.getSrcGenPath();\n        String dockerFile = srcGenPath + File.separator + dockerFileName;\n        CodeBuilder contents = new CodeBuilder();\n        contents.pr(PythonDockerGenerator.generateDockerFileContent(topLevelName, srcGenPath));\n        try {\n           \n            Files.deleteIfExists(srcGenPath.resolve(dockerFileName));\n            contents.writeToFile(dockerFile);\n        } catch (IOException e) {\n            Exceptions.sneakyThrow(e);\n        }\n        System.out.println(getDockerBuildCommand(dockerFile, dockerComposeDir, federateName));\n    }","cleancode":"@override public void writedockerfile(file dockercomposedir, string dockerfilename, string federatename) { if (maindef == null) { return; } path srcgenpath = fileconfig.getsrcgenpath(); string dockerfile = srcgenpath + file.separator + dockerfilename; codebuilder contents = new codebuilder(); contents.pr(pythondockergenerator.generatedockerfilecontent(toplevelname, srcgenpath)); try { files.deleteifexists(srcgenpath.resolve(dockerfilename)); contents.writetofile(dockerfile); } catch (ioexception e) { exceptions.sneakythrow(e); } system.out.println(getdockerbuildcommand(dockerfile, dockercomposedir, federatename)); }","comment":"\/** * write a dockerfile for the current federate as given by filename. * the file will go into src-gen\/filename.dockerfile. * if there is no main reactor, then no dockerfile will be generated * (it wouldn't be very useful). * @param the directory where the docker compose file is generated. * @param the name of the docker file. * @param the name of the federate. *\/\n\/\/ if a dockerfile exists, remove it.","repo":"soerendomroes\/lingua-franca","code_context_2":"@Override\npublic void writeDockerFile(File dockerComposeDir, String dockerFileName, String federateName) {\nif (mainDef == null) {\nreturn;\n}\nPath srcGenPath = fileConfig.getSrcGenPath();\nString dockerFile = srcGenPath + File.separator + dockerFileName;\nCodeBuilder contents = new CodeBuilder();\ncontents.pr(PythonDockerGenerator.generateDockerFileContent(topLevelName, srcGenPath));\ntry {\n\/\/ If a dockerfile exists, remove it.\nFiles.deleteIfExists(srcGenPath.resolve(dockerFileName));\ncontents.writeToFile(dockerFile);\n} catch (IOException e) {\nExceptions.sneakyThrow(e);\n}\nSystem.out.println(getDockerBuildCommand(dockerFile, dockerComposeDir, federateName));\n}\n\ncontents.pr(PythonDockerGenerator.generateDockerFileContent(topLevelName, srcGenPath));\ntry {\n\/\/ If a dockerfile exists, remove it.\nFiles.deleteIfExists(srcGenPath.resolve(dockerFileName));\ncontents.writeToFile(dockerFile);","code_context_10":"@Override\npublic void writeDockerFile(File dockerComposeDir, String dockerFileName, String federateName) {\nif (mainDef == null) {\nreturn;\n}\nPath srcGenPath = fileConfig.getSrcGenPath();\nString dockerFile = srcGenPath + File.separator + dockerFileName;\nCodeBuilder contents = new CodeBuilder();\ncontents.pr(PythonDockerGenerator.generateDockerFileContent(topLevelName, srcGenPath));\ntry {\n\/\/ If a dockerfile exists, remove it.\nFiles.deleteIfExists(srcGenPath.resolve(dockerFileName));\ncontents.writeToFile(dockerFile);\n} catch (IOException e) {\nExceptions.sneakyThrow(e);\n}\nSystem.out.println(getDockerBuildCommand(dockerFile, dockerComposeDir, federateName));\n}\n\n@Override\npublic void writeDockerFile(File dockerComposeDir, String dockerFileName, String federateName) {\nif (mainDef == null) {\nreturn;\n}\nPath srcGenPath = fileConfig.getSrcGenPath();\nString dockerFile = srcGenPath + File.separator + dockerFileName;\nCodeBuilder contents = new CodeBuilder();\ncontents.pr(PythonDockerGenerator.generateDockerFileContent(topLevelName, srcGenPath));\ntry {\n\/\/ If a dockerfile exists, remove it.\nFiles.deleteIfExists(srcGenPath.resolve(dockerFileName));\ncontents.writeToFile(dockerFile);\n} catch (IOException e) {\nExceptions.sneakyThrow(e);\n}\nSystem.out.println(getDockerBuildCommand(dockerFile, dockerComposeDir, federateName));\n}","code_context_20":"@Override\npublic void writeDockerFile(File dockerComposeDir, String dockerFileName, String federateName) {\nif (mainDef == null) {\nreturn;\n}\nPath srcGenPath = fileConfig.getSrcGenPath();\nString dockerFile = srcGenPath + File.separator + dockerFileName;\nCodeBuilder contents = new CodeBuilder();\ncontents.pr(PythonDockerGenerator.generateDockerFileContent(topLevelName, srcGenPath));\ntry {\n\/\/ If a dockerfile exists, remove it.\nFiles.deleteIfExists(srcGenPath.resolve(dockerFileName));\ncontents.writeToFile(dockerFile);\n} catch (IOException e) {\nExceptions.sneakyThrow(e);\n}\nSystem.out.println(getDockerBuildCommand(dockerFile, dockerComposeDir, federateName));\n}\n\n@Override\npublic void writeDockerFile(File dockerComposeDir, String dockerFileName, String federateName) {\nif (mainDef == null) {\nreturn;\n}\nPath srcGenPath = fileConfig.getSrcGenPath();\nString dockerFile = srcGenPath + File.separator + dockerFileName;\nCodeBuilder contents = new CodeBuilder();\ncontents.pr(PythonDockerGenerator.generateDockerFileContent(topLevelName, srcGenPath));\ntry {\n\/\/ If a dockerfile exists, remove it.\nFiles.deleteIfExists(srcGenPath.resolve(dockerFileName));\ncontents.writeToFile(dockerFile);\n} catch (IOException e) {\nExceptions.sneakyThrow(e);\n}\nSystem.out.println(getDockerBuildCommand(dockerFile, dockerComposeDir, federateName));\n}","label":[0,0,0,0]}
{"id":32106,"original_code":"@Test\n    public void testMakePaymentForSavingsAccountOnDeposit() throws Exception {\n        savingsBO = createClientSavingsAccount();\n        String deposit = \"400\";\n        CustomerDto clientDto = new CustomerDto();\n        clientDto.setCustomerId(client.getCustomerId());\n        \/\/FIXME why one day in future payment is allowed\n        LocalDate paymentDate = new LocalDate().plusDays(1);\n        LocalDate receiptDate = new LocalDate().minusDays(3);\n        String receiptNumber = \"AA\/03\/UX-9Q\";\n        Assert.assertEquals(0, savingsBO.getAccountPayments().size());\n        AccountPaymentParametersDto depositPayment = new AccountPaymentParametersDto(new UserReferenceDto(savingsBO\n                .getPersonnel().getPersonnelId()), new AccountReferenceDto(savingsBO.getAccountId()), new BigDecimal(\n                deposit), paymentDate, defaultPaymentType, \"comment\", receiptDate, receiptNumber,\n                clientDto);\n        standardAccountService.makePayment(depositPayment);\n        TestObjectFactory.updateObject(savingsBO);\n        Assert.assertEquals(\"The amount returned for the payment should have been \" + deposit, Double\n                .parseDouble(deposit), savingsBO.getLastPmntAmnt());\n        Assert.assertEquals(1, savingsBO.getAccountPayments().size());\n        for (AccountPaymentEntity payment : savingsBO.getAccountPayments()) {\n            Assert.assertEquals(TestUtils.createMoney(deposit), payment.getAmount());\n            Assert.assertEquals(1, payment.getAccountTrxns().size());\n            Assert.assertEquals(paymentDate.toDateMidnight().toDate(), payment.getPaymentDate());\n            Assert.assertEquals(defaultPaymentType.getName(), payment.getPaymentType().getName());\n            Assert.assertEquals(\"comment\", payment.getComment());\n            Assert.assertEquals(savingsBO, payment.getAccount());\n            Assert.assertEquals(savingsBO.getPersonnel(), payment.getCreatedByUser());\n            Assert.assertEquals(receiptDate.toDateMidnight().toDate(), payment.getReceiptDate());\n            Assert.assertEquals(receiptNumber, payment.getReceiptNumber());\n            Assert.assertNull(payment.getCheckNumber());\n            Assert.assertNull(payment.getBankName());\n            Assert.assertNull(payment.getVoucherNumber());\n            Assert.assertTrue(payment.isSavingsDeposit());\n            Assert.assertFalse(payment.isSavingsWithdrawal());\n            Assert.assertTrue(payment.isSavingsDepositOrWithdrawal());\n            for (AccountTrxnEntity accountTrxn : payment.getAccountTrxns()) {\n                Assert.assertEquals(client.getCustomerId(), accountTrxn.getCustomer().getCustomerId());\n            }\n        }\n    }","code":"@Test\n    public void testMakePaymentForSavingsAccountOnDeposit() throws Exception {\n        savingsBO = createClientSavingsAccount();\n        String deposit = \"400\";\n        CustomerDto clientDto = new CustomerDto();\n        clientDto.setCustomerId(client.getCustomerId());\n       \n        LocalDate paymentDate = new LocalDate().plusDays(1);\n        LocalDate receiptDate = new LocalDate().minusDays(3);\n        String receiptNumber = \"AA\/03\/UX-9Q\";\n        Assert.assertEquals(0, savingsBO.getAccountPayments().size());\n        AccountPaymentParametersDto depositPayment = new AccountPaymentParametersDto(new UserReferenceDto(savingsBO\n                .getPersonnel().getPersonnelId()), new AccountReferenceDto(savingsBO.getAccountId()), new BigDecimal(\n                deposit), paymentDate, defaultPaymentType, \"comment\", receiptDate, receiptNumber,\n                clientDto);\n        standardAccountService.makePayment(depositPayment);\n        TestObjectFactory.updateObject(savingsBO);\n        Assert.assertEquals(\"The amount returned for the payment should have been \" + deposit, Double\n                .parseDouble(deposit), savingsBO.getLastPmntAmnt());\n        Assert.assertEquals(1, savingsBO.getAccountPayments().size());\n        for (AccountPaymentEntity payment : savingsBO.getAccountPayments()) {\n            Assert.assertEquals(TestUtils.createMoney(deposit), payment.getAmount());\n            Assert.assertEquals(1, payment.getAccountTrxns().size());\n            Assert.assertEquals(paymentDate.toDateMidnight().toDate(), payment.getPaymentDate());\n            Assert.assertEquals(defaultPaymentType.getName(), payment.getPaymentType().getName());\n            Assert.assertEquals(\"comment\", payment.getComment());\n            Assert.assertEquals(savingsBO, payment.getAccount());\n            Assert.assertEquals(savingsBO.getPersonnel(), payment.getCreatedByUser());\n            Assert.assertEquals(receiptDate.toDateMidnight().toDate(), payment.getReceiptDate());\n            Assert.assertEquals(receiptNumber, payment.getReceiptNumber());\n            Assert.assertNull(payment.getCheckNumber());\n            Assert.assertNull(payment.getBankName());\n            Assert.assertNull(payment.getVoucherNumber());\n            Assert.assertTrue(payment.isSavingsDeposit());\n            Assert.assertFalse(payment.isSavingsWithdrawal());\n            Assert.assertTrue(payment.isSavingsDepositOrWithdrawal());\n            for (AccountTrxnEntity accountTrxn : payment.getAccountTrxns()) {\n                Assert.assertEquals(client.getCustomerId(), accountTrxn.getCustomer().getCustomerId());\n            }\n        }\n    }","cleancode":"@test public void testmakepaymentforsavingsaccountondeposit() throws exception { savingsbo = createclientsavingsaccount(); string deposit = \"400\"; customerdto clientdto = new customerdto(); clientdto.setcustomerid(client.getcustomerid()); localdate paymentdate = new localdate().plusdays(1); localdate receiptdate = new localdate().minusdays(3); string receiptnumber = \"aa\/03\/ux-9q\"; assert.assertequals(0, savingsbo.getaccountpayments().size()); accountpaymentparametersdto depositpayment = new accountpaymentparametersdto(new userreferencedto(savingsbo .getpersonnel().getpersonnelid()), new accountreferencedto(savingsbo.getaccountid()), new bigdecimal( deposit), paymentdate, defaultpaymenttype, \"comment\", receiptdate, receiptnumber, clientdto); standardaccountservice.makepayment(depositpayment); testobjectfactory.updateobject(savingsbo); assert.assertequals(\"the amount returned for the payment should have been \" + deposit, double .parsedouble(deposit), savingsbo.getlastpmntamnt()); assert.assertequals(1, savingsbo.getaccountpayments().size()); for (accountpaymententity payment : savingsbo.getaccountpayments()) { assert.assertequals(testutils.createmoney(deposit), payment.getamount()); assert.assertequals(1, payment.getaccounttrxns().size()); assert.assertequals(paymentdate.todatemidnight().todate(), payment.getpaymentdate()); assert.assertequals(defaultpaymenttype.getname(), payment.getpaymenttype().getname()); assert.assertequals(\"comment\", payment.getcomment()); assert.assertequals(savingsbo, payment.getaccount()); assert.assertequals(savingsbo.getpersonnel(), payment.getcreatedbyuser()); assert.assertequals(receiptdate.todatemidnight().todate(), payment.getreceiptdate()); assert.assertequals(receiptnumber, payment.getreceiptnumber()); assert.assertnull(payment.getchecknumber()); assert.assertnull(payment.getbankname()); assert.assertnull(payment.getvouchernumber()); assert.asserttrue(payment.issavingsdeposit()); assert.assertfalse(payment.issavingswithdrawal()); assert.asserttrue(payment.issavingsdepositorwithdrawal()); for (accounttrxnentity accounttrxn : payment.getaccounttrxns()) { assert.assertequals(client.getcustomerid(), accounttrxn.getcustomer().getcustomerid()); } } }","comment":"\/\/fixme why one day in future payment is allowed","repo":"sureshkrishnamoorthy\/suresh-mifos","code_context_2":"CustomerDto clientDto = new CustomerDto();\nclientDto.setCustomerId(client.getCustomerId());\n\/\/FIXME why one day in future payment is allowed\nLocalDate paymentDate = new LocalDate().plusDays(1);\nLocalDate receiptDate = new LocalDate().minusDays(3);","code_context_10":"@Test\npublic void testMakePaymentForSavingsAccountOnDeposit() throws Exception {\nsavingsBO = createClientSavingsAccount();\nString deposit = \"400\";\nCustomerDto clientDto = new CustomerDto();\nclientDto.setCustomerId(client.getCustomerId());\n\/\/FIXME why one day in future payment is allowed\nLocalDate paymentDate = new LocalDate().plusDays(1);\nLocalDate receiptDate = new LocalDate().minusDays(3);\nString receiptNumber = \"AA\/03\/UX-9Q\";\nAssert.assertEquals(0, savingsBO.getAccountPayments().size());\nAccountPaymentParametersDto depositPayment = new AccountPaymentParametersDto(new UserReferenceDto(savingsBO\n.getPersonnel().getPersonnelId()), new AccountReferenceDto(savingsBO.getAccountId()), new BigDecimal(\ndeposit), paymentDate, defaultPaymentType, \"comment\", receiptDate, receiptNumber,\nclientDto);\nstandardAccountService.makePayment(depositPayment);\nTestObjectFactory.updateObject(savingsBO);","code_context_20":"@Test\npublic void testMakePaymentForSavingsAccountOnDeposit() throws Exception {\nsavingsBO = createClientSavingsAccount();\nString deposit = \"400\";\nCustomerDto clientDto = new CustomerDto();\nclientDto.setCustomerId(client.getCustomerId());\n\/\/FIXME why one day in future payment is allowed\nLocalDate paymentDate = new LocalDate().plusDays(1);\nLocalDate receiptDate = new LocalDate().minusDays(3);\nString receiptNumber = \"AA\/03\/UX-9Q\";\nAssert.assertEquals(0, savingsBO.getAccountPayments().size());\nAccountPaymentParametersDto depositPayment = new AccountPaymentParametersDto(new UserReferenceDto(savingsBO\n.getPersonnel().getPersonnelId()), new AccountReferenceDto(savingsBO.getAccountId()), new BigDecimal(\ndeposit), paymentDate, defaultPaymentType, \"comment\", receiptDate, receiptNumber,\nclientDto);\nstandardAccountService.makePayment(depositPayment);\nTestObjectFactory.updateObject(savingsBO);\nAssert.assertEquals(\"The amount returned for the payment should have been \" + deposit, Double\n.parseDouble(deposit), savingsBO.getLastPmntAmnt());\nAssert.assertEquals(1, savingsBO.getAccountPayments().size());\nfor (AccountPaymentEntity payment : savingsBO.getAccountPayments()) {\nAssert.assertEquals(TestUtils.createMoney(deposit), payment.getAmount());\nAssert.assertEquals(1, payment.getAccountTrxns().size());\nAssert.assertEquals(paymentDate.toDateMidnight().toDate(), payment.getPaymentDate());\nAssert.assertEquals(defaultPaymentType.getName(), payment.getPaymentType().getName());\nAssert.assertEquals(\"comment\", payment.getComment());\nAssert.assertEquals(savingsBO, payment.getAccount());","label":[1,0,0,0]}
{"id":32149,"original_code":"public static int raiseTo(int n, int p) {\n    if (n == 0) {\n      return 0;\n    }\n    if (p == 0) {\n      return 1;\n    }\n    if (n == 1) {\n      return n;\n    }\n    long result = n;\n    int counter = 1;\n    while (counter < p) {\n      if (result * n >= Integer.MAX_VALUE) {\n        return Integer.MAX_VALUE;\n      }\n      result *= n;\n      counter++;\n    }\n    return (int) result;\n  }","code":"public static int raiseTo(int n, int p) {\n    if (n == 0) {\n      return 0;\n    }\n    if (p == 0) {\n      return 1;\n    }\n    if (n == 1) {\n      return n;\n    }\n    long result = n;\n    int counter = 1;\n    while (counter < p) {\n      if (result * n >= Integer.MAX_VALUE) {\n        return Integer.MAX_VALUE;\n      }\n      result *= n;\n      counter++;\n    }\n    return (int) result;\n  }","cleancode":"public static int raiseto(int n, int p) { if (n == 0) { return 0; } if (p == 0) { return 1; } if (n == 1) { return n; } long result = n; int counter = 1; while (counter < p) { if (result * n >= integer.max_value) { return integer.max_value; } result *= n; counter++; } return (int) result; }","comment":"\/\/todo: this can be improved further to handle large powers","repo":"sachinlala\/JavaPerfTests","code_context_2":"public static int raiseTo(int n, int p) {\nif (n == 0) {\nreturn 0;\n}\nif (p == 0) {\nreturn 1;\n}\nif (n == 1) {\nreturn n;\n}\nlong result = n;\nint counter = 1;\nwhile (counter < p) {\nif (result * n >= Integer.MAX_VALUE) {\nreturn Integer.MAX_VALUE;\n}\nresult *= n;\ncounter++;\n}\nreturn (int) result;\n}","code_context_10":"public static int raiseTo(int n, int p) {\nif (n == 0) {\nreturn 0;\n}\nif (p == 0) {\nreturn 1;\n}\nif (n == 1) {\nreturn n;\n}\nlong result = n;\nint counter = 1;\nwhile (counter < p) {\nif (result * n >= Integer.MAX_VALUE) {\nreturn Integer.MAX_VALUE;\n}\nresult *= n;\ncounter++;\n}\nreturn (int) result;\n}","code_context_20":"public static int raiseTo(int n, int p) {\nif (n == 0) {\nreturn 0;\n}\nif (p == 0) {\nreturn 1;\n}\nif (n == 1) {\nreturn n;\n}\nlong result = n;\nint counter = 1;\nwhile (counter < p) {\nif (result * n >= Integer.MAX_VALUE) {\nreturn Integer.MAX_VALUE;\n}\nresult *= n;\ncounter++;\n}\nreturn (int) result;\n}","label":[1,0,0,0]}
{"id":24068,"original_code":"public static String assignShard(DocCollection collection, Integer numShards) {\n    if (numShards == null) {\n      numShards = 1;\n    }\n    String returnShardId = null;\n    Map<String, Slice> sliceMap = collection != null ? collection.getActiveSlicesMap() : null;\n    \/\/ TODO: now that we create shards ahead of time, is this code needed?  Esp since hash ranges aren't assigned when creating via this method?\n    if (sliceMap == null) {\n      return \"shard1\";\n    }\n    List<String> shardIdNames = new ArrayList<>(sliceMap.keySet());\n    if (shardIdNames.size() < numShards) {\n      return \"shard\" + (shardIdNames.size() + 1);\n    }\n    \/\/ TODO: don't need to sort to find shard with fewest replicas!\n    \/\/ else figure out which shard needs more replicas\n    final Map<String, Integer> map = new HashMap<>();\n    for (String shardId : shardIdNames) {\n      int cnt = sliceMap.get(shardId).getReplicasMap().size();\n      map.put(shardId, cnt);\n    }\n    Collections.sort(shardIdNames, (String o1, String o2) -> {\n      Integer one = map.get(o1);\n      Integer two = map.get(o2);\n      return one.compareTo(two);\n    });\n    returnShardId = shardIdNames.get(0);\n    return returnShardId;\n  }","code":"public static String assignShard(DocCollection collection, Integer numShards) {\n    if (numShards == null) {\n      numShards = 1;\n    }\n    String returnShardId = null;\n    Map<String, Slice> sliceMap = collection != null ? collection.getActiveSlicesMap() : null;\n   \n    if (sliceMap == null) {\n      return \"shard1\";\n    }\n    List<String> shardIdNames = new ArrayList<>(sliceMap.keySet());\n    if (shardIdNames.size() < numShards) {\n      return \"shard\" + (shardIdNames.size() + 1);\n    }\n   \n   \n    final Map<String, Integer> map = new HashMap<>();\n    for (String shardId : shardIdNames) {\n      int cnt = sliceMap.get(shardId).getReplicasMap().size();\n      map.put(shardId, cnt);\n    }\n    Collections.sort(shardIdNames, (String o1, String o2) -> {\n      Integer one = map.get(o1);\n      Integer two = map.get(o2);\n      return one.compareTo(two);\n    });\n    returnShardId = shardIdNames.get(0);\n    return returnShardId;\n  }","cleancode":"public static string assignshard(doccollection collection, integer numshards) { if (numshards == null) { numshards = 1; } string returnshardid = null; map<string, slice> slicemap = collection != null ? collection.getactiveslicesmap() : null; if (slicemap == null) { return \"shard1\"; } list<string> shardidnames = new arraylist<>(slicemap.keyset()); if (shardidnames.size() < numshards) { return \"shard\" + (shardidnames.size() + 1); } final map<string, integer> map = new hashmap<>(); for (string shardid : shardidnames) { int cnt = slicemap.get(shardid).getreplicasmap().size(); map.put(shardid, cnt); } collections.sort(shardidnames, (string o1, string o2) -> { integer one = map.get(o1); integer two = map.get(o2); return one.compareto(two); }); returnshardid = shardidnames.get(0); return returnshardid; }","comment":"\/** * assign a new unique id up to slices count - then add replicas evenly. * * @return the assigned shard id *\/\n\/\/ todo: now that we create shards ahead of time, is this code needed? esp since hash ranges aren't assigned when creating via this method?\n\/\/ todo: don't need to sort to find shard with fewest replicas! \/\/ else figure out which shard needs more replicas","repo":"robin850\/solr","code_context_2":"public static String assignShard(DocCollection collection, Integer numShards) {\nif (numShards == null) {\nnumShards = 1;\n}\nString returnShardId = null;\nMap<String, Slice> sliceMap = collection != null ? collection.getActiveSlicesMap() : null;\n\/\/ TODO: now that we create shards ahead of time, is this code needed? Esp since hash ranges aren't assigned when creating via this method?\nif (sliceMap == null) {\nreturn \"shard1\";\n}\nList<String> shardIdNames = new ArrayList<>(sliceMap.keySet());\nif (shardIdNames.size() < numShards) {\nreturn \"shard\" + (shardIdNames.size() + 1);\n}\n\/\/ TODO: don't need to sort to find shard with fewest replicas!\n\/\/ else figure out which shard needs more replicas\nfinal Map<String, Integer> map = new HashMap<>();\nfor (String shardId : shardIdNames) {\nint cnt = sliceMap.get(shardId).getReplicasMap().size();\nmap.put(shardId, cnt);\n}\nCollections.sort(shardIdNames, (String o1, String o2) -> {\nInteger one = map.get(o1);\nInteger two = map.get(o2);\nreturn one.compareTo(two);\n});\nreturnShardId = shardIdNames.get(0);\nreturn returnShardId;\n}\n\nString returnShardId = null;\nMap<String, Slice> sliceMap = collection != null ? collection.getActiveSlicesMap() : null;\n\/\/ TODO: now that we create shards ahead of time, is this code needed? Esp since hash ranges aren't assigned when creating via this method?\nif (sliceMap == null) {\nreturn \"shard1\";\n\nreturn \"shard\" + (shardIdNames.size() + 1);\n}\n\/\/ TODO: don't need to sort to find shard with fewest replicas!\n\/\/ else figure out which shard needs more replicas\nfinal Map<String, Integer> map = new HashMap<>();\nfor (String shardId : shardIdNames) {","code_context_10":"public static String assignShard(DocCollection collection, Integer numShards) {\nif (numShards == null) {\nnumShards = 1;\n}\nString returnShardId = null;\nMap<String, Slice> sliceMap = collection != null ? collection.getActiveSlicesMap() : null;\n\/\/ TODO: now that we create shards ahead of time, is this code needed? Esp since hash ranges aren't assigned when creating via this method?\nif (sliceMap == null) {\nreturn \"shard1\";\n}\nList<String> shardIdNames = new ArrayList<>(sliceMap.keySet());\nif (shardIdNames.size() < numShards) {\nreturn \"shard\" + (shardIdNames.size() + 1);\n}\n\/\/ TODO: don't need to sort to find shard with fewest replicas!\n\/\/ else figure out which shard needs more replicas\nfinal Map<String, Integer> map = new HashMap<>();\nfor (String shardId : shardIdNames) {\nint cnt = sliceMap.get(shardId).getReplicasMap().size();\nmap.put(shardId, cnt);\n}\nCollections.sort(shardIdNames, (String o1, String o2) -> {\nInteger one = map.get(o1);\nInteger two = map.get(o2);\nreturn one.compareTo(two);\n});\nreturnShardId = shardIdNames.get(0);\nreturn returnShardId;\n}\n\npublic static String assignShard(DocCollection collection, Integer numShards) {\nif (numShards == null) {\nnumShards = 1;\n}\nString returnShardId = null;\nMap<String, Slice> sliceMap = collection != null ? collection.getActiveSlicesMap() : null;\n\/\/ TODO: now that we create shards ahead of time, is this code needed? Esp since hash ranges aren't assigned when creating via this method?\nif (sliceMap == null) {\nreturn \"shard1\";\n}\nList<String> shardIdNames = new ArrayList<>(sliceMap.keySet());\nif (shardIdNames.size() < numShards) {\nreturn \"shard\" + (shardIdNames.size() + 1);\n}\n\/\/ TODO: don't need to sort to find shard with fewest replicas!\n\/\/ else figure out which shard needs more replicas\nfinal Map<String, Integer> map = new HashMap<>();\n\nString returnShardId = null;\nMap<String, Slice> sliceMap = collection != null ? collection.getActiveSlicesMap() : null;\n\/\/ TODO: now that we create shards ahead of time, is this code needed? Esp since hash ranges aren't assigned when creating via this method?\nif (sliceMap == null) {\nreturn \"shard1\";\n}\nList<String> shardIdNames = new ArrayList<>(sliceMap.keySet());\nif (shardIdNames.size() < numShards) {\nreturn \"shard\" + (shardIdNames.size() + 1);\n}\n\/\/ TODO: don't need to sort to find shard with fewest replicas!\n\/\/ else figure out which shard needs more replicas\nfinal Map<String, Integer> map = new HashMap<>();\nfor (String shardId : shardIdNames) {\nint cnt = sliceMap.get(shardId).getReplicasMap().size();\nmap.put(shardId, cnt);\n}\nCollections.sort(shardIdNames, (String o1, String o2) -> {\nInteger one = map.get(o1);\nInteger two = map.get(o2);\nreturn one.compareTo(two);\n});","code_context_20":"public static String assignShard(DocCollection collection, Integer numShards) {\nif (numShards == null) {\nnumShards = 1;\n}\nString returnShardId = null;\nMap<String, Slice> sliceMap = collection != null ? collection.getActiveSlicesMap() : null;\n\/\/ TODO: now that we create shards ahead of time, is this code needed? Esp since hash ranges aren't assigned when creating via this method?\nif (sliceMap == null) {\nreturn \"shard1\";\n}\nList<String> shardIdNames = new ArrayList<>(sliceMap.keySet());\nif (shardIdNames.size() < numShards) {\nreturn \"shard\" + (shardIdNames.size() + 1);\n}\n\/\/ TODO: don't need to sort to find shard with fewest replicas!\n\/\/ else figure out which shard needs more replicas\nfinal Map<String, Integer> map = new HashMap<>();\nfor (String shardId : shardIdNames) {\nint cnt = sliceMap.get(shardId).getReplicasMap().size();\nmap.put(shardId, cnt);\n}\nCollections.sort(shardIdNames, (String o1, String o2) -> {\nInteger one = map.get(o1);\nInteger two = map.get(o2);\nreturn one.compareTo(two);\n});\nreturnShardId = shardIdNames.get(0);\nreturn returnShardId;\n}\n\npublic static String assignShard(DocCollection collection, Integer numShards) {\nif (numShards == null) {\nnumShards = 1;\n}\nString returnShardId = null;\nMap<String, Slice> sliceMap = collection != null ? collection.getActiveSlicesMap() : null;\n\/\/ TODO: now that we create shards ahead of time, is this code needed? Esp since hash ranges aren't assigned when creating via this method?\nif (sliceMap == null) {\nreturn \"shard1\";\n}\nList<String> shardIdNames = new ArrayList<>(sliceMap.keySet());\nif (shardIdNames.size() < numShards) {\nreturn \"shard\" + (shardIdNames.size() + 1);\n}\n\/\/ TODO: don't need to sort to find shard with fewest replicas!\n\/\/ else figure out which shard needs more replicas\nfinal Map<String, Integer> map = new HashMap<>();\nfor (String shardId : shardIdNames) {\nint cnt = sliceMap.get(shardId).getReplicasMap().size();\nmap.put(shardId, cnt);\n}\nCollections.sort(shardIdNames, (String o1, String o2) -> {\nInteger one = map.get(o1);\nInteger two = map.get(o2);\nreturn one.compareTo(two);\n});\nreturnShardId = shardIdNames.get(0);\n\npublic static String assignShard(DocCollection collection, Integer numShards) {\nif (numShards == null) {\nnumShards = 1;\n}\nString returnShardId = null;\nMap<String, Slice> sliceMap = collection != null ? collection.getActiveSlicesMap() : null;\n\/\/ TODO: now that we create shards ahead of time, is this code needed? Esp since hash ranges aren't assigned when creating via this method?\nif (sliceMap == null) {\nreturn \"shard1\";\n}\nList<String> shardIdNames = new ArrayList<>(sliceMap.keySet());\nif (shardIdNames.size() < numShards) {\nreturn \"shard\" + (shardIdNames.size() + 1);\n}\n\/\/ TODO: don't need to sort to find shard with fewest replicas!\n\/\/ else figure out which shard needs more replicas\nfinal Map<String, Integer> map = new HashMap<>();\nfor (String shardId : shardIdNames) {\nint cnt = sliceMap.get(shardId).getReplicasMap().size();\nmap.put(shardId, cnt);\n}\nCollections.sort(shardIdNames, (String o1, String o2) -> {\nInteger one = map.get(o1);\nInteger two = map.get(o2);\nreturn one.compareTo(two);\n});\nreturnShardId = shardIdNames.get(0);\nreturn returnShardId;\n}","label":[1,0,0,0]}
{"id":24102,"original_code":"@Test\n    @MediumTest\n    public void testAppButtonExitsVoiceInput() throws InterruptedException {\n        Runnable exitAction = () -> {\n            NativeUiUtils.clickAppButton(UserFriendlyElementName.CURRENT_POSITION, new PointF());\n        };\n        testExitVoiceInputImpl(exitAction);\n    }","code":"@Test\n    @MediumTest\n    public void testAppButtonExitsVoiceInput() throws InterruptedException {\n        Runnable exitAction = () -> {\n            NativeUiUtils.clickAppButton(UserFriendlyElementName.CURRENT_POSITION, new PointF());\n        };\n        testExitVoiceInputImpl(exitAction);\n    }","cleancode":"@test @mediumtest public void testappbuttonexitsvoiceinput() throws interruptedexception { runnable exitaction = () -> { nativeuiutils.clickappbutton(userfriendlyelementname.current_position, new pointf()); }; testexitvoiceinputimpl(exitaction); }","comment":"\/** * tests that pressing the app button on the daydream controller exists voice input mode. this * would fit better in vrbrowsercontrollerinputtest, but having it here allows code reuse. *\/","repo":"sarang-apps\/darshan_browser","code_context_2":"@Test\n@MediumTest\npublic void testAppButtonExitsVoiceInput() throws InterruptedException {\nRunnable exitAction = () -> {\nNativeUiUtils.clickAppButton(UserFriendlyElementName.CURRENT_POSITION, new PointF());\n};\ntestExitVoiceInputImpl(exitAction);\n}","code_context_10":"@Test\n@MediumTest\npublic void testAppButtonExitsVoiceInput() throws InterruptedException {\nRunnable exitAction = () -> {\nNativeUiUtils.clickAppButton(UserFriendlyElementName.CURRENT_POSITION, new PointF());\n};\ntestExitVoiceInputImpl(exitAction);\n}","code_context_20":"@Test\n@MediumTest\npublic void testAppButtonExitsVoiceInput() throws InterruptedException {\nRunnable exitAction = () -> {\nNativeUiUtils.clickAppButton(UserFriendlyElementName.CURRENT_POSITION, new PointF());\n};\ntestExitVoiceInputImpl(exitAction);\n}","label":[0,0,0,1]}
{"id":15921,"original_code":"public static Map<String, List<Object>> parseAttributes(String samlResponse,\n      Set<String> attributes) throws ServletException {\n    Map<String, List<Object>> parsedResult = new HashMap<>();\n    \/\/ TODO - Using a library for managing collections\n    if (attributes == null || attributes.isEmpty()) {\n      return parsedResult;\n    }\n    byte[] samlAssertionDecoded = new byte[0];\n    try {\n      samlAssertionDecoded = Base64.decodeBase64(samlResponse.getBytes(\"UTF-8\"));\n    } catch (UnsupportedEncodingException e) {\n      throw new RuntimeException(\"Unsupported encoding to decode Saml Response\");\n    }\n    ByteArrayInputStream is = new ByteArrayInputStream(samlAssertionDecoded);\n    Assertion assertion;\n    try {\n      DocumentBuilder builder = factory.newDocumentBuilder();\n      Document document = builder.parse(is);\n      Element element = document.getDocumentElement();\n      Unmarshaller unmarshaller = unmarshallerFactory.getUnmarshaller(element);\n      if (unmarshaller == null) {\n        throw new RuntimeException(\"Could not find an unmarshaller for XML parsing\");\n      }\n      XMLObject responseXmlObj = unmarshaller.unmarshall(element);\n      Response response = (Response) responseXmlObj;\n      if (response.getAssertions() == null || response.getAssertions().isEmpty()) {\n        throw new ServletException(\"No assertions found in SAML response\");\n      }\n      assertion = response.getAssertions().get(0);\n    } catch (UnmarshallingException | ParserConfigurationException | SAXException | IOException e) {\n      throw new ServletException(\"Could not parse the SAML assertion\", e);\n    }\n    for (AttributeStatement attributeStatement : assertion.getAttributeStatements()) {\n      for (Attribute attribute : attributeStatement.getAttributes()) {\n        if (attributes.contains(attribute.getName())) {\n          List<Object> values = new ArrayList<>(attribute.getAttributeValues());\n          parsedResult.put(attribute.getName(), values);\n        }\n      }\n    }\n    return parsedResult;\n  }","code":"public static Map<String, List<Object>> parseAttributes(String samlResponse,\n      Set<String> attributes) throws ServletException {\n    Map<String, List<Object>> parsedResult = new HashMap<>();\n   \n    if (attributes == null || attributes.isEmpty()) {\n      return parsedResult;\n    }\n    byte[] samlAssertionDecoded = new byte[0];\n    try {\n      samlAssertionDecoded = Base64.decodeBase64(samlResponse.getBytes(\"UTF-8\"));\n    } catch (UnsupportedEncodingException e) {\n      throw new RuntimeException(\"Unsupported encoding to decode Saml Response\");\n    }\n    ByteArrayInputStream is = new ByteArrayInputStream(samlAssertionDecoded);\n    Assertion assertion;\n    try {\n      DocumentBuilder builder = factory.newDocumentBuilder();\n      Document document = builder.parse(is);\n      Element element = document.getDocumentElement();\n      Unmarshaller unmarshaller = unmarshallerFactory.getUnmarshaller(element);\n      if (unmarshaller == null) {\n        throw new RuntimeException(\"Could not find an unmarshaller for XML parsing\");\n      }\n      XMLObject responseXmlObj = unmarshaller.unmarshall(element);\n      Response response = (Response) responseXmlObj;\n      if (response.getAssertions() == null || response.getAssertions().isEmpty()) {\n        throw new ServletException(\"No assertions found in SAML response\");\n      }\n      assertion = response.getAssertions().get(0);\n    } catch (UnmarshallingException | ParserConfigurationException | SAXException | IOException e) {\n      throw new ServletException(\"Could not parse the SAML assertion\", e);\n    }\n    for (AttributeStatement attributeStatement : assertion.getAttributeStatements()) {\n      for (Attribute attribute : attributeStatement.getAttributes()) {\n        if (attributes.contains(attribute.getName())) {\n          List<Object> values = new ArrayList<>(attribute.getAttributeValues());\n          parsedResult.put(attribute.getName(), values);\n        }\n      }\n    }\n    return parsedResult;\n  }","cleancode":"public static map<string, list<object>> parseattributes(string samlresponse, set<string> attributes) throws servletexception { map<string, list<object>> parsedresult = new hashmap<>(); if (attributes == null || attributes.isempty()) { return parsedresult; } byte[] samlassertiondecoded = new byte[0]; try { samlassertiondecoded = base64.decodebase64(samlresponse.getbytes(\"utf-8\")); } catch (unsupportedencodingexception e) { throw new runtimeexception(\"unsupported encoding to decode saml response\"); } bytearrayinputstream is = new bytearrayinputstream(samlassertiondecoded); assertion assertion; try { documentbuilder builder = factory.newdocumentbuilder(); document document = builder.parse(is); element element = document.getdocumentelement(); unmarshaller unmarshaller = unmarshallerfactory.getunmarshaller(element); if (unmarshaller == null) { throw new runtimeexception(\"could not find an unmarshaller for xml parsing\"); } xmlobject responsexmlobj = unmarshaller.unmarshall(element); response response = (response) responsexmlobj; if (response.getassertions() == null || response.getassertions().isempty()) { throw new servletexception(\"no assertions found in saml response\"); } assertion = response.getassertions().get(0); } catch (unmarshallingexception | parserconfigurationexception | saxexception | ioexception e) { throw new servletexception(\"could not parse the saml assertion\", e); } for (attributestatement attributestatement : assertion.getattributestatements()) { for (attribute attribute : attributestatement.getattributes()) { if (attributes.contains(attribute.getname())) { list<object> values = new arraylist<>(attribute.getattributevalues()); parsedresult.put(attribute.getname(), values); } } } return parsedresult; }","comment":"\/** * parses a saml response for attributes. * * @param samlresponse the saml response sent by identity provider * @param attributes the attributes to fetch from assertion * @return {@link map} containing the mapped keys in {@code attributes} with a {@link list} of * values found for the attribute * @throws servletexception if the parsing fails for the {@code samlresponse} *\/\n\/\/ todo - using a library for managing collections","repo":"sharad-oss\/knox","code_context_2":"public static Map<String, List<Object>> parseAttributes(String samlResponse,\nSet<String> attributes) throws ServletException {\nMap<String, List<Object>> parsedResult = new HashMap<>();\n\/\/ TODO - Using a library for managing collections\nif (attributes == null || attributes.isEmpty()) {\nreturn parsedResult;\n}\nbyte[] samlAssertionDecoded = new byte[0];\ntry {\nsamlAssertionDecoded = Base64.decodeBase64(samlResponse.getBytes(\"UTF-8\"));\n} catch (UnsupportedEncodingException e) {\nthrow new RuntimeException(\"Unsupported encoding to decode Saml Response\");\n}\nByteArrayInputStream is = new ByteArrayInputStream(samlAssertionDecoded);\nAssertion assertion;\ntry {\nDocumentBuilder builder = factory.newDocumentBuilder();\nDocument document = builder.parse(is);\nElement element = document.getDocumentElement();\nUnmarshaller unmarshaller = unmarshallerFactory.getUnmarshaller(element);\nif (unmarshaller == null) {\nthrow new RuntimeException(\"Could not find an unmarshaller for XML parsing\");\n}\nXMLObject responseXmlObj = unmarshaller.unmarshall(element);\nResponse response = (Response) responseXmlObj;\nif (response.getAssertions() == null || response.getAssertions().isEmpty()) {\nthrow new ServletException(\"No assertions found in SAML response\");\n}\nassertion = response.getAssertions().get(0);\n} catch (UnmarshallingException | ParserConfigurationException | SAXException | IOException e) {\nthrow new ServletException(\"Could not parse the SAML assertion\", e);\n}\nfor (AttributeStatement attributeStatement : assertion.getAttributeStatements()) {\nfor (Attribute attribute : attributeStatement.getAttributes()) {\nif (attributes.contains(attribute.getName())) {\nList<Object> values = new ArrayList<>(attribute.getAttributeValues());\nparsedResult.put(attribute.getName(), values);\n}\n}\n}\nreturn parsedResult;\n}\n\nSet<String> attributes) throws ServletException {\nMap<String, List<Object>> parsedResult = new HashMap<>();\n\/\/ TODO - Using a library for managing collections\nif (attributes == null || attributes.isEmpty()) {\nreturn parsedResult;","code_context_10":"public static Map<String, List<Object>> parseAttributes(String samlResponse,\nSet<String> attributes) throws ServletException {\nMap<String, List<Object>> parsedResult = new HashMap<>();\n\/\/ TODO - Using a library for managing collections\nif (attributes == null || attributes.isEmpty()) {\nreturn parsedResult;\n}\nbyte[] samlAssertionDecoded = new byte[0];\ntry {\nsamlAssertionDecoded = Base64.decodeBase64(samlResponse.getBytes(\"UTF-8\"));\n} catch (UnsupportedEncodingException e) {\nthrow new RuntimeException(\"Unsupported encoding to decode Saml Response\");\n}\nByteArrayInputStream is = new ByteArrayInputStream(samlAssertionDecoded);\nAssertion assertion;\ntry {\nDocumentBuilder builder = factory.newDocumentBuilder();\nDocument document = builder.parse(is);\nElement element = document.getDocumentElement();\nUnmarshaller unmarshaller = unmarshallerFactory.getUnmarshaller(element);\nif (unmarshaller == null) {\nthrow new RuntimeException(\"Could not find an unmarshaller for XML parsing\");\n}\nXMLObject responseXmlObj = unmarshaller.unmarshall(element);\nResponse response = (Response) responseXmlObj;\nif (response.getAssertions() == null || response.getAssertions().isEmpty()) {\nthrow new ServletException(\"No assertions found in SAML response\");\n}\nassertion = response.getAssertions().get(0);\n} catch (UnmarshallingException | ParserConfigurationException | SAXException | IOException e) {\nthrow new ServletException(\"Could not parse the SAML assertion\", e);\n}\nfor (AttributeStatement attributeStatement : assertion.getAttributeStatements()) {\nfor (Attribute attribute : attributeStatement.getAttributes()) {\nif (attributes.contains(attribute.getName())) {\nList<Object> values = new ArrayList<>(attribute.getAttributeValues());\nparsedResult.put(attribute.getName(), values);\n}\n}\n}\nreturn parsedResult;\n}\n\npublic static Map<String, List<Object>> parseAttributes(String samlResponse,\nSet<String> attributes) throws ServletException {\nMap<String, List<Object>> parsedResult = new HashMap<>();\n\/\/ TODO - Using a library for managing collections\nif (attributes == null || attributes.isEmpty()) {\nreturn parsedResult;\n}\nbyte[] samlAssertionDecoded = new byte[0];\ntry {\nsamlAssertionDecoded = Base64.decodeBase64(samlResponse.getBytes(\"UTF-8\"));\n} catch (UnsupportedEncodingException e) {\nthrow new RuntimeException(\"Unsupported encoding to decode Saml Response\");\n}\nByteArrayInputStream is = new ByteArrayInputStream(samlAssertionDecoded);","code_context_20":"public static Map<String, List<Object>> parseAttributes(String samlResponse,\nSet<String> attributes) throws ServletException {\nMap<String, List<Object>> parsedResult = new HashMap<>();\n\/\/ TODO - Using a library for managing collections\nif (attributes == null || attributes.isEmpty()) {\nreturn parsedResult;\n}\nbyte[] samlAssertionDecoded = new byte[0];\ntry {\nsamlAssertionDecoded = Base64.decodeBase64(samlResponse.getBytes(\"UTF-8\"));\n} catch (UnsupportedEncodingException e) {\nthrow new RuntimeException(\"Unsupported encoding to decode Saml Response\");\n}\nByteArrayInputStream is = new ByteArrayInputStream(samlAssertionDecoded);\nAssertion assertion;\ntry {\nDocumentBuilder builder = factory.newDocumentBuilder();\nDocument document = builder.parse(is);\nElement element = document.getDocumentElement();\nUnmarshaller unmarshaller = unmarshallerFactory.getUnmarshaller(element);\nif (unmarshaller == null) {\nthrow new RuntimeException(\"Could not find an unmarshaller for XML parsing\");\n}\nXMLObject responseXmlObj = unmarshaller.unmarshall(element);\nResponse response = (Response) responseXmlObj;\nif (response.getAssertions() == null || response.getAssertions().isEmpty()) {\nthrow new ServletException(\"No assertions found in SAML response\");\n}\nassertion = response.getAssertions().get(0);\n} catch (UnmarshallingException | ParserConfigurationException | SAXException | IOException e) {\nthrow new ServletException(\"Could not parse the SAML assertion\", e);\n}\nfor (AttributeStatement attributeStatement : assertion.getAttributeStatements()) {\nfor (Attribute attribute : attributeStatement.getAttributes()) {\nif (attributes.contains(attribute.getName())) {\nList<Object> values = new ArrayList<>(attribute.getAttributeValues());\nparsedResult.put(attribute.getName(), values);\n}\n}\n}\nreturn parsedResult;\n}\n\npublic static Map<String, List<Object>> parseAttributes(String samlResponse,\nSet<String> attributes) throws ServletException {\nMap<String, List<Object>> parsedResult = new HashMap<>();\n\/\/ TODO - Using a library for managing collections\nif (attributes == null || attributes.isEmpty()) {\nreturn parsedResult;\n}\nbyte[] samlAssertionDecoded = new byte[0];\ntry {\nsamlAssertionDecoded = Base64.decodeBase64(samlResponse.getBytes(\"UTF-8\"));\n} catch (UnsupportedEncodingException e) {\nthrow new RuntimeException(\"Unsupported encoding to decode Saml Response\");\n}\nByteArrayInputStream is = new ByteArrayInputStream(samlAssertionDecoded);\nAssertion assertion;\ntry {\nDocumentBuilder builder = factory.newDocumentBuilder();\nDocument document = builder.parse(is);\nElement element = document.getDocumentElement();\nUnmarshaller unmarshaller = unmarshallerFactory.getUnmarshaller(element);\nif (unmarshaller == null) {\nthrow new RuntimeException(\"Could not find an unmarshaller for XML parsing\");\n}\nXMLObject responseXmlObj = unmarshaller.unmarshall(element);","label":[0,1,0,0]}
{"id":16008,"original_code":"@Override\n\tpublic void makeMove() {\n\t\t\/\/ TODO Not just randomly select a tile to mark\n\t\twhile (true) {\n\t\t\ttry {\n\t\t\t\tList<Tile> tiles = getGameLogic().getTerritory().getTiles();\n\t\t\t\tTile tile = tiles.get(GameLogic.RANDOM.nextInt(tiles.size()));\n\t\t\t\ttile.setMarkedPlayer(this);\n\t\t\t\tgetGameLogic().endMove();\n\t\t\t\treturn;\n\t\t\t} catch (TileAreadyMarkedException e) {\n\t\t\t}\n\t\t}\n\t}","code":"@Override\n\tpublic void makeMove() {\n\t\n\t\twhile (true) {\n\t\t\ttry {\n\t\t\t\tList<Tile> tiles = getGameLogic().getTerritory().getTiles();\n\t\t\t\tTile tile = tiles.get(GameLogic.RANDOM.nextInt(tiles.size()));\n\t\t\t\ttile.setMarkedPlayer(this);\n\t\t\t\tgetGameLogic().endMove();\n\t\t\t\treturn;\n\t\t\t} catch (TileAreadyMarkedException e) {\n\t\t\t}\n\t\t}\n\t}","cleancode":"@override public void makemove() { while (true) { try { list<tile> tiles = getgamelogic().getterritory().gettiles(); tile tile = tiles.get(gamelogic.random.nextint(tiles.size())); tile.setmarkedplayer(this); getgamelogic().endmove(); return; } catch (tileareadymarkedexception e) { } } }","comment":"\/** * lets the ai player make an automated move. * * here, the ai player calculates a fitting next field which he then marks * trying to win the tic tac toe game. *\/\n\/\/ todo not just randomly select a tile to mark","repo":"sengerts\/tic-tac-toe","code_context_2":"@Override\npublic void makeMove() {\n\/\/ TODO Not just randomly select a tile to mark\nwhile (true) {\ntry {\nList<Tile> tiles = getGameLogic().getTerritory().getTiles();\nTile tile = tiles.get(GameLogic.RANDOM.nextInt(tiles.size()));\ntile.setMarkedPlayer(this);\ngetGameLogic().endMove();\nreturn;\n} catch (TileAreadyMarkedException e) {\n}\n}\n}\n\n@Override\npublic void makeMove() {\n\/\/ TODO Not just randomly select a tile to mark\nwhile (true) {\ntry {","code_context_10":"@Override\npublic void makeMove() {\n\/\/ TODO Not just randomly select a tile to mark\nwhile (true) {\ntry {\nList<Tile> tiles = getGameLogic().getTerritory().getTiles();\nTile tile = tiles.get(GameLogic.RANDOM.nextInt(tiles.size()));\ntile.setMarkedPlayer(this);\ngetGameLogic().endMove();\nreturn;\n} catch (TileAreadyMarkedException e) {\n}\n}\n}\n\n@Override\npublic void makeMove() {\n\/\/ TODO Not just randomly select a tile to mark\nwhile (true) {\ntry {\nList<Tile> tiles = getGameLogic().getTerritory().getTiles();\nTile tile = tiles.get(GameLogic.RANDOM.nextInt(tiles.size()));\ntile.setMarkedPlayer(this);\ngetGameLogic().endMove();\nreturn;\n} catch (TileAreadyMarkedException e) {\n}\n}","code_context_20":"@Override\npublic void makeMove() {\n\/\/ TODO Not just randomly select a tile to mark\nwhile (true) {\ntry {\nList<Tile> tiles = getGameLogic().getTerritory().getTiles();\nTile tile = tiles.get(GameLogic.RANDOM.nextInt(tiles.size()));\ntile.setMarkedPlayer(this);\ngetGameLogic().endMove();\nreturn;\n} catch (TileAreadyMarkedException e) {\n}\n}\n}\n\n@Override\npublic void makeMove() {\n\/\/ TODO Not just randomly select a tile to mark\nwhile (true) {\ntry {\nList<Tile> tiles = getGameLogic().getTerritory().getTiles();\nTile tile = tiles.get(GameLogic.RANDOM.nextInt(tiles.size()));\ntile.setMarkedPlayer(this);\ngetGameLogic().endMove();\nreturn;\n} catch (TileAreadyMarkedException e) {\n}\n}\n}","label":[1,0,0,0]}
{"id":16106,"original_code":"public static String getData() {\n        Future<String> f = getInstance().startupFuture.get();\n        if (f == null) {\n            \/\/ FIXME haven't even started yet... need to busy-wait, perhaps\n        }\n        try {\n            String data = f.get(30, TimeUnit.SECONDS);\n            return data;\n        } catch (InterruptedException | ExecutionException e) {\n            \/\/ FIXME failed to startup or was interrupted during startup; maybe throw to the caller?\n            throw new IllegalStateException(e);\n        } catch (TimeoutException e) {\n            \/\/ FIXME got tired of waiting, maybe do something special here?\n            throw new IllegalStateException(e);\n        }\n    }","code":"public static String getData() {\n        Future<String> f = getInstance().startupFuture.get();\n        if (f == null) {\n           \n        }\n        try {\n            String data = f.get(30, TimeUnit.SECONDS);\n            return data;\n        } catch (InterruptedException | ExecutionException e) {\n           \n            throw new IllegalStateException(e);\n        } catch (TimeoutException e) {\n           \n            throw new IllegalStateException(e);\n        }\n    }","cleancode":"public static string getdata() { future<string> f = getinstance().startupfuture.get(); if (f == null) { } try { string data = f.get(30, timeunit.seconds); return data; } catch (interruptedexception | executionexception e) { throw new illegalstateexception(e); } catch (timeoutexception e) { throw new illegalstateexception(e); } }","comment":"\/\/ fixme haven't even started yet... need to busy-wait, perhaps\n\/\/ fixme failed to startup or was interrupted during startup; maybe throw to the caller?\n\/\/ fixme got tired of waiting, maybe do something special here?","repo":"seemikehack\/synchronized-startup","code_context_2":"Future<String> f = getInstance().startupFuture.get();\nif (f == null) {\n\/\/ FIXME haven't even started yet... need to busy-wait, perhaps\n}\ntry {\n\nreturn data;\n} catch (InterruptedException | ExecutionException e) {\n\/\/ FIXME failed to startup or was interrupted during startup; maybe throw to the caller?\nthrow new IllegalStateException(e);\n} catch (TimeoutException e) {\n\nthrow new IllegalStateException(e);\n} catch (TimeoutException e) {\n\/\/ FIXME got tired of waiting, maybe do something special here?\nthrow new IllegalStateException(e);\n}","code_context_10":"public static String getData() {\nFuture<String> f = getInstance().startupFuture.get();\nif (f == null) {\n\/\/ FIXME haven't even started yet... need to busy-wait, perhaps\n}\ntry {\nString data = f.get(30, TimeUnit.SECONDS);\nreturn data;\n} catch (InterruptedException | ExecutionException e) {\n\/\/ FIXME failed to startup or was interrupted during startup; maybe throw to the caller?\nthrow new IllegalStateException(e);\n} catch (TimeoutException e) {\n\/\/ FIXME got tired of waiting, maybe do something special here?\nthrow new IllegalStateException(e);\n\npublic static String getData() {\nFuture<String> f = getInstance().startupFuture.get();\nif (f == null) {\n\/\/ FIXME haven't even started yet... need to busy-wait, perhaps\n}\ntry {\nString data = f.get(30, TimeUnit.SECONDS);\nreturn data;\n} catch (InterruptedException | ExecutionException e) {\n\/\/ FIXME failed to startup or was interrupted during startup; maybe throw to the caller?\nthrow new IllegalStateException(e);\n} catch (TimeoutException e) {\n\/\/ FIXME got tired of waiting, maybe do something special here?\nthrow new IllegalStateException(e);\n}\n}\n\nif (f == null) {\n\/\/ FIXME haven't even started yet... need to busy-wait, perhaps\n}\ntry {\nString data = f.get(30, TimeUnit.SECONDS);\nreturn data;\n} catch (InterruptedException | ExecutionException e) {\n\/\/ FIXME failed to startup or was interrupted during startup; maybe throw to the caller?\nthrow new IllegalStateException(e);\n} catch (TimeoutException e) {\n\/\/ FIXME got tired of waiting, maybe do something special here?\nthrow new IllegalStateException(e);\n}\n}","code_context_20":"public static String getData() {\nFuture<String> f = getInstance().startupFuture.get();\nif (f == null) {\n\/\/ FIXME haven't even started yet... need to busy-wait, perhaps\n}\ntry {\nString data = f.get(30, TimeUnit.SECONDS);\nreturn data;\n} catch (InterruptedException | ExecutionException e) {\n\/\/ FIXME failed to startup or was interrupted during startup; maybe throw to the caller?\nthrow new IllegalStateException(e);\n} catch (TimeoutException e) {\n\/\/ FIXME got tired of waiting, maybe do something special here?\nthrow new IllegalStateException(e);\n}\n}\n\npublic static String getData() {\nFuture<String> f = getInstance().startupFuture.get();\nif (f == null) {\n\/\/ FIXME haven't even started yet... need to busy-wait, perhaps\n}\ntry {\nString data = f.get(30, TimeUnit.SECONDS);\nreturn data;\n} catch (InterruptedException | ExecutionException e) {\n\/\/ FIXME failed to startup or was interrupted during startup; maybe throw to the caller?\nthrow new IllegalStateException(e);\n} catch (TimeoutException e) {\n\/\/ FIXME got tired of waiting, maybe do something special here?\nthrow new IllegalStateException(e);\n}\n}\n\npublic static String getData() {\nFuture<String> f = getInstance().startupFuture.get();\nif (f == null) {\n\/\/ FIXME haven't even started yet... need to busy-wait, perhaps\n}\ntry {\nString data = f.get(30, TimeUnit.SECONDS);\nreturn data;\n} catch (InterruptedException | ExecutionException e) {\n\/\/ FIXME failed to startup or was interrupted during startup; maybe throw to the caller?\nthrow new IllegalStateException(e);\n} catch (TimeoutException e) {\n\/\/ FIXME got tired of waiting, maybe do something special here?\nthrow new IllegalStateException(e);\n}\n}","label":[0,0,1,0]}
{"id":8111,"original_code":"public synchronized void start() throws IOException, InterruptedException {\n        final AtomicBoolean bound = new AtomicBoolean();\n        running.set(true);\n        Thread t = new Thread(new Runnable() {\n            @Override\n            public void run() {\n                try {\n                    ServerSocket ss = new ServerSocket(port);\n                    synchronized (bound) {\n                        bound.set(true);\n                        bound.notifyAll();\n                    }\n                    Socket[] conn = new Socket[nDataGens];\n                    try {\n                        for (int i = 0; i < nDataGens; i++) {\n                            conn[i] = ss.accept();\n                        }\n                        for (int n = 0; n < nIntervals; ++n) {\n                            \/\/TODO refactor operations according to the protocol message\n                            if (flagStopResume) {\n                                for (int i = 0; i < nDataGens; i++) {\n                                    receiveStopped(conn[i]);\n                                }\n                                protocolActions[n].perform();\n                                if (n != nIntervals - 1) {\n                                    for (int i = 0; i < nDataGens; i++) {\n                                        sendResume(conn[i]);\n                                    }\n                                }\n                            } else {\n                                for (int i = 0; i < nDataGens; i++) {\n                                    receiveReached(conn[i]);\n                                }\n                                protocolActions[n].perform();\n                            }\n                        }\n                    } finally {\n                        for (int i = 0; i < conn.length; ++i) {\n                            if (conn[i] != null) {\n                                conn[i].close();\n                            }\n                        }\n                        ss.close();\n                    }\n                    running.set(false);\n                    synchronized (OrchestratorServer.this) {\n                        OrchestratorServer.this.notifyAll();\n                    }\n                } catch (Throwable t) {\n                    t.printStackTrace();\n                }\n            }\n        });\n        t.start();\n        synchronized (bound) {\n            while (!bound.get()) {\n                bound.wait();\n            }\n        }\n    }","code":"public synchronized void start() throws IOException, InterruptedException {\n        final AtomicBoolean bound = new AtomicBoolean();\n        running.set(true);\n        Thread t = new Thread(new Runnable() {\n            @Override\n            public void run() {\n                try {\n                    ServerSocket ss = new ServerSocket(port);\n                    synchronized (bound) {\n                        bound.set(true);\n                        bound.notifyAll();\n                    }\n                    Socket[] conn = new Socket[nDataGens];\n                    try {\n                        for (int i = 0; i < nDataGens; i++) {\n                            conn[i] = ss.accept();\n                        }\n                        for (int n = 0; n < nIntervals; ++n) {\n                           \n                            if (flagStopResume) {\n                                for (int i = 0; i < nDataGens; i++) {\n                                    receiveStopped(conn[i]);\n                                }\n                                protocolActions[n].perform();\n                                if (n != nIntervals - 1) {\n                                    for (int i = 0; i < nDataGens; i++) {\n                                        sendResume(conn[i]);\n                                    }\n                                }\n                            } else {\n                                for (int i = 0; i < nDataGens; i++) {\n                                    receiveReached(conn[i]);\n                                }\n                                protocolActions[n].perform();\n                            }\n                        }\n                    } finally {\n                        for (int i = 0; i < conn.length; ++i) {\n                            if (conn[i] != null) {\n                                conn[i].close();\n                            }\n                        }\n                        ss.close();\n                    }\n                    running.set(false);\n                    synchronized (OrchestratorServer.this) {\n                        OrchestratorServer.this.notifyAll();\n                    }\n                } catch (Throwable t) {\n                    t.printStackTrace();\n                }\n            }\n        });\n        t.start();\n        synchronized (bound) {\n            while (!bound.get()) {\n                bound.wait();\n            }\n        }\n    }","cleancode":"public synchronized void start() throws ioexception, interruptedexception { final atomicboolean bound = new atomicboolean(); running.set(true); thread t = new thread(new runnable() { @override public void run() { try { serversocket ss = new serversocket(port); synchronized (bound) { bound.set(true); bound.notifyall(); } socket[] conn = new socket[ndatagens]; try { for (int i = 0; i < ndatagens; i++) { conn[i] = ss.accept(); } for (int n = 0; n < nintervals; ++n) { if (flagstopresume) { for (int i = 0; i < ndatagens; i++) { receivestopped(conn[i]); } protocolactions[n].perform(); if (n != nintervals - 1) { for (int i = 0; i < ndatagens; i++) { sendresume(conn[i]); } } } else { for (int i = 0; i < ndatagens; i++) { receivereached(conn[i]); } protocolactions[n].perform(); } } } finally { for (int i = 0; i < conn.length; ++i) { if (conn[i] != null) { conn[i].close(); } } ss.close(); } running.set(false); synchronized (orchestratorserver.this) { orchestratorserver.this.notifyall(); } } catch (throwable t) { t.printstacktrace(); } } }); t.start(); synchronized (bound) { while (!bound.get()) { bound.wait(); } } }","comment":"\/\/todo refactor operations according to the protocol message","repo":"srinivas491\/AsterixDB","code_context_2":"}\nfor (int n = 0; n < nIntervals; ++n) {\n\/\/TODO refactor operations according to the protocol message\nif (flagStopResume) {\nfor (int i = 0; i < nDataGens; i++) {","code_context_10":"synchronized (bound) {\nbound.set(true);\nbound.notifyAll();\n}\nSocket[] conn = new Socket[nDataGens];\ntry {\nfor (int i = 0; i < nDataGens; i++) {\nconn[i] = ss.accept();\n}\nfor (int n = 0; n < nIntervals; ++n) {\n\/\/TODO refactor operations according to the protocol message\nif (flagStopResume) {\nfor (int i = 0; i < nDataGens; i++) {\nreceiveStopped(conn[i]);\n}\nprotocolActions[n].perform();\nif (n != nIntervals - 1) {\nfor (int i = 0; i < nDataGens; i++) {\nsendResume(conn[i]);\n}\n}","code_context_20":"public synchronized void start() throws IOException, InterruptedException {\nfinal AtomicBoolean bound = new AtomicBoolean();\nrunning.set(true);\nThread t = new Thread(new Runnable() {\n@Override\npublic void run() {\ntry {\nServerSocket ss = new ServerSocket(port);\nsynchronized (bound) {\nbound.set(true);\nbound.notifyAll();\n}\nSocket[] conn = new Socket[nDataGens];\ntry {\nfor (int i = 0; i < nDataGens; i++) {\nconn[i] = ss.accept();\n}\nfor (int n = 0; n < nIntervals; ++n) {\n\/\/TODO refactor operations according to the protocol message\nif (flagStopResume) {\nfor (int i = 0; i < nDataGens; i++) {\nreceiveStopped(conn[i]);\n}\nprotocolActions[n].perform();\nif (n != nIntervals - 1) {\nfor (int i = 0; i < nDataGens; i++) {\nsendResume(conn[i]);\n}\n}\n} else {\nfor (int i = 0; i < nDataGens; i++) {\nreceiveReached(conn[i]);\n}\nprotocolActions[n].perform();\n}\n}\n} finally {\nfor (int i = 0; i < conn.length; ++i) {\nif (conn[i] != null) {","label":[1,0,0,0]}
{"id":16343,"original_code":"@Override\n    public void registerDefaults() {\n        \/\/ @formatter:off\n        \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n        \/\/\/    Air      \/\/\/\n        \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n        register(0, builder()\n                        .properties(PropertyProviderCollections.DEFAULT_GAS)\n                        .translation(\"tile.air.name\")\n                        .build(\"minecraft\", \"air\"));\n        \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n        \/\/\/    Stone    \/\/\/\n        \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n        register(1, simpleBuilder()\n                        .trait(LanternEnumTraits.STONE_TYPE)\n                        .defaultState(state -> state.withTrait(LanternEnumTraits.STONE_TYPE, LanternStoneType.STONE).get())\n                        .itemType(builder -> builder\n                                .keysProvider(collection -> collection\n                                        .register(Keys.STONE_TYPE, LanternStoneType.STONE)\n                                )\n                        )\n                        .properties(builder -> builder\n                                .add(hardness(1.5))\n                                .add(blastResistance(30.0)))\n                        .translation(TranslationProvider.of(LanternEnumTraits.STONE_TYPE))\n                        .build(\"minecraft\", \"stone\"),\n                blockState -> (byte) blockState.getTraitValue(LanternEnumTraits.STONE_TYPE).get().getInternalId());\n        \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n        \/\/\/    Grass    \/\/\/\n        \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n        register(2, simpleBuilder()\n                        .trait(LanternBooleanTraits.SNOWY)\n                        .extendedStateProvider(new SnowyExtendedBlockStateProvider())\n                        .defaultState(state -> state.withTrait(LanternBooleanTraits.SNOWY, false).get())\n                        .itemType()\n                        .properties(builder -> builder\n                                .add(hardness(0.6))\n                                .add(blastResistance(3.0)))\n                        .translation(\"tile.grass.name\")\n                        .build(\"minecraft\", \"grass\"));\n        \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n        \/\/\/    Dirt     \/\/\/\n        \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n        register(3, simpleBuilder()\n                        .traits(LanternEnumTraits.DIRT_TYPE, LanternBooleanTraits.SNOWY)\n                        .defaultState(state -> state\n                                .withTrait(LanternEnumTraits.DIRT_TYPE, LanternDirtType.DIRT).get()\n                                .withTrait(LanternBooleanTraits.SNOWY, false).get())\n                        .extendedStateProvider(new SnowyExtendedBlockStateProvider())\n                        .itemType(builder -> builder\n                                .keysProvider(collection -> collection\n                                        .register(Keys.DIRT_TYPE, LanternDirtType.DIRT)\n                                )\n                        )\n                        .properties(builder -> builder\n                                .add(hardness(0.5))\n                                .add(blastResistance(2.5)))\n                        .translation(TranslationProvider.of(LanternEnumTraits.DIRT_TYPE))\n                        .build(\"minecraft\", \"dirt\"),\n                blockState -> (byte) blockState.getTraitValue(LanternEnumTraits.DIRT_TYPE).get().getInternalId());\n        \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n        \/\/\/ Cobblestone \/\/\/\n        \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n        register(4, simpleBuilder()\n                        .itemType()\n                        .properties(builder -> builder\n                                .add(hardness(2.0))\n                                .add(blastResistance(3.0)))\n                        .translation(\"tile.stonebrick.name\")\n                        .build(\"minecraft\", \"cobblestone\"));\n        \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n        \/\/\/    Planks   \/\/\/\n        \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n        register(5, simpleBuilder()\n                        .trait(LanternEnumTraits.TREE_TYPE)\n                        .defaultState(state -> state.withTrait(LanternEnumTraits.TREE_TYPE, LanternTreeType.OAK).get())\n                        .itemType(builder -> builder\n                                .keysProvider(collection -> collection\n                                        .register(Keys.TREE_TYPE, LanternTreeType.OAK)\n                                )\n                        )\n                        .properties(builder -> builder\n                                .add(hardness(2.0))\n                                .add(blastResistance(5.0))\n                                .add(flammableInfo(5, 20)))\n                        .translation(TranslationProvider.of(LanternEnumTraits.TREE_TYPE, type ->\n                                tr(\"tile.planks.\" + type.getTranslationKeyBase() + \".name\")))\n                        .build(\"minecraft\", \"planks\"),\n                blockState -> (byte) blockState.getTraitValue(LanternEnumTraits.TREE_TYPE).get().getInternalId());\n        \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n        \/\/\/    Sapling   \/\/\/\n        \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n        register(6, simpleBuilder()\n                        .traits(LanternEnumTraits.TREE_TYPE, LanternIntegerTraits.SAPLING_GROWTH_STAGE)\n                        .defaultState(state -> state\n                                .withTrait(LanternEnumTraits.TREE_TYPE, LanternTreeType.OAK).get()\n                                .withTrait(LanternIntegerTraits.SAPLING_GROWTH_STAGE, 0).get())\n                        .itemType(builder -> builder\n                                .keysProvider(collection -> collection\n                                        .register(Keys.TREE_TYPE, LanternTreeType.OAK)\n                                )\n                        )\n                        .properties(builder -> builder\n                                .add(PASSABLE)\n                                .add(INSTANT_BROKEN))\n                        .translation(TranslationProvider.of(LanternEnumTraits.TREE_TYPE, type ->\n                                tr(\"tile.sapling.\" + type.getTranslationKeyBase() + \".name\")))\n                        .build(\"minecraft\", \"sapling\"),\n                blockState -> {\n                    final int type = blockState.getTraitValue(LanternEnumTraits.TREE_TYPE).get().getInternalId();\n                    final int stage = blockState.getTraitValue(LanternIntegerTraits.SAPLING_GROWTH_STAGE).get();\n                    return (byte) (stage << 3 | type);\n                });\n        \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n        \/\/\/    Bedrock   \/\/\/\n        \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n        register(7, simpleBuilder()\n                        .itemType()\n                        .properties(builder -> builder\n                                .add(PropertyProviderCollections.UNBREAKABLE))\n                        .translation(\"tile.bedrock.name\")\n                        .build(\"minecraft\", \"bedrock\"));\n        \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n        \/\/\/     Sand     \/\/\/\n        \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n        register(12, simpleBuilder()\n                        .trait(LanternEnumTraits.SAND_TYPE)\n                        .defaultState(state -> state.withTrait(LanternEnumTraits.SAND_TYPE, LanternSandType.NORMAL).get())\n                        .itemType(builder -> builder\n                                .keysProvider(collection -> collection\n                                        .register(Keys.SAND_TYPE, LanternSandType.NORMAL)\n                                )\n                        )\n                        .properties(builder -> builder\n                                .add(hardness(0.5))\n                                .add(blastResistance(2.5)))\n                        .translation(TranslationProvider.of(LanternEnumTraits.SAND_TYPE))\n                        .build(\"minecraft\", \"sand\"),\n                blockState -> (byte) blockState.getTraitValue(LanternEnumTraits.SAND_TYPE).get().getInternalId());\n        \/\/ TODO: Sand physics behavior\n        \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n        \/\/\/    Gravel    \/\/\/\n        \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n        register(13, simpleBuilder()\n                        .itemType()\n                        .properties(builder -> builder\n                                .add(hardness(0.6))\n                                .add(blastResistance(3.0)))\n                        .translation(\"tile.gravel.name\")\n                        .build(\"minecraft\", \"gravel\"));\n        \/\/ TODO: Gravel physics behavior\n        \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n        \/\/\/   Gold Ore   \/\/\/\n        \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n        register(14, simpleBuilder()\n                        .itemType()\n                        .properties(builder -> builder\n                                .add(hardness(3.0))\n                                .add(blastResistance(15.0)))\n                        .translation(\"tile.oreGold.name\")\n                        .build(\"minecraft\", \"gold_ore\"));\n        \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n        \/\/\/   Iron Ore   \/\/\/\n        \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n        register(15, simpleBuilder()\n                        .itemType()\n                        .properties(builder -> builder\n                                .add(hardness(3.0))\n                                .add(blastResistance(15.0)))\n                        .translation(\"tile.oreIron.name\")\n                        .build(\"minecraft\", \"iron_ore\"));\n        \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n        \/\/\/   Coal Ore   \/\/\/\n        \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n        register(16, simpleBuilder()\n                        .itemType()\n                        .properties(builder -> builder\n                                .add(hardness(3.0))\n                                .add(blastResistance(15.0)))\n                        .translation(\"tile.oreCoal.name\")\n                        .build(\"minecraft\", \"coal_ore\"));\n        \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n        \/\/\/    Log 1     \/\/\/\n        \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n        register(17, logBuilder(LanternEnumTraits.LOG1_TYPE, LanternTreeType.OAK)\n                        .build(\"minecraft\", \"log\"),\n                blockState -> logData(blockState, blockState.getTraitValue(LanternEnumTraits.LOG1_TYPE).get().getInternalId()));\n        \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n        \/\/\/   Leaves 1   \/\/\/\n        \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n        register(18, leavesBuilder(LanternEnumTraits.LEAVES1_TYPE, LanternTreeType.OAK)\n                        .build(\"minecraft\", \"leaves\"),\n                blockState -> leavesData(blockState, blockState.getTraitValue(LanternEnumTraits.LEAVES1_TYPE).get().getInternalId()));\n        \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n        \/\/\/    Sponge    \/\/\/\n        \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n        register(19, simpleBuilder()\n                        .trait(LanternBooleanTraits.IS_WET)\n                        .defaultState(state -> state.withTrait(LanternBooleanTraits.IS_WET, false).get())\n                        .itemType(builder -> builder\n                                .keysProvider(collection -> collection\n                                        .register(Keys.IS_WET, false)\n                                )\n                        )\n                        .properties(builder -> builder\n                                .add(hardness(0.6))\n                                .add(blastResistance(3.0)))\n                        .translation(new SpongeTranslationProvider())\n                        .build(\"minecraft\", \"sponge\"),\n                blockState -> (byte) (blockState.getTraitValue(LanternBooleanTraits.IS_WET).get() ? 1 : 0));\n        \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n        \/\/\/    Glass     \/\/\/\n        \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n        register(20, simpleBuilder()\n                        .itemType()\n                        .properties(builder -> builder\n                                .add(hardness(0.3))\n                                .add(blastResistance(1.5)))\n                        .translation(\"tile.glass.name\")\n                        .build(\"minecraft\", \"glass\"));\n        \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n        \/\/\/   Lapis Ore  \/\/\/\n        \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n        register(21, simpleBuilder()\n                        .itemType()\n                        .properties(builder -> builder\n                                .add(hardness(3.0))\n                                .add(blastResistance(15.0)))\n                        .translation(\"tile.oreLapis.name\")\n                        .build(\"minecraft\", \"lapis_ore\"));\n        \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n        \/\/\/  Lapis Block \/\/\/\n        \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n        register(22, simpleBuilder()\n                        .itemType()\n                        .properties(builder -> builder\n                                .add(hardness(3.0))\n                                .add(blastResistance(15.0)))\n                        .translation(\"tile.blockLapis.name\")\n                        .build(\"minecraft\", \"lapis_block\"));\n        \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n        \/\/\/   Dispenser  \/\/\/\n        \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n        register(23, simpleBuilder()\n                        .traits(LanternEnumTraits.FACING, LanternBooleanTraits.TRIGGERED)\n                        .defaultState(state -> state\n                                .withTrait(LanternEnumTraits.FACING, Direction.NORTH).get()\n                                .withTrait(LanternBooleanTraits.TRIGGERED, false).get())\n                        .itemType()\n                        .properties(builder -> builder\n                                .add(hardness(3.5))\n                                .add(blastResistance(17.5)))\n                        \/\/ .tileEntityType(() -> TileEntityTypes.DISPENSER)\n                        .translation(\"tile.dispenser.name\")\n                        .behaviors(pipeline -> pipeline\n                                .add(new RotationPlacementBehavior()))\n                        .build(\"minecraft\", \"dispenser\"),\n                blockState -> {\n                    int data = directionData(blockState.getTraitValue(LanternEnumTraits.FACING).get());\n                    if (blockState.getTraitValue(LanternBooleanTraits.TRIGGERED).get()) {\n                        data |= 0x8;\n                    }\n                    return (byte) data;\n                });\n        \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n        \/\/\/   Sandstone  \/\/\/\n        \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n        register(24, simpleBuilder()\n                        .trait(LanternEnumTraits.SANDSTONE_TYPE)\n                        .defaultState(state -> state.withTrait(LanternEnumTraits.SANDSTONE_TYPE, LanternSandstoneType.DEFAULT).get())\n                        .itemType(builder -> builder\n                                .keysProvider(collection -> collection\n                                        .register(Keys.SANDSTONE_TYPE, LanternSandstoneType.DEFAULT)\n                                )\n                        )\n                        .properties(builder -> builder\n                                .add(hardness(0.8))\n                                .add(blastResistance(4.0)))\n                        .translation(TranslationProvider.of(LanternEnumTraits.SANDSTONE_TYPE))\n                        .build(\"minecraft\", \"sandstone\"),\n                blockState -> (byte) blockState.getTraitValue(LanternEnumTraits.SANDSTONE_TYPE).get().getInternalId());\n        \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n        \/\/\/   Noteblock  \/\/\/\n        \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n        register(25, simpleBuilder()\n                        .itemType()\n                        .properties(builder -> builder\n                                .add(hardness(0.8))\n                                .add(blastResistance(4.0)))\n                        .translation(\"tile.musicBlock.name\")\n                        .tileEntityType(() -> TileEntityTypes.NOTE)\n                        .behaviors(pipeline -> pipeline\n                                .add(new NoteBlockInteractionBehavior()))\n                        .build(\"minecraft\", \"noteblock\"));\n        \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n        \/\/\/     Bed      \/\/\/\n        \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n        register(26, simpleBuilder()\n                        .traits(LanternEnumTraits.HORIZONTAL_FACING, LanternEnumTraits.BED_PART, LanternBooleanTraits.OCCUPIED)\n                        .defaultState(state -> state\n                                .withTrait(LanternEnumTraits.HORIZONTAL_FACING, Direction.NORTH).get()\n                                .withTrait(LanternEnumTraits.BED_PART, LanternBedPart.FOOT).get()\n                                .withTrait(LanternBooleanTraits.OCCUPIED, false).get())\n                        .properties(builder -> builder\n                                .add(hardness(0.2))\n                                .add(blastResistance(1.0)))\n                        .translation(\"tile.bed.name\")\n                        .build(\"minecraft\", \"bed\"),\n                blockState -> {\n                    final Direction facing = blockState.getTraitValue(LanternEnumTraits.HORIZONTAL_FACING).get();\n                    int type = facing == Direction.SOUTH  ? 0 : facing == Direction.WEST ? 1 :\n                            facing == Direction.NORTH ? 2 : facing == Direction.EAST ? 3 : -1;\n                    checkArgument(type != -1);\n                    if (blockState.getTraitValue(LanternBooleanTraits.OCCUPIED).get()) {\n                        type |= 0x4;\n                    }\n                    if (blockState.getTraitValue(LanternEnumTraits.BED_PART).get() == LanternBedPart.HEAD) {\n                        type |= 0x8;\n                    }\n                    return (byte) type;\n                });\n        \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n        \/\/\/   Golden Rail  \/\/\/\n        \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n        register(27, simpleBuilder()\n                        .traits(LanternEnumTraits.STRAIGHT_RAIL_DIRECTION, LanternBooleanTraits.POWERED)\n                        .defaultState(state -> state\n                                .withTrait(LanternEnumTraits.STRAIGHT_RAIL_DIRECTION, LanternRailDirection.NORTH_SOUTH).get()\n                                .withTrait(LanternBooleanTraits.POWERED, false).get())\n                        .itemType()\n                        .selectionBox(BoundingBoxes::rail)\n                        .properties(builder -> builder\n                                .add(PASSABLE)\n                                .add(hardness(0.7))\n                                .add(blastResistance(3.5)))\n                        .translation(\"tile.goldenRail.name\")\n                        .build(\"minecraft\", \"golden_rail\"),\n                blockState -> {\n                    int type = blockState.getTraitValue(LanternEnumTraits.STRAIGHT_RAIL_DIRECTION).get().getInternalId();\n                    if (blockState.getTraitValue(LanternBooleanTraits.POWERED).get()) {\n                        type |= 0x8;\n                    }\n                    return (byte) type;\n                });\n        \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n        \/\/\/   Detector Rail  \/\/\/\n        \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n        register(28, simpleBuilder()\n                        .traits(LanternEnumTraits.STRAIGHT_RAIL_DIRECTION, LanternBooleanTraits.POWERED)\n                        .defaultState(state -> state\n                                .withTrait(LanternEnumTraits.STRAIGHT_RAIL_DIRECTION, LanternRailDirection.NORTH_SOUTH).get()\n                                .withTrait(LanternBooleanTraits.POWERED, false).get())\n                        .itemType()\n                        .selectionBox(BoundingBoxes::rail)\n                        .properties(builder -> builder\n                                .add(PASSABLE)\n                                .add(hardness(0.7))\n                                .add(blastResistance(3.5)))\n                        .translation(\"tile.detectorRail.name\")\n                        .build(\"minecraft\", \"detector_rail\"),\n                blockState -> {\n                    int type = blockState.getTraitValue(LanternEnumTraits.STRAIGHT_RAIL_DIRECTION).get().getInternalId();\n                    if (blockState.getTraitValue(LanternBooleanTraits.POWERED).get()) {\n                        type |= 0x8;\n                    }\n                    return (byte) type;\n                });\n        \/\/ TODO: 29\n        \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n        \/\/\/   Web   \/\/\/\n        \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n        register(30, simpleBuilder()\n                        .itemType()\n                        .properties(builder -> builder\n                                .add(PASSABLE)\n                                .add(hardness(4.0))\n                                .add(blastResistance(20.0)))\n                        .translation(\"tile.web.name\")\n                        .build(\"minecraft\", \"web\"));\n        \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n        \/\/\/   Tall Grass   \/\/\/\n        \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n        register(31, simpleBuilder()\n                        .traits(LanternEnumTraits.SHRUB_TYPE)\n                            .defaultState(state -> state\n                                    .withTrait(LanternEnumTraits.SHRUB_TYPE, LanternShrubType.DEAD_BUSH).get())\n                        .itemType(builder -> builder\n                                .keysProvider(collection -> collection\n                                        .register(Keys.SHRUB_TYPE, LanternShrubType.DEAD_BUSH)))\n                        .selectionBox(BoundingBoxes.bush())\n                        .properties(builder -> builder\n                                .add(INSTANT_BROKEN)\n                                .add(PASSABLE)\n                                .add(replaceable(true)))\n                        .translation(\"tile.tallgrass.name\")\n                        .build(\"minecraft\", \"tallgrass\"),\n                blockState -> (byte) blockState.getTraitValue(LanternEnumTraits.SHRUB_TYPE).get().getInternalId());\n        \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n        \/\/\/   Dead Bush   \/\/\/\n        \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n        register(32, simpleBuilder()\n                        .properties(builder -> builder\n                                .add(INSTANT_BROKEN)\n                                .add(PASSABLE)\n                                .add(replaceable(true)))\n                        .selectionBox(BoundingBoxes.bush())\n                        .itemType()\n                        .translation(\"tile.deadbush.name\")\n                        .build(\"minecraft\", \"deadbush\"));\n        \/\/ TODO: 33\n        \/\/ TODO: 34\n        \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n        \/\/\/     Wool    \/\/\/\n        \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n        register(35, dyedBuilder(\"tile.wool.%s.name\")\n                        .properties(builder -> builder\n                                .add(hardness(0.8))\n                                .add(blastResistance(4.0)))\n                        .build(\"minecraft\", \"wool\"),\n                this::dyedData);\n        \/\/ TODO: 36\n        \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n        \/\/\/   Yellow Flower   \/\/\/\n        \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n        register(37, simpleBuilder()\n                        .traits(LanternEnumTraits.YELLOW_FLOWER_TYPE)\n                        .defaultState(state -> state\n                                .withTrait(LanternEnumTraits.YELLOW_FLOWER_TYPE, LanternPlantType.DANDELION).get())\n                        .itemType(builder -> builder\n                                .keysProvider(collection -> collection\n                                        .register(Keys.PLANT_TYPE, LanternPlantType.DANDELION)))\n                        .selectionBox(BoundingBoxes.bush())\n                        .properties(builder -> builder\n                                .add(INSTANT_BROKEN)\n                                .add(PASSABLE))\n                        .translation(TranslationProvider.of(LanternEnumTraits.YELLOW_FLOWER_TYPE))\n                        .build(\"minecraft\", \"yellow_flower\"),\n                blockState -> (byte) blockState.getTraitValue(LanternEnumTraits.YELLOW_FLOWER_TYPE).get().getInternalId());\n        \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n        \/\/\/   Red Flower   \/\/\/\n        \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n        register(38, simpleBuilder()\n                        .traits(LanternEnumTraits.RED_FLOWER_TYPE)\n                        .defaultState(state -> state\n                                .withTrait(LanternEnumTraits.RED_FLOWER_TYPE, LanternPlantType.POPPY).get())\n                        .itemType(builder -> builder\n                                .keysProvider(collection -> collection\n                                        .register(Keys.PLANT_TYPE, LanternPlantType.POPPY)))\n                        .selectionBox(BoundingBoxes.bush())\n                        .properties(builder -> builder\n                                .add(INSTANT_BROKEN)\n                                .add(PASSABLE))\n                        .translation(TranslationProvider.of(LanternEnumTraits.RED_FLOWER_TYPE))\n                        .build(\"minecraft\", \"red_flower\"),\n                blockState -> (byte) blockState.getTraitValue(LanternEnumTraits.RED_FLOWER_TYPE).get().getInternalId());\n        \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n        \/\/\/   Brown Mushroom   \/\/\/\n        \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n        register(39, simpleBuilder()\n                        .selectionBox(BoundingBoxes.bush())\n                        .properties(builder -> builder\n                                .add(INSTANT_BROKEN)\n                                .add(PASSABLE)\n                                .add(lightEmission(1)))\n                        .translation(\"tile.mushroom.name\")\n                        .build(\"minecraft\", \"brown_mushroom\"));\n        \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n        \/\/\/   Red Mushroom   \/\/\/\n        \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n        register(40, simpleBuilder()\n                        .selectionBox(BoundingBoxes.bush())\n                        .properties(builder -> builder\n                                .add(INSTANT_BROKEN)\n                                .add(PASSABLE))\n                        .translation(\"tile.mushroom.name\")\n                        .build(\"minecraft\", \"red_mushroom\"));\n        \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n        \/\/\/   Gold Block   \/\/\/\n        \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n        register(41, simpleBuilder()\n                        .itemType()\n                        .properties(builder -> builder\n                                .add(hardness(3.0))\n                                .add(blastResistance(10.0)))\n                        .translation(\"tile.blockGold.name\")\n                        .build(\"minecraft\", \"gold_block\"));\n        \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n        \/\/\/   Iron Block   \/\/\/\n        \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n        register(42, simpleBuilder()\n                        .itemType()\n                        .properties(builder -> builder\n                                .add(hardness(5.0))\n                                .add(blastResistance(10.0)))\n                        .translation(\"tile.blockIron.name\")\n                        .build(\"minecraft\", \"iron_block\"));\n        \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n        \/\/\/ Double Stone Slab 1 \/\/\/\n        \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n        register(43, doubleStoneSlab(LanternEnumTraits.STONE_SLAB1_TYPE, LanternSlabType.STONE)\n                        .translation(\"tile.stoneSlab.name\")\n                        .build(\"minecraft\", \"double_stone_slab\"),\n                blockState -> doubleStoneSlabData(blockState, blockState.getTraitValue(LanternEnumTraits.STONE_SLAB1_TYPE).get().getInternalId()));\n        \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n        \/\/\/   Stone Slab 1   \/\/\/\n        \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n        register(44, stoneSlab(LanternEnumTraits.STONE_SLAB1_TYPE, LanternSlabType.STONE,\n                () -> BlockTypes.STONE_SLAB,\n                () -> BlockTypes.DOUBLE_STONE_SLAB)\n                        .translation(\"tile.stoneSlab.name\")\n                        .collisionBox(BoundingBoxes::slab)\n                        .build(\"minecraft\", \"stone_slab\"),\n                blockState -> stoneSlabData(blockState, blockState.getTraitValue(LanternEnumTraits.STONE_SLAB1_TYPE).get().getInternalId()));\n        \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n        \/\/\/   Brick Block   \/\/\/\n        \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n        register(45, simpleBuilder()\n                        .itemType()\n                        .properties(builder -> builder\n                                .add(hardness(2.0))\n                                .add(blastResistance(10.0)))\n                        .translation(\"tile.brick.name\")\n                        .build(\"minecraft\", \"brick_block\"));\n        \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n        \/\/\/   TNT   \/\/\/\n        \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n        register(46, simpleBuilder()\n                        .trait(LanternBooleanTraits.EXPLODE)\n                        .defaultState(state -> state\n                                .withTrait(LanternBooleanTraits.EXPLODE, false).get())\n                        .itemType()\n                        .properties(builder -> builder\n                                .add(INSTANT_BROKEN))\n                        .translation(\"tile.tnt.name\")\n                        .build(\"minecraft\", \"tnt\"),\n                blockState -> (byte) (blockState.getTraitValue(LanternBooleanTraits.EXPLODE).get() ? 1 : 0));\n        \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n        \/\/\/   Bookshelf   \/\/\/\n        \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n        register(47, simpleBuilder()\n                        .itemType()\n                        .properties(builder -> builder\n                                .add(hardness(1.5))\n                                .add(blastResistance(7.5)))\n                        .translation(\"tile.bookshelf.name\")\n                        .build(\"minecraft\", \"bookshelf\"));\n        \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n        \/\/\/   Mossy Cobblestone   \/\/\/\n        \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n        register(48, simpleBuilder()\n                        .itemType()\n                        .properties(builder -> builder\n                                .add(hardness(2.0))\n                                .add(blastResistance(10.0)))\n                        .translation(\"tile.stoneMoss.name\")\n                        .build(\"minecraft\", \"mossy_cobblestone\"));\n        \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n        \/\/\/   Obsidian   \/\/\/\n        \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n        register(49, simpleBuilder()\n                        .itemType()\n                        .properties(builder -> builder\n                                .add(hardness(50.0))\n                                .add(blastResistance(2000.0)))\n                        .translation(\"tile.obsidian.name\")\n                        .build(\"minecraft\", \"obsidian\"));\n        \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n        \/\/\/   Torch   \/\/\/\n        \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n        register(50, builder()\n                        .trait(LanternEnumTraits.TORCH_FACING)\n                            .defaultState(state -> state\n                                    .withTrait(LanternEnumTraits.TORCH_FACING, Direction.UP).get())\n                        .itemType()\n                        .properties(builder -> builder\n                                .add(PASSABLE)\n                                .add(INSTANT_BROKEN))\n                        .translation(\"tile.torch.name\")\n                        .selectionBox(BoundingBoxes::torch)\n                        .behaviors(pipeline -> pipeline\n                                .add(new BlockSnapshotProviderPlaceBehavior())\n                                .add(new TorchPlacementBehavior())\n                                .add(new SimpleBreakBehavior()))\n                        .build(\"minecraft\", \"torch\"),\n                blockState -> {\n                    final Direction direction = blockState.getTraitValue(LanternEnumTraits.TORCH_FACING).get();\n                    switch (direction) {\n                        case EAST:\n                            return (byte) 1;\n                        case WEST:\n                            return (byte) 2;\n                        case SOUTH:\n                            return (byte) 3;\n                        case NORTH:\n                            return (byte) 4;\n                        case UP:\n                            return (byte) 5;\n                        default:\n                            throw new IllegalArgumentException();\n                    }\n                });\n        \/\/\/\/\/\/\/\/\/\/\/\/\/\/\n        \/\/\/  Fire  \/\/\/\n        \/\/\/\/\/\/\/\/\/\/\/\/\/\/\n        register(51, simpleBuilder()\n                        .properties(builder -> builder\n                                .add(PASSABLE)\n                                .add(INSTANT_BROKEN)\n                                .add(lightEmission(15)))\n                        .collisionBox(BoundingBoxes.NULL)\n                        .translation(\"tile.fire.name\")\n                        .build(\"minecraft\", \"fire\"));\n        \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n        \/\/\/  Mob Spawner  \/\/\/\n        \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n        register(52, simpleBuilder()\n                        .properties(builder -> builder\n                                .add(hardness(5.0))\n                                .add(blastResistance(25.0)))\n                        .translation(\"tile.mobSpawner.name\")\n                        .build(\"minecraft\", \"mob_spawner\"));\n        \/\/ TODO: Oak Stairs\n        \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n        \/\/\/     Chest    \/\/\/\n        \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n        register(54, chestBuilder()\n                        .translation(\"tile.chest.name\")\n                        .build(\"minecraft\", \"chest\"),\n                this::horizontalFacingData);\n        \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n        \/\/\/     Redstone Wire   \/\/\/\n        \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n        register(55, simpleBuilder()\n                        .traits(LanternIntegerTraits.POWER)\n                        .selectionBox(new AABB(0, 0, 0, 1.0, 0.0625, 1.0)) \/\/ TODO: Based on connections\n                        .properties(builder -> builder\n                                .add(PASSABLE)\n                                .add(INSTANT_BROKEN))\n                        .defaultState(state -> state\n                                .withTrait(LanternIntegerTraits.POWER, 0).get())\n                        .translation(\"tile.redstoneDust.name\")\n                        .build(\"minecraft\", \"redstone_wire\"),\n                state -> state.get(Keys.POWER).get().byteValue());\n        \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n        \/\/\/   Diamond Ore   \/\/\/\n        \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n        register(56, simpleBuilder()\n                        .itemType()\n                        .properties(builder -> builder\n                                .add(hardness(3.0))\n                                .add(blastResistance(5.0)))\n                        .translation(\"tile.oreDiamond.name\")\n                        .build(\"minecraft\", \"diamond_ore\"));\n        \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n        \/\/\/   Diamond Block   \/\/\/\n        \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n        register(57, simpleBuilder()\n                        .itemType()\n                        .properties(builder -> builder\n                                .add(hardness(5.0))\n                                .add(blastResistance(10.0)))\n                        .translation(\"tile.blockDiamond.name\")\n                        .build(\"minecraft\", \"diamond_block\"));\n        \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n        \/\/\/   Crafting Table   \/\/\/\n        \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n        register(58, simpleBuilder()\n                        .itemType()\n                        .properties(builder -> builder\n                                .add(hardness(2.5))\n                                .add(blastResistance(12.5)))\n                        .translation(\"tile.workbench.name\")\n                        .behaviors(pipeline -> pipeline\n                                .add(new CraftingTableInteractionBehavior()))\n                        .build(\"minecraft\", \"crafting_table\"));\n        \/\/ TODO: Wheat\n        \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n        \/\/\/   Farmland   \/\/\/\n        \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n        register(60, simpleBuilder()\n                        .collisionBox(BoundingBoxes.farmland())\n                        .trait(LanternIntegerTraits.MOISTURE)\n                        .properties(builder -> builder\n                                .add(hardness(0.6))\n                                .add(blastResistance(3.0)))\n                        .defaultState(state ->\n                                state.withTrait(LanternIntegerTraits.MOISTURE, 0).get())\n                        .translation(\"tile.farmland.name\")\n                        .build(\"minecraft\", \"farmland\"),\n                state -> state.getTraitValue(LanternIntegerTraits.MOISTURE).get().byteValue());\n        \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n        \/\/\/    Furnace   \/\/\/\n        \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n        register(61, furnaceBuilder()\n                        .itemType()\n                        .translation(\"tile.furnace.name\")\n                        .build(\"minecraft\", \"furnace\"),\n                this::directionData);\n        \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n        \/\/\/  Lit Furnace \/\/\/\n        \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n        register(62, furnaceBuilder()\n                        .properties(builder -> builder\n                                .add(lightEmission(13)))\n                        .translation(\"tile.furnace.name\")\n                        .build(\"minecraft\", \"lit_furnace\"),\n                this::directionData);\n        \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n        \/\/\/ Stone Pressure Plate \/\/\/\n        \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n        register(70, pressurePlateBuilder()\n                        .translation(\"tile.pressurePlateStone.name\")\n                        .build(\"minecraft\", \"stone_pressure_plate\"),\n                this::pressurePlateData);\n        \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n        \/\/\/ Wooden Pressure Plate \/\/\/\n        \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n        register(72, pressurePlateBuilder()\n                        .translation(\"tile.pressurePlateWood.name\")\n                        .build(\"minecraft\", \"wooden_pressure_plate\"),\n                this::pressurePlateData);\n        \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n        \/\/\/    Jukebox   \/\/\/\n        \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n        register(84, simpleBuilder()\n                        .itemType()\n                        .traits(LanternBooleanTraits.HAS_RECORD)\n                        .defaultState(state -> state\n                                .withTrait(LanternBooleanTraits.HAS_RECORD, false).get())\n                        .properties(builder -> builder\n                                .add(hardness(2.0))\n                                .add(blastResistance(10.0)))\n                        .tileEntityType(() -> TileEntityTypes.JUKEBOX)\n                        .translation(\"tile.jukebox.name\")\n                        .behaviors(pipeline -> pipeline\n                                .add(new JukeboxInteractionBehavior()))\n                        .build(\"minecraft\", \"jukebox\"),\n                state -> (byte) (state.getTraitValue(LanternBooleanTraits.HAS_RECORD).get() ? 1 : 0));\n        \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n        \/\/\/    Pumpkin   \/\/\/\n        \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n        register(86, pumpkinBuilder()\n                        .itemType(builder -> builder\n                                .properties(properties -> properties\n                                        .add(equipmentType(EquipmentTypes.HEADWEAR))))\n                        .translation(\"tile.pumpkin.name\")\n                        .build(\"minecraft\", \"pumpkin\"),\n                this::horizontalDirectionData);\n        \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n        \/\/\/   Netherrack   \/\/\/\n        \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n        register(87, simpleBuilder()\n                        .itemType()\n                        .properties(builder -> builder\n                                .add(hardness(0.4))\n                                .add(blastResistance(2.0)))\n                        .translation(\"tile.hellrock.name\")\n                        .build(\"minecraft\", \"netherrack\"));\n        \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n        \/\/\/  Lit Pumpkin \/\/\/\n        \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n        register(91, pumpkinBuilder()\n                        .properties(builder -> builder\n                                .add(lightEmission(15)))\n                        .translation(\"tile.litpumpkin.name\")\n                        .build(\"minecraft\", \"lit_pumpkin\"),\n                this::horizontalDirectionData);\n        \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n        \/\/\/ Stained Glass \/\/\/\n        \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n        register(95, dyedBuilder(\"tile.stainedGlass.%s.name\")\n                        .properties(builder -> builder\n                                .add(hardness(0.3))\n                                .add(blastResistance(1.5)))\n                        .build(\"minecraft\", \"stained_glass\"),\n                this::dyedData);\n        \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n        \/\/\/  Iron Bars  \/\/\/\n        \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n        register(101, simpleBuilder()\n                        \/\/ TODO\n                        .itemType()\n                        .properties(builder -> builder\n                                .add(hardness(5.0))\n                                .add(blastResistance(10.0)))\n                        .translation(\"tile.fenceIron.name\")\n                        .build(\"minecraft\", \"iron_bars\"));\n        \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n        \/\/\/   End Stone   \/\/\/\n        \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n        register(121, simpleBuilder()\n                        .itemType()\n                        .properties(builder -> builder\n                                .add(hardness(3.0))\n                                .add(blastResistance(15.0)))\n                        .translation(\"tile.whiteStone.name\")\n                        .build(\"minecraft\", \"end_stone\"));\n        \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n        \/\/\/ Double Wooden Slab \/\/\/\n        \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n        register(125, simpleBuilder()\n                        .traits(LanternEnumTraits.TREE_TYPE)\n                        .defaultState(state -> state\n                                .withTrait(LanternEnumTraits.TREE_TYPE, LanternTreeType.OAK).get())\n                        .translation(TranslationProvider.of(LanternEnumTraits.TREE_TYPE, type ->\n                                tr(\"tile.woodSlab.\" + type.getTranslationKeyBase() + \".name\")))\n                        .itemType(builder -> builder\n                                .keysProvider(collection -> collection\n                                        .register(Keys.TREE_TYPE, LanternTreeType.OAK)\n                                )\n                        )\n                        .properties(builder -> builder\n                                .add(hardness(2.0))\n                                .add(blastResistance(5.0)))\n                        .build(\"minecraft\", \"double_wooden_slab\"),\n                blockState -> (byte) blockState.getTraitValue(LanternEnumTraits.TREE_TYPE).get().getInternalId());\n        \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n        \/\/\/     Wooden Slab    \/\/\/\n        \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n        register(126, simpleBuilder()\n                        .traits(LanternEnumTraits.PORTION_TYPE, LanternEnumTraits.TREE_TYPE)\n                        .defaultState(state -> state\n                                .withTrait(LanternEnumTraits.PORTION_TYPE, LanternPortionType.BOTTOM).get()\n                                .withTrait(LanternEnumTraits.TREE_TYPE, LanternTreeType.OAK).get())\n                        .translation(TranslationProvider.of(LanternEnumTraits.TREE_TYPE, type ->\n                                tr(\"tile.woodSlab.\" + type.getTranslationKeyBase() + \".name\")))\n                        .itemType(builder -> builder\n                                .behaviors(pipeline -> pipeline\n                                        .add(new SlabItemInteractionBehavior<>(LanternEnumTraits.TREE_TYPE,\n                                                () -> BlockTypes.WOODEN_SLAB,\n                                                () -> BlockTypes.DOUBLE_WOODEN_SLAB))\n                                        .add(new PlacementCollisionDetectionBehavior()))\n                                .keysProvider(collection -> collection\n                                        .register(Keys.TREE_TYPE, LanternTreeType.OAK)\n                                )\n                        )\n                        .collisionBox(BoundingBoxes::slab)\n                        .properties(builder -> builder\n                                .add(hardness(2.0))\n                                .add(blastResistance(5.0)))\n                        .build(\"minecraft\", \"wooden_slab\"),\n                blockState -> {\n                    final int type = blockState.getTraitValue(LanternEnumTraits.TREE_TYPE).get().getInternalId();\n                    final int portion = (byte) blockState.getTraitValue(LanternEnumTraits.PORTION_TYPE).get().getInternalId();\n                    return (byte) (portion << 3 | type);\n                });\n        \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n        \/\/\/  Ender Chest  \/\/\/\n        \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n        register(130, simpleBuilder()\n                        .trait(LanternEnumTraits.HORIZONTAL_FACING)\n                        .defaultState(state -> state.withTrait(LanternEnumTraits.HORIZONTAL_FACING, Direction.NORTH).get())\n                        .itemType()\n                        .tileEntityType(() -> TileEntityTypes.ENDER_CHEST)\n                        .properties(builder -> builder\n                                .add(hardness(22.5))\n                                .add(blastResistance(3000.0))\n                                .add(lightEmission(7)))\n                        .translation(\"tile.enderChest.name\")\n                        .collisionBox(BoundingBoxes.chest())\n                        .behaviors(pipeline -> pipeline\n                                .add(new HorizontalRotationPlacementBehavior())\n                                .add(new EnderChestInteractionBehavior()))\n                        .build(\"minecraft\", \"ender_chest\"),\n                this::horizontalFacingData);\n        \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n        \/\/\/ Trapped Chest \/\/\/\n        \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n        register(146, chestBuilder()\n                        .translation(\"tile.chestTrap.name\")\n                        .build(\"minecraft\", \"trapped_chest\"),\n                this::horizontalFacingData);\n        \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n        \/\/\/ Weighted Pressure Plate (Light) \/\/\/\n        \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n        register(147, weightedPressurePlateBuilder()\n                        .translation(\"tile.weightedPlate_light.name\")\n                        .build(\"minecraft\", \"light_weighted_pressure_plate\"),\n                this::weightedPressurePlateData);\n        \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n        \/\/\/ Weighted Pressure Plate (Heavy) \/\/\/\n        \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n        register(148, weightedPressurePlateBuilder()\n                        .translation(\"tile.weightedPlate_heavy.name\")\n                        .build(\"minecraft\", \"heavy_weighted_pressure_plate\"),\n                this::weightedPressurePlateData);\n        \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n        \/\/\/ Redstone Block  \/\/\/\n        \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n        register(152, simpleBuilder()\n                        .itemType()\n                        .properties(builder -> builder\n                                .add(hardness(5.0))\n                                .add(blastResistance(30.0)))\n                        .translation(\"tile.blockRedstone.name\")\n                        .build(\"minecraft\", \"redstone_block\"));\n        \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n        \/\/\/  Quartz Ore  \/\/\/\n        \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n        register(153, simpleBuilder()\n                        .itemType()\n                        .properties(builder -> builder\n                                .add(hardness(3.0))\n                                .add(blastResistance(15.0)))\n                        .translation(\"tile.netherquartz.name\")\n                        .build(\"minecraft\", \"quartz_ore\"));\n        \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n        \/\/\/     Hopper   \/\/\/\n        \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n        register(154, simpleBuilder()\n                        .traits(LanternEnumTraits.HOPPER_FACING, LanternBooleanTraits.ENABLED)\n                        .defaultState(state -> state\n                                .withTrait(LanternEnumTraits.HOPPER_FACING, Direction.DOWN).get()\n                                .withTrait(LanternBooleanTraits.ENABLED, false).get())\n                        .itemType()\n                        .properties(builder -> builder\n                                .add(hardness(3.0))\n                                .add(blastResistance(8.0)))\n                        .translation(\"tile.hopper.name\")\n                        .behaviors(pipeline -> pipeline\n                                .add(new HopperPlacementBehavior()))\n                        .build(\"minecraft\", \"hopper\"),\n                blockState -> {\n                    int data = directionData(blockState.getTraitValue(LanternEnumTraits.HOPPER_FACING).get());\n                    if (!blockState.getTraitValue(LanternBooleanTraits.ENABLED).get()) {\n                        data |= 0x8;\n                    }\n                    return (byte) data;\n                });\n        \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n        \/\/\/  Quartz Block  \/\/\/\n        \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n        register(155, simpleBuilder()\n                        .trait(LanternEnumTraits.QUARTZ_TYPE)\n                        .defaultState(state -> state\n                                .withTrait(LanternEnumTraits.QUARTZ_TYPE, LanternQuartzType.DEFAULT).get())\n                        .itemType(builder -> builder\n                                .keysProvider(collection -> collection\n                                        .register(Keys.QUARTZ_TYPE, LanternQuartzType.DEFAULT)\n                                )\n                        )\n                        .properties(builder -> builder\n                                .add(hardness(0.8))\n                                .add(blastResistance(2.4)))\n                        .translation(TranslationProvider.of(LanternEnumTraits.QUARTZ_TYPE))\n                        .behaviors(pipeline -> pipeline\n                                .add(new QuartzLinesRotationPlacementBehavior()))\n                        .build(\"minecraft\", \"quartz_block\"),\n                blockState -> (byte) blockState.getTraitValue(LanternEnumTraits.QUARTZ_TYPE).get().getInternalId());\n        \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n        \/\/\/    Dropper   \/\/\/\n        \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n        register(158, simpleBuilder()\n                        .traits(LanternEnumTraits.FACING, LanternBooleanTraits.TRIGGERED)\n                        .defaultState(state -> state\n                                .withTrait(LanternEnumTraits.FACING, Direction.NORTH).get()\n                                .withTrait(LanternBooleanTraits.TRIGGERED, false).get())\n                        .itemType()\n                        .properties(builder -> builder\n                                .add(hardness(3.5))\n                                .add(blastResistance(17.5)))\n                        \/\/ .tileEntityType(() -> TileEntityTypes.DROPPER)\n                        .translation(\"tile.dropper.name\")\n                        .behaviors(pipeline -> pipeline\n                                .add(new RotationPlacementBehavior()))\n                        .build(\"minecraft\", \"dropper\"),\n                blockState -> {\n                    int data = directionData(blockState.getTraitValue(LanternEnumTraits.FACING).get());\n                    if (blockState.getTraitValue(LanternBooleanTraits.TRIGGERED).get()) {\n                        data |= 0x8;\n                    }\n                    return (byte) data;\n                });\n        \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n        \/\/\/ Stained Hardended Clay \/\/\/\n        \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n        register(159, dyedBuilder(\"tile.clayHardenedStained.%s.name\")\n                        .properties(builder -> builder\n                                .add(hardness(1.25))\n                                .add(blastResistance(7.0)))\n                        .build(\"minecraft\", \"stained_hardened_clay\"),\n                this::dyedData);\n        \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n        \/\/\/ Stained Glass Pane \/\/\/\n        \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n        register(160, dyedBuilder(\"tile.thinStainedGlass.%s.name\")\n                        .properties(builder -> builder\n                                .add(hardness(0.3))\n                                .add(blastResistance(1.5)))\n                        .build(\"minecraft\", \"stained_glass_pane\"),\n                this::dyedData);\n        \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n        \/\/\/   Leaves 2   \/\/\/\n        \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n        register(161, leavesBuilder(LanternEnumTraits.LEAVES2_TYPE, LanternTreeType.ACACIA)\n                        .build(\"minecraft\", \"leaves2\"),\n                blockState -> leavesData(blockState, blockState.getTraitValue(LanternEnumTraits.LEAVES2_TYPE).get().getInternalId() - 4));\n        \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n        \/\/\/    Log 2     \/\/\/\n        \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n        register(162, logBuilder(LanternEnumTraits.LOG2_TYPE, LanternTreeType.ACACIA)\n                        .build(\"minecraft\", \"log2\"),\n                blockState -> logData(blockState, blockState.getTraitValue(LanternEnumTraits.LOG2_TYPE).get().getInternalId() - 4));\n        \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n        \/\/\/   Barrier    \/\/\/\n        \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n        register(166, simpleBuilder()\n                        .itemType()\n                        .properties(builder -> builder\n                                .add(PropertyProviderCollections.UNBREAKABLE))\n                        .translation(\"tile.barrier.name\")\n                        .build(\"minecraft\", \"barrier\"));\n        \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n        \/\/\/     Carpet    \/\/\/\n        \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n        register(171, dyedBuilder(\"tile.carpet.%s.name\")\n                        .properties(builder -> builder\n                                .add(hardness(0.1))\n                                .add(blastResistance(0.5))\n                                .add(solidMaterial(false)))\n                        .collisionBox(BoundingBoxes.carpet())\n                        .build(\"minecraft\", \"carpet\"),\n                this::dyedData);\n        \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n        \/\/\/ Red Sandstone \/\/\/\n        \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n        register(179, simpleBuilder()\n                        .trait(LanternEnumTraits.SANDSTONE_TYPE)\n                        .defaultState(state -> state.withTrait(LanternEnumTraits.SANDSTONE_TYPE, LanternSandstoneType.DEFAULT).get())\n                        .itemType(builder -> builder\n                                .keysProvider(collection -> collection\n                                        .register(Keys.SANDSTONE_TYPE, LanternSandstoneType.DEFAULT)\n                                )\n                        )\n                        .properties(builder -> builder\n                                .add(hardness(0.8))\n                                .add(blastResistance(4.0)))\n                        .translation(TranslationProvider.of(LanternEnumTraits.SANDSTONE_TYPE))\n                        .build(\"minecraft\", \"red_sandstone\"),\n                blockState -> (byte) blockState.getTraitValue(LanternEnumTraits.SANDSTONE_TYPE).get().getInternalId());\n        \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n        \/\/\/ Double Stone Slab 2 \/\/\/\n        \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n        register(181, doubleStoneSlab(LanternEnumTraits.STONE_SLAB2_TYPE, LanternSlabType.RED_SAND)\n                        .translation(\"tile.stoneSlab2.name\")\n                        .build(\"minecraft\", \"double_stone_slab2\"),\n                blockState -> doubleStoneSlabData(blockState,\n                        blockState.getTraitValue(LanternEnumTraits.STONE_SLAB2_TYPE).get().getInternalId() - 8));\n        \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n        \/\/\/   Stone Slab 2   \/\/\/\n        \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n        register(182, stoneSlab(LanternEnumTraits.STONE_SLAB2_TYPE, LanternSlabType.RED_SAND,\n                () -> BlockTypes.STONE_SLAB2,\n                () -> BlockTypes.DOUBLE_STONE_SLAB2)\n                        .translation(\"tile.stoneSlab2.name\")\n                        .collisionBox(BoundingBoxes::slab)\n                        .build(\"minecraft\", \"stone_slab2\"),\n                blockState -> stoneSlabData(blockState, blockState.getTraitValue(LanternEnumTraits.STONE_SLAB2_TYPE).get().getInternalId() - 8));\n        \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n        \/\/\/   End Rod   \/\/\/\n        \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n        register(198, simpleBuilder()\n                        .itemType()\n                        .properties(builder -> builder\n                                .add(hardness(0.0))\n                                .add(blastResistance(0.0))\n                                .add(lightEmission(14)))\n                        .translation(\"tile.endRod.name\")\n                        .build(\"minecraft\", \"end_rod\"));\n        \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n        \/\/\/  White Shulker Box  \/\/\/\n        \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n        register(219, shulkerBox()\n                        .translation(\"tile.shulkerBoxWhite.name\")\n                        .build(\"minecraft\", \"white_shulker_box\"),\n                this::shulkerBoxData);\n        \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n        \/\/\/  Orange Shulker Box \/\/\/\n        \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n        register(220, shulkerBox()\n                        .translation(\"tile.shulkerBoxOrange.name\")\n                        .build(\"minecraft\", \"orange_shulker_box\"),\n                this::shulkerBoxData);\n        \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n        \/\/\/  Magenta Shulker Box \/\/\/\n        \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n        register(221, shulkerBox()\n                        .translation(\"tile.shulkerBoxMagenta.name\")\n                        .build(\"minecraft\", \"magenta_shulker_box\"),\n                this::shulkerBoxData);\n        \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n        \/\/\/  Light Blue Shulker Box \/\/\/\n        \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n        register(222, shulkerBox()\n                        .translation(\"tile.shulkerBoxLightBlue.name\")\n                        .build(\"minecraft\", \"light_blue_shulker_box\"),\n                this::shulkerBoxData);\n        \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n        \/\/\/  Yellow Shulker Box \/\/\/\n        \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n        register(223, shulkerBox()\n                        .translation(\"tile.shulkerBoxYellow.name\")\n                        .build(\"minecraft\", \"yellow_shulker_box\"),\n                this::shulkerBoxData);\n        \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n        \/\/\/  Lime Shulker Box \/\/\/\n        \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n        register(224, shulkerBox()\n                        .translation(\"tile.shulkerBoxLime.name\")\n                        .build(\"minecraft\", \"lime_shulker_box\"),\n                this::shulkerBoxData);\n        \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n        \/\/\/  Pink Shulker Box \/\/\/\n        \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n        register(225, shulkerBox()\n                        .translation(\"tile.shulkerBoxPink.name\")\n                        .build(\"minecraft\", \"pink_shulker_box\"),\n                this::shulkerBoxData);\n        \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n        \/\/\/  Gray Shulker Box \/\/\/\n        \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n        register(226, shulkerBox()\n                        .translation(\"tile.shulkerBoxGray.name\")\n                        .build(\"minecraft\", \"gray_shulker_box\"),\n                this::shulkerBoxData);\n        \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n        \/\/\/  Gray Shulker Box \/\/\/\n        \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n        register(227, shulkerBox()\n                        .translation(\"tile.shulkerBoxSilver.name\")\n                        .build(\"minecraft\", \"silver_shulker_box\"),\n                this::shulkerBoxData);\n        \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n        \/\/\/  Cyan Shulker Box \/\/\/\n        \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n        register(228, shulkerBox()\n                        .translation(\"tile.shulkerBoxCyan.name\")\n                        .build(\"minecraft\", \"cyan_shulker_box\"),\n                this::shulkerBoxData);\n        \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n        \/\/\/  Purple Shulker Box \/\/\/\n        \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n        register(229, shulkerBox()\n                        .translation(\"tile.shulkerBoxPurple.name\")\n                        .build(\"minecraft\", \"purple_shulker_box\"),\n                this::shulkerBoxData);\n        \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n        \/\/\/  Blue Shulker Box \/\/\/\n        \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n        register(230, shulkerBox()\n                        .translation(\"tile.shulkerBoxBlue.name\")\n                        .build(\"minecraft\", \"blue_shulker_box\"),\n                this::shulkerBoxData);\n        \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n        \/\/\/  Brown Shulker Box \/\/\/\n        \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n        register(231, shulkerBox()\n                        .translation(\"tile.shulkerBoxBrown.name\")\n                        .build(\"minecraft\", \"brown_shulker_box\"),\n                this::shulkerBoxData);\n        \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n        \/\/\/  Green Shulker Box \/\/\/\n        \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n        register(232, shulkerBox()\n                        .translation(\"tile.shulkerBoxGreen.name\")\n                        .build(\"minecraft\", \"green_shulker_box\"),\n                this::shulkerBoxData);\n        \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n        \/\/\/  Red Shulker Box \/\/\/\n        \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n        register(233, shulkerBox()\n                        .translation(\"tile.shulkerBoxRed.name\")\n                        .build(\"minecraft\", \"red_shulker_box\"),\n                this::shulkerBoxData);\n        \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n        \/\/\/  Black Shulker Box \/\/\/\n        \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n        register(234, shulkerBox()\n                        .translation(\"tile.shulkerBoxBlack.name\")\n                        .build(\"minecraft\", \"black_shulker_box\"),\n                this::shulkerBoxData);\n        \/\/\/\/\/\/\/\/\/\/\/\/\/\/\n        \/\/\/  Sign  \/\/\/\n        \/\/\/\/\/\/\/\/\/\/\/\/\/\/\n        register(63, simpleBuilder()\n                        .trait(LanternIntegerTraits.ROTATION)\n                        .defaultState(state -> state\n                                .withTrait(LanternIntegerTraits.ROTATION, 0).get())\n                        .properties(builder -> builder\n                                .add(hardness(1.0))\n                                .add(blastResistance(5.0)))\n                        .behaviors(pipeline -> pipeline\n                                .add(new SignInteractionBehavior()))\n                        .tileEntityType(() -> TileEntityTypes.SIGN)\n                        .build(\"minecraft\", \"standing_sign\"),\n                blockState -> blockState.getTraitValue(LanternIntegerTraits.ROTATION).get().byteValue());\n        register(68, simpleBuilder()\n                        .trait(LanternEnumTraits.HORIZONTAL_FACING)\n                        .defaultState(state -> state\n                                .withTrait(LanternEnumTraits.HORIZONTAL_FACING, Direction.NORTH).get())\n                        .properties(builder -> builder\n                                .add(hardness(1.0))\n                                .add(blastResistance(5.0)))\n                        .behaviors(pipeline -> pipeline\n                                .add(new SignInteractionBehavior()))\n                        .tileEntityType(() -> TileEntityTypes.SIGN)\n                        .build(\"minecraft\", \"wall_sign\"),\n                this::horizontalFacingData);\n        \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n        \/\/\/  Banner  \/\/\/\n        \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n        register(176, simpleBuilder()\n                        .trait(LanternIntegerTraits.ROTATION)\n                        .defaultState(state -> state\n                                .withTrait(LanternIntegerTraits.ROTATION, 0).get())\n                        .properties(builder -> builder\n                                .add(hardness(1.0))\n                                .add(blastResistance(5.0)))\n                        .behaviors(pipeline -> pipeline\n                                .add(new SignInteractionBehavior()))\n                        .tileEntityType(() -> TileEntityTypes.BANNER)\n                        .build(\"minecraft\", \"standing_banner\"),\n                blockState -> blockState.getTraitValue(LanternIntegerTraits.ROTATION).get().byteValue());\n        register(177, simpleBuilder()\n                        .trait(LanternEnumTraits.HORIZONTAL_FACING)\n                        .defaultState(state -> state\n                                .withTrait(LanternEnumTraits.HORIZONTAL_FACING, Direction.NORTH).get())\n                        .properties(builder -> builder\n                                .add(hardness(1.0))\n                                .add(blastResistance(5.0)))\n                        .behaviors(pipeline -> pipeline\n                                .add(new SignInteractionBehavior()))\n                        .tileEntityType(() -> TileEntityTypes.BANNER)\n                        .build(\"minecraft\", \"wall_banner\"),\n                this::horizontalFacingData);\n        \/\/ @formatter:on\n    }","code":"@Override\n    public void registerDefaults() {\n       \n       \n       \n       \n        register(0, builder()\n                        .properties(PropertyProviderCollections.DEFAULT_GAS)\n                        .translation(\"tile.air.name\")\n                        .build(\"minecraft\", \"air\"));\n       \n       \n       \n        register(1, simpleBuilder()\n                        .trait(LanternEnumTraits.STONE_TYPE)\n                        .defaultState(state -> state.withTrait(LanternEnumTraits.STONE_TYPE, LanternStoneType.STONE).get())\n                        .itemType(builder -> builder\n                                .keysProvider(collection -> collection\n                                        .register(Keys.STONE_TYPE, LanternStoneType.STONE)\n                                )\n                        )\n                        .properties(builder -> builder\n                                .add(hardness(1.5))\n                                .add(blastResistance(30.0)))\n                        .translation(TranslationProvider.of(LanternEnumTraits.STONE_TYPE))\n                        .build(\"minecraft\", \"stone\"),\n                blockState -> (byte) blockState.getTraitValue(LanternEnumTraits.STONE_TYPE).get().getInternalId());\n       \n       \n       \n        register(2, simpleBuilder()\n                        .trait(LanternBooleanTraits.SNOWY)\n                        .extendedStateProvider(new SnowyExtendedBlockStateProvider())\n                        .defaultState(state -> state.withTrait(LanternBooleanTraits.SNOWY, false).get())\n                        .itemType()\n                        .properties(builder -> builder\n                                .add(hardness(0.6))\n                                .add(blastResistance(3.0)))\n                        .translation(\"tile.grass.name\")\n                        .build(\"minecraft\", \"grass\"));\n       \n       \n       \n        register(3, simpleBuilder()\n                        .traits(LanternEnumTraits.DIRT_TYPE, LanternBooleanTraits.SNOWY)\n                        .defaultState(state -> state\n                                .withTrait(LanternEnumTraits.DIRT_TYPE, LanternDirtType.DIRT).get()\n                                .withTrait(LanternBooleanTraits.SNOWY, false).get())\n                        .extendedStateProvider(new SnowyExtendedBlockStateProvider())\n                        .itemType(builder -> builder\n                                .keysProvider(collection -> collection\n                                        .register(Keys.DIRT_TYPE, LanternDirtType.DIRT)\n                                )\n                        )\n                        .properties(builder -> builder\n                                .add(hardness(0.5))\n                                .add(blastResistance(2.5)))\n                        .translation(TranslationProvider.of(LanternEnumTraits.DIRT_TYPE))\n                        .build(\"minecraft\", \"dirt\"),\n                blockState -> (byte) blockState.getTraitValue(LanternEnumTraits.DIRT_TYPE).get().getInternalId());\n       \n       \n       \n        register(4, simpleBuilder()\n                        .itemType()\n                        .properties(builder -> builder\n                                .add(hardness(2.0))\n                                .add(blastResistance(3.0)))\n                        .translation(\"tile.stonebrick.name\")\n                        .build(\"minecraft\", \"cobblestone\"));\n       \n       \n       \n        register(5, simpleBuilder()\n                        .trait(LanternEnumTraits.TREE_TYPE)\n                        .defaultState(state -> state.withTrait(LanternEnumTraits.TREE_TYPE, LanternTreeType.OAK).get())\n                        .itemType(builder -> builder\n                                .keysProvider(collection -> collection\n                                        .register(Keys.TREE_TYPE, LanternTreeType.OAK)\n                                )\n                        )\n                        .properties(builder -> builder\n                                .add(hardness(2.0))\n                                .add(blastResistance(5.0))\n                                .add(flammableInfo(5, 20)))\n                        .translation(TranslationProvider.of(LanternEnumTraits.TREE_TYPE, type ->\n                                tr(\"tile.planks.\" + type.getTranslationKeyBase() + \".name\")))\n                        .build(\"minecraft\", \"planks\"),\n                blockState -> (byte) blockState.getTraitValue(LanternEnumTraits.TREE_TYPE).get().getInternalId());\n       \n       \n       \n        register(6, simpleBuilder()\n                        .traits(LanternEnumTraits.TREE_TYPE, LanternIntegerTraits.SAPLING_GROWTH_STAGE)\n                        .defaultState(state -> state\n                                .withTrait(LanternEnumTraits.TREE_TYPE, LanternTreeType.OAK).get()\n                                .withTrait(LanternIntegerTraits.SAPLING_GROWTH_STAGE, 0).get())\n                        .itemType(builder -> builder\n                                .keysProvider(collection -> collection\n                                        .register(Keys.TREE_TYPE, LanternTreeType.OAK)\n                                )\n                        )\n                        .properties(builder -> builder\n                                .add(PASSABLE)\n                                .add(INSTANT_BROKEN))\n                        .translation(TranslationProvider.of(LanternEnumTraits.TREE_TYPE, type ->\n                                tr(\"tile.sapling.\" + type.getTranslationKeyBase() + \".name\")))\n                        .build(\"minecraft\", \"sapling\"),\n                blockState -> {\n                    final int type = blockState.getTraitValue(LanternEnumTraits.TREE_TYPE).get().getInternalId();\n                    final int stage = blockState.getTraitValue(LanternIntegerTraits.SAPLING_GROWTH_STAGE).get();\n                    return (byte) (stage << 3 | type);\n                });\n       \n       \n       \n        register(7, simpleBuilder()\n                        .itemType()\n                        .properties(builder -> builder\n                                .add(PropertyProviderCollections.UNBREAKABLE))\n                        .translation(\"tile.bedrock.name\")\n                        .build(\"minecraft\", \"bedrock\"));\n       \n       \n       \n        register(12, simpleBuilder()\n                        .trait(LanternEnumTraits.SAND_TYPE)\n                        .defaultState(state -> state.withTrait(LanternEnumTraits.SAND_TYPE, LanternSandType.NORMAL).get())\n                        .itemType(builder -> builder\n                                .keysProvider(collection -> collection\n                                        .register(Keys.SAND_TYPE, LanternSandType.NORMAL)\n                                )\n                        )\n                        .properties(builder -> builder\n                                .add(hardness(0.5))\n                                .add(blastResistance(2.5)))\n                        .translation(TranslationProvider.of(LanternEnumTraits.SAND_TYPE))\n                        .build(\"minecraft\", \"sand\"),\n                blockState -> (byte) blockState.getTraitValue(LanternEnumTraits.SAND_TYPE).get().getInternalId());\n       \n       \n       \n       \n        register(13, simpleBuilder()\n                        .itemType()\n                        .properties(builder -> builder\n                                .add(hardness(0.6))\n                                .add(blastResistance(3.0)))\n                        .translation(\"tile.gravel.name\")\n                        .build(\"minecraft\", \"gravel\"));\n       \n       \n       \n       \n        register(14, simpleBuilder()\n                        .itemType()\n                        .properties(builder -> builder\n                                .add(hardness(3.0))\n                                .add(blastResistance(15.0)))\n                        .translation(\"tile.oreGold.name\")\n                        .build(\"minecraft\", \"gold_ore\"));\n       \n       \n       \n        register(15, simpleBuilder()\n                        .itemType()\n                        .properties(builder -> builder\n                                .add(hardness(3.0))\n                                .add(blastResistance(15.0)))\n                        .translation(\"tile.oreIron.name\")\n                        .build(\"minecraft\", \"iron_ore\"));\n       \n       \n       \n        register(16, simpleBuilder()\n                        .itemType()\n                        .properties(builder -> builder\n                                .add(hardness(3.0))\n                                .add(blastResistance(15.0)))\n                        .translation(\"tile.oreCoal.name\")\n                        .build(\"minecraft\", \"coal_ore\"));\n       \n       \n       \n        register(17, logBuilder(LanternEnumTraits.LOG1_TYPE, LanternTreeType.OAK)\n                        .build(\"minecraft\", \"log\"),\n                blockState -> logData(blockState, blockState.getTraitValue(LanternEnumTraits.LOG1_TYPE).get().getInternalId()));\n       \n       \n       \n        register(18, leavesBuilder(LanternEnumTraits.LEAVES1_TYPE, LanternTreeType.OAK)\n                        .build(\"minecraft\", \"leaves\"),\n                blockState -> leavesData(blockState, blockState.getTraitValue(LanternEnumTraits.LEAVES1_TYPE).get().getInternalId()));\n       \n       \n       \n        register(19, simpleBuilder()\n                        .trait(LanternBooleanTraits.IS_WET)\n                        .defaultState(state -> state.withTrait(LanternBooleanTraits.IS_WET, false).get())\n                        .itemType(builder -> builder\n                                .keysProvider(collection -> collection\n                                        .register(Keys.IS_WET, false)\n                                )\n                        )\n                        .properties(builder -> builder\n                                .add(hardness(0.6))\n                                .add(blastResistance(3.0)))\n                        .translation(new SpongeTranslationProvider())\n                        .build(\"minecraft\", \"sponge\"),\n                blockState -> (byte) (blockState.getTraitValue(LanternBooleanTraits.IS_WET).get() ? 1 : 0));\n       \n       \n       \n        register(20, simpleBuilder()\n                        .itemType()\n                        .properties(builder -> builder\n                                .add(hardness(0.3))\n                                .add(blastResistance(1.5)))\n                        .translation(\"tile.glass.name\")\n                        .build(\"minecraft\", \"glass\"));\n       \n       \n       \n        register(21, simpleBuilder()\n                        .itemType()\n                        .properties(builder -> builder\n                                .add(hardness(3.0))\n                                .add(blastResistance(15.0)))\n                        .translation(\"tile.oreLapis.name\")\n                        .build(\"minecraft\", \"lapis_ore\"));\n       \n       \n       \n        register(22, simpleBuilder()\n                        .itemType()\n                        .properties(builder -> builder\n                                .add(hardness(3.0))\n                                .add(blastResistance(15.0)))\n                        .translation(\"tile.blockLapis.name\")\n                        .build(\"minecraft\", \"lapis_block\"));\n       \n       \n       \n        register(23, simpleBuilder()\n                        .traits(LanternEnumTraits.FACING, LanternBooleanTraits.TRIGGERED)\n                        .defaultState(state -> state\n                                .withTrait(LanternEnumTraits.FACING, Direction.NORTH).get()\n                                .withTrait(LanternBooleanTraits.TRIGGERED, false).get())\n                        .itemType()\n                        .properties(builder -> builder\n                                .add(hardness(3.5))\n                                .add(blastResistance(17.5)))\n                       \n                        .translation(\"tile.dispenser.name\")\n                        .behaviors(pipeline -> pipeline\n                                .add(new RotationPlacementBehavior()))\n                        .build(\"minecraft\", \"dispenser\"),\n                blockState -> {\n                    int data = directionData(blockState.getTraitValue(LanternEnumTraits.FACING).get());\n                    if (blockState.getTraitValue(LanternBooleanTraits.TRIGGERED).get()) {\n                        data |= 0x8;\n                    }\n                    return (byte) data;\n                });\n       \n       \n       \n        register(24, simpleBuilder()\n                        .trait(LanternEnumTraits.SANDSTONE_TYPE)\n                        .defaultState(state -> state.withTrait(LanternEnumTraits.SANDSTONE_TYPE, LanternSandstoneType.DEFAULT).get())\n                        .itemType(builder -> builder\n                                .keysProvider(collection -> collection\n                                        .register(Keys.SANDSTONE_TYPE, LanternSandstoneType.DEFAULT)\n                                )\n                        )\n                        .properties(builder -> builder\n                                .add(hardness(0.8))\n                                .add(blastResistance(4.0)))\n                        .translation(TranslationProvider.of(LanternEnumTraits.SANDSTONE_TYPE))\n                        .build(\"minecraft\", \"sandstone\"),\n                blockState -> (byte) blockState.getTraitValue(LanternEnumTraits.SANDSTONE_TYPE).get().getInternalId());\n       \n       \n       \n        register(25, simpleBuilder()\n                        .itemType()\n                        .properties(builder -> builder\n                                .add(hardness(0.8))\n                                .add(blastResistance(4.0)))\n                        .translation(\"tile.musicBlock.name\")\n                        .tileEntityType(() -> TileEntityTypes.NOTE)\n                        .behaviors(pipeline -> pipeline\n                                .add(new NoteBlockInteractionBehavior()))\n                        .build(\"minecraft\", \"noteblock\"));\n       \n       \n       \n        register(26, simpleBuilder()\n                        .traits(LanternEnumTraits.HORIZONTAL_FACING, LanternEnumTraits.BED_PART, LanternBooleanTraits.OCCUPIED)\n                        .defaultState(state -> state\n                                .withTrait(LanternEnumTraits.HORIZONTAL_FACING, Direction.NORTH).get()\n                                .withTrait(LanternEnumTraits.BED_PART, LanternBedPart.FOOT).get()\n                                .withTrait(LanternBooleanTraits.OCCUPIED, false).get())\n                        .properties(builder -> builder\n                                .add(hardness(0.2))\n                                .add(blastResistance(1.0)))\n                        .translation(\"tile.bed.name\")\n                        .build(\"minecraft\", \"bed\"),\n                blockState -> {\n                    final Direction facing = blockState.getTraitValue(LanternEnumTraits.HORIZONTAL_FACING).get();\n                    int type = facing == Direction.SOUTH  ? 0 : facing == Direction.WEST ? 1 :\n                            facing == Direction.NORTH ? 2 : facing == Direction.EAST ? 3 : -1;\n                    checkArgument(type != -1);\n                    if (blockState.getTraitValue(LanternBooleanTraits.OCCUPIED).get()) {\n                        type |= 0x4;\n                    }\n                    if (blockState.getTraitValue(LanternEnumTraits.BED_PART).get() == LanternBedPart.HEAD) {\n                        type |= 0x8;\n                    }\n                    return (byte) type;\n                });\n       \n       \n       \n        register(27, simpleBuilder()\n                        .traits(LanternEnumTraits.STRAIGHT_RAIL_DIRECTION, LanternBooleanTraits.POWERED)\n                        .defaultState(state -> state\n                                .withTrait(LanternEnumTraits.STRAIGHT_RAIL_DIRECTION, LanternRailDirection.NORTH_SOUTH).get()\n                                .withTrait(LanternBooleanTraits.POWERED, false).get())\n                        .itemType()\n                        .selectionBox(BoundingBoxes::rail)\n                        .properties(builder -> builder\n                                .add(PASSABLE)\n                                .add(hardness(0.7))\n                                .add(blastResistance(3.5)))\n                        .translation(\"tile.goldenRail.name\")\n                        .build(\"minecraft\", \"golden_rail\"),\n                blockState -> {\n                    int type = blockState.getTraitValue(LanternEnumTraits.STRAIGHT_RAIL_DIRECTION).get().getInternalId();\n                    if (blockState.getTraitValue(LanternBooleanTraits.POWERED).get()) {\n                        type |= 0x8;\n                    }\n                    return (byte) type;\n                });\n       \n       \n       \n        register(28, simpleBuilder()\n                        .traits(LanternEnumTraits.STRAIGHT_RAIL_DIRECTION, LanternBooleanTraits.POWERED)\n                        .defaultState(state -> state\n                                .withTrait(LanternEnumTraits.STRAIGHT_RAIL_DIRECTION, LanternRailDirection.NORTH_SOUTH).get()\n                                .withTrait(LanternBooleanTraits.POWERED, false).get())\n                        .itemType()\n                        .selectionBox(BoundingBoxes::rail)\n                        .properties(builder -> builder\n                                .add(PASSABLE)\n                                .add(hardness(0.7))\n                                .add(blastResistance(3.5)))\n                        .translation(\"tile.detectorRail.name\")\n                        .build(\"minecraft\", \"detector_rail\"),\n                blockState -> {\n                    int type = blockState.getTraitValue(LanternEnumTraits.STRAIGHT_RAIL_DIRECTION).get().getInternalId();\n                    if (blockState.getTraitValue(LanternBooleanTraits.POWERED).get()) {\n                        type |= 0x8;\n                    }\n                    return (byte) type;\n                });\n       \n       \n       \n       \n        register(30, simpleBuilder()\n                        .itemType()\n                        .properties(builder -> builder\n                                .add(PASSABLE)\n                                .add(hardness(4.0))\n                                .add(blastResistance(20.0)))\n                        .translation(\"tile.web.name\")\n                        .build(\"minecraft\", \"web\"));\n       \n       \n       \n        register(31, simpleBuilder()\n                        .traits(LanternEnumTraits.SHRUB_TYPE)\n                            .defaultState(state -> state\n                                    .withTrait(LanternEnumTraits.SHRUB_TYPE, LanternShrubType.DEAD_BUSH).get())\n                        .itemType(builder -> builder\n                                .keysProvider(collection -> collection\n                                        .register(Keys.SHRUB_TYPE, LanternShrubType.DEAD_BUSH)))\n                        .selectionBox(BoundingBoxes.bush())\n                        .properties(builder -> builder\n                                .add(INSTANT_BROKEN)\n                                .add(PASSABLE)\n                                .add(replaceable(true)))\n                        .translation(\"tile.tallgrass.name\")\n                        .build(\"minecraft\", \"tallgrass\"),\n                blockState -> (byte) blockState.getTraitValue(LanternEnumTraits.SHRUB_TYPE).get().getInternalId());\n       \n       \n       \n        register(32, simpleBuilder()\n                        .properties(builder -> builder\n                                .add(INSTANT_BROKEN)\n                                .add(PASSABLE)\n                                .add(replaceable(true)))\n                        .selectionBox(BoundingBoxes.bush())\n                        .itemType()\n                        .translation(\"tile.deadbush.name\")\n                        .build(\"minecraft\", \"deadbush\"));\n       \n       \n       \n       \n       \n        register(35, dyedBuilder(\"tile.wool.%s.name\")\n                        .properties(builder -> builder\n                                .add(hardness(0.8))\n                                .add(blastResistance(4.0)))\n                        .build(\"minecraft\", \"wool\"),\n                this::dyedData);\n       \n       \n       \n       \n        register(37, simpleBuilder()\n                        .traits(LanternEnumTraits.YELLOW_FLOWER_TYPE)\n                        .defaultState(state -> state\n                                .withTrait(LanternEnumTraits.YELLOW_FLOWER_TYPE, LanternPlantType.DANDELION).get())\n                        .itemType(builder -> builder\n                                .keysProvider(collection -> collection\n                                        .register(Keys.PLANT_TYPE, LanternPlantType.DANDELION)))\n                        .selectionBox(BoundingBoxes.bush())\n                        .properties(builder -> builder\n                                .add(INSTANT_BROKEN)\n                                .add(PASSABLE))\n                        .translation(TranslationProvider.of(LanternEnumTraits.YELLOW_FLOWER_TYPE))\n                        .build(\"minecraft\", \"yellow_flower\"),\n                blockState -> (byte) blockState.getTraitValue(LanternEnumTraits.YELLOW_FLOWER_TYPE).get().getInternalId());\n       \n       \n       \n        register(38, simpleBuilder()\n                        .traits(LanternEnumTraits.RED_FLOWER_TYPE)\n                        .defaultState(state -> state\n                                .withTrait(LanternEnumTraits.RED_FLOWER_TYPE, LanternPlantType.POPPY).get())\n                        .itemType(builder -> builder\n                                .keysProvider(collection -> collection\n                                        .register(Keys.PLANT_TYPE, LanternPlantType.POPPY)))\n                        .selectionBox(BoundingBoxes.bush())\n                        .properties(builder -> builder\n                                .add(INSTANT_BROKEN)\n                                .add(PASSABLE))\n                        .translation(TranslationProvider.of(LanternEnumTraits.RED_FLOWER_TYPE))\n                        .build(\"minecraft\", \"red_flower\"),\n                blockState -> (byte) blockState.getTraitValue(LanternEnumTraits.RED_FLOWER_TYPE).get().getInternalId());\n       \n       \n       \n        register(39, simpleBuilder()\n                        .selectionBox(BoundingBoxes.bush())\n                        .properties(builder -> builder\n                                .add(INSTANT_BROKEN)\n                                .add(PASSABLE)\n                                .add(lightEmission(1)))\n                        .translation(\"tile.mushroom.name\")\n                        .build(\"minecraft\", \"brown_mushroom\"));\n       \n       \n       \n        register(40, simpleBuilder()\n                        .selectionBox(BoundingBoxes.bush())\n                        .properties(builder -> builder\n                                .add(INSTANT_BROKEN)\n                                .add(PASSABLE))\n                        .translation(\"tile.mushroom.name\")\n                        .build(\"minecraft\", \"red_mushroom\"));\n       \n       \n       \n        register(41, simpleBuilder()\n                        .itemType()\n                        .properties(builder -> builder\n                                .add(hardness(3.0))\n                                .add(blastResistance(10.0)))\n                        .translation(\"tile.blockGold.name\")\n                        .build(\"minecraft\", \"gold_block\"));\n       \n       \n       \n        register(42, simpleBuilder()\n                        .itemType()\n                        .properties(builder -> builder\n                                .add(hardness(5.0))\n                                .add(blastResistance(10.0)))\n                        .translation(\"tile.blockIron.name\")\n                        .build(\"minecraft\", \"iron_block\"));\n       \n       \n       \n        register(43, doubleStoneSlab(LanternEnumTraits.STONE_SLAB1_TYPE, LanternSlabType.STONE)\n                        .translation(\"tile.stoneSlab.name\")\n                        .build(\"minecraft\", \"double_stone_slab\"),\n                blockState -> doubleStoneSlabData(blockState, blockState.getTraitValue(LanternEnumTraits.STONE_SLAB1_TYPE).get().getInternalId()));\n       \n       \n       \n        register(44, stoneSlab(LanternEnumTraits.STONE_SLAB1_TYPE, LanternSlabType.STONE,\n                () -> BlockTypes.STONE_SLAB,\n                () -> BlockTypes.DOUBLE_STONE_SLAB)\n                        .translation(\"tile.stoneSlab.name\")\n                        .collisionBox(BoundingBoxes::slab)\n                        .build(\"minecraft\", \"stone_slab\"),\n                blockState -> stoneSlabData(blockState, blockState.getTraitValue(LanternEnumTraits.STONE_SLAB1_TYPE).get().getInternalId()));\n       \n       \n       \n        register(45, simpleBuilder()\n                        .itemType()\n                        .properties(builder -> builder\n                                .add(hardness(2.0))\n                                .add(blastResistance(10.0)))\n                        .translation(\"tile.brick.name\")\n                        .build(\"minecraft\", \"brick_block\"));\n       \n       \n       \n        register(46, simpleBuilder()\n                        .trait(LanternBooleanTraits.EXPLODE)\n                        .defaultState(state -> state\n                                .withTrait(LanternBooleanTraits.EXPLODE, false).get())\n                        .itemType()\n                        .properties(builder -> builder\n                                .add(INSTANT_BROKEN))\n                        .translation(\"tile.tnt.name\")\n                        .build(\"minecraft\", \"tnt\"),\n                blockState -> (byte) (blockState.getTraitValue(LanternBooleanTraits.EXPLODE).get() ? 1 : 0));\n       \n       \n       \n        register(47, simpleBuilder()\n                        .itemType()\n                        .properties(builder -> builder\n                                .add(hardness(1.5))\n                                .add(blastResistance(7.5)))\n                        .translation(\"tile.bookshelf.name\")\n                        .build(\"minecraft\", \"bookshelf\"));\n       \n       \n       \n        register(48, simpleBuilder()\n                        .itemType()\n                        .properties(builder -> builder\n                                .add(hardness(2.0))\n                                .add(blastResistance(10.0)))\n                        .translation(\"tile.stoneMoss.name\")\n                        .build(\"minecraft\", \"mossy_cobblestone\"));\n       \n       \n       \n        register(49, simpleBuilder()\n                        .itemType()\n                        .properties(builder -> builder\n                                .add(hardness(50.0))\n                                .add(blastResistance(2000.0)))\n                        .translation(\"tile.obsidian.name\")\n                        .build(\"minecraft\", \"obsidian\"));\n       \n       \n       \n        register(50, builder()\n                        .trait(LanternEnumTraits.TORCH_FACING)\n                            .defaultState(state -> state\n                                    .withTrait(LanternEnumTraits.TORCH_FACING, Direction.UP).get())\n                        .itemType()\n                        .properties(builder -> builder\n                                .add(PASSABLE)\n                                .add(INSTANT_BROKEN))\n                        .translation(\"tile.torch.name\")\n                        .selectionBox(BoundingBoxes::torch)\n                        .behaviors(pipeline -> pipeline\n                                .add(new BlockSnapshotProviderPlaceBehavior())\n                                .add(new TorchPlacementBehavior())\n                                .add(new SimpleBreakBehavior()))\n                        .build(\"minecraft\", \"torch\"),\n                blockState -> {\n                    final Direction direction = blockState.getTraitValue(LanternEnumTraits.TORCH_FACING).get();\n                    switch (direction) {\n                        case EAST:\n                            return (byte) 1;\n                        case WEST:\n                            return (byte) 2;\n                        case SOUTH:\n                            return (byte) 3;\n                        case NORTH:\n                            return (byte) 4;\n                        case UP:\n                            return (byte) 5;\n                        default:\n                            throw new IllegalArgumentException();\n                    }\n                });\n       \n       \n       \n        register(51, simpleBuilder()\n                        .properties(builder -> builder\n                                .add(PASSABLE)\n                                .add(INSTANT_BROKEN)\n                                .add(lightEmission(15)))\n                        .collisionBox(BoundingBoxes.NULL)\n                        .translation(\"tile.fire.name\")\n                        .build(\"minecraft\", \"fire\"));\n       \n       \n       \n        register(52, simpleBuilder()\n                        .properties(builder -> builder\n                                .add(hardness(5.0))\n                                .add(blastResistance(25.0)))\n                        .translation(\"tile.mobSpawner.name\")\n                        .build(\"minecraft\", \"mob_spawner\"));\n       \n       \n       \n       \n        register(54, chestBuilder()\n                        .translation(\"tile.chest.name\")\n                        .build(\"minecraft\", \"chest\"),\n                this::horizontalFacingData);\n       \n       \n       \n        register(55, simpleBuilder()\n                        .traits(LanternIntegerTraits.POWER)\n                        .selectionBox(new AABB(0, 0, 0, 1.0, 0.0625, 1.0))\n                        .properties(builder -> builder\n                                .add(PASSABLE)\n                                .add(INSTANT_BROKEN))\n                        .defaultState(state -> state\n                                .withTrait(LanternIntegerTraits.POWER, 0).get())\n                        .translation(\"tile.redstoneDust.name\")\n                        .build(\"minecraft\", \"redstone_wire\"),\n                state -> state.get(Keys.POWER).get().byteValue());\n       \n       \n       \n        register(56, simpleBuilder()\n                        .itemType()\n                        .properties(builder -> builder\n                                .add(hardness(3.0))\n                                .add(blastResistance(5.0)))\n                        .translation(\"tile.oreDiamond.name\")\n                        .build(\"minecraft\", \"diamond_ore\"));\n       \n       \n       \n        register(57, simpleBuilder()\n                        .itemType()\n                        .properties(builder -> builder\n                                .add(hardness(5.0))\n                                .add(blastResistance(10.0)))\n                        .translation(\"tile.blockDiamond.name\")\n                        .build(\"minecraft\", \"diamond_block\"));\n       \n       \n       \n        register(58, simpleBuilder()\n                        .itemType()\n                        .properties(builder -> builder\n                                .add(hardness(2.5))\n                                .add(blastResistance(12.5)))\n                        .translation(\"tile.workbench.name\")\n                        .behaviors(pipeline -> pipeline\n                                .add(new CraftingTableInteractionBehavior()))\n                        .build(\"minecraft\", \"crafting_table\"));\n       \n       \n       \n       \n        register(60, simpleBuilder()\n                        .collisionBox(BoundingBoxes.farmland())\n                        .trait(LanternIntegerTraits.MOISTURE)\n                        .properties(builder -> builder\n                                .add(hardness(0.6))\n                                .add(blastResistance(3.0)))\n                        .defaultState(state ->\n                                state.withTrait(LanternIntegerTraits.MOISTURE, 0).get())\n                        .translation(\"tile.farmland.name\")\n                        .build(\"minecraft\", \"farmland\"),\n                state -> state.getTraitValue(LanternIntegerTraits.MOISTURE).get().byteValue());\n       \n       \n       \n        register(61, furnaceBuilder()\n                        .itemType()\n                        .translation(\"tile.furnace.name\")\n                        .build(\"minecraft\", \"furnace\"),\n                this::directionData);\n       \n       \n       \n        register(62, furnaceBuilder()\n                        .properties(builder -> builder\n                                .add(lightEmission(13)))\n                        .translation(\"tile.furnace.name\")\n                        .build(\"minecraft\", \"lit_furnace\"),\n                this::directionData);\n       \n       \n       \n        register(70, pressurePlateBuilder()\n                        .translation(\"tile.pressurePlateStone.name\")\n                        .build(\"minecraft\", \"stone_pressure_plate\"),\n                this::pressurePlateData);\n       \n       \n       \n        register(72, pressurePlateBuilder()\n                        .translation(\"tile.pressurePlateWood.name\")\n                        .build(\"minecraft\", \"wooden_pressure_plate\"),\n                this::pressurePlateData);\n       \n       \n       \n        register(84, simpleBuilder()\n                        .itemType()\n                        .traits(LanternBooleanTraits.HAS_RECORD)\n                        .defaultState(state -> state\n                                .withTrait(LanternBooleanTraits.HAS_RECORD, false).get())\n                        .properties(builder -> builder\n                                .add(hardness(2.0))\n                                .add(blastResistance(10.0)))\n                        .tileEntityType(() -> TileEntityTypes.JUKEBOX)\n                        .translation(\"tile.jukebox.name\")\n                        .behaviors(pipeline -> pipeline\n                                .add(new JukeboxInteractionBehavior()))\n                        .build(\"minecraft\", \"jukebox\"),\n                state -> (byte) (state.getTraitValue(LanternBooleanTraits.HAS_RECORD).get() ? 1 : 0));\n       \n       \n       \n        register(86, pumpkinBuilder()\n                        .itemType(builder -> builder\n                                .properties(properties -> properties\n                                        .add(equipmentType(EquipmentTypes.HEADWEAR))))\n                        .translation(\"tile.pumpkin.name\")\n                        .build(\"minecraft\", \"pumpkin\"),\n                this::horizontalDirectionData);\n       \n       \n       \n        register(87, simpleBuilder()\n                        .itemType()\n                        .properties(builder -> builder\n                                .add(hardness(0.4))\n                                .add(blastResistance(2.0)))\n                        .translation(\"tile.hellrock.name\")\n                        .build(\"minecraft\", \"netherrack\"));\n       \n       \n       \n        register(91, pumpkinBuilder()\n                        .properties(builder -> builder\n                                .add(lightEmission(15)))\n                        .translation(\"tile.litpumpkin.name\")\n                        .build(\"minecraft\", \"lit_pumpkin\"),\n                this::horizontalDirectionData);\n       \n       \n       \n        register(95, dyedBuilder(\"tile.stainedGlass.%s.name\")\n                        .properties(builder -> builder\n                                .add(hardness(0.3))\n                                .add(blastResistance(1.5)))\n                        .build(\"minecraft\", \"stained_glass\"),\n                this::dyedData);\n       \n       \n       \n        register(101, simpleBuilder()\n                       \n                        .itemType()\n                        .properties(builder -> builder\n                                .add(hardness(5.0))\n                                .add(blastResistance(10.0)))\n                        .translation(\"tile.fenceIron.name\")\n                        .build(\"minecraft\", \"iron_bars\"));\n       \n       \n       \n        register(121, simpleBuilder()\n                        .itemType()\n                        .properties(builder -> builder\n                                .add(hardness(3.0))\n                                .add(blastResistance(15.0)))\n                        .translation(\"tile.whiteStone.name\")\n                        .build(\"minecraft\", \"end_stone\"));\n       \n       \n       \n        register(125, simpleBuilder()\n                        .traits(LanternEnumTraits.TREE_TYPE)\n                        .defaultState(state -> state\n                                .withTrait(LanternEnumTraits.TREE_TYPE, LanternTreeType.OAK).get())\n                        .translation(TranslationProvider.of(LanternEnumTraits.TREE_TYPE, type ->\n                                tr(\"tile.woodSlab.\" + type.getTranslationKeyBase() + \".name\")))\n                        .itemType(builder -> builder\n                                .keysProvider(collection -> collection\n                                        .register(Keys.TREE_TYPE, LanternTreeType.OAK)\n                                )\n                        )\n                        .properties(builder -> builder\n                                .add(hardness(2.0))\n                                .add(blastResistance(5.0)))\n                        .build(\"minecraft\", \"double_wooden_slab\"),\n                blockState -> (byte) blockState.getTraitValue(LanternEnumTraits.TREE_TYPE).get().getInternalId());\n       \n       \n       \n        register(126, simpleBuilder()\n                        .traits(LanternEnumTraits.PORTION_TYPE, LanternEnumTraits.TREE_TYPE)\n                        .defaultState(state -> state\n                                .withTrait(LanternEnumTraits.PORTION_TYPE, LanternPortionType.BOTTOM).get()\n                                .withTrait(LanternEnumTraits.TREE_TYPE, LanternTreeType.OAK).get())\n                        .translation(TranslationProvider.of(LanternEnumTraits.TREE_TYPE, type ->\n                                tr(\"tile.woodSlab.\" + type.getTranslationKeyBase() + \".name\")))\n                        .itemType(builder -> builder\n                                .behaviors(pipeline -> pipeline\n                                        .add(new SlabItemInteractionBehavior<>(LanternEnumTraits.TREE_TYPE,\n                                                () -> BlockTypes.WOODEN_SLAB,\n                                                () -> BlockTypes.DOUBLE_WOODEN_SLAB))\n                                        .add(new PlacementCollisionDetectionBehavior()))\n                                .keysProvider(collection -> collection\n                                        .register(Keys.TREE_TYPE, LanternTreeType.OAK)\n                                )\n                        )\n                        .collisionBox(BoundingBoxes::slab)\n                        .properties(builder -> builder\n                                .add(hardness(2.0))\n                                .add(blastResistance(5.0)))\n                        .build(\"minecraft\", \"wooden_slab\"),\n                blockState -> {\n                    final int type = blockState.getTraitValue(LanternEnumTraits.TREE_TYPE).get().getInternalId();\n                    final int portion = (byte) blockState.getTraitValue(LanternEnumTraits.PORTION_TYPE).get().getInternalId();\n                    return (byte) (portion << 3 | type);\n                });\n       \n       \n       \n        register(130, simpleBuilder()\n                        .trait(LanternEnumTraits.HORIZONTAL_FACING)\n                        .defaultState(state -> state.withTrait(LanternEnumTraits.HORIZONTAL_FACING, Direction.NORTH).get())\n                        .itemType()\n                        .tileEntityType(() -> TileEntityTypes.ENDER_CHEST)\n                        .properties(builder -> builder\n                                .add(hardness(22.5))\n                                .add(blastResistance(3000.0))\n                                .add(lightEmission(7)))\n                        .translation(\"tile.enderChest.name\")\n                        .collisionBox(BoundingBoxes.chest())\n                        .behaviors(pipeline -> pipeline\n                                .add(new HorizontalRotationPlacementBehavior())\n                                .add(new EnderChestInteractionBehavior()))\n                        .build(\"minecraft\", \"ender_chest\"),\n                this::horizontalFacingData);\n       \n       \n       \n        register(146, chestBuilder()\n                        .translation(\"tile.chestTrap.name\")\n                        .build(\"minecraft\", \"trapped_chest\"),\n                this::horizontalFacingData);\n       \n       \n       \n        register(147, weightedPressurePlateBuilder()\n                        .translation(\"tile.weightedPlate_light.name\")\n                        .build(\"minecraft\", \"light_weighted_pressure_plate\"),\n                this::weightedPressurePlateData);\n       \n       \n       \n        register(148, weightedPressurePlateBuilder()\n                        .translation(\"tile.weightedPlate_heavy.name\")\n                        .build(\"minecraft\", \"heavy_weighted_pressure_plate\"),\n                this::weightedPressurePlateData);\n       \n       \n       \n        register(152, simpleBuilder()\n                        .itemType()\n                        .properties(builder -> builder\n                                .add(hardness(5.0))\n                                .add(blastResistance(30.0)))\n                        .translation(\"tile.blockRedstone.name\")\n                        .build(\"minecraft\", \"redstone_block\"));\n       \n       \n       \n        register(153, simpleBuilder()\n                        .itemType()\n                        .properties(builder -> builder\n                                .add(hardness(3.0))\n                                .add(blastResistance(15.0)))\n                        .translation(\"tile.netherquartz.name\")\n                        .build(\"minecraft\", \"quartz_ore\"));\n       \n       \n       \n        register(154, simpleBuilder()\n                        .traits(LanternEnumTraits.HOPPER_FACING, LanternBooleanTraits.ENABLED)\n                        .defaultState(state -> state\n                                .withTrait(LanternEnumTraits.HOPPER_FACING, Direction.DOWN).get()\n                                .withTrait(LanternBooleanTraits.ENABLED, false).get())\n                        .itemType()\n                        .properties(builder -> builder\n                                .add(hardness(3.0))\n                                .add(blastResistance(8.0)))\n                        .translation(\"tile.hopper.name\")\n                        .behaviors(pipeline -> pipeline\n                                .add(new HopperPlacementBehavior()))\n                        .build(\"minecraft\", \"hopper\"),\n                blockState -> {\n                    int data = directionData(blockState.getTraitValue(LanternEnumTraits.HOPPER_FACING).get());\n                    if (!blockState.getTraitValue(LanternBooleanTraits.ENABLED).get()) {\n                        data |= 0x8;\n                    }\n                    return (byte) data;\n                });\n       \n       \n       \n        register(155, simpleBuilder()\n                        .trait(LanternEnumTraits.QUARTZ_TYPE)\n                        .defaultState(state -> state\n                                .withTrait(LanternEnumTraits.QUARTZ_TYPE, LanternQuartzType.DEFAULT).get())\n                        .itemType(builder -> builder\n                                .keysProvider(collection -> collection\n                                        .register(Keys.QUARTZ_TYPE, LanternQuartzType.DEFAULT)\n                                )\n                        )\n                        .properties(builder -> builder\n                                .add(hardness(0.8))\n                                .add(blastResistance(2.4)))\n                        .translation(TranslationProvider.of(LanternEnumTraits.QUARTZ_TYPE))\n                        .behaviors(pipeline -> pipeline\n                                .add(new QuartzLinesRotationPlacementBehavior()))\n                        .build(\"minecraft\", \"quartz_block\"),\n                blockState -> (byte) blockState.getTraitValue(LanternEnumTraits.QUARTZ_TYPE).get().getInternalId());\n       \n       \n       \n        register(158, simpleBuilder()\n                        .traits(LanternEnumTraits.FACING, LanternBooleanTraits.TRIGGERED)\n                        .defaultState(state -> state\n                                .withTrait(LanternEnumTraits.FACING, Direction.NORTH).get()\n                                .withTrait(LanternBooleanTraits.TRIGGERED, false).get())\n                        .itemType()\n                        .properties(builder -> builder\n                                .add(hardness(3.5))\n                                .add(blastResistance(17.5)))\n                       \n                        .translation(\"tile.dropper.name\")\n                        .behaviors(pipeline -> pipeline\n                                .add(new RotationPlacementBehavior()))\n                        .build(\"minecraft\", \"dropper\"),\n                blockState -> {\n                    int data = directionData(blockState.getTraitValue(LanternEnumTraits.FACING).get());\n                    if (blockState.getTraitValue(LanternBooleanTraits.TRIGGERED).get()) {\n                        data |= 0x8;\n                    }\n                    return (byte) data;\n                });\n       \n       \n       \n        register(159, dyedBuilder(\"tile.clayHardenedStained.%s.name\")\n                        .properties(builder -> builder\n                                .add(hardness(1.25))\n                                .add(blastResistance(7.0)))\n                        .build(\"minecraft\", \"stained_hardened_clay\"),\n                this::dyedData);\n       \n       \n       \n        register(160, dyedBuilder(\"tile.thinStainedGlass.%s.name\")\n                        .properties(builder -> builder\n                                .add(hardness(0.3))\n                                .add(blastResistance(1.5)))\n                        .build(\"minecraft\", \"stained_glass_pane\"),\n                this::dyedData);\n       \n       \n       \n        register(161, leavesBuilder(LanternEnumTraits.LEAVES2_TYPE, LanternTreeType.ACACIA)\n                        .build(\"minecraft\", \"leaves2\"),\n                blockState -> leavesData(blockState, blockState.getTraitValue(LanternEnumTraits.LEAVES2_TYPE).get().getInternalId() - 4));\n       \n       \n       \n        register(162, logBuilder(LanternEnumTraits.LOG2_TYPE, LanternTreeType.ACACIA)\n                        .build(\"minecraft\", \"log2\"),\n                blockState -> logData(blockState, blockState.getTraitValue(LanternEnumTraits.LOG2_TYPE).get().getInternalId() - 4));\n       \n       \n       \n        register(166, simpleBuilder()\n                        .itemType()\n                        .properties(builder -> builder\n                                .add(PropertyProviderCollections.UNBREAKABLE))\n                        .translation(\"tile.barrier.name\")\n                        .build(\"minecraft\", \"barrier\"));\n       \n       \n       \n        register(171, dyedBuilder(\"tile.carpet.%s.name\")\n                        .properties(builder -> builder\n                                .add(hardness(0.1))\n                                .add(blastResistance(0.5))\n                                .add(solidMaterial(false)))\n                        .collisionBox(BoundingBoxes.carpet())\n                        .build(\"minecraft\", \"carpet\"),\n                this::dyedData);\n       \n       \n       \n        register(179, simpleBuilder()\n                        .trait(LanternEnumTraits.SANDSTONE_TYPE)\n                        .defaultState(state -> state.withTrait(LanternEnumTraits.SANDSTONE_TYPE, LanternSandstoneType.DEFAULT).get())\n                        .itemType(builder -> builder\n                                .keysProvider(collection -> collection\n                                        .register(Keys.SANDSTONE_TYPE, LanternSandstoneType.DEFAULT)\n                                )\n                        )\n                        .properties(builder -> builder\n                                .add(hardness(0.8))\n                                .add(blastResistance(4.0)))\n                        .translation(TranslationProvider.of(LanternEnumTraits.SANDSTONE_TYPE))\n                        .build(\"minecraft\", \"red_sandstone\"),\n                blockState -> (byte) blockState.getTraitValue(LanternEnumTraits.SANDSTONE_TYPE).get().getInternalId());\n       \n       \n       \n        register(181, doubleStoneSlab(LanternEnumTraits.STONE_SLAB2_TYPE, LanternSlabType.RED_SAND)\n                        .translation(\"tile.stoneSlab2.name\")\n                        .build(\"minecraft\", \"double_stone_slab2\"),\n                blockState -> doubleStoneSlabData(blockState,\n                        blockState.getTraitValue(LanternEnumTraits.STONE_SLAB2_TYPE).get().getInternalId() - 8));\n       \n       \n       \n        register(182, stoneSlab(LanternEnumTraits.STONE_SLAB2_TYPE, LanternSlabType.RED_SAND,\n                () -> BlockTypes.STONE_SLAB2,\n                () -> BlockTypes.DOUBLE_STONE_SLAB2)\n                        .translation(\"tile.stoneSlab2.name\")\n                        .collisionBox(BoundingBoxes::slab)\n                        .build(\"minecraft\", \"stone_slab2\"),\n                blockState -> stoneSlabData(blockState, blockState.getTraitValue(LanternEnumTraits.STONE_SLAB2_TYPE).get().getInternalId() - 8));\n       \n       \n       \n        register(198, simpleBuilder()\n                        .itemType()\n                        .properties(builder -> builder\n                                .add(hardness(0.0))\n                                .add(blastResistance(0.0))\n                                .add(lightEmission(14)))\n                        .translation(\"tile.endRod.name\")\n                        .build(\"minecraft\", \"end_rod\"));\n       \n       \n       \n        register(219, shulkerBox()\n                        .translation(\"tile.shulkerBoxWhite.name\")\n                        .build(\"minecraft\", \"white_shulker_box\"),\n                this::shulkerBoxData);\n       \n       \n       \n        register(220, shulkerBox()\n                        .translation(\"tile.shulkerBoxOrange.name\")\n                        .build(\"minecraft\", \"orange_shulker_box\"),\n                this::shulkerBoxData);\n       \n       \n       \n        register(221, shulkerBox()\n                        .translation(\"tile.shulkerBoxMagenta.name\")\n                        .build(\"minecraft\", \"magenta_shulker_box\"),\n                this::shulkerBoxData);\n       \n       \n       \n        register(222, shulkerBox()\n                        .translation(\"tile.shulkerBoxLightBlue.name\")\n                        .build(\"minecraft\", \"light_blue_shulker_box\"),\n                this::shulkerBoxData);\n       \n       \n       \n        register(223, shulkerBox()\n                        .translation(\"tile.shulkerBoxYellow.name\")\n                        .build(\"minecraft\", \"yellow_shulker_box\"),\n                this::shulkerBoxData);\n       \n       \n       \n        register(224, shulkerBox()\n                        .translation(\"tile.shulkerBoxLime.name\")\n                        .build(\"minecraft\", \"lime_shulker_box\"),\n                this::shulkerBoxData);\n       \n       \n       \n        register(225, shulkerBox()\n                        .translation(\"tile.shulkerBoxPink.name\")\n                        .build(\"minecraft\", \"pink_shulker_box\"),\n                this::shulkerBoxData);\n       \n       \n       \n        register(226, shulkerBox()\n                        .translation(\"tile.shulkerBoxGray.name\")\n                        .build(\"minecraft\", \"gray_shulker_box\"),\n                this::shulkerBoxData);\n       \n       \n       \n        register(227, shulkerBox()\n                        .translation(\"tile.shulkerBoxSilver.name\")\n                        .build(\"minecraft\", \"silver_shulker_box\"),\n                this::shulkerBoxData);\n       \n       \n       \n        register(228, shulkerBox()\n                        .translation(\"tile.shulkerBoxCyan.name\")\n                        .build(\"minecraft\", \"cyan_shulker_box\"),\n                this::shulkerBoxData);\n       \n       \n       \n        register(229, shulkerBox()\n                        .translation(\"tile.shulkerBoxPurple.name\")\n                        .build(\"minecraft\", \"purple_shulker_box\"),\n                this::shulkerBoxData);\n       \n       \n       \n        register(230, shulkerBox()\n                        .translation(\"tile.shulkerBoxBlue.name\")\n                        .build(\"minecraft\", \"blue_shulker_box\"),\n                this::shulkerBoxData);\n       \n       \n       \n        register(231, shulkerBox()\n                        .translation(\"tile.shulkerBoxBrown.name\")\n                        .build(\"minecraft\", \"brown_shulker_box\"),\n                this::shulkerBoxData);\n       \n       \n       \n        register(232, shulkerBox()\n                        .translation(\"tile.shulkerBoxGreen.name\")\n                        .build(\"minecraft\", \"green_shulker_box\"),\n                this::shulkerBoxData);\n       \n       \n       \n        register(233, shulkerBox()\n                        .translation(\"tile.shulkerBoxRed.name\")\n                        .build(\"minecraft\", \"red_shulker_box\"),\n                this::shulkerBoxData);\n       \n       \n       \n        register(234, shulkerBox()\n                        .translation(\"tile.shulkerBoxBlack.name\")\n                        .build(\"minecraft\", \"black_shulker_box\"),\n                this::shulkerBoxData);\n       \n       \n       \n        register(63, simpleBuilder()\n                        .trait(LanternIntegerTraits.ROTATION)\n                        .defaultState(state -> state\n                                .withTrait(LanternIntegerTraits.ROTATION, 0).get())\n                        .properties(builder -> builder\n                                .add(hardness(1.0))\n                                .add(blastResistance(5.0)))\n                        .behaviors(pipeline -> pipeline\n                                .add(new SignInteractionBehavior()))\n                        .tileEntityType(() -> TileEntityTypes.SIGN)\n                        .build(\"minecraft\", \"standing_sign\"),\n                blockState -> blockState.getTraitValue(LanternIntegerTraits.ROTATION).get().byteValue());\n        register(68, simpleBuilder()\n                        .trait(LanternEnumTraits.HORIZONTAL_FACING)\n                        .defaultState(state -> state\n                                .withTrait(LanternEnumTraits.HORIZONTAL_FACING, Direction.NORTH).get())\n                        .properties(builder -> builder\n                                .add(hardness(1.0))\n                                .add(blastResistance(5.0)))\n                        .behaviors(pipeline -> pipeline\n                                .add(new SignInteractionBehavior()))\n                        .tileEntityType(() -> TileEntityTypes.SIGN)\n                        .build(\"minecraft\", \"wall_sign\"),\n                this::horizontalFacingData);\n       \n       \n       \n        register(176, simpleBuilder()\n                        .trait(LanternIntegerTraits.ROTATION)\n                        .defaultState(state -> state\n                                .withTrait(LanternIntegerTraits.ROTATION, 0).get())\n                        .properties(builder -> builder\n                                .add(hardness(1.0))\n                                .add(blastResistance(5.0)))\n                        .behaviors(pipeline -> pipeline\n                                .add(new SignInteractionBehavior()))\n                        .tileEntityType(() -> TileEntityTypes.BANNER)\n                        .build(\"minecraft\", \"standing_banner\"),\n                blockState -> blockState.getTraitValue(LanternIntegerTraits.ROTATION).get().byteValue());\n        register(177, simpleBuilder()\n                        .trait(LanternEnumTraits.HORIZONTAL_FACING)\n                        .defaultState(state -> state\n                                .withTrait(LanternEnumTraits.HORIZONTAL_FACING, Direction.NORTH).get())\n                        .properties(builder -> builder\n                                .add(hardness(1.0))\n                                .add(blastResistance(5.0)))\n                        .behaviors(pipeline -> pipeline\n                                .add(new SignInteractionBehavior()))\n                        .tileEntityType(() -> TileEntityTypes.BANNER)\n                        .build(\"minecraft\", \"wall_banner\"),\n                this::horizontalFacingData);\n       \n    }","cleancode":"@override public void registerdefaults() { register(0, builder() .properties(propertyprovidercollections.default_gas) .translation(\"tile.air.name\") .build(\"minecraft\", \"air\")); register(1, simplebuilder() .trait(lanternenumtraits.stone_type) .defaultstate(state -> state.withtrait(lanternenumtraits.stone_type, lanternstonetype.stone).get()) .itemtype(builder -> builder .keysprovider(collection -> collection .register(keys.stone_type, lanternstonetype.stone) ) ) .properties(builder -> builder .add(hardness(1.5)) .add(blastresistance(30.0))) .translation(translationprovider.of(lanternenumtraits.stone_type)) .build(\"minecraft\", \"stone\"), blockstate -> (byte) blockstate.gettraitvalue(lanternenumtraits.stone_type).get().getinternalid()); register(2, simplebuilder() .trait(lanternbooleantraits.snowy) .extendedstateprovider(new snowyextendedblockstateprovider()) .defaultstate(state -> state.withtrait(lanternbooleantraits.snowy, false).get()) .itemtype() .properties(builder -> builder .add(hardness(0.6)) .add(blastresistance(3.0))) .translation(\"tile.grass.name\") .build(\"minecraft\", \"grass\")); register(3, simplebuilder() .traits(lanternenumtraits.dirt_type, lanternbooleantraits.snowy) .defaultstate(state -> state .withtrait(lanternenumtraits.dirt_type, lanterndirttype.dirt).get() .withtrait(lanternbooleantraits.snowy, false).get()) .extendedstateprovider(new snowyextendedblockstateprovider()) .itemtype(builder -> builder .keysprovider(collection -> collection .register(keys.dirt_type, lanterndirttype.dirt) ) ) .properties(builder -> builder .add(hardness(0.5)) .add(blastresistance(2.5))) .translation(translationprovider.of(lanternenumtraits.dirt_type)) .build(\"minecraft\", \"dirt\"), blockstate -> (byte) blockstate.gettraitvalue(lanternenumtraits.dirt_type).get().getinternalid()); register(4, simplebuilder() .itemtype() .properties(builder -> builder .add(hardness(2.0)) .add(blastresistance(3.0))) .translation(\"tile.stonebrick.name\") .build(\"minecraft\", \"cobblestone\")); register(5, simplebuilder() .trait(lanternenumtraits.tree_type) .defaultstate(state -> state.withtrait(lanternenumtraits.tree_type, lanterntreetype.oak).get()) .itemtype(builder -> builder .keysprovider(collection -> collection .register(keys.tree_type, lanterntreetype.oak) ) ) .properties(builder -> builder .add(hardness(2.0)) .add(blastresistance(5.0)) .add(flammableinfo(5, 20))) .translation(translationprovider.of(lanternenumtraits.tree_type, type -> tr(\"tile.planks.\" + type.gettranslationkeybase() + \".name\"))) .build(\"minecraft\", \"planks\"), blockstate -> (byte) blockstate.gettraitvalue(lanternenumtraits.tree_type).get().getinternalid()); register(6, simplebuilder() .traits(lanternenumtraits.tree_type, lanternintegertraits.sapling_growth_stage) .defaultstate(state -> state .withtrait(lanternenumtraits.tree_type, lanterntreetype.oak).get() .withtrait(lanternintegertraits.sapling_growth_stage, 0).get()) .itemtype(builder -> builder .keysprovider(collection -> collection .register(keys.tree_type, lanterntreetype.oak) ) ) .properties(builder -> builder .add(passable) .add(instant_broken)) .translation(translationprovider.of(lanternenumtraits.tree_type, type -> tr(\"tile.sapling.\" + type.gettranslationkeybase() + \".name\"))) .build(\"minecraft\", \"sapling\"), blockstate -> { final int type = blockstate.gettraitvalue(lanternenumtraits.tree_type).get().getinternalid(); final int stage = blockstate.gettraitvalue(lanternintegertraits.sapling_growth_stage).get(); return (byte) (stage << 3 | type); }); register(7, simplebuilder() .itemtype() .properties(builder -> builder .add(propertyprovidercollections.unbreakable)) .translation(\"tile.bedrock.name\") .build(\"minecraft\", \"bedrock\")); register(12, simplebuilder() .trait(lanternenumtraits.sand_type) .defaultstate(state -> state.withtrait(lanternenumtraits.sand_type, lanternsandtype.normal).get()) .itemtype(builder -> builder .keysprovider(collection -> collection .register(keys.sand_type, lanternsandtype.normal) ) ) .properties(builder -> builder .add(hardness(0.5)) .add(blastresistance(2.5))) .translation(translationprovider.of(lanternenumtraits.sand_type)) .build(\"minecraft\", \"sand\"), blockstate -> (byte) blockstate.gettraitvalue(lanternenumtraits.sand_type).get().getinternalid()); register(13, simplebuilder() .itemtype() .properties(builder -> builder .add(hardness(0.6)) .add(blastresistance(3.0))) .translation(\"tile.gravel.name\") .build(\"minecraft\", \"gravel\")); register(14, simplebuilder() .itemtype() .properties(builder -> builder .add(hardness(3.0)) .add(blastresistance(15.0))) .translation(\"tile.oregold.name\") .build(\"minecraft\", \"gold_ore\")); register(15, simplebuilder() .itemtype() .properties(builder -> builder .add(hardness(3.0)) .add(blastresistance(15.0))) .translation(\"tile.oreiron.name\") .build(\"minecraft\", \"iron_ore\")); register(16, simplebuilder() .itemtype() .properties(builder -> builder .add(hardness(3.0)) .add(blastresistance(15.0))) .translation(\"tile.orecoal.name\") .build(\"minecraft\", \"coal_ore\")); register(17, logbuilder(lanternenumtraits.log1_type, lanterntreetype.oak) .build(\"minecraft\", \"log\"), blockstate -> logdata(blockstate, blockstate.gettraitvalue(lanternenumtraits.log1_type).get().getinternalid())); register(18, leavesbuilder(lanternenumtraits.leaves1_type, lanterntreetype.oak) .build(\"minecraft\", \"leaves\"), blockstate -> leavesdata(blockstate, blockstate.gettraitvalue(lanternenumtraits.leaves1_type).get().getinternalid())); register(19, simplebuilder() .trait(lanternbooleantraits.is_wet) .defaultstate(state -> state.withtrait(lanternbooleantraits.is_wet, false).get()) .itemtype(builder -> builder .keysprovider(collection -> collection .register(keys.is_wet, false) ) ) .properties(builder -> builder .add(hardness(0.6)) .add(blastresistance(3.0))) .translation(new spongetranslationprovider()) .build(\"minecraft\", \"sponge\"), blockstate -> (byte) (blockstate.gettraitvalue(lanternbooleantraits.is_wet).get() ? 1 : 0)); register(20, simplebuilder() .itemtype() .properties(builder -> builder .add(hardness(0.3)) .add(blastresistance(1.5))) .translation(\"tile.glass.name\") .build(\"minecraft\", \"glass\")); register(21, simplebuilder() .itemtype() .properties(builder -> builder .add(hardness(3.0)) .add(blastresistance(15.0))) .translation(\"tile.orelapis.name\") .build(\"minecraft\", \"lapis_ore\")); register(22, simplebuilder() .itemtype() .properties(builder -> builder .add(hardness(3.0)) .add(blastresistance(15.0))) .translation(\"tile.blocklapis.name\") .build(\"minecraft\", \"lapis_block\")); register(23, simplebuilder() .traits(lanternenumtraits.facing, lanternbooleantraits.triggered) .defaultstate(state -> state .withtrait(lanternenumtraits.facing, direction.north).get() .withtrait(lanternbooleantraits.triggered, false).get()) .itemtype() .properties(builder -> builder .add(hardness(3.5)) .add(blastresistance(17.5))) .translation(\"tile.dispenser.name\") .behaviors(pipeline -> pipeline .add(new rotationplacementbehavior())) .build(\"minecraft\", \"dispenser\"), blockstate -> { int data = directiondata(blockstate.gettraitvalue(lanternenumtraits.facing).get()); if (blockstate.gettraitvalue(lanternbooleantraits.triggered).get()) { data |= 0x8; } return (byte) data; }); register(24, simplebuilder() .trait(lanternenumtraits.sandstone_type) .defaultstate(state -> state.withtrait(lanternenumtraits.sandstone_type, lanternsandstonetype.default).get()) .itemtype(builder -> builder .keysprovider(collection -> collection .register(keys.sandstone_type, lanternsandstonetype.default) ) ) .properties(builder -> builder .add(hardness(0.8)) .add(blastresistance(4.0))) .translation(translationprovider.of(lanternenumtraits.sandstone_type)) .build(\"minecraft\", \"sandstone\"), blockstate -> (byte) blockstate.gettraitvalue(lanternenumtraits.sandstone_type).get().getinternalid()); register(25, simplebuilder() .itemtype() .properties(builder -> builder .add(hardness(0.8)) .add(blastresistance(4.0))) .translation(\"tile.musicblock.name\") .tileentitytype(() -> tileentitytypes.note) .behaviors(pipeline -> pipeline .add(new noteblockinteractionbehavior())) .build(\"minecraft\", \"noteblock\")); register(26, simplebuilder() .traits(lanternenumtraits.horizontal_facing, lanternenumtraits.bed_part, lanternbooleantraits.occupied) .defaultstate(state -> state .withtrait(lanternenumtraits.horizontal_facing, direction.north).get() .withtrait(lanternenumtraits.bed_part, lanternbedpart.foot).get() .withtrait(lanternbooleantraits.occupied, false).get()) .properties(builder -> builder .add(hardness(0.2)) .add(blastresistance(1.0))) .translation(\"tile.bed.name\") .build(\"minecraft\", \"bed\"), blockstate -> { final direction facing = blockstate.gettraitvalue(lanternenumtraits.horizontal_facing).get(); int type = facing == direction.south ? 0 : facing == direction.west ? 1 : facing == direction.north ? 2 : facing == direction.east ? 3 : -1; checkargument(type != -1); if (blockstate.gettraitvalue(lanternbooleantraits.occupied).get()) { type |= 0x4; } if (blockstate.gettraitvalue(lanternenumtraits.bed_part).get() == lanternbedpart.head) { type |= 0x8; } return (byte) type; }); register(27, simplebuilder() .traits(lanternenumtraits.straight_rail_direction, lanternbooleantraits.powered) .defaultstate(state -> state .withtrait(lanternenumtraits.straight_rail_direction, lanternraildirection.north_south).get() .withtrait(lanternbooleantraits.powered, false).get()) .itemtype() .selectionbox(boundingboxes::rail) .properties(builder -> builder .add(passable) .add(hardness(0.7)) .add(blastresistance(3.5))) .translation(\"tile.goldenrail.name\") .build(\"minecraft\", \"golden_rail\"), blockstate -> { int type = blockstate.gettraitvalue(lanternenumtraits.straight_rail_direction).get().getinternalid(); if (blockstate.gettraitvalue(lanternbooleantraits.powered).get()) { type |= 0x8; } return (byte) type; }); register(28, simplebuilder() .traits(lanternenumtraits.straight_rail_direction, lanternbooleantraits.powered) .defaultstate(state -> state .withtrait(lanternenumtraits.straight_rail_direction, lanternraildirection.north_south).get() .withtrait(lanternbooleantraits.powered, false).get()) .itemtype() .selectionbox(boundingboxes::rail) .properties(builder -> builder .add(passable) .add(hardness(0.7)) .add(blastresistance(3.5))) .translation(\"tile.detectorrail.name\") .build(\"minecraft\", \"detector_rail\"), blockstate -> { int type = blockstate.gettraitvalue(lanternenumtraits.straight_rail_direction).get().getinternalid(); if (blockstate.gettraitvalue(lanternbooleantraits.powered).get()) { type |= 0x8; } return (byte) type; }); register(30, simplebuilder() .itemtype() .properties(builder -> builder .add(passable) .add(hardness(4.0)) .add(blastresistance(20.0))) .translation(\"tile.web.name\") .build(\"minecraft\", \"web\")); register(31, simplebuilder() .traits(lanternenumtraits.shrub_type) .defaultstate(state -> state .withtrait(lanternenumtraits.shrub_type, lanternshrubtype.dead_bush).get()) .itemtype(builder -> builder .keysprovider(collection -> collection .register(keys.shrub_type, lanternshrubtype.dead_bush))) .selectionbox(boundingboxes.bush()) .properties(builder -> builder .add(instant_broken) .add(passable) .add(replaceable(true))) .translation(\"tile.tallgrass.name\") .build(\"minecraft\", \"tallgrass\"), blockstate -> (byte) blockstate.gettraitvalue(lanternenumtraits.shrub_type).get().getinternalid()); register(32, simplebuilder() .properties(builder -> builder .add(instant_broken) .add(passable) .add(replaceable(true))) .selectionbox(boundingboxes.bush()) .itemtype() .translation(\"tile.deadbush.name\") .build(\"minecraft\", \"deadbush\")); register(35, dyedbuilder(\"tile.wool.%s.name\") .properties(builder -> builder .add(hardness(0.8)) .add(blastresistance(4.0))) .build(\"minecraft\", \"wool\"), this::dyeddata); register(37, simplebuilder() .traits(lanternenumtraits.yellow_flower_type) .defaultstate(state -> state .withtrait(lanternenumtraits.yellow_flower_type, lanternplanttype.dandelion).get()) .itemtype(builder -> builder .keysprovider(collection -> collection .register(keys.plant_type, lanternplanttype.dandelion))) .selectionbox(boundingboxes.bush()) .properties(builder -> builder .add(instant_broken) .add(passable)) .translation(translationprovider.of(lanternenumtraits.yellow_flower_type)) .build(\"minecraft\", \"yellow_flower\"), blockstate -> (byte) blockstate.gettraitvalue(lanternenumtraits.yellow_flower_type).get().getinternalid()); register(38, simplebuilder() .traits(lanternenumtraits.red_flower_type) .defaultstate(state -> state .withtrait(lanternenumtraits.red_flower_type, lanternplanttype.poppy).get()) .itemtype(builder -> builder .keysprovider(collection -> collection .register(keys.plant_type, lanternplanttype.poppy))) .selectionbox(boundingboxes.bush()) .properties(builder -> builder .add(instant_broken) .add(passable)) .translation(translationprovider.of(lanternenumtraits.red_flower_type)) .build(\"minecraft\", \"red_flower\"), blockstate -> (byte) blockstate.gettraitvalue(lanternenumtraits.red_flower_type).get().getinternalid()); register(39, simplebuilder() .selectionbox(boundingboxes.bush()) .properties(builder -> builder .add(instant_broken) .add(passable) .add(lightemission(1))) .translation(\"tile.mushroom.name\") .build(\"minecraft\", \"brown_mushroom\")); register(40, simplebuilder() .selectionbox(boundingboxes.bush()) .properties(builder -> builder .add(instant_broken) .add(passable)) .translation(\"tile.mushroom.name\") .build(\"minecraft\", \"red_mushroom\")); register(41, simplebuilder() .itemtype() .properties(builder -> builder .add(hardness(3.0)) .add(blastresistance(10.0))) .translation(\"tile.blockgold.name\") .build(\"minecraft\", \"gold_block\")); register(42, simplebuilder() .itemtype() .properties(builder -> builder .add(hardness(5.0)) .add(blastresistance(10.0))) .translation(\"tile.blockiron.name\") .build(\"minecraft\", \"iron_block\")); register(43, doublestoneslab(lanternenumtraits.stone_slab1_type, lanternslabtype.stone) .translation(\"tile.stoneslab.name\") .build(\"minecraft\", \"double_stone_slab\"), blockstate -> doublestoneslabdata(blockstate, blockstate.gettraitvalue(lanternenumtraits.stone_slab1_type).get().getinternalid())); register(44, stoneslab(lanternenumtraits.stone_slab1_type, lanternslabtype.stone, () -> blocktypes.stone_slab, () -> blocktypes.double_stone_slab) .translation(\"tile.stoneslab.name\") .collisionbox(boundingboxes::slab) .build(\"minecraft\", \"stone_slab\"), blockstate -> stoneslabdata(blockstate, blockstate.gettraitvalue(lanternenumtraits.stone_slab1_type).get().getinternalid())); register(45, simplebuilder() .itemtype() .properties(builder -> builder .add(hardness(2.0)) .add(blastresistance(10.0))) .translation(\"tile.brick.name\") .build(\"minecraft\", \"brick_block\")); register(46, simplebuilder() .trait(lanternbooleantraits.explode) .defaultstate(state -> state .withtrait(lanternbooleantraits.explode, false).get()) .itemtype() .properties(builder -> builder .add(instant_broken)) .translation(\"tile.tnt.name\") .build(\"minecraft\", \"tnt\"), blockstate -> (byte) (blockstate.gettraitvalue(lanternbooleantraits.explode).get() ? 1 : 0)); register(47, simplebuilder() .itemtype() .properties(builder -> builder .add(hardness(1.5)) .add(blastresistance(7.5))) .translation(\"tile.bookshelf.name\") .build(\"minecraft\", \"bookshelf\")); register(48, simplebuilder() .itemtype() .properties(builder -> builder .add(hardness(2.0)) .add(blastresistance(10.0))) .translation(\"tile.stonemoss.name\") .build(\"minecraft\", \"mossy_cobblestone\")); register(49, simplebuilder() .itemtype() .properties(builder -> builder .add(hardness(50.0)) .add(blastresistance(2000.0))) .translation(\"tile.obsidian.name\") .build(\"minecraft\", \"obsidian\")); register(50, builder() .trait(lanternenumtraits.torch_facing) .defaultstate(state -> state .withtrait(lanternenumtraits.torch_facing, direction.up).get()) .itemtype() .properties(builder -> builder .add(passable) .add(instant_broken)) .translation(\"tile.torch.name\") .selectionbox(boundingboxes::torch) .behaviors(pipeline -> pipeline .add(new blocksnapshotproviderplacebehavior()) .add(new torchplacementbehavior()) .add(new simplebreakbehavior())) .build(\"minecraft\", \"torch\"), blockstate -> { final direction direction = blockstate.gettraitvalue(lanternenumtraits.torch_facing).get(); switch (direction) { case east: return (byte) 1; case west: return (byte) 2; case south: return (byte) 3; case north: return (byte) 4; case up: return (byte) 5; default: throw new illegalargumentexception(); } }); register(51, simplebuilder() .properties(builder -> builder .add(passable) .add(instant_broken) .add(lightemission(15))) .collisionbox(boundingboxes.null) .translation(\"tile.fire.name\") .build(\"minecraft\", \"fire\")); register(52, simplebuilder() .properties(builder -> builder .add(hardness(5.0)) .add(blastresistance(25.0))) .translation(\"tile.mobspawner.name\") .build(\"minecraft\", \"mob_spawner\")); register(54, chestbuilder() .translation(\"tile.chest.name\") .build(\"minecraft\", \"chest\"), this::horizontalfacingdata); register(55, simplebuilder() .traits(lanternintegertraits.power) .selectionbox(new aabb(0, 0, 0, 1.0, 0.0625, 1.0)) .properties(builder -> builder .add(passable) .add(instant_broken)) .defaultstate(state -> state .withtrait(lanternintegertraits.power, 0).get()) .translation(\"tile.redstonedust.name\") .build(\"minecraft\", \"redstone_wire\"), state -> state.get(keys.power).get().bytevalue()); register(56, simplebuilder() .itemtype() .properties(builder -> builder .add(hardness(3.0)) .add(blastresistance(5.0))) .translation(\"tile.orediamond.name\") .build(\"minecraft\", \"diamond_ore\")); register(57, simplebuilder() .itemtype() .properties(builder -> builder .add(hardness(5.0)) .add(blastresistance(10.0))) .translation(\"tile.blockdiamond.name\") .build(\"minecraft\", \"diamond_block\")); register(58, simplebuilder() .itemtype() .properties(builder -> builder .add(hardness(2.5)) .add(blastresistance(12.5))) .translation(\"tile.workbench.name\") .behaviors(pipeline -> pipeline .add(new craftingtableinteractionbehavior())) .build(\"minecraft\", \"crafting_table\")); register(60, simplebuilder() .collisionbox(boundingboxes.farmland()) .trait(lanternintegertraits.moisture) .properties(builder -> builder .add(hardness(0.6)) .add(blastresistance(3.0))) .defaultstate(state -> state.withtrait(lanternintegertraits.moisture, 0).get()) .translation(\"tile.farmland.name\") .build(\"minecraft\", \"farmland\"), state -> state.gettraitvalue(lanternintegertraits.moisture).get().bytevalue()); register(61, furnacebuilder() .itemtype() .translation(\"tile.furnace.name\") .build(\"minecraft\", \"furnace\"), this::directiondata); register(62, furnacebuilder() .properties(builder -> builder .add(lightemission(13))) .translation(\"tile.furnace.name\") .build(\"minecraft\", \"lit_furnace\"), this::directiondata); register(70, pressureplatebuilder() .translation(\"tile.pressureplatestone.name\") .build(\"minecraft\", \"stone_pressure_plate\"), this::pressureplatedata); register(72, pressureplatebuilder() .translation(\"tile.pressureplatewood.name\") .build(\"minecraft\", \"wooden_pressure_plate\"), this::pressureplatedata); register(84, simplebuilder() .itemtype() .traits(lanternbooleantraits.has_record) .defaultstate(state -> state .withtrait(lanternbooleantraits.has_record, false).get()) .properties(builder -> builder .add(hardness(2.0)) .add(blastresistance(10.0))) .tileentitytype(() -> tileentitytypes.jukebox) .translation(\"tile.jukebox.name\") .behaviors(pipeline -> pipeline .add(new jukeboxinteractionbehavior())) .build(\"minecraft\", \"jukebox\"), state -> (byte) (state.gettraitvalue(lanternbooleantraits.has_record).get() ? 1 : 0)); register(86, pumpkinbuilder() .itemtype(builder -> builder .properties(properties -> properties .add(equipmenttype(equipmenttypes.headwear)))) .translation(\"tile.pumpkin.name\") .build(\"minecraft\", \"pumpkin\"), this::horizontaldirectiondata); register(87, simplebuilder() .itemtype() .properties(builder -> builder .add(hardness(0.4)) .add(blastresistance(2.0))) .translation(\"tile.hellrock.name\") .build(\"minecraft\", \"netherrack\")); register(91, pumpkinbuilder() .properties(builder -> builder .add(lightemission(15))) .translation(\"tile.litpumpkin.name\") .build(\"minecraft\", \"lit_pumpkin\"), this::horizontaldirectiondata); register(95, dyedbuilder(\"tile.stainedglass.%s.name\") .properties(builder -> builder .add(hardness(0.3)) .add(blastresistance(1.5))) .build(\"minecraft\", \"stained_glass\"), this::dyeddata); register(101, simplebuilder() .itemtype() .properties(builder -> builder .add(hardness(5.0)) .add(blastresistance(10.0))) .translation(\"tile.fenceiron.name\") .build(\"minecraft\", \"iron_bars\")); register(121, simplebuilder() .itemtype() .properties(builder -> builder .add(hardness(3.0)) .add(blastresistance(15.0))) .translation(\"tile.whitestone.name\") .build(\"minecraft\", \"end_stone\")); register(125, simplebuilder() .traits(lanternenumtraits.tree_type) .defaultstate(state -> state .withtrait(lanternenumtraits.tree_type, lanterntreetype.oak).get()) .translation(translationprovider.of(lanternenumtraits.tree_type, type -> tr(\"tile.woodslab.\" + type.gettranslationkeybase() + \".name\"))) .itemtype(builder -> builder .keysprovider(collection -> collection .register(keys.tree_type, lanterntreetype.oak) ) ) .properties(builder -> builder .add(hardness(2.0)) .add(blastresistance(5.0))) .build(\"minecraft\", \"double_wooden_slab\"), blockstate -> (byte) blockstate.gettraitvalue(lanternenumtraits.tree_type).get().getinternalid()); register(126, simplebuilder() .traits(lanternenumtraits.portion_type, lanternenumtraits.tree_type) .defaultstate(state -> state .withtrait(lanternenumtraits.portion_type, lanternportiontype.bottom).get() .withtrait(lanternenumtraits.tree_type, lanterntreetype.oak).get()) .translation(translationprovider.of(lanternenumtraits.tree_type, type -> tr(\"tile.woodslab.\" + type.gettranslationkeybase() + \".name\"))) .itemtype(builder -> builder .behaviors(pipeline -> pipeline .add(new slabiteminteractionbehavior<>(lanternenumtraits.tree_type, () -> blocktypes.wooden_slab, () -> blocktypes.double_wooden_slab)) .add(new placementcollisiondetectionbehavior())) .keysprovider(collection -> collection .register(keys.tree_type, lanterntreetype.oak) ) ) .collisionbox(boundingboxes::slab) .properties(builder -> builder .add(hardness(2.0)) .add(blastresistance(5.0))) .build(\"minecraft\", \"wooden_slab\"), blockstate -> { final int type = blockstate.gettraitvalue(lanternenumtraits.tree_type).get().getinternalid(); final int portion = (byte) blockstate.gettraitvalue(lanternenumtraits.portion_type).get().getinternalid(); return (byte) (portion << 3 | type); }); register(130, simplebuilder() .trait(lanternenumtraits.horizontal_facing) .defaultstate(state -> state.withtrait(lanternenumtraits.horizontal_facing, direction.north).get()) .itemtype() .tileentitytype(() -> tileentitytypes.ender_chest) .properties(builder -> builder .add(hardness(22.5)) .add(blastresistance(3000.0)) .add(lightemission(7))) .translation(\"tile.enderchest.name\") .collisionbox(boundingboxes.chest()) .behaviors(pipeline -> pipeline .add(new horizontalrotationplacementbehavior()) .add(new enderchestinteractionbehavior())) .build(\"minecraft\", \"ender_chest\"), this::horizontalfacingdata); register(146, chestbuilder() .translation(\"tile.chesttrap.name\") .build(\"minecraft\", \"trapped_chest\"), this::horizontalfacingdata); register(147, weightedpressureplatebuilder() .translation(\"tile.weightedplate_light.name\") .build(\"minecraft\", \"light_weighted_pressure_plate\"), this::weightedpressureplatedata); register(148, weightedpressureplatebuilder() .translation(\"tile.weightedplate_heavy.name\") .build(\"minecraft\", \"heavy_weighted_pressure_plate\"), this::weightedpressureplatedata); register(152, simplebuilder() .itemtype() .properties(builder -> builder .add(hardness(5.0)) .add(blastresistance(30.0))) .translation(\"tile.blockredstone.name\") .build(\"minecraft\", \"redstone_block\")); register(153, simplebuilder() .itemtype() .properties(builder -> builder .add(hardness(3.0)) .add(blastresistance(15.0))) .translation(\"tile.netherquartz.name\") .build(\"minecraft\", \"quartz_ore\")); register(154, simplebuilder() .traits(lanternenumtraits.hopper_facing, lanternbooleantraits.enabled) .defaultstate(state -> state .withtrait(lanternenumtraits.hopper_facing, direction.down).get() .withtrait(lanternbooleantraits.enabled, false).get()) .itemtype() .properties(builder -> builder .add(hardness(3.0)) .add(blastresistance(8.0))) .translation(\"tile.hopper.name\") .behaviors(pipeline -> pipeline .add(new hopperplacementbehavior())) .build(\"minecraft\", \"hopper\"), blockstate -> { int data = directiondata(blockstate.gettraitvalue(lanternenumtraits.hopper_facing).get()); if (!blockstate.gettraitvalue(lanternbooleantraits.enabled).get()) { data |= 0x8; } return (byte) data; }); register(155, simplebuilder() .trait(lanternenumtraits.quartz_type) .defaultstate(state -> state .withtrait(lanternenumtraits.quartz_type, lanternquartztype.default).get()) .itemtype(builder -> builder .keysprovider(collection -> collection .register(keys.quartz_type, lanternquartztype.default) ) ) .properties(builder -> builder .add(hardness(0.8)) .add(blastresistance(2.4))) .translation(translationprovider.of(lanternenumtraits.quartz_type)) .behaviors(pipeline -> pipeline .add(new quartzlinesrotationplacementbehavior())) .build(\"minecraft\", \"quartz_block\"), blockstate -> (byte) blockstate.gettraitvalue(lanternenumtraits.quartz_type).get().getinternalid()); register(158, simplebuilder() .traits(lanternenumtraits.facing, lanternbooleantraits.triggered) .defaultstate(state -> state .withtrait(lanternenumtraits.facing, direction.north).get() .withtrait(lanternbooleantraits.triggered, false).get()) .itemtype() .properties(builder -> builder .add(hardness(3.5)) .add(blastresistance(17.5))) .translation(\"tile.dropper.name\") .behaviors(pipeline -> pipeline .add(new rotationplacementbehavior())) .build(\"minecraft\", \"dropper\"), blockstate -> { int data = directiondata(blockstate.gettraitvalue(lanternenumtraits.facing).get()); if (blockstate.gettraitvalue(lanternbooleantraits.triggered).get()) { data |= 0x8; } return (byte) data; }); register(159, dyedbuilder(\"tile.clayhardenedstained.%s.name\") .properties(builder -> builder .add(hardness(1.25)) .add(blastresistance(7.0))) .build(\"minecraft\", \"stained_hardened_clay\"), this::dyeddata); register(160, dyedbuilder(\"tile.thinstainedglass.%s.name\") .properties(builder -> builder .add(hardness(0.3)) .add(blastresistance(1.5))) .build(\"minecraft\", \"stained_glass_pane\"), this::dyeddata); register(161, leavesbuilder(lanternenumtraits.leaves2_type, lanterntreetype.acacia) .build(\"minecraft\", \"leaves2\"), blockstate -> leavesdata(blockstate, blockstate.gettraitvalue(lanternenumtraits.leaves2_type).get().getinternalid() - 4)); register(162, logbuilder(lanternenumtraits.log2_type, lanterntreetype.acacia) .build(\"minecraft\", \"log2\"), blockstate -> logdata(blockstate, blockstate.gettraitvalue(lanternenumtraits.log2_type).get().getinternalid() - 4)); register(166, simplebuilder() .itemtype() .properties(builder -> builder .add(propertyprovidercollections.unbreakable)) .translation(\"tile.barrier.name\") .build(\"minecraft\", \"barrier\")); register(171, dyedbuilder(\"tile.carpet.%s.name\") .properties(builder -> builder .add(hardness(0.1)) .add(blastresistance(0.5)) .add(solidmaterial(false))) .collisionbox(boundingboxes.carpet()) .build(\"minecraft\", \"carpet\"), this::dyeddata); register(179, simplebuilder() .trait(lanternenumtraits.sandstone_type) .defaultstate(state -> state.withtrait(lanternenumtraits.sandstone_type, lanternsandstonetype.default).get()) .itemtype(builder -> builder .keysprovider(collection -> collection .register(keys.sandstone_type, lanternsandstonetype.default) ) ) .properties(builder -> builder .add(hardness(0.8)) .add(blastresistance(4.0))) .translation(translationprovider.of(lanternenumtraits.sandstone_type)) .build(\"minecraft\", \"red_sandstone\"), blockstate -> (byte) blockstate.gettraitvalue(lanternenumtraits.sandstone_type).get().getinternalid()); register(181, doublestoneslab(lanternenumtraits.stone_slab2_type, lanternslabtype.red_sand) .translation(\"tile.stoneslab2.name\") .build(\"minecraft\", \"double_stone_slab2\"), blockstate -> doublestoneslabdata(blockstate, blockstate.gettraitvalue(lanternenumtraits.stone_slab2_type).get().getinternalid() - 8)); register(182, stoneslab(lanternenumtraits.stone_slab2_type, lanternslabtype.red_sand, () -> blocktypes.stone_slab2, () -> blocktypes.double_stone_slab2) .translation(\"tile.stoneslab2.name\") .collisionbox(boundingboxes::slab) .build(\"minecraft\", \"stone_slab2\"), blockstate -> stoneslabdata(blockstate, blockstate.gettraitvalue(lanternenumtraits.stone_slab2_type).get().getinternalid() - 8)); register(198, simplebuilder() .itemtype() .properties(builder -> builder .add(hardness(0.0)) .add(blastresistance(0.0)) .add(lightemission(14))) .translation(\"tile.endrod.name\") .build(\"minecraft\", \"end_rod\")); register(219, shulkerbox() .translation(\"tile.shulkerboxwhite.name\") .build(\"minecraft\", \"white_shulker_box\"), this::shulkerboxdata); register(220, shulkerbox() .translation(\"tile.shulkerboxorange.name\") .build(\"minecraft\", \"orange_shulker_box\"), this::shulkerboxdata); register(221, shulkerbox() .translation(\"tile.shulkerboxmagenta.name\") .build(\"minecraft\", \"magenta_shulker_box\"), this::shulkerboxdata); register(222, shulkerbox() .translation(\"tile.shulkerboxlightblue.name\") .build(\"minecraft\", \"light_blue_shulker_box\"), this::shulkerboxdata); register(223, shulkerbox() .translation(\"tile.shulkerboxyellow.name\") .build(\"minecraft\", \"yellow_shulker_box\"), this::shulkerboxdata); register(224, shulkerbox() .translation(\"tile.shulkerboxlime.name\") .build(\"minecraft\", \"lime_shulker_box\"), this::shulkerboxdata); register(225, shulkerbox() .translation(\"tile.shulkerboxpink.name\") .build(\"minecraft\", \"pink_shulker_box\"), this::shulkerboxdata); register(226, shulkerbox() .translation(\"tile.shulkerboxgray.name\") .build(\"minecraft\", \"gray_shulker_box\"), this::shulkerboxdata); register(227, shulkerbox() .translation(\"tile.shulkerboxsilver.name\") .build(\"minecraft\", \"silver_shulker_box\"), this::shulkerboxdata); register(228, shulkerbox() .translation(\"tile.shulkerboxcyan.name\") .build(\"minecraft\", \"cyan_shulker_box\"), this::shulkerboxdata); register(229, shulkerbox() .translation(\"tile.shulkerboxpurple.name\") .build(\"minecraft\", \"purple_shulker_box\"), this::shulkerboxdata); register(230, shulkerbox() .translation(\"tile.shulkerboxblue.name\") .build(\"minecraft\", \"blue_shulker_box\"), this::shulkerboxdata); register(231, shulkerbox() .translation(\"tile.shulkerboxbrown.name\") .build(\"minecraft\", \"brown_shulker_box\"), this::shulkerboxdata); register(232, shulkerbox() .translation(\"tile.shulkerboxgreen.name\") .build(\"minecraft\", \"green_shulker_box\"), this::shulkerboxdata); register(233, shulkerbox() .translation(\"tile.shulkerboxred.name\") .build(\"minecraft\", \"red_shulker_box\"), this::shulkerboxdata); register(234, shulkerbox() .translation(\"tile.shulkerboxblack.name\") .build(\"minecraft\", \"black_shulker_box\"), this::shulkerboxdata); register(63, simplebuilder() .trait(lanternintegertraits.rotation) .defaultstate(state -> state .withtrait(lanternintegertraits.rotation, 0).get()) .properties(builder -> builder .add(hardness(1.0)) .add(blastresistance(5.0))) .behaviors(pipeline -> pipeline .add(new signinteractionbehavior())) .tileentitytype(() -> tileentitytypes.sign) .build(\"minecraft\", \"standing_sign\"), blockstate -> blockstate.gettraitvalue(lanternintegertraits.rotation).get().bytevalue()); register(68, simplebuilder() .trait(lanternenumtraits.horizontal_facing) .defaultstate(state -> state .withtrait(lanternenumtraits.horizontal_facing, direction.north).get()) .properties(builder -> builder .add(hardness(1.0)) .add(blastresistance(5.0))) .behaviors(pipeline -> pipeline .add(new signinteractionbehavior())) .tileentitytype(() -> tileentitytypes.sign) .build(\"minecraft\", \"wall_sign\"), this::horizontalfacingdata); register(176, simplebuilder() .trait(lanternintegertraits.rotation) .defaultstate(state -> state .withtrait(lanternintegertraits.rotation, 0).get()) .properties(builder -> builder .add(hardness(1.0)) .add(blastresistance(5.0))) .behaviors(pipeline -> pipeline .add(new signinteractionbehavior())) .tileentitytype(() -> tileentitytypes.banner) .build(\"minecraft\", \"standing_banner\"), blockstate -> blockstate.gettraitvalue(lanternintegertraits.rotation).get().bytevalue()); register(177, simplebuilder() .trait(lanternenumtraits.horizontal_facing) .defaultstate(state -> state .withtrait(lanternenumtraits.horizontal_facing, direction.north).get()) .properties(builder -> builder .add(hardness(1.0)) .add(blastresistance(5.0))) .behaviors(pipeline -> pipeline .add(new signinteractionbehavior())) .tileentitytype(() -> tileentitytypes.banner) .build(\"minecraft\", \"wall_banner\"), this::horizontalfacingdata); }","comment":"\/\/ @formatter:off \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/ \/\/\/ air \/\/\/ \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/ \/\/\/ stone \/\/\/ \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/ \/\/\/ grass \/\/\/ \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/ \/\/\/ dirt \/\/\/ \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/ \/\/\/ cobblestone \/\/\/ \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/ \/\/\/ planks \/\/\/ \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/ \/\/\/ sapling \/\/\/ \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/ \/\/\/ bedrock \/\/\/ \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/ \/\/\/ sand \/\/\/ \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\/\/ todo: sand physics behavior \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/ \/\/\/ gravel \/\/\/ \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\/\/ todo: gravel physics behavior \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/ \/\/\/ gold ore \/\/\/ \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/ \/\/\/ iron ore \/\/\/ \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/ \/\/\/ coal ore \/\/\/ \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/ \/\/\/ log 1 \/\/\/ \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/ \/\/\/ leaves 1 \/\/\/ \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/ \/\/\/ sponge \/\/\/ \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/ \/\/\/ glass \/\/\/ \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/ \/\/\/ lapis ore \/\/\/ \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/ \/\/\/ lapis block \/\/\/ \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/ \/\/\/ dispenser \/\/\/ \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\/\/ .tileentitytype(() -> tileentitytypes.dispenser)\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/ \/\/\/ sandstone \/\/\/ \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/ \/\/\/ noteblock \/\/\/ \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/ \/\/\/ bed \/\/\/ \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/ \/\/\/ golden rail \/\/\/ \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/ \/\/\/ detector rail \/\/\/ \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\/\/ todo: 29 \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/ \/\/\/ web \/\/\/ \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/ \/\/\/ tall grass \/\/\/ \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/ \/\/\/ dead bush \/\/\/ \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\/\/ todo: 33 \/\/ todo: 34 \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/ \/\/\/ wool \/\/\/ \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\/\/ todo: 36 \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/ \/\/\/ yellow flower \/\/\/ \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/ \/\/\/ red flower \/\/\/ \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/ \/\/\/ brown mushroom \/\/\/ \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/ \/\/\/ red mushroom \/\/\/ \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/ \/\/\/ gold block \/\/\/ \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/ \/\/\/ iron block \/\/\/ \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/ \/\/\/ double stone slab 1 \/\/\/ \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/ \/\/\/ stone slab 1 \/\/\/ \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/ \/\/\/ brick block \/\/\/ \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/ \/\/\/ tnt \/\/\/ \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/ \/\/\/ bookshelf \/\/\/ \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/ \/\/\/ mossy cobblestone \/\/\/ \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/ \/\/\/ obsidian \/\/\/ \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/ \/\/\/ torch \/\/\/ \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/ \/\/\/ fire \/\/\/ \/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/ \/\/\/ mob spawner \/\/\/ \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\/\/ todo: oak stairs \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/ \/\/\/ chest \/\/\/ \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/ \/\/\/ redstone wire \/\/\/ \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\/\/ todo: based on connections\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/ \/\/\/ diamond ore \/\/\/ \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/ \/\/\/ diamond block \/\/\/ \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/ \/\/\/ crafting table \/\/\/ \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\/\/ todo: wheat \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/ \/\/\/ farmland \/\/\/ \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/ \/\/\/ furnace \/\/\/ \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/ \/\/\/ lit furnace \/\/\/ \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/ \/\/\/ stone pressure plate \/\/\/ \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/ \/\/\/ wooden pressure plate \/\/\/ \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/ \/\/\/ jukebox \/\/\/ \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/ \/\/\/ pumpkin \/\/\/ \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/ \/\/\/ netherrack \/\/\/ \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/ \/\/\/ lit pumpkin \/\/\/ \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/ \/\/\/ stained glass \/\/\/ \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/ \/\/\/ iron bars \/\/\/ \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\/\/ todo\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/ \/\/\/ end stone \/\/\/ \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/ \/\/\/ double wooden slab \/\/\/ \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/ \/\/\/ wooden slab \/\/\/ \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/ \/\/\/ ender chest \/\/\/ \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/ \/\/\/ trapped chest \/\/\/ \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/ \/\/\/ weighted pressure plate (light) \/\/\/ \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/ \/\/\/ weighted pressure plate (heavy) \/\/\/ \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/ \/\/\/ redstone block \/\/\/ \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/ \/\/\/ quartz ore \/\/\/ \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/ \/\/\/ hopper \/\/\/ \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/ \/\/\/ quartz block \/\/\/ \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/ \/\/\/ dropper \/\/\/ \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\/\/ .tileentitytype(() -> tileentitytypes.dropper)\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/ \/\/\/ stained hardended clay \/\/\/ \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/ \/\/\/ stained glass pane \/\/\/ \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/ \/\/\/ leaves 2 \/\/\/ \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/ \/\/\/ log 2 \/\/\/ \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/ \/\/\/ barrier \/\/\/ \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/ \/\/\/ carpet \/\/\/ \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/ \/\/\/ red sandstone \/\/\/ \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/ \/\/\/ double stone slab 2 \/\/\/ \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/ \/\/\/ stone slab 2 \/\/\/ \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/ \/\/\/ end rod \/\/\/ \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/ \/\/\/ white shulker box \/\/\/ \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/ \/\/\/ orange shulker box \/\/\/ \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/ \/\/\/ magenta shulker box \/\/\/ \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/ \/\/\/ light blue shulker box \/\/\/ \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/ \/\/\/ yellow shulker box \/\/\/ \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/ \/\/\/ lime shulker box \/\/\/ \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/ \/\/\/ pink shulker box \/\/\/ \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/ \/\/\/ gray shulker box \/\/\/ \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/ \/\/\/ gray shulker box \/\/\/ \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/ \/\/\/ cyan shulker box \/\/\/ \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/ \/\/\/ purple shulker box \/\/\/ \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/ \/\/\/ blue shulker box \/\/\/ \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/ \/\/\/ brown shulker box \/\/\/ \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/ \/\/\/ green shulker box \/\/\/ \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/ \/\/\/ red shulker box \/\/\/ \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/ \/\/\/ black shulker box \/\/\/ \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/ \/\/\/ sign \/\/\/ \/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/ \/\/\/ banner \/\/\/ \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\/\/ @formatter:on","repo":"shisheng-1\/Lantern","code_context_2":"@Override\npublic void registerDefaults() {\n\/\/ @formatter:off\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\/\/\/ Air \/\/\/\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\nregister(0, builder()\n.properties(PropertyProviderCollections.DEFAULT_GAS)\n\npublic void registerDefaults() {\n\/\/ @formatter:off\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\/\/\/ Air \/\/\/\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\nregister(0, builder()\n.properties(PropertyProviderCollections.DEFAULT_GAS)\n\npublic void registerDefaults() {\n\/\/ @formatter:off\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\/\/\/ Air \/\/\/\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\nregister(0, builder()\n.properties(PropertyProviderCollections.DEFAULT_GAS)\n\npublic void registerDefaults() {\n\/\/ @formatter:off\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\/\/\/ Air \/\/\/\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\nregister(0, builder()\n.properties(PropertyProviderCollections.DEFAULT_GAS)\n\npublic void registerDefaults() {\n\/\/ @formatter:off\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\/\/\/ Air \/\/\/\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\nregister(0, builder()\n.properties(PropertyProviderCollections.DEFAULT_GAS)\n\npublic void registerDefaults() {\n\/\/ @formatter:off\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\/\/\/ Air \/\/\/\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\nregister(0, builder()\n.properties(PropertyProviderCollections.DEFAULT_GAS)\n\n.build(\"minecraft\", \"planks\"),\nblockState -> (byte) blockState.getTraitValue(LanternEnumTraits.TREE_TYPE).get().getInternalId());\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\/\/\/ Sapling \/\/\/\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\nregister(6, simpleBuilder()\n.traits(LanternEnumTraits.TREE_TYPE, LanternIntegerTraits.SAPLING_GROWTH_STAGE)\n\n.build(\"minecraft\", \"planks\"),\nblockState -> (byte) blockState.getTraitValue(LanternEnumTraits.TREE_TYPE).get().getInternalId());\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\/\/\/ Sapling \/\/\/\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\nregister(6, simpleBuilder()\n.traits(LanternEnumTraits.TREE_TYPE, LanternIntegerTraits.SAPLING_GROWTH_STAGE)\n\n.build(\"minecraft\", \"planks\"),\nblockState -> (byte) blockState.getTraitValue(LanternEnumTraits.TREE_TYPE).get().getInternalId());\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\/\/\/ Sapling \/\/\/\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\nregister(6, simpleBuilder()\n.traits(LanternEnumTraits.TREE_TYPE, LanternIntegerTraits.SAPLING_GROWTH_STAGE)\n\n.build(\"minecraft\", \"sand\"),\nblockState -> (byte) blockState.getTraitValue(LanternEnumTraits.SAND_TYPE).get().getInternalId());\n\/\/ TODO: Sand physics behavior\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\/\/\/ Gravel \/\/\/\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\nregister(13, simpleBuilder()\n.itemType()\n\n.translation(\"tile.gravel.name\")\n.build(\"minecraft\", \"gravel\"));\n\/\/ TODO: Gravel physics behavior\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\/\/\/ Gold Ore \/\/\/\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\nregister(14, simpleBuilder()\n.itemType()\n\n.build(\"minecraft\", \"planks\"),\nblockState -> (byte) blockState.getTraitValue(LanternEnumTraits.TREE_TYPE).get().getInternalId());\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\/\/\/ Sapling \/\/\/\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\nregister(6, simpleBuilder()\n.traits(LanternEnumTraits.TREE_TYPE, LanternIntegerTraits.SAPLING_GROWTH_STAGE)\n\n.build(\"minecraft\", \"planks\"),\nblockState -> (byte) blockState.getTraitValue(LanternEnumTraits.TREE_TYPE).get().getInternalId());\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\/\/\/ Sapling \/\/\/\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\nregister(6, simpleBuilder()\n.traits(LanternEnumTraits.TREE_TYPE, LanternIntegerTraits.SAPLING_GROWTH_STAGE)\n\n.build(\"minecraft\", \"planks\"),\nblockState -> (byte) blockState.getTraitValue(LanternEnumTraits.TREE_TYPE).get().getInternalId());\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\/\/\/ Sapling \/\/\/\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\nregister(6, simpleBuilder()\n.traits(LanternEnumTraits.TREE_TYPE, LanternIntegerTraits.SAPLING_GROWTH_STAGE)\n\n.build(\"minecraft\", \"planks\"),\nblockState -> (byte) blockState.getTraitValue(LanternEnumTraits.TREE_TYPE).get().getInternalId());\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\/\/\/ Sapling \/\/\/\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\nregister(6, simpleBuilder()\n.traits(LanternEnumTraits.TREE_TYPE, LanternIntegerTraits.SAPLING_GROWTH_STAGE)\n\n.build(\"minecraft\", \"planks\"),\nblockState -> (byte) blockState.getTraitValue(LanternEnumTraits.TREE_TYPE).get().getInternalId());\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\/\/\/ Sapling \/\/\/\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\nregister(6, simpleBuilder()\n.traits(LanternEnumTraits.TREE_TYPE, LanternIntegerTraits.SAPLING_GROWTH_STAGE)\n\n.build(\"minecraft\", \"planks\"),\nblockState -> (byte) blockState.getTraitValue(LanternEnumTraits.TREE_TYPE).get().getInternalId());\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\/\/\/ Sapling \/\/\/\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\nregister(6, simpleBuilder()\n.traits(LanternEnumTraits.TREE_TYPE, LanternIntegerTraits.SAPLING_GROWTH_STAGE)\n\n.build(\"minecraft\", \"planks\"),\nblockState -> (byte) blockState.getTraitValue(LanternEnumTraits.TREE_TYPE).get().getInternalId());\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\/\/\/ Sapling \/\/\/\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\nregister(6, simpleBuilder()\n.traits(LanternEnumTraits.TREE_TYPE, LanternIntegerTraits.SAPLING_GROWTH_STAGE)\n\n.build(\"minecraft\", \"planks\"),\nblockState -> (byte) blockState.getTraitValue(LanternEnumTraits.TREE_TYPE).get().getInternalId());\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\/\/\/ Sapling \/\/\/\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\nregister(6, simpleBuilder()\n.traits(LanternEnumTraits.TREE_TYPE, LanternIntegerTraits.SAPLING_GROWTH_STAGE)\n\n.build(\"minecraft\", \"planks\"),\nblockState -> (byte) blockState.getTraitValue(LanternEnumTraits.TREE_TYPE).get().getInternalId());\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\/\/\/ Sapling \/\/\/\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\nregister(6, simpleBuilder()\n.traits(LanternEnumTraits.TREE_TYPE, LanternIntegerTraits.SAPLING_GROWTH_STAGE)\n\n.add(hardness(3.5))\n.add(blastResistance(17.5)))\n\/\/ .tileEntityType(() -> TileEntityTypes.DISPENSER)\n.translation(\"tile.dispenser.name\")\n.behaviors(pipeline -> pipeline\n\n.build(\"minecraft\", \"planks\"),\nblockState -> (byte) blockState.getTraitValue(LanternEnumTraits.TREE_TYPE).get().getInternalId());\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\/\/\/ Sapling \/\/\/\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\nregister(6, simpleBuilder()\n.traits(LanternEnumTraits.TREE_TYPE, LanternIntegerTraits.SAPLING_GROWTH_STAGE)\n\n.build(\"minecraft\", \"planks\"),\nblockState -> (byte) blockState.getTraitValue(LanternEnumTraits.TREE_TYPE).get().getInternalId());\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\/\/\/ Sapling \/\/\/\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\nregister(6, simpleBuilder()\n.traits(LanternEnumTraits.TREE_TYPE, LanternIntegerTraits.SAPLING_GROWTH_STAGE)\n\n.build(\"minecraft\", \"planks\"),\nblockState -> (byte) blockState.getTraitValue(LanternEnumTraits.TREE_TYPE).get().getInternalId());\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\/\/\/ Sapling \/\/\/\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\nregister(6, simpleBuilder()\n.traits(LanternEnumTraits.TREE_TYPE, LanternIntegerTraits.SAPLING_GROWTH_STAGE)\n\nreturn (byte) type;\n});\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\/\/\/ Golden Rail \/\/\/\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\nregister(27, simpleBuilder()\n.traits(LanternEnumTraits.STRAIGHT_RAIL_DIRECTION, LanternBooleanTraits.POWERED)\n\nreturn (byte) type;\n});\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\/\/\/ Detector Rail \/\/\/\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\nregister(28, simpleBuilder()\n.traits(LanternEnumTraits.STRAIGHT_RAIL_DIRECTION, LanternBooleanTraits.POWERED)\n\nreturn (byte) type;\n});\n\/\/ TODO: 29\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\/\/\/ Web \/\/\/\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\nregister(30, simpleBuilder()\n.itemType()\n\nreturn (byte) type;\n});\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\/\/\/ Golden Rail \/\/\/\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\nregister(27, simpleBuilder()\n.traits(LanternEnumTraits.STRAIGHT_RAIL_DIRECTION, LanternBooleanTraits.POWERED)\n\nreturn (byte) type;\n});\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\/\/\/ Golden Rail \/\/\/\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\nregister(27, simpleBuilder()\n.traits(LanternEnumTraits.STRAIGHT_RAIL_DIRECTION, LanternBooleanTraits.POWERED)\n\n.translation(\"tile.deadbush.name\")\n.build(\"minecraft\", \"deadbush\"));\n\/\/ TODO: 33\n\/\/ TODO: 34\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\/\/\/ Wool \/\/\/\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\nregister(35, dyedBuilder(\"tile.wool.%s.name\")\n.properties(builder -> builder\n\n.build(\"minecraft\", \"wool\"),\nthis::dyedData);\n\/\/ TODO: 36\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\/\/\/ Yellow Flower \/\/\/\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\nregister(37, simpleBuilder()\n.traits(LanternEnumTraits.YELLOW_FLOWER_TYPE)\n\nreturn (byte) type;\n});\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\/\/\/ Golden Rail \/\/\/\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\nregister(27, simpleBuilder()\n.traits(LanternEnumTraits.STRAIGHT_RAIL_DIRECTION, LanternBooleanTraits.POWERED)\n\n.build(\"minecraft\", \"red_flower\"),\nblockState -> (byte) blockState.getTraitValue(LanternEnumTraits.RED_FLOWER_TYPE).get().getInternalId());\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\/\/\/ Brown Mushroom \/\/\/\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\nregister(39, simpleBuilder()\n.selectionBox(BoundingBoxes.bush())\n\nreturn (byte) type;\n});\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\/\/\/ Detector Rail \/\/\/\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\nregister(28, simpleBuilder()\n.traits(LanternEnumTraits.STRAIGHT_RAIL_DIRECTION, LanternBooleanTraits.POWERED)\n\nreturn (byte) type;\n});\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\/\/\/ Golden Rail \/\/\/\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\nregister(27, simpleBuilder()\n.traits(LanternEnumTraits.STRAIGHT_RAIL_DIRECTION, LanternBooleanTraits.POWERED)\n\nreturn (byte) type;\n});\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\/\/\/ Golden Rail \/\/\/\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\nregister(27, simpleBuilder()\n.traits(LanternEnumTraits.STRAIGHT_RAIL_DIRECTION, LanternBooleanTraits.POWERED)\n\n.translation(\"tile.blockIron.name\")\n.build(\"minecraft\", \"iron_block\"));\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\/\/\/ Double Stone Slab 1 \/\/\/\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\nregister(43, doubleStoneSlab(LanternEnumTraits.STONE_SLAB1_TYPE, LanternSlabType.STONE)\n.translation(\"tile.stoneSlab.name\")\n\nreturn (byte) type;\n});\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\/\/\/ Detector Rail \/\/\/\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\nregister(28, simpleBuilder()\n.traits(LanternEnumTraits.STRAIGHT_RAIL_DIRECTION, LanternBooleanTraits.POWERED)\n\nreturn (byte) type;\n});\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\/\/\/ Detector Rail \/\/\/\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\nregister(28, simpleBuilder()\n.traits(LanternEnumTraits.STRAIGHT_RAIL_DIRECTION, LanternBooleanTraits.POWERED)\n\npublic void registerDefaults() {\n\/\/ @formatter:off\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\/\/\/ Air \/\/\/\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\nregister(0, builder()\n.properties(PropertyProviderCollections.DEFAULT_GAS)\n\nreturn (byte) type;\n});\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\/\/\/ Golden Rail \/\/\/\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\nregister(27, simpleBuilder()\n.traits(LanternEnumTraits.STRAIGHT_RAIL_DIRECTION, LanternBooleanTraits.POWERED)\n\n.translation(\"tile.bookshelf.name\")\n.build(\"minecraft\", \"bookshelf\"));\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\/\/\/ Mossy Cobblestone \/\/\/\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\nregister(48, simpleBuilder()\n.itemType()\n\n.build(\"minecraft\", \"planks\"),\nblockState -> (byte) blockState.getTraitValue(LanternEnumTraits.TREE_TYPE).get().getInternalId());\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\/\/\/ Sapling \/\/\/\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\nregister(6, simpleBuilder()\n.traits(LanternEnumTraits.TREE_TYPE, LanternIntegerTraits.SAPLING_GROWTH_STAGE)\n\npublic void registerDefaults() {\n\/\/ @formatter:off\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\/\/\/ Air \/\/\/\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\nregister(0, builder()\n.properties(PropertyProviderCollections.DEFAULT_GAS)\n\npublic void registerDefaults() {\n\/\/ @formatter:off\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\/\/\/ Air \/\/\/\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\nregister(0, builder()\n.properties(PropertyProviderCollections.DEFAULT_GAS)\n\nreturn (byte) type;\n});\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\/\/\/ Golden Rail \/\/\/\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\nregister(27, simpleBuilder()\n.traits(LanternEnumTraits.STRAIGHT_RAIL_DIRECTION, LanternBooleanTraits.POWERED)\n\n.translation(\"tile.mobSpawner.name\")\n.build(\"minecraft\", \"mob_spawner\"));\n\/\/ TODO: Oak Stairs\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\/\/\/ Chest \/\/\/\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\nregister(54, chestBuilder()\n.translation(\"tile.chest.name\")\n\n.translation(\"tile.blockIron.name\")\n.build(\"minecraft\", \"iron_block\"));\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\/\/\/ Double Stone Slab 1 \/\/\/\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\nregister(43, doubleStoneSlab(LanternEnumTraits.STONE_SLAB1_TYPE, LanternSlabType.STONE)\n.translation(\"tile.stoneSlab.name\")\n\nregister(55, simpleBuilder()\n.traits(LanternIntegerTraits.POWER)\n.selectionBox(new AABB(0, 0, 0, 1.0, 0.0625, 1.0)) \/\/ TODO: Based on connections\n.properties(builder -> builder\n.add(PASSABLE)\n\nreturn (byte) type;\n});\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\/\/\/ Detector Rail \/\/\/\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\nregister(28, simpleBuilder()\n.traits(LanternEnumTraits.STRAIGHT_RAIL_DIRECTION, LanternBooleanTraits.POWERED)\n\nthis::dyedData);\n\/\/ TODO: 36\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\/\/\/ Yellow Flower \/\/\/\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\nregister(37, simpleBuilder()\n.traits(LanternEnumTraits.YELLOW_FLOWER_TYPE)\n\n.build(\"minecraft\", \"red_flower\"),\nblockState -> (byte) blockState.getTraitValue(LanternEnumTraits.RED_FLOWER_TYPE).get().getInternalId());\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\/\/\/ Brown Mushroom \/\/\/\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\nregister(39, simpleBuilder()\n.selectionBox(BoundingBoxes.bush())\n\n.add(new CraftingTableInteractionBehavior()))\n.build(\"minecraft\", \"crafting_table\"));\n\/\/ TODO: Wheat\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\/\/\/ Farmland \/\/\/\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\nregister(60, simpleBuilder()\n.collisionBox(BoundingBoxes.farmland())\n\n.build(\"minecraft\", \"planks\"),\nblockState -> (byte) blockState.getTraitValue(LanternEnumTraits.TREE_TYPE).get().getInternalId());\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\/\/\/ Sapling \/\/\/\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\nregister(6, simpleBuilder()\n.traits(LanternEnumTraits.TREE_TYPE, LanternIntegerTraits.SAPLING_GROWTH_STAGE)\n\n.build(\"minecraft\", \"planks\"),\nblockState -> (byte) blockState.getTraitValue(LanternEnumTraits.TREE_TYPE).get().getInternalId());\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\/\/\/ Sapling \/\/\/\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\nregister(6, simpleBuilder()\n.traits(LanternEnumTraits.TREE_TYPE, LanternIntegerTraits.SAPLING_GROWTH_STAGE)\n\n.translation(\"tile.bookshelf.name\")\n.build(\"minecraft\", \"bookshelf\"));\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\/\/\/ Mossy Cobblestone \/\/\/\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\nregister(48, simpleBuilder()\n.itemType()\n\n.translation(\"tile.bookshelf.name\")\n.build(\"minecraft\", \"bookshelf\"));\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\/\/\/ Mossy Cobblestone \/\/\/\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\nregister(48, simpleBuilder()\n.itemType()\n\n.build(\"minecraft\", \"planks\"),\nblockState -> (byte) blockState.getTraitValue(LanternEnumTraits.TREE_TYPE).get().getInternalId());\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\/\/\/ Sapling \/\/\/\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\nregister(6, simpleBuilder()\n.traits(LanternEnumTraits.TREE_TYPE, LanternIntegerTraits.SAPLING_GROWTH_STAGE)\n\n.build(\"minecraft\", \"planks\"),\nblockState -> (byte) blockState.getTraitValue(LanternEnumTraits.TREE_TYPE).get().getInternalId());\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\/\/\/ Sapling \/\/\/\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\nregister(6, simpleBuilder()\n.traits(LanternEnumTraits.TREE_TYPE, LanternIntegerTraits.SAPLING_GROWTH_STAGE)\n\nreturn (byte) type;\n});\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\/\/\/ Golden Rail \/\/\/\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\nregister(27, simpleBuilder()\n.traits(LanternEnumTraits.STRAIGHT_RAIL_DIRECTION, LanternBooleanTraits.POWERED)\n\n.build(\"minecraft\", \"planks\"),\nblockState -> (byte) blockState.getTraitValue(LanternEnumTraits.TREE_TYPE).get().getInternalId());\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\/\/\/ Sapling \/\/\/\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\nregister(6, simpleBuilder()\n.traits(LanternEnumTraits.TREE_TYPE, LanternIntegerTraits.SAPLING_GROWTH_STAGE)\n\nreturn (byte) type;\n});\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\/\/\/ Golden Rail \/\/\/\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\nregister(27, simpleBuilder()\n.traits(LanternEnumTraits.STRAIGHT_RAIL_DIRECTION, LanternBooleanTraits.POWERED)\n\npublic void registerDefaults() {\n\/\/ @formatter:off\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\/\/\/ Air \/\/\/\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\nregister(0, builder()\n.properties(PropertyProviderCollections.DEFAULT_GAS)\n\n.build(\"minecraft\", \"sand\"),\nblockState -> (byte) blockState.getTraitValue(LanternEnumTraits.SAND_TYPE).get().getInternalId());\n\/\/ TODO: Sand physics behavior\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\/\/\/ Gravel \/\/\/\n\nreturn (byte) type;\n});\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\/\/\/ Golden Rail \/\/\/\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\nregister(27, simpleBuilder()\n.traits(LanternEnumTraits.STRAIGHT_RAIL_DIRECTION, LanternBooleanTraits.POWERED)\n\n.build(\"minecraft\", \"red_flower\"),\nblockState -> (byte) blockState.getTraitValue(LanternEnumTraits.RED_FLOWER_TYPE).get().getInternalId());\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\/\/\/ Brown Mushroom \/\/\/\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\nregister(39, simpleBuilder()\n.selectionBox(BoundingBoxes.bush())\n\n.build(\"minecraft\", \"red_flower\"),\nblockState -> (byte) blockState.getTraitValue(LanternEnumTraits.RED_FLOWER_TYPE).get().getInternalId());\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\/\/\/ Brown Mushroom \/\/\/\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\nregister(39, simpleBuilder()\n.selectionBox(BoundingBoxes.bush())\n\nreturn (byte) type;\n});\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\/\/\/ Golden Rail \/\/\/\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\nregister(27, simpleBuilder()\n.traits(LanternEnumTraits.STRAIGHT_RAIL_DIRECTION, LanternBooleanTraits.POWERED)\n\nreturn (byte) type;\n});\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\/\/\/ Golden Rail \/\/\/\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\nregister(27, simpleBuilder()\n.traits(LanternEnumTraits.STRAIGHT_RAIL_DIRECTION, LanternBooleanTraits.POWERED)\n\n.build(\"minecraft\", \"trapped_chest\"),\nthis::horizontalFacingData);\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\/\/\/ Weighted Pressure Plate (Light) \/\/\/\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\nregister(147, weightedPressurePlateBuilder()\n.translation(\"tile.weightedPlate_light.name\")\n\n.build(\"minecraft\", \"trapped_chest\"),\nthis::horizontalFacingData);\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\/\/\/ Weighted Pressure Plate (Light) \/\/\/\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\nregister(147, weightedPressurePlateBuilder()\n.translation(\"tile.weightedPlate_light.name\")\n\nreturn (byte) type;\n});\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\/\/\/ Detector Rail \/\/\/\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\nregister(28, simpleBuilder()\n.traits(LanternEnumTraits.STRAIGHT_RAIL_DIRECTION, LanternBooleanTraits.POWERED)\n\n.build(\"minecraft\", \"planks\"),\nblockState -> (byte) blockState.getTraitValue(LanternEnumTraits.TREE_TYPE).get().getInternalId());\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\/\/\/ Sapling \/\/\/\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\nregister(6, simpleBuilder()\n.traits(LanternEnumTraits.TREE_TYPE, LanternIntegerTraits.SAPLING_GROWTH_STAGE)\n\n.build(\"minecraft\", \"planks\"),\nblockState -> (byte) blockState.getTraitValue(LanternEnumTraits.TREE_TYPE).get().getInternalId());\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\/\/\/ Sapling \/\/\/\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\nregister(6, simpleBuilder()\n.traits(LanternEnumTraits.TREE_TYPE, LanternIntegerTraits.SAPLING_GROWTH_STAGE)\n\nreturn (byte) type;\n});\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\/\/\/ Golden Rail \/\/\/\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\nregister(27, simpleBuilder()\n.traits(LanternEnumTraits.STRAIGHT_RAIL_DIRECTION, LanternBooleanTraits.POWERED)\n\n.build(\"minecraft\", \"planks\"),\nblockState -> (byte) blockState.getTraitValue(LanternEnumTraits.TREE_TYPE).get().getInternalId());\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\/\/\/ Sapling \/\/\/\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\nregister(6, simpleBuilder()\n.traits(LanternEnumTraits.TREE_TYPE, LanternIntegerTraits.SAPLING_GROWTH_STAGE)\n\n.add(hardness(3.5))\n.add(blastResistance(17.5)))\n\/\/ .tileEntityType(() -> TileEntityTypes.DROPPER)\n.translation(\"tile.dropper.name\")\n.behaviors(pipeline -> pipeline\n\n.build(\"minecraft\", \"trapped_chest\"),\nthis::horizontalFacingData);\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\/\/\/ Weighted Pressure Plate (Light) \/\/\/\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\nregister(147, weightedPressurePlateBuilder()\n.translation(\"tile.weightedPlate_light.name\")\n\n.build(\"minecraft\", \"red_flower\"),\nblockState -> (byte) blockState.getTraitValue(LanternEnumTraits.RED_FLOWER_TYPE).get().getInternalId());\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\/\/\/ Brown Mushroom \/\/\/\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\nregister(39, simpleBuilder()\n.selectionBox(BoundingBoxes.bush())\n\n.build(\"minecraft\", \"planks\"),\nblockState -> (byte) blockState.getTraitValue(LanternEnumTraits.TREE_TYPE).get().getInternalId());\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\/\/\/ Sapling \/\/\/\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\nregister(6, simpleBuilder()\n.traits(LanternEnumTraits.TREE_TYPE, LanternIntegerTraits.SAPLING_GROWTH_STAGE)\n\n.build(\"minecraft\", \"planks\"),\nblockState -> (byte) blockState.getTraitValue(LanternEnumTraits.TREE_TYPE).get().getInternalId());\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\/\/\/ Sapling \/\/\/\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\nregister(6, simpleBuilder()\n.traits(LanternEnumTraits.TREE_TYPE, LanternIntegerTraits.SAPLING_GROWTH_STAGE)\n\n.build(\"minecraft\", \"planks\"),\nblockState -> (byte) blockState.getTraitValue(LanternEnumTraits.TREE_TYPE).get().getInternalId());\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\/\/\/ Sapling \/\/\/\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\nregister(6, simpleBuilder()\n.traits(LanternEnumTraits.TREE_TYPE, LanternIntegerTraits.SAPLING_GROWTH_STAGE)\n\nreturn (byte) type;\n});\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\/\/\/ Golden Rail \/\/\/\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\nregister(27, simpleBuilder()\n.traits(LanternEnumTraits.STRAIGHT_RAIL_DIRECTION, LanternBooleanTraits.POWERED)\n\nreturn (byte) type;\n});\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\/\/\/ Golden Rail \/\/\/\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\nregister(27, simpleBuilder()\n.traits(LanternEnumTraits.STRAIGHT_RAIL_DIRECTION, LanternBooleanTraits.POWERED)\n\n.translation(\"tile.blockIron.name\")\n.build(\"minecraft\", \"iron_block\"));\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\/\/\/ Double Stone Slab 1 \/\/\/\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\nregister(43, doubleStoneSlab(LanternEnumTraits.STONE_SLAB1_TYPE, LanternSlabType.STONE)\n.translation(\"tile.stoneSlab.name\")\n\nreturn (byte) type;\n});\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\/\/\/ Detector Rail \/\/\/\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\nregister(28, simpleBuilder()\n.traits(LanternEnumTraits.STRAIGHT_RAIL_DIRECTION, LanternBooleanTraits.POWERED)\n\npublic void registerDefaults() {\n\/\/ @formatter:off\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\/\/\/ Air \/\/\/\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\nregister(0, builder()\n.properties(PropertyProviderCollections.DEFAULT_GAS)\n\n.translation(\"tile.blockIron.name\")\n.build(\"minecraft\", \"iron_block\"));\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\/\/\/ Double Stone Slab 1 \/\/\/\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\nregister(43, doubleStoneSlab(LanternEnumTraits.STONE_SLAB1_TYPE, LanternSlabType.STONE)\n.translation(\"tile.stoneSlab.name\")\n\n.translation(\"tile.blockIron.name\")\n.build(\"minecraft\", \"iron_block\"));\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\/\/\/ Double Stone Slab 1 \/\/\/\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\nregister(43, doubleStoneSlab(LanternEnumTraits.STONE_SLAB1_TYPE, LanternSlabType.STONE)\n.translation(\"tile.stoneSlab.name\")\n\n.translation(\"tile.bookshelf.name\")\n.build(\"minecraft\", \"bookshelf\"));\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\/\/\/ Mossy Cobblestone \/\/\/\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\nregister(48, simpleBuilder()\n.itemType()\n\n.build(\"minecraft\", \"trapped_chest\"),\nthis::horizontalFacingData);\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\/\/\/ Weighted Pressure Plate (Light) \/\/\/\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\nregister(147, weightedPressurePlateBuilder()\n.translation(\"tile.weightedPlate_light.name\")\n\n.translation(\"tile.blockIron.name\")\n.build(\"minecraft\", \"iron_block\"));\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\/\/\/ Double Stone Slab 1 \/\/\/\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\nregister(43, doubleStoneSlab(LanternEnumTraits.STONE_SLAB1_TYPE, LanternSlabType.STONE)\n.translation(\"tile.stoneSlab.name\")\n\nthis::dyedData);\n\/\/ TODO: 36\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\/\/\/ Yellow Flower \/\/\/\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\nregister(37, simpleBuilder()\n.traits(LanternEnumTraits.YELLOW_FLOWER_TYPE)\n\nthis::dyedData);\n\/\/ TODO: 36\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\/\/\/ Yellow Flower \/\/\/\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\nregister(37, simpleBuilder()\n.traits(LanternEnumTraits.YELLOW_FLOWER_TYPE)\n\nthis::dyedData);\n\/\/ TODO: 36\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\/\/\/ Yellow Flower \/\/\/\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\nregister(37, simpleBuilder()\n.traits(LanternEnumTraits.YELLOW_FLOWER_TYPE)\n\nthis::dyedData);\n\/\/ TODO: 36\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\/\/\/ Yellow Flower \/\/\/\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\nregister(37, simpleBuilder()\n.traits(LanternEnumTraits.YELLOW_FLOWER_TYPE)\n\nthis::dyedData);\n\/\/ TODO: 36\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\/\/\/ Yellow Flower \/\/\/\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\nregister(37, simpleBuilder()\n.traits(LanternEnumTraits.YELLOW_FLOWER_TYPE)\n\n.translation(\"tile.blockIron.name\")\n.build(\"minecraft\", \"iron_block\"));\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\/\/\/ Double Stone Slab 1 \/\/\/\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\nregister(43, doubleStoneSlab(LanternEnumTraits.STONE_SLAB1_TYPE, LanternSlabType.STONE)\n.translation(\"tile.stoneSlab.name\")\n\nthis::dyedData);\n\/\/ TODO: 36\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\/\/\/ Yellow Flower \/\/\/\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\nregister(37, simpleBuilder()\n.traits(LanternEnumTraits.YELLOW_FLOWER_TYPE)\n\n.build(\"minecraft\", \"red_flower\"),\nblockState -> (byte) blockState.getTraitValue(LanternEnumTraits.RED_FLOWER_TYPE).get().getInternalId());\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\/\/\/ Brown Mushroom \/\/\/\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\nregister(39, simpleBuilder()\n.selectionBox(BoundingBoxes.bush())\n\n.build(\"minecraft\", \"red_flower\"),\nblockState -> (byte) blockState.getTraitValue(LanternEnumTraits.RED_FLOWER_TYPE).get().getInternalId());\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\/\/\/ Brown Mushroom \/\/\/\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\nregister(39, simpleBuilder()\n.selectionBox(BoundingBoxes.bush())\n\nreturn (byte) type;\n});\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\/\/\/ Detector Rail \/\/\/\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\nregister(28, simpleBuilder()\n.traits(LanternEnumTraits.STRAIGHT_RAIL_DIRECTION, LanternBooleanTraits.POWERED)\n\n.build(\"minecraft\", \"red_flower\"),\nblockState -> (byte) blockState.getTraitValue(LanternEnumTraits.RED_FLOWER_TYPE).get().getInternalId());\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\/\/\/ Brown Mushroom \/\/\/\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\nregister(39, simpleBuilder()\n.selectionBox(BoundingBoxes.bush())\n\npublic void registerDefaults() {\n\/\/ @formatter:off\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\/\/\/ Air \/\/\/\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\nregister(0, builder()\n.properties(PropertyProviderCollections.DEFAULT_GAS)\n\npublic void registerDefaults() {\n\/\/ @formatter:off\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\/\/\/ Air \/\/\/\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\nregister(0, builder()\n.properties(PropertyProviderCollections.DEFAULT_GAS)\n\n.build(\"minecraft\", \"wall_banner\"),\nthis::horizontalFacingData);\n\/\/ @formatter:on\n}","code_context_10":"@Override\npublic void registerDefaults() {\n\/\/ @formatter:off\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\/\/\/ Air \/\/\/\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\nregister(0, builder()\n.properties(PropertyProviderCollections.DEFAULT_GAS)\n.translation(\"tile.air.name\")\n.build(\"minecraft\", \"air\"));\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\/\/\/ Stone \/\/\/\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\nregister(1, simpleBuilder()\n.trait(LanternEnumTraits.STONE_TYPE)\n.defaultState(state -> state.withTrait(LanternEnumTraits.STONE_TYPE, LanternStoneType.STONE).get())\n\n@Override\npublic void registerDefaults() {\n\/\/ @formatter:off\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\/\/\/ Air \/\/\/\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\nregister(0, builder()\n.properties(PropertyProviderCollections.DEFAULT_GAS)\n.translation(\"tile.air.name\")\n.build(\"minecraft\", \"air\"));\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\/\/\/ Stone \/\/\/\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\nregister(1, simpleBuilder()\n.trait(LanternEnumTraits.STONE_TYPE)\n.defaultState(state -> state.withTrait(LanternEnumTraits.STONE_TYPE, LanternStoneType.STONE).get())\n\n@Override\npublic void registerDefaults() {\n\/\/ @formatter:off\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\/\/\/ Air \/\/\/\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\nregister(0, builder()\n.properties(PropertyProviderCollections.DEFAULT_GAS)\n.translation(\"tile.air.name\")\n.build(\"minecraft\", \"air\"));\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\/\/\/ Stone \/\/\/\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\nregister(1, simpleBuilder()\n.trait(LanternEnumTraits.STONE_TYPE)\n.defaultState(state -> state.withTrait(LanternEnumTraits.STONE_TYPE, LanternStoneType.STONE).get())\n\n@Override\npublic void registerDefaults() {\n\/\/ @formatter:off\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\/\/\/ Air \/\/\/\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\nregister(0, builder()\n.properties(PropertyProviderCollections.DEFAULT_GAS)\n.translation(\"tile.air.name\")\n.build(\"minecraft\", \"air\"));\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\/\/\/ Stone \/\/\/\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\nregister(1, simpleBuilder()\n.trait(LanternEnumTraits.STONE_TYPE)\n.defaultState(state -> state.withTrait(LanternEnumTraits.STONE_TYPE, LanternStoneType.STONE).get())\n\n@Override\npublic void registerDefaults() {\n\/\/ @formatter:off\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\/\/\/ Air \/\/\/\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\nregister(0, builder()\n.properties(PropertyProviderCollections.DEFAULT_GAS)\n.translation(\"tile.air.name\")\n.build(\"minecraft\", \"air\"));\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\/\/\/ Stone \/\/\/\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\nregister(1, simpleBuilder()\n.trait(LanternEnumTraits.STONE_TYPE)\n.defaultState(state -> state.withTrait(LanternEnumTraits.STONE_TYPE, LanternStoneType.STONE).get())\n\n@Override\npublic void registerDefaults() {\n\/\/ @formatter:off\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\/\/\/ Air \/\/\/\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\nregister(0, builder()\n.properties(PropertyProviderCollections.DEFAULT_GAS)\n.translation(\"tile.air.name\")\n.build(\"minecraft\", \"air\"));\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\/\/\/ Stone \/\/\/\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\nregister(1, simpleBuilder()\n.trait(LanternEnumTraits.STONE_TYPE)\n.defaultState(state -> state.withTrait(LanternEnumTraits.STONE_TYPE, LanternStoneType.STONE).get())\n\n)\n)\n.properties(builder -> builder\n.add(hardness(2.0))\n.add(blastResistance(5.0))\n.add(flammableInfo(5, 20)))\n.translation(TranslationProvider.of(LanternEnumTraits.TREE_TYPE, type ->\ntr(\"tile.planks.\" + type.getTranslationKeyBase() + \".name\")))\n.build(\"minecraft\", \"planks\"),\nblockState -> (byte) blockState.getTraitValue(LanternEnumTraits.TREE_TYPE).get().getInternalId());\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\/\/\/ Sapling \/\/\/\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\nregister(6, simpleBuilder()\n.traits(LanternEnumTraits.TREE_TYPE, LanternIntegerTraits.SAPLING_GROWTH_STAGE)\n.defaultState(state -> state\n.withTrait(LanternEnumTraits.TREE_TYPE, LanternTreeType.OAK).get()\n.withTrait(LanternIntegerTraits.SAPLING_GROWTH_STAGE, 0).get())\n.itemType(builder -> builder\n.keysProvider(collection -> collection\n.register(Keys.TREE_TYPE, LanternTreeType.OAK)\n)\n)\n\n)\n)\n.properties(builder -> builder\n.add(hardness(2.0))\n.add(blastResistance(5.0))\n.add(flammableInfo(5, 20)))\n.translation(TranslationProvider.of(LanternEnumTraits.TREE_TYPE, type ->\ntr(\"tile.planks.\" + type.getTranslationKeyBase() + \".name\")))\n.build(\"minecraft\", \"planks\"),\nblockState -> (byte) blockState.getTraitValue(LanternEnumTraits.TREE_TYPE).get().getInternalId());\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\/\/\/ Sapling \/\/\/\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\nregister(6, simpleBuilder()\n.traits(LanternEnumTraits.TREE_TYPE, LanternIntegerTraits.SAPLING_GROWTH_STAGE)\n.defaultState(state -> state\n.withTrait(LanternEnumTraits.TREE_TYPE, LanternTreeType.OAK).get()\n.withTrait(LanternIntegerTraits.SAPLING_GROWTH_STAGE, 0).get())\n.itemType(builder -> builder\n.keysProvider(collection -> collection\n.register(Keys.TREE_TYPE, LanternTreeType.OAK)\n)\n)\n\n)\n)\n.properties(builder -> builder\n.add(hardness(2.0))\n.add(blastResistance(5.0))\n.add(flammableInfo(5, 20)))\n.translation(TranslationProvider.of(LanternEnumTraits.TREE_TYPE, type ->\ntr(\"tile.planks.\" + type.getTranslationKeyBase() + \".name\")))\n.build(\"minecraft\", \"planks\"),\nblockState -> (byte) blockState.getTraitValue(LanternEnumTraits.TREE_TYPE).get().getInternalId());\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\/\/\/ Sapling \/\/\/\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\nregister(6, simpleBuilder()\n.traits(LanternEnumTraits.TREE_TYPE, LanternIntegerTraits.SAPLING_GROWTH_STAGE)\n.defaultState(state -> state\n.withTrait(LanternEnumTraits.TREE_TYPE, LanternTreeType.OAK).get()\n.withTrait(LanternIntegerTraits.SAPLING_GROWTH_STAGE, 0).get())\n.itemType(builder -> builder\n.keysProvider(collection -> collection\n.register(Keys.TREE_TYPE, LanternTreeType.OAK)\n)\n)\n\n.keysProvider(collection -> collection\n.register(Keys.SAND_TYPE, LanternSandType.NORMAL)\n)\n)\n.properties(builder -> builder\n.add(hardness(0.5))\n.add(blastResistance(2.5)))\n.translation(TranslationProvider.of(LanternEnumTraits.SAND_TYPE))\n.build(\"minecraft\", \"sand\"),\nblockState -> (byte) blockState.getTraitValue(LanternEnumTraits.SAND_TYPE).get().getInternalId());\n\/\/ TODO: Sand physics behavior\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\/\/\/ Gravel \/\/\/\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\nregister(13, simpleBuilder()\n.itemType()\n.properties(builder -> builder\n.add(hardness(0.6))\n.add(blastResistance(3.0)))\n.translation(\"tile.gravel.name\")\n.build(\"minecraft\", \"gravel\"));\n\/\/ TODO: Gravel physics behavior\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\/\/\/ Gold Ore \/\/\/\n\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\/\/\/ Gravel \/\/\/\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\nregister(13, simpleBuilder()\n.itemType()\n.properties(builder -> builder\n.add(hardness(0.6))\n.add(blastResistance(3.0)))\n.translation(\"tile.gravel.name\")\n.build(\"minecraft\", \"gravel\"));\n\/\/ TODO: Gravel physics behavior\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\/\/\/ Gold Ore \/\/\/\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\nregister(14, simpleBuilder()\n.itemType()\n.properties(builder -> builder\n.add(hardness(3.0))\n.add(blastResistance(15.0)))\n.translation(\"tile.oreGold.name\")\n.build(\"minecraft\", \"gold_ore\"));\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\/\/\/ Iron Ore \/\/\/\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\n)\n)\n.properties(builder -> builder\n.add(hardness(2.0))\n.add(blastResistance(5.0))\n.add(flammableInfo(5, 20)))\n.translation(TranslationProvider.of(LanternEnumTraits.TREE_TYPE, type ->\ntr(\"tile.planks.\" + type.getTranslationKeyBase() + \".name\")))\n.build(\"minecraft\", \"planks\"),\nblockState -> (byte) blockState.getTraitValue(LanternEnumTraits.TREE_TYPE).get().getInternalId());\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\/\/\/ Sapling \/\/\/\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\nregister(6, simpleBuilder()\n.traits(LanternEnumTraits.TREE_TYPE, LanternIntegerTraits.SAPLING_GROWTH_STAGE)\n.defaultState(state -> state\n.withTrait(LanternEnumTraits.TREE_TYPE, LanternTreeType.OAK).get()\n.withTrait(LanternIntegerTraits.SAPLING_GROWTH_STAGE, 0).get())\n.itemType(builder -> builder\n.keysProvider(collection -> collection\n.register(Keys.TREE_TYPE, LanternTreeType.OAK)\n)\n)\n\n)\n)\n.properties(builder -> builder\n.add(hardness(2.0))\n.add(blastResistance(5.0))\n.add(flammableInfo(5, 20)))\n.translation(TranslationProvider.of(LanternEnumTraits.TREE_TYPE, type ->\ntr(\"tile.planks.\" + type.getTranslationKeyBase() + \".name\")))\n.build(\"minecraft\", \"planks\"),\nblockState -> (byte) blockState.getTraitValue(LanternEnumTraits.TREE_TYPE).get().getInternalId());\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\/\/\/ Sapling \/\/\/\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\nregister(6, simpleBuilder()\n.traits(LanternEnumTraits.TREE_TYPE, LanternIntegerTraits.SAPLING_GROWTH_STAGE)\n.defaultState(state -> state\n.withTrait(LanternEnumTraits.TREE_TYPE, LanternTreeType.OAK).get()\n.withTrait(LanternIntegerTraits.SAPLING_GROWTH_STAGE, 0).get())\n.itemType(builder -> builder\n.keysProvider(collection -> collection\n.register(Keys.TREE_TYPE, LanternTreeType.OAK)\n)\n)\n\n)\n)\n.properties(builder -> builder\n.add(hardness(2.0))\n.add(blastResistance(5.0))\n.add(flammableInfo(5, 20)))\n.translation(TranslationProvider.of(LanternEnumTraits.TREE_TYPE, type ->\ntr(\"tile.planks.\" + type.getTranslationKeyBase() + \".name\")))\n.build(\"minecraft\", \"planks\"),\nblockState -> (byte) blockState.getTraitValue(LanternEnumTraits.TREE_TYPE).get().getInternalId());\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\/\/\/ Sapling \/\/\/\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\nregister(6, simpleBuilder()\n.traits(LanternEnumTraits.TREE_TYPE, LanternIntegerTraits.SAPLING_GROWTH_STAGE)\n.defaultState(state -> state\n.withTrait(LanternEnumTraits.TREE_TYPE, LanternTreeType.OAK).get()\n.withTrait(LanternIntegerTraits.SAPLING_GROWTH_STAGE, 0).get())\n.itemType(builder -> builder\n.keysProvider(collection -> collection\n.register(Keys.TREE_TYPE, LanternTreeType.OAK)\n)\n)\n\n)\n)\n.properties(builder -> builder\n.add(hardness(2.0))\n.add(blastResistance(5.0))\n.add(flammableInfo(5, 20)))\n.translation(TranslationProvider.of(LanternEnumTraits.TREE_TYPE, type ->\ntr(\"tile.planks.\" + type.getTranslationKeyBase() + \".name\")))\n.build(\"minecraft\", \"planks\"),\nblockState -> (byte) blockState.getTraitValue(LanternEnumTraits.TREE_TYPE).get().getInternalId());\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\/\/\/ Sapling \/\/\/\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\nregister(6, simpleBuilder()\n.traits(LanternEnumTraits.TREE_TYPE, LanternIntegerTraits.SAPLING_GROWTH_STAGE)\n.defaultState(state -> state\n.withTrait(LanternEnumTraits.TREE_TYPE, LanternTreeType.OAK).get()\n.withTrait(LanternIntegerTraits.SAPLING_GROWTH_STAGE, 0).get())\n.itemType(builder -> builder\n.keysProvider(collection -> collection\n.register(Keys.TREE_TYPE, LanternTreeType.OAK)\n)\n)\n\n)\n)\n.properties(builder -> builder\n.add(hardness(2.0))\n.add(blastResistance(5.0))\n.add(flammableInfo(5, 20)))\n.translation(TranslationProvider.of(LanternEnumTraits.TREE_TYPE, type ->\ntr(\"tile.planks.\" + type.getTranslationKeyBase() + \".name\")))\n.build(\"minecraft\", \"planks\"),\nblockState -> (byte) blockState.getTraitValue(LanternEnumTraits.TREE_TYPE).get().getInternalId());\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\/\/\/ Sapling \/\/\/\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\nregister(6, simpleBuilder()\n.traits(LanternEnumTraits.TREE_TYPE, LanternIntegerTraits.SAPLING_GROWTH_STAGE)\n.defaultState(state -> state\n.withTrait(LanternEnumTraits.TREE_TYPE, LanternTreeType.OAK).get()\n.withTrait(LanternIntegerTraits.SAPLING_GROWTH_STAGE, 0).get())\n.itemType(builder -> builder\n.keysProvider(collection -> collection\n.register(Keys.TREE_TYPE, LanternTreeType.OAK)\n)\n)\n\n)\n)\n.properties(builder -> builder\n.add(hardness(2.0))\n.add(blastResistance(5.0))\n.add(flammableInfo(5, 20)))\n.translation(TranslationProvider.of(LanternEnumTraits.TREE_TYPE, type ->\ntr(\"tile.planks.\" + type.getTranslationKeyBase() + \".name\")))\n.build(\"minecraft\", \"planks\"),\nblockState -> (byte) blockState.getTraitValue(LanternEnumTraits.TREE_TYPE).get().getInternalId());\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\/\/\/ Sapling \/\/\/\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\nregister(6, simpleBuilder()\n.traits(LanternEnumTraits.TREE_TYPE, LanternIntegerTraits.SAPLING_GROWTH_STAGE)\n.defaultState(state -> state\n.withTrait(LanternEnumTraits.TREE_TYPE, LanternTreeType.OAK).get()\n.withTrait(LanternIntegerTraits.SAPLING_GROWTH_STAGE, 0).get())\n.itemType(builder -> builder\n.keysProvider(collection -> collection\n.register(Keys.TREE_TYPE, LanternTreeType.OAK)\n)\n)\n\n)\n)\n.properties(builder -> builder\n.add(hardness(2.0))\n.add(blastResistance(5.0))\n.add(flammableInfo(5, 20)))\n.translation(TranslationProvider.of(LanternEnumTraits.TREE_TYPE, type ->\ntr(\"tile.planks.\" + type.getTranslationKeyBase() + \".name\")))\n.build(\"minecraft\", \"planks\"),\nblockState -> (byte) blockState.getTraitValue(LanternEnumTraits.TREE_TYPE).get().getInternalId());\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\/\/\/ Sapling \/\/\/\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\nregister(6, simpleBuilder()\n.traits(LanternEnumTraits.TREE_TYPE, LanternIntegerTraits.SAPLING_GROWTH_STAGE)\n.defaultState(state -> state\n.withTrait(LanternEnumTraits.TREE_TYPE, LanternTreeType.OAK).get()\n.withTrait(LanternIntegerTraits.SAPLING_GROWTH_STAGE, 0).get())\n.itemType(builder -> builder\n.keysProvider(collection -> collection\n.register(Keys.TREE_TYPE, LanternTreeType.OAK)\n)\n)\n\n)\n)\n.properties(builder -> builder\n.add(hardness(2.0))\n.add(blastResistance(5.0))\n.add(flammableInfo(5, 20)))\n.translation(TranslationProvider.of(LanternEnumTraits.TREE_TYPE, type ->\ntr(\"tile.planks.\" + type.getTranslationKeyBase() + \".name\")))\n.build(\"minecraft\", \"planks\"),\nblockState -> (byte) blockState.getTraitValue(LanternEnumTraits.TREE_TYPE).get().getInternalId());\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\/\/\/ Sapling \/\/\/\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\nregister(6, simpleBuilder()\n.traits(LanternEnumTraits.TREE_TYPE, LanternIntegerTraits.SAPLING_GROWTH_STAGE)\n.defaultState(state -> state\n.withTrait(LanternEnumTraits.TREE_TYPE, LanternTreeType.OAK).get()\n.withTrait(LanternIntegerTraits.SAPLING_GROWTH_STAGE, 0).get())\n.itemType(builder -> builder\n.keysProvider(collection -> collection\n.register(Keys.TREE_TYPE, LanternTreeType.OAK)\n)\n)\n\n)\n)\n.properties(builder -> builder\n.add(hardness(2.0))\n.add(blastResistance(5.0))\n.add(flammableInfo(5, 20)))\n.translation(TranslationProvider.of(LanternEnumTraits.TREE_TYPE, type ->\ntr(\"tile.planks.\" + type.getTranslationKeyBase() + \".name\")))\n.build(\"minecraft\", \"planks\"),\nblockState -> (byte) blockState.getTraitValue(LanternEnumTraits.TREE_TYPE).get().getInternalId());\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\/\/\/ Sapling \/\/\/\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\nregister(6, simpleBuilder()\n.traits(LanternEnumTraits.TREE_TYPE, LanternIntegerTraits.SAPLING_GROWTH_STAGE)\n.defaultState(state -> state\n.withTrait(LanternEnumTraits.TREE_TYPE, LanternTreeType.OAK).get()\n.withTrait(LanternIntegerTraits.SAPLING_GROWTH_STAGE, 0).get())\n.itemType(builder -> builder\n.keysProvider(collection -> collection\n.register(Keys.TREE_TYPE, LanternTreeType.OAK)\n)\n)\n\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\nregister(23, simpleBuilder()\n.traits(LanternEnumTraits.FACING, LanternBooleanTraits.TRIGGERED)\n.defaultState(state -> state\n.withTrait(LanternEnumTraits.FACING, Direction.NORTH).get()\n.withTrait(LanternBooleanTraits.TRIGGERED, false).get())\n.itemType()\n.properties(builder -> builder\n.add(hardness(3.5))\n.add(blastResistance(17.5)))\n\/\/ .tileEntityType(() -> TileEntityTypes.DISPENSER)\n.translation(\"tile.dispenser.name\")\n.behaviors(pipeline -> pipeline\n.add(new RotationPlacementBehavior()))\n.build(\"minecraft\", \"dispenser\"),\nblockState -> {\nint data = directionData(blockState.getTraitValue(LanternEnumTraits.FACING).get());\nif (blockState.getTraitValue(LanternBooleanTraits.TRIGGERED).get()) {\ndata |= 0x8;\n}\nreturn (byte) data;\n\n)\n)\n.properties(builder -> builder\n.add(hardness(2.0))\n.add(blastResistance(5.0))\n.add(flammableInfo(5, 20)))\n.translation(TranslationProvider.of(LanternEnumTraits.TREE_TYPE, type ->\ntr(\"tile.planks.\" + type.getTranslationKeyBase() + \".name\")))\n.build(\"minecraft\", \"planks\"),\nblockState -> (byte) blockState.getTraitValue(LanternEnumTraits.TREE_TYPE).get().getInternalId());\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\/\/\/ Sapling \/\/\/\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\nregister(6, simpleBuilder()\n.traits(LanternEnumTraits.TREE_TYPE, LanternIntegerTraits.SAPLING_GROWTH_STAGE)\n.defaultState(state -> state\n.withTrait(LanternEnumTraits.TREE_TYPE, LanternTreeType.OAK).get()\n.withTrait(LanternIntegerTraits.SAPLING_GROWTH_STAGE, 0).get())\n.itemType(builder -> builder\n.keysProvider(collection -> collection\n.register(Keys.TREE_TYPE, LanternTreeType.OAK)\n)\n)\n\n)\n)\n.properties(builder -> builder\n.add(hardness(2.0))\n.add(blastResistance(5.0))\n.add(flammableInfo(5, 20)))\n.translation(TranslationProvider.of(LanternEnumTraits.TREE_TYPE, type ->\ntr(\"tile.planks.\" + type.getTranslationKeyBase() + \".name\")))\n.build(\"minecraft\", \"planks\"),\nblockState -> (byte) blockState.getTraitValue(LanternEnumTraits.TREE_TYPE).get().getInternalId());\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\/\/\/ Sapling \/\/\/\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\nregister(6, simpleBuilder()\n.traits(LanternEnumTraits.TREE_TYPE, LanternIntegerTraits.SAPLING_GROWTH_STAGE)\n.defaultState(state -> state\n.withTrait(LanternEnumTraits.TREE_TYPE, LanternTreeType.OAK).get()\n.withTrait(LanternIntegerTraits.SAPLING_GROWTH_STAGE, 0).get())\n.itemType(builder -> builder\n.keysProvider(collection -> collection\n.register(Keys.TREE_TYPE, LanternTreeType.OAK)\n)\n)\n\n)\n)\n.properties(builder -> builder\n.add(hardness(2.0))\n.add(blastResistance(5.0))\n.add(flammableInfo(5, 20)))\n.translation(TranslationProvider.of(LanternEnumTraits.TREE_TYPE, type ->\ntr(\"tile.planks.\" + type.getTranslationKeyBase() + \".name\")))\n.build(\"minecraft\", \"planks\"),\nblockState -> (byte) blockState.getTraitValue(LanternEnumTraits.TREE_TYPE).get().getInternalId());\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\/\/\/ Sapling \/\/\/\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\nregister(6, simpleBuilder()\n.traits(LanternEnumTraits.TREE_TYPE, LanternIntegerTraits.SAPLING_GROWTH_STAGE)\n.defaultState(state -> state\n.withTrait(LanternEnumTraits.TREE_TYPE, LanternTreeType.OAK).get()\n.withTrait(LanternIntegerTraits.SAPLING_GROWTH_STAGE, 0).get())\n.itemType(builder -> builder\n.keysProvider(collection -> collection\n.register(Keys.TREE_TYPE, LanternTreeType.OAK)\n)\n)\n\nfacing == Direction.NORTH ? 2 : facing == Direction.EAST ? 3 : -1;\ncheckArgument(type != -1);\nif (blockState.getTraitValue(LanternBooleanTraits.OCCUPIED).get()) {\ntype |= 0x4;\n}\nif (blockState.getTraitValue(LanternEnumTraits.BED_PART).get() == LanternBedPart.HEAD) {\ntype |= 0x8;\n}\nreturn (byte) type;\n});\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\/\/\/ Golden Rail \/\/\/\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\nregister(27, simpleBuilder()\n.traits(LanternEnumTraits.STRAIGHT_RAIL_DIRECTION, LanternBooleanTraits.POWERED)\n.defaultState(state -> state\n.withTrait(LanternEnumTraits.STRAIGHT_RAIL_DIRECTION, LanternRailDirection.NORTH_SOUTH).get()\n.withTrait(LanternBooleanTraits.POWERED, false).get())\n.itemType()\n.selectionBox(BoundingBoxes::rail)\n.properties(builder -> builder\n.add(PASSABLE)\n.add(hardness(0.7))\n\n.add(blastResistance(3.5)))\n.translation(\"tile.goldenRail.name\")\n.build(\"minecraft\", \"golden_rail\"),\nblockState -> {\nint type = blockState.getTraitValue(LanternEnumTraits.STRAIGHT_RAIL_DIRECTION).get().getInternalId();\nif (blockState.getTraitValue(LanternBooleanTraits.POWERED).get()) {\ntype |= 0x8;\n}\nreturn (byte) type;\n});\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\/\/\/ Detector Rail \/\/\/\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\nregister(28, simpleBuilder()\n.traits(LanternEnumTraits.STRAIGHT_RAIL_DIRECTION, LanternBooleanTraits.POWERED)\n.defaultState(state -> state\n.withTrait(LanternEnumTraits.STRAIGHT_RAIL_DIRECTION, LanternRailDirection.NORTH_SOUTH).get()\n.withTrait(LanternBooleanTraits.POWERED, false).get())\n.itemType()\n.selectionBox(BoundingBoxes::rail)\n.properties(builder -> builder\n.add(PASSABLE)\n.add(hardness(0.7))\n\n.add(blastResistance(3.5)))\n.translation(\"tile.detectorRail.name\")\n.build(\"minecraft\", \"detector_rail\"),\nblockState -> {\nint type = blockState.getTraitValue(LanternEnumTraits.STRAIGHT_RAIL_DIRECTION).get().getInternalId();\nif (blockState.getTraitValue(LanternBooleanTraits.POWERED).get()) {\ntype |= 0x8;\n}\nreturn (byte) type;\n});\n\/\/ TODO: 29\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\/\/\/ Web \/\/\/\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\nregister(30, simpleBuilder()\n.itemType()\n.properties(builder -> builder\n.add(PASSABLE)\n.add(hardness(4.0))\n.add(blastResistance(20.0)))\n.translation(\"tile.web.name\")\n.build(\"minecraft\", \"web\"));\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\/\/\/ Tall Grass \/\/\/\n\nfacing == Direction.NORTH ? 2 : facing == Direction.EAST ? 3 : -1;\ncheckArgument(type != -1);\nif (blockState.getTraitValue(LanternBooleanTraits.OCCUPIED).get()) {\ntype |= 0x4;\n}\nif (blockState.getTraitValue(LanternEnumTraits.BED_PART).get() == LanternBedPart.HEAD) {\ntype |= 0x8;\n}\nreturn (byte) type;\n});\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\/\/\/ Golden Rail \/\/\/\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\nregister(27, simpleBuilder()\n.traits(LanternEnumTraits.STRAIGHT_RAIL_DIRECTION, LanternBooleanTraits.POWERED)\n.defaultState(state -> state\n.withTrait(LanternEnumTraits.STRAIGHT_RAIL_DIRECTION, LanternRailDirection.NORTH_SOUTH).get()\n.withTrait(LanternBooleanTraits.POWERED, false).get())\n.itemType()\n.selectionBox(BoundingBoxes::rail)\n.properties(builder -> builder\n.add(PASSABLE)\n.add(hardness(0.7))\n\nfacing == Direction.NORTH ? 2 : facing == Direction.EAST ? 3 : -1;\ncheckArgument(type != -1);\nif (blockState.getTraitValue(LanternBooleanTraits.OCCUPIED).get()) {\ntype |= 0x4;\n}\nif (blockState.getTraitValue(LanternEnumTraits.BED_PART).get() == LanternBedPart.HEAD) {\ntype |= 0x8;\n}\nreturn (byte) type;\n});\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\/\/\/ Golden Rail \/\/\/\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\nregister(27, simpleBuilder()\n.traits(LanternEnumTraits.STRAIGHT_RAIL_DIRECTION, LanternBooleanTraits.POWERED)\n.defaultState(state -> state\n.withTrait(LanternEnumTraits.STRAIGHT_RAIL_DIRECTION, LanternRailDirection.NORTH_SOUTH).get()\n.withTrait(LanternBooleanTraits.POWERED, false).get())\n.itemType()\n.selectionBox(BoundingBoxes::rail)\n.properties(builder -> builder\n.add(PASSABLE)\n.add(hardness(0.7))\n\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\nregister(32, simpleBuilder()\n.properties(builder -> builder\n.add(INSTANT_BROKEN)\n.add(PASSABLE)\n.add(replaceable(true)))\n.selectionBox(BoundingBoxes.bush())\n.itemType()\n.translation(\"tile.deadbush.name\")\n.build(\"minecraft\", \"deadbush\"));\n\/\/ TODO: 33\n\/\/ TODO: 34\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\/\/\/ Wool \/\/\/\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\nregister(35, dyedBuilder(\"tile.wool.%s.name\")\n.properties(builder -> builder\n.add(hardness(0.8))\n.add(blastResistance(4.0)))\n.build(\"minecraft\", \"wool\"),\nthis::dyedData);\n\/\/ TODO: 36\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\/\/\/ Yellow Flower \/\/\/\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\n\/\/ TODO: 34\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\/\/\/ Wool \/\/\/\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\nregister(35, dyedBuilder(\"tile.wool.%s.name\")\n.properties(builder -> builder\n.add(hardness(0.8))\n.add(blastResistance(4.0)))\n.build(\"minecraft\", \"wool\"),\nthis::dyedData);\n\/\/ TODO: 36\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\/\/\/ Yellow Flower \/\/\/\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\nregister(37, simpleBuilder()\n.traits(LanternEnumTraits.YELLOW_FLOWER_TYPE)\n.defaultState(state -> state\n.withTrait(LanternEnumTraits.YELLOW_FLOWER_TYPE, LanternPlantType.DANDELION).get())\n.itemType(builder -> builder\n.keysProvider(collection -> collection\n.register(Keys.PLANT_TYPE, LanternPlantType.DANDELION)))\n.selectionBox(BoundingBoxes.bush())\n.properties(builder -> builder\n.add(INSTANT_BROKEN)\n\nfacing == Direction.NORTH ? 2 : facing == Direction.EAST ? 3 : -1;\ncheckArgument(type != -1);\nif (blockState.getTraitValue(LanternBooleanTraits.OCCUPIED).get()) {\ntype |= 0x4;\n}\nif (blockState.getTraitValue(LanternEnumTraits.BED_PART).get() == LanternBedPart.HEAD) {\ntype |= 0x8;\n}\nreturn (byte) type;\n});\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\/\/\/ Golden Rail \/\/\/\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\nregister(27, simpleBuilder()\n.traits(LanternEnumTraits.STRAIGHT_RAIL_DIRECTION, LanternBooleanTraits.POWERED)\n.defaultState(state -> state\n.withTrait(LanternEnumTraits.STRAIGHT_RAIL_DIRECTION, LanternRailDirection.NORTH_SOUTH).get()\n.withTrait(LanternBooleanTraits.POWERED, false).get())\n.itemType()\n.selectionBox(BoundingBoxes::rail)\n.properties(builder -> builder\n.add(PASSABLE)\n.add(hardness(0.7))\n\n.itemType(builder -> builder\n.keysProvider(collection -> collection\n.register(Keys.PLANT_TYPE, LanternPlantType.POPPY)))\n.selectionBox(BoundingBoxes.bush())\n.properties(builder -> builder\n.add(INSTANT_BROKEN)\n.add(PASSABLE))\n.translation(TranslationProvider.of(LanternEnumTraits.RED_FLOWER_TYPE))\n.build(\"minecraft\", \"red_flower\"),\nblockState -> (byte) blockState.getTraitValue(LanternEnumTraits.RED_FLOWER_TYPE).get().getInternalId());\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\/\/\/ Brown Mushroom \/\/\/\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\nregister(39, simpleBuilder()\n.selectionBox(BoundingBoxes.bush())\n.properties(builder -> builder\n.add(INSTANT_BROKEN)\n.add(PASSABLE)\n.add(lightEmission(1)))\n.translation(\"tile.mushroom.name\")\n.build(\"minecraft\", \"brown_mushroom\"));\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\/\/\/ Red Mushroom \/\/\/\n\n.add(blastResistance(3.5)))\n.translation(\"tile.goldenRail.name\")\n.build(\"minecraft\", \"golden_rail\"),\nblockState -> {\nint type = blockState.getTraitValue(LanternEnumTraits.STRAIGHT_RAIL_DIRECTION).get().getInternalId();\nif (blockState.getTraitValue(LanternBooleanTraits.POWERED).get()) {\ntype |= 0x8;\n}\nreturn (byte) type;\n});\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\/\/\/ Detector Rail \/\/\/\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\nregister(28, simpleBuilder()\n.traits(LanternEnumTraits.STRAIGHT_RAIL_DIRECTION, LanternBooleanTraits.POWERED)\n.defaultState(state -> state\n.withTrait(LanternEnumTraits.STRAIGHT_RAIL_DIRECTION, LanternRailDirection.NORTH_SOUTH).get()\n.withTrait(LanternBooleanTraits.POWERED, false).get())\n.itemType()\n.selectionBox(BoundingBoxes::rail)\n.properties(builder -> builder\n.add(PASSABLE)\n.add(hardness(0.7))\n\nfacing == Direction.NORTH ? 2 : facing == Direction.EAST ? 3 : -1;\ncheckArgument(type != -1);\nif (blockState.getTraitValue(LanternBooleanTraits.OCCUPIED).get()) {\ntype |= 0x4;\n}\nif (blockState.getTraitValue(LanternEnumTraits.BED_PART).get() == LanternBedPart.HEAD) {\ntype |= 0x8;\n}\nreturn (byte) type;\n});\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\/\/\/ Golden Rail \/\/\/\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\nregister(27, simpleBuilder()\n.traits(LanternEnumTraits.STRAIGHT_RAIL_DIRECTION, LanternBooleanTraits.POWERED)\n.defaultState(state -> state\n.withTrait(LanternEnumTraits.STRAIGHT_RAIL_DIRECTION, LanternRailDirection.NORTH_SOUTH).get()\n.withTrait(LanternBooleanTraits.POWERED, false).get())\n.itemType()\n.selectionBox(BoundingBoxes::rail)\n.properties(builder -> builder\n.add(PASSABLE)\n.add(hardness(0.7))\n\nfacing == Direction.NORTH ? 2 : facing == Direction.EAST ? 3 : -1;\ncheckArgument(type != -1);\nif (blockState.getTraitValue(LanternBooleanTraits.OCCUPIED).get()) {\ntype |= 0x4;\n}\nif (blockState.getTraitValue(LanternEnumTraits.BED_PART).get() == LanternBedPart.HEAD) {\ntype |= 0x8;\n}\nreturn (byte) type;\n});\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\/\/\/ Golden Rail \/\/\/\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\nregister(27, simpleBuilder()\n.traits(LanternEnumTraits.STRAIGHT_RAIL_DIRECTION, LanternBooleanTraits.POWERED)\n.defaultState(state -> state\n.withTrait(LanternEnumTraits.STRAIGHT_RAIL_DIRECTION, LanternRailDirection.NORTH_SOUTH).get()\n.withTrait(LanternBooleanTraits.POWERED, false).get())\n.itemType()\n.selectionBox(BoundingBoxes::rail)\n.properties(builder -> builder\n.add(PASSABLE)\n.add(hardness(0.7))\n\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\/\/\/ Iron Block \/\/\/\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\nregister(42, simpleBuilder()\n.itemType()\n.properties(builder -> builder\n.add(hardness(5.0))\n.add(blastResistance(10.0)))\n.translation(\"tile.blockIron.name\")\n.build(\"minecraft\", \"iron_block\"));\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\/\/\/ Double Stone Slab 1 \/\/\/\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\nregister(43, doubleStoneSlab(LanternEnumTraits.STONE_SLAB1_TYPE, LanternSlabType.STONE)\n.translation(\"tile.stoneSlab.name\")\n.build(\"minecraft\", \"double_stone_slab\"),\nblockState -> doubleStoneSlabData(blockState, blockState.getTraitValue(LanternEnumTraits.STONE_SLAB1_TYPE).get().getInternalId()));\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\/\/\/ Stone Slab 1 \/\/\/\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\nregister(44, stoneSlab(LanternEnumTraits.STONE_SLAB1_TYPE, LanternSlabType.STONE,\n() -> BlockTypes.STONE_SLAB,\n() -> BlockTypes.DOUBLE_STONE_SLAB)\n\n.add(blastResistance(3.5)))\n.translation(\"tile.goldenRail.name\")\n.build(\"minecraft\", \"golden_rail\"),\nblockState -> {\nint type = blockState.getTraitValue(LanternEnumTraits.STRAIGHT_RAIL_DIRECTION).get().getInternalId();\nif (blockState.getTraitValue(LanternBooleanTraits.POWERED).get()) {\ntype |= 0x8;\n}\nreturn (byte) type;\n});\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\/\/\/ Detector Rail \/\/\/\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\nregister(28, simpleBuilder()\n.traits(LanternEnumTraits.STRAIGHT_RAIL_DIRECTION, LanternBooleanTraits.POWERED)\n.defaultState(state -> state\n.withTrait(LanternEnumTraits.STRAIGHT_RAIL_DIRECTION, LanternRailDirection.NORTH_SOUTH).get()\n.withTrait(LanternBooleanTraits.POWERED, false).get())\n.itemType()\n.selectionBox(BoundingBoxes::rail)\n.properties(builder -> builder\n.add(PASSABLE)\n.add(hardness(0.7))\n\n.add(blastResistance(3.5)))\n.translation(\"tile.goldenRail.name\")\n.build(\"minecraft\", \"golden_rail\"),\nblockState -> {\nint type = blockState.getTraitValue(LanternEnumTraits.STRAIGHT_RAIL_DIRECTION).get().getInternalId();\nif (blockState.getTraitValue(LanternBooleanTraits.POWERED).get()) {\ntype |= 0x8;\n}\nreturn (byte) type;\n});\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\/\/\/ Detector Rail \/\/\/\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\nregister(28, simpleBuilder()\n.traits(LanternEnumTraits.STRAIGHT_RAIL_DIRECTION, LanternBooleanTraits.POWERED)\n.defaultState(state -> state\n.withTrait(LanternEnumTraits.STRAIGHT_RAIL_DIRECTION, LanternRailDirection.NORTH_SOUTH).get()\n.withTrait(LanternBooleanTraits.POWERED, false).get())\n.itemType()\n.selectionBox(BoundingBoxes::rail)\n.properties(builder -> builder\n.add(PASSABLE)\n.add(hardness(0.7))\n\n@Override\npublic void registerDefaults() {\n\/\/ @formatter:off\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\/\/\/ Air \/\/\/\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\nregister(0, builder()\n.properties(PropertyProviderCollections.DEFAULT_GAS)\n.translation(\"tile.air.name\")\n.build(\"minecraft\", \"air\"));\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\/\/\/ Stone \/\/\/\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\nregister(1, simpleBuilder()\n.trait(LanternEnumTraits.STONE_TYPE)\n.defaultState(state -> state.withTrait(LanternEnumTraits.STONE_TYPE, LanternStoneType.STONE).get())\n\nfacing == Direction.NORTH ? 2 : facing == Direction.EAST ? 3 : -1;\ncheckArgument(type != -1);\nif (blockState.getTraitValue(LanternBooleanTraits.OCCUPIED).get()) {\ntype |= 0x4;\n}\nif (blockState.getTraitValue(LanternEnumTraits.BED_PART).get() == LanternBedPart.HEAD) {\ntype |= 0x8;\n}\nreturn (byte) type;\n});\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\/\/\/ Golden Rail \/\/\/\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\nregister(27, simpleBuilder()\n.traits(LanternEnumTraits.STRAIGHT_RAIL_DIRECTION, LanternBooleanTraits.POWERED)\n.defaultState(state -> state\n.withTrait(LanternEnumTraits.STRAIGHT_RAIL_DIRECTION, LanternRailDirection.NORTH_SOUTH).get()\n.withTrait(LanternBooleanTraits.POWERED, false).get())\n.itemType()\n.selectionBox(BoundingBoxes::rail)\n.properties(builder -> builder\n.add(PASSABLE)\n.add(hardness(0.7))\n\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\/\/\/ Bookshelf \/\/\/\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\nregister(47, simpleBuilder()\n.itemType()\n.properties(builder -> builder\n.add(hardness(1.5))\n.add(blastResistance(7.5)))\n.translation(\"tile.bookshelf.name\")\n.build(\"minecraft\", \"bookshelf\"));\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\/\/\/ Mossy Cobblestone \/\/\/\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\nregister(48, simpleBuilder()\n.itemType()\n.properties(builder -> builder\n.add(hardness(2.0))\n.add(blastResistance(10.0)))\n.translation(\"tile.stoneMoss.name\")\n.build(\"minecraft\", \"mossy_cobblestone\"));\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\/\/\/ Obsidian \/\/\/\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\n)\n)\n.properties(builder -> builder\n.add(hardness(2.0))\n.add(blastResistance(5.0))\n.add(flammableInfo(5, 20)))\n.translation(TranslationProvider.of(LanternEnumTraits.TREE_TYPE, type ->\ntr(\"tile.planks.\" + type.getTranslationKeyBase() + \".name\")))\n.build(\"minecraft\", \"planks\"),\nblockState -> (byte) blockState.getTraitValue(LanternEnumTraits.TREE_TYPE).get().getInternalId());\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\/\/\/ Sapling \/\/\/\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\nregister(6, simpleBuilder()\n.traits(LanternEnumTraits.TREE_TYPE, LanternIntegerTraits.SAPLING_GROWTH_STAGE)\n.defaultState(state -> state\n.withTrait(LanternEnumTraits.TREE_TYPE, LanternTreeType.OAK).get()\n.withTrait(LanternIntegerTraits.SAPLING_GROWTH_STAGE, 0).get())\n.itemType(builder -> builder\n.keysProvider(collection -> collection\n.register(Keys.TREE_TYPE, LanternTreeType.OAK)\n)\n)\n\n@Override\npublic void registerDefaults() {\n\/\/ @formatter:off\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\/\/\/ Air \/\/\/\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\nregister(0, builder()\n.properties(PropertyProviderCollections.DEFAULT_GAS)\n.translation(\"tile.air.name\")\n.build(\"minecraft\", \"air\"));\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\/\/\/ Stone \/\/\/\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\nregister(1, simpleBuilder()\n.trait(LanternEnumTraits.STONE_TYPE)\n.defaultState(state -> state.withTrait(LanternEnumTraits.STONE_TYPE, LanternStoneType.STONE).get())\n\n@Override\npublic void registerDefaults() {\n\/\/ @formatter:off\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\/\/\/ Air \/\/\/\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\nregister(0, builder()\n.properties(PropertyProviderCollections.DEFAULT_GAS)\n.translation(\"tile.air.name\")\n.build(\"minecraft\", \"air\"));\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\/\/\/ Stone \/\/\/\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\nregister(1, simpleBuilder()\n.trait(LanternEnumTraits.STONE_TYPE)\n.defaultState(state -> state.withTrait(LanternEnumTraits.STONE_TYPE, LanternStoneType.STONE).get())\n\nfacing == Direction.NORTH ? 2 : facing == Direction.EAST ? 3 : -1;\ncheckArgument(type != -1);\nif (blockState.getTraitValue(LanternBooleanTraits.OCCUPIED).get()) {\ntype |= 0x4;\n}\nif (blockState.getTraitValue(LanternEnumTraits.BED_PART).get() == LanternBedPart.HEAD) {\ntype |= 0x8;\n}\nreturn (byte) type;\n});\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\/\/\/ Golden Rail \/\/\/\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\nregister(27, simpleBuilder()\n.traits(LanternEnumTraits.STRAIGHT_RAIL_DIRECTION, LanternBooleanTraits.POWERED)\n.defaultState(state -> state\n.withTrait(LanternEnumTraits.STRAIGHT_RAIL_DIRECTION, LanternRailDirection.NORTH_SOUTH).get()\n.withTrait(LanternBooleanTraits.POWERED, false).get())\n.itemType()\n.selectionBox(BoundingBoxes::rail)\n.properties(builder -> builder\n.add(PASSABLE)\n.add(hardness(0.7))\n\n.build(\"minecraft\", \"fire\"));\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\/\/\/ Mob Spawner \/\/\/\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\nregister(52, simpleBuilder()\n.properties(builder -> builder\n.add(hardness(5.0))\n.add(blastResistance(25.0)))\n.translation(\"tile.mobSpawner.name\")\n.build(\"minecraft\", \"mob_spawner\"));\n\/\/ TODO: Oak Stairs\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\/\/\/ Chest \/\/\/\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\nregister(54, chestBuilder()\n.translation(\"tile.chest.name\")\n.build(\"minecraft\", \"chest\"),\nthis::horizontalFacingData);\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\/\/\/ Redstone Wire \/\/\/\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\nregister(55, simpleBuilder()\n.traits(LanternIntegerTraits.POWER)\n.selectionBox(new AABB(0, 0, 0, 1.0, 0.0625, 1.0)) \/\/ TODO: Based on connections\n\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\/\/\/ Iron Block \/\/\/\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\nregister(42, simpleBuilder()\n.itemType()\n.properties(builder -> builder\n.add(hardness(5.0))\n.add(blastResistance(10.0)))\n.translation(\"tile.blockIron.name\")\n.build(\"minecraft\", \"iron_block\"));\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\/\/\/ Double Stone Slab 1 \/\/\/\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\nregister(43, doubleStoneSlab(LanternEnumTraits.STONE_SLAB1_TYPE, LanternSlabType.STONE)\n.translation(\"tile.stoneSlab.name\")\n.build(\"minecraft\", \"double_stone_slab\"),\nblockState -> doubleStoneSlabData(blockState, blockState.getTraitValue(LanternEnumTraits.STONE_SLAB1_TYPE).get().getInternalId()));\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\/\/\/ Stone Slab 1 \/\/\/\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\nregister(44, stoneSlab(LanternEnumTraits.STONE_SLAB1_TYPE, LanternSlabType.STONE,\n() -> BlockTypes.STONE_SLAB,\n() -> BlockTypes.DOUBLE_STONE_SLAB)\n\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\nregister(54, chestBuilder()\n.translation(\"tile.chest.name\")\n.build(\"minecraft\", \"chest\"),\nthis::horizontalFacingData);\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\/\/\/ Redstone Wire \/\/\/\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\nregister(55, simpleBuilder()\n.traits(LanternIntegerTraits.POWER)\n.selectionBox(new AABB(0, 0, 0, 1.0, 0.0625, 1.0)) \/\/ TODO: Based on connections\n.properties(builder -> builder\n.add(PASSABLE)\n.add(INSTANT_BROKEN))\n.defaultState(state -> state\n.withTrait(LanternIntegerTraits.POWER, 0).get())\n.translation(\"tile.redstoneDust.name\")\n.build(\"minecraft\", \"redstone_wire\"),\nstate -> state.get(Keys.POWER).get().byteValue());\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\/\/\/ Diamond Ore \/\/\/\n\n.add(blastResistance(3.5)))\n.translation(\"tile.goldenRail.name\")\n.build(\"minecraft\", \"golden_rail\"),\nblockState -> {\nint type = blockState.getTraitValue(LanternEnumTraits.STRAIGHT_RAIL_DIRECTION).get().getInternalId();\nif (blockState.getTraitValue(LanternBooleanTraits.POWERED).get()) {\ntype |= 0x8;\n}\nreturn (byte) type;\n});\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\/\/\/ Detector Rail \/\/\/\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\nregister(28, simpleBuilder()\n.traits(LanternEnumTraits.STRAIGHT_RAIL_DIRECTION, LanternBooleanTraits.POWERED)\n.defaultState(state -> state\n.withTrait(LanternEnumTraits.STRAIGHT_RAIL_DIRECTION, LanternRailDirection.NORTH_SOUTH).get()\n.withTrait(LanternBooleanTraits.POWERED, false).get())\n.itemType()\n.selectionBox(BoundingBoxes::rail)\n.properties(builder -> builder\n.add(PASSABLE)\n.add(hardness(0.7))\n\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\/\/\/ Wool \/\/\/\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\nregister(35, dyedBuilder(\"tile.wool.%s.name\")\n.properties(builder -> builder\n.add(hardness(0.8))\n.add(blastResistance(4.0)))\n.build(\"minecraft\", \"wool\"),\nthis::dyedData);\n\/\/ TODO: 36\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\/\/\/ Yellow Flower \/\/\/\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\nregister(37, simpleBuilder()\n.traits(LanternEnumTraits.YELLOW_FLOWER_TYPE)\n.defaultState(state -> state\n.withTrait(LanternEnumTraits.YELLOW_FLOWER_TYPE, LanternPlantType.DANDELION).get())\n.itemType(builder -> builder\n.keysProvider(collection -> collection\n.register(Keys.PLANT_TYPE, LanternPlantType.DANDELION)))\n.selectionBox(BoundingBoxes.bush())\n.properties(builder -> builder\n.add(INSTANT_BROKEN)\n\n.itemType(builder -> builder\n.keysProvider(collection -> collection\n.register(Keys.PLANT_TYPE, LanternPlantType.POPPY)))\n.selectionBox(BoundingBoxes.bush())\n.properties(builder -> builder\n.add(INSTANT_BROKEN)\n.add(PASSABLE))\n.translation(TranslationProvider.of(LanternEnumTraits.RED_FLOWER_TYPE))\n.build(\"minecraft\", \"red_flower\"),\nblockState -> (byte) blockState.getTraitValue(LanternEnumTraits.RED_FLOWER_TYPE).get().getInternalId());\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\/\/\/ Brown Mushroom \/\/\/\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\nregister(39, simpleBuilder()\n.selectionBox(BoundingBoxes.bush())\n.properties(builder -> builder\n.add(INSTANT_BROKEN)\n.add(PASSABLE)\n.add(lightEmission(1)))\n.translation(\"tile.mushroom.name\")\n.build(\"minecraft\", \"brown_mushroom\"));\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\/\/\/ Red Mushroom \/\/\/\n\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\nregister(58, simpleBuilder()\n.itemType()\n.properties(builder -> builder\n.add(hardness(2.5))\n.add(blastResistance(12.5)))\n.translation(\"tile.workbench.name\")\n.behaviors(pipeline -> pipeline\n.add(new CraftingTableInteractionBehavior()))\n.build(\"minecraft\", \"crafting_table\"));\n\/\/ TODO: Wheat\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\/\/\/ Farmland \/\/\/\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\nregister(60, simpleBuilder()\n.collisionBox(BoundingBoxes.farmland())\n.trait(LanternIntegerTraits.MOISTURE)\n.properties(builder -> builder\n.add(hardness(0.6))\n.add(blastResistance(3.0)))\n.defaultState(state ->\nstate.withTrait(LanternIntegerTraits.MOISTURE, 0).get())\n.translation(\"tile.farmland.name\")\n.build(\"minecraft\", \"farmland\"),\n\n)\n)\n.properties(builder -> builder\n.add(hardness(2.0))\n.add(blastResistance(5.0))\n.add(flammableInfo(5, 20)))\n.translation(TranslationProvider.of(LanternEnumTraits.TREE_TYPE, type ->\ntr(\"tile.planks.\" + type.getTranslationKeyBase() + \".name\")))\n.build(\"minecraft\", \"planks\"),\nblockState -> (byte) blockState.getTraitValue(LanternEnumTraits.TREE_TYPE).get().getInternalId());\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\/\/\/ Sapling \/\/\/\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\nregister(6, simpleBuilder()\n.traits(LanternEnumTraits.TREE_TYPE, LanternIntegerTraits.SAPLING_GROWTH_STAGE)\n.defaultState(state -> state\n.withTrait(LanternEnumTraits.TREE_TYPE, LanternTreeType.OAK).get()\n.withTrait(LanternIntegerTraits.SAPLING_GROWTH_STAGE, 0).get())\n.itemType(builder -> builder\n.keysProvider(collection -> collection\n.register(Keys.TREE_TYPE, LanternTreeType.OAK)\n)\n)\n\n)\n)\n.properties(builder -> builder\n.add(hardness(2.0))\n.add(blastResistance(5.0))\n.add(flammableInfo(5, 20)))\n.translation(TranslationProvider.of(LanternEnumTraits.TREE_TYPE, type ->\ntr(\"tile.planks.\" + type.getTranslationKeyBase() + \".name\")))\n.build(\"minecraft\", \"planks\"),\nblockState -> (byte) blockState.getTraitValue(LanternEnumTraits.TREE_TYPE).get().getInternalId());\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\/\/\/ Sapling \/\/\/\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\nregister(6, simpleBuilder()\n.traits(LanternEnumTraits.TREE_TYPE, LanternIntegerTraits.SAPLING_GROWTH_STAGE)\n.defaultState(state -> state\n.withTrait(LanternEnumTraits.TREE_TYPE, LanternTreeType.OAK).get()\n.withTrait(LanternIntegerTraits.SAPLING_GROWTH_STAGE, 0).get())\n.itemType(builder -> builder\n.keysProvider(collection -> collection\n.register(Keys.TREE_TYPE, LanternTreeType.OAK)\n)\n)\n\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\/\/\/ Bookshelf \/\/\/\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\nregister(47, simpleBuilder()\n.itemType()\n.properties(builder -> builder\n.add(hardness(1.5))\n.add(blastResistance(7.5)))\n.translation(\"tile.bookshelf.name\")\n.build(\"minecraft\", \"bookshelf\"));\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\/\/\/ Mossy Cobblestone \/\/\/\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\nregister(48, simpleBuilder()\n.itemType()\n.properties(builder -> builder\n.add(hardness(2.0))\n.add(blastResistance(10.0)))\n.translation(\"tile.stoneMoss.name\")\n.build(\"minecraft\", \"mossy_cobblestone\"));\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\/\/\/ Obsidian \/\/\/\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\/\/\/ Bookshelf \/\/\/\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\nregister(47, simpleBuilder()\n.itemType()\n.properties(builder -> builder\n.add(hardness(1.5))\n.add(blastResistance(7.5)))\n.translation(\"tile.bookshelf.name\")\n.build(\"minecraft\", \"bookshelf\"));\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\/\/\/ Mossy Cobblestone \/\/\/\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\nregister(48, simpleBuilder()\n.itemType()\n.properties(builder -> builder\n.add(hardness(2.0))\n.add(blastResistance(10.0)))\n.translation(\"tile.stoneMoss.name\")\n.build(\"minecraft\", \"mossy_cobblestone\"));\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\/\/\/ Obsidian \/\/\/\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\n)\n)\n.properties(builder -> builder\n.add(hardness(2.0))\n.add(blastResistance(5.0))\n.add(flammableInfo(5, 20)))\n.translation(TranslationProvider.of(LanternEnumTraits.TREE_TYPE, type ->\ntr(\"tile.planks.\" + type.getTranslationKeyBase() + \".name\")))\n.build(\"minecraft\", \"planks\"),\nblockState -> (byte) blockState.getTraitValue(LanternEnumTraits.TREE_TYPE).get().getInternalId());\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\/\/\/ Sapling \/\/\/\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\nregister(6, simpleBuilder()\n.traits(LanternEnumTraits.TREE_TYPE, LanternIntegerTraits.SAPLING_GROWTH_STAGE)\n.defaultState(state -> state\n.withTrait(LanternEnumTraits.TREE_TYPE, LanternTreeType.OAK).get()\n.withTrait(LanternIntegerTraits.SAPLING_GROWTH_STAGE, 0).get())\n.itemType(builder -> builder\n.keysProvider(collection -> collection\n.register(Keys.TREE_TYPE, LanternTreeType.OAK)\n)\n)\n\n)\n)\n.properties(builder -> builder\n.add(hardness(2.0))\n.add(blastResistance(5.0))\n.add(flammableInfo(5, 20)))\n.translation(TranslationProvider.of(LanternEnumTraits.TREE_TYPE, type ->\ntr(\"tile.planks.\" + type.getTranslationKeyBase() + \".name\")))\n.build(\"minecraft\", \"planks\"),\nblockState -> (byte) blockState.getTraitValue(LanternEnumTraits.TREE_TYPE).get().getInternalId());\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\/\/\/ Sapling \/\/\/\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\nregister(6, simpleBuilder()\n.traits(LanternEnumTraits.TREE_TYPE, LanternIntegerTraits.SAPLING_GROWTH_STAGE)\n.defaultState(state -> state\n.withTrait(LanternEnumTraits.TREE_TYPE, LanternTreeType.OAK).get()\n.withTrait(LanternIntegerTraits.SAPLING_GROWTH_STAGE, 0).get())\n.itemType(builder -> builder\n.keysProvider(collection -> collection\n.register(Keys.TREE_TYPE, LanternTreeType.OAK)\n)\n)\n\nfacing == Direction.NORTH ? 2 : facing == Direction.EAST ? 3 : -1;\ncheckArgument(type != -1);\nif (blockState.getTraitValue(LanternBooleanTraits.OCCUPIED).get()) {\ntype |= 0x4;\n}\nif (blockState.getTraitValue(LanternEnumTraits.BED_PART).get() == LanternBedPart.HEAD) {\ntype |= 0x8;\n}\nreturn (byte) type;\n});\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\/\/\/ Golden Rail \/\/\/\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\nregister(27, simpleBuilder()\n.traits(LanternEnumTraits.STRAIGHT_RAIL_DIRECTION, LanternBooleanTraits.POWERED)\n.defaultState(state -> state\n.withTrait(LanternEnumTraits.STRAIGHT_RAIL_DIRECTION, LanternRailDirection.NORTH_SOUTH).get()\n.withTrait(LanternBooleanTraits.POWERED, false).get())\n.itemType()\n.selectionBox(BoundingBoxes::rail)\n.properties(builder -> builder\n.add(PASSABLE)\n.add(hardness(0.7))\n\n)\n)\n.properties(builder -> builder\n.add(hardness(2.0))\n.add(blastResistance(5.0))\n.add(flammableInfo(5, 20)))\n.translation(TranslationProvider.of(LanternEnumTraits.TREE_TYPE, type ->\ntr(\"tile.planks.\" + type.getTranslationKeyBase() + \".name\")))\n.build(\"minecraft\", \"planks\"),\nblockState -> (byte) blockState.getTraitValue(LanternEnumTraits.TREE_TYPE).get().getInternalId());\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\/\/\/ Sapling \/\/\/\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\nregister(6, simpleBuilder()\n.traits(LanternEnumTraits.TREE_TYPE, LanternIntegerTraits.SAPLING_GROWTH_STAGE)\n.defaultState(state -> state\n.withTrait(LanternEnumTraits.TREE_TYPE, LanternTreeType.OAK).get()\n.withTrait(LanternIntegerTraits.SAPLING_GROWTH_STAGE, 0).get())\n.itemType(builder -> builder\n.keysProvider(collection -> collection\n.register(Keys.TREE_TYPE, LanternTreeType.OAK)\n)\n)\n\nfacing == Direction.NORTH ? 2 : facing == Direction.EAST ? 3 : -1;\ncheckArgument(type != -1);\nif (blockState.getTraitValue(LanternBooleanTraits.OCCUPIED).get()) {\ntype |= 0x4;\n}\nif (blockState.getTraitValue(LanternEnumTraits.BED_PART).get() == LanternBedPart.HEAD) {\ntype |= 0x8;\n}\nreturn (byte) type;\n});\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\/\/\/ Golden Rail \/\/\/\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\nregister(27, simpleBuilder()\n.traits(LanternEnumTraits.STRAIGHT_RAIL_DIRECTION, LanternBooleanTraits.POWERED)\n.defaultState(state -> state\n.withTrait(LanternEnumTraits.STRAIGHT_RAIL_DIRECTION, LanternRailDirection.NORTH_SOUTH).get()\n.withTrait(LanternBooleanTraits.POWERED, false).get())\n.itemType()\n.selectionBox(BoundingBoxes::rail)\n.properties(builder -> builder\n.add(PASSABLE)\n.add(hardness(0.7))\n\n@Override\npublic void registerDefaults() {\n\/\/ @formatter:off\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\/\/\/ Air \/\/\/\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\nregister(0, builder()\n.properties(PropertyProviderCollections.DEFAULT_GAS)\n.translation(\"tile.air.name\")\n.build(\"minecraft\", \"air\"));\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\/\/\/ Stone \/\/\/\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\nregister(1, simpleBuilder()\n.trait(LanternEnumTraits.STONE_TYPE)\n.defaultState(state -> state.withTrait(LanternEnumTraits.STONE_TYPE, LanternStoneType.STONE).get())\n\n.keysProvider(collection -> collection\n.register(Keys.SAND_TYPE, LanternSandType.NORMAL)\n)\n)\n.properties(builder -> builder\n.add(hardness(0.5))\n.add(blastResistance(2.5)))\n.translation(TranslationProvider.of(LanternEnumTraits.SAND_TYPE))\n.build(\"minecraft\", \"sand\"),\nblockState -> (byte) blockState.getTraitValue(LanternEnumTraits.SAND_TYPE).get().getInternalId());\n\/\/ TODO: Sand physics behavior\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\/\/\/ Gravel \/\/\/\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\nregister(13, simpleBuilder()\n.itemType()\n.properties(builder -> builder\n.add(hardness(0.6))\n.add(blastResistance(3.0)))\n.translation(\"tile.gravel.name\")\n.build(\"minecraft\", \"gravel\"));\n\nfacing == Direction.NORTH ? 2 : facing == Direction.EAST ? 3 : -1;\ncheckArgument(type != -1);\nif (blockState.getTraitValue(LanternBooleanTraits.OCCUPIED).get()) {\ntype |= 0x4;\n}\nif (blockState.getTraitValue(LanternEnumTraits.BED_PART).get() == LanternBedPart.HEAD) {\ntype |= 0x8;\n}\nreturn (byte) type;\n});\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\/\/\/ Golden Rail \/\/\/\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\nregister(27, simpleBuilder()\n.traits(LanternEnumTraits.STRAIGHT_RAIL_DIRECTION, LanternBooleanTraits.POWERED)\n.defaultState(state -> state\n.withTrait(LanternEnumTraits.STRAIGHT_RAIL_DIRECTION, LanternRailDirection.NORTH_SOUTH).get()\n.withTrait(LanternBooleanTraits.POWERED, false).get())\n.itemType()\n.selectionBox(BoundingBoxes::rail)\n.properties(builder -> builder\n.add(PASSABLE)\n.add(hardness(0.7))\n\n.itemType(builder -> builder\n.keysProvider(collection -> collection\n.register(Keys.PLANT_TYPE, LanternPlantType.POPPY)))\n.selectionBox(BoundingBoxes.bush())\n.properties(builder -> builder\n.add(INSTANT_BROKEN)\n.add(PASSABLE))\n.translation(TranslationProvider.of(LanternEnumTraits.RED_FLOWER_TYPE))\n.build(\"minecraft\", \"red_flower\"),\nblockState -> (byte) blockState.getTraitValue(LanternEnumTraits.RED_FLOWER_TYPE).get().getInternalId());\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\/\/\/ Brown Mushroom \/\/\/\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\nregister(39, simpleBuilder()\n.selectionBox(BoundingBoxes.bush())\n.properties(builder -> builder\n.add(INSTANT_BROKEN)\n.add(PASSABLE)\n.add(lightEmission(1)))\n.translation(\"tile.mushroom.name\")\n.build(\"minecraft\", \"brown_mushroom\"));\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\/\/\/ Red Mushroom \/\/\/\n\n.itemType(builder -> builder\n.keysProvider(collection -> collection\n.register(Keys.PLANT_TYPE, LanternPlantType.POPPY)))\n.selectionBox(BoundingBoxes.bush())\n.properties(builder -> builder\n.add(INSTANT_BROKEN)\n.add(PASSABLE))\n.translation(TranslationProvider.of(LanternEnumTraits.RED_FLOWER_TYPE))\n.build(\"minecraft\", \"red_flower\"),\nblockState -> (byte) blockState.getTraitValue(LanternEnumTraits.RED_FLOWER_TYPE).get().getInternalId());\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\/\/\/ Brown Mushroom \/\/\/\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\nregister(39, simpleBuilder()\n.selectionBox(BoundingBoxes.bush())\n.properties(builder -> builder\n.add(INSTANT_BROKEN)\n.add(PASSABLE)\n.add(lightEmission(1)))\n.translation(\"tile.mushroom.name\")\n.build(\"minecraft\", \"brown_mushroom\"));\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\/\/\/ Red Mushroom \/\/\/\n\nfacing == Direction.NORTH ? 2 : facing == Direction.EAST ? 3 : -1;\ncheckArgument(type != -1);\nif (blockState.getTraitValue(LanternBooleanTraits.OCCUPIED).get()) {\ntype |= 0x4;\n}\nif (blockState.getTraitValue(LanternEnumTraits.BED_PART).get() == LanternBedPart.HEAD) {\ntype |= 0x8;\n}\nreturn (byte) type;\n});\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\/\/\/ Golden Rail \/\/\/\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\nregister(27, simpleBuilder()\n.traits(LanternEnumTraits.STRAIGHT_RAIL_DIRECTION, LanternBooleanTraits.POWERED)\n.defaultState(state -> state\n.withTrait(LanternEnumTraits.STRAIGHT_RAIL_DIRECTION, LanternRailDirection.NORTH_SOUTH).get()\n.withTrait(LanternBooleanTraits.POWERED, false).get())\n.itemType()\n.selectionBox(BoundingBoxes::rail)\n.properties(builder -> builder\n.add(PASSABLE)\n.add(hardness(0.7))\n\nfacing == Direction.NORTH ? 2 : facing == Direction.EAST ? 3 : -1;\ncheckArgument(type != -1);\nif (blockState.getTraitValue(LanternBooleanTraits.OCCUPIED).get()) {\ntype |= 0x4;\n}\nif (blockState.getTraitValue(LanternEnumTraits.BED_PART).get() == LanternBedPart.HEAD) {\ntype |= 0x8;\n}\nreturn (byte) type;\n});\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\/\/\/ Golden Rail \/\/\/\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\nregister(27, simpleBuilder()\n.traits(LanternEnumTraits.STRAIGHT_RAIL_DIRECTION, LanternBooleanTraits.POWERED)\n.defaultState(state -> state\n.withTrait(LanternEnumTraits.STRAIGHT_RAIL_DIRECTION, LanternRailDirection.NORTH_SOUTH).get()\n.withTrait(LanternBooleanTraits.POWERED, false).get())\n.itemType()\n.selectionBox(BoundingBoxes::rail)\n.properties(builder -> builder\n.add(PASSABLE)\n.add(hardness(0.7))\n\n.add(new EnderChestInteractionBehavior()))\n.build(\"minecraft\", \"ender_chest\"),\nthis::horizontalFacingData);\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\/\/\/ Trapped Chest \/\/\/\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\nregister(146, chestBuilder()\n.translation(\"tile.chestTrap.name\")\n.build(\"minecraft\", \"trapped_chest\"),\nthis::horizontalFacingData);\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\/\/\/ Weighted Pressure Plate (Light) \/\/\/\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\nregister(147, weightedPressurePlateBuilder()\n.translation(\"tile.weightedPlate_light.name\")\n.build(\"minecraft\", \"light_weighted_pressure_plate\"),\nthis::weightedPressurePlateData);\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\/\/\/ Weighted Pressure Plate (Heavy) \/\/\/\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\nregister(148, weightedPressurePlateBuilder()\n.translation(\"tile.weightedPlate_heavy.name\")\n.build(\"minecraft\", \"heavy_weighted_pressure_plate\"),\n\n.add(new EnderChestInteractionBehavior()))\n.build(\"minecraft\", \"ender_chest\"),\nthis::horizontalFacingData);\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\/\/\/ Trapped Chest \/\/\/\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\nregister(146, chestBuilder()\n.translation(\"tile.chestTrap.name\")\n.build(\"minecraft\", \"trapped_chest\"),\nthis::horizontalFacingData);\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\/\/\/ Weighted Pressure Plate (Light) \/\/\/\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\nregister(147, weightedPressurePlateBuilder()\n.translation(\"tile.weightedPlate_light.name\")\n.build(\"minecraft\", \"light_weighted_pressure_plate\"),\nthis::weightedPressurePlateData);\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\/\/\/ Weighted Pressure Plate (Heavy) \/\/\/\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\nregister(148, weightedPressurePlateBuilder()\n.translation(\"tile.weightedPlate_heavy.name\")\n.build(\"minecraft\", \"heavy_weighted_pressure_plate\"),\n\n.add(blastResistance(3.5)))\n.translation(\"tile.goldenRail.name\")\n.build(\"minecraft\", \"golden_rail\"),\nblockState -> {\nint type = blockState.getTraitValue(LanternEnumTraits.STRAIGHT_RAIL_DIRECTION).get().getInternalId();\nif (blockState.getTraitValue(LanternBooleanTraits.POWERED).get()) {\ntype |= 0x8;\n}\nreturn (byte) type;\n});\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\/\/\/ Detector Rail \/\/\/\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\nregister(28, simpleBuilder()\n.traits(LanternEnumTraits.STRAIGHT_RAIL_DIRECTION, LanternBooleanTraits.POWERED)\n.defaultState(state -> state\n.withTrait(LanternEnumTraits.STRAIGHT_RAIL_DIRECTION, LanternRailDirection.NORTH_SOUTH).get()\n.withTrait(LanternBooleanTraits.POWERED, false).get())\n.itemType()\n.selectionBox(BoundingBoxes::rail)\n.properties(builder -> builder\n.add(PASSABLE)\n.add(hardness(0.7))\n\n)\n)\n.properties(builder -> builder\n.add(hardness(2.0))\n.add(blastResistance(5.0))\n.add(flammableInfo(5, 20)))\n.translation(TranslationProvider.of(LanternEnumTraits.TREE_TYPE, type ->\ntr(\"tile.planks.\" + type.getTranslationKeyBase() + \".name\")))\n.build(\"minecraft\", \"planks\"),\nblockState -> (byte) blockState.getTraitValue(LanternEnumTraits.TREE_TYPE).get().getInternalId());\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\/\/\/ Sapling \/\/\/\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\nregister(6, simpleBuilder()\n.traits(LanternEnumTraits.TREE_TYPE, LanternIntegerTraits.SAPLING_GROWTH_STAGE)\n.defaultState(state -> state\n.withTrait(LanternEnumTraits.TREE_TYPE, LanternTreeType.OAK).get()\n.withTrait(LanternIntegerTraits.SAPLING_GROWTH_STAGE, 0).get())\n.itemType(builder -> builder\n.keysProvider(collection -> collection\n.register(Keys.TREE_TYPE, LanternTreeType.OAK)\n)\n)\n\n)\n)\n.properties(builder -> builder\n.add(hardness(2.0))\n.add(blastResistance(5.0))\n.add(flammableInfo(5, 20)))\n.translation(TranslationProvider.of(LanternEnumTraits.TREE_TYPE, type ->\ntr(\"tile.planks.\" + type.getTranslationKeyBase() + \".name\")))\n.build(\"minecraft\", \"planks\"),\nblockState -> (byte) blockState.getTraitValue(LanternEnumTraits.TREE_TYPE).get().getInternalId());\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\/\/\/ Sapling \/\/\/\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\nregister(6, simpleBuilder()\n.traits(LanternEnumTraits.TREE_TYPE, LanternIntegerTraits.SAPLING_GROWTH_STAGE)\n.defaultState(state -> state\n.withTrait(LanternEnumTraits.TREE_TYPE, LanternTreeType.OAK).get()\n.withTrait(LanternIntegerTraits.SAPLING_GROWTH_STAGE, 0).get())\n.itemType(builder -> builder\n.keysProvider(collection -> collection\n.register(Keys.TREE_TYPE, LanternTreeType.OAK)\n)\n)\n\nfacing == Direction.NORTH ? 2 : facing == Direction.EAST ? 3 : -1;\ncheckArgument(type != -1);\nif (blockState.getTraitValue(LanternBooleanTraits.OCCUPIED).get()) {\ntype |= 0x4;\n}\nif (blockState.getTraitValue(LanternEnumTraits.BED_PART).get() == LanternBedPart.HEAD) {\ntype |= 0x8;\n}\nreturn (byte) type;\n});\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\/\/\/ Golden Rail \/\/\/\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\nregister(27, simpleBuilder()\n.traits(LanternEnumTraits.STRAIGHT_RAIL_DIRECTION, LanternBooleanTraits.POWERED)\n.defaultState(state -> state\n.withTrait(LanternEnumTraits.STRAIGHT_RAIL_DIRECTION, LanternRailDirection.NORTH_SOUTH).get()\n.withTrait(LanternBooleanTraits.POWERED, false).get())\n.itemType()\n.selectionBox(BoundingBoxes::rail)\n.properties(builder -> builder\n.add(PASSABLE)\n.add(hardness(0.7))\n\n)\n)\n.properties(builder -> builder\n.add(hardness(2.0))\n.add(blastResistance(5.0))\n.add(flammableInfo(5, 20)))\n.translation(TranslationProvider.of(LanternEnumTraits.TREE_TYPE, type ->\ntr(\"tile.planks.\" + type.getTranslationKeyBase() + \".name\")))\n.build(\"minecraft\", \"planks\"),\nblockState -> (byte) blockState.getTraitValue(LanternEnumTraits.TREE_TYPE).get().getInternalId());\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\/\/\/ Sapling \/\/\/\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\nregister(6, simpleBuilder()\n.traits(LanternEnumTraits.TREE_TYPE, LanternIntegerTraits.SAPLING_GROWTH_STAGE)\n.defaultState(state -> state\n.withTrait(LanternEnumTraits.TREE_TYPE, LanternTreeType.OAK).get()\n.withTrait(LanternIntegerTraits.SAPLING_GROWTH_STAGE, 0).get())\n.itemType(builder -> builder\n.keysProvider(collection -> collection\n.register(Keys.TREE_TYPE, LanternTreeType.OAK)\n)\n)\n\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\nregister(158, simpleBuilder()\n.traits(LanternEnumTraits.FACING, LanternBooleanTraits.TRIGGERED)\n.defaultState(state -> state\n.withTrait(LanternEnumTraits.FACING, Direction.NORTH).get()\n.withTrait(LanternBooleanTraits.TRIGGERED, false).get())\n.itemType()\n.properties(builder -> builder\n.add(hardness(3.5))\n.add(blastResistance(17.5)))\n\/\/ .tileEntityType(() -> TileEntityTypes.DROPPER)\n.translation(\"tile.dropper.name\")\n.behaviors(pipeline -> pipeline\n.add(new RotationPlacementBehavior()))\n.build(\"minecraft\", \"dropper\"),\nblockState -> {\nint data = directionData(blockState.getTraitValue(LanternEnumTraits.FACING).get());\nif (blockState.getTraitValue(LanternBooleanTraits.TRIGGERED).get()) {\ndata |= 0x8;\n}\nreturn (byte) data;\n\n.add(new EnderChestInteractionBehavior()))\n.build(\"minecraft\", \"ender_chest\"),\nthis::horizontalFacingData);\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\/\/\/ Trapped Chest \/\/\/\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\nregister(146, chestBuilder()\n.translation(\"tile.chestTrap.name\")\n.build(\"minecraft\", \"trapped_chest\"),\nthis::horizontalFacingData);\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\/\/\/ Weighted Pressure Plate (Light) \/\/\/\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\nregister(147, weightedPressurePlateBuilder()\n.translation(\"tile.weightedPlate_light.name\")\n.build(\"minecraft\", \"light_weighted_pressure_plate\"),\nthis::weightedPressurePlateData);\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\/\/\/ Weighted Pressure Plate (Heavy) \/\/\/\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\nregister(148, weightedPressurePlateBuilder()\n.translation(\"tile.weightedPlate_heavy.name\")\n.build(\"minecraft\", \"heavy_weighted_pressure_plate\"),\n\n.itemType(builder -> builder\n.keysProvider(collection -> collection\n.register(Keys.PLANT_TYPE, LanternPlantType.POPPY)))\n.selectionBox(BoundingBoxes.bush())\n.properties(builder -> builder\n.add(INSTANT_BROKEN)\n.add(PASSABLE))\n.translation(TranslationProvider.of(LanternEnumTraits.RED_FLOWER_TYPE))\n.build(\"minecraft\", \"red_flower\"),\nblockState -> (byte) blockState.getTraitValue(LanternEnumTraits.RED_FLOWER_TYPE).get().getInternalId());\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\/\/\/ Brown Mushroom \/\/\/\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\nregister(39, simpleBuilder()\n.selectionBox(BoundingBoxes.bush())\n.properties(builder -> builder\n.add(INSTANT_BROKEN)\n.add(PASSABLE)\n.add(lightEmission(1)))\n.translation(\"tile.mushroom.name\")\n.build(\"minecraft\", \"brown_mushroom\"));\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\/\/\/ Red Mushroom \/\/\/\n\n)\n)\n.properties(builder -> builder\n.add(hardness(2.0))\n.add(blastResistance(5.0))\n.add(flammableInfo(5, 20)))\n.translation(TranslationProvider.of(LanternEnumTraits.TREE_TYPE, type ->\ntr(\"tile.planks.\" + type.getTranslationKeyBase() + \".name\")))\n.build(\"minecraft\", \"planks\"),\nblockState -> (byte) blockState.getTraitValue(LanternEnumTraits.TREE_TYPE).get().getInternalId());\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\/\/\/ Sapling \/\/\/\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\nregister(6, simpleBuilder()\n.traits(LanternEnumTraits.TREE_TYPE, LanternIntegerTraits.SAPLING_GROWTH_STAGE)\n.defaultState(state -> state\n.withTrait(LanternEnumTraits.TREE_TYPE, LanternTreeType.OAK).get()\n.withTrait(LanternIntegerTraits.SAPLING_GROWTH_STAGE, 0).get())\n.itemType(builder -> builder\n.keysProvider(collection -> collection\n.register(Keys.TREE_TYPE, LanternTreeType.OAK)\n)\n)\n\n)\n)\n.properties(builder -> builder\n.add(hardness(2.0))\n.add(blastResistance(5.0))\n.add(flammableInfo(5, 20)))\n.translation(TranslationProvider.of(LanternEnumTraits.TREE_TYPE, type ->\ntr(\"tile.planks.\" + type.getTranslationKeyBase() + \".name\")))\n.build(\"minecraft\", \"planks\"),\nblockState -> (byte) blockState.getTraitValue(LanternEnumTraits.TREE_TYPE).get().getInternalId());\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\/\/\/ Sapling \/\/\/\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\nregister(6, simpleBuilder()\n.traits(LanternEnumTraits.TREE_TYPE, LanternIntegerTraits.SAPLING_GROWTH_STAGE)\n.defaultState(state -> state\n.withTrait(LanternEnumTraits.TREE_TYPE, LanternTreeType.OAK).get()\n.withTrait(LanternIntegerTraits.SAPLING_GROWTH_STAGE, 0).get())\n.itemType(builder -> builder\n.keysProvider(collection -> collection\n.register(Keys.TREE_TYPE, LanternTreeType.OAK)\n)\n)\n\n)\n)\n.properties(builder -> builder\n.add(hardness(2.0))\n.add(blastResistance(5.0))\n.add(flammableInfo(5, 20)))\n.translation(TranslationProvider.of(LanternEnumTraits.TREE_TYPE, type ->\ntr(\"tile.planks.\" + type.getTranslationKeyBase() + \".name\")))\n.build(\"minecraft\", \"planks\"),\nblockState -> (byte) blockState.getTraitValue(LanternEnumTraits.TREE_TYPE).get().getInternalId());\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\/\/\/ Sapling \/\/\/\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\nregister(6, simpleBuilder()\n.traits(LanternEnumTraits.TREE_TYPE, LanternIntegerTraits.SAPLING_GROWTH_STAGE)\n.defaultState(state -> state\n.withTrait(LanternEnumTraits.TREE_TYPE, LanternTreeType.OAK).get()\n.withTrait(LanternIntegerTraits.SAPLING_GROWTH_STAGE, 0).get())\n.itemType(builder -> builder\n.keysProvider(collection -> collection\n.register(Keys.TREE_TYPE, LanternTreeType.OAK)\n)\n)\n\nfacing == Direction.NORTH ? 2 : facing == Direction.EAST ? 3 : -1;\ncheckArgument(type != -1);\nif (blockState.getTraitValue(LanternBooleanTraits.OCCUPIED).get()) {\ntype |= 0x4;\n}\nif (blockState.getTraitValue(LanternEnumTraits.BED_PART).get() == LanternBedPart.HEAD) {\ntype |= 0x8;\n}\nreturn (byte) type;\n});\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\/\/\/ Golden Rail \/\/\/\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\nregister(27, simpleBuilder()\n.traits(LanternEnumTraits.STRAIGHT_RAIL_DIRECTION, LanternBooleanTraits.POWERED)\n.defaultState(state -> state\n.withTrait(LanternEnumTraits.STRAIGHT_RAIL_DIRECTION, LanternRailDirection.NORTH_SOUTH).get()\n.withTrait(LanternBooleanTraits.POWERED, false).get())\n.itemType()\n.selectionBox(BoundingBoxes::rail)\n.properties(builder -> builder\n.add(PASSABLE)\n.add(hardness(0.7))\n\nfacing == Direction.NORTH ? 2 : facing == Direction.EAST ? 3 : -1;\ncheckArgument(type != -1);\nif (blockState.getTraitValue(LanternBooleanTraits.OCCUPIED).get()) {\ntype |= 0x4;\n}\nif (blockState.getTraitValue(LanternEnumTraits.BED_PART).get() == LanternBedPart.HEAD) {\ntype |= 0x8;\n}\nreturn (byte) type;\n});\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\/\/\/ Golden Rail \/\/\/\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\nregister(27, simpleBuilder()\n.traits(LanternEnumTraits.STRAIGHT_RAIL_DIRECTION, LanternBooleanTraits.POWERED)\n.defaultState(state -> state\n.withTrait(LanternEnumTraits.STRAIGHT_RAIL_DIRECTION, LanternRailDirection.NORTH_SOUTH).get()\n.withTrait(LanternBooleanTraits.POWERED, false).get())\n.itemType()\n.selectionBox(BoundingBoxes::rail)\n.properties(builder -> builder\n.add(PASSABLE)\n.add(hardness(0.7))\n\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\/\/\/ Iron Block \/\/\/\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\nregister(42, simpleBuilder()\n.itemType()\n.properties(builder -> builder\n.add(hardness(5.0))\n.add(blastResistance(10.0)))\n.translation(\"tile.blockIron.name\")\n.build(\"minecraft\", \"iron_block\"));\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\/\/\/ Double Stone Slab 1 \/\/\/\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\nregister(43, doubleStoneSlab(LanternEnumTraits.STONE_SLAB1_TYPE, LanternSlabType.STONE)\n.translation(\"tile.stoneSlab.name\")\n.build(\"minecraft\", \"double_stone_slab\"),\nblockState -> doubleStoneSlabData(blockState, blockState.getTraitValue(LanternEnumTraits.STONE_SLAB1_TYPE).get().getInternalId()));\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\/\/\/ Stone Slab 1 \/\/\/\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\nregister(44, stoneSlab(LanternEnumTraits.STONE_SLAB1_TYPE, LanternSlabType.STONE,\n() -> BlockTypes.STONE_SLAB,\n() -> BlockTypes.DOUBLE_STONE_SLAB)\n\n.add(blastResistance(3.5)))\n.translation(\"tile.goldenRail.name\")\n.build(\"minecraft\", \"golden_rail\"),\nblockState -> {\nint type = blockState.getTraitValue(LanternEnumTraits.STRAIGHT_RAIL_DIRECTION).get().getInternalId();\nif (blockState.getTraitValue(LanternBooleanTraits.POWERED).get()) {\ntype |= 0x8;\n}\nreturn (byte) type;\n});\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\/\/\/ Detector Rail \/\/\/\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\nregister(28, simpleBuilder()\n.traits(LanternEnumTraits.STRAIGHT_RAIL_DIRECTION, LanternBooleanTraits.POWERED)\n.defaultState(state -> state\n.withTrait(LanternEnumTraits.STRAIGHT_RAIL_DIRECTION, LanternRailDirection.NORTH_SOUTH).get()\n.withTrait(LanternBooleanTraits.POWERED, false).get())\n.itemType()\n.selectionBox(BoundingBoxes::rail)\n.properties(builder -> builder\n.add(PASSABLE)\n.add(hardness(0.7))\n\n@Override\npublic void registerDefaults() {\n\/\/ @formatter:off\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\/\/\/ Air \/\/\/\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\nregister(0, builder()\n.properties(PropertyProviderCollections.DEFAULT_GAS)\n.translation(\"tile.air.name\")\n.build(\"minecraft\", \"air\"));\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\/\/\/ Stone \/\/\/\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\nregister(1, simpleBuilder()\n.trait(LanternEnumTraits.STONE_TYPE)\n.defaultState(state -> state.withTrait(LanternEnumTraits.STONE_TYPE, LanternStoneType.STONE).get())\n\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\/\/\/ Iron Block \/\/\/\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\nregister(42, simpleBuilder()\n.itemType()\n.properties(builder -> builder\n.add(hardness(5.0))\n.add(blastResistance(10.0)))\n.translation(\"tile.blockIron.name\")\n.build(\"minecraft\", \"iron_block\"));\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\/\/\/ Double Stone Slab 1 \/\/\/\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\nregister(43, doubleStoneSlab(LanternEnumTraits.STONE_SLAB1_TYPE, LanternSlabType.STONE)\n.translation(\"tile.stoneSlab.name\")\n.build(\"minecraft\", \"double_stone_slab\"),\nblockState -> doubleStoneSlabData(blockState, blockState.getTraitValue(LanternEnumTraits.STONE_SLAB1_TYPE).get().getInternalId()));\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\/\/\/ Stone Slab 1 \/\/\/\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\nregister(44, stoneSlab(LanternEnumTraits.STONE_SLAB1_TYPE, LanternSlabType.STONE,\n() -> BlockTypes.STONE_SLAB,\n() -> BlockTypes.DOUBLE_STONE_SLAB)\n\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\/\/\/ Iron Block \/\/\/\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\nregister(42, simpleBuilder()\n.itemType()\n.properties(builder -> builder\n.add(hardness(5.0))\n.add(blastResistance(10.0)))\n.translation(\"tile.blockIron.name\")\n.build(\"minecraft\", \"iron_block\"));\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\/\/\/ Double Stone Slab 1 \/\/\/\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\nregister(43, doubleStoneSlab(LanternEnumTraits.STONE_SLAB1_TYPE, LanternSlabType.STONE)\n.translation(\"tile.stoneSlab.name\")\n.build(\"minecraft\", \"double_stone_slab\"),\nblockState -> doubleStoneSlabData(blockState, blockState.getTraitValue(LanternEnumTraits.STONE_SLAB1_TYPE).get().getInternalId()));\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\/\/\/ Stone Slab 1 \/\/\/\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\nregister(44, stoneSlab(LanternEnumTraits.STONE_SLAB1_TYPE, LanternSlabType.STONE,\n() -> BlockTypes.STONE_SLAB,\n() -> BlockTypes.DOUBLE_STONE_SLAB)\n\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\/\/\/ Bookshelf \/\/\/\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\nregister(47, simpleBuilder()\n.itemType()\n.properties(builder -> builder\n.add(hardness(1.5))\n.add(blastResistance(7.5)))\n.translation(\"tile.bookshelf.name\")\n.build(\"minecraft\", \"bookshelf\"));\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\/\/\/ Mossy Cobblestone \/\/\/\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\nregister(48, simpleBuilder()\n.itemType()\n.properties(builder -> builder\n.add(hardness(2.0))\n.add(blastResistance(10.0)))\n.translation(\"tile.stoneMoss.name\")\n.build(\"minecraft\", \"mossy_cobblestone\"));\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\/\/\/ Obsidian \/\/\/\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\n.add(new EnderChestInteractionBehavior()))\n.build(\"minecraft\", \"ender_chest\"),\nthis::horizontalFacingData);\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\/\/\/ Trapped Chest \/\/\/\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\nregister(146, chestBuilder()\n.translation(\"tile.chestTrap.name\")\n.build(\"minecraft\", \"trapped_chest\"),\nthis::horizontalFacingData);\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\/\/\/ Weighted Pressure Plate (Light) \/\/\/\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\nregister(147, weightedPressurePlateBuilder()\n.translation(\"tile.weightedPlate_light.name\")\n.build(\"minecraft\", \"light_weighted_pressure_plate\"),\nthis::weightedPressurePlateData);\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\/\/\/ Weighted Pressure Plate (Heavy) \/\/\/\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\nregister(148, weightedPressurePlateBuilder()\n.translation(\"tile.weightedPlate_heavy.name\")\n.build(\"minecraft\", \"heavy_weighted_pressure_plate\"),\n\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\/\/\/ Iron Block \/\/\/\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\nregister(42, simpleBuilder()\n.itemType()\n.properties(builder -> builder\n.add(hardness(5.0))\n.add(blastResistance(10.0)))\n.translation(\"tile.blockIron.name\")\n.build(\"minecraft\", \"iron_block\"));\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\/\/\/ Double Stone Slab 1 \/\/\/\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\nregister(43, doubleStoneSlab(LanternEnumTraits.STONE_SLAB1_TYPE, LanternSlabType.STONE)\n.translation(\"tile.stoneSlab.name\")\n.build(\"minecraft\", \"double_stone_slab\"),\nblockState -> doubleStoneSlabData(blockState, blockState.getTraitValue(LanternEnumTraits.STONE_SLAB1_TYPE).get().getInternalId()));\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\/\/\/ Stone Slab 1 \/\/\/\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\nregister(44, stoneSlab(LanternEnumTraits.STONE_SLAB1_TYPE, LanternSlabType.STONE,\n() -> BlockTypes.STONE_SLAB,\n() -> BlockTypes.DOUBLE_STONE_SLAB)\n\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\/\/\/ Wool \/\/\/\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\nregister(35, dyedBuilder(\"tile.wool.%s.name\")\n.properties(builder -> builder\n.add(hardness(0.8))\n.add(blastResistance(4.0)))\n.build(\"minecraft\", \"wool\"),\nthis::dyedData);\n\/\/ TODO: 36\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\/\/\/ Yellow Flower \/\/\/\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\nregister(37, simpleBuilder()\n.traits(LanternEnumTraits.YELLOW_FLOWER_TYPE)\n.defaultState(state -> state\n.withTrait(LanternEnumTraits.YELLOW_FLOWER_TYPE, LanternPlantType.DANDELION).get())\n.itemType(builder -> builder\n.keysProvider(collection -> collection\n.register(Keys.PLANT_TYPE, LanternPlantType.DANDELION)))\n.selectionBox(BoundingBoxes.bush())\n.properties(builder -> builder\n.add(INSTANT_BROKEN)\n\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\/\/\/ Wool \/\/\/\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\nregister(35, dyedBuilder(\"tile.wool.%s.name\")\n.properties(builder -> builder\n.add(hardness(0.8))\n.add(blastResistance(4.0)))\n.build(\"minecraft\", \"wool\"),\nthis::dyedData);\n\/\/ TODO: 36\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\/\/\/ Yellow Flower \/\/\/\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\nregister(37, simpleBuilder()\n.traits(LanternEnumTraits.YELLOW_FLOWER_TYPE)\n.defaultState(state -> state\n.withTrait(LanternEnumTraits.YELLOW_FLOWER_TYPE, LanternPlantType.DANDELION).get())\n.itemType(builder -> builder\n.keysProvider(collection -> collection\n.register(Keys.PLANT_TYPE, LanternPlantType.DANDELION)))\n.selectionBox(BoundingBoxes.bush())\n.properties(builder -> builder\n.add(INSTANT_BROKEN)\n\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\/\/\/ Wool \/\/\/\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\nregister(35, dyedBuilder(\"tile.wool.%s.name\")\n.properties(builder -> builder\n.add(hardness(0.8))\n.add(blastResistance(4.0)))\n.build(\"minecraft\", \"wool\"),\nthis::dyedData);\n\/\/ TODO: 36\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\/\/\/ Yellow Flower \/\/\/\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\nregister(37, simpleBuilder()\n.traits(LanternEnumTraits.YELLOW_FLOWER_TYPE)\n.defaultState(state -> state\n.withTrait(LanternEnumTraits.YELLOW_FLOWER_TYPE, LanternPlantType.DANDELION).get())\n.itemType(builder -> builder\n.keysProvider(collection -> collection\n.register(Keys.PLANT_TYPE, LanternPlantType.DANDELION)))\n.selectionBox(BoundingBoxes.bush())\n.properties(builder -> builder\n.add(INSTANT_BROKEN)\n\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\/\/\/ Wool \/\/\/\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\nregister(35, dyedBuilder(\"tile.wool.%s.name\")\n.properties(builder -> builder\n.add(hardness(0.8))\n.add(blastResistance(4.0)))\n.build(\"minecraft\", \"wool\"),\nthis::dyedData);\n\/\/ TODO: 36\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\/\/\/ Yellow Flower \/\/\/\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\nregister(37, simpleBuilder()\n.traits(LanternEnumTraits.YELLOW_FLOWER_TYPE)\n.defaultState(state -> state\n.withTrait(LanternEnumTraits.YELLOW_FLOWER_TYPE, LanternPlantType.DANDELION).get())\n.itemType(builder -> builder\n.keysProvider(collection -> collection\n.register(Keys.PLANT_TYPE, LanternPlantType.DANDELION)))\n.selectionBox(BoundingBoxes.bush())\n.properties(builder -> builder\n.add(INSTANT_BROKEN)\n\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\/\/\/ Wool \/\/\/\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\nregister(35, dyedBuilder(\"tile.wool.%s.name\")\n.properties(builder -> builder\n.add(hardness(0.8))\n.add(blastResistance(4.0)))\n.build(\"minecraft\", \"wool\"),\nthis::dyedData);\n\/\/ TODO: 36\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\/\/\/ Yellow Flower \/\/\/\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\nregister(37, simpleBuilder()\n.traits(LanternEnumTraits.YELLOW_FLOWER_TYPE)\n.defaultState(state -> state\n.withTrait(LanternEnumTraits.YELLOW_FLOWER_TYPE, LanternPlantType.DANDELION).get())\n.itemType(builder -> builder\n.keysProvider(collection -> collection\n.register(Keys.PLANT_TYPE, LanternPlantType.DANDELION)))\n.selectionBox(BoundingBoxes.bush())\n.properties(builder -> builder\n.add(INSTANT_BROKEN)\n\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\/\/\/ Iron Block \/\/\/\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\nregister(42, simpleBuilder()\n.itemType()\n.properties(builder -> builder\n.add(hardness(5.0))\n.add(blastResistance(10.0)))\n.translation(\"tile.blockIron.name\")\n.build(\"minecraft\", \"iron_block\"));\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\/\/\/ Double Stone Slab 1 \/\/\/\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\nregister(43, doubleStoneSlab(LanternEnumTraits.STONE_SLAB1_TYPE, LanternSlabType.STONE)\n.translation(\"tile.stoneSlab.name\")\n.build(\"minecraft\", \"double_stone_slab\"),\nblockState -> doubleStoneSlabData(blockState, blockState.getTraitValue(LanternEnumTraits.STONE_SLAB1_TYPE).get().getInternalId()));\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\/\/\/ Stone Slab 1 \/\/\/\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\nregister(44, stoneSlab(LanternEnumTraits.STONE_SLAB1_TYPE, LanternSlabType.STONE,\n() -> BlockTypes.STONE_SLAB,\n() -> BlockTypes.DOUBLE_STONE_SLAB)\n\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\/\/\/ Wool \/\/\/\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\nregister(35, dyedBuilder(\"tile.wool.%s.name\")\n.properties(builder -> builder\n.add(hardness(0.8))\n.add(blastResistance(4.0)))\n.build(\"minecraft\", \"wool\"),\nthis::dyedData);\n\/\/ TODO: 36\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\/\/\/ Yellow Flower \/\/\/\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\nregister(37, simpleBuilder()\n.traits(LanternEnumTraits.YELLOW_FLOWER_TYPE)\n.defaultState(state -> state\n.withTrait(LanternEnumTraits.YELLOW_FLOWER_TYPE, LanternPlantType.DANDELION).get())\n.itemType(builder -> builder\n.keysProvider(collection -> collection\n.register(Keys.PLANT_TYPE, LanternPlantType.DANDELION)))\n.selectionBox(BoundingBoxes.bush())\n.properties(builder -> builder\n.add(INSTANT_BROKEN)\n\n.itemType(builder -> builder\n.keysProvider(collection -> collection\n.register(Keys.PLANT_TYPE, LanternPlantType.POPPY)))\n.selectionBox(BoundingBoxes.bush())\n.properties(builder -> builder\n.add(INSTANT_BROKEN)\n.add(PASSABLE))\n.translation(TranslationProvider.of(LanternEnumTraits.RED_FLOWER_TYPE))\n.build(\"minecraft\", \"red_flower\"),\nblockState -> (byte) blockState.getTraitValue(LanternEnumTraits.RED_FLOWER_TYPE).get().getInternalId());\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\/\/\/ Brown Mushroom \/\/\/\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\nregister(39, simpleBuilder()\n.selectionBox(BoundingBoxes.bush())\n.properties(builder -> builder\n.add(INSTANT_BROKEN)\n.add(PASSABLE)\n.add(lightEmission(1)))\n.translation(\"tile.mushroom.name\")\n.build(\"minecraft\", \"brown_mushroom\"));\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\/\/\/ Red Mushroom \/\/\/\n\n.itemType(builder -> builder\n.keysProvider(collection -> collection\n.register(Keys.PLANT_TYPE, LanternPlantType.POPPY)))\n.selectionBox(BoundingBoxes.bush())\n.properties(builder -> builder\n.add(INSTANT_BROKEN)\n.add(PASSABLE))\n.translation(TranslationProvider.of(LanternEnumTraits.RED_FLOWER_TYPE))\n.build(\"minecraft\", \"red_flower\"),\nblockState -> (byte) blockState.getTraitValue(LanternEnumTraits.RED_FLOWER_TYPE).get().getInternalId());\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\/\/\/ Brown Mushroom \/\/\/\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\nregister(39, simpleBuilder()\n.selectionBox(BoundingBoxes.bush())\n.properties(builder -> builder\n.add(INSTANT_BROKEN)\n.add(PASSABLE)\n.add(lightEmission(1)))\n.translation(\"tile.mushroom.name\")\n.build(\"minecraft\", \"brown_mushroom\"));\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\/\/\/ Red Mushroom \/\/\/\n\n.add(blastResistance(3.5)))\n.translation(\"tile.goldenRail.name\")\n.build(\"minecraft\", \"golden_rail\"),\nblockState -> {\nint type = blockState.getTraitValue(LanternEnumTraits.STRAIGHT_RAIL_DIRECTION).get().getInternalId();\nif (blockState.getTraitValue(LanternBooleanTraits.POWERED).get()) {\ntype |= 0x8;\n}\nreturn (byte) type;\n});\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\/\/\/ Detector Rail \/\/\/\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\nregister(28, simpleBuilder()\n.traits(LanternEnumTraits.STRAIGHT_RAIL_DIRECTION, LanternBooleanTraits.POWERED)\n.defaultState(state -> state\n.withTrait(LanternEnumTraits.STRAIGHT_RAIL_DIRECTION, LanternRailDirection.NORTH_SOUTH).get()\n.withTrait(LanternBooleanTraits.POWERED, false).get())\n.itemType()\n.selectionBox(BoundingBoxes::rail)\n.properties(builder -> builder\n.add(PASSABLE)\n.add(hardness(0.7))\n\n.itemType(builder -> builder\n.keysProvider(collection -> collection\n.register(Keys.PLANT_TYPE, LanternPlantType.POPPY)))\n.selectionBox(BoundingBoxes.bush())\n.properties(builder -> builder\n.add(INSTANT_BROKEN)\n.add(PASSABLE))\n.translation(TranslationProvider.of(LanternEnumTraits.RED_FLOWER_TYPE))\n.build(\"minecraft\", \"red_flower\"),\nblockState -> (byte) blockState.getTraitValue(LanternEnumTraits.RED_FLOWER_TYPE).get().getInternalId());\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\/\/\/ Brown Mushroom \/\/\/\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\nregister(39, simpleBuilder()\n.selectionBox(BoundingBoxes.bush())\n.properties(builder -> builder\n.add(INSTANT_BROKEN)\n.add(PASSABLE)\n.add(lightEmission(1)))\n.translation(\"tile.mushroom.name\")\n.build(\"minecraft\", \"brown_mushroom\"));\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\/\/\/ Red Mushroom \/\/\/\n\n@Override\npublic void registerDefaults() {\n\/\/ @formatter:off\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\/\/\/ Air \/\/\/\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\nregister(0, builder()\n.properties(PropertyProviderCollections.DEFAULT_GAS)\n.translation(\"tile.air.name\")\n.build(\"minecraft\", \"air\"));\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\/\/\/ Stone \/\/\/\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\nregister(1, simpleBuilder()\n.trait(LanternEnumTraits.STONE_TYPE)\n.defaultState(state -> state.withTrait(LanternEnumTraits.STONE_TYPE, LanternStoneType.STONE).get())\n\n@Override\npublic void registerDefaults() {\n\/\/ @formatter:off\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\/\/\/ Air \/\/\/\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\nregister(0, builder()\n.properties(PropertyProviderCollections.DEFAULT_GAS)\n.translation(\"tile.air.name\")\n.build(\"minecraft\", \"air\"));\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\/\/\/ Stone \/\/\/\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\nregister(1, simpleBuilder()\n.trait(LanternEnumTraits.STONE_TYPE)\n.defaultState(state -> state.withTrait(LanternEnumTraits.STONE_TYPE, LanternStoneType.STONE).get())\n\n.defaultState(state -> state\n.withTrait(LanternEnumTraits.HORIZONTAL_FACING, Direction.NORTH).get())\n.properties(builder -> builder\n.add(hardness(1.0))\n.add(blastResistance(5.0)))\n.behaviors(pipeline -> pipeline\n.add(new SignInteractionBehavior()))\n.tileEntityType(() -> TileEntityTypes.BANNER)\n.build(\"minecraft\", \"wall_banner\"),\nthis::horizontalFacingData);\n\/\/ @formatter:on\n}","code_context_20":"@Override\npublic void registerDefaults() {\n\/\/ @formatter:off\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\/\/\/ Air \/\/\/\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\nregister(0, builder()\n.properties(PropertyProviderCollections.DEFAULT_GAS)\n.translation(\"tile.air.name\")\n.build(\"minecraft\", \"air\"));\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\/\/\/ Stone \/\/\/\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\nregister(1, simpleBuilder()\n.trait(LanternEnumTraits.STONE_TYPE)\n.defaultState(state -> state.withTrait(LanternEnumTraits.STONE_TYPE, LanternStoneType.STONE).get())\n.itemType(builder -> builder\n.keysProvider(collection -> collection\n.register(Keys.STONE_TYPE, LanternStoneType.STONE)\n)\n)\n.properties(builder -> builder\n.add(hardness(1.5))\n.add(blastResistance(30.0)))\n.translation(TranslationProvider.of(LanternEnumTraits.STONE_TYPE))\n.build(\"minecraft\", \"stone\"),\n\n@Override\npublic void registerDefaults() {\n\/\/ @formatter:off\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\/\/\/ Air \/\/\/\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\nregister(0, builder()\n.properties(PropertyProviderCollections.DEFAULT_GAS)\n.translation(\"tile.air.name\")\n.build(\"minecraft\", \"air\"));\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\/\/\/ Stone \/\/\/\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\nregister(1, simpleBuilder()\n.trait(LanternEnumTraits.STONE_TYPE)\n.defaultState(state -> state.withTrait(LanternEnumTraits.STONE_TYPE, LanternStoneType.STONE).get())\n.itemType(builder -> builder\n.keysProvider(collection -> collection\n.register(Keys.STONE_TYPE, LanternStoneType.STONE)\n)\n)\n.properties(builder -> builder\n.add(hardness(1.5))\n.add(blastResistance(30.0)))\n.translation(TranslationProvider.of(LanternEnumTraits.STONE_TYPE))\n.build(\"minecraft\", \"stone\"),\n\n@Override\npublic void registerDefaults() {\n\/\/ @formatter:off\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\/\/\/ Air \/\/\/\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\nregister(0, builder()\n.properties(PropertyProviderCollections.DEFAULT_GAS)\n.translation(\"tile.air.name\")\n.build(\"minecraft\", \"air\"));\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\/\/\/ Stone \/\/\/\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\nregister(1, simpleBuilder()\n.trait(LanternEnumTraits.STONE_TYPE)\n.defaultState(state -> state.withTrait(LanternEnumTraits.STONE_TYPE, LanternStoneType.STONE).get())\n.itemType(builder -> builder\n.keysProvider(collection -> collection\n.register(Keys.STONE_TYPE, LanternStoneType.STONE)\n)\n)\n.properties(builder -> builder\n.add(hardness(1.5))\n.add(blastResistance(30.0)))\n.translation(TranslationProvider.of(LanternEnumTraits.STONE_TYPE))\n.build(\"minecraft\", \"stone\"),\n\n@Override\npublic void registerDefaults() {\n\/\/ @formatter:off\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\/\/\/ Air \/\/\/\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\nregister(0, builder()\n.properties(PropertyProviderCollections.DEFAULT_GAS)\n.translation(\"tile.air.name\")\n.build(\"minecraft\", \"air\"));\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\/\/\/ Stone \/\/\/\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\nregister(1, simpleBuilder()\n.trait(LanternEnumTraits.STONE_TYPE)\n.defaultState(state -> state.withTrait(LanternEnumTraits.STONE_TYPE, LanternStoneType.STONE).get())\n.itemType(builder -> builder\n.keysProvider(collection -> collection\n.register(Keys.STONE_TYPE, LanternStoneType.STONE)\n)\n)\n.properties(builder -> builder\n.add(hardness(1.5))\n.add(blastResistance(30.0)))\n.translation(TranslationProvider.of(LanternEnumTraits.STONE_TYPE))\n.build(\"minecraft\", \"stone\"),\n\n@Override\npublic void registerDefaults() {\n\/\/ @formatter:off\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\/\/\/ Air \/\/\/\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\nregister(0, builder()\n.properties(PropertyProviderCollections.DEFAULT_GAS)\n.translation(\"tile.air.name\")\n.build(\"minecraft\", \"air\"));\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\/\/\/ Stone \/\/\/\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\nregister(1, simpleBuilder()\n.trait(LanternEnumTraits.STONE_TYPE)\n.defaultState(state -> state.withTrait(LanternEnumTraits.STONE_TYPE, LanternStoneType.STONE).get())\n.itemType(builder -> builder\n.keysProvider(collection -> collection\n.register(Keys.STONE_TYPE, LanternStoneType.STONE)\n)\n)\n.properties(builder -> builder\n.add(hardness(1.5))\n.add(blastResistance(30.0)))\n.translation(TranslationProvider.of(LanternEnumTraits.STONE_TYPE))\n.build(\"minecraft\", \"stone\"),\n\n@Override\npublic void registerDefaults() {\n\/\/ @formatter:off\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\/\/\/ Air \/\/\/\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\nregister(0, builder()\n.properties(PropertyProviderCollections.DEFAULT_GAS)\n.translation(\"tile.air.name\")\n.build(\"minecraft\", \"air\"));\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\/\/\/ Stone \/\/\/\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\nregister(1, simpleBuilder()\n.trait(LanternEnumTraits.STONE_TYPE)\n.defaultState(state -> state.withTrait(LanternEnumTraits.STONE_TYPE, LanternStoneType.STONE).get())\n.itemType(builder -> builder\n.keysProvider(collection -> collection\n.register(Keys.STONE_TYPE, LanternStoneType.STONE)\n)\n)\n.properties(builder -> builder\n.add(hardness(1.5))\n.add(blastResistance(30.0)))\n.translation(TranslationProvider.of(LanternEnumTraits.STONE_TYPE))\n.build(\"minecraft\", \"stone\"),\n\n.build(\"minecraft\", \"cobblestone\"));\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\/\/\/ Planks \/\/\/\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\nregister(5, simpleBuilder()\n.trait(LanternEnumTraits.TREE_TYPE)\n.defaultState(state -> state.withTrait(LanternEnumTraits.TREE_TYPE, LanternTreeType.OAK).get())\n.itemType(builder -> builder\n.keysProvider(collection -> collection\n.register(Keys.TREE_TYPE, LanternTreeType.OAK)\n)\n)\n.properties(builder -> builder\n.add(hardness(2.0))\n.add(blastResistance(5.0))\n.add(flammableInfo(5, 20)))\n.translation(TranslationProvider.of(LanternEnumTraits.TREE_TYPE, type ->\ntr(\"tile.planks.\" + type.getTranslationKeyBase() + \".name\")))\n.build(\"minecraft\", \"planks\"),\nblockState -> (byte) blockState.getTraitValue(LanternEnumTraits.TREE_TYPE).get().getInternalId());\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\/\/\/ Sapling \/\/\/\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\nregister(6, simpleBuilder()\n.traits(LanternEnumTraits.TREE_TYPE, LanternIntegerTraits.SAPLING_GROWTH_STAGE)\n.defaultState(state -> state\n.withTrait(LanternEnumTraits.TREE_TYPE, LanternTreeType.OAK).get()\n.withTrait(LanternIntegerTraits.SAPLING_GROWTH_STAGE, 0).get())\n.itemType(builder -> builder\n.keysProvider(collection -> collection\n.register(Keys.TREE_TYPE, LanternTreeType.OAK)\n)\n)\n.properties(builder -> builder\n.add(PASSABLE)\n.add(INSTANT_BROKEN))\n.translation(TranslationProvider.of(LanternEnumTraits.TREE_TYPE, type ->\ntr(\"tile.sapling.\" + type.getTranslationKeyBase() + \".name\")))\n.build(\"minecraft\", \"sapling\"),\nblockState -> {\nfinal int type = blockState.getTraitValue(LanternEnumTraits.TREE_TYPE).get().getInternalId();\nfinal int stage = blockState.getTraitValue(LanternIntegerTraits.SAPLING_GROWTH_STAGE).get();\nreturn (byte) (stage << 3 | type);\n\n.build(\"minecraft\", \"cobblestone\"));\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\/\/\/ Planks \/\/\/\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\nregister(5, simpleBuilder()\n.trait(LanternEnumTraits.TREE_TYPE)\n.defaultState(state -> state.withTrait(LanternEnumTraits.TREE_TYPE, LanternTreeType.OAK).get())\n.itemType(builder -> builder\n.keysProvider(collection -> collection\n.register(Keys.TREE_TYPE, LanternTreeType.OAK)\n)\n)\n.properties(builder -> builder\n.add(hardness(2.0))\n.add(blastResistance(5.0))\n.add(flammableInfo(5, 20)))\n.translation(TranslationProvider.of(LanternEnumTraits.TREE_TYPE, type ->\ntr(\"tile.planks.\" + type.getTranslationKeyBase() + \".name\")))\n.build(\"minecraft\", \"planks\"),\nblockState -> (byte) blockState.getTraitValue(LanternEnumTraits.TREE_TYPE).get().getInternalId());\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\/\/\/ Sapling \/\/\/\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\nregister(6, simpleBuilder()\n.traits(LanternEnumTraits.TREE_TYPE, LanternIntegerTraits.SAPLING_GROWTH_STAGE)\n.defaultState(state -> state\n.withTrait(LanternEnumTraits.TREE_TYPE, LanternTreeType.OAK).get()\n.withTrait(LanternIntegerTraits.SAPLING_GROWTH_STAGE, 0).get())\n.itemType(builder -> builder\n.keysProvider(collection -> collection\n.register(Keys.TREE_TYPE, LanternTreeType.OAK)\n)\n)\n.properties(builder -> builder\n.add(PASSABLE)\n.add(INSTANT_BROKEN))\n.translation(TranslationProvider.of(LanternEnumTraits.TREE_TYPE, type ->\ntr(\"tile.sapling.\" + type.getTranslationKeyBase() + \".name\")))\n.build(\"minecraft\", \"sapling\"),\nblockState -> {\nfinal int type = blockState.getTraitValue(LanternEnumTraits.TREE_TYPE).get().getInternalId();\nfinal int stage = blockState.getTraitValue(LanternIntegerTraits.SAPLING_GROWTH_STAGE).get();\nreturn (byte) (stage << 3 | type);\n\n.build(\"minecraft\", \"cobblestone\"));\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\/\/\/ Planks \/\/\/\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\nregister(5, simpleBuilder()\n.trait(LanternEnumTraits.TREE_TYPE)\n.defaultState(state -> state.withTrait(LanternEnumTraits.TREE_TYPE, LanternTreeType.OAK).get())\n.itemType(builder -> builder\n.keysProvider(collection -> collection\n.register(Keys.TREE_TYPE, LanternTreeType.OAK)\n)\n)\n.properties(builder -> builder\n.add(hardness(2.0))\n.add(blastResistance(5.0))\n.add(flammableInfo(5, 20)))\n.translation(TranslationProvider.of(LanternEnumTraits.TREE_TYPE, type ->\ntr(\"tile.planks.\" + type.getTranslationKeyBase() + \".name\")))\n.build(\"minecraft\", \"planks\"),\nblockState -> (byte) blockState.getTraitValue(LanternEnumTraits.TREE_TYPE).get().getInternalId());\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\/\/\/ Sapling \/\/\/\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\nregister(6, simpleBuilder()\n.traits(LanternEnumTraits.TREE_TYPE, LanternIntegerTraits.SAPLING_GROWTH_STAGE)\n.defaultState(state -> state\n.withTrait(LanternEnumTraits.TREE_TYPE, LanternTreeType.OAK).get()\n.withTrait(LanternIntegerTraits.SAPLING_GROWTH_STAGE, 0).get())\n.itemType(builder -> builder\n.keysProvider(collection -> collection\n.register(Keys.TREE_TYPE, LanternTreeType.OAK)\n)\n)\n.properties(builder -> builder\n.add(PASSABLE)\n.add(INSTANT_BROKEN))\n.translation(TranslationProvider.of(LanternEnumTraits.TREE_TYPE, type ->\ntr(\"tile.sapling.\" + type.getTranslationKeyBase() + \".name\")))\n.build(\"minecraft\", \"sapling\"),\nblockState -> {\nfinal int type = blockState.getTraitValue(LanternEnumTraits.TREE_TYPE).get().getInternalId();\nfinal int stage = blockState.getTraitValue(LanternIntegerTraits.SAPLING_GROWTH_STAGE).get();\nreturn (byte) (stage << 3 | type);\n\n.add(PropertyProviderCollections.UNBREAKABLE))\n.translation(\"tile.bedrock.name\")\n.build(\"minecraft\", \"bedrock\"));\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\/\/\/ Sand \/\/\/\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\nregister(12, simpleBuilder()\n.trait(LanternEnumTraits.SAND_TYPE)\n.defaultState(state -> state.withTrait(LanternEnumTraits.SAND_TYPE, LanternSandType.NORMAL).get())\n.itemType(builder -> builder\n.keysProvider(collection -> collection\n.register(Keys.SAND_TYPE, LanternSandType.NORMAL)\n)\n)\n.properties(builder -> builder\n.add(hardness(0.5))\n.add(blastResistance(2.5)))\n.translation(TranslationProvider.of(LanternEnumTraits.SAND_TYPE))\n.build(\"minecraft\", \"sand\"),\nblockState -> (byte) blockState.getTraitValue(LanternEnumTraits.SAND_TYPE).get().getInternalId());\n\/\/ TODO: Sand physics behavior\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\/\/\/ Gravel \/\/\/\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\nregister(13, simpleBuilder()\n.itemType()\n.properties(builder -> builder\n.add(hardness(0.6))\n.add(blastResistance(3.0)))\n.translation(\"tile.gravel.name\")\n.build(\"minecraft\", \"gravel\"));\n\/\/ TODO: Gravel physics behavior\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\/\/\/ Gold Ore \/\/\/\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\nregister(14, simpleBuilder()\n.itemType()\n.properties(builder -> builder\n.add(hardness(3.0))\n.add(blastResistance(15.0)))\n.translation(\"tile.oreGold.name\")\n.build(\"minecraft\", \"gold_ore\"));\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\/\/\/ Iron Ore \/\/\/\n\n.register(Keys.SAND_TYPE, LanternSandType.NORMAL)\n)\n)\n.properties(builder -> builder\n.add(hardness(0.5))\n.add(blastResistance(2.5)))\n.translation(TranslationProvider.of(LanternEnumTraits.SAND_TYPE))\n.build(\"minecraft\", \"sand\"),\nblockState -> (byte) blockState.getTraitValue(LanternEnumTraits.SAND_TYPE).get().getInternalId());\n\/\/ TODO: Sand physics behavior\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\/\/\/ Gravel \/\/\/\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\nregister(13, simpleBuilder()\n.itemType()\n.properties(builder -> builder\n.add(hardness(0.6))\n.add(blastResistance(3.0)))\n.translation(\"tile.gravel.name\")\n.build(\"minecraft\", \"gravel\"));\n\/\/ TODO: Gravel physics behavior\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\/\/\/ Gold Ore \/\/\/\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\nregister(14, simpleBuilder()\n.itemType()\n.properties(builder -> builder\n.add(hardness(3.0))\n.add(blastResistance(15.0)))\n.translation(\"tile.oreGold.name\")\n.build(\"minecraft\", \"gold_ore\"));\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\/\/\/ Iron Ore \/\/\/\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\nregister(15, simpleBuilder()\n.itemType()\n.properties(builder -> builder\n.add(hardness(3.0))\n.add(blastResistance(15.0)))\n.translation(\"tile.oreIron.name\")\n.build(\"minecraft\", \"iron_ore\"));\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\/\/\/ Coal Ore \/\/\/\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\n.build(\"minecraft\", \"cobblestone\"));\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\/\/\/ Planks \/\/\/\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\nregister(5, simpleBuilder()\n.trait(LanternEnumTraits.TREE_TYPE)\n.defaultState(state -> state.withTrait(LanternEnumTraits.TREE_TYPE, LanternTreeType.OAK).get())\n.itemType(builder -> builder\n.keysProvider(collection -> collection\n.register(Keys.TREE_TYPE, LanternTreeType.OAK)\n)\n)\n.properties(builder -> builder\n.add(hardness(2.0))\n.add(blastResistance(5.0))\n.add(flammableInfo(5, 20)))\n.translation(TranslationProvider.of(LanternEnumTraits.TREE_TYPE, type ->\ntr(\"tile.planks.\" + type.getTranslationKeyBase() + \".name\")))\n.build(\"minecraft\", \"planks\"),\nblockState -> (byte) blockState.getTraitValue(LanternEnumTraits.TREE_TYPE).get().getInternalId());\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\/\/\/ Sapling \/\/\/\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\nregister(6, simpleBuilder()\n.traits(LanternEnumTraits.TREE_TYPE, LanternIntegerTraits.SAPLING_GROWTH_STAGE)\n.defaultState(state -> state\n.withTrait(LanternEnumTraits.TREE_TYPE, LanternTreeType.OAK).get()\n.withTrait(LanternIntegerTraits.SAPLING_GROWTH_STAGE, 0).get())\n.itemType(builder -> builder\n.keysProvider(collection -> collection\n.register(Keys.TREE_TYPE, LanternTreeType.OAK)\n)\n)\n.properties(builder -> builder\n.add(PASSABLE)\n.add(INSTANT_BROKEN))\n.translation(TranslationProvider.of(LanternEnumTraits.TREE_TYPE, type ->\ntr(\"tile.sapling.\" + type.getTranslationKeyBase() + \".name\")))\n.build(\"minecraft\", \"sapling\"),\nblockState -> {\nfinal int type = blockState.getTraitValue(LanternEnumTraits.TREE_TYPE).get().getInternalId();\nfinal int stage = blockState.getTraitValue(LanternIntegerTraits.SAPLING_GROWTH_STAGE).get();\nreturn (byte) (stage << 3 | type);\n\n.build(\"minecraft\", \"cobblestone\"));\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\/\/\/ Planks \/\/\/\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\nregister(5, simpleBuilder()\n.trait(LanternEnumTraits.TREE_TYPE)\n.defaultState(state -> state.withTrait(LanternEnumTraits.TREE_TYPE, LanternTreeType.OAK).get())\n.itemType(builder -> builder\n.keysProvider(collection -> collection\n.register(Keys.TREE_TYPE, LanternTreeType.OAK)\n)\n)\n.properties(builder -> builder\n.add(hardness(2.0))\n.add(blastResistance(5.0))\n.add(flammableInfo(5, 20)))\n.translation(TranslationProvider.of(LanternEnumTraits.TREE_TYPE, type ->\ntr(\"tile.planks.\" + type.getTranslationKeyBase() + \".name\")))\n.build(\"minecraft\", \"planks\"),\nblockState -> (byte) blockState.getTraitValue(LanternEnumTraits.TREE_TYPE).get().getInternalId());\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\/\/\/ Sapling \/\/\/\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\nregister(6, simpleBuilder()\n.traits(LanternEnumTraits.TREE_TYPE, LanternIntegerTraits.SAPLING_GROWTH_STAGE)\n.defaultState(state -> state\n.withTrait(LanternEnumTraits.TREE_TYPE, LanternTreeType.OAK).get()\n.withTrait(LanternIntegerTraits.SAPLING_GROWTH_STAGE, 0).get())\n.itemType(builder -> builder\n.keysProvider(collection -> collection\n.register(Keys.TREE_TYPE, LanternTreeType.OAK)\n)\n)\n.properties(builder -> builder\n.add(PASSABLE)\n.add(INSTANT_BROKEN))\n.translation(TranslationProvider.of(LanternEnumTraits.TREE_TYPE, type ->\ntr(\"tile.sapling.\" + type.getTranslationKeyBase() + \".name\")))\n.build(\"minecraft\", \"sapling\"),\nblockState -> {\nfinal int type = blockState.getTraitValue(LanternEnumTraits.TREE_TYPE).get().getInternalId();\nfinal int stage = blockState.getTraitValue(LanternIntegerTraits.SAPLING_GROWTH_STAGE).get();\nreturn (byte) (stage << 3 | type);\n\n.build(\"minecraft\", \"cobblestone\"));\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\/\/\/ Planks \/\/\/\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\nregister(5, simpleBuilder()\n.trait(LanternEnumTraits.TREE_TYPE)\n.defaultState(state -> state.withTrait(LanternEnumTraits.TREE_TYPE, LanternTreeType.OAK).get())\n.itemType(builder -> builder\n.keysProvider(collection -> collection\n.register(Keys.TREE_TYPE, LanternTreeType.OAK)\n)\n)\n.properties(builder -> builder\n.add(hardness(2.0))\n.add(blastResistance(5.0))\n.add(flammableInfo(5, 20)))\n.translation(TranslationProvider.of(LanternEnumTraits.TREE_TYPE, type ->\ntr(\"tile.planks.\" + type.getTranslationKeyBase() + \".name\")))\n.build(\"minecraft\", \"planks\"),\nblockState -> (byte) blockState.getTraitValue(LanternEnumTraits.TREE_TYPE).get().getInternalId());\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\/\/\/ Sapling \/\/\/\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\nregister(6, simpleBuilder()\n.traits(LanternEnumTraits.TREE_TYPE, LanternIntegerTraits.SAPLING_GROWTH_STAGE)\n.defaultState(state -> state\n.withTrait(LanternEnumTraits.TREE_TYPE, LanternTreeType.OAK).get()\n.withTrait(LanternIntegerTraits.SAPLING_GROWTH_STAGE, 0).get())\n.itemType(builder -> builder\n.keysProvider(collection -> collection\n.register(Keys.TREE_TYPE, LanternTreeType.OAK)\n)\n)\n.properties(builder -> builder\n.add(PASSABLE)\n.add(INSTANT_BROKEN))\n.translation(TranslationProvider.of(LanternEnumTraits.TREE_TYPE, type ->\ntr(\"tile.sapling.\" + type.getTranslationKeyBase() + \".name\")))\n.build(\"minecraft\", \"sapling\"),\nblockState -> {\nfinal int type = blockState.getTraitValue(LanternEnumTraits.TREE_TYPE).get().getInternalId();\nfinal int stage = blockState.getTraitValue(LanternIntegerTraits.SAPLING_GROWTH_STAGE).get();\nreturn (byte) (stage << 3 | type);\n\n.build(\"minecraft\", \"cobblestone\"));\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\/\/\/ Planks \/\/\/\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\nregister(5, simpleBuilder()\n.trait(LanternEnumTraits.TREE_TYPE)\n.defaultState(state -> state.withTrait(LanternEnumTraits.TREE_TYPE, LanternTreeType.OAK).get())\n.itemType(builder -> builder\n.keysProvider(collection -> collection\n.register(Keys.TREE_TYPE, LanternTreeType.OAK)\n)\n)\n.properties(builder -> builder\n.add(hardness(2.0))\n.add(blastResistance(5.0))\n.add(flammableInfo(5, 20)))\n.translation(TranslationProvider.of(LanternEnumTraits.TREE_TYPE, type ->\ntr(\"tile.planks.\" + type.getTranslationKeyBase() + \".name\")))\n.build(\"minecraft\", \"planks\"),\nblockState -> (byte) blockState.getTraitValue(LanternEnumTraits.TREE_TYPE).get().getInternalId());\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\/\/\/ Sapling \/\/\/\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\nregister(6, simpleBuilder()\n.traits(LanternEnumTraits.TREE_TYPE, LanternIntegerTraits.SAPLING_GROWTH_STAGE)\n.defaultState(state -> state\n.withTrait(LanternEnumTraits.TREE_TYPE, LanternTreeType.OAK).get()\n.withTrait(LanternIntegerTraits.SAPLING_GROWTH_STAGE, 0).get())\n.itemType(builder -> builder\n.keysProvider(collection -> collection\n.register(Keys.TREE_TYPE, LanternTreeType.OAK)\n)\n)\n.properties(builder -> builder\n.add(PASSABLE)\n.add(INSTANT_BROKEN))\n.translation(TranslationProvider.of(LanternEnumTraits.TREE_TYPE, type ->\ntr(\"tile.sapling.\" + type.getTranslationKeyBase() + \".name\")))\n.build(\"minecraft\", \"sapling\"),\nblockState -> {\nfinal int type = blockState.getTraitValue(LanternEnumTraits.TREE_TYPE).get().getInternalId();\nfinal int stage = blockState.getTraitValue(LanternIntegerTraits.SAPLING_GROWTH_STAGE).get();\nreturn (byte) (stage << 3 | type);\n\n.build(\"minecraft\", \"cobblestone\"));\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\/\/\/ Planks \/\/\/\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\nregister(5, simpleBuilder()\n.trait(LanternEnumTraits.TREE_TYPE)\n.defaultState(state -> state.withTrait(LanternEnumTraits.TREE_TYPE, LanternTreeType.OAK).get())\n.itemType(builder -> builder\n.keysProvider(collection -> collection\n.register(Keys.TREE_TYPE, LanternTreeType.OAK)\n)\n)\n.properties(builder -> builder\n.add(hardness(2.0))\n.add(blastResistance(5.0))\n.add(flammableInfo(5, 20)))\n.translation(TranslationProvider.of(LanternEnumTraits.TREE_TYPE, type ->\ntr(\"tile.planks.\" + type.getTranslationKeyBase() + \".name\")))\n.build(\"minecraft\", \"planks\"),\nblockState -> (byte) blockState.getTraitValue(LanternEnumTraits.TREE_TYPE).get().getInternalId());\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\/\/\/ Sapling \/\/\/\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\nregister(6, simpleBuilder()\n.traits(LanternEnumTraits.TREE_TYPE, LanternIntegerTraits.SAPLING_GROWTH_STAGE)\n.defaultState(state -> state\n.withTrait(LanternEnumTraits.TREE_TYPE, LanternTreeType.OAK).get()\n.withTrait(LanternIntegerTraits.SAPLING_GROWTH_STAGE, 0).get())\n.itemType(builder -> builder\n.keysProvider(collection -> collection\n.register(Keys.TREE_TYPE, LanternTreeType.OAK)\n)\n)\n.properties(builder -> builder\n.add(PASSABLE)\n.add(INSTANT_BROKEN))\n.translation(TranslationProvider.of(LanternEnumTraits.TREE_TYPE, type ->\ntr(\"tile.sapling.\" + type.getTranslationKeyBase() + \".name\")))\n.build(\"minecraft\", \"sapling\"),\nblockState -> {\nfinal int type = blockState.getTraitValue(LanternEnumTraits.TREE_TYPE).get().getInternalId();\nfinal int stage = blockState.getTraitValue(LanternIntegerTraits.SAPLING_GROWTH_STAGE).get();\nreturn (byte) (stage << 3 | type);\n\n.build(\"minecraft\", \"cobblestone\"));\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\/\/\/ Planks \/\/\/\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\nregister(5, simpleBuilder()\n.trait(LanternEnumTraits.TREE_TYPE)\n.defaultState(state -> state.withTrait(LanternEnumTraits.TREE_TYPE, LanternTreeType.OAK).get())\n.itemType(builder -> builder\n.keysProvider(collection -> collection\n.register(Keys.TREE_TYPE, LanternTreeType.OAK)\n)\n)\n.properties(builder -> builder\n.add(hardness(2.0))\n.add(blastResistance(5.0))\n.add(flammableInfo(5, 20)))\n.translation(TranslationProvider.of(LanternEnumTraits.TREE_TYPE, type ->\ntr(\"tile.planks.\" + type.getTranslationKeyBase() + \".name\")))\n.build(\"minecraft\", \"planks\"),\nblockState -> (byte) blockState.getTraitValue(LanternEnumTraits.TREE_TYPE).get().getInternalId());\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\/\/\/ Sapling \/\/\/\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\nregister(6, simpleBuilder()\n.traits(LanternEnumTraits.TREE_TYPE, LanternIntegerTraits.SAPLING_GROWTH_STAGE)\n.defaultState(state -> state\n.withTrait(LanternEnumTraits.TREE_TYPE, LanternTreeType.OAK).get()\n.withTrait(LanternIntegerTraits.SAPLING_GROWTH_STAGE, 0).get())\n.itemType(builder -> builder\n.keysProvider(collection -> collection\n.register(Keys.TREE_TYPE, LanternTreeType.OAK)\n)\n)\n.properties(builder -> builder\n.add(PASSABLE)\n.add(INSTANT_BROKEN))\n.translation(TranslationProvider.of(LanternEnumTraits.TREE_TYPE, type ->\ntr(\"tile.sapling.\" + type.getTranslationKeyBase() + \".name\")))\n.build(\"minecraft\", \"sapling\"),\nblockState -> {\nfinal int type = blockState.getTraitValue(LanternEnumTraits.TREE_TYPE).get().getInternalId();\nfinal int stage = blockState.getTraitValue(LanternIntegerTraits.SAPLING_GROWTH_STAGE).get();\nreturn (byte) (stage << 3 | type);\n\n.build(\"minecraft\", \"cobblestone\"));\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\/\/\/ Planks \/\/\/\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\nregister(5, simpleBuilder()\n.trait(LanternEnumTraits.TREE_TYPE)\n.defaultState(state -> state.withTrait(LanternEnumTraits.TREE_TYPE, LanternTreeType.OAK).get())\n.itemType(builder -> builder\n.keysProvider(collection -> collection\n.register(Keys.TREE_TYPE, LanternTreeType.OAK)\n)\n)\n.properties(builder -> builder\n.add(hardness(2.0))\n.add(blastResistance(5.0))\n.add(flammableInfo(5, 20)))\n.translation(TranslationProvider.of(LanternEnumTraits.TREE_TYPE, type ->\ntr(\"tile.planks.\" + type.getTranslationKeyBase() + \".name\")))\n.build(\"minecraft\", \"planks\"),\nblockState -> (byte) blockState.getTraitValue(LanternEnumTraits.TREE_TYPE).get().getInternalId());\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\/\/\/ Sapling \/\/\/\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\nregister(6, simpleBuilder()\n.traits(LanternEnumTraits.TREE_TYPE, LanternIntegerTraits.SAPLING_GROWTH_STAGE)\n.defaultState(state -> state\n.withTrait(LanternEnumTraits.TREE_TYPE, LanternTreeType.OAK).get()\n.withTrait(LanternIntegerTraits.SAPLING_GROWTH_STAGE, 0).get())\n.itemType(builder -> builder\n.keysProvider(collection -> collection\n.register(Keys.TREE_TYPE, LanternTreeType.OAK)\n)\n)\n.properties(builder -> builder\n.add(PASSABLE)\n.add(INSTANT_BROKEN))\n.translation(TranslationProvider.of(LanternEnumTraits.TREE_TYPE, type ->\ntr(\"tile.sapling.\" + type.getTranslationKeyBase() + \".name\")))\n.build(\"minecraft\", \"sapling\"),\nblockState -> {\nfinal int type = blockState.getTraitValue(LanternEnumTraits.TREE_TYPE).get().getInternalId();\nfinal int stage = blockState.getTraitValue(LanternIntegerTraits.SAPLING_GROWTH_STAGE).get();\nreturn (byte) (stage << 3 | type);\n\n.build(\"minecraft\", \"cobblestone\"));\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\/\/\/ Planks \/\/\/\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\nregister(5, simpleBuilder()\n.trait(LanternEnumTraits.TREE_TYPE)\n.defaultState(state -> state.withTrait(LanternEnumTraits.TREE_TYPE, LanternTreeType.OAK).get())\n.itemType(builder -> builder\n.keysProvider(collection -> collection\n.register(Keys.TREE_TYPE, LanternTreeType.OAK)\n)\n)\n.properties(builder -> builder\n.add(hardness(2.0))\n.add(blastResistance(5.0))\n.add(flammableInfo(5, 20)))\n.translation(TranslationProvider.of(LanternEnumTraits.TREE_TYPE, type ->\ntr(\"tile.planks.\" + type.getTranslationKeyBase() + \".name\")))\n.build(\"minecraft\", \"planks\"),\nblockState -> (byte) blockState.getTraitValue(LanternEnumTraits.TREE_TYPE).get().getInternalId());\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\/\/\/ Sapling \/\/\/\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\nregister(6, simpleBuilder()\n.traits(LanternEnumTraits.TREE_TYPE, LanternIntegerTraits.SAPLING_GROWTH_STAGE)\n.defaultState(state -> state\n.withTrait(LanternEnumTraits.TREE_TYPE, LanternTreeType.OAK).get()\n.withTrait(LanternIntegerTraits.SAPLING_GROWTH_STAGE, 0).get())\n.itemType(builder -> builder\n.keysProvider(collection -> collection\n.register(Keys.TREE_TYPE, LanternTreeType.OAK)\n)\n)\n.properties(builder -> builder\n.add(PASSABLE)\n.add(INSTANT_BROKEN))\n.translation(TranslationProvider.of(LanternEnumTraits.TREE_TYPE, type ->\ntr(\"tile.sapling.\" + type.getTranslationKeyBase() + \".name\")))\n.build(\"minecraft\", \"sapling\"),\nblockState -> {\nfinal int type = blockState.getTraitValue(LanternEnumTraits.TREE_TYPE).get().getInternalId();\nfinal int stage = blockState.getTraitValue(LanternIntegerTraits.SAPLING_GROWTH_STAGE).get();\nreturn (byte) (stage << 3 | type);\n\n.build(\"minecraft\", \"cobblestone\"));\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\/\/\/ Planks \/\/\/\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\nregister(5, simpleBuilder()\n.trait(LanternEnumTraits.TREE_TYPE)\n.defaultState(state -> state.withTrait(LanternEnumTraits.TREE_TYPE, LanternTreeType.OAK).get())\n.itemType(builder -> builder\n.keysProvider(collection -> collection\n.register(Keys.TREE_TYPE, LanternTreeType.OAK)\n)\n)\n.properties(builder -> builder\n.add(hardness(2.0))\n.add(blastResistance(5.0))\n.add(flammableInfo(5, 20)))\n.translation(TranslationProvider.of(LanternEnumTraits.TREE_TYPE, type ->\ntr(\"tile.planks.\" + type.getTranslationKeyBase() + \".name\")))\n.build(\"minecraft\", \"planks\"),\nblockState -> (byte) blockState.getTraitValue(LanternEnumTraits.TREE_TYPE).get().getInternalId());\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\/\/\/ Sapling \/\/\/\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\nregister(6, simpleBuilder()\n.traits(LanternEnumTraits.TREE_TYPE, LanternIntegerTraits.SAPLING_GROWTH_STAGE)\n.defaultState(state -> state\n.withTrait(LanternEnumTraits.TREE_TYPE, LanternTreeType.OAK).get()\n.withTrait(LanternIntegerTraits.SAPLING_GROWTH_STAGE, 0).get())\n.itemType(builder -> builder\n.keysProvider(collection -> collection\n.register(Keys.TREE_TYPE, LanternTreeType.OAK)\n)\n)\n.properties(builder -> builder\n.add(PASSABLE)\n.add(INSTANT_BROKEN))\n.translation(TranslationProvider.of(LanternEnumTraits.TREE_TYPE, type ->\ntr(\"tile.sapling.\" + type.getTranslationKeyBase() + \".name\")))\n.build(\"minecraft\", \"sapling\"),\nblockState -> {\nfinal int type = blockState.getTraitValue(LanternEnumTraits.TREE_TYPE).get().getInternalId();\nfinal int stage = blockState.getTraitValue(LanternIntegerTraits.SAPLING_GROWTH_STAGE).get();\nreturn (byte) (stage << 3 | type);\n\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\nregister(22, simpleBuilder()\n.itemType()\n.properties(builder -> builder\n.add(hardness(3.0))\n.add(blastResistance(15.0)))\n.translation(\"tile.blockLapis.name\")\n.build(\"minecraft\", \"lapis_block\"));\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\/\/\/ Dispenser \/\/\/\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\nregister(23, simpleBuilder()\n.traits(LanternEnumTraits.FACING, LanternBooleanTraits.TRIGGERED)\n.defaultState(state -> state\n.withTrait(LanternEnumTraits.FACING, Direction.NORTH).get()\n.withTrait(LanternBooleanTraits.TRIGGERED, false).get())\n.itemType()\n.properties(builder -> builder\n.add(hardness(3.5))\n.add(blastResistance(17.5)))\n\/\/ .tileEntityType(() -> TileEntityTypes.DISPENSER)\n.translation(\"tile.dispenser.name\")\n.behaviors(pipeline -> pipeline\n.add(new RotationPlacementBehavior()))\n.build(\"minecraft\", \"dispenser\"),\nblockState -> {\nint data = directionData(blockState.getTraitValue(LanternEnumTraits.FACING).get());\nif (blockState.getTraitValue(LanternBooleanTraits.TRIGGERED).get()) {\ndata |= 0x8;\n}\nreturn (byte) data;\n});\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\/\/\/ Sandstone \/\/\/\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\nregister(24, simpleBuilder()\n.trait(LanternEnumTraits.SANDSTONE_TYPE)\n.defaultState(state -> state.withTrait(LanternEnumTraits.SANDSTONE_TYPE, LanternSandstoneType.DEFAULT).get())\n.itemType(builder -> builder\n.keysProvider(collection -> collection\n.register(Keys.SANDSTONE_TYPE, LanternSandstoneType.DEFAULT)\n\n.build(\"minecraft\", \"cobblestone\"));\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\/\/\/ Planks \/\/\/\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\nregister(5, simpleBuilder()\n.trait(LanternEnumTraits.TREE_TYPE)\n.defaultState(state -> state.withTrait(LanternEnumTraits.TREE_TYPE, LanternTreeType.OAK).get())\n.itemType(builder -> builder\n.keysProvider(collection -> collection\n.register(Keys.TREE_TYPE, LanternTreeType.OAK)\n)\n)\n.properties(builder -> builder\n.add(hardness(2.0))\n.add(blastResistance(5.0))\n.add(flammableInfo(5, 20)))\n.translation(TranslationProvider.of(LanternEnumTraits.TREE_TYPE, type ->\ntr(\"tile.planks.\" + type.getTranslationKeyBase() + \".name\")))\n.build(\"minecraft\", \"planks\"),\nblockState -> (byte) blockState.getTraitValue(LanternEnumTraits.TREE_TYPE).get().getInternalId());\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\/\/\/ Sapling \/\/\/\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\nregister(6, simpleBuilder()\n.traits(LanternEnumTraits.TREE_TYPE, LanternIntegerTraits.SAPLING_GROWTH_STAGE)\n.defaultState(state -> state\n.withTrait(LanternEnumTraits.TREE_TYPE, LanternTreeType.OAK).get()\n.withTrait(LanternIntegerTraits.SAPLING_GROWTH_STAGE, 0).get())\n.itemType(builder -> builder\n.keysProvider(collection -> collection\n.register(Keys.TREE_TYPE, LanternTreeType.OAK)\n)\n)\n.properties(builder -> builder\n.add(PASSABLE)\n.add(INSTANT_BROKEN))\n.translation(TranslationProvider.of(LanternEnumTraits.TREE_TYPE, type ->\ntr(\"tile.sapling.\" + type.getTranslationKeyBase() + \".name\")))\n.build(\"minecraft\", \"sapling\"),\nblockState -> {\nfinal int type = blockState.getTraitValue(LanternEnumTraits.TREE_TYPE).get().getInternalId();\nfinal int stage = blockState.getTraitValue(LanternIntegerTraits.SAPLING_GROWTH_STAGE).get();\nreturn (byte) (stage << 3 | type);\n\n.build(\"minecraft\", \"cobblestone\"));\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\/\/\/ Planks \/\/\/\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\nregister(5, simpleBuilder()\n.trait(LanternEnumTraits.TREE_TYPE)\n.defaultState(state -> state.withTrait(LanternEnumTraits.TREE_TYPE, LanternTreeType.OAK).get())\n.itemType(builder -> builder\n.keysProvider(collection -> collection\n.register(Keys.TREE_TYPE, LanternTreeType.OAK)\n)\n)\n.properties(builder -> builder\n.add(hardness(2.0))\n.add(blastResistance(5.0))\n.add(flammableInfo(5, 20)))\n.translation(TranslationProvider.of(LanternEnumTraits.TREE_TYPE, type ->\ntr(\"tile.planks.\" + type.getTranslationKeyBase() + \".name\")))\n.build(\"minecraft\", \"planks\"),\nblockState -> (byte) blockState.getTraitValue(LanternEnumTraits.TREE_TYPE).get().getInternalId());\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\/\/\/ Sapling \/\/\/\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\nregister(6, simpleBuilder()\n.traits(LanternEnumTraits.TREE_TYPE, LanternIntegerTraits.SAPLING_GROWTH_STAGE)\n.defaultState(state -> state\n.withTrait(LanternEnumTraits.TREE_TYPE, LanternTreeType.OAK).get()\n.withTrait(LanternIntegerTraits.SAPLING_GROWTH_STAGE, 0).get())\n.itemType(builder -> builder\n.keysProvider(collection -> collection\n.register(Keys.TREE_TYPE, LanternTreeType.OAK)\n)\n)\n.properties(builder -> builder\n.add(PASSABLE)\n.add(INSTANT_BROKEN))\n.translation(TranslationProvider.of(LanternEnumTraits.TREE_TYPE, type ->\ntr(\"tile.sapling.\" + type.getTranslationKeyBase() + \".name\")))\n.build(\"minecraft\", \"sapling\"),\nblockState -> {\nfinal int type = blockState.getTraitValue(LanternEnumTraits.TREE_TYPE).get().getInternalId();\nfinal int stage = blockState.getTraitValue(LanternIntegerTraits.SAPLING_GROWTH_STAGE).get();\nreturn (byte) (stage << 3 | type);\n\n.build(\"minecraft\", \"cobblestone\"));\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\/\/\/ Planks \/\/\/\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\nregister(5, simpleBuilder()\n.trait(LanternEnumTraits.TREE_TYPE)\n.defaultState(state -> state.withTrait(LanternEnumTraits.TREE_TYPE, LanternTreeType.OAK).get())\n.itemType(builder -> builder\n.keysProvider(collection -> collection\n.register(Keys.TREE_TYPE, LanternTreeType.OAK)\n)\n)\n.properties(builder -> builder\n.add(hardness(2.0))\n.add(blastResistance(5.0))\n.add(flammableInfo(5, 20)))\n.translation(TranslationProvider.of(LanternEnumTraits.TREE_TYPE, type ->\ntr(\"tile.planks.\" + type.getTranslationKeyBase() + \".name\")))\n.build(\"minecraft\", \"planks\"),\nblockState -> (byte) blockState.getTraitValue(LanternEnumTraits.TREE_TYPE).get().getInternalId());\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\/\/\/ Sapling \/\/\/\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\nregister(6, simpleBuilder()\n.traits(LanternEnumTraits.TREE_TYPE, LanternIntegerTraits.SAPLING_GROWTH_STAGE)\n.defaultState(state -> state\n.withTrait(LanternEnumTraits.TREE_TYPE, LanternTreeType.OAK).get()\n.withTrait(LanternIntegerTraits.SAPLING_GROWTH_STAGE, 0).get())\n.itemType(builder -> builder\n.keysProvider(collection -> collection\n.register(Keys.TREE_TYPE, LanternTreeType.OAK)\n)\n)\n.properties(builder -> builder\n.add(PASSABLE)\n.add(INSTANT_BROKEN))\n.translation(TranslationProvider.of(LanternEnumTraits.TREE_TYPE, type ->\ntr(\"tile.sapling.\" + type.getTranslationKeyBase() + \".name\")))\n.build(\"minecraft\", \"sapling\"),\nblockState -> {\nfinal int type = blockState.getTraitValue(LanternEnumTraits.TREE_TYPE).get().getInternalId();\nfinal int stage = blockState.getTraitValue(LanternIntegerTraits.SAPLING_GROWTH_STAGE).get();\nreturn (byte) (stage << 3 | type);\n\n.withTrait(LanternEnumTraits.BED_PART, LanternBedPart.FOOT).get()\n.withTrait(LanternBooleanTraits.OCCUPIED, false).get())\n.properties(builder -> builder\n.add(hardness(0.2))\n.add(blastResistance(1.0)))\n.translation(\"tile.bed.name\")\n.build(\"minecraft\", \"bed\"),\nblockState -> {\nfinal Direction facing = blockState.getTraitValue(LanternEnumTraits.HORIZONTAL_FACING).get();\nint type = facing == Direction.SOUTH ? 0 : facing == Direction.WEST ? 1 :\nfacing == Direction.NORTH ? 2 : facing == Direction.EAST ? 3 : -1;\ncheckArgument(type != -1);\nif (blockState.getTraitValue(LanternBooleanTraits.OCCUPIED).get()) {\ntype |= 0x4;\n}\nif (blockState.getTraitValue(LanternEnumTraits.BED_PART).get() == LanternBedPart.HEAD) {\ntype |= 0x8;\n}\nreturn (byte) type;\n});\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\/\/\/ Golden Rail \/\/\/\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\nregister(27, simpleBuilder()\n.traits(LanternEnumTraits.STRAIGHT_RAIL_DIRECTION, LanternBooleanTraits.POWERED)\n.defaultState(state -> state\n.withTrait(LanternEnumTraits.STRAIGHT_RAIL_DIRECTION, LanternRailDirection.NORTH_SOUTH).get()\n.withTrait(LanternBooleanTraits.POWERED, false).get())\n.itemType()\n.selectionBox(BoundingBoxes::rail)\n.properties(builder -> builder\n.add(PASSABLE)\n.add(hardness(0.7))\n.add(blastResistance(3.5)))\n.translation(\"tile.goldenRail.name\")\n.build(\"minecraft\", \"golden_rail\"),\nblockState -> {\nint type = blockState.getTraitValue(LanternEnumTraits.STRAIGHT_RAIL_DIRECTION).get().getInternalId();\nif (blockState.getTraitValue(LanternBooleanTraits.POWERED).get()) {\ntype |= 0x8;\n}\nreturn (byte) type;\n});\n\nregister(27, simpleBuilder()\n.traits(LanternEnumTraits.STRAIGHT_RAIL_DIRECTION, LanternBooleanTraits.POWERED)\n.defaultState(state -> state\n.withTrait(LanternEnumTraits.STRAIGHT_RAIL_DIRECTION, LanternRailDirection.NORTH_SOUTH).get()\n.withTrait(LanternBooleanTraits.POWERED, false).get())\n.itemType()\n.selectionBox(BoundingBoxes::rail)\n.properties(builder -> builder\n.add(PASSABLE)\n.add(hardness(0.7))\n.add(blastResistance(3.5)))\n.translation(\"tile.goldenRail.name\")\n.build(\"minecraft\", \"golden_rail\"),\nblockState -> {\nint type = blockState.getTraitValue(LanternEnumTraits.STRAIGHT_RAIL_DIRECTION).get().getInternalId();\nif (blockState.getTraitValue(LanternBooleanTraits.POWERED).get()) {\ntype |= 0x8;\n}\nreturn (byte) type;\n});\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\/\/\/ Detector Rail \/\/\/\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\nregister(28, simpleBuilder()\n.traits(LanternEnumTraits.STRAIGHT_RAIL_DIRECTION, LanternBooleanTraits.POWERED)\n.defaultState(state -> state\n.withTrait(LanternEnumTraits.STRAIGHT_RAIL_DIRECTION, LanternRailDirection.NORTH_SOUTH).get()\n.withTrait(LanternBooleanTraits.POWERED, false).get())\n.itemType()\n.selectionBox(BoundingBoxes::rail)\n.properties(builder -> builder\n.add(PASSABLE)\n.add(hardness(0.7))\n.add(blastResistance(3.5)))\n.translation(\"tile.detectorRail.name\")\n.build(\"minecraft\", \"detector_rail\"),\nblockState -> {\nint type = blockState.getTraitValue(LanternEnumTraits.STRAIGHT_RAIL_DIRECTION).get().getInternalId();\nif (blockState.getTraitValue(LanternBooleanTraits.POWERED).get()) {\ntype |= 0x8;\n}\nreturn (byte) type;\n});\n\nregister(28, simpleBuilder()\n.traits(LanternEnumTraits.STRAIGHT_RAIL_DIRECTION, LanternBooleanTraits.POWERED)\n.defaultState(state -> state\n.withTrait(LanternEnumTraits.STRAIGHT_RAIL_DIRECTION, LanternRailDirection.NORTH_SOUTH).get()\n.withTrait(LanternBooleanTraits.POWERED, false).get())\n.itemType()\n.selectionBox(BoundingBoxes::rail)\n.properties(builder -> builder\n.add(PASSABLE)\n.add(hardness(0.7))\n.add(blastResistance(3.5)))\n.translation(\"tile.detectorRail.name\")\n.build(\"minecraft\", \"detector_rail\"),\nblockState -> {\nint type = blockState.getTraitValue(LanternEnumTraits.STRAIGHT_RAIL_DIRECTION).get().getInternalId();\nif (blockState.getTraitValue(LanternBooleanTraits.POWERED).get()) {\ntype |= 0x8;\n}\nreturn (byte) type;\n});\n\/\/ TODO: 29\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\/\/\/ Web \/\/\/\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\nregister(30, simpleBuilder()\n.itemType()\n.properties(builder -> builder\n.add(PASSABLE)\n.add(hardness(4.0))\n.add(blastResistance(20.0)))\n.translation(\"tile.web.name\")\n.build(\"minecraft\", \"web\"));\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\/\/\/ Tall Grass \/\/\/\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\nregister(31, simpleBuilder()\n.traits(LanternEnumTraits.SHRUB_TYPE)\n.defaultState(state -> state\n.withTrait(LanternEnumTraits.SHRUB_TYPE, LanternShrubType.DEAD_BUSH).get())\n.itemType(builder -> builder\n.keysProvider(collection -> collection\n.register(Keys.SHRUB_TYPE, LanternShrubType.DEAD_BUSH)))\n.selectionBox(BoundingBoxes.bush())\n.properties(builder -> builder\n\n.withTrait(LanternEnumTraits.BED_PART, LanternBedPart.FOOT).get()\n.withTrait(LanternBooleanTraits.OCCUPIED, false).get())\n.properties(builder -> builder\n.add(hardness(0.2))\n.add(blastResistance(1.0)))\n.translation(\"tile.bed.name\")\n.build(\"minecraft\", \"bed\"),\nblockState -> {\nfinal Direction facing = blockState.getTraitValue(LanternEnumTraits.HORIZONTAL_FACING).get();\nint type = facing == Direction.SOUTH ? 0 : facing == Direction.WEST ? 1 :\nfacing == Direction.NORTH ? 2 : facing == Direction.EAST ? 3 : -1;\ncheckArgument(type != -1);\nif (blockState.getTraitValue(LanternBooleanTraits.OCCUPIED).get()) {\ntype |= 0x4;\n}\nif (blockState.getTraitValue(LanternEnumTraits.BED_PART).get() == LanternBedPart.HEAD) {\ntype |= 0x8;\n}\nreturn (byte) type;\n});\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\/\/\/ Golden Rail \/\/\/\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\nregister(27, simpleBuilder()\n.traits(LanternEnumTraits.STRAIGHT_RAIL_DIRECTION, LanternBooleanTraits.POWERED)\n.defaultState(state -> state\n.withTrait(LanternEnumTraits.STRAIGHT_RAIL_DIRECTION, LanternRailDirection.NORTH_SOUTH).get()\n.withTrait(LanternBooleanTraits.POWERED, false).get())\n.itemType()\n.selectionBox(BoundingBoxes::rail)\n.properties(builder -> builder\n.add(PASSABLE)\n.add(hardness(0.7))\n.add(blastResistance(3.5)))\n.translation(\"tile.goldenRail.name\")\n.build(\"minecraft\", \"golden_rail\"),\nblockState -> {\nint type = blockState.getTraitValue(LanternEnumTraits.STRAIGHT_RAIL_DIRECTION).get().getInternalId();\nif (blockState.getTraitValue(LanternBooleanTraits.POWERED).get()) {\ntype |= 0x8;\n}\nreturn (byte) type;\n});\n\n.withTrait(LanternEnumTraits.BED_PART, LanternBedPart.FOOT).get()\n.withTrait(LanternBooleanTraits.OCCUPIED, false).get())\n.properties(builder -> builder\n.add(hardness(0.2))\n.add(blastResistance(1.0)))\n.translation(\"tile.bed.name\")\n.build(\"minecraft\", \"bed\"),\nblockState -> {\nfinal Direction facing = blockState.getTraitValue(LanternEnumTraits.HORIZONTAL_FACING).get();\nint type = facing == Direction.SOUTH ? 0 : facing == Direction.WEST ? 1 :\nfacing == Direction.NORTH ? 2 : facing == Direction.EAST ? 3 : -1;\ncheckArgument(type != -1);\nif (blockState.getTraitValue(LanternBooleanTraits.OCCUPIED).get()) {\ntype |= 0x4;\n}\nif (blockState.getTraitValue(LanternEnumTraits.BED_PART).get() == LanternBedPart.HEAD) {\ntype |= 0x8;\n}\nreturn (byte) type;\n});\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\/\/\/ Golden Rail \/\/\/\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\nregister(27, simpleBuilder()\n.traits(LanternEnumTraits.STRAIGHT_RAIL_DIRECTION, LanternBooleanTraits.POWERED)\n.defaultState(state -> state\n.withTrait(LanternEnumTraits.STRAIGHT_RAIL_DIRECTION, LanternRailDirection.NORTH_SOUTH).get()\n.withTrait(LanternBooleanTraits.POWERED, false).get())\n.itemType()\n.selectionBox(BoundingBoxes::rail)\n.properties(builder -> builder\n.add(PASSABLE)\n.add(hardness(0.7))\n.add(blastResistance(3.5)))\n.translation(\"tile.goldenRail.name\")\n.build(\"minecraft\", \"golden_rail\"),\nblockState -> {\nint type = blockState.getTraitValue(LanternEnumTraits.STRAIGHT_RAIL_DIRECTION).get().getInternalId();\nif (blockState.getTraitValue(LanternBooleanTraits.POWERED).get()) {\ntype |= 0x8;\n}\nreturn (byte) type;\n});\n\n.selectionBox(BoundingBoxes.bush())\n.properties(builder -> builder\n.add(INSTANT_BROKEN)\n.add(PASSABLE)\n.add(replaceable(true)))\n.translation(\"tile.tallgrass.name\")\n.build(\"minecraft\", \"tallgrass\"),\nblockState -> (byte) blockState.getTraitValue(LanternEnumTraits.SHRUB_TYPE).get().getInternalId());\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\/\/\/ Dead Bush \/\/\/\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\nregister(32, simpleBuilder()\n.properties(builder -> builder\n.add(INSTANT_BROKEN)\n.add(PASSABLE)\n.add(replaceable(true)))\n.selectionBox(BoundingBoxes.bush())\n.itemType()\n.translation(\"tile.deadbush.name\")\n.build(\"minecraft\", \"deadbush\"));\n\/\/ TODO: 33\n\/\/ TODO: 34\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\/\/\/ Wool \/\/\/\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\nregister(35, dyedBuilder(\"tile.wool.%s.name\")\n.properties(builder -> builder\n.add(hardness(0.8))\n.add(blastResistance(4.0)))\n.build(\"minecraft\", \"wool\"),\nthis::dyedData);\n\/\/ TODO: 36\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\/\/\/ Yellow Flower \/\/\/\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\nregister(37, simpleBuilder()\n.traits(LanternEnumTraits.YELLOW_FLOWER_TYPE)\n.defaultState(state -> state\n.withTrait(LanternEnumTraits.YELLOW_FLOWER_TYPE, LanternPlantType.DANDELION).get())\n.itemType(builder -> builder\n.keysProvider(collection -> collection\n.register(Keys.PLANT_TYPE, LanternPlantType.DANDELION)))\n.selectionBox(BoundingBoxes.bush())\n.properties(builder -> builder\n.add(INSTANT_BROKEN)\n\nregister(32, simpleBuilder()\n.properties(builder -> builder\n.add(INSTANT_BROKEN)\n.add(PASSABLE)\n.add(replaceable(true)))\n.selectionBox(BoundingBoxes.bush())\n.itemType()\n.translation(\"tile.deadbush.name\")\n.build(\"minecraft\", \"deadbush\"));\n\/\/ TODO: 33\n\/\/ TODO: 34\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\/\/\/ Wool \/\/\/\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\nregister(35, dyedBuilder(\"tile.wool.%s.name\")\n.properties(builder -> builder\n.add(hardness(0.8))\n.add(blastResistance(4.0)))\n.build(\"minecraft\", \"wool\"),\nthis::dyedData);\n\/\/ TODO: 36\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\/\/\/ Yellow Flower \/\/\/\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\nregister(37, simpleBuilder()\n.traits(LanternEnumTraits.YELLOW_FLOWER_TYPE)\n.defaultState(state -> state\n.withTrait(LanternEnumTraits.YELLOW_FLOWER_TYPE, LanternPlantType.DANDELION).get())\n.itemType(builder -> builder\n.keysProvider(collection -> collection\n.register(Keys.PLANT_TYPE, LanternPlantType.DANDELION)))\n.selectionBox(BoundingBoxes.bush())\n.properties(builder -> builder\n.add(INSTANT_BROKEN)\n.add(PASSABLE))\n.translation(TranslationProvider.of(LanternEnumTraits.YELLOW_FLOWER_TYPE))\n.build(\"minecraft\", \"yellow_flower\"),\nblockState -> (byte) blockState.getTraitValue(LanternEnumTraits.YELLOW_FLOWER_TYPE).get().getInternalId());\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\/\/\/ Red Flower \/\/\/\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\nregister(38, simpleBuilder()\n.traits(LanternEnumTraits.RED_FLOWER_TYPE)\n.defaultState(state -> state\n\n.withTrait(LanternEnumTraits.BED_PART, LanternBedPart.FOOT).get()\n.withTrait(LanternBooleanTraits.OCCUPIED, false).get())\n.properties(builder -> builder\n.add(hardness(0.2))\n.add(blastResistance(1.0)))\n.translation(\"tile.bed.name\")\n.build(\"minecraft\", \"bed\"),\nblockState -> {\nfinal Direction facing = blockState.getTraitValue(LanternEnumTraits.HORIZONTAL_FACING).get();\nint type = facing == Direction.SOUTH ? 0 : facing == Direction.WEST ? 1 :\nfacing == Direction.NORTH ? 2 : facing == Direction.EAST ? 3 : -1;\ncheckArgument(type != -1);\nif (blockState.getTraitValue(LanternBooleanTraits.OCCUPIED).get()) {\ntype |= 0x4;\n}\nif (blockState.getTraitValue(LanternEnumTraits.BED_PART).get() == LanternBedPart.HEAD) {\ntype |= 0x8;\n}\nreturn (byte) type;\n});\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\/\/\/ Golden Rail \/\/\/\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\nregister(27, simpleBuilder()\n.traits(LanternEnumTraits.STRAIGHT_RAIL_DIRECTION, LanternBooleanTraits.POWERED)\n.defaultState(state -> state\n.withTrait(LanternEnumTraits.STRAIGHT_RAIL_DIRECTION, LanternRailDirection.NORTH_SOUTH).get()\n.withTrait(LanternBooleanTraits.POWERED, false).get())\n.itemType()\n.selectionBox(BoundingBoxes::rail)\n.properties(builder -> builder\n.add(PASSABLE)\n.add(hardness(0.7))\n.add(blastResistance(3.5)))\n.translation(\"tile.goldenRail.name\")\n.build(\"minecraft\", \"golden_rail\"),\nblockState -> {\nint type = blockState.getTraitValue(LanternEnumTraits.STRAIGHT_RAIL_DIRECTION).get().getInternalId();\nif (blockState.getTraitValue(LanternBooleanTraits.POWERED).get()) {\ntype |= 0x8;\n}\nreturn (byte) type;\n});\n\n.translation(TranslationProvider.of(LanternEnumTraits.YELLOW_FLOWER_TYPE))\n.build(\"minecraft\", \"yellow_flower\"),\nblockState -> (byte) blockState.getTraitValue(LanternEnumTraits.YELLOW_FLOWER_TYPE).get().getInternalId());\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\/\/\/ Red Flower \/\/\/\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\nregister(38, simpleBuilder()\n.traits(LanternEnumTraits.RED_FLOWER_TYPE)\n.defaultState(state -> state\n.withTrait(LanternEnumTraits.RED_FLOWER_TYPE, LanternPlantType.POPPY).get())\n.itemType(builder -> builder\n.keysProvider(collection -> collection\n.register(Keys.PLANT_TYPE, LanternPlantType.POPPY)))\n.selectionBox(BoundingBoxes.bush())\n.properties(builder -> builder\n.add(INSTANT_BROKEN)\n.add(PASSABLE))\n.translation(TranslationProvider.of(LanternEnumTraits.RED_FLOWER_TYPE))\n.build(\"minecraft\", \"red_flower\"),\nblockState -> (byte) blockState.getTraitValue(LanternEnumTraits.RED_FLOWER_TYPE).get().getInternalId());\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\/\/\/ Brown Mushroom \/\/\/\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\nregister(39, simpleBuilder()\n.selectionBox(BoundingBoxes.bush())\n.properties(builder -> builder\n.add(INSTANT_BROKEN)\n.add(PASSABLE)\n.add(lightEmission(1)))\n.translation(\"tile.mushroom.name\")\n.build(\"minecraft\", \"brown_mushroom\"));\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\/\/\/ Red Mushroom \/\/\/\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\nregister(40, simpleBuilder()\n.selectionBox(BoundingBoxes.bush())\n.properties(builder -> builder\n.add(INSTANT_BROKEN)\n.add(PASSABLE))\n.translation(\"tile.mushroom.name\")\n.build(\"minecraft\", \"red_mushroom\"));\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\/\/\/ Gold Block \/\/\/\n\nregister(27, simpleBuilder()\n.traits(LanternEnumTraits.STRAIGHT_RAIL_DIRECTION, LanternBooleanTraits.POWERED)\n.defaultState(state -> state\n.withTrait(LanternEnumTraits.STRAIGHT_RAIL_DIRECTION, LanternRailDirection.NORTH_SOUTH).get()\n.withTrait(LanternBooleanTraits.POWERED, false).get())\n.itemType()\n.selectionBox(BoundingBoxes::rail)\n.properties(builder -> builder\n.add(PASSABLE)\n.add(hardness(0.7))\n.add(blastResistance(3.5)))\n.translation(\"tile.goldenRail.name\")\n.build(\"minecraft\", \"golden_rail\"),\nblockState -> {\nint type = blockState.getTraitValue(LanternEnumTraits.STRAIGHT_RAIL_DIRECTION).get().getInternalId();\nif (blockState.getTraitValue(LanternBooleanTraits.POWERED).get()) {\ntype |= 0x8;\n}\nreturn (byte) type;\n});\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\/\/\/ Detector Rail \/\/\/\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\nregister(28, simpleBuilder()\n.traits(LanternEnumTraits.STRAIGHT_RAIL_DIRECTION, LanternBooleanTraits.POWERED)\n.defaultState(state -> state\n.withTrait(LanternEnumTraits.STRAIGHT_RAIL_DIRECTION, LanternRailDirection.NORTH_SOUTH).get()\n.withTrait(LanternBooleanTraits.POWERED, false).get())\n.itemType()\n.selectionBox(BoundingBoxes::rail)\n.properties(builder -> builder\n.add(PASSABLE)\n.add(hardness(0.7))\n.add(blastResistance(3.5)))\n.translation(\"tile.detectorRail.name\")\n.build(\"minecraft\", \"detector_rail\"),\nblockState -> {\nint type = blockState.getTraitValue(LanternEnumTraits.STRAIGHT_RAIL_DIRECTION).get().getInternalId();\nif (blockState.getTraitValue(LanternBooleanTraits.POWERED).get()) {\ntype |= 0x8;\n}\nreturn (byte) type;\n});\n\n.withTrait(LanternEnumTraits.BED_PART, LanternBedPart.FOOT).get()\n.withTrait(LanternBooleanTraits.OCCUPIED, false).get())\n.properties(builder -> builder\n.add(hardness(0.2))\n.add(blastResistance(1.0)))\n.translation(\"tile.bed.name\")\n.build(\"minecraft\", \"bed\"),\nblockState -> {\nfinal Direction facing = blockState.getTraitValue(LanternEnumTraits.HORIZONTAL_FACING).get();\nint type = facing == Direction.SOUTH ? 0 : facing == Direction.WEST ? 1 :\nfacing == Direction.NORTH ? 2 : facing == Direction.EAST ? 3 : -1;\ncheckArgument(type != -1);\nif (blockState.getTraitValue(LanternBooleanTraits.OCCUPIED).get()) {\ntype |= 0x4;\n}\nif (blockState.getTraitValue(LanternEnumTraits.BED_PART).get() == LanternBedPart.HEAD) {\ntype |= 0x8;\n}\nreturn (byte) type;\n});\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\/\/\/ Golden Rail \/\/\/\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\nregister(27, simpleBuilder()\n.traits(LanternEnumTraits.STRAIGHT_RAIL_DIRECTION, LanternBooleanTraits.POWERED)\n.defaultState(state -> state\n.withTrait(LanternEnumTraits.STRAIGHT_RAIL_DIRECTION, LanternRailDirection.NORTH_SOUTH).get()\n.withTrait(LanternBooleanTraits.POWERED, false).get())\n.itemType()\n.selectionBox(BoundingBoxes::rail)\n.properties(builder -> builder\n.add(PASSABLE)\n.add(hardness(0.7))\n.add(blastResistance(3.5)))\n.translation(\"tile.goldenRail.name\")\n.build(\"minecraft\", \"golden_rail\"),\nblockState -> {\nint type = blockState.getTraitValue(LanternEnumTraits.STRAIGHT_RAIL_DIRECTION).get().getInternalId();\nif (blockState.getTraitValue(LanternBooleanTraits.POWERED).get()) {\ntype |= 0x8;\n}\nreturn (byte) type;\n});\n\n.withTrait(LanternEnumTraits.BED_PART, LanternBedPart.FOOT).get()\n.withTrait(LanternBooleanTraits.OCCUPIED, false).get())\n.properties(builder -> builder\n.add(hardness(0.2))\n.add(blastResistance(1.0)))\n.translation(\"tile.bed.name\")\n.build(\"minecraft\", \"bed\"),\nblockState -> {\nfinal Direction facing = blockState.getTraitValue(LanternEnumTraits.HORIZONTAL_FACING).get();\nint type = facing == Direction.SOUTH ? 0 : facing == Direction.WEST ? 1 :\nfacing == Direction.NORTH ? 2 : facing == Direction.EAST ? 3 : -1;\ncheckArgument(type != -1);\nif (blockState.getTraitValue(LanternBooleanTraits.OCCUPIED).get()) {\ntype |= 0x4;\n}\nif (blockState.getTraitValue(LanternEnumTraits.BED_PART).get() == LanternBedPart.HEAD) {\ntype |= 0x8;\n}\nreturn (byte) type;\n});\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\/\/\/ Golden Rail \/\/\/\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\nregister(27, simpleBuilder()\n.traits(LanternEnumTraits.STRAIGHT_RAIL_DIRECTION, LanternBooleanTraits.POWERED)\n.defaultState(state -> state\n.withTrait(LanternEnumTraits.STRAIGHT_RAIL_DIRECTION, LanternRailDirection.NORTH_SOUTH).get()\n.withTrait(LanternBooleanTraits.POWERED, false).get())\n.itemType()\n.selectionBox(BoundingBoxes::rail)\n.properties(builder -> builder\n.add(PASSABLE)\n.add(hardness(0.7))\n.add(blastResistance(3.5)))\n.translation(\"tile.goldenRail.name\")\n.build(\"minecraft\", \"golden_rail\"),\nblockState -> {\nint type = blockState.getTraitValue(LanternEnumTraits.STRAIGHT_RAIL_DIRECTION).get().getInternalId();\nif (blockState.getTraitValue(LanternBooleanTraits.POWERED).get()) {\ntype |= 0x8;\n}\nreturn (byte) type;\n});\n\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\/\/\/ Gold Block \/\/\/\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\nregister(41, simpleBuilder()\n.itemType()\n.properties(builder -> builder\n.add(hardness(3.0))\n.add(blastResistance(10.0)))\n.translation(\"tile.blockGold.name\")\n.build(\"minecraft\", \"gold_block\"));\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\/\/\/ Iron Block \/\/\/\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\nregister(42, simpleBuilder()\n.itemType()\n.properties(builder -> builder\n.add(hardness(5.0))\n.add(blastResistance(10.0)))\n.translation(\"tile.blockIron.name\")\n.build(\"minecraft\", \"iron_block\"));\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\/\/\/ Double Stone Slab 1 \/\/\/\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\nregister(43, doubleStoneSlab(LanternEnumTraits.STONE_SLAB1_TYPE, LanternSlabType.STONE)\n.translation(\"tile.stoneSlab.name\")\n.build(\"minecraft\", \"double_stone_slab\"),\nblockState -> doubleStoneSlabData(blockState, blockState.getTraitValue(LanternEnumTraits.STONE_SLAB1_TYPE).get().getInternalId()));\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\/\/\/ Stone Slab 1 \/\/\/\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\nregister(44, stoneSlab(LanternEnumTraits.STONE_SLAB1_TYPE, LanternSlabType.STONE,\n() -> BlockTypes.STONE_SLAB,\n() -> BlockTypes.DOUBLE_STONE_SLAB)\n.translation(\"tile.stoneSlab.name\")\n.collisionBox(BoundingBoxes::slab)\n.build(\"minecraft\", \"stone_slab\"),\nblockState -> stoneSlabData(blockState, blockState.getTraitValue(LanternEnumTraits.STONE_SLAB1_TYPE).get().getInternalId()));\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\/\/\/ Brick Block \/\/\/\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\nregister(45, simpleBuilder()\n.itemType()\n.properties(builder -> builder\n\nregister(27, simpleBuilder()\n.traits(LanternEnumTraits.STRAIGHT_RAIL_DIRECTION, LanternBooleanTraits.POWERED)\n.defaultState(state -> state\n.withTrait(LanternEnumTraits.STRAIGHT_RAIL_DIRECTION, LanternRailDirection.NORTH_SOUTH).get()\n.withTrait(LanternBooleanTraits.POWERED, false).get())\n.itemType()\n.selectionBox(BoundingBoxes::rail)\n.properties(builder -> builder\n.add(PASSABLE)\n.add(hardness(0.7))\n.add(blastResistance(3.5)))\n.translation(\"tile.goldenRail.name\")\n.build(\"minecraft\", \"golden_rail\"),\nblockState -> {\nint type = blockState.getTraitValue(LanternEnumTraits.STRAIGHT_RAIL_DIRECTION).get().getInternalId();\nif (blockState.getTraitValue(LanternBooleanTraits.POWERED).get()) {\ntype |= 0x8;\n}\nreturn (byte) type;\n});\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\/\/\/ Detector Rail \/\/\/\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\nregister(28, simpleBuilder()\n.traits(LanternEnumTraits.STRAIGHT_RAIL_DIRECTION, LanternBooleanTraits.POWERED)\n.defaultState(state -> state\n.withTrait(LanternEnumTraits.STRAIGHT_RAIL_DIRECTION, LanternRailDirection.NORTH_SOUTH).get()\n.withTrait(LanternBooleanTraits.POWERED, false).get())\n.itemType()\n.selectionBox(BoundingBoxes::rail)\n.properties(builder -> builder\n.add(PASSABLE)\n.add(hardness(0.7))\n.add(blastResistance(3.5)))\n.translation(\"tile.detectorRail.name\")\n.build(\"minecraft\", \"detector_rail\"),\nblockState -> {\nint type = blockState.getTraitValue(LanternEnumTraits.STRAIGHT_RAIL_DIRECTION).get().getInternalId();\nif (blockState.getTraitValue(LanternBooleanTraits.POWERED).get()) {\ntype |= 0x8;\n}\nreturn (byte) type;\n});\n\nregister(27, simpleBuilder()\n.traits(LanternEnumTraits.STRAIGHT_RAIL_DIRECTION, LanternBooleanTraits.POWERED)\n.defaultState(state -> state\n.withTrait(LanternEnumTraits.STRAIGHT_RAIL_DIRECTION, LanternRailDirection.NORTH_SOUTH).get()\n.withTrait(LanternBooleanTraits.POWERED, false).get())\n.itemType()\n.selectionBox(BoundingBoxes::rail)\n.properties(builder -> builder\n.add(PASSABLE)\n.add(hardness(0.7))\n.add(blastResistance(3.5)))\n.translation(\"tile.goldenRail.name\")\n.build(\"minecraft\", \"golden_rail\"),\nblockState -> {\nint type = blockState.getTraitValue(LanternEnumTraits.STRAIGHT_RAIL_DIRECTION).get().getInternalId();\nif (blockState.getTraitValue(LanternBooleanTraits.POWERED).get()) {\ntype |= 0x8;\n}\nreturn (byte) type;\n});\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\/\/\/ Detector Rail \/\/\/\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\nregister(28, simpleBuilder()\n.traits(LanternEnumTraits.STRAIGHT_RAIL_DIRECTION, LanternBooleanTraits.POWERED)\n.defaultState(state -> state\n.withTrait(LanternEnumTraits.STRAIGHT_RAIL_DIRECTION, LanternRailDirection.NORTH_SOUTH).get()\n.withTrait(LanternBooleanTraits.POWERED, false).get())\n.itemType()\n.selectionBox(BoundingBoxes::rail)\n.properties(builder -> builder\n.add(PASSABLE)\n.add(hardness(0.7))\n.add(blastResistance(3.5)))\n.translation(\"tile.detectorRail.name\")\n.build(\"minecraft\", \"detector_rail\"),\nblockState -> {\nint type = blockState.getTraitValue(LanternEnumTraits.STRAIGHT_RAIL_DIRECTION).get().getInternalId();\nif (blockState.getTraitValue(LanternBooleanTraits.POWERED).get()) {\ntype |= 0x8;\n}\nreturn (byte) type;\n});\n\n@Override\npublic void registerDefaults() {\n\/\/ @formatter:off\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\/\/\/ Air \/\/\/\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\nregister(0, builder()\n.properties(PropertyProviderCollections.DEFAULT_GAS)\n.translation(\"tile.air.name\")\n.build(\"minecraft\", \"air\"));\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\/\/\/ Stone \/\/\/\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\nregister(1, simpleBuilder()\n.trait(LanternEnumTraits.STONE_TYPE)\n.defaultState(state -> state.withTrait(LanternEnumTraits.STONE_TYPE, LanternStoneType.STONE).get())\n.itemType(builder -> builder\n.keysProvider(collection -> collection\n.register(Keys.STONE_TYPE, LanternStoneType.STONE)\n)\n)\n.properties(builder -> builder\n.add(hardness(1.5))\n.add(blastResistance(30.0)))\n.translation(TranslationProvider.of(LanternEnumTraits.STONE_TYPE))\n.build(\"minecraft\", \"stone\"),\n\n.withTrait(LanternEnumTraits.BED_PART, LanternBedPart.FOOT).get()\n.withTrait(LanternBooleanTraits.OCCUPIED, false).get())\n.properties(builder -> builder\n.add(hardness(0.2))\n.add(blastResistance(1.0)))\n.translation(\"tile.bed.name\")\n.build(\"minecraft\", \"bed\"),\nblockState -> {\nfinal Direction facing = blockState.getTraitValue(LanternEnumTraits.HORIZONTAL_FACING).get();\nint type = facing == Direction.SOUTH ? 0 : facing == Direction.WEST ? 1 :\nfacing == Direction.NORTH ? 2 : facing == Direction.EAST ? 3 : -1;\ncheckArgument(type != -1);\nif (blockState.getTraitValue(LanternBooleanTraits.OCCUPIED).get()) {\ntype |= 0x4;\n}\nif (blockState.getTraitValue(LanternEnumTraits.BED_PART).get() == LanternBedPart.HEAD) {\ntype |= 0x8;\n}\nreturn (byte) type;\n});\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\/\/\/ Golden Rail \/\/\/\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\nregister(27, simpleBuilder()\n.traits(LanternEnumTraits.STRAIGHT_RAIL_DIRECTION, LanternBooleanTraits.POWERED)\n.defaultState(state -> state\n.withTrait(LanternEnumTraits.STRAIGHT_RAIL_DIRECTION, LanternRailDirection.NORTH_SOUTH).get()\n.withTrait(LanternBooleanTraits.POWERED, false).get())\n.itemType()\n.selectionBox(BoundingBoxes::rail)\n.properties(builder -> builder\n.add(PASSABLE)\n.add(hardness(0.7))\n.add(blastResistance(3.5)))\n.translation(\"tile.goldenRail.name\")\n.build(\"minecraft\", \"golden_rail\"),\nblockState -> {\nint type = blockState.getTraitValue(LanternEnumTraits.STRAIGHT_RAIL_DIRECTION).get().getInternalId();\nif (blockState.getTraitValue(LanternBooleanTraits.POWERED).get()) {\ntype |= 0x8;\n}\nreturn (byte) type;\n});\n\nregister(46, simpleBuilder()\n.trait(LanternBooleanTraits.EXPLODE)\n.defaultState(state -> state\n.withTrait(LanternBooleanTraits.EXPLODE, false).get())\n.itemType()\n.properties(builder -> builder\n.add(INSTANT_BROKEN))\n.translation(\"tile.tnt.name\")\n.build(\"minecraft\", \"tnt\"),\nblockState -> (byte) (blockState.getTraitValue(LanternBooleanTraits.EXPLODE).get() ? 1 : 0));\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\/\/\/ Bookshelf \/\/\/\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\nregister(47, simpleBuilder()\n.itemType()\n.properties(builder -> builder\n.add(hardness(1.5))\n.add(blastResistance(7.5)))\n.translation(\"tile.bookshelf.name\")\n.build(\"minecraft\", \"bookshelf\"));\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\/\/\/ Mossy Cobblestone \/\/\/\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\nregister(48, simpleBuilder()\n.itemType()\n.properties(builder -> builder\n.add(hardness(2.0))\n.add(blastResistance(10.0)))\n.translation(\"tile.stoneMoss.name\")\n.build(\"minecraft\", \"mossy_cobblestone\"));\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\/\/\/ Obsidian \/\/\/\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\nregister(49, simpleBuilder()\n.itemType()\n.properties(builder -> builder\n.add(hardness(50.0))\n.add(blastResistance(2000.0)))\n.translation(\"tile.obsidian.name\")\n.build(\"minecraft\", \"obsidian\"));\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\/\/\/ Torch \/\/\/\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\n.build(\"minecraft\", \"cobblestone\"));\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\/\/\/ Planks \/\/\/\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\nregister(5, simpleBuilder()\n.trait(LanternEnumTraits.TREE_TYPE)\n.defaultState(state -> state.withTrait(LanternEnumTraits.TREE_TYPE, LanternTreeType.OAK).get())\n.itemType(builder -> builder\n.keysProvider(collection -> collection\n.register(Keys.TREE_TYPE, LanternTreeType.OAK)\n)\n)\n.properties(builder -> builder\n.add(hardness(2.0))\n.add(blastResistance(5.0))\n.add(flammableInfo(5, 20)))\n.translation(TranslationProvider.of(LanternEnumTraits.TREE_TYPE, type ->\ntr(\"tile.planks.\" + type.getTranslationKeyBase() + \".name\")))\n.build(\"minecraft\", \"planks\"),\nblockState -> (byte) blockState.getTraitValue(LanternEnumTraits.TREE_TYPE).get().getInternalId());\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\/\/\/ Sapling \/\/\/\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\nregister(6, simpleBuilder()\n.traits(LanternEnumTraits.TREE_TYPE, LanternIntegerTraits.SAPLING_GROWTH_STAGE)\n.defaultState(state -> state\n.withTrait(LanternEnumTraits.TREE_TYPE, LanternTreeType.OAK).get()\n.withTrait(LanternIntegerTraits.SAPLING_GROWTH_STAGE, 0).get())\n.itemType(builder -> builder\n.keysProvider(collection -> collection\n.register(Keys.TREE_TYPE, LanternTreeType.OAK)\n)\n)\n.properties(builder -> builder\n.add(PASSABLE)\n.add(INSTANT_BROKEN))\n.translation(TranslationProvider.of(LanternEnumTraits.TREE_TYPE, type ->\ntr(\"tile.sapling.\" + type.getTranslationKeyBase() + \".name\")))\n.build(\"minecraft\", \"sapling\"),\nblockState -> {\nfinal int type = blockState.getTraitValue(LanternEnumTraits.TREE_TYPE).get().getInternalId();\nfinal int stage = blockState.getTraitValue(LanternIntegerTraits.SAPLING_GROWTH_STAGE).get();\nreturn (byte) (stage << 3 | type);\n\n@Override\npublic void registerDefaults() {\n\/\/ @formatter:off\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\/\/\/ Air \/\/\/\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\nregister(0, builder()\n.properties(PropertyProviderCollections.DEFAULT_GAS)\n.translation(\"tile.air.name\")\n.build(\"minecraft\", \"air\"));\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\/\/\/ Stone \/\/\/\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\nregister(1, simpleBuilder()\n.trait(LanternEnumTraits.STONE_TYPE)\n.defaultState(state -> state.withTrait(LanternEnumTraits.STONE_TYPE, LanternStoneType.STONE).get())\n.itemType(builder -> builder\n.keysProvider(collection -> collection\n.register(Keys.STONE_TYPE, LanternStoneType.STONE)\n)\n)\n.properties(builder -> builder\n.add(hardness(1.5))\n.add(blastResistance(30.0)))\n.translation(TranslationProvider.of(LanternEnumTraits.STONE_TYPE))\n.build(\"minecraft\", \"stone\"),\n\n@Override\npublic void registerDefaults() {\n\/\/ @formatter:off\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\/\/\/ Air \/\/\/\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\nregister(0, builder()\n.properties(PropertyProviderCollections.DEFAULT_GAS)\n.translation(\"tile.air.name\")\n.build(\"minecraft\", \"air\"));\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\/\/\/ Stone \/\/\/\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\nregister(1, simpleBuilder()\n.trait(LanternEnumTraits.STONE_TYPE)\n.defaultState(state -> state.withTrait(LanternEnumTraits.STONE_TYPE, LanternStoneType.STONE).get())\n.itemType(builder -> builder\n.keysProvider(collection -> collection\n.register(Keys.STONE_TYPE, LanternStoneType.STONE)\n)\n)\n.properties(builder -> builder\n.add(hardness(1.5))\n.add(blastResistance(30.0)))\n.translation(TranslationProvider.of(LanternEnumTraits.STONE_TYPE))\n.build(\"minecraft\", \"stone\"),\n\n.withTrait(LanternEnumTraits.BED_PART, LanternBedPart.FOOT).get()\n.withTrait(LanternBooleanTraits.OCCUPIED, false).get())\n.properties(builder -> builder\n.add(hardness(0.2))\n.add(blastResistance(1.0)))\n.translation(\"tile.bed.name\")\n.build(\"minecraft\", \"bed\"),\nblockState -> {\nfinal Direction facing = blockState.getTraitValue(LanternEnumTraits.HORIZONTAL_FACING).get();\nint type = facing == Direction.SOUTH ? 0 : facing == Direction.WEST ? 1 :\nfacing == Direction.NORTH ? 2 : facing == Direction.EAST ? 3 : -1;\ncheckArgument(type != -1);\nif (blockState.getTraitValue(LanternBooleanTraits.OCCUPIED).get()) {\ntype |= 0x4;\n}\nif (blockState.getTraitValue(LanternEnumTraits.BED_PART).get() == LanternBedPart.HEAD) {\ntype |= 0x8;\n}\nreturn (byte) type;\n});\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\/\/\/ Golden Rail \/\/\/\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\nregister(27, simpleBuilder()\n.traits(LanternEnumTraits.STRAIGHT_RAIL_DIRECTION, LanternBooleanTraits.POWERED)\n.defaultState(state -> state\n.withTrait(LanternEnumTraits.STRAIGHT_RAIL_DIRECTION, LanternRailDirection.NORTH_SOUTH).get()\n.withTrait(LanternBooleanTraits.POWERED, false).get())\n.itemType()\n.selectionBox(BoundingBoxes::rail)\n.properties(builder -> builder\n.add(PASSABLE)\n.add(hardness(0.7))\n.add(blastResistance(3.5)))\n.translation(\"tile.goldenRail.name\")\n.build(\"minecraft\", \"golden_rail\"),\nblockState -> {\nint type = blockState.getTraitValue(LanternEnumTraits.STRAIGHT_RAIL_DIRECTION).get().getInternalId();\nif (blockState.getTraitValue(LanternBooleanTraits.POWERED).get()) {\ntype |= 0x8;\n}\nreturn (byte) type;\n});\n\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\/\/\/ Fire \/\/\/\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\nregister(51, simpleBuilder()\n.properties(builder -> builder\n.add(PASSABLE)\n.add(INSTANT_BROKEN)\n.add(lightEmission(15)))\n.collisionBox(BoundingBoxes.NULL)\n.translation(\"tile.fire.name\")\n.build(\"minecraft\", \"fire\"));\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\/\/\/ Mob Spawner \/\/\/\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\nregister(52, simpleBuilder()\n.properties(builder -> builder\n.add(hardness(5.0))\n.add(blastResistance(25.0)))\n.translation(\"tile.mobSpawner.name\")\n.build(\"minecraft\", \"mob_spawner\"));\n\/\/ TODO: Oak Stairs\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\/\/\/ Chest \/\/\/\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\nregister(54, chestBuilder()\n.translation(\"tile.chest.name\")\n.build(\"minecraft\", \"chest\"),\nthis::horizontalFacingData);\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\/\/\/ Redstone Wire \/\/\/\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\nregister(55, simpleBuilder()\n.traits(LanternIntegerTraits.POWER)\n.selectionBox(new AABB(0, 0, 0, 1.0, 0.0625, 1.0)) \/\/ TODO: Based on connections\n.properties(builder -> builder\n.add(PASSABLE)\n.add(INSTANT_BROKEN))\n.defaultState(state -> state\n.withTrait(LanternIntegerTraits.POWER, 0).get())\n.translation(\"tile.redstoneDust.name\")\n.build(\"minecraft\", \"redstone_wire\"),\nstate -> state.get(Keys.POWER).get().byteValue());\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\/\/\/ Diamond Ore \/\/\/\n\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\/\/\/ Gold Block \/\/\/\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\nregister(41, simpleBuilder()\n.itemType()\n.properties(builder -> builder\n.add(hardness(3.0))\n.add(blastResistance(10.0)))\n.translation(\"tile.blockGold.name\")\n.build(\"minecraft\", \"gold_block\"));\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\/\/\/ Iron Block \/\/\/\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\nregister(42, simpleBuilder()\n.itemType()\n.properties(builder -> builder\n.add(hardness(5.0))\n.add(blastResistance(10.0)))\n.translation(\"tile.blockIron.name\")\n.build(\"minecraft\", \"iron_block\"));\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\/\/\/ Double Stone Slab 1 \/\/\/\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\nregister(43, doubleStoneSlab(LanternEnumTraits.STONE_SLAB1_TYPE, LanternSlabType.STONE)\n.translation(\"tile.stoneSlab.name\")\n.build(\"minecraft\", \"double_stone_slab\"),\nblockState -> doubleStoneSlabData(blockState, blockState.getTraitValue(LanternEnumTraits.STONE_SLAB1_TYPE).get().getInternalId()));\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\/\/\/ Stone Slab 1 \/\/\/\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\nregister(44, stoneSlab(LanternEnumTraits.STONE_SLAB1_TYPE, LanternSlabType.STONE,\n() -> BlockTypes.STONE_SLAB,\n() -> BlockTypes.DOUBLE_STONE_SLAB)\n.translation(\"tile.stoneSlab.name\")\n.collisionBox(BoundingBoxes::slab)\n.build(\"minecraft\", \"stone_slab\"),\nblockState -> stoneSlabData(blockState, blockState.getTraitValue(LanternEnumTraits.STONE_SLAB1_TYPE).get().getInternalId()));\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\/\/\/ Brick Block \/\/\/\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\nregister(45, simpleBuilder()\n.itemType()\n.properties(builder -> builder\n\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\nregister(52, simpleBuilder()\n.properties(builder -> builder\n.add(hardness(5.0))\n.add(blastResistance(25.0)))\n.translation(\"tile.mobSpawner.name\")\n.build(\"minecraft\", \"mob_spawner\"));\n\/\/ TODO: Oak Stairs\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\/\/\/ Chest \/\/\/\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\nregister(54, chestBuilder()\n.translation(\"tile.chest.name\")\n.build(\"minecraft\", \"chest\"),\nthis::horizontalFacingData);\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\/\/\/ Redstone Wire \/\/\/\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\nregister(55, simpleBuilder()\n.traits(LanternIntegerTraits.POWER)\n.selectionBox(new AABB(0, 0, 0, 1.0, 0.0625, 1.0)) \/\/ TODO: Based on connections\n.properties(builder -> builder\n.add(PASSABLE)\n.add(INSTANT_BROKEN))\n.defaultState(state -> state\n.withTrait(LanternIntegerTraits.POWER, 0).get())\n.translation(\"tile.redstoneDust.name\")\n.build(\"minecraft\", \"redstone_wire\"),\nstate -> state.get(Keys.POWER).get().byteValue());\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\/\/\/ Diamond Ore \/\/\/\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\nregister(56, simpleBuilder()\n.itemType()\n.properties(builder -> builder\n.add(hardness(3.0))\n.add(blastResistance(5.0)))\n.translation(\"tile.oreDiamond.name\")\n.build(\"minecraft\", \"diamond_ore\"));\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\/\/\/ Diamond Block \/\/\/\n\nregister(27, simpleBuilder()\n.traits(LanternEnumTraits.STRAIGHT_RAIL_DIRECTION, LanternBooleanTraits.POWERED)\n.defaultState(state -> state\n.withTrait(LanternEnumTraits.STRAIGHT_RAIL_DIRECTION, LanternRailDirection.NORTH_SOUTH).get()\n.withTrait(LanternBooleanTraits.POWERED, false).get())\n.itemType()\n.selectionBox(BoundingBoxes::rail)\n.properties(builder -> builder\n.add(PASSABLE)\n.add(hardness(0.7))\n.add(blastResistance(3.5)))\n.translation(\"tile.goldenRail.name\")\n.build(\"minecraft\", \"golden_rail\"),\nblockState -> {\nint type = blockState.getTraitValue(LanternEnumTraits.STRAIGHT_RAIL_DIRECTION).get().getInternalId();\nif (blockState.getTraitValue(LanternBooleanTraits.POWERED).get()) {\ntype |= 0x8;\n}\nreturn (byte) type;\n});\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\/\/\/ Detector Rail \/\/\/\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\nregister(28, simpleBuilder()\n.traits(LanternEnumTraits.STRAIGHT_RAIL_DIRECTION, LanternBooleanTraits.POWERED)\n.defaultState(state -> state\n.withTrait(LanternEnumTraits.STRAIGHT_RAIL_DIRECTION, LanternRailDirection.NORTH_SOUTH).get()\n.withTrait(LanternBooleanTraits.POWERED, false).get())\n.itemType()\n.selectionBox(BoundingBoxes::rail)\n.properties(builder -> builder\n.add(PASSABLE)\n.add(hardness(0.7))\n.add(blastResistance(3.5)))\n.translation(\"tile.detectorRail.name\")\n.build(\"minecraft\", \"detector_rail\"),\nblockState -> {\nint type = blockState.getTraitValue(LanternEnumTraits.STRAIGHT_RAIL_DIRECTION).get().getInternalId();\nif (blockState.getTraitValue(LanternBooleanTraits.POWERED).get()) {\ntype |= 0x8;\n}\nreturn (byte) type;\n});\n\n.properties(builder -> builder\n.add(INSTANT_BROKEN)\n.add(PASSABLE)\n.add(replaceable(true)))\n.selectionBox(BoundingBoxes.bush())\n.itemType()\n.translation(\"tile.deadbush.name\")\n.build(\"minecraft\", \"deadbush\"));\n\/\/ TODO: 33\n\/\/ TODO: 34\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\/\/\/ Wool \/\/\/\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\nregister(35, dyedBuilder(\"tile.wool.%s.name\")\n.properties(builder -> builder\n.add(hardness(0.8))\n.add(blastResistance(4.0)))\n.build(\"minecraft\", \"wool\"),\nthis::dyedData);\n\/\/ TODO: 36\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\/\/\/ Yellow Flower \/\/\/\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\nregister(37, simpleBuilder()\n.traits(LanternEnumTraits.YELLOW_FLOWER_TYPE)\n.defaultState(state -> state\n.withTrait(LanternEnumTraits.YELLOW_FLOWER_TYPE, LanternPlantType.DANDELION).get())\n.itemType(builder -> builder\n.keysProvider(collection -> collection\n.register(Keys.PLANT_TYPE, LanternPlantType.DANDELION)))\n.selectionBox(BoundingBoxes.bush())\n.properties(builder -> builder\n.add(INSTANT_BROKEN)\n.add(PASSABLE))\n.translation(TranslationProvider.of(LanternEnumTraits.YELLOW_FLOWER_TYPE))\n.build(\"minecraft\", \"yellow_flower\"),\nblockState -> (byte) blockState.getTraitValue(LanternEnumTraits.YELLOW_FLOWER_TYPE).get().getInternalId());\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\/\/\/ Red Flower \/\/\/\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\nregister(38, simpleBuilder()\n.traits(LanternEnumTraits.RED_FLOWER_TYPE)\n.defaultState(state -> state\n\n.translation(TranslationProvider.of(LanternEnumTraits.YELLOW_FLOWER_TYPE))\n.build(\"minecraft\", \"yellow_flower\"),\nblockState -> (byte) blockState.getTraitValue(LanternEnumTraits.YELLOW_FLOWER_TYPE).get().getInternalId());\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\/\/\/ Red Flower \/\/\/\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\nregister(38, simpleBuilder()\n.traits(LanternEnumTraits.RED_FLOWER_TYPE)\n.defaultState(state -> state\n.withTrait(LanternEnumTraits.RED_FLOWER_TYPE, LanternPlantType.POPPY).get())\n.itemType(builder -> builder\n.keysProvider(collection -> collection\n.register(Keys.PLANT_TYPE, LanternPlantType.POPPY)))\n.selectionBox(BoundingBoxes.bush())\n.properties(builder -> builder\n.add(INSTANT_BROKEN)\n.add(PASSABLE))\n.translation(TranslationProvider.of(LanternEnumTraits.RED_FLOWER_TYPE))\n.build(\"minecraft\", \"red_flower\"),\nblockState -> (byte) blockState.getTraitValue(LanternEnumTraits.RED_FLOWER_TYPE).get().getInternalId());\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\/\/\/ Brown Mushroom \/\/\/\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\nregister(39, simpleBuilder()\n.selectionBox(BoundingBoxes.bush())\n.properties(builder -> builder\n.add(INSTANT_BROKEN)\n.add(PASSABLE)\n.add(lightEmission(1)))\n.translation(\"tile.mushroom.name\")\n.build(\"minecraft\", \"brown_mushroom\"));\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\/\/\/ Red Mushroom \/\/\/\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\nregister(40, simpleBuilder()\n.selectionBox(BoundingBoxes.bush())\n.properties(builder -> builder\n.add(INSTANT_BROKEN)\n.add(PASSABLE))\n.translation(\"tile.mushroom.name\")\n.build(\"minecraft\", \"red_mushroom\"));\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\/\/\/ Gold Block \/\/\/\n\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\nregister(57, simpleBuilder()\n.itemType()\n.properties(builder -> builder\n.add(hardness(5.0))\n.add(blastResistance(10.0)))\n.translation(\"tile.blockDiamond.name\")\n.build(\"minecraft\", \"diamond_block\"));\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\/\/\/ Crafting Table \/\/\/\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\nregister(58, simpleBuilder()\n.itemType()\n.properties(builder -> builder\n.add(hardness(2.5))\n.add(blastResistance(12.5)))\n.translation(\"tile.workbench.name\")\n.behaviors(pipeline -> pipeline\n.add(new CraftingTableInteractionBehavior()))\n.build(\"minecraft\", \"crafting_table\"));\n\/\/ TODO: Wheat\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\/\/\/ Farmland \/\/\/\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\nregister(60, simpleBuilder()\n.collisionBox(BoundingBoxes.farmland())\n.trait(LanternIntegerTraits.MOISTURE)\n.properties(builder -> builder\n.add(hardness(0.6))\n.add(blastResistance(3.0)))\n.defaultState(state ->\nstate.withTrait(LanternIntegerTraits.MOISTURE, 0).get())\n.translation(\"tile.farmland.name\")\n.build(\"minecraft\", \"farmland\"),\nstate -> state.getTraitValue(LanternIntegerTraits.MOISTURE).get().byteValue());\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\/\/\/ Furnace \/\/\/\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\nregister(61, furnaceBuilder()\n.itemType()\n.translation(\"tile.furnace.name\")\n.build(\"minecraft\", \"furnace\"),\nthis::directionData);\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\n.build(\"minecraft\", \"cobblestone\"));\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\/\/\/ Planks \/\/\/\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\nregister(5, simpleBuilder()\n.trait(LanternEnumTraits.TREE_TYPE)\n.defaultState(state -> state.withTrait(LanternEnumTraits.TREE_TYPE, LanternTreeType.OAK).get())\n.itemType(builder -> builder\n.keysProvider(collection -> collection\n.register(Keys.TREE_TYPE, LanternTreeType.OAK)\n)\n)\n.properties(builder -> builder\n.add(hardness(2.0))\n.add(blastResistance(5.0))\n.add(flammableInfo(5, 20)))\n.translation(TranslationProvider.of(LanternEnumTraits.TREE_TYPE, type ->\ntr(\"tile.planks.\" + type.getTranslationKeyBase() + \".name\")))\n.build(\"minecraft\", \"planks\"),\nblockState -> (byte) blockState.getTraitValue(LanternEnumTraits.TREE_TYPE).get().getInternalId());\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\/\/\/ Sapling \/\/\/\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\nregister(6, simpleBuilder()\n.traits(LanternEnumTraits.TREE_TYPE, LanternIntegerTraits.SAPLING_GROWTH_STAGE)\n.defaultState(state -> state\n.withTrait(LanternEnumTraits.TREE_TYPE, LanternTreeType.OAK).get()\n.withTrait(LanternIntegerTraits.SAPLING_GROWTH_STAGE, 0).get())\n.itemType(builder -> builder\n.keysProvider(collection -> collection\n.register(Keys.TREE_TYPE, LanternTreeType.OAK)\n)\n)\n.properties(builder -> builder\n.add(PASSABLE)\n.add(INSTANT_BROKEN))\n.translation(TranslationProvider.of(LanternEnumTraits.TREE_TYPE, type ->\ntr(\"tile.sapling.\" + type.getTranslationKeyBase() + \".name\")))\n.build(\"minecraft\", \"sapling\"),\nblockState -> {\nfinal int type = blockState.getTraitValue(LanternEnumTraits.TREE_TYPE).get().getInternalId();\nfinal int stage = blockState.getTraitValue(LanternIntegerTraits.SAPLING_GROWTH_STAGE).get();\nreturn (byte) (stage << 3 | type);\n\n.build(\"minecraft\", \"cobblestone\"));\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\/\/\/ Planks \/\/\/\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\nregister(5, simpleBuilder()\n.trait(LanternEnumTraits.TREE_TYPE)\n.defaultState(state -> state.withTrait(LanternEnumTraits.TREE_TYPE, LanternTreeType.OAK).get())\n.itemType(builder -> builder\n.keysProvider(collection -> collection\n.register(Keys.TREE_TYPE, LanternTreeType.OAK)\n)\n)\n.properties(builder -> builder\n.add(hardness(2.0))\n.add(blastResistance(5.0))\n.add(flammableInfo(5, 20)))\n.translation(TranslationProvider.of(LanternEnumTraits.TREE_TYPE, type ->\ntr(\"tile.planks.\" + type.getTranslationKeyBase() + \".name\")))\n.build(\"minecraft\", \"planks\"),\nblockState -> (byte) blockState.getTraitValue(LanternEnumTraits.TREE_TYPE).get().getInternalId());\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\/\/\/ Sapling \/\/\/\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\nregister(6, simpleBuilder()\n.traits(LanternEnumTraits.TREE_TYPE, LanternIntegerTraits.SAPLING_GROWTH_STAGE)\n.defaultState(state -> state\n.withTrait(LanternEnumTraits.TREE_TYPE, LanternTreeType.OAK).get()\n.withTrait(LanternIntegerTraits.SAPLING_GROWTH_STAGE, 0).get())\n.itemType(builder -> builder\n.keysProvider(collection -> collection\n.register(Keys.TREE_TYPE, LanternTreeType.OAK)\n)\n)\n.properties(builder -> builder\n.add(PASSABLE)\n.add(INSTANT_BROKEN))\n.translation(TranslationProvider.of(LanternEnumTraits.TREE_TYPE, type ->\ntr(\"tile.sapling.\" + type.getTranslationKeyBase() + \".name\")))\n.build(\"minecraft\", \"sapling\"),\nblockState -> {\nfinal int type = blockState.getTraitValue(LanternEnumTraits.TREE_TYPE).get().getInternalId();\nfinal int stage = blockState.getTraitValue(LanternIntegerTraits.SAPLING_GROWTH_STAGE).get();\nreturn (byte) (stage << 3 | type);\n\nregister(46, simpleBuilder()\n.trait(LanternBooleanTraits.EXPLODE)\n.defaultState(state -> state\n.withTrait(LanternBooleanTraits.EXPLODE, false).get())\n.itemType()\n.properties(builder -> builder\n.add(INSTANT_BROKEN))\n.translation(\"tile.tnt.name\")\n.build(\"minecraft\", \"tnt\"),\nblockState -> (byte) (blockState.getTraitValue(LanternBooleanTraits.EXPLODE).get() ? 1 : 0));\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\/\/\/ Bookshelf \/\/\/\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\nregister(47, simpleBuilder()\n.itemType()\n.properties(builder -> builder\n.add(hardness(1.5))\n.add(blastResistance(7.5)))\n.translation(\"tile.bookshelf.name\")\n.build(\"minecraft\", \"bookshelf\"));\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\/\/\/ Mossy Cobblestone \/\/\/\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\nregister(48, simpleBuilder()\n.itemType()\n.properties(builder -> builder\n.add(hardness(2.0))\n.add(blastResistance(10.0)))\n.translation(\"tile.stoneMoss.name\")\n.build(\"minecraft\", \"mossy_cobblestone\"));\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\/\/\/ Obsidian \/\/\/\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\nregister(49, simpleBuilder()\n.itemType()\n.properties(builder -> builder\n.add(hardness(50.0))\n.add(blastResistance(2000.0)))\n.translation(\"tile.obsidian.name\")\n.build(\"minecraft\", \"obsidian\"));\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\/\/\/ Torch \/\/\/\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\nregister(46, simpleBuilder()\n.trait(LanternBooleanTraits.EXPLODE)\n.defaultState(state -> state\n.withTrait(LanternBooleanTraits.EXPLODE, false).get())\n.itemType()\n.properties(builder -> builder\n.add(INSTANT_BROKEN))\n.translation(\"tile.tnt.name\")\n.build(\"minecraft\", \"tnt\"),\nblockState -> (byte) (blockState.getTraitValue(LanternBooleanTraits.EXPLODE).get() ? 1 : 0));\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\/\/\/ Bookshelf \/\/\/\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\nregister(47, simpleBuilder()\n.itemType()\n.properties(builder -> builder\n.add(hardness(1.5))\n.add(blastResistance(7.5)))\n.translation(\"tile.bookshelf.name\")\n.build(\"minecraft\", \"bookshelf\"));\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\/\/\/ Mossy Cobblestone \/\/\/\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\nregister(48, simpleBuilder()\n.itemType()\n.properties(builder -> builder\n.add(hardness(2.0))\n.add(blastResistance(10.0)))\n.translation(\"tile.stoneMoss.name\")\n.build(\"minecraft\", \"mossy_cobblestone\"));\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\/\/\/ Obsidian \/\/\/\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\nregister(49, simpleBuilder()\n.itemType()\n.properties(builder -> builder\n.add(hardness(50.0))\n.add(blastResistance(2000.0)))\n.translation(\"tile.obsidian.name\")\n.build(\"minecraft\", \"obsidian\"));\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\/\/\/ Torch \/\/\/\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\n.build(\"minecraft\", \"cobblestone\"));\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\/\/\/ Planks \/\/\/\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\nregister(5, simpleBuilder()\n.trait(LanternEnumTraits.TREE_TYPE)\n.defaultState(state -> state.withTrait(LanternEnumTraits.TREE_TYPE, LanternTreeType.OAK).get())\n.itemType(builder -> builder\n.keysProvider(collection -> collection\n.register(Keys.TREE_TYPE, LanternTreeType.OAK)\n)\n)\n.properties(builder -> builder\n.add(hardness(2.0))\n.add(blastResistance(5.0))\n.add(flammableInfo(5, 20)))\n.translation(TranslationProvider.of(LanternEnumTraits.TREE_TYPE, type ->\ntr(\"tile.planks.\" + type.getTranslationKeyBase() + \".name\")))\n.build(\"minecraft\", \"planks\"),\nblockState -> (byte) blockState.getTraitValue(LanternEnumTraits.TREE_TYPE).get().getInternalId());\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\/\/\/ Sapling \/\/\/\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\nregister(6, simpleBuilder()\n.traits(LanternEnumTraits.TREE_TYPE, LanternIntegerTraits.SAPLING_GROWTH_STAGE)\n.defaultState(state -> state\n.withTrait(LanternEnumTraits.TREE_TYPE, LanternTreeType.OAK).get()\n.withTrait(LanternIntegerTraits.SAPLING_GROWTH_STAGE, 0).get())\n.itemType(builder -> builder\n.keysProvider(collection -> collection\n.register(Keys.TREE_TYPE, LanternTreeType.OAK)\n)\n)\n.properties(builder -> builder\n.add(PASSABLE)\n.add(INSTANT_BROKEN))\n.translation(TranslationProvider.of(LanternEnumTraits.TREE_TYPE, type ->\ntr(\"tile.sapling.\" + type.getTranslationKeyBase() + \".name\")))\n.build(\"minecraft\", \"sapling\"),\nblockState -> {\nfinal int type = blockState.getTraitValue(LanternEnumTraits.TREE_TYPE).get().getInternalId();\nfinal int stage = blockState.getTraitValue(LanternIntegerTraits.SAPLING_GROWTH_STAGE).get();\nreturn (byte) (stage << 3 | type);\n\n.build(\"minecraft\", \"cobblestone\"));\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\/\/\/ Planks \/\/\/\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\nregister(5, simpleBuilder()\n.trait(LanternEnumTraits.TREE_TYPE)\n.defaultState(state -> state.withTrait(LanternEnumTraits.TREE_TYPE, LanternTreeType.OAK).get())\n.itemType(builder -> builder\n.keysProvider(collection -> collection\n.register(Keys.TREE_TYPE, LanternTreeType.OAK)\n)\n)\n.properties(builder -> builder\n.add(hardness(2.0))\n.add(blastResistance(5.0))\n.add(flammableInfo(5, 20)))\n.translation(TranslationProvider.of(LanternEnumTraits.TREE_TYPE, type ->\ntr(\"tile.planks.\" + type.getTranslationKeyBase() + \".name\")))\n.build(\"minecraft\", \"planks\"),\nblockState -> (byte) blockState.getTraitValue(LanternEnumTraits.TREE_TYPE).get().getInternalId());\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\/\/\/ Sapling \/\/\/\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\nregister(6, simpleBuilder()\n.traits(LanternEnumTraits.TREE_TYPE, LanternIntegerTraits.SAPLING_GROWTH_STAGE)\n.defaultState(state -> state\n.withTrait(LanternEnumTraits.TREE_TYPE, LanternTreeType.OAK).get()\n.withTrait(LanternIntegerTraits.SAPLING_GROWTH_STAGE, 0).get())\n.itemType(builder -> builder\n.keysProvider(collection -> collection\n.register(Keys.TREE_TYPE, LanternTreeType.OAK)\n)\n)\n.properties(builder -> builder\n.add(PASSABLE)\n.add(INSTANT_BROKEN))\n.translation(TranslationProvider.of(LanternEnumTraits.TREE_TYPE, type ->\ntr(\"tile.sapling.\" + type.getTranslationKeyBase() + \".name\")))\n.build(\"minecraft\", \"sapling\"),\nblockState -> {\nfinal int type = blockState.getTraitValue(LanternEnumTraits.TREE_TYPE).get().getInternalId();\nfinal int stage = blockState.getTraitValue(LanternIntegerTraits.SAPLING_GROWTH_STAGE).get();\nreturn (byte) (stage << 3 | type);\n\n.withTrait(LanternEnumTraits.BED_PART, LanternBedPart.FOOT).get()\n.withTrait(LanternBooleanTraits.OCCUPIED, false).get())\n.properties(builder -> builder\n.add(hardness(0.2))\n.add(blastResistance(1.0)))\n.translation(\"tile.bed.name\")\n.build(\"minecraft\", \"bed\"),\nblockState -> {\nfinal Direction facing = blockState.getTraitValue(LanternEnumTraits.HORIZONTAL_FACING).get();\nint type = facing == Direction.SOUTH ? 0 : facing == Direction.WEST ? 1 :\nfacing == Direction.NORTH ? 2 : facing == Direction.EAST ? 3 : -1;\ncheckArgument(type != -1);\nif (blockState.getTraitValue(LanternBooleanTraits.OCCUPIED).get()) {\ntype |= 0x4;\n}\nif (blockState.getTraitValue(LanternEnumTraits.BED_PART).get() == LanternBedPart.HEAD) {\ntype |= 0x8;\n}\nreturn (byte) type;\n});\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\/\/\/ Golden Rail \/\/\/\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\nregister(27, simpleBuilder()\n.traits(LanternEnumTraits.STRAIGHT_RAIL_DIRECTION, LanternBooleanTraits.POWERED)\n.defaultState(state -> state\n.withTrait(LanternEnumTraits.STRAIGHT_RAIL_DIRECTION, LanternRailDirection.NORTH_SOUTH).get()\n.withTrait(LanternBooleanTraits.POWERED, false).get())\n.itemType()\n.selectionBox(BoundingBoxes::rail)\n.properties(builder -> builder\n.add(PASSABLE)\n.add(hardness(0.7))\n.add(blastResistance(3.5)))\n.translation(\"tile.goldenRail.name\")\n.build(\"minecraft\", \"golden_rail\"),\nblockState -> {\nint type = blockState.getTraitValue(LanternEnumTraits.STRAIGHT_RAIL_DIRECTION).get().getInternalId();\nif (blockState.getTraitValue(LanternBooleanTraits.POWERED).get()) {\ntype |= 0x8;\n}\nreturn (byte) type;\n});\n\n.build(\"minecraft\", \"cobblestone\"));\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\/\/\/ Planks \/\/\/\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\nregister(5, simpleBuilder()\n.trait(LanternEnumTraits.TREE_TYPE)\n.defaultState(state -> state.withTrait(LanternEnumTraits.TREE_TYPE, LanternTreeType.OAK).get())\n.itemType(builder -> builder\n.keysProvider(collection -> collection\n.register(Keys.TREE_TYPE, LanternTreeType.OAK)\n)\n)\n.properties(builder -> builder\n.add(hardness(2.0))\n.add(blastResistance(5.0))\n.add(flammableInfo(5, 20)))\n.translation(TranslationProvider.of(LanternEnumTraits.TREE_TYPE, type ->\ntr(\"tile.planks.\" + type.getTranslationKeyBase() + \".name\")))\n.build(\"minecraft\", \"planks\"),\nblockState -> (byte) blockState.getTraitValue(LanternEnumTraits.TREE_TYPE).get().getInternalId());\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\/\/\/ Sapling \/\/\/\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\nregister(6, simpleBuilder()\n.traits(LanternEnumTraits.TREE_TYPE, LanternIntegerTraits.SAPLING_GROWTH_STAGE)\n.defaultState(state -> state\n.withTrait(LanternEnumTraits.TREE_TYPE, LanternTreeType.OAK).get()\n.withTrait(LanternIntegerTraits.SAPLING_GROWTH_STAGE, 0).get())\n.itemType(builder -> builder\n.keysProvider(collection -> collection\n.register(Keys.TREE_TYPE, LanternTreeType.OAK)\n)\n)\n.properties(builder -> builder\n.add(PASSABLE)\n.add(INSTANT_BROKEN))\n.translation(TranslationProvider.of(LanternEnumTraits.TREE_TYPE, type ->\ntr(\"tile.sapling.\" + type.getTranslationKeyBase() + \".name\")))\n.build(\"minecraft\", \"sapling\"),\nblockState -> {\nfinal int type = blockState.getTraitValue(LanternEnumTraits.TREE_TYPE).get().getInternalId();\nfinal int stage = blockState.getTraitValue(LanternIntegerTraits.SAPLING_GROWTH_STAGE).get();\nreturn (byte) (stage << 3 | type);\n\n.withTrait(LanternEnumTraits.BED_PART, LanternBedPart.FOOT).get()\n.withTrait(LanternBooleanTraits.OCCUPIED, false).get())\n.properties(builder -> builder\n.add(hardness(0.2))\n.add(blastResistance(1.0)))\n.translation(\"tile.bed.name\")\n.build(\"minecraft\", \"bed\"),\nblockState -> {\nfinal Direction facing = blockState.getTraitValue(LanternEnumTraits.HORIZONTAL_FACING).get();\nint type = facing == Direction.SOUTH ? 0 : facing == Direction.WEST ? 1 :\nfacing == Direction.NORTH ? 2 : facing == Direction.EAST ? 3 : -1;\ncheckArgument(type != -1);\nif (blockState.getTraitValue(LanternBooleanTraits.OCCUPIED).get()) {\ntype |= 0x4;\n}\nif (blockState.getTraitValue(LanternEnumTraits.BED_PART).get() == LanternBedPart.HEAD) {\ntype |= 0x8;\n}\nreturn (byte) type;\n});\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\/\/\/ Golden Rail \/\/\/\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\nregister(27, simpleBuilder()\n.traits(LanternEnumTraits.STRAIGHT_RAIL_DIRECTION, LanternBooleanTraits.POWERED)\n.defaultState(state -> state\n.withTrait(LanternEnumTraits.STRAIGHT_RAIL_DIRECTION, LanternRailDirection.NORTH_SOUTH).get()\n.withTrait(LanternBooleanTraits.POWERED, false).get())\n.itemType()\n.selectionBox(BoundingBoxes::rail)\n.properties(builder -> builder\n.add(PASSABLE)\n.add(hardness(0.7))\n.add(blastResistance(3.5)))\n.translation(\"tile.goldenRail.name\")\n.build(\"minecraft\", \"golden_rail\"),\nblockState -> {\nint type = blockState.getTraitValue(LanternEnumTraits.STRAIGHT_RAIL_DIRECTION).get().getInternalId();\nif (blockState.getTraitValue(LanternBooleanTraits.POWERED).get()) {\ntype |= 0x8;\n}\nreturn (byte) type;\n});\n\n@Override\npublic void registerDefaults() {\n\/\/ @formatter:off\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\/\/\/ Air \/\/\/\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\nregister(0, builder()\n.properties(PropertyProviderCollections.DEFAULT_GAS)\n.translation(\"tile.air.name\")\n.build(\"minecraft\", \"air\"));\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\/\/\/ Stone \/\/\/\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\nregister(1, simpleBuilder()\n.trait(LanternEnumTraits.STONE_TYPE)\n.defaultState(state -> state.withTrait(LanternEnumTraits.STONE_TYPE, LanternStoneType.STONE).get())\n.itemType(builder -> builder\n.keysProvider(collection -> collection\n.register(Keys.STONE_TYPE, LanternStoneType.STONE)\n)\n)\n.properties(builder -> builder\n.add(hardness(1.5))\n.add(blastResistance(30.0)))\n.translation(TranslationProvider.of(LanternEnumTraits.STONE_TYPE))\n.build(\"minecraft\", \"stone\"),\n\n.add(PropertyProviderCollections.UNBREAKABLE))\n.translation(\"tile.bedrock.name\")\n.build(\"minecraft\", \"bedrock\"));\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\/\/\/ Sand \/\/\/\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\nregister(12, simpleBuilder()\n.trait(LanternEnumTraits.SAND_TYPE)\n.defaultState(state -> state.withTrait(LanternEnumTraits.SAND_TYPE, LanternSandType.NORMAL).get())\n.itemType(builder -> builder\n.keysProvider(collection -> collection\n.register(Keys.SAND_TYPE, LanternSandType.NORMAL)\n)\n)\n.properties(builder -> builder\n.add(hardness(0.5))\n.add(blastResistance(2.5)))\n.translation(TranslationProvider.of(LanternEnumTraits.SAND_TYPE))\n.build(\"minecraft\", \"sand\"),\nblockState -> (byte) blockState.getTraitValue(LanternEnumTraits.SAND_TYPE).get().getInternalId());\n\/\/ TODO: Sand physics behavior\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\/\/\/ Gravel \/\/\/\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\nregister(13, simpleBuilder()\n.itemType()\n.properties(builder -> builder\n.add(hardness(0.6))\n.add(blastResistance(3.0)))\n.translation(\"tile.gravel.name\")\n.build(\"minecraft\", \"gravel\"));\n\/\/ TODO: Gravel physics behavior\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\/\/\/ Gold Ore \/\/\/\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\nregister(14, simpleBuilder()\n.itemType()\n.properties(builder -> builder\n.add(hardness(3.0))\n.add(blastResistance(15.0)))\n.translation(\"tile.oreGold.name\")\n\n.withTrait(LanternEnumTraits.BED_PART, LanternBedPart.FOOT).get()\n.withTrait(LanternBooleanTraits.OCCUPIED, false).get())\n.properties(builder -> builder\n.add(hardness(0.2))\n.add(blastResistance(1.0)))\n.translation(\"tile.bed.name\")\n.build(\"minecraft\", \"bed\"),\nblockState -> {\nfinal Direction facing = blockState.getTraitValue(LanternEnumTraits.HORIZONTAL_FACING).get();\nint type = facing == Direction.SOUTH ? 0 : facing == Direction.WEST ? 1 :\nfacing == Direction.NORTH ? 2 : facing == Direction.EAST ? 3 : -1;\ncheckArgument(type != -1);\nif (blockState.getTraitValue(LanternBooleanTraits.OCCUPIED).get()) {\ntype |= 0x4;\n}\nif (blockState.getTraitValue(LanternEnumTraits.BED_PART).get() == LanternBedPart.HEAD) {\ntype |= 0x8;\n}\nreturn (byte) type;\n});\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\/\/\/ Golden Rail \/\/\/\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\nregister(27, simpleBuilder()\n.traits(LanternEnumTraits.STRAIGHT_RAIL_DIRECTION, LanternBooleanTraits.POWERED)\n.defaultState(state -> state\n.withTrait(LanternEnumTraits.STRAIGHT_RAIL_DIRECTION, LanternRailDirection.NORTH_SOUTH).get()\n.withTrait(LanternBooleanTraits.POWERED, false).get())\n.itemType()\n.selectionBox(BoundingBoxes::rail)\n.properties(builder -> builder\n.add(PASSABLE)\n.add(hardness(0.7))\n.add(blastResistance(3.5)))\n.translation(\"tile.goldenRail.name\")\n.build(\"minecraft\", \"golden_rail\"),\nblockState -> {\nint type = blockState.getTraitValue(LanternEnumTraits.STRAIGHT_RAIL_DIRECTION).get().getInternalId();\nif (blockState.getTraitValue(LanternBooleanTraits.POWERED).get()) {\ntype |= 0x8;\n}\nreturn (byte) type;\n});\n\n.translation(TranslationProvider.of(LanternEnumTraits.YELLOW_FLOWER_TYPE))\n.build(\"minecraft\", \"yellow_flower\"),\nblockState -> (byte) blockState.getTraitValue(LanternEnumTraits.YELLOW_FLOWER_TYPE).get().getInternalId());\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\/\/\/ Red Flower \/\/\/\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\nregister(38, simpleBuilder()\n.traits(LanternEnumTraits.RED_FLOWER_TYPE)\n.defaultState(state -> state\n.withTrait(LanternEnumTraits.RED_FLOWER_TYPE, LanternPlantType.POPPY).get())\n.itemType(builder -> builder\n.keysProvider(collection -> collection\n.register(Keys.PLANT_TYPE, LanternPlantType.POPPY)))\n.selectionBox(BoundingBoxes.bush())\n.properties(builder -> builder\n.add(INSTANT_BROKEN)\n.add(PASSABLE))\n.translation(TranslationProvider.of(LanternEnumTraits.RED_FLOWER_TYPE))\n.build(\"minecraft\", \"red_flower\"),\nblockState -> (byte) blockState.getTraitValue(LanternEnumTraits.RED_FLOWER_TYPE).get().getInternalId());\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\/\/\/ Brown Mushroom \/\/\/\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\nregister(39, simpleBuilder()\n.selectionBox(BoundingBoxes.bush())\n.properties(builder -> builder\n.add(INSTANT_BROKEN)\n.add(PASSABLE)\n.add(lightEmission(1)))\n.translation(\"tile.mushroom.name\")\n.build(\"minecraft\", \"brown_mushroom\"));\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\/\/\/ Red Mushroom \/\/\/\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\nregister(40, simpleBuilder()\n.selectionBox(BoundingBoxes.bush())\n.properties(builder -> builder\n.add(INSTANT_BROKEN)\n.add(PASSABLE))\n.translation(\"tile.mushroom.name\")\n.build(\"minecraft\", \"red_mushroom\"));\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\/\/\/ Gold Block \/\/\/\n\n.translation(TranslationProvider.of(LanternEnumTraits.YELLOW_FLOWER_TYPE))\n.build(\"minecraft\", \"yellow_flower\"),\nblockState -> (byte) blockState.getTraitValue(LanternEnumTraits.YELLOW_FLOWER_TYPE).get().getInternalId());\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\/\/\/ Red Flower \/\/\/\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\nregister(38, simpleBuilder()\n.traits(LanternEnumTraits.RED_FLOWER_TYPE)\n.defaultState(state -> state\n.withTrait(LanternEnumTraits.RED_FLOWER_TYPE, LanternPlantType.POPPY).get())\n.itemType(builder -> builder\n.keysProvider(collection -> collection\n.register(Keys.PLANT_TYPE, LanternPlantType.POPPY)))\n.selectionBox(BoundingBoxes.bush())\n.properties(builder -> builder\n.add(INSTANT_BROKEN)\n.add(PASSABLE))\n.translation(TranslationProvider.of(LanternEnumTraits.RED_FLOWER_TYPE))\n.build(\"minecraft\", \"red_flower\"),\nblockState -> (byte) blockState.getTraitValue(LanternEnumTraits.RED_FLOWER_TYPE).get().getInternalId());\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\/\/\/ Brown Mushroom \/\/\/\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\nregister(39, simpleBuilder()\n.selectionBox(BoundingBoxes.bush())\n.properties(builder -> builder\n.add(INSTANT_BROKEN)\n.add(PASSABLE)\n.add(lightEmission(1)))\n.translation(\"tile.mushroom.name\")\n.build(\"minecraft\", \"brown_mushroom\"));\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\/\/\/ Red Mushroom \/\/\/\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\nregister(40, simpleBuilder()\n.selectionBox(BoundingBoxes.bush())\n.properties(builder -> builder\n.add(INSTANT_BROKEN)\n.add(PASSABLE))\n.translation(\"tile.mushroom.name\")\n.build(\"minecraft\", \"red_mushroom\"));\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\/\/\/ Gold Block \/\/\/\n\n.withTrait(LanternEnumTraits.BED_PART, LanternBedPart.FOOT).get()\n.withTrait(LanternBooleanTraits.OCCUPIED, false).get())\n.properties(builder -> builder\n.add(hardness(0.2))\n.add(blastResistance(1.0)))\n.translation(\"tile.bed.name\")\n.build(\"minecraft\", \"bed\"),\nblockState -> {\nfinal Direction facing = blockState.getTraitValue(LanternEnumTraits.HORIZONTAL_FACING).get();\nint type = facing == Direction.SOUTH ? 0 : facing == Direction.WEST ? 1 :\nfacing == Direction.NORTH ? 2 : facing == Direction.EAST ? 3 : -1;\ncheckArgument(type != -1);\nif (blockState.getTraitValue(LanternBooleanTraits.OCCUPIED).get()) {\ntype |= 0x4;\n}\nif (blockState.getTraitValue(LanternEnumTraits.BED_PART).get() == LanternBedPart.HEAD) {\ntype |= 0x8;\n}\nreturn (byte) type;\n});\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\/\/\/ Golden Rail \/\/\/\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\nregister(27, simpleBuilder()\n.traits(LanternEnumTraits.STRAIGHT_RAIL_DIRECTION, LanternBooleanTraits.POWERED)\n.defaultState(state -> state\n.withTrait(LanternEnumTraits.STRAIGHT_RAIL_DIRECTION, LanternRailDirection.NORTH_SOUTH).get()\n.withTrait(LanternBooleanTraits.POWERED, false).get())\n.itemType()\n.selectionBox(BoundingBoxes::rail)\n.properties(builder -> builder\n.add(PASSABLE)\n.add(hardness(0.7))\n.add(blastResistance(3.5)))\n.translation(\"tile.goldenRail.name\")\n.build(\"minecraft\", \"golden_rail\"),\nblockState -> {\nint type = blockState.getTraitValue(LanternEnumTraits.STRAIGHT_RAIL_DIRECTION).get().getInternalId();\nif (blockState.getTraitValue(LanternBooleanTraits.POWERED).get()) {\ntype |= 0x8;\n}\nreturn (byte) type;\n});\n\n.withTrait(LanternEnumTraits.BED_PART, LanternBedPart.FOOT).get()\n.withTrait(LanternBooleanTraits.OCCUPIED, false).get())\n.properties(builder -> builder\n.add(hardness(0.2))\n.add(blastResistance(1.0)))\n.translation(\"tile.bed.name\")\n.build(\"minecraft\", \"bed\"),\nblockState -> {\nfinal Direction facing = blockState.getTraitValue(LanternEnumTraits.HORIZONTAL_FACING).get();\nint type = facing == Direction.SOUTH ? 0 : facing == Direction.WEST ? 1 :\nfacing == Direction.NORTH ? 2 : facing == Direction.EAST ? 3 : -1;\ncheckArgument(type != -1);\nif (blockState.getTraitValue(LanternBooleanTraits.OCCUPIED).get()) {\ntype |= 0x4;\n}\nif (blockState.getTraitValue(LanternEnumTraits.BED_PART).get() == LanternBedPart.HEAD) {\ntype |= 0x8;\n}\nreturn (byte) type;\n});\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\/\/\/ Golden Rail \/\/\/\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\nregister(27, simpleBuilder()\n.traits(LanternEnumTraits.STRAIGHT_RAIL_DIRECTION, LanternBooleanTraits.POWERED)\n.defaultState(state -> state\n.withTrait(LanternEnumTraits.STRAIGHT_RAIL_DIRECTION, LanternRailDirection.NORTH_SOUTH).get()\n.withTrait(LanternBooleanTraits.POWERED, false).get())\n.itemType()\n.selectionBox(BoundingBoxes::rail)\n.properties(builder -> builder\n.add(PASSABLE)\n.add(hardness(0.7))\n.add(blastResistance(3.5)))\n.translation(\"tile.goldenRail.name\")\n.build(\"minecraft\", \"golden_rail\"),\nblockState -> {\nint type = blockState.getTraitValue(LanternEnumTraits.STRAIGHT_RAIL_DIRECTION).get().getInternalId();\nif (blockState.getTraitValue(LanternBooleanTraits.POWERED).get()) {\ntype |= 0x8;\n}\nreturn (byte) type;\n});\n\n.itemType()\n.tileEntityType(() -> TileEntityTypes.ENDER_CHEST)\n.properties(builder -> builder\n.add(hardness(22.5))\n.add(blastResistance(3000.0))\n.add(lightEmission(7)))\n.translation(\"tile.enderChest.name\")\n.collisionBox(BoundingBoxes.chest())\n.behaviors(pipeline -> pipeline\n.add(new HorizontalRotationPlacementBehavior())\n.add(new EnderChestInteractionBehavior()))\n.build(\"minecraft\", \"ender_chest\"),\nthis::horizontalFacingData);\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\/\/\/ Trapped Chest \/\/\/\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\nregister(146, chestBuilder()\n.translation(\"tile.chestTrap.name\")\n.build(\"minecraft\", \"trapped_chest\"),\nthis::horizontalFacingData);\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\/\/\/ Weighted Pressure Plate (Light) \/\/\/\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\nregister(147, weightedPressurePlateBuilder()\n.translation(\"tile.weightedPlate_light.name\")\n.build(\"minecraft\", \"light_weighted_pressure_plate\"),\nthis::weightedPressurePlateData);\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\/\/\/ Weighted Pressure Plate (Heavy) \/\/\/\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\nregister(148, weightedPressurePlateBuilder()\n.translation(\"tile.weightedPlate_heavy.name\")\n.build(\"minecraft\", \"heavy_weighted_pressure_plate\"),\nthis::weightedPressurePlateData);\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\/\/\/ Redstone Block \/\/\/\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\nregister(152, simpleBuilder()\n.itemType()\n.properties(builder -> builder\n.add(hardness(5.0))\n.add(blastResistance(30.0)))\n.translation(\"tile.blockRedstone.name\")\n\n.itemType()\n.tileEntityType(() -> TileEntityTypes.ENDER_CHEST)\n.properties(builder -> builder\n.add(hardness(22.5))\n.add(blastResistance(3000.0))\n.add(lightEmission(7)))\n.translation(\"tile.enderChest.name\")\n.collisionBox(BoundingBoxes.chest())\n.behaviors(pipeline -> pipeline\n.add(new HorizontalRotationPlacementBehavior())\n.add(new EnderChestInteractionBehavior()))\n.build(\"minecraft\", \"ender_chest\"),\nthis::horizontalFacingData);\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\/\/\/ Trapped Chest \/\/\/\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\nregister(146, chestBuilder()\n.translation(\"tile.chestTrap.name\")\n.build(\"minecraft\", \"trapped_chest\"),\nthis::horizontalFacingData);\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\/\/\/ Weighted Pressure Plate (Light) \/\/\/\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\nregister(147, weightedPressurePlateBuilder()\n.translation(\"tile.weightedPlate_light.name\")\n.build(\"minecraft\", \"light_weighted_pressure_plate\"),\nthis::weightedPressurePlateData);\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\/\/\/ Weighted Pressure Plate (Heavy) \/\/\/\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\nregister(148, weightedPressurePlateBuilder()\n.translation(\"tile.weightedPlate_heavy.name\")\n.build(\"minecraft\", \"heavy_weighted_pressure_plate\"),\nthis::weightedPressurePlateData);\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\/\/\/ Redstone Block \/\/\/\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\nregister(152, simpleBuilder()\n.itemType()\n.properties(builder -> builder\n.add(hardness(5.0))\n.add(blastResistance(30.0)))\n.translation(\"tile.blockRedstone.name\")\n\nregister(27, simpleBuilder()\n.traits(LanternEnumTraits.STRAIGHT_RAIL_DIRECTION, LanternBooleanTraits.POWERED)\n.defaultState(state -> state\n.withTrait(LanternEnumTraits.STRAIGHT_RAIL_DIRECTION, LanternRailDirection.NORTH_SOUTH).get()\n.withTrait(LanternBooleanTraits.POWERED, false).get())\n.itemType()\n.selectionBox(BoundingBoxes::rail)\n.properties(builder -> builder\n.add(PASSABLE)\n.add(hardness(0.7))\n.add(blastResistance(3.5)))\n.translation(\"tile.goldenRail.name\")\n.build(\"minecraft\", \"golden_rail\"),\nblockState -> {\nint type = blockState.getTraitValue(LanternEnumTraits.STRAIGHT_RAIL_DIRECTION).get().getInternalId();\nif (blockState.getTraitValue(LanternBooleanTraits.POWERED).get()) {\ntype |= 0x8;\n}\nreturn (byte) type;\n});\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\/\/\/ Detector Rail \/\/\/\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\nregister(28, simpleBuilder()\n.traits(LanternEnumTraits.STRAIGHT_RAIL_DIRECTION, LanternBooleanTraits.POWERED)\n.defaultState(state -> state\n.withTrait(LanternEnumTraits.STRAIGHT_RAIL_DIRECTION, LanternRailDirection.NORTH_SOUTH).get()\n.withTrait(LanternBooleanTraits.POWERED, false).get())\n.itemType()\n.selectionBox(BoundingBoxes::rail)\n.properties(builder -> builder\n.add(PASSABLE)\n.add(hardness(0.7))\n.add(blastResistance(3.5)))\n.translation(\"tile.detectorRail.name\")\n.build(\"minecraft\", \"detector_rail\"),\nblockState -> {\nint type = blockState.getTraitValue(LanternEnumTraits.STRAIGHT_RAIL_DIRECTION).get().getInternalId();\nif (blockState.getTraitValue(LanternBooleanTraits.POWERED).get()) {\ntype |= 0x8;\n}\nreturn (byte) type;\n});\n\n.build(\"minecraft\", \"cobblestone\"));\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\/\/\/ Planks \/\/\/\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\nregister(5, simpleBuilder()\n.trait(LanternEnumTraits.TREE_TYPE)\n.defaultState(state -> state.withTrait(LanternEnumTraits.TREE_TYPE, LanternTreeType.OAK).get())\n.itemType(builder -> builder\n.keysProvider(collection -> collection\n.register(Keys.TREE_TYPE, LanternTreeType.OAK)\n)\n)\n.properties(builder -> builder\n.add(hardness(2.0))\n.add(blastResistance(5.0))\n.add(flammableInfo(5, 20)))\n.translation(TranslationProvider.of(LanternEnumTraits.TREE_TYPE, type ->\ntr(\"tile.planks.\" + type.getTranslationKeyBase() + \".name\")))\n.build(\"minecraft\", \"planks\"),\nblockState -> (byte) blockState.getTraitValue(LanternEnumTraits.TREE_TYPE).get().getInternalId());\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\/\/\/ Sapling \/\/\/\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\nregister(6, simpleBuilder()\n.traits(LanternEnumTraits.TREE_TYPE, LanternIntegerTraits.SAPLING_GROWTH_STAGE)\n.defaultState(state -> state\n.withTrait(LanternEnumTraits.TREE_TYPE, LanternTreeType.OAK).get()\n.withTrait(LanternIntegerTraits.SAPLING_GROWTH_STAGE, 0).get())\n.itemType(builder -> builder\n.keysProvider(collection -> collection\n.register(Keys.TREE_TYPE, LanternTreeType.OAK)\n)\n)\n.properties(builder -> builder\n.add(PASSABLE)\n.add(INSTANT_BROKEN))\n.translation(TranslationProvider.of(LanternEnumTraits.TREE_TYPE, type ->\ntr(\"tile.sapling.\" + type.getTranslationKeyBase() + \".name\")))\n.build(\"minecraft\", \"sapling\"),\nblockState -> {\nfinal int type = blockState.getTraitValue(LanternEnumTraits.TREE_TYPE).get().getInternalId();\nfinal int stage = blockState.getTraitValue(LanternIntegerTraits.SAPLING_GROWTH_STAGE).get();\nreturn (byte) (stage << 3 | type);\n\n.build(\"minecraft\", \"cobblestone\"));\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\/\/\/ Planks \/\/\/\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\nregister(5, simpleBuilder()\n.trait(LanternEnumTraits.TREE_TYPE)\n.defaultState(state -> state.withTrait(LanternEnumTraits.TREE_TYPE, LanternTreeType.OAK).get())\n.itemType(builder -> builder\n.keysProvider(collection -> collection\n.register(Keys.TREE_TYPE, LanternTreeType.OAK)\n)\n)\n.properties(builder -> builder\n.add(hardness(2.0))\n.add(blastResistance(5.0))\n.add(flammableInfo(5, 20)))\n.translation(TranslationProvider.of(LanternEnumTraits.TREE_TYPE, type ->\ntr(\"tile.planks.\" + type.getTranslationKeyBase() + \".name\")))\n.build(\"minecraft\", \"planks\"),\nblockState -> (byte) blockState.getTraitValue(LanternEnumTraits.TREE_TYPE).get().getInternalId());\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\/\/\/ Sapling \/\/\/\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\nregister(6, simpleBuilder()\n.traits(LanternEnumTraits.TREE_TYPE, LanternIntegerTraits.SAPLING_GROWTH_STAGE)\n.defaultState(state -> state\n.withTrait(LanternEnumTraits.TREE_TYPE, LanternTreeType.OAK).get()\n.withTrait(LanternIntegerTraits.SAPLING_GROWTH_STAGE, 0).get())\n.itemType(builder -> builder\n.keysProvider(collection -> collection\n.register(Keys.TREE_TYPE, LanternTreeType.OAK)\n)\n)\n.properties(builder -> builder\n.add(PASSABLE)\n.add(INSTANT_BROKEN))\n.translation(TranslationProvider.of(LanternEnumTraits.TREE_TYPE, type ->\ntr(\"tile.sapling.\" + type.getTranslationKeyBase() + \".name\")))\n.build(\"minecraft\", \"sapling\"),\nblockState -> {\nfinal int type = blockState.getTraitValue(LanternEnumTraits.TREE_TYPE).get().getInternalId();\nfinal int stage = blockState.getTraitValue(LanternIntegerTraits.SAPLING_GROWTH_STAGE).get();\nreturn (byte) (stage << 3 | type);\n\n.withTrait(LanternEnumTraits.BED_PART, LanternBedPart.FOOT).get()\n.withTrait(LanternBooleanTraits.OCCUPIED, false).get())\n.properties(builder -> builder\n.add(hardness(0.2))\n.add(blastResistance(1.0)))\n.translation(\"tile.bed.name\")\n.build(\"minecraft\", \"bed\"),\nblockState -> {\nfinal Direction facing = blockState.getTraitValue(LanternEnumTraits.HORIZONTAL_FACING).get();\nint type = facing == Direction.SOUTH ? 0 : facing == Direction.WEST ? 1 :\nfacing == Direction.NORTH ? 2 : facing == Direction.EAST ? 3 : -1;\ncheckArgument(type != -1);\nif (blockState.getTraitValue(LanternBooleanTraits.OCCUPIED).get()) {\ntype |= 0x4;\n}\nif (blockState.getTraitValue(LanternEnumTraits.BED_PART).get() == LanternBedPart.HEAD) {\ntype |= 0x8;\n}\nreturn (byte) type;\n});\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\/\/\/ Golden Rail \/\/\/\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\nregister(27, simpleBuilder()\n.traits(LanternEnumTraits.STRAIGHT_RAIL_DIRECTION, LanternBooleanTraits.POWERED)\n.defaultState(state -> state\n.withTrait(LanternEnumTraits.STRAIGHT_RAIL_DIRECTION, LanternRailDirection.NORTH_SOUTH).get()\n.withTrait(LanternBooleanTraits.POWERED, false).get())\n.itemType()\n.selectionBox(BoundingBoxes::rail)\n.properties(builder -> builder\n.add(PASSABLE)\n.add(hardness(0.7))\n.add(blastResistance(3.5)))\n.translation(\"tile.goldenRail.name\")\n.build(\"minecraft\", \"golden_rail\"),\nblockState -> {\nint type = blockState.getTraitValue(LanternEnumTraits.STRAIGHT_RAIL_DIRECTION).get().getInternalId();\nif (blockState.getTraitValue(LanternBooleanTraits.POWERED).get()) {\ntype |= 0x8;\n}\nreturn (byte) type;\n});\n\n.build(\"minecraft\", \"cobblestone\"));\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\/\/\/ Planks \/\/\/\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\nregister(5, simpleBuilder()\n.trait(LanternEnumTraits.TREE_TYPE)\n.defaultState(state -> state.withTrait(LanternEnumTraits.TREE_TYPE, LanternTreeType.OAK).get())\n.itemType(builder -> builder\n.keysProvider(collection -> collection\n.register(Keys.TREE_TYPE, LanternTreeType.OAK)\n)\n)\n.properties(builder -> builder\n.add(hardness(2.0))\n.add(blastResistance(5.0))\n.add(flammableInfo(5, 20)))\n.translation(TranslationProvider.of(LanternEnumTraits.TREE_TYPE, type ->\ntr(\"tile.planks.\" + type.getTranslationKeyBase() + \".name\")))\n.build(\"minecraft\", \"planks\"),\nblockState -> (byte) blockState.getTraitValue(LanternEnumTraits.TREE_TYPE).get().getInternalId());\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\/\/\/ Sapling \/\/\/\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\nregister(6, simpleBuilder()\n.traits(LanternEnumTraits.TREE_TYPE, LanternIntegerTraits.SAPLING_GROWTH_STAGE)\n.defaultState(state -> state\n.withTrait(LanternEnumTraits.TREE_TYPE, LanternTreeType.OAK).get()\n.withTrait(LanternIntegerTraits.SAPLING_GROWTH_STAGE, 0).get())\n.itemType(builder -> builder\n.keysProvider(collection -> collection\n.register(Keys.TREE_TYPE, LanternTreeType.OAK)\n)\n)\n.properties(builder -> builder\n.add(PASSABLE)\n.add(INSTANT_BROKEN))\n.translation(TranslationProvider.of(LanternEnumTraits.TREE_TYPE, type ->\ntr(\"tile.sapling.\" + type.getTranslationKeyBase() + \".name\")))\n.build(\"minecraft\", \"sapling\"),\nblockState -> {\nfinal int type = blockState.getTraitValue(LanternEnumTraits.TREE_TYPE).get().getInternalId();\nfinal int stage = blockState.getTraitValue(LanternIntegerTraits.SAPLING_GROWTH_STAGE).get();\nreturn (byte) (stage << 3 | type);\n\n.properties(builder -> builder\n.add(hardness(0.8))\n.add(blastResistance(2.4)))\n.translation(TranslationProvider.of(LanternEnumTraits.QUARTZ_TYPE))\n.behaviors(pipeline -> pipeline\n.add(new QuartzLinesRotationPlacementBehavior()))\n.build(\"minecraft\", \"quartz_block\"),\nblockState -> (byte) blockState.getTraitValue(LanternEnumTraits.QUARTZ_TYPE).get().getInternalId());\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\/\/\/ Dropper \/\/\/\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\nregister(158, simpleBuilder()\n.traits(LanternEnumTraits.FACING, LanternBooleanTraits.TRIGGERED)\n.defaultState(state -> state\n.withTrait(LanternEnumTraits.FACING, Direction.NORTH).get()\n.withTrait(LanternBooleanTraits.TRIGGERED, false).get())\n.itemType()\n.properties(builder -> builder\n.add(hardness(3.5))\n.add(blastResistance(17.5)))\n\/\/ .tileEntityType(() -> TileEntityTypes.DROPPER)\n.translation(\"tile.dropper.name\")\n.behaviors(pipeline -> pipeline\n.add(new RotationPlacementBehavior()))\n.build(\"minecraft\", \"dropper\"),\nblockState -> {\nint data = directionData(blockState.getTraitValue(LanternEnumTraits.FACING).get());\nif (blockState.getTraitValue(LanternBooleanTraits.TRIGGERED).get()) {\ndata |= 0x8;\n}\nreturn (byte) data;\n});\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\/\/\/ Stained Hardended Clay \/\/\/\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\nregister(159, dyedBuilder(\"tile.clayHardenedStained.%s.name\")\n.properties(builder -> builder\n.add(hardness(1.25))\n.add(blastResistance(7.0)))\n.build(\"minecraft\", \"stained_hardened_clay\"),\nthis::dyedData);\n\n.itemType()\n.tileEntityType(() -> TileEntityTypes.ENDER_CHEST)\n.properties(builder -> builder\n.add(hardness(22.5))\n.add(blastResistance(3000.0))\n.add(lightEmission(7)))\n.translation(\"tile.enderChest.name\")\n.collisionBox(BoundingBoxes.chest())\n.behaviors(pipeline -> pipeline\n.add(new HorizontalRotationPlacementBehavior())\n.add(new EnderChestInteractionBehavior()))\n.build(\"minecraft\", \"ender_chest\"),\nthis::horizontalFacingData);\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\/\/\/ Trapped Chest \/\/\/\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\nregister(146, chestBuilder()\n.translation(\"tile.chestTrap.name\")\n.build(\"minecraft\", \"trapped_chest\"),\nthis::horizontalFacingData);\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\/\/\/ Weighted Pressure Plate (Light) \/\/\/\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\nregister(147, weightedPressurePlateBuilder()\n.translation(\"tile.weightedPlate_light.name\")\n.build(\"minecraft\", \"light_weighted_pressure_plate\"),\nthis::weightedPressurePlateData);\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\/\/\/ Weighted Pressure Plate (Heavy) \/\/\/\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\nregister(148, weightedPressurePlateBuilder()\n.translation(\"tile.weightedPlate_heavy.name\")\n.build(\"minecraft\", \"heavy_weighted_pressure_plate\"),\nthis::weightedPressurePlateData);\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\/\/\/ Redstone Block \/\/\/\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\nregister(152, simpleBuilder()\n.itemType()\n.properties(builder -> builder\n.add(hardness(5.0))\n.add(blastResistance(30.0)))\n.translation(\"tile.blockRedstone.name\")\n\n.translation(TranslationProvider.of(LanternEnumTraits.YELLOW_FLOWER_TYPE))\n.build(\"minecraft\", \"yellow_flower\"),\nblockState -> (byte) blockState.getTraitValue(LanternEnumTraits.YELLOW_FLOWER_TYPE).get().getInternalId());\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\/\/\/ Red Flower \/\/\/\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\nregister(38, simpleBuilder()\n.traits(LanternEnumTraits.RED_FLOWER_TYPE)\n.defaultState(state -> state\n.withTrait(LanternEnumTraits.RED_FLOWER_TYPE, LanternPlantType.POPPY).get())\n.itemType(builder -> builder\n.keysProvider(collection -> collection\n.register(Keys.PLANT_TYPE, LanternPlantType.POPPY)))\n.selectionBox(BoundingBoxes.bush())\n.properties(builder -> builder\n.add(INSTANT_BROKEN)\n.add(PASSABLE))\n.translation(TranslationProvider.of(LanternEnumTraits.RED_FLOWER_TYPE))\n.build(\"minecraft\", \"red_flower\"),\nblockState -> (byte) blockState.getTraitValue(LanternEnumTraits.RED_FLOWER_TYPE).get().getInternalId());\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\/\/\/ Brown Mushroom \/\/\/\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\nregister(39, simpleBuilder()\n.selectionBox(BoundingBoxes.bush())\n.properties(builder -> builder\n.add(INSTANT_BROKEN)\n.add(PASSABLE)\n.add(lightEmission(1)))\n.translation(\"tile.mushroom.name\")\n.build(\"minecraft\", \"brown_mushroom\"));\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\/\/\/ Red Mushroom \/\/\/\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\nregister(40, simpleBuilder()\n.selectionBox(BoundingBoxes.bush())\n.properties(builder -> builder\n.add(INSTANT_BROKEN)\n.add(PASSABLE))\n.translation(\"tile.mushroom.name\")\n.build(\"minecraft\", \"red_mushroom\"));\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\/\/\/ Gold Block \/\/\/\n\n.build(\"minecraft\", \"cobblestone\"));\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\/\/\/ Planks \/\/\/\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\nregister(5, simpleBuilder()\n.trait(LanternEnumTraits.TREE_TYPE)\n.defaultState(state -> state.withTrait(LanternEnumTraits.TREE_TYPE, LanternTreeType.OAK).get())\n.itemType(builder -> builder\n.keysProvider(collection -> collection\n.register(Keys.TREE_TYPE, LanternTreeType.OAK)\n)\n)\n.properties(builder -> builder\n.add(hardness(2.0))\n.add(blastResistance(5.0))\n.add(flammableInfo(5, 20)))\n.translation(TranslationProvider.of(LanternEnumTraits.TREE_TYPE, type ->\ntr(\"tile.planks.\" + type.getTranslationKeyBase() + \".name\")))\n.build(\"minecraft\", \"planks\"),\nblockState -> (byte) blockState.getTraitValue(LanternEnumTraits.TREE_TYPE).get().getInternalId());\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\/\/\/ Sapling \/\/\/\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\nregister(6, simpleBuilder()\n.traits(LanternEnumTraits.TREE_TYPE, LanternIntegerTraits.SAPLING_GROWTH_STAGE)\n.defaultState(state -> state\n.withTrait(LanternEnumTraits.TREE_TYPE, LanternTreeType.OAK).get()\n.withTrait(LanternIntegerTraits.SAPLING_GROWTH_STAGE, 0).get())\n.itemType(builder -> builder\n.keysProvider(collection -> collection\n.register(Keys.TREE_TYPE, LanternTreeType.OAK)\n)\n)\n.properties(builder -> builder\n.add(PASSABLE)\n.add(INSTANT_BROKEN))\n.translation(TranslationProvider.of(LanternEnumTraits.TREE_TYPE, type ->\ntr(\"tile.sapling.\" + type.getTranslationKeyBase() + \".name\")))\n.build(\"minecraft\", \"sapling\"),\nblockState -> {\nfinal int type = blockState.getTraitValue(LanternEnumTraits.TREE_TYPE).get().getInternalId();\nfinal int stage = blockState.getTraitValue(LanternIntegerTraits.SAPLING_GROWTH_STAGE).get();\nreturn (byte) (stage << 3 | type);\n\n.build(\"minecraft\", \"cobblestone\"));\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\/\/\/ Planks \/\/\/\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\nregister(5, simpleBuilder()\n.trait(LanternEnumTraits.TREE_TYPE)\n.defaultState(state -> state.withTrait(LanternEnumTraits.TREE_TYPE, LanternTreeType.OAK).get())\n.itemType(builder -> builder\n.keysProvider(collection -> collection\n.register(Keys.TREE_TYPE, LanternTreeType.OAK)\n)\n)\n.properties(builder -> builder\n.add(hardness(2.0))\n.add(blastResistance(5.0))\n.add(flammableInfo(5, 20)))\n.translation(TranslationProvider.of(LanternEnumTraits.TREE_TYPE, type ->\ntr(\"tile.planks.\" + type.getTranslationKeyBase() + \".name\")))\n.build(\"minecraft\", \"planks\"),\nblockState -> (byte) blockState.getTraitValue(LanternEnumTraits.TREE_TYPE).get().getInternalId());\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\/\/\/ Sapling \/\/\/\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\nregister(6, simpleBuilder()\n.traits(LanternEnumTraits.TREE_TYPE, LanternIntegerTraits.SAPLING_GROWTH_STAGE)\n.defaultState(state -> state\n.withTrait(LanternEnumTraits.TREE_TYPE, LanternTreeType.OAK).get()\n.withTrait(LanternIntegerTraits.SAPLING_GROWTH_STAGE, 0).get())\n.itemType(builder -> builder\n.keysProvider(collection -> collection\n.register(Keys.TREE_TYPE, LanternTreeType.OAK)\n)\n)\n.properties(builder -> builder\n.add(PASSABLE)\n.add(INSTANT_BROKEN))\n.translation(TranslationProvider.of(LanternEnumTraits.TREE_TYPE, type ->\ntr(\"tile.sapling.\" + type.getTranslationKeyBase() + \".name\")))\n.build(\"minecraft\", \"sapling\"),\nblockState -> {\nfinal int type = blockState.getTraitValue(LanternEnumTraits.TREE_TYPE).get().getInternalId();\nfinal int stage = blockState.getTraitValue(LanternIntegerTraits.SAPLING_GROWTH_STAGE).get();\nreturn (byte) (stage << 3 | type);\n\n.build(\"minecraft\", \"cobblestone\"));\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\/\/\/ Planks \/\/\/\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\nregister(5, simpleBuilder()\n.trait(LanternEnumTraits.TREE_TYPE)\n.defaultState(state -> state.withTrait(LanternEnumTraits.TREE_TYPE, LanternTreeType.OAK).get())\n.itemType(builder -> builder\n.keysProvider(collection -> collection\n.register(Keys.TREE_TYPE, LanternTreeType.OAK)\n)\n)\n.properties(builder -> builder\n.add(hardness(2.0))\n.add(blastResistance(5.0))\n.add(flammableInfo(5, 20)))\n.translation(TranslationProvider.of(LanternEnumTraits.TREE_TYPE, type ->\ntr(\"tile.planks.\" + type.getTranslationKeyBase() + \".name\")))\n.build(\"minecraft\", \"planks\"),\nblockState -> (byte) blockState.getTraitValue(LanternEnumTraits.TREE_TYPE).get().getInternalId());\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\/\/\/ Sapling \/\/\/\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\nregister(6, simpleBuilder()\n.traits(LanternEnumTraits.TREE_TYPE, LanternIntegerTraits.SAPLING_GROWTH_STAGE)\n.defaultState(state -> state\n.withTrait(LanternEnumTraits.TREE_TYPE, LanternTreeType.OAK).get()\n.withTrait(LanternIntegerTraits.SAPLING_GROWTH_STAGE, 0).get())\n.itemType(builder -> builder\n.keysProvider(collection -> collection\n.register(Keys.TREE_TYPE, LanternTreeType.OAK)\n)\n)\n.properties(builder -> builder\n.add(PASSABLE)\n.add(INSTANT_BROKEN))\n.translation(TranslationProvider.of(LanternEnumTraits.TREE_TYPE, type ->\ntr(\"tile.sapling.\" + type.getTranslationKeyBase() + \".name\")))\n.build(\"minecraft\", \"sapling\"),\nblockState -> {\nfinal int type = blockState.getTraitValue(LanternEnumTraits.TREE_TYPE).get().getInternalId();\nfinal int stage = blockState.getTraitValue(LanternIntegerTraits.SAPLING_GROWTH_STAGE).get();\nreturn (byte) (stage << 3 | type);\n\n.withTrait(LanternEnumTraits.BED_PART, LanternBedPart.FOOT).get()\n.withTrait(LanternBooleanTraits.OCCUPIED, false).get())\n.properties(builder -> builder\n.add(hardness(0.2))\n.add(blastResistance(1.0)))\n.translation(\"tile.bed.name\")\n.build(\"minecraft\", \"bed\"),\nblockState -> {\nfinal Direction facing = blockState.getTraitValue(LanternEnumTraits.HORIZONTAL_FACING).get();\nint type = facing == Direction.SOUTH ? 0 : facing == Direction.WEST ? 1 :\nfacing == Direction.NORTH ? 2 : facing == Direction.EAST ? 3 : -1;\ncheckArgument(type != -1);\nif (blockState.getTraitValue(LanternBooleanTraits.OCCUPIED).get()) {\ntype |= 0x4;\n}\nif (blockState.getTraitValue(LanternEnumTraits.BED_PART).get() == LanternBedPart.HEAD) {\ntype |= 0x8;\n}\nreturn (byte) type;\n});\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\/\/\/ Golden Rail \/\/\/\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\nregister(27, simpleBuilder()\n.traits(LanternEnumTraits.STRAIGHT_RAIL_DIRECTION, LanternBooleanTraits.POWERED)\n.defaultState(state -> state\n.withTrait(LanternEnumTraits.STRAIGHT_RAIL_DIRECTION, LanternRailDirection.NORTH_SOUTH).get()\n.withTrait(LanternBooleanTraits.POWERED, false).get())\n.itemType()\n.selectionBox(BoundingBoxes::rail)\n.properties(builder -> builder\n.add(PASSABLE)\n.add(hardness(0.7))\n.add(blastResistance(3.5)))\n.translation(\"tile.goldenRail.name\")\n.build(\"minecraft\", \"golden_rail\"),\nblockState -> {\nint type = blockState.getTraitValue(LanternEnumTraits.STRAIGHT_RAIL_DIRECTION).get().getInternalId();\nif (blockState.getTraitValue(LanternBooleanTraits.POWERED).get()) {\ntype |= 0x8;\n}\nreturn (byte) type;\n});\n\n.withTrait(LanternEnumTraits.BED_PART, LanternBedPart.FOOT).get()\n.withTrait(LanternBooleanTraits.OCCUPIED, false).get())\n.properties(builder -> builder\n.add(hardness(0.2))\n.add(blastResistance(1.0)))\n.translation(\"tile.bed.name\")\n.build(\"minecraft\", \"bed\"),\nblockState -> {\nfinal Direction facing = blockState.getTraitValue(LanternEnumTraits.HORIZONTAL_FACING).get();\nint type = facing == Direction.SOUTH ? 0 : facing == Direction.WEST ? 1 :\nfacing == Direction.NORTH ? 2 : facing == Direction.EAST ? 3 : -1;\ncheckArgument(type != -1);\nif (blockState.getTraitValue(LanternBooleanTraits.OCCUPIED).get()) {\ntype |= 0x4;\n}\nif (blockState.getTraitValue(LanternEnumTraits.BED_PART).get() == LanternBedPart.HEAD) {\ntype |= 0x8;\n}\nreturn (byte) type;\n});\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\/\/\/ Golden Rail \/\/\/\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\nregister(27, simpleBuilder()\n.traits(LanternEnumTraits.STRAIGHT_RAIL_DIRECTION, LanternBooleanTraits.POWERED)\n.defaultState(state -> state\n.withTrait(LanternEnumTraits.STRAIGHT_RAIL_DIRECTION, LanternRailDirection.NORTH_SOUTH).get()\n.withTrait(LanternBooleanTraits.POWERED, false).get())\n.itemType()\n.selectionBox(BoundingBoxes::rail)\n.properties(builder -> builder\n.add(PASSABLE)\n.add(hardness(0.7))\n.add(blastResistance(3.5)))\n.translation(\"tile.goldenRail.name\")\n.build(\"minecraft\", \"golden_rail\"),\nblockState -> {\nint type = blockState.getTraitValue(LanternEnumTraits.STRAIGHT_RAIL_DIRECTION).get().getInternalId();\nif (blockState.getTraitValue(LanternBooleanTraits.POWERED).get()) {\ntype |= 0x8;\n}\nreturn (byte) type;\n});\n\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\/\/\/ Gold Block \/\/\/\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\nregister(41, simpleBuilder()\n.itemType()\n.properties(builder -> builder\n.add(hardness(3.0))\n.add(blastResistance(10.0)))\n.translation(\"tile.blockGold.name\")\n.build(\"minecraft\", \"gold_block\"));\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\/\/\/ Iron Block \/\/\/\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\nregister(42, simpleBuilder()\n.itemType()\n.properties(builder -> builder\n.add(hardness(5.0))\n.add(blastResistance(10.0)))\n.translation(\"tile.blockIron.name\")\n.build(\"minecraft\", \"iron_block\"));\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\/\/\/ Double Stone Slab 1 \/\/\/\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\nregister(43, doubleStoneSlab(LanternEnumTraits.STONE_SLAB1_TYPE, LanternSlabType.STONE)\n.translation(\"tile.stoneSlab.name\")\n.build(\"minecraft\", \"double_stone_slab\"),\nblockState -> doubleStoneSlabData(blockState, blockState.getTraitValue(LanternEnumTraits.STONE_SLAB1_TYPE).get().getInternalId()));\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\/\/\/ Stone Slab 1 \/\/\/\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\nregister(44, stoneSlab(LanternEnumTraits.STONE_SLAB1_TYPE, LanternSlabType.STONE,\n() -> BlockTypes.STONE_SLAB,\n() -> BlockTypes.DOUBLE_STONE_SLAB)\n.translation(\"tile.stoneSlab.name\")\n.collisionBox(BoundingBoxes::slab)\n.build(\"minecraft\", \"stone_slab\"),\nblockState -> stoneSlabData(blockState, blockState.getTraitValue(LanternEnumTraits.STONE_SLAB1_TYPE).get().getInternalId()));\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\/\/\/ Brick Block \/\/\/\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\nregister(45, simpleBuilder()\n.itemType()\n.properties(builder -> builder\n\nregister(27, simpleBuilder()\n.traits(LanternEnumTraits.STRAIGHT_RAIL_DIRECTION, LanternBooleanTraits.POWERED)\n.defaultState(state -> state\n.withTrait(LanternEnumTraits.STRAIGHT_RAIL_DIRECTION, LanternRailDirection.NORTH_SOUTH).get()\n.withTrait(LanternBooleanTraits.POWERED, false).get())\n.itemType()\n.selectionBox(BoundingBoxes::rail)\n.properties(builder -> builder\n.add(PASSABLE)\n.add(hardness(0.7))\n.add(blastResistance(3.5)))\n.translation(\"tile.goldenRail.name\")\n.build(\"minecraft\", \"golden_rail\"),\nblockState -> {\nint type = blockState.getTraitValue(LanternEnumTraits.STRAIGHT_RAIL_DIRECTION).get().getInternalId();\nif (blockState.getTraitValue(LanternBooleanTraits.POWERED).get()) {\ntype |= 0x8;\n}\nreturn (byte) type;\n});\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\/\/\/ Detector Rail \/\/\/\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\nregister(28, simpleBuilder()\n.traits(LanternEnumTraits.STRAIGHT_RAIL_DIRECTION, LanternBooleanTraits.POWERED)\n.defaultState(state -> state\n.withTrait(LanternEnumTraits.STRAIGHT_RAIL_DIRECTION, LanternRailDirection.NORTH_SOUTH).get()\n.withTrait(LanternBooleanTraits.POWERED, false).get())\n.itemType()\n.selectionBox(BoundingBoxes::rail)\n.properties(builder -> builder\n.add(PASSABLE)\n.add(hardness(0.7))\n.add(blastResistance(3.5)))\n.translation(\"tile.detectorRail.name\")\n.build(\"minecraft\", \"detector_rail\"),\nblockState -> {\nint type = blockState.getTraitValue(LanternEnumTraits.STRAIGHT_RAIL_DIRECTION).get().getInternalId();\nif (blockState.getTraitValue(LanternBooleanTraits.POWERED).get()) {\ntype |= 0x8;\n}\nreturn (byte) type;\n});\n\n@Override\npublic void registerDefaults() {\n\/\/ @formatter:off\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\/\/\/ Air \/\/\/\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\nregister(0, builder()\n.properties(PropertyProviderCollections.DEFAULT_GAS)\n.translation(\"tile.air.name\")\n.build(\"minecraft\", \"air\"));\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\/\/\/ Stone \/\/\/\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\nregister(1, simpleBuilder()\n.trait(LanternEnumTraits.STONE_TYPE)\n.defaultState(state -> state.withTrait(LanternEnumTraits.STONE_TYPE, LanternStoneType.STONE).get())\n.itemType(builder -> builder\n.keysProvider(collection -> collection\n.register(Keys.STONE_TYPE, LanternStoneType.STONE)\n)\n)\n.properties(builder -> builder\n.add(hardness(1.5))\n.add(blastResistance(30.0)))\n.translation(TranslationProvider.of(LanternEnumTraits.STONE_TYPE))\n.build(\"minecraft\", \"stone\"),\n\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\/\/\/ Gold Block \/\/\/\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\nregister(41, simpleBuilder()\n.itemType()\n.properties(builder -> builder\n.add(hardness(3.0))\n.add(blastResistance(10.0)))\n.translation(\"tile.blockGold.name\")\n.build(\"minecraft\", \"gold_block\"));\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\/\/\/ Iron Block \/\/\/\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\nregister(42, simpleBuilder()\n.itemType()\n.properties(builder -> builder\n.add(hardness(5.0))\n.add(blastResistance(10.0)))\n.translation(\"tile.blockIron.name\")\n.build(\"minecraft\", \"iron_block\"));\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\/\/\/ Double Stone Slab 1 \/\/\/\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\nregister(43, doubleStoneSlab(LanternEnumTraits.STONE_SLAB1_TYPE, LanternSlabType.STONE)\n.translation(\"tile.stoneSlab.name\")\n.build(\"minecraft\", \"double_stone_slab\"),\nblockState -> doubleStoneSlabData(blockState, blockState.getTraitValue(LanternEnumTraits.STONE_SLAB1_TYPE).get().getInternalId()));\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\/\/\/ Stone Slab 1 \/\/\/\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\nregister(44, stoneSlab(LanternEnumTraits.STONE_SLAB1_TYPE, LanternSlabType.STONE,\n() -> BlockTypes.STONE_SLAB,\n() -> BlockTypes.DOUBLE_STONE_SLAB)\n.translation(\"tile.stoneSlab.name\")\n.collisionBox(BoundingBoxes::slab)\n.build(\"minecraft\", \"stone_slab\"),\nblockState -> stoneSlabData(blockState, blockState.getTraitValue(LanternEnumTraits.STONE_SLAB1_TYPE).get().getInternalId()));\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\/\/\/ Brick Block \/\/\/\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\nregister(45, simpleBuilder()\n.itemType()\n.properties(builder -> builder\n\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\/\/\/ Gold Block \/\/\/\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\nregister(41, simpleBuilder()\n.itemType()\n.properties(builder -> builder\n.add(hardness(3.0))\n.add(blastResistance(10.0)))\n.translation(\"tile.blockGold.name\")\n.build(\"minecraft\", \"gold_block\"));\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\/\/\/ Iron Block \/\/\/\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\nregister(42, simpleBuilder()\n.itemType()\n.properties(builder -> builder\n.add(hardness(5.0))\n.add(blastResistance(10.0)))\n.translation(\"tile.blockIron.name\")\n.build(\"minecraft\", \"iron_block\"));\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\/\/\/ Double Stone Slab 1 \/\/\/\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\nregister(43, doubleStoneSlab(LanternEnumTraits.STONE_SLAB1_TYPE, LanternSlabType.STONE)\n.translation(\"tile.stoneSlab.name\")\n.build(\"minecraft\", \"double_stone_slab\"),\nblockState -> doubleStoneSlabData(blockState, blockState.getTraitValue(LanternEnumTraits.STONE_SLAB1_TYPE).get().getInternalId()));\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\/\/\/ Stone Slab 1 \/\/\/\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\nregister(44, stoneSlab(LanternEnumTraits.STONE_SLAB1_TYPE, LanternSlabType.STONE,\n() -> BlockTypes.STONE_SLAB,\n() -> BlockTypes.DOUBLE_STONE_SLAB)\n.translation(\"tile.stoneSlab.name\")\n.collisionBox(BoundingBoxes::slab)\n.build(\"minecraft\", \"stone_slab\"),\nblockState -> stoneSlabData(blockState, blockState.getTraitValue(LanternEnumTraits.STONE_SLAB1_TYPE).get().getInternalId()));\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\/\/\/ Brick Block \/\/\/\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\nregister(45, simpleBuilder()\n.itemType()\n.properties(builder -> builder\n\nregister(46, simpleBuilder()\n.trait(LanternBooleanTraits.EXPLODE)\n.defaultState(state -> state\n.withTrait(LanternBooleanTraits.EXPLODE, false).get())\n.itemType()\n.properties(builder -> builder\n.add(INSTANT_BROKEN))\n.translation(\"tile.tnt.name\")\n.build(\"minecraft\", \"tnt\"),\nblockState -> (byte) (blockState.getTraitValue(LanternBooleanTraits.EXPLODE).get() ? 1 : 0));\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\/\/\/ Bookshelf \/\/\/\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\nregister(47, simpleBuilder()\n.itemType()\n.properties(builder -> builder\n.add(hardness(1.5))\n.add(blastResistance(7.5)))\n.translation(\"tile.bookshelf.name\")\n.build(\"minecraft\", \"bookshelf\"));\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\/\/\/ Mossy Cobblestone \/\/\/\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\nregister(48, simpleBuilder()\n.itemType()\n.properties(builder -> builder\n.add(hardness(2.0))\n.add(blastResistance(10.0)))\n.translation(\"tile.stoneMoss.name\")\n.build(\"minecraft\", \"mossy_cobblestone\"));\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\/\/\/ Obsidian \/\/\/\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\nregister(49, simpleBuilder()\n.itemType()\n.properties(builder -> builder\n.add(hardness(50.0))\n.add(blastResistance(2000.0)))\n.translation(\"tile.obsidian.name\")\n.build(\"minecraft\", \"obsidian\"));\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\/\/\/ Torch \/\/\/\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\n.itemType()\n.tileEntityType(() -> TileEntityTypes.ENDER_CHEST)\n.properties(builder -> builder\n.add(hardness(22.5))\n.add(blastResistance(3000.0))\n.add(lightEmission(7)))\n.translation(\"tile.enderChest.name\")\n.collisionBox(BoundingBoxes.chest())\n.behaviors(pipeline -> pipeline\n.add(new HorizontalRotationPlacementBehavior())\n.add(new EnderChestInteractionBehavior()))\n.build(\"minecraft\", \"ender_chest\"),\nthis::horizontalFacingData);\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\/\/\/ Trapped Chest \/\/\/\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\nregister(146, chestBuilder()\n.translation(\"tile.chestTrap.name\")\n.build(\"minecraft\", \"trapped_chest\"),\nthis::horizontalFacingData);\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\/\/\/ Weighted Pressure Plate (Light) \/\/\/\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\nregister(147, weightedPressurePlateBuilder()\n.translation(\"tile.weightedPlate_light.name\")\n.build(\"minecraft\", \"light_weighted_pressure_plate\"),\nthis::weightedPressurePlateData);\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\/\/\/ Weighted Pressure Plate (Heavy) \/\/\/\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\nregister(148, weightedPressurePlateBuilder()\n.translation(\"tile.weightedPlate_heavy.name\")\n.build(\"minecraft\", \"heavy_weighted_pressure_plate\"),\nthis::weightedPressurePlateData);\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\/\/\/ Redstone Block \/\/\/\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\nregister(152, simpleBuilder()\n.itemType()\n.properties(builder -> builder\n.add(hardness(5.0))\n.add(blastResistance(30.0)))\n.translation(\"tile.blockRedstone.name\")\n\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\/\/\/ Gold Block \/\/\/\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\nregister(41, simpleBuilder()\n.itemType()\n.properties(builder -> builder\n.add(hardness(3.0))\n.add(blastResistance(10.0)))\n.translation(\"tile.blockGold.name\")\n.build(\"minecraft\", \"gold_block\"));\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\/\/\/ Iron Block \/\/\/\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\nregister(42, simpleBuilder()\n.itemType()\n.properties(builder -> builder\n.add(hardness(5.0))\n.add(blastResistance(10.0)))\n.translation(\"tile.blockIron.name\")\n.build(\"minecraft\", \"iron_block\"));\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\/\/\/ Double Stone Slab 1 \/\/\/\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\nregister(43, doubleStoneSlab(LanternEnumTraits.STONE_SLAB1_TYPE, LanternSlabType.STONE)\n.translation(\"tile.stoneSlab.name\")\n.build(\"minecraft\", \"double_stone_slab\"),\nblockState -> doubleStoneSlabData(blockState, blockState.getTraitValue(LanternEnumTraits.STONE_SLAB1_TYPE).get().getInternalId()));\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\/\/\/ Stone Slab 1 \/\/\/\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\nregister(44, stoneSlab(LanternEnumTraits.STONE_SLAB1_TYPE, LanternSlabType.STONE,\n() -> BlockTypes.STONE_SLAB,\n() -> BlockTypes.DOUBLE_STONE_SLAB)\n.translation(\"tile.stoneSlab.name\")\n.collisionBox(BoundingBoxes::slab)\n.build(\"minecraft\", \"stone_slab\"),\nblockState -> stoneSlabData(blockState, blockState.getTraitValue(LanternEnumTraits.STONE_SLAB1_TYPE).get().getInternalId()));\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\/\/\/ Brick Block \/\/\/\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\nregister(45, simpleBuilder()\n.itemType()\n.properties(builder -> builder\n\n.properties(builder -> builder\n.add(INSTANT_BROKEN)\n.add(PASSABLE)\n.add(replaceable(true)))\n.selectionBox(BoundingBoxes.bush())\n.itemType()\n.translation(\"tile.deadbush.name\")\n.build(\"minecraft\", \"deadbush\"));\n\/\/ TODO: 33\n\/\/ TODO: 34\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\/\/\/ Wool \/\/\/\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\nregister(35, dyedBuilder(\"tile.wool.%s.name\")\n.properties(builder -> builder\n.add(hardness(0.8))\n.add(blastResistance(4.0)))\n.build(\"minecraft\", \"wool\"),\nthis::dyedData);\n\/\/ TODO: 36\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\/\/\/ Yellow Flower \/\/\/\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\nregister(37, simpleBuilder()\n.traits(LanternEnumTraits.YELLOW_FLOWER_TYPE)\n.defaultState(state -> state\n.withTrait(LanternEnumTraits.YELLOW_FLOWER_TYPE, LanternPlantType.DANDELION).get())\n.itemType(builder -> builder\n.keysProvider(collection -> collection\n.register(Keys.PLANT_TYPE, LanternPlantType.DANDELION)))\n.selectionBox(BoundingBoxes.bush())\n.properties(builder -> builder\n.add(INSTANT_BROKEN)\n.add(PASSABLE))\n.translation(TranslationProvider.of(LanternEnumTraits.YELLOW_FLOWER_TYPE))\n.build(\"minecraft\", \"yellow_flower\"),\nblockState -> (byte) blockState.getTraitValue(LanternEnumTraits.YELLOW_FLOWER_TYPE).get().getInternalId());\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\/\/\/ Red Flower \/\/\/\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\nregister(38, simpleBuilder()\n.traits(LanternEnumTraits.RED_FLOWER_TYPE)\n.defaultState(state -> state\n\n.properties(builder -> builder\n.add(INSTANT_BROKEN)\n.add(PASSABLE)\n.add(replaceable(true)))\n.selectionBox(BoundingBoxes.bush())\n.itemType()\n.translation(\"tile.deadbush.name\")\n.build(\"minecraft\", \"deadbush\"));\n\/\/ TODO: 33\n\/\/ TODO: 34\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\/\/\/ Wool \/\/\/\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\nregister(35, dyedBuilder(\"tile.wool.%s.name\")\n.properties(builder -> builder\n.add(hardness(0.8))\n.add(blastResistance(4.0)))\n.build(\"minecraft\", \"wool\"),\nthis::dyedData);\n\/\/ TODO: 36\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\/\/\/ Yellow Flower \/\/\/\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\nregister(37, simpleBuilder()\n.traits(LanternEnumTraits.YELLOW_FLOWER_TYPE)\n.defaultState(state -> state\n.withTrait(LanternEnumTraits.YELLOW_FLOWER_TYPE, LanternPlantType.DANDELION).get())\n.itemType(builder -> builder\n.keysProvider(collection -> collection\n.register(Keys.PLANT_TYPE, LanternPlantType.DANDELION)))\n.selectionBox(BoundingBoxes.bush())\n.properties(builder -> builder\n.add(INSTANT_BROKEN)\n.add(PASSABLE))\n.translation(TranslationProvider.of(LanternEnumTraits.YELLOW_FLOWER_TYPE))\n.build(\"minecraft\", \"yellow_flower\"),\nblockState -> (byte) blockState.getTraitValue(LanternEnumTraits.YELLOW_FLOWER_TYPE).get().getInternalId());\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\/\/\/ Red Flower \/\/\/\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\nregister(38, simpleBuilder()\n.traits(LanternEnumTraits.RED_FLOWER_TYPE)\n.defaultState(state -> state\n\n.properties(builder -> builder\n.add(INSTANT_BROKEN)\n.add(PASSABLE)\n.add(replaceable(true)))\n.selectionBox(BoundingBoxes.bush())\n.itemType()\n.translation(\"tile.deadbush.name\")\n.build(\"minecraft\", \"deadbush\"));\n\/\/ TODO: 33\n\/\/ TODO: 34\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\/\/\/ Wool \/\/\/\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\nregister(35, dyedBuilder(\"tile.wool.%s.name\")\n.properties(builder -> builder\n.add(hardness(0.8))\n.add(blastResistance(4.0)))\n.build(\"minecraft\", \"wool\"),\nthis::dyedData);\n\/\/ TODO: 36\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\/\/\/ Yellow Flower \/\/\/\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\nregister(37, simpleBuilder()\n.traits(LanternEnumTraits.YELLOW_FLOWER_TYPE)\n.defaultState(state -> state\n.withTrait(LanternEnumTraits.YELLOW_FLOWER_TYPE, LanternPlantType.DANDELION).get())\n.itemType(builder -> builder\n.keysProvider(collection -> collection\n.register(Keys.PLANT_TYPE, LanternPlantType.DANDELION)))\n.selectionBox(BoundingBoxes.bush())\n.properties(builder -> builder\n.add(INSTANT_BROKEN)\n.add(PASSABLE))\n.translation(TranslationProvider.of(LanternEnumTraits.YELLOW_FLOWER_TYPE))\n.build(\"minecraft\", \"yellow_flower\"),\nblockState -> (byte) blockState.getTraitValue(LanternEnumTraits.YELLOW_FLOWER_TYPE).get().getInternalId());\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\/\/\/ Red Flower \/\/\/\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\nregister(38, simpleBuilder()\n.traits(LanternEnumTraits.RED_FLOWER_TYPE)\n.defaultState(state -> state\n\n.properties(builder -> builder\n.add(INSTANT_BROKEN)\n.add(PASSABLE)\n.add(replaceable(true)))\n.selectionBox(BoundingBoxes.bush())\n.itemType()\n.translation(\"tile.deadbush.name\")\n.build(\"minecraft\", \"deadbush\"));\n\/\/ TODO: 33\n\/\/ TODO: 34\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\/\/\/ Wool \/\/\/\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\nregister(35, dyedBuilder(\"tile.wool.%s.name\")\n.properties(builder -> builder\n.add(hardness(0.8))\n.add(blastResistance(4.0)))\n.build(\"minecraft\", \"wool\"),\nthis::dyedData);\n\/\/ TODO: 36\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\/\/\/ Yellow Flower \/\/\/\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\nregister(37, simpleBuilder()\n.traits(LanternEnumTraits.YELLOW_FLOWER_TYPE)\n.defaultState(state -> state\n.withTrait(LanternEnumTraits.YELLOW_FLOWER_TYPE, LanternPlantType.DANDELION).get())\n.itemType(builder -> builder\n.keysProvider(collection -> collection\n.register(Keys.PLANT_TYPE, LanternPlantType.DANDELION)))\n.selectionBox(BoundingBoxes.bush())\n.properties(builder -> builder\n.add(INSTANT_BROKEN)\n.add(PASSABLE))\n.translation(TranslationProvider.of(LanternEnumTraits.YELLOW_FLOWER_TYPE))\n.build(\"minecraft\", \"yellow_flower\"),\nblockState -> (byte) blockState.getTraitValue(LanternEnumTraits.YELLOW_FLOWER_TYPE).get().getInternalId());\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\/\/\/ Red Flower \/\/\/\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\nregister(38, simpleBuilder()\n.traits(LanternEnumTraits.RED_FLOWER_TYPE)\n.defaultState(state -> state\n\n.properties(builder -> builder\n.add(INSTANT_BROKEN)\n.add(PASSABLE)\n.add(replaceable(true)))\n.selectionBox(BoundingBoxes.bush())\n.itemType()\n.translation(\"tile.deadbush.name\")\n.build(\"minecraft\", \"deadbush\"));\n\/\/ TODO: 33\n\/\/ TODO: 34\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\/\/\/ Wool \/\/\/\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\nregister(35, dyedBuilder(\"tile.wool.%s.name\")\n.properties(builder -> builder\n.add(hardness(0.8))\n.add(blastResistance(4.0)))\n.build(\"minecraft\", \"wool\"),\nthis::dyedData);\n\/\/ TODO: 36\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\/\/\/ Yellow Flower \/\/\/\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\nregister(37, simpleBuilder()\n.traits(LanternEnumTraits.YELLOW_FLOWER_TYPE)\n.defaultState(state -> state\n.withTrait(LanternEnumTraits.YELLOW_FLOWER_TYPE, LanternPlantType.DANDELION).get())\n.itemType(builder -> builder\n.keysProvider(collection -> collection\n.register(Keys.PLANT_TYPE, LanternPlantType.DANDELION)))\n.selectionBox(BoundingBoxes.bush())\n.properties(builder -> builder\n.add(INSTANT_BROKEN)\n.add(PASSABLE))\n.translation(TranslationProvider.of(LanternEnumTraits.YELLOW_FLOWER_TYPE))\n.build(\"minecraft\", \"yellow_flower\"),\nblockState -> (byte) blockState.getTraitValue(LanternEnumTraits.YELLOW_FLOWER_TYPE).get().getInternalId());\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\/\/\/ Red Flower \/\/\/\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\nregister(38, simpleBuilder()\n.traits(LanternEnumTraits.RED_FLOWER_TYPE)\n.defaultState(state -> state\n\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\/\/\/ Gold Block \/\/\/\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\nregister(41, simpleBuilder()\n.itemType()\n.properties(builder -> builder\n.add(hardness(3.0))\n.add(blastResistance(10.0)))\n.translation(\"tile.blockGold.name\")\n.build(\"minecraft\", \"gold_block\"));\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\/\/\/ Iron Block \/\/\/\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\nregister(42, simpleBuilder()\n.itemType()\n.properties(builder -> builder\n.add(hardness(5.0))\n.add(blastResistance(10.0)))\n.translation(\"tile.blockIron.name\")\n.build(\"minecraft\", \"iron_block\"));\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\/\/\/ Double Stone Slab 1 \/\/\/\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\nregister(43, doubleStoneSlab(LanternEnumTraits.STONE_SLAB1_TYPE, LanternSlabType.STONE)\n.translation(\"tile.stoneSlab.name\")\n.build(\"minecraft\", \"double_stone_slab\"),\nblockState -> doubleStoneSlabData(blockState, blockState.getTraitValue(LanternEnumTraits.STONE_SLAB1_TYPE).get().getInternalId()));\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\/\/\/ Stone Slab 1 \/\/\/\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\nregister(44, stoneSlab(LanternEnumTraits.STONE_SLAB1_TYPE, LanternSlabType.STONE,\n() -> BlockTypes.STONE_SLAB,\n() -> BlockTypes.DOUBLE_STONE_SLAB)\n.translation(\"tile.stoneSlab.name\")\n.collisionBox(BoundingBoxes::slab)\n.build(\"minecraft\", \"stone_slab\"),\nblockState -> stoneSlabData(blockState, blockState.getTraitValue(LanternEnumTraits.STONE_SLAB1_TYPE).get().getInternalId()));\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\/\/\/ Brick Block \/\/\/\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\nregister(45, simpleBuilder()\n.itemType()\n.properties(builder -> builder\n\n.properties(builder -> builder\n.add(INSTANT_BROKEN)\n.add(PASSABLE)\n.add(replaceable(true)))\n.selectionBox(BoundingBoxes.bush())\n.itemType()\n.translation(\"tile.deadbush.name\")\n.build(\"minecraft\", \"deadbush\"));\n\/\/ TODO: 33\n\/\/ TODO: 34\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\/\/\/ Wool \/\/\/\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\nregister(35, dyedBuilder(\"tile.wool.%s.name\")\n.properties(builder -> builder\n.add(hardness(0.8))\n.add(blastResistance(4.0)))\n.build(\"minecraft\", \"wool\"),\nthis::dyedData);\n\/\/ TODO: 36\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\/\/\/ Yellow Flower \/\/\/\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\nregister(37, simpleBuilder()\n.traits(LanternEnumTraits.YELLOW_FLOWER_TYPE)\n.defaultState(state -> state\n.withTrait(LanternEnumTraits.YELLOW_FLOWER_TYPE, LanternPlantType.DANDELION).get())\n.itemType(builder -> builder\n.keysProvider(collection -> collection\n.register(Keys.PLANT_TYPE, LanternPlantType.DANDELION)))\n.selectionBox(BoundingBoxes.bush())\n.properties(builder -> builder\n.add(INSTANT_BROKEN)\n.add(PASSABLE))\n.translation(TranslationProvider.of(LanternEnumTraits.YELLOW_FLOWER_TYPE))\n.build(\"minecraft\", \"yellow_flower\"),\nblockState -> (byte) blockState.getTraitValue(LanternEnumTraits.YELLOW_FLOWER_TYPE).get().getInternalId());\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\/\/\/ Red Flower \/\/\/\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\nregister(38, simpleBuilder()\n.traits(LanternEnumTraits.RED_FLOWER_TYPE)\n.defaultState(state -> state\n\n.translation(TranslationProvider.of(LanternEnumTraits.YELLOW_FLOWER_TYPE))\n.build(\"minecraft\", \"yellow_flower\"),\nblockState -> (byte) blockState.getTraitValue(LanternEnumTraits.YELLOW_FLOWER_TYPE).get().getInternalId());\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\/\/\/ Red Flower \/\/\/\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\nregister(38, simpleBuilder()\n.traits(LanternEnumTraits.RED_FLOWER_TYPE)\n.defaultState(state -> state\n.withTrait(LanternEnumTraits.RED_FLOWER_TYPE, LanternPlantType.POPPY).get())\n.itemType(builder -> builder\n.keysProvider(collection -> collection\n.register(Keys.PLANT_TYPE, LanternPlantType.POPPY)))\n.selectionBox(BoundingBoxes.bush())\n.properties(builder -> builder\n.add(INSTANT_BROKEN)\n.add(PASSABLE))\n.translation(TranslationProvider.of(LanternEnumTraits.RED_FLOWER_TYPE))\n.build(\"minecraft\", \"red_flower\"),\nblockState -> (byte) blockState.getTraitValue(LanternEnumTraits.RED_FLOWER_TYPE).get().getInternalId());\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\/\/\/ Brown Mushroom \/\/\/\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\nregister(39, simpleBuilder()\n.selectionBox(BoundingBoxes.bush())\n.properties(builder -> builder\n.add(INSTANT_BROKEN)\n.add(PASSABLE)\n.add(lightEmission(1)))\n.translation(\"tile.mushroom.name\")\n.build(\"minecraft\", \"brown_mushroom\"));\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\/\/\/ Red Mushroom \/\/\/\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\nregister(40, simpleBuilder()\n.selectionBox(BoundingBoxes.bush())\n.properties(builder -> builder\n.add(INSTANT_BROKEN)\n.add(PASSABLE))\n.translation(\"tile.mushroom.name\")\n.build(\"minecraft\", \"red_mushroom\"));\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\/\/\/ Gold Block \/\/\/\n\n.translation(TranslationProvider.of(LanternEnumTraits.YELLOW_FLOWER_TYPE))\n.build(\"minecraft\", \"yellow_flower\"),\nblockState -> (byte) blockState.getTraitValue(LanternEnumTraits.YELLOW_FLOWER_TYPE).get().getInternalId());\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\/\/\/ Red Flower \/\/\/\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\nregister(38, simpleBuilder()\n.traits(LanternEnumTraits.RED_FLOWER_TYPE)\n.defaultState(state -> state\n.withTrait(LanternEnumTraits.RED_FLOWER_TYPE, LanternPlantType.POPPY).get())\n.itemType(builder -> builder\n.keysProvider(collection -> collection\n.register(Keys.PLANT_TYPE, LanternPlantType.POPPY)))\n.selectionBox(BoundingBoxes.bush())\n.properties(builder -> builder\n.add(INSTANT_BROKEN)\n.add(PASSABLE))\n.translation(TranslationProvider.of(LanternEnumTraits.RED_FLOWER_TYPE))\n.build(\"minecraft\", \"red_flower\"),\nblockState -> (byte) blockState.getTraitValue(LanternEnumTraits.RED_FLOWER_TYPE).get().getInternalId());\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\/\/\/ Brown Mushroom \/\/\/\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\nregister(39, simpleBuilder()\n.selectionBox(BoundingBoxes.bush())\n.properties(builder -> builder\n.add(INSTANT_BROKEN)\n.add(PASSABLE)\n.add(lightEmission(1)))\n.translation(\"tile.mushroom.name\")\n.build(\"minecraft\", \"brown_mushroom\"));\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\/\/\/ Red Mushroom \/\/\/\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\nregister(40, simpleBuilder()\n.selectionBox(BoundingBoxes.bush())\n.properties(builder -> builder\n.add(INSTANT_BROKEN)\n.add(PASSABLE))\n.translation(\"tile.mushroom.name\")\n.build(\"minecraft\", \"red_mushroom\"));\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\/\/\/ Gold Block \/\/\/\n\nregister(27, simpleBuilder()\n.traits(LanternEnumTraits.STRAIGHT_RAIL_DIRECTION, LanternBooleanTraits.POWERED)\n.defaultState(state -> state\n.withTrait(LanternEnumTraits.STRAIGHT_RAIL_DIRECTION, LanternRailDirection.NORTH_SOUTH).get()\n.withTrait(LanternBooleanTraits.POWERED, false).get())\n.itemType()\n.selectionBox(BoundingBoxes::rail)\n.properties(builder -> builder\n.add(PASSABLE)\n.add(hardness(0.7))\n.add(blastResistance(3.5)))\n.translation(\"tile.goldenRail.name\")\n.build(\"minecraft\", \"golden_rail\"),\nblockState -> {\nint type = blockState.getTraitValue(LanternEnumTraits.STRAIGHT_RAIL_DIRECTION).get().getInternalId();\nif (blockState.getTraitValue(LanternBooleanTraits.POWERED).get()) {\ntype |= 0x8;\n}\nreturn (byte) type;\n});\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\/\/\/ Detector Rail \/\/\/\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\nregister(28, simpleBuilder()\n.traits(LanternEnumTraits.STRAIGHT_RAIL_DIRECTION, LanternBooleanTraits.POWERED)\n.defaultState(state -> state\n.withTrait(LanternEnumTraits.STRAIGHT_RAIL_DIRECTION, LanternRailDirection.NORTH_SOUTH).get()\n.withTrait(LanternBooleanTraits.POWERED, false).get())\n.itemType()\n.selectionBox(BoundingBoxes::rail)\n.properties(builder -> builder\n.add(PASSABLE)\n.add(hardness(0.7))\n.add(blastResistance(3.5)))\n.translation(\"tile.detectorRail.name\")\n.build(\"minecraft\", \"detector_rail\"),\nblockState -> {\nint type = blockState.getTraitValue(LanternEnumTraits.STRAIGHT_RAIL_DIRECTION).get().getInternalId();\nif (blockState.getTraitValue(LanternBooleanTraits.POWERED).get()) {\ntype |= 0x8;\n}\nreturn (byte) type;\n});\n\n.translation(TranslationProvider.of(LanternEnumTraits.YELLOW_FLOWER_TYPE))\n.build(\"minecraft\", \"yellow_flower\"),\nblockState -> (byte) blockState.getTraitValue(LanternEnumTraits.YELLOW_FLOWER_TYPE).get().getInternalId());\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\/\/\/ Red Flower \/\/\/\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\nregister(38, simpleBuilder()\n.traits(LanternEnumTraits.RED_FLOWER_TYPE)\n.defaultState(state -> state\n.withTrait(LanternEnumTraits.RED_FLOWER_TYPE, LanternPlantType.POPPY).get())\n.itemType(builder -> builder\n.keysProvider(collection -> collection\n.register(Keys.PLANT_TYPE, LanternPlantType.POPPY)))\n.selectionBox(BoundingBoxes.bush())\n.properties(builder -> builder\n.add(INSTANT_BROKEN)\n.add(PASSABLE))\n.translation(TranslationProvider.of(LanternEnumTraits.RED_FLOWER_TYPE))\n.build(\"minecraft\", \"red_flower\"),\nblockState -> (byte) blockState.getTraitValue(LanternEnumTraits.RED_FLOWER_TYPE).get().getInternalId());\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\/\/\/ Brown Mushroom \/\/\/\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\nregister(39, simpleBuilder()\n.selectionBox(BoundingBoxes.bush())\n.properties(builder -> builder\n.add(INSTANT_BROKEN)\n.add(PASSABLE)\n.add(lightEmission(1)))\n.translation(\"tile.mushroom.name\")\n.build(\"minecraft\", \"brown_mushroom\"));\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\/\/\/ Red Mushroom \/\/\/\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\nregister(40, simpleBuilder()\n.selectionBox(BoundingBoxes.bush())\n.properties(builder -> builder\n.add(INSTANT_BROKEN)\n.add(PASSABLE))\n.translation(\"tile.mushroom.name\")\n.build(\"minecraft\", \"red_mushroom\"));\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\/\/\/ Gold Block \/\/\/\n\n@Override\npublic void registerDefaults() {\n\/\/ @formatter:off\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\/\/\/ Air \/\/\/\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\nregister(0, builder()\n.properties(PropertyProviderCollections.DEFAULT_GAS)\n.translation(\"tile.air.name\")\n.build(\"minecraft\", \"air\"));\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\/\/\/ Stone \/\/\/\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\nregister(1, simpleBuilder()\n.trait(LanternEnumTraits.STONE_TYPE)\n.defaultState(state -> state.withTrait(LanternEnumTraits.STONE_TYPE, LanternStoneType.STONE).get())\n.itemType(builder -> builder\n.keysProvider(collection -> collection\n.register(Keys.STONE_TYPE, LanternStoneType.STONE)\n)\n)\n.properties(builder -> builder\n.add(hardness(1.5))\n.add(blastResistance(30.0)))\n.translation(TranslationProvider.of(LanternEnumTraits.STONE_TYPE))\n.build(\"minecraft\", \"stone\"),\n\n@Override\npublic void registerDefaults() {\n\/\/ @formatter:off\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\/\/\/ Air \/\/\/\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\nregister(0, builder()\n.properties(PropertyProviderCollections.DEFAULT_GAS)\n.translation(\"tile.air.name\")\n.build(\"minecraft\", \"air\"));\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\/\/\/ Stone \/\/\/\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\nregister(1, simpleBuilder()\n.trait(LanternEnumTraits.STONE_TYPE)\n.defaultState(state -> state.withTrait(LanternEnumTraits.STONE_TYPE, LanternStoneType.STONE).get())\n.itemType(builder -> builder\n.keysProvider(collection -> collection\n.register(Keys.STONE_TYPE, LanternStoneType.STONE)\n)\n)\n.properties(builder -> builder\n.add(hardness(1.5))\n.add(blastResistance(30.0)))\n.translation(TranslationProvider.of(LanternEnumTraits.STONE_TYPE))\n.build(\"minecraft\", \"stone\"),\n\n.properties(builder -> builder\n.add(hardness(1.0))\n.add(blastResistance(5.0)))\n.behaviors(pipeline -> pipeline\n.add(new SignInteractionBehavior()))\n.tileEntityType(() -> TileEntityTypes.BANNER)\n.build(\"minecraft\", \"standing_banner\"),\nblockState -> blockState.getTraitValue(LanternIntegerTraits.ROTATION).get().byteValue());\nregister(177, simpleBuilder()\n.trait(LanternEnumTraits.HORIZONTAL_FACING)\n.defaultState(state -> state\n.withTrait(LanternEnumTraits.HORIZONTAL_FACING, Direction.NORTH).get())\n.properties(builder -> builder\n.add(hardness(1.0))\n.add(blastResistance(5.0)))\n.behaviors(pipeline -> pipeline\n.add(new SignInteractionBehavior()))\n.tileEntityType(() -> TileEntityTypes.BANNER)\n.build(\"minecraft\", \"wall_banner\"),\nthis::horizontalFacingData);\n\/\/ @formatter:on\n}","label":[1,1,0,0]}

{"id":24673,"original_code":"private void validateZoneAvailable(String tenantId, String zone) throws IllegalArgumentException {\n    List<ZoneDTO> zones;\n    try {\n      zones = zoneApi.getAvailableZones(tenantId);\n    } catch (ResourceAccessException e) {\n      \/\/ need to do something here to handle things more gracefully.\n      throw new RuntimeException(\"Unable to validate zones.\", e);\n    }\n    boolean found = zones.stream().anyMatch(z -> z.getName().equals(zone));\n    log.debug(\"Found {} zones for tenant\", zoneApi.getAvailableZones(tenantId).size());\n    if (!found) throw new IllegalArgumentException(\"Provided zone does not exist: \" + zone);\n  }","code":"private void validateZoneAvailable(String tenantId, String zone) throws IllegalArgumentException {\n    List<ZoneDTO> zones;\n    try {\n      zones = zoneApi.getAvailableZones(tenantId);\n    } catch (ResourceAccessException e) {\n     \n      throw new RuntimeException(\"Unable to validate zones.\", e);\n    }\n    boolean found = zones.stream().anyMatch(z -> z.getName().equals(zone));\n    log.debug(\"Found {} zones for tenant\", zoneApi.getAvailableZones(tenantId).size());\n    if (!found) throw new IllegalArgumentException(\"Provided zone does not exist: \" + zone);\n  }","cleancode":"private void validatezoneavailable(string tenantid, string zone) throws illegalargumentexception { list<zonedto> zones; try { zones = zoneapi.getavailablezones(tenantid); } catch (resourceaccessexception e) { throw new runtimeexception(\"unable to validate zones.\", e); } boolean found = zones.stream().anymatch(z -> z.getname().equals(zone)); log.debug(\"found {} zones for tenant\", zoneapi.getavailablezones(tenantid).size()); if (!found) throw new illegalargumentexception(\"provided zone does not exist: \" + zone); }","comment":"\/** * checks if the provided zone is an option for the client to connect to. * any zone provided must have previously been created by zonemanagement. * * @param tenantid the tenantid of the connecting envoy. * @param zone the zone provided in the envoysummary. * @throws illegalargumentexception if the zone is not found. *\/\n\/\/ need to do something here to handle things more gracefully.","repo":"racker\/salus-telemetry-ambassador","code_context_2":"private void validateZoneAvailable(String tenantId, String zone) throws IllegalArgumentException {\nList<ZoneDTO> zones;\ntry {\nzones = zoneApi.getAvailableZones(tenantId);\n} catch (ResourceAccessException e) {\n\/\/ need to do something here to handle things more gracefully.\nthrow new RuntimeException(\"Unable to validate zones.\", e);\n}\nboolean found = zones.stream().anyMatch(z -> z.getName().equals(zone));\nlog.debug(\"Found {} zones for tenant\", zoneApi.getAvailableZones(tenantId).size());\nif (!found) throw new IllegalArgumentException(\"Provided zone does not exist: \" + zone);\n}\n\nzones = zoneApi.getAvailableZones(tenantId);\n} catch (ResourceAccessException e) {\n\/\/ need to do something here to handle things more gracefully.\nthrow new RuntimeException(\"Unable to validate zones.\", e);\n}","code_context_10":"private void validateZoneAvailable(String tenantId, String zone) throws IllegalArgumentException {\nList<ZoneDTO> zones;\ntry {\nzones = zoneApi.getAvailableZones(tenantId);\n} catch (ResourceAccessException e) {\n\/\/ need to do something here to handle things more gracefully.\nthrow new RuntimeException(\"Unable to validate zones.\", e);\n}\nboolean found = zones.stream().anyMatch(z -> z.getName().equals(zone));\nlog.debug(\"Found {} zones for tenant\", zoneApi.getAvailableZones(tenantId).size());\nif (!found) throw new IllegalArgumentException(\"Provided zone does not exist: \" + zone);\n}\n\nprivate void validateZoneAvailable(String tenantId, String zone) throws IllegalArgumentException {\nList<ZoneDTO> zones;\ntry {\nzones = zoneApi.getAvailableZones(tenantId);\n} catch (ResourceAccessException e) {\n\/\/ need to do something here to handle things more gracefully.\nthrow new RuntimeException(\"Unable to validate zones.\", e);\n}\nboolean found = zones.stream().anyMatch(z -> z.getName().equals(zone));\nlog.debug(\"Found {} zones for tenant\", zoneApi.getAvailableZones(tenantId).size());\nif (!found) throw new IllegalArgumentException(\"Provided zone does not exist: \" + zone);\n}","code_context_20":"private void validateZoneAvailable(String tenantId, String zone) throws IllegalArgumentException {\nList<ZoneDTO> zones;\ntry {\nzones = zoneApi.getAvailableZones(tenantId);\n} catch (ResourceAccessException e) {\n\/\/ need to do something here to handle things more gracefully.\nthrow new RuntimeException(\"Unable to validate zones.\", e);\n}\nboolean found = zones.stream().anyMatch(z -> z.getName().equals(zone));\nlog.debug(\"Found {} zones for tenant\", zoneApi.getAvailableZones(tenantId).size());\nif (!found) throw new IllegalArgumentException(\"Provided zone does not exist: \" + zone);\n}\n\nprivate void validateZoneAvailable(String tenantId, String zone) throws IllegalArgumentException {\nList<ZoneDTO> zones;\ntry {\nzones = zoneApi.getAvailableZones(tenantId);\n} catch (ResourceAccessException e) {\n\/\/ need to do something here to handle things more gracefully.\nthrow new RuntimeException(\"Unable to validate zones.\", e);\n}\nboolean found = zones.stream().anyMatch(z -> z.getName().equals(zone));\nlog.debug(\"Found {} zones for tenant\", zoneApi.getAvailableZones(tenantId).size());\nif (!found) throw new IllegalArgumentException(\"Provided zone does not exist: \" + zone);\n}","label":[1,0,0,0]}
{"id":16532,"original_code":"public String getBlockId() {\n            final BlockEntity be = serverWorld.getBlockEntity(this.blockPos); \/\/ FIXME do we need to check at y+1?\n            return String.valueOf(Registry.BLOCK_ENTITY_TYPE.getId(be.getType()));\n        }","code":"public String getBlockId() {\n            final BlockEntity be = serverWorld.getBlockEntity(this.blockPos);\n            return String.valueOf(Registry.BLOCK_ENTITY_TYPE.getId(be.getType()));\n        }","cleancode":"public string getblockid() { final blockentity be = serverworld.getblockentity(this.blockpos); return string.valueof(registry.block_entity_type.getid(be.gettype())); }","comment":"\/** * return the id of the block that the spawn is happening on. *\/\n\/\/ fixme do we need to check at y+1?","repo":"pcal43\/mob-filter","code_context_2":"public String getBlockId() {\nfinal BlockEntity be = serverWorld.getBlockEntity(this.blockPos); \/\/ FIXME do we need to check at y+1?\nreturn String.valueOf(Registry.BLOCK_ENTITY_TYPE.getId(be.getType()));\n}\n\npublic String getBlockId() {\nfinal BlockEntity be = serverWorld.getBlockEntity(this.blockPos); \/\/ FIXME do we need to check at y+1?\nreturn String.valueOf(Registry.BLOCK_ENTITY_TYPE.getId(be.getType()));\n}","code_context_10":"public String getBlockId() {\nfinal BlockEntity be = serverWorld.getBlockEntity(this.blockPos); \/\/ FIXME do we need to check at y+1?\nreturn String.valueOf(Registry.BLOCK_ENTITY_TYPE.getId(be.getType()));\n}\n\npublic String getBlockId() {\nfinal BlockEntity be = serverWorld.getBlockEntity(this.blockPos); \/\/ FIXME do we need to check at y+1?\nreturn String.valueOf(Registry.BLOCK_ENTITY_TYPE.getId(be.getType()));\n}","code_context_20":"public String getBlockId() {\nfinal BlockEntity be = serverWorld.getBlockEntity(this.blockPos); \/\/ FIXME do we need to check at y+1?\nreturn String.valueOf(Registry.BLOCK_ENTITY_TYPE.getId(be.getType()));\n}\n\npublic String getBlockId() {\nfinal BlockEntity be = serverWorld.getBlockEntity(this.blockPos); \/\/ FIXME do we need to check at y+1?\nreturn String.valueOf(Registry.BLOCK_ENTITY_TYPE.getId(be.getType()));\n}","label":[0,0,1,0]}
{"id":24727,"original_code":"@Override\n    public List<DeviceStorageRoot> getSecondaryDeviceStorageRoots() {\n        ArrayList<DeviceStorageRoot> secondaryStorageRoot = new ArrayList<>(1);\n        if (secondaryStoragePath != null) {\n            secondaryStorageRoot.add(new DeviceStorageRoot(secondaryStoragePath, secondaryStoragePath, DeviceStorageRoot.Type.SECONDARY));\n        }\n        return secondaryStorageRoot;\n    }","code":"@Override\n    public List<DeviceStorageRoot> getSecondaryDeviceStorageRoots() {\n        ArrayList<DeviceStorageRoot> secondaryStorageRoot = new ArrayList<>(1);\n        if (secondaryStoragePath != null) {\n            secondaryStorageRoot.add(new DeviceStorageRoot(secondaryStoragePath, secondaryStoragePath, DeviceStorageRoot.Type.SECONDARY));\n        }\n        return secondaryStorageRoot;\n    }","cleancode":"@override public list<devicestorageroot> getsecondarydevicestorageroots() { arraylist<devicestorageroot> secondarystorageroot = new arraylist<>(1); if (secondarystoragepath != null) { secondarystorageroot.add(new devicestorageroot(secondarystoragepath, secondarystoragepath, devicestorageroot.type.secondary)); } return secondarystorageroot; }","comment":"\/\/ todo: not sure what to do about this now that we have base and absolute path.","repo":"novoda\/storage-path-finder","code_context_2":"@Override\npublic List<DeviceStorageRoot> getSecondaryDeviceStorageRoots() {\nArrayList<DeviceStorageRoot> secondaryStorageRoot = new ArrayList<>(1);\nif (secondaryStoragePath != null) {\nsecondaryStorageRoot.add(new DeviceStorageRoot(secondaryStoragePath, secondaryStoragePath, DeviceStorageRoot.Type.SECONDARY));\n}\nreturn secondaryStorageRoot;\n}","code_context_10":"@Override\npublic List<DeviceStorageRoot> getSecondaryDeviceStorageRoots() {\nArrayList<DeviceStorageRoot> secondaryStorageRoot = new ArrayList<>(1);\nif (secondaryStoragePath != null) {\nsecondaryStorageRoot.add(new DeviceStorageRoot(secondaryStoragePath, secondaryStoragePath, DeviceStorageRoot.Type.SECONDARY));\n}\nreturn secondaryStorageRoot;\n}","code_context_20":"@Override\npublic List<DeviceStorageRoot> getSecondaryDeviceStorageRoots() {\nArrayList<DeviceStorageRoot> secondaryStorageRoot = new ArrayList<>(1);\nif (secondaryStoragePath != null) {\nsecondaryStorageRoot.add(new DeviceStorageRoot(secondaryStoragePath, secondaryStoragePath, DeviceStorageRoot.Type.SECONDARY));\n}\nreturn secondaryStorageRoot;\n}","label":[1,0,0,0]}
{"id":8431,"original_code":"@JsonGetter(\"amount\")\n    public int getAmount ( ) { \n        return this.amount;\n    }","code":"@JsonGetter(\"amount\")\n    public int getAmount ( ) { \n        return this.amount;\n    }","cleancode":"@jsongetter(\"amount\") public int getamount ( ) { return this.amount; }","comment":"\/** getter * todo: write general description for this method *\/","repo":"pagarme\/pagarme-core-api-java","code_context_2":"@JsonGetter(\"amount\")\npublic int getAmount ( ) {\nreturn this.amount;\n}","code_context_10":"@JsonGetter(\"amount\")\npublic int getAmount ( ) {\nreturn this.amount;\n}","code_context_20":"@JsonGetter(\"amount\")\npublic int getAmount ( ) {\nreturn this.amount;\n}","label":[0,0,0,0]}
{"id":8432,"original_code":"@JsonSetter(\"amount\")\n    public void setAmount (int value) { \n        this.amount = value;\n    }","code":"@JsonSetter(\"amount\")\n    public void setAmount (int value) { \n        this.amount = value;\n    }","cleancode":"@jsonsetter(\"amount\") public void setamount (int value) { this.amount = value; }","comment":"\/** setter * todo: write general description for this method *\/","repo":"pagarme\/pagarme-core-api-java","code_context_2":"@JsonSetter(\"amount\")\npublic void setAmount (int value) {\nthis.amount = value;\n}","code_context_10":"@JsonSetter(\"amount\")\npublic void setAmount (int value) {\nthis.amount = value;\n}","code_context_20":"@JsonSetter(\"amount\")\npublic void setAmount (int value) {\nthis.amount = value;\n}","label":[0,0,0,0]}
{"id":8433,"original_code":"@JsonGetter(\"description\")\n    public String getDescription ( ) { \n        return this.description;\n    }","code":"@JsonGetter(\"description\")\n    public String getDescription ( ) { \n        return this.description;\n    }","cleancode":"@jsongetter(\"description\") public string getdescription ( ) { return this.description; }","comment":"\/** getter * todo: write general description for this method *\/","repo":"pagarme\/pagarme-core-api-java","code_context_2":"@JsonGetter(\"description\")\npublic String getDescription ( ) {\nreturn this.description;\n}","code_context_10":"@JsonGetter(\"description\")\npublic String getDescription ( ) {\nreturn this.description;\n}","code_context_20":"@JsonGetter(\"description\")\npublic String getDescription ( ) {\nreturn this.description;\n}","label":[0,0,0,0]}
{"id":8434,"original_code":"@JsonSetter(\"description\")\n    public void setDescription (String value) { \n        this.description = value;\n    }","code":"@JsonSetter(\"description\")\n    public void setDescription (String value) { \n        this.description = value;\n    }","cleancode":"@jsonsetter(\"description\") public void setdescription (string value) { this.description = value; }","comment":"\/** setter * todo: write general description for this method *\/","repo":"pagarme\/pagarme-core-api-java","code_context_2":"@JsonSetter(\"description\")\npublic void setDescription (String value) {\nthis.description = value;\n}","code_context_10":"@JsonSetter(\"description\")\npublic void setDescription (String value) {\nthis.description = value;\n}","code_context_20":"@JsonSetter(\"description\")\npublic void setDescription (String value) {\nthis.description = value;\n}","label":[0,0,0,0]}
{"id":8435,"original_code":"@JsonGetter(\"quantity\")\n    public int getQuantity ( ) { \n        return this.quantity;\n    }","code":"@JsonGetter(\"quantity\")\n    public int getQuantity ( ) { \n        return this.quantity;\n    }","cleancode":"@jsongetter(\"quantity\") public int getquantity ( ) { return this.quantity; }","comment":"\/** getter * todo: write general description for this method *\/","repo":"pagarme\/pagarme-core-api-java","code_context_2":"@JsonGetter(\"quantity\")\npublic int getQuantity ( ) {\nreturn this.quantity;\n}","code_context_10":"@JsonGetter(\"quantity\")\npublic int getQuantity ( ) {\nreturn this.quantity;\n}","code_context_20":"@JsonGetter(\"quantity\")\npublic int getQuantity ( ) {\nreturn this.quantity;\n}","label":[0,0,0,0]}
{"id":8436,"original_code":"@JsonSetter(\"quantity\")\n    public void setQuantity (int value) { \n        this.quantity = value;\n    }","code":"@JsonSetter(\"quantity\")\n    public void setQuantity (int value) { \n        this.quantity = value;\n    }","cleancode":"@jsonsetter(\"quantity\") public void setquantity (int value) { this.quantity = value; }","comment":"\/** setter * todo: write general description for this method *\/","repo":"pagarme\/pagarme-core-api-java","code_context_2":"@JsonSetter(\"quantity\")\npublic void setQuantity (int value) {\nthis.quantity = value;\n}","code_context_10":"@JsonSetter(\"quantity\")\npublic void setQuantity (int value) {\nthis.quantity = value;\n}","code_context_20":"@JsonSetter(\"quantity\")\npublic void setQuantity (int value) {\nthis.quantity = value;\n}","label":[0,0,0,0]}
{"id":8437,"original_code":"@JsonGetter(\"category\")\n    public String getCategory ( ) { \n        return this.category;\n    }","code":"@JsonGetter(\"category\")\n    public String getCategory ( ) { \n        return this.category;\n    }","cleancode":"@jsongetter(\"category\") public string getcategory ( ) { return this.category; }","comment":"\/** getter * todo: write general description for this method *\/","repo":"pagarme\/pagarme-core-api-java","code_context_2":"@JsonGetter(\"category\")\npublic String getCategory ( ) {\nreturn this.category;\n}","code_context_10":"@JsonGetter(\"category\")\npublic String getCategory ( ) {\nreturn this.category;\n}","code_context_20":"@JsonGetter(\"category\")\npublic String getCategory ( ) {\nreturn this.category;\n}","label":[0,0,0,0]}
{"id":8438,"original_code":"@JsonSetter(\"category\")\n    public void setCategory (String value) { \n        this.category = value;\n    }","code":"@JsonSetter(\"category\")\n    public void setCategory (String value) { \n        this.category = value;\n    }","cleancode":"@jsonsetter(\"category\") public void setcategory (string value) { this.category = value; }","comment":"\/** setter * todo: write general description for this method *\/","repo":"pagarme\/pagarme-core-api-java","code_context_2":"@JsonSetter(\"category\")\npublic void setCategory (String value) {\nthis.category = value;\n}","code_context_10":"@JsonSetter(\"category\")\npublic void setCategory (String value) {\nthis.category = value;\n}","code_context_20":"@JsonSetter(\"category\")\npublic void setCategory (String value) {\nthis.category = value;\n}","label":[0,0,0,0]}
{"id":8485,"original_code":"private void updateCartCount(int count){\n        if (txtItemCount != null) {\n            txtItemCount.setText(String.valueOf(count));\n        }\n    }","code":"private void updateCartCount(int count){\n        if (txtItemCount != null) {\n            txtItemCount.setText(String.valueOf(count));\n        }\n    }","cleancode":"private void updatecartcount(int count){ if (txtitemcount != null) { txtitemcount.settext(string.valueof(count)); } }","comment":"\/\/ not called","repo":"nilesh14\/FMC","code_context_2":"private void updateCartCount(int count){\nif (txtItemCount != null) {\ntxtItemCount.setText(String.valueOf(count));\n}\n}","code_context_10":"private void updateCartCount(int count){\nif (txtItemCount != null) {\ntxtItemCount.setText(String.valueOf(count));\n}\n}","code_context_20":"private void updateCartCount(int count){\nif (txtItemCount != null) {\ntxtItemCount.setText(String.valueOf(count));\n}\n}","label":[1,0,0,0]}
{"id":16767,"original_code":"@Override\n      public Runnable getConsumer(final KafkaSynchronizedConsumerPool pool, final KafkaStream<byte[], byte[]> stream) {\n        return new Runnable() {          \n          @Override\n          public void run() {\n            ConsumerIterator<byte[],byte[]> iter = stream.iterator();\n            byte[] sipHashKey = frontend.keystore.getKey(KeyStore.SIPHASH_KAFKA_PLASMA_FRONTEND_IN);\n            byte[] aesKey = frontend.keystore.getKey(KeyStore.AES_KAFKA_PLASMA_FRONTEND_IN);\n            \/\/ Iterate on the messages\n            TDeserializer deserializer = new TDeserializer(new TCompactProtocol.Factory());\n            KafkaOffsetCounters counters = pool.getCounters();\n            \/\/ TODO(hbs): allow setting of writeBufferSize\n            try {\n            while (iter.hasNext()) {\n              \/\/\n              \/\/ Since the cal to 'next' may block, we need to first\n              \/\/ check that there is a message available\n              \/\/\n              boolean nonEmpty = iter.nonEmpty();\n              if (nonEmpty) {\n                MessageAndMetadata<byte[], byte[]> msg = iter.next();\n                counters.count(msg.partition(), msg.offset());\n                byte[] data = msg.message();\n                Sensision.update(SensisionConstants.SENSISION_CLASS_PLASMA_FRONTEND_KAFKA_MESSAGES, Sensision.EMPTY_LABELS, 1);\n                Sensision.update(SensisionConstants.SENSISION_CLASS_PLASMA_FRONTEND_KAFKA_BYTES, Sensision.EMPTY_LABELS, data.length);\n                if (null != sipHashKey) {\n                  data = CryptoUtils.removeMAC(sipHashKey, data);\n                }\n                \/\/ Skip data whose MAC was not verified successfully\n                if (null == data) {\n                  Sensision.update(SensisionConstants.SENSISION_CLASS_PLASMA_FRONTEND_KAFKA_INVALIDMACS, Sensision.EMPTY_LABELS, 1);\n                  continue;\n                }\n                \/\/ Unwrap data if need be\n                if (null != aesKey) {\n                  data = CryptoUtils.unwrap(aesKey, data);\n                }\n                \/\/ Skip data that was not unwrapped successfuly\n                if (null == data) {\n                  Sensision.update(SensisionConstants.SENSISION_CLASS_PLASMA_FRONTEND_KAFKA_INVALIDCIPHERS, Sensision.EMPTY_LABELS, 1);\n                  continue;\n                }\n                \/\/\n                \/\/ Extract KafkaDataMessage\n                \/\/\n                KafkaDataMessage tmsg = new KafkaDataMessage();\n                deserializer.deserialize(tmsg, data);\n                switch(tmsg.getType()) {\n                  case STORE:\n                    GTSEncoder encoder = new GTSEncoder(0L, null, tmsg.getData());\n                    encoder.setClassId(tmsg.getClassId());\n                    encoder.setLabelsId(tmsg.getLabelsId());\n                    frontend.dispatch(encoder);\n                    break;\n                  case DELETE:\n                  case ARCHIVE:\n                    break;\n                  default:\n                    throw new RuntimeException(\"Invalid message type.\");\n                }            \n              } else {\n                \/\/ Sleep a tiny while\n                try {\n                  Thread.sleep(1L);\n                } catch (InterruptedException ie) {             \n                }\n              }          \n            }        \n          } catch (Throwable t) {\n            t.printStackTrace(System.err);\n          } finally {\n            \/\/ Set abort to true in case we exit the 'run' method\n            pool.getAbort().set(true);\n          }\n          }\n        };\n      }","code":"@Override\n      public Runnable getConsumer(final KafkaSynchronizedConsumerPool pool, final KafkaStream<byte[], byte[]> stream) {\n        return new Runnable() {          \n          @Override\n          public void run() {\n            ConsumerIterator<byte[],byte[]> iter = stream.iterator();\n            byte[] sipHashKey = frontend.keystore.getKey(KeyStore.SIPHASH_KAFKA_PLASMA_FRONTEND_IN);\n            byte[] aesKey = frontend.keystore.getKey(KeyStore.AES_KAFKA_PLASMA_FRONTEND_IN);\n           \n            TDeserializer deserializer = new TDeserializer(new TCompactProtocol.Factory());\n            KafkaOffsetCounters counters = pool.getCounters();\n           \n            try {\n            while (iter.hasNext()) {\n             \n             \n             \n             \n              boolean nonEmpty = iter.nonEmpty();\n              if (nonEmpty) {\n                MessageAndMetadata<byte[], byte[]> msg = iter.next();\n                counters.count(msg.partition(), msg.offset());\n                byte[] data = msg.message();\n                Sensision.update(SensisionConstants.SENSISION_CLASS_PLASMA_FRONTEND_KAFKA_MESSAGES, Sensision.EMPTY_LABELS, 1);\n                Sensision.update(SensisionConstants.SENSISION_CLASS_PLASMA_FRONTEND_KAFKA_BYTES, Sensision.EMPTY_LABELS, data.length);\n                if (null != sipHashKey) {\n                  data = CryptoUtils.removeMAC(sipHashKey, data);\n                }\n               \n                if (null == data) {\n                  Sensision.update(SensisionConstants.SENSISION_CLASS_PLASMA_FRONTEND_KAFKA_INVALIDMACS, Sensision.EMPTY_LABELS, 1);\n                  continue;\n                }\n               \n                if (null != aesKey) {\n                  data = CryptoUtils.unwrap(aesKey, data);\n                }\n               \n                if (null == data) {\n                  Sensision.update(SensisionConstants.SENSISION_CLASS_PLASMA_FRONTEND_KAFKA_INVALIDCIPHERS, Sensision.EMPTY_LABELS, 1);\n                  continue;\n                }\n               \n               \n               \n                KafkaDataMessage tmsg = new KafkaDataMessage();\n                deserializer.deserialize(tmsg, data);\n                switch(tmsg.getType()) {\n                  case STORE:\n                    GTSEncoder encoder = new GTSEncoder(0L, null, tmsg.getData());\n                    encoder.setClassId(tmsg.getClassId());\n                    encoder.setLabelsId(tmsg.getLabelsId());\n                    frontend.dispatch(encoder);\n                    break;\n                  case DELETE:\n                  case ARCHIVE:\n                    break;\n                  default:\n                    throw new RuntimeException(\"Invalid message type.\");\n                }            \n              } else {\n               \n                try {\n                  Thread.sleep(1L);\n                } catch (InterruptedException ie) {             \n                }\n              }          \n            }        \n          } catch (Throwable t) {\n            t.printStackTrace(System.err);\n          } finally {\n           \n            pool.getAbort().set(true);\n          }\n          }\n        };\n      }","cleancode":"@override public runnable getconsumer(final kafkasynchronizedconsumerpool pool, final kafkastream<byte[], byte[]> stream) { return new runnable() { @override public void run() { consumeriterator<byte[],byte[]> iter = stream.iterator(); byte[] siphashkey = frontend.keystore.getkey(keystore.siphash_kafka_plasma_frontend_in); byte[] aeskey = frontend.keystore.getkey(keystore.aes_kafka_plasma_frontend_in); tdeserializer deserializer = new tdeserializer(new tcompactprotocol.factory()); kafkaoffsetcounters counters = pool.getcounters(); try { while (iter.hasnext()) { boolean nonempty = iter.nonempty(); if (nonempty) { messageandmetadata<byte[], byte[]> msg = iter.next(); counters.count(msg.partition(), msg.offset()); byte[] data = msg.message(); sensision.update(sensisionconstants.sensision_class_plasma_frontend_kafka_messages, sensision.empty_labels, 1); sensision.update(sensisionconstants.sensision_class_plasma_frontend_kafka_bytes, sensision.empty_labels, data.length); if (null != siphashkey) { data = cryptoutils.removemac(siphashkey, data); } if (null == data) { sensision.update(sensisionconstants.sensision_class_plasma_frontend_kafka_invalidmacs, sensision.empty_labels, 1); continue; } if (null != aeskey) { data = cryptoutils.unwrap(aeskey, data); } if (null == data) { sensision.update(sensisionconstants.sensision_class_plasma_frontend_kafka_invalidciphers, sensision.empty_labels, 1); continue; } kafkadatamessage tmsg = new kafkadatamessage(); deserializer.deserialize(tmsg, data); switch(tmsg.gettype()) { case store: gtsencoder encoder = new gtsencoder(0l, null, tmsg.getdata()); encoder.setclassid(tmsg.getclassid()); encoder.setlabelsid(tmsg.getlabelsid()); frontend.dispatch(encoder); break; case delete: case archive: break; default: throw new runtimeexception(\"invalid message type.\"); } } else { try { thread.sleep(1l); } catch (interruptedexception ie) { } } } } catch (throwable t) { t.printstacktrace(system.err); } finally { pool.getabort().set(true); } } }; }","comment":"\/\/ iterate on the messages\n\/\/ todo(hbs): allow setting of writebuffersize\n\/\/ \/\/ since the cal to 'next' may block, we need to first \/\/ check that there is a message available \/\/\n\/\/ skip data whose mac was not verified successfully\n\/\/ unwrap data if need be\n\/\/ skip data that was not unwrapped successfuly\n\/\/ \/\/ extract kafkadatamessage \/\/\n\/\/ sleep a tiny while\n\/\/ set abort to true in case we exit the 'run' method","repo":"randomboolean\/warp10-platform","code_context_2":"byte[] sipHashKey = frontend.keystore.getKey(KeyStore.SIPHASH_KAFKA_PLASMA_FRONTEND_IN);\nbyte[] aesKey = frontend.keystore.getKey(KeyStore.AES_KAFKA_PLASMA_FRONTEND_IN);\n\/\/ Iterate on the messages\nTDeserializer deserializer = new TDeserializer(new TCompactProtocol.Factory());\nKafkaOffsetCounters counters = pool.getCounters();\n\nTDeserializer deserializer = new TDeserializer(new TCompactProtocol.Factory());\nKafkaOffsetCounters counters = pool.getCounters();\n\/\/ TODO(hbs): allow setting of writeBufferSize\ntry {\nwhile (iter.hasNext()) {\n\nbyte[] sipHashKey = frontend.keystore.getKey(KeyStore.SIPHASH_KAFKA_PLASMA_FRONTEND_IN);\nbyte[] aesKey = frontend.keystore.getKey(KeyStore.AES_KAFKA_PLASMA_FRONTEND_IN);\n\/\/ Iterate on the messages\nTDeserializer deserializer = new TDeserializer(new TCompactProtocol.Factory());\nKafkaOffsetCounters counters = pool.getCounters();\n\/\/ TODO(hbs): allow setting of writeBufferSize\ntry {\nwhile (iter.hasNext()) {\n\ndata = CryptoUtils.removeMAC(sipHashKey, data);\n}\n\/\/ Skip data whose MAC was not verified successfully\nif (null == data) {\nSensision.update(SensisionConstants.SENSISION_CLASS_PLASMA_FRONTEND_KAFKA_INVALIDMACS, Sensision.EMPTY_LABELS, 1);\n\ncontinue;\n}\n\/\/ Unwrap data if need be\nif (null != aesKey) {\ndata = CryptoUtils.unwrap(aesKey, data);\n\ndata = CryptoUtils.unwrap(aesKey, data);\n}\n\/\/ Skip data that was not unwrapped successfuly\nif (null == data) {\nSensision.update(SensisionConstants.SENSISION_CLASS_PLASMA_FRONTEND_KAFKA_INVALIDCIPHERS, Sensision.EMPTY_LABELS, 1);\n\nbyte[] sipHashKey = frontend.keystore.getKey(KeyStore.SIPHASH_KAFKA_PLASMA_FRONTEND_IN);\nbyte[] aesKey = frontend.keystore.getKey(KeyStore.AES_KAFKA_PLASMA_FRONTEND_IN);\n\/\/ Iterate on the messages\nTDeserializer deserializer = new TDeserializer(new TCompactProtocol.Factory());\nKafkaOffsetCounters counters = pool.getCounters();\n\/\/ TODO(hbs): allow setting of writeBufferSize\ntry {\n\n}\n} else {\n\/\/ Sleep a tiny while\ntry {\nThread.sleep(1L);\n\nt.printStackTrace(System.err);\n} finally {\n\/\/ Set abort to true in case we exit the 'run' method\npool.getAbort().set(true);\n}","code_context_10":"@Override\npublic Runnable getConsumer(final KafkaSynchronizedConsumerPool pool, final KafkaStream<byte[], byte[]> stream) {\nreturn new Runnable() {\n@Override\npublic void run() {\nConsumerIterator<byte[],byte[]> iter = stream.iterator();\nbyte[] sipHashKey = frontend.keystore.getKey(KeyStore.SIPHASH_KAFKA_PLASMA_FRONTEND_IN);\nbyte[] aesKey = frontend.keystore.getKey(KeyStore.AES_KAFKA_PLASMA_FRONTEND_IN);\n\/\/ Iterate on the messages\nTDeserializer deserializer = new TDeserializer(new TCompactProtocol.Factory());\nKafkaOffsetCounters counters = pool.getCounters();\n\/\/ TODO(hbs): allow setting of writeBufferSize\ntry {\nwhile (iter.hasNext()) {\n\/\/\n\/\/ Since the cal to 'next' may block, we need to first\n\/\/ check that there is a message available\n\/\/\nboolean nonEmpty = iter.nonEmpty();\n\npublic Runnable getConsumer(final KafkaSynchronizedConsumerPool pool, final KafkaStream<byte[], byte[]> stream) {\nreturn new Runnable() {\n@Override\npublic void run() {\nConsumerIterator<byte[],byte[]> iter = stream.iterator();\nbyte[] sipHashKey = frontend.keystore.getKey(KeyStore.SIPHASH_KAFKA_PLASMA_FRONTEND_IN);\nbyte[] aesKey = frontend.keystore.getKey(KeyStore.AES_KAFKA_PLASMA_FRONTEND_IN);\n\/\/ Iterate on the messages\nTDeserializer deserializer = new TDeserializer(new TCompactProtocol.Factory());\nKafkaOffsetCounters counters = pool.getCounters();\n\/\/ TODO(hbs): allow setting of writeBufferSize\ntry {\nwhile (iter.hasNext()) {\n\/\/\n\/\/ Since the cal to 'next' may block, we need to first\n\/\/ check that there is a message available\n\/\/\nboolean nonEmpty = iter.nonEmpty();\nif (nonEmpty) {\nMessageAndMetadata<byte[], byte[]> msg = iter.next();\ncounters.count(msg.partition(), msg.offset());\n\n@Override\npublic Runnable getConsumer(final KafkaSynchronizedConsumerPool pool, final KafkaStream<byte[], byte[]> stream) {\nreturn new Runnable() {\n@Override\npublic void run() {\nConsumerIterator<byte[],byte[]> iter = stream.iterator();\nbyte[] sipHashKey = frontend.keystore.getKey(KeyStore.SIPHASH_KAFKA_PLASMA_FRONTEND_IN);\nbyte[] aesKey = frontend.keystore.getKey(KeyStore.AES_KAFKA_PLASMA_FRONTEND_IN);\n\/\/ Iterate on the messages\nTDeserializer deserializer = new TDeserializer(new TCompactProtocol.Factory());\nKafkaOffsetCounters counters = pool.getCounters();\n\/\/ TODO(hbs): allow setting of writeBufferSize\ntry {\nwhile (iter.hasNext()) {\n\/\/\n\/\/ Since the cal to 'next' may block, we need to first\n\/\/ check that there is a message available\n\/\/\nboolean nonEmpty = iter.nonEmpty();\nif (nonEmpty) {\nMessageAndMetadata<byte[], byte[]> msg = iter.next();\ncounters.count(msg.partition(), msg.offset());\n\nboolean nonEmpty = iter.nonEmpty();\nif (nonEmpty) {\nMessageAndMetadata<byte[], byte[]> msg = iter.next();\ncounters.count(msg.partition(), msg.offset());\nbyte[] data = msg.message();\nSensision.update(SensisionConstants.SENSISION_CLASS_PLASMA_FRONTEND_KAFKA_MESSAGES, Sensision.EMPTY_LABELS, 1);\nSensision.update(SensisionConstants.SENSISION_CLASS_PLASMA_FRONTEND_KAFKA_BYTES, Sensision.EMPTY_LABELS, data.length);\nif (null != sipHashKey) {\ndata = CryptoUtils.removeMAC(sipHashKey, data);\n}\n\/\/ Skip data whose MAC was not verified successfully\nif (null == data) {\nSensision.update(SensisionConstants.SENSISION_CLASS_PLASMA_FRONTEND_KAFKA_INVALIDMACS, Sensision.EMPTY_LABELS, 1);\ncontinue;\n}\n\/\/ Unwrap data if need be\nif (null != aesKey) {\ndata = CryptoUtils.unwrap(aesKey, data);\n}\n\/\/ Skip data that was not unwrapped successfuly\nif (null == data) {\n\nSensision.update(SensisionConstants.SENSISION_CLASS_PLASMA_FRONTEND_KAFKA_MESSAGES, Sensision.EMPTY_LABELS, 1);\nSensision.update(SensisionConstants.SENSISION_CLASS_PLASMA_FRONTEND_KAFKA_BYTES, Sensision.EMPTY_LABELS, data.length);\nif (null != sipHashKey) {\ndata = CryptoUtils.removeMAC(sipHashKey, data);\n}\n\/\/ Skip data whose MAC was not verified successfully\nif (null == data) {\nSensision.update(SensisionConstants.SENSISION_CLASS_PLASMA_FRONTEND_KAFKA_INVALIDMACS, Sensision.EMPTY_LABELS, 1);\ncontinue;\n}\n\/\/ Unwrap data if need be\nif (null != aesKey) {\ndata = CryptoUtils.unwrap(aesKey, data);\n}\n\/\/ Skip data that was not unwrapped successfuly\nif (null == data) {\nSensision.update(SensisionConstants.SENSISION_CLASS_PLASMA_FRONTEND_KAFKA_INVALIDCIPHERS, Sensision.EMPTY_LABELS, 1);\ncontinue;\n}\n\/\/\n\/\/ Extract KafkaDataMessage\n\n}\n\/\/ Skip data whose MAC was not verified successfully\nif (null == data) {\nSensision.update(SensisionConstants.SENSISION_CLASS_PLASMA_FRONTEND_KAFKA_INVALIDMACS, Sensision.EMPTY_LABELS, 1);\ncontinue;\n}\n\/\/ Unwrap data if need be\nif (null != aesKey) {\ndata = CryptoUtils.unwrap(aesKey, data);\n}\n\/\/ Skip data that was not unwrapped successfuly\nif (null == data) {\nSensision.update(SensisionConstants.SENSISION_CLASS_PLASMA_FRONTEND_KAFKA_INVALIDCIPHERS, Sensision.EMPTY_LABELS, 1);\ncontinue;\n}\n\/\/\n\/\/ Extract KafkaDataMessage\n\/\/\nKafkaDataMessage tmsg = new KafkaDataMessage();\ndeserializer.deserialize(tmsg, data);\nswitch(tmsg.getType()) {\n\n@Override\npublic Runnable getConsumer(final KafkaSynchronizedConsumerPool pool, final KafkaStream<byte[], byte[]> stream) {\nreturn new Runnable() {\n@Override\npublic void run() {\nConsumerIterator<byte[],byte[]> iter = stream.iterator();\nbyte[] sipHashKey = frontend.keystore.getKey(KeyStore.SIPHASH_KAFKA_PLASMA_FRONTEND_IN);\nbyte[] aesKey = frontend.keystore.getKey(KeyStore.AES_KAFKA_PLASMA_FRONTEND_IN);\n\/\/ Iterate on the messages\nTDeserializer deserializer = new TDeserializer(new TCompactProtocol.Factory());\nKafkaOffsetCounters counters = pool.getCounters();\n\/\/ TODO(hbs): allow setting of writeBufferSize\ntry {\nwhile (iter.hasNext()) {\n\/\/\n\/\/ Since the cal to 'next' may block, we need to first\n\/\/ check that there is a message available\n\/\/\nboolean nonEmpty = iter.nonEmpty();\nif (nonEmpty) {\nMessageAndMetadata<byte[], byte[]> msg = iter.next();\n\nencoder.setLabelsId(tmsg.getLabelsId());\nfrontend.dispatch(encoder);\nbreak;\ncase DELETE:\ncase ARCHIVE:\nbreak;\ndefault:\nthrow new RuntimeException(\"Invalid message type.\");\n}\n} else {\n\/\/ Sleep a tiny while\ntry {\nThread.sleep(1L);\n} catch (InterruptedException ie) {\n}\n}\n}\n} catch (Throwable t) {\nt.printStackTrace(System.err);\n} finally {\n\/\/ Set abort to true in case we exit the 'run' method\n\n\/\/ Sleep a tiny while\ntry {\nThread.sleep(1L);\n} catch (InterruptedException ie) {\n}\n}\n}\n} catch (Throwable t) {\nt.printStackTrace(System.err);\n} finally {\n\/\/ Set abort to true in case we exit the 'run' method\npool.getAbort().set(true);\n}\n}\n};\n}","code_context_20":"@Override\npublic Runnable getConsumer(final KafkaSynchronizedConsumerPool pool, final KafkaStream<byte[], byte[]> stream) {\nreturn new Runnable() {\n@Override\npublic void run() {\nConsumerIterator<byte[],byte[]> iter = stream.iterator();\nbyte[] sipHashKey = frontend.keystore.getKey(KeyStore.SIPHASH_KAFKA_PLASMA_FRONTEND_IN);\nbyte[] aesKey = frontend.keystore.getKey(KeyStore.AES_KAFKA_PLASMA_FRONTEND_IN);\n\/\/ Iterate on the messages\nTDeserializer deserializer = new TDeserializer(new TCompactProtocol.Factory());\nKafkaOffsetCounters counters = pool.getCounters();\n\/\/ TODO(hbs): allow setting of writeBufferSize\ntry {\nwhile (iter.hasNext()) {\n\/\/\n\/\/ Since the cal to 'next' may block, we need to first\n\/\/ check that there is a message available\n\/\/\nboolean nonEmpty = iter.nonEmpty();\nif (nonEmpty) {\nMessageAndMetadata<byte[], byte[]> msg = iter.next();\ncounters.count(msg.partition(), msg.offset());\nbyte[] data = msg.message();\nSensision.update(SensisionConstants.SENSISION_CLASS_PLASMA_FRONTEND_KAFKA_MESSAGES, Sensision.EMPTY_LABELS, 1);\nSensision.update(SensisionConstants.SENSISION_CLASS_PLASMA_FRONTEND_KAFKA_BYTES, Sensision.EMPTY_LABELS, data.length);\nif (null != sipHashKey) {\ndata = CryptoUtils.removeMAC(sipHashKey, data);\n}\n\/\/ Skip data whose MAC was not verified successfully\n\n@Override\npublic Runnable getConsumer(final KafkaSynchronizedConsumerPool pool, final KafkaStream<byte[], byte[]> stream) {\nreturn new Runnable() {\n@Override\npublic void run() {\nConsumerIterator<byte[],byte[]> iter = stream.iterator();\nbyte[] sipHashKey = frontend.keystore.getKey(KeyStore.SIPHASH_KAFKA_PLASMA_FRONTEND_IN);\nbyte[] aesKey = frontend.keystore.getKey(KeyStore.AES_KAFKA_PLASMA_FRONTEND_IN);\n\/\/ Iterate on the messages\nTDeserializer deserializer = new TDeserializer(new TCompactProtocol.Factory());\nKafkaOffsetCounters counters = pool.getCounters();\n\/\/ TODO(hbs): allow setting of writeBufferSize\ntry {\nwhile (iter.hasNext()) {\n\/\/\n\/\/ Since the cal to 'next' may block, we need to first\n\/\/ check that there is a message available\n\/\/\nboolean nonEmpty = iter.nonEmpty();\nif (nonEmpty) {\nMessageAndMetadata<byte[], byte[]> msg = iter.next();\ncounters.count(msg.partition(), msg.offset());\nbyte[] data = msg.message();\nSensision.update(SensisionConstants.SENSISION_CLASS_PLASMA_FRONTEND_KAFKA_MESSAGES, Sensision.EMPTY_LABELS, 1);\nSensision.update(SensisionConstants.SENSISION_CLASS_PLASMA_FRONTEND_KAFKA_BYTES, Sensision.EMPTY_LABELS, data.length);\nif (null != sipHashKey) {\ndata = CryptoUtils.removeMAC(sipHashKey, data);\n}\n\/\/ Skip data whose MAC was not verified successfully\nif (null == data) {\nSensision.update(SensisionConstants.SENSISION_CLASS_PLASMA_FRONTEND_KAFKA_INVALIDMACS, Sensision.EMPTY_LABELS, 1);\ncontinue;\n\n@Override\npublic Runnable getConsumer(final KafkaSynchronizedConsumerPool pool, final KafkaStream<byte[], byte[]> stream) {\nreturn new Runnable() {\n@Override\npublic void run() {\nConsumerIterator<byte[],byte[]> iter = stream.iterator();\nbyte[] sipHashKey = frontend.keystore.getKey(KeyStore.SIPHASH_KAFKA_PLASMA_FRONTEND_IN);\nbyte[] aesKey = frontend.keystore.getKey(KeyStore.AES_KAFKA_PLASMA_FRONTEND_IN);\n\/\/ Iterate on the messages\nTDeserializer deserializer = new TDeserializer(new TCompactProtocol.Factory());\nKafkaOffsetCounters counters = pool.getCounters();\n\/\/ TODO(hbs): allow setting of writeBufferSize\ntry {\nwhile (iter.hasNext()) {\n\/\/\n\/\/ Since the cal to 'next' may block, we need to first\n\/\/ check that there is a message available\n\/\/\nboolean nonEmpty = iter.nonEmpty();\nif (nonEmpty) {\nMessageAndMetadata<byte[], byte[]> msg = iter.next();\ncounters.count(msg.partition(), msg.offset());\nbyte[] data = msg.message();\nSensision.update(SensisionConstants.SENSISION_CLASS_PLASMA_FRONTEND_KAFKA_MESSAGES, Sensision.EMPTY_LABELS, 1);\nSensision.update(SensisionConstants.SENSISION_CLASS_PLASMA_FRONTEND_KAFKA_BYTES, Sensision.EMPTY_LABELS, data.length);\nif (null != sipHashKey) {\ndata = CryptoUtils.removeMAC(sipHashKey, data);\n}\n\/\/ Skip data whose MAC was not verified successfully\nif (null == data) {\nSensision.update(SensisionConstants.SENSISION_CLASS_PLASMA_FRONTEND_KAFKA_INVALIDMACS, Sensision.EMPTY_LABELS, 1);\ncontinue;\n\n\/\/ Iterate on the messages\nTDeserializer deserializer = new TDeserializer(new TCompactProtocol.Factory());\nKafkaOffsetCounters counters = pool.getCounters();\n\/\/ TODO(hbs): allow setting of writeBufferSize\ntry {\nwhile (iter.hasNext()) {\n\/\/\n\/\/ Since the cal to 'next' may block, we need to first\n\/\/ check that there is a message available\n\/\/\nboolean nonEmpty = iter.nonEmpty();\nif (nonEmpty) {\nMessageAndMetadata<byte[], byte[]> msg = iter.next();\ncounters.count(msg.partition(), msg.offset());\nbyte[] data = msg.message();\nSensision.update(SensisionConstants.SENSISION_CLASS_PLASMA_FRONTEND_KAFKA_MESSAGES, Sensision.EMPTY_LABELS, 1);\nSensision.update(SensisionConstants.SENSISION_CLASS_PLASMA_FRONTEND_KAFKA_BYTES, Sensision.EMPTY_LABELS, data.length);\nif (null != sipHashKey) {\ndata = CryptoUtils.removeMAC(sipHashKey, data);\n}\n\/\/ Skip data whose MAC was not verified successfully\nif (null == data) {\nSensision.update(SensisionConstants.SENSISION_CLASS_PLASMA_FRONTEND_KAFKA_INVALIDMACS, Sensision.EMPTY_LABELS, 1);\ncontinue;\n}\n\/\/ Unwrap data if need be\nif (null != aesKey) {\ndata = CryptoUtils.unwrap(aesKey, data);\n}\n\/\/ Skip data that was not unwrapped successfuly\nif (null == data) {\nSensision.update(SensisionConstants.SENSISION_CLASS_PLASMA_FRONTEND_KAFKA_INVALIDCIPHERS, Sensision.EMPTY_LABELS, 1);\ncontinue;\n}\n\/\/\n\/\/ Extract KafkaDataMessage\n\/\/\nKafkaDataMessage tmsg = new KafkaDataMessage();\ndeserializer.deserialize(tmsg, data);\nswitch(tmsg.getType()) {\ncase STORE:\n\nwhile (iter.hasNext()) {\n\/\/\n\/\/ Since the cal to 'next' may block, we need to first\n\/\/ check that there is a message available\n\/\/\nboolean nonEmpty = iter.nonEmpty();\nif (nonEmpty) {\nMessageAndMetadata<byte[], byte[]> msg = iter.next();\ncounters.count(msg.partition(), msg.offset());\nbyte[] data = msg.message();\nSensision.update(SensisionConstants.SENSISION_CLASS_PLASMA_FRONTEND_KAFKA_MESSAGES, Sensision.EMPTY_LABELS, 1);\nSensision.update(SensisionConstants.SENSISION_CLASS_PLASMA_FRONTEND_KAFKA_BYTES, Sensision.EMPTY_LABELS, data.length);\nif (null != sipHashKey) {\ndata = CryptoUtils.removeMAC(sipHashKey, data);\n}\n\/\/ Skip data whose MAC was not verified successfully\nif (null == data) {\nSensision.update(SensisionConstants.SENSISION_CLASS_PLASMA_FRONTEND_KAFKA_INVALIDMACS, Sensision.EMPTY_LABELS, 1);\ncontinue;\n}\n\/\/ Unwrap data if need be\nif (null != aesKey) {\ndata = CryptoUtils.unwrap(aesKey, data);\n}\n\/\/ Skip data that was not unwrapped successfuly\nif (null == data) {\nSensision.update(SensisionConstants.SENSISION_CLASS_PLASMA_FRONTEND_KAFKA_INVALIDCIPHERS, Sensision.EMPTY_LABELS, 1);\ncontinue;\n}\n\/\/\n\/\/ Extract KafkaDataMessage\n\/\/\nKafkaDataMessage tmsg = new KafkaDataMessage();\ndeserializer.deserialize(tmsg, data);\nswitch(tmsg.getType()) {\ncase STORE:\nGTSEncoder encoder = new GTSEncoder(0L, null, tmsg.getData());\nencoder.setClassId(tmsg.getClassId());\nencoder.setLabelsId(tmsg.getLabelsId());\nfrontend.dispatch(encoder);\nbreak;\n\n\/\/\nboolean nonEmpty = iter.nonEmpty();\nif (nonEmpty) {\nMessageAndMetadata<byte[], byte[]> msg = iter.next();\ncounters.count(msg.partition(), msg.offset());\nbyte[] data = msg.message();\nSensision.update(SensisionConstants.SENSISION_CLASS_PLASMA_FRONTEND_KAFKA_MESSAGES, Sensision.EMPTY_LABELS, 1);\nSensision.update(SensisionConstants.SENSISION_CLASS_PLASMA_FRONTEND_KAFKA_BYTES, Sensision.EMPTY_LABELS, data.length);\nif (null != sipHashKey) {\ndata = CryptoUtils.removeMAC(sipHashKey, data);\n}\n\/\/ Skip data whose MAC was not verified successfully\nif (null == data) {\nSensision.update(SensisionConstants.SENSISION_CLASS_PLASMA_FRONTEND_KAFKA_INVALIDMACS, Sensision.EMPTY_LABELS, 1);\ncontinue;\n}\n\/\/ Unwrap data if need be\nif (null != aesKey) {\ndata = CryptoUtils.unwrap(aesKey, data);\n}\n\/\/ Skip data that was not unwrapped successfuly\nif (null == data) {\nSensision.update(SensisionConstants.SENSISION_CLASS_PLASMA_FRONTEND_KAFKA_INVALIDCIPHERS, Sensision.EMPTY_LABELS, 1);\ncontinue;\n}\n\/\/\n\/\/ Extract KafkaDataMessage\n\/\/\nKafkaDataMessage tmsg = new KafkaDataMessage();\ndeserializer.deserialize(tmsg, data);\nswitch(tmsg.getType()) {\ncase STORE:\nGTSEncoder encoder = new GTSEncoder(0L, null, tmsg.getData());\nencoder.setClassId(tmsg.getClassId());\nencoder.setLabelsId(tmsg.getLabelsId());\nfrontend.dispatch(encoder);\nbreak;\ncase DELETE:\ncase ARCHIVE:\nbreak;\ndefault:\n\n@Override\npublic Runnable getConsumer(final KafkaSynchronizedConsumerPool pool, final KafkaStream<byte[], byte[]> stream) {\nreturn new Runnable() {\n@Override\npublic void run() {\nConsumerIterator<byte[],byte[]> iter = stream.iterator();\nbyte[] sipHashKey = frontend.keystore.getKey(KeyStore.SIPHASH_KAFKA_PLASMA_FRONTEND_IN);\nbyte[] aesKey = frontend.keystore.getKey(KeyStore.AES_KAFKA_PLASMA_FRONTEND_IN);\n\/\/ Iterate on the messages\nTDeserializer deserializer = new TDeserializer(new TCompactProtocol.Factory());\nKafkaOffsetCounters counters = pool.getCounters();\n\/\/ TODO(hbs): allow setting of writeBufferSize\ntry {\nwhile (iter.hasNext()) {\n\/\/\n\/\/ Since the cal to 'next' may block, we need to first\n\/\/ check that there is a message available\n\/\/\nboolean nonEmpty = iter.nonEmpty();\nif (nonEmpty) {\nMessageAndMetadata<byte[], byte[]> msg = iter.next();\ncounters.count(msg.partition(), msg.offset());\nbyte[] data = msg.message();\nSensision.update(SensisionConstants.SENSISION_CLASS_PLASMA_FRONTEND_KAFKA_MESSAGES, Sensision.EMPTY_LABELS, 1);\nSensision.update(SensisionConstants.SENSISION_CLASS_PLASMA_FRONTEND_KAFKA_BYTES, Sensision.EMPTY_LABELS, data.length);\nif (null != sipHashKey) {\ndata = CryptoUtils.removeMAC(sipHashKey, data);\n}\n\/\/ Skip data whose MAC was not verified successfully\nif (null == data) {\nSensision.update(SensisionConstants.SENSISION_CLASS_PLASMA_FRONTEND_KAFKA_INVALIDMACS, Sensision.EMPTY_LABELS, 1);\n\n}\n\/\/\n\/\/ Extract KafkaDataMessage\n\/\/\nKafkaDataMessage tmsg = new KafkaDataMessage();\ndeserializer.deserialize(tmsg, data);\nswitch(tmsg.getType()) {\ncase STORE:\nGTSEncoder encoder = new GTSEncoder(0L, null, tmsg.getData());\nencoder.setClassId(tmsg.getClassId());\nencoder.setLabelsId(tmsg.getLabelsId());\nfrontend.dispatch(encoder);\nbreak;\ncase DELETE:\ncase ARCHIVE:\nbreak;\ndefault:\nthrow new RuntimeException(\"Invalid message type.\");\n}\n} else {\n\/\/ Sleep a tiny while\ntry {\nThread.sleep(1L);\n} catch (InterruptedException ie) {\n}\n}\n}\n} catch (Throwable t) {\nt.printStackTrace(System.err);\n} finally {\n\/\/ Set abort to true in case we exit the 'run' method\npool.getAbort().set(true);\n}\n}\n};\n}\n\nencoder.setLabelsId(tmsg.getLabelsId());\nfrontend.dispatch(encoder);\nbreak;\ncase DELETE:\ncase ARCHIVE:\nbreak;\ndefault:\nthrow new RuntimeException(\"Invalid message type.\");\n}\n} else {\n\/\/ Sleep a tiny while\ntry {\nThread.sleep(1L);\n} catch (InterruptedException ie) {\n}\n}\n}\n} catch (Throwable t) {\nt.printStackTrace(System.err);\n} finally {\n\/\/ Set abort to true in case we exit the 'run' method\npool.getAbort().set(true);\n}\n}\n};\n}","label":[0,1,0,0]}
{"id":432,"original_code":"protected void addSubtable(GlyphSubtable subtable) {\n        if (subtable instanceof GlyphClassSubtable) {\n            this.gct = (GlyphClassSubtable) subtable;\n        } else if (subtable instanceof AttachmentPointSubtable) {\n            \/\/ TODO - not yet used\n            \/\/ this.apt = (AttachmentPointSubtable) subtable;\n        } else if (subtable instanceof LigatureCaretSubtable) {\n            \/\/ TODO - not yet used\n            \/\/ this.lct = (LigatureCaretSubtable) subtable;\n        } else if (subtable instanceof MarkAttachmentSubtable) {\n            this.mat = (MarkAttachmentSubtable) subtable;\n        } else {\n            throw new UnsupportedOperationException(\"unsupported glyph definition subtable type: \" + subtable);\n        }\n    }","code":"protected void addSubtable(GlyphSubtable subtable) {\n        if (subtable instanceof GlyphClassSubtable) {\n            this.gct = (GlyphClassSubtable) subtable;\n        } else if (subtable instanceof AttachmentPointSubtable) {\n           \n           \n        } else if (subtable instanceof LigatureCaretSubtable) {\n           \n           \n        } else if (subtable instanceof MarkAttachmentSubtable) {\n            this.mat = (MarkAttachmentSubtable) subtable;\n        } else {\n            throw new UnsupportedOperationException(\"unsupported glyph definition subtable type: \" + subtable);\n        }\n    }","cleancode":"protected void addsubtable(glyphsubtable subtable) { if (subtable instanceof glyphclasssubtable) { this.gct = (glyphclasssubtable) subtable; } else if (subtable instanceof attachmentpointsubtable) { } else if (subtable instanceof ligaturecaretsubtable) { } else if (subtable instanceof markattachmentsubtable) { this.mat = (markattachmentsubtable) subtable; } else { throw new unsupportedoperationexception(\"unsupported glyph definition subtable type: \" + subtable); } }","comment":"\/** {@inheritdoc} *\/\n\/\/ todo - not yet used \/\/ this.apt = (attachmentpointsubtable) subtable;\n\/\/ todo - not yet used \/\/ this.lct = (ligaturecaretsubtable) subtable;","repo":"not2sirius\/fop","code_context_2":"protected void addSubtable(GlyphSubtable subtable) {\nif (subtable instanceof GlyphClassSubtable) {\nthis.gct = (GlyphClassSubtable) subtable;\n} else if (subtable instanceof AttachmentPointSubtable) {\n\/\/ TODO - not yet used\n\/\/ this.apt = (AttachmentPointSubtable) subtable;\n} else if (subtable instanceof LigatureCaretSubtable) {\n\/\/ TODO - not yet used\n\/\/ this.lct = (LigatureCaretSubtable) subtable;\n} else if (subtable instanceof MarkAttachmentSubtable) {\nthis.mat = (MarkAttachmentSubtable) subtable;\n} else {\nthrow new UnsupportedOperationException(\"unsupported glyph definition subtable type: \" + subtable);\n}\n}\n\nthis.gct = (GlyphClassSubtable) subtable;\n} else if (subtable instanceof AttachmentPointSubtable) {\n\/\/ TODO - not yet used\n\/\/ this.apt = (AttachmentPointSubtable) subtable;\n} else if (subtable instanceof LigatureCaretSubtable) {\n\/\/ TODO - not yet used\n\nthis.gct = (GlyphClassSubtable) subtable;\n} else if (subtable instanceof AttachmentPointSubtable) {\n\/\/ TODO - not yet used\n\/\/ this.apt = (AttachmentPointSubtable) subtable;\n} else if (subtable instanceof LigatureCaretSubtable) {\n\/\/ TODO - not yet used","code_context_10":"protected void addSubtable(GlyphSubtable subtable) {\nif (subtable instanceof GlyphClassSubtable) {\nthis.gct = (GlyphClassSubtable) subtable;\n} else if (subtable instanceof AttachmentPointSubtable) {\n\/\/ TODO - not yet used\n\/\/ this.apt = (AttachmentPointSubtable) subtable;\n} else if (subtable instanceof LigatureCaretSubtable) {\n\/\/ TODO - not yet used\n\/\/ this.lct = (LigatureCaretSubtable) subtable;\n} else if (subtable instanceof MarkAttachmentSubtable) {\nthis.mat = (MarkAttachmentSubtable) subtable;\n} else {\nthrow new UnsupportedOperationException(\"unsupported glyph definition subtable type: \" + subtable);\n}\n}\n\nprotected void addSubtable(GlyphSubtable subtable) {\nif (subtable instanceof GlyphClassSubtable) {\nthis.gct = (GlyphClassSubtable) subtable;\n} else if (subtable instanceof AttachmentPointSubtable) {\n\/\/ TODO - not yet used\n\/\/ this.apt = (AttachmentPointSubtable) subtable;\n} else if (subtable instanceof LigatureCaretSubtable) {\n\/\/ TODO - not yet used\n\/\/ this.lct = (LigatureCaretSubtable) subtable;\n} else if (subtable instanceof MarkAttachmentSubtable) {\nthis.mat = (MarkAttachmentSubtable) subtable;\n} else {\nthrow new UnsupportedOperationException(\"unsupported glyph definition subtable type: \" + subtable);\n}\n}\n\nprotected void addSubtable(GlyphSubtable subtable) {\nif (subtable instanceof GlyphClassSubtable) {\nthis.gct = (GlyphClassSubtable) subtable;\n} else if (subtable instanceof AttachmentPointSubtable) {\n\/\/ TODO - not yet used\n\/\/ this.apt = (AttachmentPointSubtable) subtable;\n} else if (subtable instanceof LigatureCaretSubtable) {\n\/\/ TODO - not yet used\n\/\/ this.lct = (LigatureCaretSubtable) subtable;\n} else if (subtable instanceof MarkAttachmentSubtable) {\nthis.mat = (MarkAttachmentSubtable) subtable;\n} else {\nthrow new UnsupportedOperationException(\"unsupported glyph definition subtable type: \" + subtable);\n}\n}","code_context_20":"protected void addSubtable(GlyphSubtable subtable) {\nif (subtable instanceof GlyphClassSubtable) {\nthis.gct = (GlyphClassSubtable) subtable;\n} else if (subtable instanceof AttachmentPointSubtable) {\n\/\/ TODO - not yet used\n\/\/ this.apt = (AttachmentPointSubtable) subtable;\n} else if (subtable instanceof LigatureCaretSubtable) {\n\/\/ TODO - not yet used\n\/\/ this.lct = (LigatureCaretSubtable) subtable;\n} else if (subtable instanceof MarkAttachmentSubtable) {\nthis.mat = (MarkAttachmentSubtable) subtable;\n} else {\nthrow new UnsupportedOperationException(\"unsupported glyph definition subtable type: \" + subtable);\n}\n}\n\nprotected void addSubtable(GlyphSubtable subtable) {\nif (subtable instanceof GlyphClassSubtable) {\nthis.gct = (GlyphClassSubtable) subtable;\n} else if (subtable instanceof AttachmentPointSubtable) {\n\/\/ TODO - not yet used\n\/\/ this.apt = (AttachmentPointSubtable) subtable;\n} else if (subtable instanceof LigatureCaretSubtable) {\n\/\/ TODO - not yet used\n\/\/ this.lct = (LigatureCaretSubtable) subtable;\n} else if (subtable instanceof MarkAttachmentSubtable) {\nthis.mat = (MarkAttachmentSubtable) subtable;\n} else {\nthrow new UnsupportedOperationException(\"unsupported glyph definition subtable type: \" + subtable);\n}\n}\n\nprotected void addSubtable(GlyphSubtable subtable) {\nif (subtable instanceof GlyphClassSubtable) {\nthis.gct = (GlyphClassSubtable) subtable;\n} else if (subtable instanceof AttachmentPointSubtable) {\n\/\/ TODO - not yet used\n\/\/ this.apt = (AttachmentPointSubtable) subtable;\n} else if (subtable instanceof LigatureCaretSubtable) {\n\/\/ TODO - not yet used\n\/\/ this.lct = (LigatureCaretSubtable) subtable;\n} else if (subtable instanceof MarkAttachmentSubtable) {\nthis.mat = (MarkAttachmentSubtable) subtable;\n} else {\nthrow new UnsupportedOperationException(\"unsupported glyph definition subtable type: \" + subtable);\n}\n}","label":[1,0,0,0]}
{"id":8645,"original_code":"@Override\n    public void exitOperator_expr(OperonModuleParser.Operator_exprContext ctx) {\n        \/\/:OFF:log.debug(\"EXIT Operator_expr :: Stack size :: \" + this.stack.size());\n        List<ParseTree> subNodes = getContextChildNodes(ctx);\n        int subNodesSize = subNodes.size();\n        \/\/ Get the FunctionRef\n        FunctionRef funcRef = (FunctionRef) this.stack.pop();\n        boolean isCascade = false;\n        if (subNodes.get(subNodes.size() - 2) instanceof TerminalNode && \n            subNodes.get(subNodes.size() - 2).getText().toLowerCase().equals(\"cascade\")) {\n            \/\/:OFF:log.debug(\"  >> Operator :: set cascade true :: \" + subNodes.get(subNodes.size() - 2).getText());\n            isCascade = true;\n        }\n        \/\/ Get the overloaded operator:\n        for (int i = 0; i < subNodesSize; i ++) {\n            \/\/:OFF:log.debug(subNodes.get(i).getClass().getName());\n            if (subNodes.get(i) instanceof TerminalNode) {\n                \/\/:OFF:log.debug(\"  >> Operator :: terminal-node found.\");\n            }\n        }\n        String operator = subNodes.get(2).getText();\n        \/\/:OFF:log.debug(\" >> OPERATOR :: \" + operator);\n        Operator op = new Operator(this.currentStatement); \/\/ TODO: might not to inherit Node, therefore giving statement not required.\n        op.setOperator(operator);\n        op.setFunctionRef(funcRef);\n        op.setCascade(isCascade);\n        this.stack.push(op);\n    }","code":"@Override\n    public void exitOperator_expr(OperonModuleParser.Operator_exprContext ctx) {\n       \n        List<ParseTree> subNodes = getContextChildNodes(ctx);\n        int subNodesSize = subNodes.size();\n       \n        FunctionRef funcRef = (FunctionRef) this.stack.pop();\n        boolean isCascade = false;\n        if (subNodes.get(subNodes.size() - 2) instanceof TerminalNode && \n            subNodes.get(subNodes.size() - 2).getText().toLowerCase().equals(\"cascade\")) {\n           \n            isCascade = true;\n        }\n       \n        for (int i = 0; i < subNodesSize; i ++) {\n           \n            if (subNodes.get(i) instanceof TerminalNode) {\n               \n            }\n        }\n        String operator = subNodes.get(2).getText();\n       \n        Operator op = new Operator(this.currentStatement);\n        op.setOperator(operator);\n        op.setFunctionRef(funcRef);\n        op.setCascade(isCascade);\n        this.stack.push(op);\n    }","cleancode":"@override public void exitoperator_expr(operonmoduleparser.operator_exprcontext ctx) { list<parsetree> subnodes = getcontextchildnodes(ctx); int subnodessize = subnodes.size(); functionref funcref = (functionref) this.stack.pop(); boolean iscascade = false; if (subnodes.get(subnodes.size() - 2) instanceof terminalnode && subnodes.get(subnodes.size() - 2).gettext().tolowercase().equals(\"cascade\")) { iscascade = true; } for (int i = 0; i < subnodessize; i ++) { if (subnodes.get(i) instanceof terminalnode) { } } string operator = subnodes.get(2).gettext(); operator op = new operator(this.currentstatement); op.setoperator(operator); op.setfunctionref(funcref); op.setcascade(iscascade); this.stack.push(op); }","comment":"\/\/:off:log.debug(\"exit operator_expr :: stack size :: \" + this.stack.size());\n\/\/ get the functionref\n\/\/:off:log.debug(\" >> operator :: set cascade true :: \" + subnodes.get(subnodes.size() - 2).gettext());\n\/\/ get the overloaded operator:\n\/\/:off:log.debug(subnodes.get(i).getclass().getname());\n\/\/:off:log.debug(\" >> operator :: terminal-node found.\");\n\/\/:off:log.debug(\" >> operator :: \" + operator);\n\/\/ todo: might not to inherit node, therefore giving statement not required.","repo":"operon-io\/operon-lang","code_context_2":"@Override\npublic void exitOperator_expr(OperonModuleParser.Operator_exprContext ctx) {\n\/\/:OFF:log.debug(\"EXIT Operator_expr :: Stack size :: \" + this.stack.size());\nList<ParseTree> subNodes = getContextChildNodes(ctx);\nint subNodesSize = subNodes.size();\n\nList<ParseTree> subNodes = getContextChildNodes(ctx);\nint subNodesSize = subNodes.size();\n\/\/ Get the FunctionRef\nFunctionRef funcRef = (FunctionRef) this.stack.pop();\nboolean isCascade = false;\n\nif (subNodes.get(subNodes.size() - 2) instanceof TerminalNode &&\nsubNodes.get(subNodes.size() - 2).getText().toLowerCase().equals(\"cascade\")) {\n\/\/:OFF:log.debug(\" >> Operator :: set cascade true :: \" + subNodes.get(subNodes.size() - 2).getText());\nisCascade = true;\n}\n\nisCascade = true;\n}\n\/\/ Get the overloaded operator:\nfor (int i = 0; i < subNodesSize; i ++) {\n\/\/:OFF:log.debug(subNodes.get(i).getClass().getName());\n\n\/\/ Get the overloaded operator:\nfor (int i = 0; i < subNodesSize; i ++) {\n\/\/:OFF:log.debug(subNodes.get(i).getClass().getName());\nif (subNodes.get(i) instanceof TerminalNode) {\n\/\/:OFF:log.debug(\" >> Operator :: terminal-node found.\");\n\n\/\/:OFF:log.debug(subNodes.get(i).getClass().getName());\nif (subNodes.get(i) instanceof TerminalNode) {\n\/\/:OFF:log.debug(\" >> Operator :: terminal-node found.\");\n}\n}\n\n}\nString operator = subNodes.get(2).getText();\n\/\/:OFF:log.debug(\" >> OPERATOR :: \" + operator);\nOperator op = new Operator(this.currentStatement); \/\/ TODO: might not to inherit Node, therefore giving statement not required.\nop.setOperator(operator);\n\nString operator = subNodes.get(2).getText();\n\/\/:OFF:log.debug(\" >> OPERATOR :: \" + operator);\nOperator op = new Operator(this.currentStatement); \/\/ TODO: might not to inherit Node, therefore giving statement not required.\nop.setOperator(operator);\nop.setFunctionRef(funcRef);","code_context_10":"@Override\npublic void exitOperator_expr(OperonModuleParser.Operator_exprContext ctx) {\n\/\/:OFF:log.debug(\"EXIT Operator_expr :: Stack size :: \" + this.stack.size());\nList<ParseTree> subNodes = getContextChildNodes(ctx);\nint subNodesSize = subNodes.size();\n\/\/ Get the FunctionRef\nFunctionRef funcRef = (FunctionRef) this.stack.pop();\nboolean isCascade = false;\nif (subNodes.get(subNodes.size() - 2) instanceof TerminalNode &&\nsubNodes.get(subNodes.size() - 2).getText().toLowerCase().equals(\"cascade\")) {\n\/\/:OFF:log.debug(\" >> Operator :: set cascade true :: \" + subNodes.get(subNodes.size() - 2).getText());\nisCascade = true;\n}\n\n@Override\npublic void exitOperator_expr(OperonModuleParser.Operator_exprContext ctx) {\n\/\/:OFF:log.debug(\"EXIT Operator_expr :: Stack size :: \" + this.stack.size());\nList<ParseTree> subNodes = getContextChildNodes(ctx);\nint subNodesSize = subNodes.size();\n\/\/ Get the FunctionRef\nFunctionRef funcRef = (FunctionRef) this.stack.pop();\nboolean isCascade = false;\nif (subNodes.get(subNodes.size() - 2) instanceof TerminalNode &&\nsubNodes.get(subNodes.size() - 2).getText().toLowerCase().equals(\"cascade\")) {\n\/\/:OFF:log.debug(\" >> Operator :: set cascade true :: \" + subNodes.get(subNodes.size() - 2).getText());\nisCascade = true;\n}\n\/\/ Get the overloaded operator:\nfor (int i = 0; i < subNodesSize; i ++) {\n\/\/:OFF:log.debug(subNodes.get(i).getClass().getName());\n\n@Override\npublic void exitOperator_expr(OperonModuleParser.Operator_exprContext ctx) {\n\/\/:OFF:log.debug(\"EXIT Operator_expr :: Stack size :: \" + this.stack.size());\nList<ParseTree> subNodes = getContextChildNodes(ctx);\nint subNodesSize = subNodes.size();\n\/\/ Get the FunctionRef\nFunctionRef funcRef = (FunctionRef) this.stack.pop();\nboolean isCascade = false;\nif (subNodes.get(subNodes.size() - 2) instanceof TerminalNode &&\nsubNodes.get(subNodes.size() - 2).getText().toLowerCase().equals(\"cascade\")) {\n\/\/:OFF:log.debug(\" >> Operator :: set cascade true :: \" + subNodes.get(subNodes.size() - 2).getText());\nisCascade = true;\n}\n\/\/ Get the overloaded operator:\nfor (int i = 0; i < subNodesSize; i ++) {\n\/\/:OFF:log.debug(subNodes.get(i).getClass().getName());\nif (subNodes.get(i) instanceof TerminalNode) {\n\/\/:OFF:log.debug(\" >> Operator :: terminal-node found.\");\n}\n}\nString operator = subNodes.get(2).getText();\n\nList<ParseTree> subNodes = getContextChildNodes(ctx);\nint subNodesSize = subNodes.size();\n\/\/ Get the FunctionRef\nFunctionRef funcRef = (FunctionRef) this.stack.pop();\nboolean isCascade = false;\nif (subNodes.get(subNodes.size() - 2) instanceof TerminalNode &&\nsubNodes.get(subNodes.size() - 2).getText().toLowerCase().equals(\"cascade\")) {\n\/\/:OFF:log.debug(\" >> Operator :: set cascade true :: \" + subNodes.get(subNodes.size() - 2).getText());\nisCascade = true;\n}\n\/\/ Get the overloaded operator:\nfor (int i = 0; i < subNodesSize; i ++) {\n\/\/:OFF:log.debug(subNodes.get(i).getClass().getName());\nif (subNodes.get(i) instanceof TerminalNode) {\n\/\/:OFF:log.debug(\" >> Operator :: terminal-node found.\");\n}\n}\nString operator = subNodes.get(2).getText();\n\/\/:OFF:log.debug(\" >> OPERATOR :: \" + operator);\nOperator op = new Operator(this.currentStatement); \/\/ TODO: might not to inherit Node, therefore giving statement not required.\nop.setOperator(operator);\n\n\/\/ Get the FunctionRef\nFunctionRef funcRef = (FunctionRef) this.stack.pop();\nboolean isCascade = false;\nif (subNodes.get(subNodes.size() - 2) instanceof TerminalNode &&\nsubNodes.get(subNodes.size() - 2).getText().toLowerCase().equals(\"cascade\")) {\n\/\/:OFF:log.debug(\" >> Operator :: set cascade true :: \" + subNodes.get(subNodes.size() - 2).getText());\nisCascade = true;\n}\n\/\/ Get the overloaded operator:\nfor (int i = 0; i < subNodesSize; i ++) {\n\/\/:OFF:log.debug(subNodes.get(i).getClass().getName());\nif (subNodes.get(i) instanceof TerminalNode) {\n\/\/:OFF:log.debug(\" >> Operator :: terminal-node found.\");\n}\n}\nString operator = subNodes.get(2).getText();\n\/\/:OFF:log.debug(\" >> OPERATOR :: \" + operator);\nOperator op = new Operator(this.currentStatement); \/\/ TODO: might not to inherit Node, therefore giving statement not required.\nop.setOperator(operator);\nop.setFunctionRef(funcRef);\nop.setCascade(isCascade);\n\nboolean isCascade = false;\nif (subNodes.get(subNodes.size() - 2) instanceof TerminalNode &&\nsubNodes.get(subNodes.size() - 2).getText().toLowerCase().equals(\"cascade\")) {\n\/\/:OFF:log.debug(\" >> Operator :: set cascade true :: \" + subNodes.get(subNodes.size() - 2).getText());\nisCascade = true;\n}\n\/\/ Get the overloaded operator:\nfor (int i = 0; i < subNodesSize; i ++) {\n\/\/:OFF:log.debug(subNodes.get(i).getClass().getName());\nif (subNodes.get(i) instanceof TerminalNode) {\n\/\/:OFF:log.debug(\" >> Operator :: terminal-node found.\");\n}\n}\nString operator = subNodes.get(2).getText();\n\/\/:OFF:log.debug(\" >> OPERATOR :: \" + operator);\nOperator op = new Operator(this.currentStatement); \/\/ TODO: might not to inherit Node, therefore giving statement not required.\nop.setOperator(operator);\nop.setFunctionRef(funcRef);\nop.setCascade(isCascade);\nthis.stack.push(op);\n}\n\nisCascade = true;\n}\n\/\/ Get the overloaded operator:\nfor (int i = 0; i < subNodesSize; i ++) {\n\/\/:OFF:log.debug(subNodes.get(i).getClass().getName());\nif (subNodes.get(i) instanceof TerminalNode) {\n\/\/:OFF:log.debug(\" >> Operator :: terminal-node found.\");\n}\n}\nString operator = subNodes.get(2).getText();\n\/\/:OFF:log.debug(\" >> OPERATOR :: \" + operator);\nOperator op = new Operator(this.currentStatement); \/\/ TODO: might not to inherit Node, therefore giving statement not required.\nop.setOperator(operator);\nop.setFunctionRef(funcRef);\nop.setCascade(isCascade);\nthis.stack.push(op);\n}\n\n}\n\/\/ Get the overloaded operator:\nfor (int i = 0; i < subNodesSize; i ++) {\n\/\/:OFF:log.debug(subNodes.get(i).getClass().getName());\nif (subNodes.get(i) instanceof TerminalNode) {\n\/\/:OFF:log.debug(\" >> Operator :: terminal-node found.\");\n}\n}\nString operator = subNodes.get(2).getText();\n\/\/:OFF:log.debug(\" >> OPERATOR :: \" + operator);\nOperator op = new Operator(this.currentStatement); \/\/ TODO: might not to inherit Node, therefore giving statement not required.\nop.setOperator(operator);\nop.setFunctionRef(funcRef);\nop.setCascade(isCascade);\nthis.stack.push(op);\n}","code_context_20":"@Override\npublic void exitOperator_expr(OperonModuleParser.Operator_exprContext ctx) {\n\/\/:OFF:log.debug(\"EXIT Operator_expr :: Stack size :: \" + this.stack.size());\nList<ParseTree> subNodes = getContextChildNodes(ctx);\nint subNodesSize = subNodes.size();\n\/\/ Get the FunctionRef\nFunctionRef funcRef = (FunctionRef) this.stack.pop();\nboolean isCascade = false;\nif (subNodes.get(subNodes.size() - 2) instanceof TerminalNode &&\nsubNodes.get(subNodes.size() - 2).getText().toLowerCase().equals(\"cascade\")) {\n\/\/:OFF:log.debug(\" >> Operator :: set cascade true :: \" + subNodes.get(subNodes.size() - 2).getText());\nisCascade = true;\n}\n\/\/ Get the overloaded operator:\nfor (int i = 0; i < subNodesSize; i ++) {\n\/\/:OFF:log.debug(subNodes.get(i).getClass().getName());\nif (subNodes.get(i) instanceof TerminalNode) {\n\/\/:OFF:log.debug(\" >> Operator :: terminal-node found.\");\n}\n}\nString operator = subNodes.get(2).getText();\n\/\/:OFF:log.debug(\" >> OPERATOR :: \" + operator);\nOperator op = new Operator(this.currentStatement); \/\/ TODO: might not to inherit Node, therefore giving statement not required.\n\n@Override\npublic void exitOperator_expr(OperonModuleParser.Operator_exprContext ctx) {\n\/\/:OFF:log.debug(\"EXIT Operator_expr :: Stack size :: \" + this.stack.size());\nList<ParseTree> subNodes = getContextChildNodes(ctx);\nint subNodesSize = subNodes.size();\n\/\/ Get the FunctionRef\nFunctionRef funcRef = (FunctionRef) this.stack.pop();\nboolean isCascade = false;\nif (subNodes.get(subNodes.size() - 2) instanceof TerminalNode &&\nsubNodes.get(subNodes.size() - 2).getText().toLowerCase().equals(\"cascade\")) {\n\/\/:OFF:log.debug(\" >> Operator :: set cascade true :: \" + subNodes.get(subNodes.size() - 2).getText());\nisCascade = true;\n}\n\/\/ Get the overloaded operator:\nfor (int i = 0; i < subNodesSize; i ++) {\n\/\/:OFF:log.debug(subNodes.get(i).getClass().getName());\nif (subNodes.get(i) instanceof TerminalNode) {\n\/\/:OFF:log.debug(\" >> Operator :: terminal-node found.\");\n}\n}\nString operator = subNodes.get(2).getText();\n\/\/:OFF:log.debug(\" >> OPERATOR :: \" + operator);\nOperator op = new Operator(this.currentStatement); \/\/ TODO: might not to inherit Node, therefore giving statement not required.\nop.setOperator(operator);\nop.setFunctionRef(funcRef);\nop.setCascade(isCascade);\n\n@Override\npublic void exitOperator_expr(OperonModuleParser.Operator_exprContext ctx) {\n\/\/:OFF:log.debug(\"EXIT Operator_expr :: Stack size :: \" + this.stack.size());\nList<ParseTree> subNodes = getContextChildNodes(ctx);\nint subNodesSize = subNodes.size();\n\/\/ Get the FunctionRef\nFunctionRef funcRef = (FunctionRef) this.stack.pop();\nboolean isCascade = false;\nif (subNodes.get(subNodes.size() - 2) instanceof TerminalNode &&\nsubNodes.get(subNodes.size() - 2).getText().toLowerCase().equals(\"cascade\")) {\n\/\/:OFF:log.debug(\" >> Operator :: set cascade true :: \" + subNodes.get(subNodes.size() - 2).getText());\nisCascade = true;\n}\n\/\/ Get the overloaded operator:\nfor (int i = 0; i < subNodesSize; i ++) {\n\/\/:OFF:log.debug(subNodes.get(i).getClass().getName());\nif (subNodes.get(i) instanceof TerminalNode) {\n\/\/:OFF:log.debug(\" >> Operator :: terminal-node found.\");\n}\n}\nString operator = subNodes.get(2).getText();\n\/\/:OFF:log.debug(\" >> OPERATOR :: \" + operator);\nOperator op = new Operator(this.currentStatement); \/\/ TODO: might not to inherit Node, therefore giving statement not required.\nop.setOperator(operator);\nop.setFunctionRef(funcRef);\nop.setCascade(isCascade);\nthis.stack.push(op);\n}\n\n@Override\npublic void exitOperator_expr(OperonModuleParser.Operator_exprContext ctx) {\n\/\/:OFF:log.debug(\"EXIT Operator_expr :: Stack size :: \" + this.stack.size());\nList<ParseTree> subNodes = getContextChildNodes(ctx);\nint subNodesSize = subNodes.size();\n\/\/ Get the FunctionRef\nFunctionRef funcRef = (FunctionRef) this.stack.pop();\nboolean isCascade = false;\nif (subNodes.get(subNodes.size() - 2) instanceof TerminalNode &&\nsubNodes.get(subNodes.size() - 2).getText().toLowerCase().equals(\"cascade\")) {\n\/\/:OFF:log.debug(\" >> Operator :: set cascade true :: \" + subNodes.get(subNodes.size() - 2).getText());\nisCascade = true;\n}\n\/\/ Get the overloaded operator:\nfor (int i = 0; i < subNodesSize; i ++) {\n\/\/:OFF:log.debug(subNodes.get(i).getClass().getName());\nif (subNodes.get(i) instanceof TerminalNode) {\n\/\/:OFF:log.debug(\" >> Operator :: terminal-node found.\");\n}\n}\nString operator = subNodes.get(2).getText();\n\/\/:OFF:log.debug(\" >> OPERATOR :: \" + operator);\nOperator op = new Operator(this.currentStatement); \/\/ TODO: might not to inherit Node, therefore giving statement not required.\nop.setOperator(operator);\nop.setFunctionRef(funcRef);\nop.setCascade(isCascade);\nthis.stack.push(op);\n}\n\n@Override\npublic void exitOperator_expr(OperonModuleParser.Operator_exprContext ctx) {\n\/\/:OFF:log.debug(\"EXIT Operator_expr :: Stack size :: \" + this.stack.size());\nList<ParseTree> subNodes = getContextChildNodes(ctx);\nint subNodesSize = subNodes.size();\n\/\/ Get the FunctionRef\nFunctionRef funcRef = (FunctionRef) this.stack.pop();\nboolean isCascade = false;\nif (subNodes.get(subNodes.size() - 2) instanceof TerminalNode &&\nsubNodes.get(subNodes.size() - 2).getText().toLowerCase().equals(\"cascade\")) {\n\/\/:OFF:log.debug(\" >> Operator :: set cascade true :: \" + subNodes.get(subNodes.size() - 2).getText());\nisCascade = true;\n}\n\/\/ Get the overloaded operator:\nfor (int i = 0; i < subNodesSize; i ++) {\n\/\/:OFF:log.debug(subNodes.get(i).getClass().getName());\nif (subNodes.get(i) instanceof TerminalNode) {\n\/\/:OFF:log.debug(\" >> Operator :: terminal-node found.\");\n}\n}\nString operator = subNodes.get(2).getText();\n\/\/:OFF:log.debug(\" >> OPERATOR :: \" + operator);\nOperator op = new Operator(this.currentStatement); \/\/ TODO: might not to inherit Node, therefore giving statement not required.\nop.setOperator(operator);\nop.setFunctionRef(funcRef);\nop.setCascade(isCascade);\nthis.stack.push(op);\n}\n\n@Override\npublic void exitOperator_expr(OperonModuleParser.Operator_exprContext ctx) {\n\/\/:OFF:log.debug(\"EXIT Operator_expr :: Stack size :: \" + this.stack.size());\nList<ParseTree> subNodes = getContextChildNodes(ctx);\nint subNodesSize = subNodes.size();\n\/\/ Get the FunctionRef\nFunctionRef funcRef = (FunctionRef) this.stack.pop();\nboolean isCascade = false;\nif (subNodes.get(subNodes.size() - 2) instanceof TerminalNode &&\nsubNodes.get(subNodes.size() - 2).getText().toLowerCase().equals(\"cascade\")) {\n\/\/:OFF:log.debug(\" >> Operator :: set cascade true :: \" + subNodes.get(subNodes.size() - 2).getText());\nisCascade = true;\n}\n\/\/ Get the overloaded operator:\nfor (int i = 0; i < subNodesSize; i ++) {\n\/\/:OFF:log.debug(subNodes.get(i).getClass().getName());\nif (subNodes.get(i) instanceof TerminalNode) {\n\/\/:OFF:log.debug(\" >> Operator :: terminal-node found.\");\n}\n}\nString operator = subNodes.get(2).getText();\n\/\/:OFF:log.debug(\" >> OPERATOR :: \" + operator);\nOperator op = new Operator(this.currentStatement); \/\/ TODO: might not to inherit Node, therefore giving statement not required.\nop.setOperator(operator);\nop.setFunctionRef(funcRef);\nop.setCascade(isCascade);\nthis.stack.push(op);\n}\n\npublic void exitOperator_expr(OperonModuleParser.Operator_exprContext ctx) {\n\/\/:OFF:log.debug(\"EXIT Operator_expr :: Stack size :: \" + this.stack.size());\nList<ParseTree> subNodes = getContextChildNodes(ctx);\nint subNodesSize = subNodes.size();\n\/\/ Get the FunctionRef\nFunctionRef funcRef = (FunctionRef) this.stack.pop();\nboolean isCascade = false;\nif (subNodes.get(subNodes.size() - 2) instanceof TerminalNode &&\nsubNodes.get(subNodes.size() - 2).getText().toLowerCase().equals(\"cascade\")) {\n\/\/:OFF:log.debug(\" >> Operator :: set cascade true :: \" + subNodes.get(subNodes.size() - 2).getText());\nisCascade = true;\n}\n\/\/ Get the overloaded operator:\nfor (int i = 0; i < subNodesSize; i ++) {\n\/\/:OFF:log.debug(subNodes.get(i).getClass().getName());\nif (subNodes.get(i) instanceof TerminalNode) {\n\/\/:OFF:log.debug(\" >> Operator :: terminal-node found.\");\n}\n}\nString operator = subNodes.get(2).getText();\n\/\/:OFF:log.debug(\" >> OPERATOR :: \" + operator);\nOperator op = new Operator(this.currentStatement); \/\/ TODO: might not to inherit Node, therefore giving statement not required.\nop.setOperator(operator);\nop.setFunctionRef(funcRef);\nop.setCascade(isCascade);\nthis.stack.push(op);\n}\n\n\/\/:OFF:log.debug(\"EXIT Operator_expr :: Stack size :: \" + this.stack.size());\nList<ParseTree> subNodes = getContextChildNodes(ctx);\nint subNodesSize = subNodes.size();\n\/\/ Get the FunctionRef\nFunctionRef funcRef = (FunctionRef) this.stack.pop();\nboolean isCascade = false;\nif (subNodes.get(subNodes.size() - 2) instanceof TerminalNode &&\nsubNodes.get(subNodes.size() - 2).getText().toLowerCase().equals(\"cascade\")) {\n\/\/:OFF:log.debug(\" >> Operator :: set cascade true :: \" + subNodes.get(subNodes.size() - 2).getText());\nisCascade = true;\n}\n\/\/ Get the overloaded operator:\nfor (int i = 0; i < subNodesSize; i ++) {\n\/\/:OFF:log.debug(subNodes.get(i).getClass().getName());\nif (subNodes.get(i) instanceof TerminalNode) {\n\/\/:OFF:log.debug(\" >> Operator :: terminal-node found.\");\n}\n}\nString operator = subNodes.get(2).getText();\n\/\/:OFF:log.debug(\" >> OPERATOR :: \" + operator);\nOperator op = new Operator(this.currentStatement); \/\/ TODO: might not to inherit Node, therefore giving statement not required.\nop.setOperator(operator);\nop.setFunctionRef(funcRef);\nop.setCascade(isCascade);\nthis.stack.push(op);\n}","label":[1,0,0,0]}
{"id":33243,"original_code":"private void testClassify(String testID, String testExpectedID) {\n        log.info(\"Testing the CLASSIFY task\");\n        OWLOntologyManager manager = TestData.manager;\n        \/\/ We prepare the input ontology\n        try {\n            OWLOntology testOntology = manager.createOntology();\n            OWLOntologyID testOntologyID = testOntology.getOntologyID();\n            log.debug(\"Created test ontology with ID: {}\", testOntologyID);\n            manager.applyChange(new AddImport(testOntology, TestData.factory.getOWLImportsDeclaration(IRI\n                    .create(testID))));\n            \/\/ Maybe we want to see what is in before\n            if (log.isDebugEnabled()) TestUtils.debug(manager.getOntology(testOntologyID), log);\n            \/\/ Now we test the method\n            log.debug(\"Running HermiT\");\n            Set<OWLAxiom> inferred = this.theinstance.runTask(ReasoningService.Tasks.CLASSIFY,\n                manager.getOntology(testOntologyID));\n            \/\/ Maybe we want to see the inferred axiom list\n            if (log.isDebugEnabled()) {\n                TestUtils.debug(inferred, log);\n            }\n            Set<OWLLogicalAxiom> expectedAxioms = manager.getOntology(IRI.create(testExpectedID))\n                    .getLogicalAxioms();\n            Set<OWLAxiom> missing = new HashSet<OWLAxiom>();\n            for (OWLAxiom expected : expectedAxioms) {\n                if (!inferred.contains(expected)) {\n                    log.error(\"missing expected axiom: {}\", expected);\n                    missing.add(expected);\n                }\n            }\n            assertTrue(missing.isEmpty());\n            \/\/ We want only Class related axioms in the result set\n            for (OWLAxiom a : inferred) {\n                assertTrue(a instanceof OWLClassAssertionAxiom || a instanceof OWLSubClassOfAxiom\n                           || a instanceof OWLEquivalentClassesAxiom || a instanceof OWLDisjointClassesAxiom);\n            }\n            \/\/ We want to remove the ontology from the manager\n            manager.removeOntology(testOntology);\n        } catch (OWLOntologyCreationException e) {\n            log.error(\"An {} have been thrown while creating the input ontology for test\", e.getClass());\n            assertTrue(false);\n        } catch (ReasoningServiceException e) {\n            log.error(\"An {} have been thrown while executing the reasoning\", e.getClass());\n            assertTrue(false);\n        } catch (InconsistentInputException e) {\n            log.error(\"An {} have been thrown while executing the reasoning\", e.getClass());\n            assertTrue(false);\n        } catch (UnsupportedTaskException e) {\n            log.error(\"An {} have been thrown while executing the reasoning\", e.getClass());\n            assertTrue(false);\n        }\n    }","code":"private void testClassify(String testID, String testExpectedID) {\n        log.info(\"Testing the CLASSIFY task\");\n        OWLOntologyManager manager = TestData.manager;\n       \n        try {\n            OWLOntology testOntology = manager.createOntology();\n            OWLOntologyID testOntologyID = testOntology.getOntologyID();\n            log.debug(\"Created test ontology with ID: {}\", testOntologyID);\n            manager.applyChange(new AddImport(testOntology, TestData.factory.getOWLImportsDeclaration(IRI\n                    .create(testID))));\n           \n            if (log.isDebugEnabled()) TestUtils.debug(manager.getOntology(testOntologyID), log);\n           \n            log.debug(\"Running HermiT\");\n            Set<OWLAxiom> inferred = this.theinstance.runTask(ReasoningService.Tasks.CLASSIFY,\n                manager.getOntology(testOntologyID));\n           \n            if (log.isDebugEnabled()) {\n                TestUtils.debug(inferred, log);\n            }\n            Set<OWLLogicalAxiom> expectedAxioms = manager.getOntology(IRI.create(testExpectedID))\n                    .getLogicalAxioms();\n            Set<OWLAxiom> missing = new HashSet<OWLAxiom>();\n            for (OWLAxiom expected : expectedAxioms) {\n                if (!inferred.contains(expected)) {\n                    log.error(\"missing expected axiom: {}\", expected);\n                    missing.add(expected);\n                }\n            }\n            assertTrue(missing.isEmpty());\n           \n            for (OWLAxiom a : inferred) {\n                assertTrue(a instanceof OWLClassAssertionAxiom || a instanceof OWLSubClassOfAxiom\n                           || a instanceof OWLEquivalentClassesAxiom || a instanceof OWLDisjointClassesAxiom);\n            }\n           \n            manager.removeOntology(testOntology);\n        } catch (OWLOntologyCreationException e) {\n            log.error(\"An {} have been thrown while creating the input ontology for test\", e.getClass());\n            assertTrue(false);\n        } catch (ReasoningServiceException e) {\n            log.error(\"An {} have been thrown while executing the reasoning\", e.getClass());\n            assertTrue(false);\n        } catch (InconsistentInputException e) {\n            log.error(\"An {} have been thrown while executing the reasoning\", e.getClass());\n            assertTrue(false);\n        } catch (UnsupportedTaskException e) {\n            log.error(\"An {} have been thrown while executing the reasoning\", e.getClass());\n            assertTrue(false);\n        }\n    }","cleancode":"private void testclassify(string testid, string testexpectedid) { log.info(\"testing the classify task\"); owlontologymanager manager = testdata.manager; try { owlontology testontology = manager.createontology(); owlontologyid testontologyid = testontology.getontologyid(); log.debug(\"created test ontology with id: {}\", testontologyid); manager.applychange(new addimport(testontology, testdata.factory.getowlimportsdeclaration(iri .create(testid)))); if (log.isdebugenabled()) testutils.debug(manager.getontology(testontologyid), log); log.debug(\"running hermit\"); set<owlaxiom> inferred = this.theinstance.runtask(reasoningservice.tasks.classify, manager.getontology(testontologyid)); if (log.isdebugenabled()) { testutils.debug(inferred, log); } set<owllogicalaxiom> expectedaxioms = manager.getontology(iri.create(testexpectedid)) .getlogicalaxioms(); set<owlaxiom> missing = new hashset<owlaxiom>(); for (owlaxiom expected : expectedaxioms) { if (!inferred.contains(expected)) { log.error(\"missing expected axiom: {}\", expected); missing.add(expected); } } asserttrue(missing.isempty()); for (owlaxiom a : inferred) { asserttrue(a instanceof owlclassassertionaxiom || a instanceof owlsubclassofaxiom || a instanceof owlequivalentclassesaxiom || a instanceof owldisjointclassesaxiom); } manager.removeontology(testontology); } catch (owlontologycreationexception e) { log.error(\"an {} have been thrown while creating the input ontology for test\", e.getclass()); asserttrue(false); } catch (reasoningserviceexception e) { log.error(\"an {} have been thrown while executing the reasoning\", e.getclass()); asserttrue(false); } catch (inconsistentinputexception e) { log.error(\"an {} have been thrown while executing the reasoning\", e.getclass()); asserttrue(false); } catch (unsupportedtaskexception e) { log.error(\"an {} have been thrown while executing the reasoning\", e.getclass()); asserttrue(false); } }","comment":"\/** * we may want to test this method with more then 1 ontology. this is why the implementation is in * aprivate method. this method tests if all the logical axioms in testexpectedid ontology are inferences * of the testid ontology. * * @param testid * \/\/ the id of the ontology to be the input (loaded in the testdata.manager) * @param testexpectedid * \/\/ the id of the ontology which contains logical axioms expected in the result *\/\n\/\/ we prepare the input ontology\n\/\/ maybe we want to see what is in before\n\/\/ now we test the method\n\/\/ maybe we want to see the inferred axiom list\n\/\/ we want only class related axioms in the result set\n\/\/ we want to remove the ontology from the manager","repo":"nikosnikolaidis\/stanbol","code_context_2":"private void testClassify(String testID, String testExpectedID) {\nlog.info(\"Testing the CLASSIFY task\");\nOWLOntologyManager manager = TestData.manager;\n\/\/ We prepare the input ontology\ntry {\nOWLOntology testOntology = manager.createOntology();\nOWLOntologyID testOntologyID = testOntology.getOntologyID();\nlog.debug(\"Created test ontology with ID: {}\", testOntologyID);\nmanager.applyChange(new AddImport(testOntology, TestData.factory.getOWLImportsDeclaration(IRI\n.create(testID))));\n\/\/ Maybe we want to see what is in before\nif (log.isDebugEnabled()) TestUtils.debug(manager.getOntology(testOntologyID), log);\n\/\/ Now we test the method\nlog.debug(\"Running HermiT\");\nSet<OWLAxiom> inferred = this.theinstance.runTask(ReasoningService.Tasks.CLASSIFY,\nmanager.getOntology(testOntologyID));\n\/\/ Maybe we want to see the inferred axiom list\nif (log.isDebugEnabled()) {\nTestUtils.debug(inferred, log);\n}\nSet<OWLLogicalAxiom> expectedAxioms = manager.getOntology(IRI.create(testExpectedID))\n.getLogicalAxioms();\nSet<OWLAxiom> missing = new HashSet<OWLAxiom>();\nfor (OWLAxiom expected : expectedAxioms) {\nif (!inferred.contains(expected)) {\nlog.error(\"missing expected axiom: {}\", expected);\nmissing.add(expected);\n}\n}\nassertTrue(missing.isEmpty());\n\/\/ We want only Class related axioms in the result set\nfor (OWLAxiom a : inferred) {\nassertTrue(a instanceof OWLClassAssertionAxiom || a instanceof OWLSubClassOfAxiom\n|| a instanceof OWLEquivalentClassesAxiom || a instanceof OWLDisjointClassesAxiom);\n}\n\/\/ We want to remove the ontology from the manager\nmanager.removeOntology(testOntology);\n} catch (OWLOntologyCreationException e) {\nlog.error(\"An {} have been thrown while creating the input ontology for test\", e.getClass());\nassertTrue(false);\n} catch (ReasoningServiceException e) {\nlog.error(\"An {} have been thrown while executing the reasoning\", e.getClass());\nassertTrue(false);\n} catch (InconsistentInputException e) {\nlog.error(\"An {} have been thrown while executing the reasoning\", e.getClass());\nassertTrue(false);\n} catch (UnsupportedTaskException e) {\nlog.error(\"An {} have been thrown while executing the reasoning\", e.getClass());\nassertTrue(false);\n}\n}\n\nlog.info(\"Testing the CLASSIFY task\");\nOWLOntologyManager manager = TestData.manager;\n\/\/ We prepare the input ontology\ntry {\nOWLOntology testOntology = manager.createOntology();\n\nmanager.applyChange(new AddImport(testOntology, TestData.factory.getOWLImportsDeclaration(IRI\n.create(testID))));\n\/\/ Maybe we want to see what is in before\nif (log.isDebugEnabled()) TestUtils.debug(manager.getOntology(testOntologyID), log);\n\/\/ Now we test the method\n\n\/\/ Maybe we want to see what is in before\nif (log.isDebugEnabled()) TestUtils.debug(manager.getOntology(testOntologyID), log);\n\/\/ Now we test the method\nlog.debug(\"Running HermiT\");\nSet<OWLAxiom> inferred = this.theinstance.runTask(ReasoningService.Tasks.CLASSIFY,\n\nSet<OWLAxiom> inferred = this.theinstance.runTask(ReasoningService.Tasks.CLASSIFY,\nmanager.getOntology(testOntologyID));\n\/\/ Maybe we want to see the inferred axiom list\nif (log.isDebugEnabled()) {\nTestUtils.debug(inferred, log);\n\n}\nassertTrue(missing.isEmpty());\n\/\/ We want only Class related axioms in the result set\nfor (OWLAxiom a : inferred) {\nassertTrue(a instanceof OWLClassAssertionAxiom || a instanceof OWLSubClassOfAxiom\n\n|| a instanceof OWLEquivalentClassesAxiom || a instanceof OWLDisjointClassesAxiom);\n}\n\/\/ We want to remove the ontology from the manager\nmanager.removeOntology(testOntology);\n} catch (OWLOntologyCreationException e) {","code_context_10":"private void testClassify(String testID, String testExpectedID) {\nlog.info(\"Testing the CLASSIFY task\");\nOWLOntologyManager manager = TestData.manager;\n\/\/ We prepare the input ontology\ntry {\nOWLOntology testOntology = manager.createOntology();\nOWLOntologyID testOntologyID = testOntology.getOntologyID();\nlog.debug(\"Created test ontology with ID: {}\", testOntologyID);\nmanager.applyChange(new AddImport(testOntology, TestData.factory.getOWLImportsDeclaration(IRI\n.create(testID))));\n\/\/ Maybe we want to see what is in before\nif (log.isDebugEnabled()) TestUtils.debug(manager.getOntology(testOntologyID), log);\n\/\/ Now we test the method\nlog.debug(\"Running HermiT\");\nSet<OWLAxiom> inferred = this.theinstance.runTask(ReasoningService.Tasks.CLASSIFY,\nmanager.getOntology(testOntologyID));\n\/\/ Maybe we want to see the inferred axiom list\nif (log.isDebugEnabled()) {\nTestUtils.debug(inferred, log);\n}\nSet<OWLLogicalAxiom> expectedAxioms = manager.getOntology(IRI.create(testExpectedID))\n.getLogicalAxioms();\nSet<OWLAxiom> missing = new HashSet<OWLAxiom>();\nfor (OWLAxiom expected : expectedAxioms) {\nif (!inferred.contains(expected)) {\nlog.error(\"missing expected axiom: {}\", expected);\nmissing.add(expected);\n}\n}\nassertTrue(missing.isEmpty());\n\/\/ We want only Class related axioms in the result set\nfor (OWLAxiom a : inferred) {\nassertTrue(a instanceof OWLClassAssertionAxiom || a instanceof OWLSubClassOfAxiom\n|| a instanceof OWLEquivalentClassesAxiom || a instanceof OWLDisjointClassesAxiom);\n}\n\/\/ We want to remove the ontology from the manager\nmanager.removeOntology(testOntology);\n} catch (OWLOntologyCreationException e) {\nlog.error(\"An {} have been thrown while creating the input ontology for test\", e.getClass());\nassertTrue(false);\n} catch (ReasoningServiceException e) {\nlog.error(\"An {} have been thrown while executing the reasoning\", e.getClass());\nassertTrue(false);\n} catch (InconsistentInputException e) {\nlog.error(\"An {} have been thrown while executing the reasoning\", e.getClass());\nassertTrue(false);\n} catch (UnsupportedTaskException e) {\nlog.error(\"An {} have been thrown while executing the reasoning\", e.getClass());\nassertTrue(false);\n}\n}\n\nprivate void testClassify(String testID, String testExpectedID) {\nlog.info(\"Testing the CLASSIFY task\");\nOWLOntologyManager manager = TestData.manager;\n\/\/ We prepare the input ontology\ntry {\nOWLOntology testOntology = manager.createOntology();\nOWLOntologyID testOntologyID = testOntology.getOntologyID();\nlog.debug(\"Created test ontology with ID: {}\", testOntologyID);\nmanager.applyChange(new AddImport(testOntology, TestData.factory.getOWLImportsDeclaration(IRI\n.create(testID))));\n\/\/ Maybe we want to see what is in before\nif (log.isDebugEnabled()) TestUtils.debug(manager.getOntology(testOntologyID), log);\n\/\/ Now we test the method\nlog.debug(\"Running HermiT\");\n\nprivate void testClassify(String testID, String testExpectedID) {\nlog.info(\"Testing the CLASSIFY task\");\nOWLOntologyManager manager = TestData.manager;\n\/\/ We prepare the input ontology\ntry {\nOWLOntology testOntology = manager.createOntology();\nOWLOntologyID testOntologyID = testOntology.getOntologyID();\nlog.debug(\"Created test ontology with ID: {}\", testOntologyID);\nmanager.applyChange(new AddImport(testOntology, TestData.factory.getOWLImportsDeclaration(IRI\n.create(testID))));\n\/\/ Maybe we want to see what is in before\nif (log.isDebugEnabled()) TestUtils.debug(manager.getOntology(testOntologyID), log);\n\/\/ Now we test the method\nlog.debug(\"Running HermiT\");\nSet<OWLAxiom> inferred = this.theinstance.runTask(ReasoningService.Tasks.CLASSIFY,\nmanager.getOntology(testOntologyID));\n\/\/ Maybe we want to see the inferred axiom list\nif (log.isDebugEnabled()) {\nTestUtils.debug(inferred, log);\n}\nSet<OWLLogicalAxiom> expectedAxioms = manager.getOntology(IRI.create(testExpectedID))\n\nOWLOntologyManager manager = TestData.manager;\n\/\/ We prepare the input ontology\ntry {\nOWLOntology testOntology = manager.createOntology();\nOWLOntologyID testOntologyID = testOntology.getOntologyID();\nlog.debug(\"Created test ontology with ID: {}\", testOntologyID);\nmanager.applyChange(new AddImport(testOntology, TestData.factory.getOWLImportsDeclaration(IRI\n.create(testID))));\n\/\/ Maybe we want to see what is in before\nif (log.isDebugEnabled()) TestUtils.debug(manager.getOntology(testOntologyID), log);\n\/\/ Now we test the method\nlog.debug(\"Running HermiT\");\nSet<OWLAxiom> inferred = this.theinstance.runTask(ReasoningService.Tasks.CLASSIFY,\nmanager.getOntology(testOntologyID));\n\/\/ Maybe we want to see the inferred axiom list\nif (log.isDebugEnabled()) {\nTestUtils.debug(inferred, log);\n}\nSet<OWLLogicalAxiom> expectedAxioms = manager.getOntology(IRI.create(testExpectedID))\n.getLogicalAxioms();\nSet<OWLAxiom> missing = new HashSet<OWLAxiom>();\n\nOWLOntologyID testOntologyID = testOntology.getOntologyID();\nlog.debug(\"Created test ontology with ID: {}\", testOntologyID);\nmanager.applyChange(new AddImport(testOntology, TestData.factory.getOWLImportsDeclaration(IRI\n.create(testID))));\n\/\/ Maybe we want to see what is in before\nif (log.isDebugEnabled()) TestUtils.debug(manager.getOntology(testOntologyID), log);\n\/\/ Now we test the method\nlog.debug(\"Running HermiT\");\nSet<OWLAxiom> inferred = this.theinstance.runTask(ReasoningService.Tasks.CLASSIFY,\nmanager.getOntology(testOntologyID));\n\/\/ Maybe we want to see the inferred axiom list\nif (log.isDebugEnabled()) {\nTestUtils.debug(inferred, log);\n}\nSet<OWLLogicalAxiom> expectedAxioms = manager.getOntology(IRI.create(testExpectedID))\n.getLogicalAxioms();\nSet<OWLAxiom> missing = new HashSet<OWLAxiom>();\nfor (OWLAxiom expected : expectedAxioms) {\nif (!inferred.contains(expected)) {\nlog.error(\"missing expected axiom: {}\", expected);\nmissing.add(expected);\n\nSet<OWLLogicalAxiom> expectedAxioms = manager.getOntology(IRI.create(testExpectedID))\n.getLogicalAxioms();\nSet<OWLAxiom> missing = new HashSet<OWLAxiom>();\nfor (OWLAxiom expected : expectedAxioms) {\nif (!inferred.contains(expected)) {\nlog.error(\"missing expected axiom: {}\", expected);\nmissing.add(expected);\n}\n}\nassertTrue(missing.isEmpty());\n\/\/ We want only Class related axioms in the result set\nfor (OWLAxiom a : inferred) {\nassertTrue(a instanceof OWLClassAssertionAxiom || a instanceof OWLSubClassOfAxiom\n|| a instanceof OWLEquivalentClassesAxiom || a instanceof OWLDisjointClassesAxiom);\n}\n\/\/ We want to remove the ontology from the manager\nmanager.removeOntology(testOntology);\n} catch (OWLOntologyCreationException e) {\nlog.error(\"An {} have been thrown while creating the input ontology for test\", e.getClass());\nassertTrue(false);\n} catch (ReasoningServiceException e) {\n\nlog.error(\"missing expected axiom: {}\", expected);\nmissing.add(expected);\n}\n}\nassertTrue(missing.isEmpty());\n\/\/ We want only Class related axioms in the result set\nfor (OWLAxiom a : inferred) {\nassertTrue(a instanceof OWLClassAssertionAxiom || a instanceof OWLSubClassOfAxiom\n|| a instanceof OWLEquivalentClassesAxiom || a instanceof OWLDisjointClassesAxiom);\n}\n\/\/ We want to remove the ontology from the manager\nmanager.removeOntology(testOntology);\n} catch (OWLOntologyCreationException e) {\nlog.error(\"An {} have been thrown while creating the input ontology for test\", e.getClass());\nassertTrue(false);\n} catch (ReasoningServiceException e) {\nlog.error(\"An {} have been thrown while executing the reasoning\", e.getClass());\nassertTrue(false);\n} catch (InconsistentInputException e) {\nlog.error(\"An {} have been thrown while executing the reasoning\", e.getClass());\nassertTrue(false);","code_context_20":"private void testClassify(String testID, String testExpectedID) {\nlog.info(\"Testing the CLASSIFY task\");\nOWLOntologyManager manager = TestData.manager;\n\/\/ We prepare the input ontology\ntry {\nOWLOntology testOntology = manager.createOntology();\nOWLOntologyID testOntologyID = testOntology.getOntologyID();\nlog.debug(\"Created test ontology with ID: {}\", testOntologyID);\nmanager.applyChange(new AddImport(testOntology, TestData.factory.getOWLImportsDeclaration(IRI\n.create(testID))));\n\/\/ Maybe we want to see what is in before\nif (log.isDebugEnabled()) TestUtils.debug(manager.getOntology(testOntologyID), log);\n\/\/ Now we test the method\nlog.debug(\"Running HermiT\");\nSet<OWLAxiom> inferred = this.theinstance.runTask(ReasoningService.Tasks.CLASSIFY,\nmanager.getOntology(testOntologyID));\n\/\/ Maybe we want to see the inferred axiom list\nif (log.isDebugEnabled()) {\nTestUtils.debug(inferred, log);\n}\nSet<OWLLogicalAxiom> expectedAxioms = manager.getOntology(IRI.create(testExpectedID))\n.getLogicalAxioms();\nSet<OWLAxiom> missing = new HashSet<OWLAxiom>();\nfor (OWLAxiom expected : expectedAxioms) {\nif (!inferred.contains(expected)) {\nlog.error(\"missing expected axiom: {}\", expected);\nmissing.add(expected);\n}\n}\nassertTrue(missing.isEmpty());\n\/\/ We want only Class related axioms in the result set\nfor (OWLAxiom a : inferred) {\nassertTrue(a instanceof OWLClassAssertionAxiom || a instanceof OWLSubClassOfAxiom\n|| a instanceof OWLEquivalentClassesAxiom || a instanceof OWLDisjointClassesAxiom);\n}\n\/\/ We want to remove the ontology from the manager\nmanager.removeOntology(testOntology);\n} catch (OWLOntologyCreationException e) {\nlog.error(\"An {} have been thrown while creating the input ontology for test\", e.getClass());\nassertTrue(false);\n} catch (ReasoningServiceException e) {\nlog.error(\"An {} have been thrown while executing the reasoning\", e.getClass());\nassertTrue(false);\n} catch (InconsistentInputException e) {\nlog.error(\"An {} have been thrown while executing the reasoning\", e.getClass());\nassertTrue(false);\n} catch (UnsupportedTaskException e) {\nlog.error(\"An {} have been thrown while executing the reasoning\", e.getClass());\nassertTrue(false);\n}\n}\n\nprivate void testClassify(String testID, String testExpectedID) {\nlog.info(\"Testing the CLASSIFY task\");\nOWLOntologyManager manager = TestData.manager;\n\/\/ We prepare the input ontology\ntry {\nOWLOntology testOntology = manager.createOntology();\nOWLOntologyID testOntologyID = testOntology.getOntologyID();\nlog.debug(\"Created test ontology with ID: {}\", testOntologyID);\nmanager.applyChange(new AddImport(testOntology, TestData.factory.getOWLImportsDeclaration(IRI\n.create(testID))));\n\/\/ Maybe we want to see what is in before\nif (log.isDebugEnabled()) TestUtils.debug(manager.getOntology(testOntologyID), log);\n\/\/ Now we test the method\nlog.debug(\"Running HermiT\");\nSet<OWLAxiom> inferred = this.theinstance.runTask(ReasoningService.Tasks.CLASSIFY,\nmanager.getOntology(testOntologyID));\n\/\/ Maybe we want to see the inferred axiom list\nif (log.isDebugEnabled()) {\nTestUtils.debug(inferred, log);\n}\nSet<OWLLogicalAxiom> expectedAxioms = manager.getOntology(IRI.create(testExpectedID))\n.getLogicalAxioms();\nSet<OWLAxiom> missing = new HashSet<OWLAxiom>();\nfor (OWLAxiom expected : expectedAxioms) {\n\nprivate void testClassify(String testID, String testExpectedID) {\nlog.info(\"Testing the CLASSIFY task\");\nOWLOntologyManager manager = TestData.manager;\n\/\/ We prepare the input ontology\ntry {\nOWLOntology testOntology = manager.createOntology();\nOWLOntologyID testOntologyID = testOntology.getOntologyID();\nlog.debug(\"Created test ontology with ID: {}\", testOntologyID);\nmanager.applyChange(new AddImport(testOntology, TestData.factory.getOWLImportsDeclaration(IRI\n.create(testID))));\n\/\/ Maybe we want to see what is in before\nif (log.isDebugEnabled()) TestUtils.debug(manager.getOntology(testOntologyID), log);\n\/\/ Now we test the method\nlog.debug(\"Running HermiT\");\nSet<OWLAxiom> inferred = this.theinstance.runTask(ReasoningService.Tasks.CLASSIFY,\nmanager.getOntology(testOntologyID));\n\/\/ Maybe we want to see the inferred axiom list\nif (log.isDebugEnabled()) {\nTestUtils.debug(inferred, log);\n}\nSet<OWLLogicalAxiom> expectedAxioms = manager.getOntology(IRI.create(testExpectedID))\n.getLogicalAxioms();\nSet<OWLAxiom> missing = new HashSet<OWLAxiom>();\nfor (OWLAxiom expected : expectedAxioms) {\nif (!inferred.contains(expected)) {\nlog.error(\"missing expected axiom: {}\", expected);\nmissing.add(expected);\n}\n}\nassertTrue(missing.isEmpty());\n\/\/ We want only Class related axioms in the result set\n\nprivate void testClassify(String testID, String testExpectedID) {\nlog.info(\"Testing the CLASSIFY task\");\nOWLOntologyManager manager = TestData.manager;\n\/\/ We prepare the input ontology\ntry {\nOWLOntology testOntology = manager.createOntology();\nOWLOntologyID testOntologyID = testOntology.getOntologyID();\nlog.debug(\"Created test ontology with ID: {}\", testOntologyID);\nmanager.applyChange(new AddImport(testOntology, TestData.factory.getOWLImportsDeclaration(IRI\n.create(testID))));\n\/\/ Maybe we want to see what is in before\nif (log.isDebugEnabled()) TestUtils.debug(manager.getOntology(testOntologyID), log);\n\/\/ Now we test the method\nlog.debug(\"Running HermiT\");\nSet<OWLAxiom> inferred = this.theinstance.runTask(ReasoningService.Tasks.CLASSIFY,\nmanager.getOntology(testOntologyID));\n\/\/ Maybe we want to see the inferred axiom list\nif (log.isDebugEnabled()) {\nTestUtils.debug(inferred, log);\n}\nSet<OWLLogicalAxiom> expectedAxioms = manager.getOntology(IRI.create(testExpectedID))\n.getLogicalAxioms();\nSet<OWLAxiom> missing = new HashSet<OWLAxiom>();\nfor (OWLAxiom expected : expectedAxioms) {\nif (!inferred.contains(expected)) {\nlog.error(\"missing expected axiom: {}\", expected);\nmissing.add(expected);\n}\n}\nassertTrue(missing.isEmpty());\n\/\/ We want only Class related axioms in the result set\nfor (OWLAxiom a : inferred) {\nassertTrue(a instanceof OWLClassAssertionAxiom || a instanceof OWLSubClassOfAxiom\n\nprivate void testClassify(String testID, String testExpectedID) {\nlog.info(\"Testing the CLASSIFY task\");\nOWLOntologyManager manager = TestData.manager;\n\/\/ We prepare the input ontology\ntry {\nOWLOntology testOntology = manager.createOntology();\nOWLOntologyID testOntologyID = testOntology.getOntologyID();\nlog.debug(\"Created test ontology with ID: {}\", testOntologyID);\nmanager.applyChange(new AddImport(testOntology, TestData.factory.getOWLImportsDeclaration(IRI\n.create(testID))));\n\/\/ Maybe we want to see what is in before\nif (log.isDebugEnabled()) TestUtils.debug(manager.getOntology(testOntologyID), log);\n\/\/ Now we test the method\nlog.debug(\"Running HermiT\");\nSet<OWLAxiom> inferred = this.theinstance.runTask(ReasoningService.Tasks.CLASSIFY,\nmanager.getOntology(testOntologyID));\n\/\/ Maybe we want to see the inferred axiom list\nif (log.isDebugEnabled()) {\nTestUtils.debug(inferred, log);\n}\nSet<OWLLogicalAxiom> expectedAxioms = manager.getOntology(IRI.create(testExpectedID))\n.getLogicalAxioms();\nSet<OWLAxiom> missing = new HashSet<OWLAxiom>();\nfor (OWLAxiom expected : expectedAxioms) {\nif (!inferred.contains(expected)) {\nlog.error(\"missing expected axiom: {}\", expected);\nmissing.add(expected);\n}\n}\nassertTrue(missing.isEmpty());\n\/\/ We want only Class related axioms in the result set\nfor (OWLAxiom a : inferred) {\nassertTrue(a instanceof OWLClassAssertionAxiom || a instanceof OWLSubClassOfAxiom\n|| a instanceof OWLEquivalentClassesAxiom || a instanceof OWLDisjointClassesAxiom);\n}\n\/\/ We want to remove the ontology from the manager\nmanager.removeOntology(testOntology);\n\n\/\/ Maybe we want to see what is in before\nif (log.isDebugEnabled()) TestUtils.debug(manager.getOntology(testOntologyID), log);\n\/\/ Now we test the method\nlog.debug(\"Running HermiT\");\nSet<OWLAxiom> inferred = this.theinstance.runTask(ReasoningService.Tasks.CLASSIFY,\nmanager.getOntology(testOntologyID));\n\/\/ Maybe we want to see the inferred axiom list\nif (log.isDebugEnabled()) {\nTestUtils.debug(inferred, log);\n}\nSet<OWLLogicalAxiom> expectedAxioms = manager.getOntology(IRI.create(testExpectedID))\n.getLogicalAxioms();\nSet<OWLAxiom> missing = new HashSet<OWLAxiom>();\nfor (OWLAxiom expected : expectedAxioms) {\nif (!inferred.contains(expected)) {\nlog.error(\"missing expected axiom: {}\", expected);\nmissing.add(expected);\n}\n}\nassertTrue(missing.isEmpty());\n\/\/ We want only Class related axioms in the result set\nfor (OWLAxiom a : inferred) {\nassertTrue(a instanceof OWLClassAssertionAxiom || a instanceof OWLSubClassOfAxiom\n|| a instanceof OWLEquivalentClassesAxiom || a instanceof OWLDisjointClassesAxiom);\n}\n\/\/ We want to remove the ontology from the manager\nmanager.removeOntology(testOntology);\n} catch (OWLOntologyCreationException e) {\nlog.error(\"An {} have been thrown while creating the input ontology for test\", e.getClass());\nassertTrue(false);\n} catch (ReasoningServiceException e) {\nlog.error(\"An {} have been thrown while executing the reasoning\", e.getClass());\nassertTrue(false);\n} catch (InconsistentInputException e) {\nlog.error(\"An {} have been thrown while executing the reasoning\", e.getClass());\nassertTrue(false);\n} catch (UnsupportedTaskException e) {\nlog.error(\"An {} have been thrown while executing the reasoning\", e.getClass());\nassertTrue(false);\n}\n}\n\nmanager.getOntology(testOntologyID));\n\/\/ Maybe we want to see the inferred axiom list\nif (log.isDebugEnabled()) {\nTestUtils.debug(inferred, log);\n}\nSet<OWLLogicalAxiom> expectedAxioms = manager.getOntology(IRI.create(testExpectedID))\n.getLogicalAxioms();\nSet<OWLAxiom> missing = new HashSet<OWLAxiom>();\nfor (OWLAxiom expected : expectedAxioms) {\nif (!inferred.contains(expected)) {\nlog.error(\"missing expected axiom: {}\", expected);\nmissing.add(expected);\n}\n}\nassertTrue(missing.isEmpty());\n\/\/ We want only Class related axioms in the result set\nfor (OWLAxiom a : inferred) {\nassertTrue(a instanceof OWLClassAssertionAxiom || a instanceof OWLSubClassOfAxiom\n|| a instanceof OWLEquivalentClassesAxiom || a instanceof OWLDisjointClassesAxiom);\n}\n\/\/ We want to remove the ontology from the manager\nmanager.removeOntology(testOntology);\n} catch (OWLOntologyCreationException e) {\nlog.error(\"An {} have been thrown while creating the input ontology for test\", e.getClass());\nassertTrue(false);\n} catch (ReasoningServiceException e) {\nlog.error(\"An {} have been thrown while executing the reasoning\", e.getClass());\nassertTrue(false);\n} catch (InconsistentInputException e) {\nlog.error(\"An {} have been thrown while executing the reasoning\", e.getClass());\nassertTrue(false);\n} catch (UnsupportedTaskException e) {\nlog.error(\"An {} have been thrown while executing the reasoning\", e.getClass());\nassertTrue(false);\n}\n}","label":[0,0,0,1]}
{"id":8668,"original_code":"@Test\n  public void testAclExtraction() {\n    CiscoXrConfiguration c = parseVendorConfig(\"acl\");\n    assertThat(c.getIpv4Acls(), hasKeys(\"acl\"));\n    Ipv4AccessList acl = c.getIpv4Acls().get(\"acl\");\n    \/\/ TODO: get the remark line in there too.\n    assertThat(acl.getLines(), hasSize(7));\n    assertThat(c.getIpv6Acls(), hasKeys(\"aclv6\"));\n    Ipv6AccessList aclv6 = c.getIpv6Acls().get(\"aclv6\");\n    \/\/ TODO: get the remark line in there too.\n    assertThat(aclv6.getLines(), hasSize(4));\n  }","code":"@Test\n  public void testAclExtraction() {\n    CiscoXrConfiguration c = parseVendorConfig(\"acl\");\n    assertThat(c.getIpv4Acls(), hasKeys(\"acl\"));\n    Ipv4AccessList acl = c.getIpv4Acls().get(\"acl\");\n   \n    assertThat(acl.getLines(), hasSize(7));\n    assertThat(c.getIpv6Acls(), hasKeys(\"aclv6\"));\n    Ipv6AccessList aclv6 = c.getIpv6Acls().get(\"aclv6\");\n   \n    assertThat(aclv6.getLines(), hasSize(4));\n  }","cleancode":"@test public void testaclextraction() { ciscoxrconfiguration c = parsevendorconfig(\"acl\"); assertthat(c.getipv4acls(), haskeys(\"acl\")); ipv4accesslist acl = c.getipv4acls().get(\"acl\"); assertthat(acl.getlines(), hassize(7)); assertthat(c.getipv6acls(), haskeys(\"aclv6\")); ipv6accesslist aclv6 = c.getipv6acls().get(\"aclv6\"); assertthat(aclv6.getlines(), hassize(4)); }","comment":"\/\/ todo: get the remark line in there too.\n\/\/ todo: get the remark line in there too.","repo":"pranavbj-amzn\/batfish","code_context_2":"assertThat(c.getIpv4Acls(), hasKeys(\"acl\"));\nIpv4AccessList acl = c.getIpv4Acls().get(\"acl\");\n\/\/ TODO: get the remark line in there too.\nassertThat(acl.getLines(), hasSize(7));\nassertThat(c.getIpv6Acls(), hasKeys(\"aclv6\"));\n\nassertThat(c.getIpv4Acls(), hasKeys(\"acl\"));\nIpv4AccessList acl = c.getIpv4Acls().get(\"acl\");\n\/\/ TODO: get the remark line in there too.\nassertThat(acl.getLines(), hasSize(7));\nassertThat(c.getIpv6Acls(), hasKeys(\"aclv6\"));","code_context_10":"@Test\npublic void testAclExtraction() {\nCiscoXrConfiguration c = parseVendorConfig(\"acl\");\nassertThat(c.getIpv4Acls(), hasKeys(\"acl\"));\nIpv4AccessList acl = c.getIpv4Acls().get(\"acl\");\n\/\/ TODO: get the remark line in there too.\nassertThat(acl.getLines(), hasSize(7));\nassertThat(c.getIpv6Acls(), hasKeys(\"aclv6\"));\nIpv6AccessList aclv6 = c.getIpv6Acls().get(\"aclv6\");\n\/\/ TODO: get the remark line in there too.\nassertThat(aclv6.getLines(), hasSize(4));\n}\n\n@Test\npublic void testAclExtraction() {\nCiscoXrConfiguration c = parseVendorConfig(\"acl\");\nassertThat(c.getIpv4Acls(), hasKeys(\"acl\"));\nIpv4AccessList acl = c.getIpv4Acls().get(\"acl\");\n\/\/ TODO: get the remark line in there too.\nassertThat(acl.getLines(), hasSize(7));\nassertThat(c.getIpv6Acls(), hasKeys(\"aclv6\"));\nIpv6AccessList aclv6 = c.getIpv6Acls().get(\"aclv6\");\n\/\/ TODO: get the remark line in there too.\nassertThat(aclv6.getLines(), hasSize(4));\n}","code_context_20":"@Test\npublic void testAclExtraction() {\nCiscoXrConfiguration c = parseVendorConfig(\"acl\");\nassertThat(c.getIpv4Acls(), hasKeys(\"acl\"));\nIpv4AccessList acl = c.getIpv4Acls().get(\"acl\");\n\/\/ TODO: get the remark line in there too.\nassertThat(acl.getLines(), hasSize(7));\nassertThat(c.getIpv6Acls(), hasKeys(\"aclv6\"));\nIpv6AccessList aclv6 = c.getIpv6Acls().get(\"aclv6\");\n\/\/ TODO: get the remark line in there too.\nassertThat(aclv6.getLines(), hasSize(4));\n}\n\n@Test\npublic void testAclExtraction() {\nCiscoXrConfiguration c = parseVendorConfig(\"acl\");\nassertThat(c.getIpv4Acls(), hasKeys(\"acl\"));\nIpv4AccessList acl = c.getIpv4Acls().get(\"acl\");\n\/\/ TODO: get the remark line in there too.\nassertThat(acl.getLines(), hasSize(7));\nassertThat(c.getIpv6Acls(), hasKeys(\"aclv6\"));\nIpv6AccessList aclv6 = c.getIpv6Acls().get(\"aclv6\");\n\/\/ TODO: get the remark line in there too.\nassertThat(aclv6.getLines(), hasSize(4));\n}","label":[1,0,0,0]}
{"id":8669,"original_code":"@Test\n  public void testAclConversion() {\n    Configuration c = parseConfig(\"acl\");\n    assertThat(c.getIpAccessLists(), hasKeys(\"acl\"));\n    IpAccessList acl = c.getIpAccessLists().get(\"acl\");\n    \/\/ TODO: get the remark line in there too.\n    assertThat(acl.getLines(), hasSize(7));\n    assertThat(c.getIp6AccessLists(), hasKeys(\"aclv6\"));\n    Ip6AccessList aclv6 = c.getIp6AccessLists().get(\"aclv6\");\n    \/\/ TODO: get the remark line in there too.\n    assertThat(aclv6.getLines(), hasSize(4));\n  }","code":"@Test\n  public void testAclConversion() {\n    Configuration c = parseConfig(\"acl\");\n    assertThat(c.getIpAccessLists(), hasKeys(\"acl\"));\n    IpAccessList acl = c.getIpAccessLists().get(\"acl\");\n   \n    assertThat(acl.getLines(), hasSize(7));\n    assertThat(c.getIp6AccessLists(), hasKeys(\"aclv6\"));\n    Ip6AccessList aclv6 = c.getIp6AccessLists().get(\"aclv6\");\n   \n    assertThat(aclv6.getLines(), hasSize(4));\n  }","cleancode":"@test public void testaclconversion() { configuration c = parseconfig(\"acl\"); assertthat(c.getipaccesslists(), haskeys(\"acl\")); ipaccesslist acl = c.getipaccesslists().get(\"acl\"); assertthat(acl.getlines(), hassize(7)); assertthat(c.getip6accesslists(), haskeys(\"aclv6\")); ip6accesslist aclv6 = c.getip6accesslists().get(\"aclv6\"); assertthat(aclv6.getlines(), hassize(4)); }","comment":"\/\/ todo: get the remark line in there too.\n\/\/ todo: get the remark line in there too.","repo":"pranavbj-amzn\/batfish","code_context_2":"assertThat(c.getIpAccessLists(), hasKeys(\"acl\"));\nIpAccessList acl = c.getIpAccessLists().get(\"acl\");\n\/\/ TODO: get the remark line in there too.\nassertThat(acl.getLines(), hasSize(7));\nassertThat(c.getIp6AccessLists(), hasKeys(\"aclv6\"));\n\nassertThat(c.getIpAccessLists(), hasKeys(\"acl\"));\nIpAccessList acl = c.getIpAccessLists().get(\"acl\");\n\/\/ TODO: get the remark line in there too.\nassertThat(acl.getLines(), hasSize(7));\nassertThat(c.getIp6AccessLists(), hasKeys(\"aclv6\"));","code_context_10":"@Test\npublic void testAclConversion() {\nConfiguration c = parseConfig(\"acl\");\nassertThat(c.getIpAccessLists(), hasKeys(\"acl\"));\nIpAccessList acl = c.getIpAccessLists().get(\"acl\");\n\/\/ TODO: get the remark line in there too.\nassertThat(acl.getLines(), hasSize(7));\nassertThat(c.getIp6AccessLists(), hasKeys(\"aclv6\"));\nIp6AccessList aclv6 = c.getIp6AccessLists().get(\"aclv6\");\n\/\/ TODO: get the remark line in there too.\nassertThat(aclv6.getLines(), hasSize(4));\n}\n\n@Test\npublic void testAclConversion() {\nConfiguration c = parseConfig(\"acl\");\nassertThat(c.getIpAccessLists(), hasKeys(\"acl\"));\nIpAccessList acl = c.getIpAccessLists().get(\"acl\");\n\/\/ TODO: get the remark line in there too.\nassertThat(acl.getLines(), hasSize(7));\nassertThat(c.getIp6AccessLists(), hasKeys(\"aclv6\"));\nIp6AccessList aclv6 = c.getIp6AccessLists().get(\"aclv6\");\n\/\/ TODO: get the remark line in there too.\nassertThat(aclv6.getLines(), hasSize(4));\n}","code_context_20":"@Test\npublic void testAclConversion() {\nConfiguration c = parseConfig(\"acl\");\nassertThat(c.getIpAccessLists(), hasKeys(\"acl\"));\nIpAccessList acl = c.getIpAccessLists().get(\"acl\");\n\/\/ TODO: get the remark line in there too.\nassertThat(acl.getLines(), hasSize(7));\nassertThat(c.getIp6AccessLists(), hasKeys(\"aclv6\"));\nIp6AccessList aclv6 = c.getIp6AccessLists().get(\"aclv6\");\n\/\/ TODO: get the remark line in there too.\nassertThat(aclv6.getLines(), hasSize(4));\n}\n\n@Test\npublic void testAclConversion() {\nConfiguration c = parseConfig(\"acl\");\nassertThat(c.getIpAccessLists(), hasKeys(\"acl\"));\nIpAccessList acl = c.getIpAccessLists().get(\"acl\");\n\/\/ TODO: get the remark line in there too.\nassertThat(acl.getLines(), hasSize(7));\nassertThat(c.getIp6AccessLists(), hasKeys(\"aclv6\"));\nIp6AccessList aclv6 = c.getIp6AccessLists().get(\"aclv6\");\n\/\/ TODO: get the remark line in there too.\nassertThat(aclv6.getLines(), hasSize(4));\n}","label":[1,0,0,0]}
{"id":33288,"original_code":"@Override\n\t\tpublic boolean onTouch(View v, MotionEvent event) {\n\t\t\tswitch(event.getAction()){\n\t\t\t\tcase MotionEvent.ACTION_CANCEL:\n\t\t\t\t\t_downTime.set(0);\n\t\t\t\t\tbreak;\n\t\t\t\tcase MotionEvent.ACTION_DOWN:\n\t\t\t\t\t_downTime.set(System.currentTimeMillis());\n\t\t\t\t\t_downX = event.getX();\n\t\t\t\t\t_downY = event.getY();\n\t\t\t\t\tif(_longClickTimer == null){\t\/\/ if there is no pre-existing task, create a new one\n\t\t\t\t\t\t_longClickTimer = new AsyncTask<Void, Void, Boolean>(){\n\t\t\t\t\t\t\t@Override\n\t\t\t\t\t\t\tprotected Boolean doInBackground(Void... params) {\n\t\t\t\t\t\t\t\ttry{\n\t\t\t\t\t\t\t\t\tfor(long i=0;i<Definitions.THRESHOLD_LONG_CLICK_MAX_DURATION;i+=INTERVAL_LONG_CLICK_CHECK){\n\t\t\t\t\t\t\t\t\t\tThread.sleep(INTERVAL_LONG_CLICK_CHECK);\n\t\t\t\t\t\t\t\t\t\tlong downTime = _downTime.get();\n\t\t\t\t\t\t\t\t\t\tif(downTime > 0 && System.currentTimeMillis()-downTime > Definitions.THRESHOLD_LONG_CLICK_MIN_DURATION){\n\t\t\t\t\t\t\t\t\t\t\treturn true;\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}catch(InterruptedException ex){\n\t\t\t\t\t\t\t\t\tLogUtils.warn(CLASS_NAME, \"doInBackground\", ex.toString());\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\treturn false;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t@Override\n\t\t\t\t\t\t\tprotected void onPostExecute(Boolean result) {\n\t\t\t\t\t\t\t\tif(result){\n\t\t\t\t\t\t\t\t\tcenterChart();\n\t\t\t\t\t\t\t\t\t_downTime.set(0);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t_longClickTimer = null;\n\t\t\t\t\t\t\t}\t\t\t\t\t\n\t\t\t\t\t\t};\t\/\/ new asyncTask\n\t\t\t\t\t\t_longClickTimer.execute();\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\tcase MotionEvent.ACTION_MOVE:\n\t\t\t\t\tcheckForMovement(event);\n\t\t\t\t\tbreak;\n\t\t\t\tcase MotionEvent.ACTION_UP:\n\t\t\t\t\tlong downTime = _downTime.getAndSet(0);\n\t\t\t\t\tif(downTime != 0 && (System.currentTimeMillis()-downTime) < Definitions.THRESHOLD_CLICK_MAX_DURATION && !checkForMovement(event)){\n\t\t\t\t\t\tSeriesSelection selection = _viewChart.getCurrentSeriesAndPoint();\n\t\t\t\t\t\tif(selection == null || selection.getSeriesIndex() != 0){\t\/\/ if there was no selection or this is not the first series (point values)\n\t\t\t\t\t\t\tLogUtils.debug(CLASS_NAME, \"onTouch\", \"No usable selection.\");\n\t\t\t\t\t\t}else{\n\t\t\t\t\t\t\tList<GaugeValue> values = _currentGauge.getValues();\n\t\t\t\t\t\t\tint valueCount = values.size();\n\t\t\t\t\t\t\tint index = 0;\n\t\t\t\t\t\t\t\/\/TODO: this will break if the chart shows something else than the last getMaxGraphPoints() of values\n\t\t\t\t\t\t\tif(valueCount - _settings.getMaxGraphPoints() > 0){\n\t\t\t\t\t\t\t\tindex = valueCount - _settings.getMaxGraphPoints() + selection.getPointIndex();\n\t\t\t\t\t\t\t}else{\n\t\t\t\t\t\t\t\tindex = selection.getPointIndex();\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t_currentValue = _currentGauge.getValues().get(index);\n\t\t\t\t\t\t\t(new GaugeValueDialog()).show(GraphActivity.this.getSupportFragmentManager(), GaugeValueDialog.TAG);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t\t\tbreak;\t\/\/ ignore everything else\n\t\t\t}\n\t\t\treturn false;\t\/\/ always return false so that we do not interfere with the graph pan\/zoom controls\n\t\t}","code":"@Override\n\t\tpublic boolean onTouch(View v, MotionEvent event) {\n\t\t\tswitch(event.getAction()){\n\t\t\t\tcase MotionEvent.ACTION_CANCEL:\n\t\t\t\t\t_downTime.set(0);\n\t\t\t\t\tbreak;\n\t\t\t\tcase MotionEvent.ACTION_DOWN:\n\t\t\t\t\t_downTime.set(System.currentTimeMillis());\n\t\t\t\t\t_downX = event.getX();\n\t\t\t\t\t_downY = event.getY();\n\t\t\t\t\tif(_longClickTimer == null){\n\t\t\t\t\t\t_longClickTimer = new AsyncTask<Void, Void, Boolean>(){\n\t\t\t\t\t\t\t@Override\n\t\t\t\t\t\t\tprotected Boolean doInBackground(Void... params) {\n\t\t\t\t\t\t\t\ttry{\n\t\t\t\t\t\t\t\t\tfor(long i=0;i<Definitions.THRESHOLD_LONG_CLICK_MAX_DURATION;i+=INTERVAL_LONG_CLICK_CHECK){\n\t\t\t\t\t\t\t\t\t\tThread.sleep(INTERVAL_LONG_CLICK_CHECK);\n\t\t\t\t\t\t\t\t\t\tlong downTime = _downTime.get();\n\t\t\t\t\t\t\t\t\t\tif(downTime > 0 && System.currentTimeMillis()-downTime > Definitions.THRESHOLD_LONG_CLICK_MIN_DURATION){\n\t\t\t\t\t\t\t\t\t\t\treturn true;\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}catch(InterruptedException ex){\n\t\t\t\t\t\t\t\t\tLogUtils.warn(CLASS_NAME, \"doInBackground\", ex.toString());\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\treturn false;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t@Override\n\t\t\t\t\t\t\tprotected void onPostExecute(Boolean result) {\n\t\t\t\t\t\t\t\tif(result){\n\t\t\t\t\t\t\t\t\tcenterChart();\n\t\t\t\t\t\t\t\t\t_downTime.set(0);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t_longClickTimer = null;\n\t\t\t\t\t\t\t}\t\t\t\t\t\n\t\t\t\t\t\t};\n\t\t\t\t\t\t_longClickTimer.execute();\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\tcase MotionEvent.ACTION_MOVE:\n\t\t\t\t\tcheckForMovement(event);\n\t\t\t\t\tbreak;\n\t\t\t\tcase MotionEvent.ACTION_UP:\n\t\t\t\t\tlong downTime = _downTime.getAndSet(0);\n\t\t\t\t\tif(downTime != 0 && (System.currentTimeMillis()-downTime) < Definitions.THRESHOLD_CLICK_MAX_DURATION && !checkForMovement(event)){\n\t\t\t\t\t\tSeriesSelection selection = _viewChart.getCurrentSeriesAndPoint();\n\t\t\t\t\t\tif(selection == null || selection.getSeriesIndex() != 0){\n\t\t\t\t\t\t\tLogUtils.debug(CLASS_NAME, \"onTouch\", \"No usable selection.\");\n\t\t\t\t\t\t}else{\n\t\t\t\t\t\t\tList<GaugeValue> values = _currentGauge.getValues();\n\t\t\t\t\t\t\tint valueCount = values.size();\n\t\t\t\t\t\t\tint index = 0;\n\t\t\t\t\t\t\n\t\t\t\t\t\t\tif(valueCount - _settings.getMaxGraphPoints() > 0){\n\t\t\t\t\t\t\t\tindex = valueCount - _settings.getMaxGraphPoints() + selection.getPointIndex();\n\t\t\t\t\t\t\t}else{\n\t\t\t\t\t\t\t\tindex = selection.getPointIndex();\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t_currentValue = _currentGauge.getValues().get(index);\n\t\t\t\t\t\t\t(new GaugeValueDialog()).show(GraphActivity.this.getSupportFragmentManager(), GaugeValueDialog.TAG);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t\treturn false;\n\t\t}","cleancode":"@override public boolean ontouch(view v, motionevent event) { switch(event.getaction()){ case motionevent.action_cancel: _downtime.set(0); break; case motionevent.action_down: _downtime.set(system.currenttimemillis()); _downx = event.getx(); _downy = event.gety(); if(_longclicktimer == null){ _longclicktimer = new asynctask<void, void, boolean>(){ @override protected boolean doinbackground(void... params) { try{ for(long i=0;i<definitions.threshold_long_click_max_duration;i+=interval_long_click_check){ thread.sleep(interval_long_click_check); long downtime = _downtime.get(); if(downtime > 0 && system.currenttimemillis()-downtime > definitions.threshold_long_click_min_duration){ return true; } } }catch(interruptedexception ex){ logutils.warn(class_name, \"doinbackground\", ex.tostring()); } return false; } @override protected void onpostexecute(boolean result) { if(result){ centerchart(); _downtime.set(0); } _longclicktimer = null; } }; _longclicktimer.execute(); } break; case motionevent.action_move: checkformovement(event); break; case motionevent.action_up: long downtime = _downtime.getandset(0); if(downtime != 0 && (system.currenttimemillis()-downtime) < definitions.threshold_click_max_duration && !checkformovement(event)){ seriesselection selection = _viewchart.getcurrentseriesandpoint(); if(selection == null || selection.getseriesindex() != 0){ logutils.debug(class_name, \"ontouch\", \"no usable selection.\"); }else{ list<gaugevalue> values = _currentgauge.getvalues(); int valuecount = values.size(); int index = 0; if(valuecount - _settings.getmaxgraphpoints() > 0){ index = valuecount - _settings.getmaxgraphpoints() + selection.getpointindex(); }else{ index = selection.getpointindex(); } _currentvalue = _currentgauge.getvalues().get(index); (new gaugevaluedialog()).show(graphactivity.this.getsupportfragmentmanager(), gaugevaluedialog.tag); } } break; default: break; } return false; }","comment":"\/\/ if there is no pre-existing task, create a new one\n\/\/ new asynctask\n\/\/ if there was no selection or this is not the first series (point values)\n\/\/todo: this will break if the chart shows something else than the last getmaxgraphpoints() of values\n\/\/ ignore everything else\n\/\/ always return false so that we do not interfere with the graph pan\/zoom controls","repo":"otula\/kiiaudata","code_context_2":"_downX = event.getX();\n_downY = event.getY();\nif(_longClickTimer == null){ \/\/ if there is no pre-existing task, create a new one\n_longClickTimer = new AsyncTask<Void, Void, Boolean>(){\n@Override\n\n_longClickTimer = null;\n}\n}; \/\/ new asyncTask\n_longClickTimer.execute();\n}\n\nif(downTime != 0 && (System.currentTimeMillis()-downTime) < Definitions.THRESHOLD_CLICK_MAX_DURATION && !checkForMovement(event)){\nSeriesSelection selection = _viewChart.getCurrentSeriesAndPoint();\nif(selection == null || selection.getSeriesIndex() != 0){ \/\/ if there was no selection or this is not the first series (point values)\nLogUtils.debug(CLASS_NAME, \"onTouch\", \"No usable selection.\");\n}else{\n\nint valueCount = values.size();\nint index = 0;\n\/\/TODO: this will break if the chart shows something else than the last getMaxGraphPoints() of values\nif(valueCount - _settings.getMaxGraphPoints() > 0){\nindex = valueCount - _settings.getMaxGraphPoints() + selection.getPointIndex();\n\nbreak;\ndefault:\nbreak; \/\/ ignore everything else\n}\nreturn false; \/\/ always return false so that we do not interfere with the graph pan\/zoom controls\n\nbreak; \/\/ ignore everything else\n}\nreturn false; \/\/ always return false so that we do not interfere with the graph pan\/zoom controls\n}","code_context_10":"@Override\npublic boolean onTouch(View v, MotionEvent event) {\nswitch(event.getAction()){\ncase MotionEvent.ACTION_CANCEL:\n_downTime.set(0);\nbreak;\ncase MotionEvent.ACTION_DOWN:\n_downTime.set(System.currentTimeMillis());\n_downX = event.getX();\n_downY = event.getY();\nif(_longClickTimer == null){ \/\/ if there is no pre-existing task, create a new one\n_longClickTimer = new AsyncTask<Void, Void, Boolean>(){\n@Override\nprotected Boolean doInBackground(Void... params) {\ntry{\nfor(long i=0;i<Definitions.THRESHOLD_LONG_CLICK_MAX_DURATION;i+=INTERVAL_LONG_CLICK_CHECK){\nThread.sleep(INTERVAL_LONG_CLICK_CHECK);\nlong downTime = _downTime.get();\nif(downTime > 0 && System.currentTimeMillis()-downTime > Definitions.THRESHOLD_LONG_CLICK_MIN_DURATION){\nreturn true;\n}\n\nreturn false;\n}\n@Override\nprotected void onPostExecute(Boolean result) {\nif(result){\ncenterChart();\n_downTime.set(0);\n}\n_longClickTimer = null;\n}\n}; \/\/ new asyncTask\n_longClickTimer.execute();\n}\nbreak;\ncase MotionEvent.ACTION_MOVE:\ncheckForMovement(event);\nbreak;\ncase MotionEvent.ACTION_UP:\nlong downTime = _downTime.getAndSet(0);\nif(downTime != 0 && (System.currentTimeMillis()-downTime) < Definitions.THRESHOLD_CLICK_MAX_DURATION && !checkForMovement(event)){\nSeriesSelection selection = _viewChart.getCurrentSeriesAndPoint();\n\n_longClickTimer.execute();\n}\nbreak;\ncase MotionEvent.ACTION_MOVE:\ncheckForMovement(event);\nbreak;\ncase MotionEvent.ACTION_UP:\nlong downTime = _downTime.getAndSet(0);\nif(downTime != 0 && (System.currentTimeMillis()-downTime) < Definitions.THRESHOLD_CLICK_MAX_DURATION && !checkForMovement(event)){\nSeriesSelection selection = _viewChart.getCurrentSeriesAndPoint();\nif(selection == null || selection.getSeriesIndex() != 0){ \/\/ if there was no selection or this is not the first series (point values)\nLogUtils.debug(CLASS_NAME, \"onTouch\", \"No usable selection.\");\n}else{\nList<GaugeValue> values = _currentGauge.getValues();\nint valueCount = values.size();\nint index = 0;\n\/\/TODO: this will break if the chart shows something else than the last getMaxGraphPoints() of values\nif(valueCount - _settings.getMaxGraphPoints() > 0){\nindex = valueCount - _settings.getMaxGraphPoints() + selection.getPointIndex();\n}else{\nindex = selection.getPointIndex();\n\ncase MotionEvent.ACTION_UP:\nlong downTime = _downTime.getAndSet(0);\nif(downTime != 0 && (System.currentTimeMillis()-downTime) < Definitions.THRESHOLD_CLICK_MAX_DURATION && !checkForMovement(event)){\nSeriesSelection selection = _viewChart.getCurrentSeriesAndPoint();\nif(selection == null || selection.getSeriesIndex() != 0){ \/\/ if there was no selection or this is not the first series (point values)\nLogUtils.debug(CLASS_NAME, \"onTouch\", \"No usable selection.\");\n}else{\nList<GaugeValue> values = _currentGauge.getValues();\nint valueCount = values.size();\nint index = 0;\n\/\/TODO: this will break if the chart shows something else than the last getMaxGraphPoints() of values\nif(valueCount - _settings.getMaxGraphPoints() > 0){\nindex = valueCount - _settings.getMaxGraphPoints() + selection.getPointIndex();\n}else{\nindex = selection.getPointIndex();\n}\n_currentValue = _currentGauge.getValues().get(index);\n(new GaugeValueDialog()).show(GraphActivity.this.getSupportFragmentManager(), GaugeValueDialog.TAG);\n}\n}\nbreak;\n\nindex = valueCount - _settings.getMaxGraphPoints() + selection.getPointIndex();\n}else{\nindex = selection.getPointIndex();\n}\n_currentValue = _currentGauge.getValues().get(index);\n(new GaugeValueDialog()).show(GraphActivity.this.getSupportFragmentManager(), GaugeValueDialog.TAG);\n}\n}\nbreak;\ndefault:\nbreak; \/\/ ignore everything else\n}\nreturn false; \/\/ always return false so that we do not interfere with the graph pan\/zoom controls\n}\n\nindex = selection.getPointIndex();\n}\n_currentValue = _currentGauge.getValues().get(index);\n(new GaugeValueDialog()).show(GraphActivity.this.getSupportFragmentManager(), GaugeValueDialog.TAG);\n}\n}\nbreak;\ndefault:\nbreak; \/\/ ignore everything else\n}\nreturn false; \/\/ always return false so that we do not interfere with the graph pan\/zoom controls\n}","code_context_20":"@Override\npublic boolean onTouch(View v, MotionEvent event) {\nswitch(event.getAction()){\ncase MotionEvent.ACTION_CANCEL:\n_downTime.set(0);\nbreak;\ncase MotionEvent.ACTION_DOWN:\n_downTime.set(System.currentTimeMillis());\n_downX = event.getX();\n_downY = event.getY();\nif(_longClickTimer == null){ \/\/ if there is no pre-existing task, create a new one\n_longClickTimer = new AsyncTask<Void, Void, Boolean>(){\n@Override\nprotected Boolean doInBackground(Void... params) {\ntry{\nfor(long i=0;i<Definitions.THRESHOLD_LONG_CLICK_MAX_DURATION;i+=INTERVAL_LONG_CLICK_CHECK){\nThread.sleep(INTERVAL_LONG_CLICK_CHECK);\nlong downTime = _downTime.get();\nif(downTime > 0 && System.currentTimeMillis()-downTime > Definitions.THRESHOLD_LONG_CLICK_MIN_DURATION){\nreturn true;\n}\n}\n}catch(InterruptedException ex){\nLogUtils.warn(CLASS_NAME, \"doInBackground\", ex.toString());\n}\nreturn false;\n}\n@Override\nprotected void onPostExecute(Boolean result) {\nif(result){\ncenterChart();\n\nfor(long i=0;i<Definitions.THRESHOLD_LONG_CLICK_MAX_DURATION;i+=INTERVAL_LONG_CLICK_CHECK){\nThread.sleep(INTERVAL_LONG_CLICK_CHECK);\nlong downTime = _downTime.get();\nif(downTime > 0 && System.currentTimeMillis()-downTime > Definitions.THRESHOLD_LONG_CLICK_MIN_DURATION){\nreturn true;\n}\n}\n}catch(InterruptedException ex){\nLogUtils.warn(CLASS_NAME, \"doInBackground\", ex.toString());\n}\nreturn false;\n}\n@Override\nprotected void onPostExecute(Boolean result) {\nif(result){\ncenterChart();\n_downTime.set(0);\n}\n_longClickTimer = null;\n}\n}; \/\/ new asyncTask\n_longClickTimer.execute();\n}\nbreak;\ncase MotionEvent.ACTION_MOVE:\ncheckForMovement(event);\nbreak;\ncase MotionEvent.ACTION_UP:\nlong downTime = _downTime.getAndSet(0);\nif(downTime != 0 && (System.currentTimeMillis()-downTime) < Definitions.THRESHOLD_CLICK_MAX_DURATION && !checkForMovement(event)){\nSeriesSelection selection = _viewChart.getCurrentSeriesAndPoint();\nif(selection == null || selection.getSeriesIndex() != 0){ \/\/ if there was no selection or this is not the first series (point values)\nLogUtils.debug(CLASS_NAME, \"onTouch\", \"No usable selection.\");\n}else{\nList<GaugeValue> values = _currentGauge.getValues();\nint valueCount = values.size();\nint index = 0;\n\/\/TODO: this will break if the chart shows something else than the last getMaxGraphPoints() of values\nif(valueCount - _settings.getMaxGraphPoints() > 0){\nindex = valueCount - _settings.getMaxGraphPoints() + selection.getPointIndex();\n}else{\n\n}\n@Override\nprotected void onPostExecute(Boolean result) {\nif(result){\ncenterChart();\n_downTime.set(0);\n}\n_longClickTimer = null;\n}\n}; \/\/ new asyncTask\n_longClickTimer.execute();\n}\nbreak;\ncase MotionEvent.ACTION_MOVE:\ncheckForMovement(event);\nbreak;\ncase MotionEvent.ACTION_UP:\nlong downTime = _downTime.getAndSet(0);\nif(downTime != 0 && (System.currentTimeMillis()-downTime) < Definitions.THRESHOLD_CLICK_MAX_DURATION && !checkForMovement(event)){\nSeriesSelection selection = _viewChart.getCurrentSeriesAndPoint();\nif(selection == null || selection.getSeriesIndex() != 0){ \/\/ if there was no selection or this is not the first series (point values)\nLogUtils.debug(CLASS_NAME, \"onTouch\", \"No usable selection.\");\n}else{\nList<GaugeValue> values = _currentGauge.getValues();\nint valueCount = values.size();\nint index = 0;\n\/\/TODO: this will break if the chart shows something else than the last getMaxGraphPoints() of values\nif(valueCount - _settings.getMaxGraphPoints() > 0){\nindex = valueCount - _settings.getMaxGraphPoints() + selection.getPointIndex();\n}else{\nindex = selection.getPointIndex();\n}\n_currentValue = _currentGauge.getValues().get(index);\n(new GaugeValueDialog()).show(GraphActivity.this.getSupportFragmentManager(), GaugeValueDialog.TAG);\n}\n}\nbreak;\ndefault:\nbreak; \/\/ ignore everything else\n}\nreturn false; \/\/ always return false so that we do not interfere with the graph pan\/zoom controls\n\n}\n_longClickTimer = null;\n}\n}; \/\/ new asyncTask\n_longClickTimer.execute();\n}\nbreak;\ncase MotionEvent.ACTION_MOVE:\ncheckForMovement(event);\nbreak;\ncase MotionEvent.ACTION_UP:\nlong downTime = _downTime.getAndSet(0);\nif(downTime != 0 && (System.currentTimeMillis()-downTime) < Definitions.THRESHOLD_CLICK_MAX_DURATION && !checkForMovement(event)){\nSeriesSelection selection = _viewChart.getCurrentSeriesAndPoint();\nif(selection == null || selection.getSeriesIndex() != 0){ \/\/ if there was no selection or this is not the first series (point values)\nLogUtils.debug(CLASS_NAME, \"onTouch\", \"No usable selection.\");\n}else{\nList<GaugeValue> values = _currentGauge.getValues();\nint valueCount = values.size();\nint index = 0;\n\/\/TODO: this will break if the chart shows something else than the last getMaxGraphPoints() of values\nif(valueCount - _settings.getMaxGraphPoints() > 0){\nindex = valueCount - _settings.getMaxGraphPoints() + selection.getPointIndex();\n}else{\nindex = selection.getPointIndex();\n}\n_currentValue = _currentGauge.getValues().get(index);\n(new GaugeValueDialog()).show(GraphActivity.this.getSupportFragmentManager(), GaugeValueDialog.TAG);\n}\n}\nbreak;\ndefault:\nbreak; \/\/ ignore everything else\n}\nreturn false; \/\/ always return false so that we do not interfere with the graph pan\/zoom controls\n}\n\nif(downTime != 0 && (System.currentTimeMillis()-downTime) < Definitions.THRESHOLD_CLICK_MAX_DURATION && !checkForMovement(event)){\nSeriesSelection selection = _viewChart.getCurrentSeriesAndPoint();\nif(selection == null || selection.getSeriesIndex() != 0){ \/\/ if there was no selection or this is not the first series (point values)\nLogUtils.debug(CLASS_NAME, \"onTouch\", \"No usable selection.\");\n}else{\nList<GaugeValue> values = _currentGauge.getValues();\nint valueCount = values.size();\nint index = 0;\n\/\/TODO: this will break if the chart shows something else than the last getMaxGraphPoints() of values\nif(valueCount - _settings.getMaxGraphPoints() > 0){\nindex = valueCount - _settings.getMaxGraphPoints() + selection.getPointIndex();\n}else{\nindex = selection.getPointIndex();\n}\n_currentValue = _currentGauge.getValues().get(index);\n(new GaugeValueDialog()).show(GraphActivity.this.getSupportFragmentManager(), GaugeValueDialog.TAG);\n}\n}\nbreak;\ndefault:\nbreak; \/\/ ignore everything else\n}\nreturn false; \/\/ always return false so that we do not interfere with the graph pan\/zoom controls\n}\n\nif(selection == null || selection.getSeriesIndex() != 0){ \/\/ if there was no selection or this is not the first series (point values)\nLogUtils.debug(CLASS_NAME, \"onTouch\", \"No usable selection.\");\n}else{\nList<GaugeValue> values = _currentGauge.getValues();\nint valueCount = values.size();\nint index = 0;\n\/\/TODO: this will break if the chart shows something else than the last getMaxGraphPoints() of values\nif(valueCount - _settings.getMaxGraphPoints() > 0){\nindex = valueCount - _settings.getMaxGraphPoints() + selection.getPointIndex();\n}else{\nindex = selection.getPointIndex();\n}\n_currentValue = _currentGauge.getValues().get(index);\n(new GaugeValueDialog()).show(GraphActivity.this.getSupportFragmentManager(), GaugeValueDialog.TAG);\n}\n}\nbreak;\ndefault:\nbreak; \/\/ ignore everything else\n}\nreturn false; \/\/ always return false so that we do not interfere with the graph pan\/zoom controls\n}","label":[0,0,1,0]}
{"id":675,"original_code":"@Override\n    public int describeContents() {\n        return 0;\/\/TODO figure out how to act with this stuff\n    }","code":"@Override\n    public int describeContents() {\n        return 0\n    }","cleancode":"@override public int describecontents() { return 0 }","comment":"\/\/todo figure out how to act with this stuff","repo":"programmerr47\/breverkruntkin-test-task","code_context_2":"@Override\npublic int describeContents() {\nreturn 0;\/\/TODO figure out how to act with this stuff\n}","code_context_10":"@Override\npublic int describeContents() {\nreturn 0;\/\/TODO figure out how to act with this stuff\n}","code_context_20":"@Override\npublic int describeContents() {\nreturn 0;\/\/TODO figure out how to act with this stuff\n}","label":[1,0,0,0]}
{"id":8907,"original_code":"public void setWs(boolean b) {\n    \/\/ TODO: document me\n    this.tr.setSkipws(b);\n  }","code":"public void setWs(boolean b) {\n   \n    this.tr.setSkipws(b);\n  }","cleancode":"public void setws(boolean b) { this.tr.setskipws(b); }","comment":"\/\/ todo: document me","repo":"rebse\/flaka","code_context_2":"public void setWs(boolean b) {\n\/\/ TODO: document me\nthis.tr.setSkipws(b);\n}","code_context_10":"public void setWs(boolean b) {\n\/\/ TODO: document me\nthis.tr.setSkipws(b);\n}","code_context_20":"public void setWs(boolean b) {\n\/\/ TODO: document me\nthis.tr.setSkipws(b);\n}","label":[0,0,0,0]}
{"id":8908,"original_code":"public void setCl(boolean b) {\n    \/\/ TODO: document me\n    this.tr.setResolveContLines(b);\n  }","code":"public void setCl(boolean b) {\n   \n    this.tr.setResolveContLines(b);\n  }","cleancode":"public void setcl(boolean b) { this.tr.setresolvecontlines(b); }","comment":"\/\/ todo: document me","repo":"rebse\/flaka","code_context_2":"public void setCl(boolean b) {\n\/\/ TODO: document me\nthis.tr.setResolveContLines(b);\n}","code_context_10":"public void setCl(boolean b) {\n\/\/ TODO: document me\nthis.tr.setResolveContLines(b);\n}","code_context_20":"public void setCl(boolean b) {\n\/\/ TODO: document me\nthis.tr.setResolveContLines(b);\n}","label":[0,0,0,0]}
{"id":781,"original_code":"private Map<String, T> getChoiceMap() {\n        if (choiceMap == null || alwaysReload()) {\n            Collection<T> choices = loadChoices();\n            choiceMap = new HashMap<>();\n            for (T choice: choices) {\n                \/\/ TODO: smarter initialization of the map\n                choiceMap.put(choice.getLocalPart(), choice);\n            }\n        }\n        return choiceMap;\n    }","code":"private Map<String, T> getChoiceMap() {\n        if (choiceMap == null || alwaysReload()) {\n            Collection<T> choices = loadChoices();\n            choiceMap = new HashMap<>();\n            for (T choice: choices) {\n               \n                choiceMap.put(choice.getLocalPart(), choice);\n            }\n        }\n        return choiceMap;\n    }","cleancode":"private map<string, t> getchoicemap() { if (choicemap == null || alwaysreload()) { collection<t> choices = loadchoices(); choicemap = new hashmap<>(); for (t choice: choices) { choicemap.put(choice.getlocalpart(), choice); } } return choicemap; }","comment":"\/\/ todo: smarter initialization of the map","repo":"mythoss\/midpoint","code_context_2":"choiceMap = new HashMap<>();\nfor (T choice: choices) {\n\/\/ TODO: smarter initialization of the map\nchoiceMap.put(choice.getLocalPart(), choice);\n}","code_context_10":"private Map<String, T> getChoiceMap() {\nif (choiceMap == null || alwaysReload()) {\nCollection<T> choices = loadChoices();\nchoiceMap = new HashMap<>();\nfor (T choice: choices) {\n\/\/ TODO: smarter initialization of the map\nchoiceMap.put(choice.getLocalPart(), choice);\n}\n}\nreturn choiceMap;\n}","code_context_20":"private Map<String, T> getChoiceMap() {\nif (choiceMap == null || alwaysReload()) {\nCollection<T> choices = loadChoices();\nchoiceMap = new HashMap<>();\nfor (T choice: choices) {\n\/\/ TODO: smarter initialization of the map\nchoiceMap.put(choice.getLocalPart(), choice);\n}\n}\nreturn choiceMap;\n}","label":[1,0,0,0]}
{"id":9010,"original_code":"public static void main(String[] args) {\n        \/\/ The connection string value can be obtained by:\n        \/\/ 1. Going to your Event Hubs namespace in Azure Portal.\n        \/\/ 2. Creating an Event Hub instance.\n        \/\/ 3. Creating a \"Shared access policy\" for your Event Hub instance.\n        \/\/ 4. Copying the connection string from the policy's properties.\n        String connectionString = \"Endpoint={endpoint};SharedAccessKeyName={sharedAccessKeyName};SharedAccessKey={sharedAccessKey};EntityPath={eventHubName}\";\n        EventHubProducerAsyncClient producer = new EventHubClientBuilder()\n            .connectionString(connectionString)\n            .buildAsyncProducer();\n        \/\/ Create an event to send.\n        EventData data = new EventData(\"Hello world!\".getBytes(UTF_8));\n        \/\/ Send that event. This call returns a Mono<Void>, which we subscribe to. It completes successfully when the\n        \/\/ event has been delivered to the Event Hub. It completes with an error if an exception occurred while sending\n        \/\/ the event.\n        \/\/ SendOptions are not specified, so events sent are load balanced between all available partitions in the\n        \/\/ Event Hub instance.\n        producer.send(data).subscribe(\n            (ignored) -> System.out.println(\"Event sent.\"),\n            error -> {\n                System.err.println(\"There was an error sending the event: \" + error.toString());\n                if (error instanceof AmqpException) {\n                    AmqpException amqpException = (AmqpException) error;\n                    System.err.println(String.format(\"Is send operation retriable? %s. Error condition: %s\",\n                        amqpException.isTransient(), amqpException.getErrorCondition()));\n                }\n            }, () -> {\n                \/\/ Disposing of our producer and client.\n                producer.close();\n            });\n    }","code":"public static void main(String[] args) {\n       \n       \n       \n       \n       \n        String connectionString = \"Endpoint={endpoint};SharedAccessKeyName={sharedAccessKeyName};SharedAccessKey={sharedAccessKey};EntityPath={eventHubName}\";\n        EventHubProducerAsyncClient producer = new EventHubClientBuilder()\n            .connectionString(connectionString)\n            .buildAsyncProducer();\n       \n        EventData data = new EventData(\"Hello world!\".getBytes(UTF_8));\n       \n       \n       \n       \n       \n        producer.send(data).subscribe(\n            (ignored) -> System.out.println(\"Event sent.\"),\n            error -> {\n                System.err.println(\"There was an error sending the event: \" + error.toString());\n                if (error instanceof AmqpException) {\n                    AmqpException amqpException = (AmqpException) error;\n                    System.err.println(String.format(\"Is send operation retriable? %s. Error condition: %s\",\n                        amqpException.isTransient(), amqpException.getErrorCondition()));\n                }\n            }, () -> {\n               \n                producer.close();\n            });\n    }","cleancode":"public static void main(string[] args) { string connectionstring = \"endpoint={endpoint};sharedaccesskeyname={sharedaccesskeyname};sharedaccesskey={sharedaccesskey};entitypath={eventhubname}\"; eventhubproducerasyncclient producer = new eventhubclientbuilder() .connectionstring(connectionstring) .buildasyncproducer(); eventdata data = new eventdata(\"hello world!\".getbytes(utf_8)); producer.send(data).subscribe( (ignored) -> system.out.println(\"event sent.\"), error -> { system.err.println(\"there was an error sending the event: \" + error.tostring()); if (error instanceof amqpexception) { amqpexception amqpexception = (amqpexception) error; system.err.println(string.format(\"is send operation retriable? %s. error condition: %s\", amqpexception.istransient(), amqpexception.geterrorcondition())); } }, () -> { producer.close(); }); }","comment":"\/** * main method to invoke this demo on how to send a message to an azure event hub. * * @param args unused arguments to the program. *\/\n\/\/ the connection string value can be obtained by: \/\/ 1. going to your event hubs namespace in azure portal. \/\/ 2. creating an event hub instance. \/\/ 3. creating a \"shared access policy\" for your event hub instance. \/\/ 4. copying the connection string from the policy's properties.\n\/\/ create an event to send.\n\/\/ send that event. this call returns a mono<void>, which we subscribe to. it completes successfully when the \/\/ event has been delivered to the event hub. it completes with an error if an exception occurred while sending \/\/ the event. \/\/ sendoptions are not specified, so events sent are load balanced between all available partitions in the \/\/ event hub instance.\n\/\/ disposing of our producer and client.","repo":"ppsim\/azure-sdk-for-java","code_context_2":"public static void main(String[] args) {\n\/\/ The connection string value can be obtained by:\n\/\/ 1. Going to your Event Hubs namespace in Azure Portal.\n\/\/ 2. Creating an Event Hub instance.\n\/\/ 3. Creating a \"Shared access policy\" for your Event Hub instance.\n\/\/ 4. Copying the connection string from the policy's properties.\nString connectionString = \"Endpoint={endpoint};SharedAccessKeyName={sharedAccessKeyName};SharedAccessKey={sharedAccessKey};EntityPath={eventHubName}\";\nEventHubProducerAsyncClient producer = new EventHubClientBuilder()\n.connectionString(connectionString)\n.buildAsyncProducer();\n\/\/ Create an event to send.\nEventData data = new EventData(\"Hello world!\".getBytes(UTF_8));\n\/\/ Send that event. This call returns a Mono<Void>, which we subscribe to. It completes successfully when the\n\/\/ event has been delivered to the Event Hub. It completes with an error if an exception occurred while sending\n\/\/ the event.\n\/\/ SendOptions are not specified, so events sent are load balanced between all available partitions in the\n\/\/ Event Hub instance.\nproducer.send(data).subscribe(\n(ignored) -> System.out.println(\"Event sent.\"),\nerror -> {\nSystem.err.println(\"There was an error sending the event: \" + error.toString());\nif (error instanceof AmqpException) {\nAmqpException amqpException = (AmqpException) error;\nSystem.err.println(String.format(\"Is send operation retriable? %s. Error condition: %s\",\namqpException.isTransient(), amqpException.getErrorCondition()));\n}\n}, () -> {\n\/\/ Disposing of our producer and client.\nproducer.close();\n});\n}\n\npublic static void main(String[] args) {\n\/\/ The connection string value can be obtained by:\n\/\/ 1. Going to your Event Hubs namespace in Azure Portal.\n\/\/ 2. Creating an Event Hub instance.\n\/\/ 3. Creating a \"Shared access policy\" for your Event Hub instance.\n\/\/ 4. Copying the connection string from the policy's properties.\nString connectionString = \"Endpoint={endpoint};SharedAccessKeyName={sharedAccessKeyName};SharedAccessKey={sharedAccessKey};EntityPath={eventHubName}\";\nEventHubProducerAsyncClient producer = new EventHubClientBuilder()\n\n.connectionString(connectionString)\n.buildAsyncProducer();\n\/\/ Create an event to send.\nEventData data = new EventData(\"Hello world!\".getBytes(UTF_8));\n\/\/ Send that event. This call returns a Mono<Void>, which we subscribe to. It completes successfully when the\n\n\/\/ Create an event to send.\nEventData data = new EventData(\"Hello world!\".getBytes(UTF_8));\n\/\/ Send that event. This call returns a Mono<Void>, which we subscribe to. It completes successfully when the\n\/\/ event has been delivered to the Event Hub. It completes with an error if an exception occurred while sending\n\/\/ the event.\n\/\/ SendOptions are not specified, so events sent are load balanced between all available partitions in the\n\/\/ Event Hub instance.\nproducer.send(data).subscribe(\n(ignored) -> System.out.println(\"Event sent.\"),\n\n}\n}, () -> {\n\/\/ Disposing of our producer and client.\nproducer.close();\n});","code_context_10":"public static void main(String[] args) {\n\/\/ The connection string value can be obtained by:\n\/\/ 1. Going to your Event Hubs namespace in Azure Portal.\n\/\/ 2. Creating an Event Hub instance.\n\/\/ 3. Creating a \"Shared access policy\" for your Event Hub instance.\n\/\/ 4. Copying the connection string from the policy's properties.\nString connectionString = \"Endpoint={endpoint};SharedAccessKeyName={sharedAccessKeyName};SharedAccessKey={sharedAccessKey};EntityPath={eventHubName}\";\nEventHubProducerAsyncClient producer = new EventHubClientBuilder()\n.connectionString(connectionString)\n.buildAsyncProducer();\n\/\/ Create an event to send.\nEventData data = new EventData(\"Hello world!\".getBytes(UTF_8));\n\/\/ Send that event. This call returns a Mono<Void>, which we subscribe to. It completes successfully when the\n\/\/ event has been delivered to the Event Hub. It completes with an error if an exception occurred while sending\n\/\/ the event.\n\/\/ SendOptions are not specified, so events sent are load balanced between all available partitions in the\n\/\/ Event Hub instance.\nproducer.send(data).subscribe(\n(ignored) -> System.out.println(\"Event sent.\"),\nerror -> {\nSystem.err.println(\"There was an error sending the event: \" + error.toString());\nif (error instanceof AmqpException) {\nAmqpException amqpException = (AmqpException) error;\nSystem.err.println(String.format(\"Is send operation retriable? %s. Error condition: %s\",\namqpException.isTransient(), amqpException.getErrorCondition()));\n}\n}, () -> {\n\/\/ Disposing of our producer and client.\nproducer.close();\n});\n}\n\npublic static void main(String[] args) {\n\/\/ The connection string value can be obtained by:\n\/\/ 1. Going to your Event Hubs namespace in Azure Portal.\n\/\/ 2. Creating an Event Hub instance.\n\/\/ 3. Creating a \"Shared access policy\" for your Event Hub instance.\n\/\/ 4. Copying the connection string from the policy's properties.\nString connectionString = \"Endpoint={endpoint};SharedAccessKeyName={sharedAccessKeyName};SharedAccessKey={sharedAccessKey};EntityPath={eventHubName}\";\nEventHubProducerAsyncClient producer = new EventHubClientBuilder()\n.connectionString(connectionString)\n.buildAsyncProducer();\n\/\/ Create an event to send.\nEventData data = new EventData(\"Hello world!\".getBytes(UTF_8));\n\/\/ Send that event. This call returns a Mono<Void>, which we subscribe to. It completes successfully when the\n\/\/ event has been delivered to the Event Hub. It completes with an error if an exception occurred while sending\n\/\/ the event.\n\/\/ SendOptions are not specified, so events sent are load balanced between all available partitions in the\n\npublic static void main(String[] args) {\n\/\/ The connection string value can be obtained by:\n\/\/ 1. Going to your Event Hubs namespace in Azure Portal.\n\/\/ 2. Creating an Event Hub instance.\n\/\/ 3. Creating a \"Shared access policy\" for your Event Hub instance.\n\/\/ 4. Copying the connection string from the policy's properties.\nString connectionString = \"Endpoint={endpoint};SharedAccessKeyName={sharedAccessKeyName};SharedAccessKey={sharedAccessKey};EntityPath={eventHubName}\";\nEventHubProducerAsyncClient producer = new EventHubClientBuilder()\n.connectionString(connectionString)\n.buildAsyncProducer();\n\/\/ Create an event to send.\nEventData data = new EventData(\"Hello world!\".getBytes(UTF_8));\n\/\/ Send that event. This call returns a Mono<Void>, which we subscribe to. It completes successfully when the\n\/\/ event has been delivered to the Event Hub. It completes with an error if an exception occurred while sending\n\/\/ the event.\n\/\/ SendOptions are not specified, so events sent are load balanced between all available partitions in the\n\/\/ Event Hub instance.\nproducer.send(data).subscribe(\n(ignored) -> System.out.println(\"Event sent.\"),\nerror -> {\nSystem.err.println(\"There was an error sending the event: \" + error.toString());\n\n\/\/ 1. Going to your Event Hubs namespace in Azure Portal.\n\/\/ 2. Creating an Event Hub instance.\n\/\/ 3. Creating a \"Shared access policy\" for your Event Hub instance.\n\/\/ 4. Copying the connection string from the policy's properties.\nString connectionString = \"Endpoint={endpoint};SharedAccessKeyName={sharedAccessKeyName};SharedAccessKey={sharedAccessKey};EntityPath={eventHubName}\";\nEventHubProducerAsyncClient producer = new EventHubClientBuilder()\n.connectionString(connectionString)\n.buildAsyncProducer();\n\/\/ Create an event to send.\nEventData data = new EventData(\"Hello world!\".getBytes(UTF_8));\n\/\/ Send that event. This call returns a Mono<Void>, which we subscribe to. It completes successfully when the\n\/\/ event has been delivered to the Event Hub. It completes with an error if an exception occurred while sending\n\/\/ the event.\n\/\/ SendOptions are not specified, so events sent are load balanced between all available partitions in the\n\/\/ Event Hub instance.\nproducer.send(data).subscribe(\n(ignored) -> System.out.println(\"Event sent.\"),\nerror -> {\nSystem.err.println(\"There was an error sending the event: \" + error.toString());\nif (error instanceof AmqpException) {\nAmqpException amqpException = (AmqpException) error;\nSystem.err.println(String.format(\"Is send operation retriable? %s. Error condition: %s\",\namqpException.isTransient(), amqpException.getErrorCondition()));\n}\n}, () -> {\n\nproducer.send(data).subscribe(\n(ignored) -> System.out.println(\"Event sent.\"),\nerror -> {\nSystem.err.println(\"There was an error sending the event: \" + error.toString());\nif (error instanceof AmqpException) {\nAmqpException amqpException = (AmqpException) error;\nSystem.err.println(String.format(\"Is send operation retriable? %s. Error condition: %s\",\namqpException.isTransient(), amqpException.getErrorCondition()));\n}\n}, () -> {\n\/\/ Disposing of our producer and client.\nproducer.close();\n});\n}","code_context_20":"public static void main(String[] args) {\n\/\/ The connection string value can be obtained by:\n\/\/ 1. Going to your Event Hubs namespace in Azure Portal.\n\/\/ 2. Creating an Event Hub instance.\n\/\/ 3. Creating a \"Shared access policy\" for your Event Hub instance.\n\/\/ 4. Copying the connection string from the policy's properties.\nString connectionString = \"Endpoint={endpoint};SharedAccessKeyName={sharedAccessKeyName};SharedAccessKey={sharedAccessKey};EntityPath={eventHubName}\";\nEventHubProducerAsyncClient producer = new EventHubClientBuilder()\n.connectionString(connectionString)\n.buildAsyncProducer();\n\/\/ Create an event to send.\nEventData data = new EventData(\"Hello world!\".getBytes(UTF_8));\n\/\/ Send that event. This call returns a Mono<Void>, which we subscribe to. It completes successfully when the\n\/\/ event has been delivered to the Event Hub. It completes with an error if an exception occurred while sending\n\/\/ the event.\n\/\/ SendOptions are not specified, so events sent are load balanced between all available partitions in the\n\/\/ Event Hub instance.\nproducer.send(data).subscribe(\n(ignored) -> System.out.println(\"Event sent.\"),\nerror -> {\nSystem.err.println(\"There was an error sending the event: \" + error.toString());\nif (error instanceof AmqpException) {\nAmqpException amqpException = (AmqpException) error;\nSystem.err.println(String.format(\"Is send operation retriable? %s. Error condition: %s\",\namqpException.isTransient(), amqpException.getErrorCondition()));\n}\n}, () -> {\n\/\/ Disposing of our producer and client.\nproducer.close();\n});\n}\n\npublic static void main(String[] args) {\n\/\/ The connection string value can be obtained by:\n\/\/ 1. Going to your Event Hubs namespace in Azure Portal.\n\/\/ 2. Creating an Event Hub instance.\n\/\/ 3. Creating a \"Shared access policy\" for your Event Hub instance.\n\/\/ 4. Copying the connection string from the policy's properties.\nString connectionString = \"Endpoint={endpoint};SharedAccessKeyName={sharedAccessKeyName};SharedAccessKey={sharedAccessKey};EntityPath={eventHubName}\";\nEventHubProducerAsyncClient producer = new EventHubClientBuilder()\n.connectionString(connectionString)\n.buildAsyncProducer();\n\/\/ Create an event to send.\nEventData data = new EventData(\"Hello world!\".getBytes(UTF_8));\n\/\/ Send that event. This call returns a Mono<Void>, which we subscribe to. It completes successfully when the\n\/\/ event has been delivered to the Event Hub. It completes with an error if an exception occurred while sending\n\/\/ the event.\n\/\/ SendOptions are not specified, so events sent are load balanced between all available partitions in the\n\/\/ Event Hub instance.\nproducer.send(data).subscribe(\n(ignored) -> System.out.println(\"Event sent.\"),\nerror -> {\nSystem.err.println(\"There was an error sending the event: \" + error.toString());\nif (error instanceof AmqpException) {\nAmqpException amqpException = (AmqpException) error;\nSystem.err.println(String.format(\"Is send operation retriable? %s. Error condition: %s\",\namqpException.isTransient(), amqpException.getErrorCondition()));\n}\n\npublic static void main(String[] args) {\n\/\/ The connection string value can be obtained by:\n\/\/ 1. Going to your Event Hubs namespace in Azure Portal.\n\/\/ 2. Creating an Event Hub instance.\n\/\/ 3. Creating a \"Shared access policy\" for your Event Hub instance.\n\/\/ 4. Copying the connection string from the policy's properties.\nString connectionString = \"Endpoint={endpoint};SharedAccessKeyName={sharedAccessKeyName};SharedAccessKey={sharedAccessKey};EntityPath={eventHubName}\";\nEventHubProducerAsyncClient producer = new EventHubClientBuilder()\n.connectionString(connectionString)\n.buildAsyncProducer();\n\/\/ Create an event to send.\nEventData data = new EventData(\"Hello world!\".getBytes(UTF_8));\n\/\/ Send that event. This call returns a Mono<Void>, which we subscribe to. It completes successfully when the\n\/\/ event has been delivered to the Event Hub. It completes with an error if an exception occurred while sending\n\/\/ the event.\n\/\/ SendOptions are not specified, so events sent are load balanced between all available partitions in the\n\/\/ Event Hub instance.\nproducer.send(data).subscribe(\n(ignored) -> System.out.println(\"Event sent.\"),\nerror -> {\nSystem.err.println(\"There was an error sending the event: \" + error.toString());\nif (error instanceof AmqpException) {\nAmqpException amqpException = (AmqpException) error;\nSystem.err.println(String.format(\"Is send operation retriable? %s. Error condition: %s\",\namqpException.isTransient(), amqpException.getErrorCondition()));\n}\n}, () -> {\n\/\/ Disposing of our producer and client.\nproducer.close();\n});\n}\n\npublic static void main(String[] args) {\n\/\/ The connection string value can be obtained by:\n\/\/ 1. Going to your Event Hubs namespace in Azure Portal.\n\/\/ 2. Creating an Event Hub instance.\n\/\/ 3. Creating a \"Shared access policy\" for your Event Hub instance.\n\/\/ 4. Copying the connection string from the policy's properties.\nString connectionString = \"Endpoint={endpoint};SharedAccessKeyName={sharedAccessKeyName};SharedAccessKey={sharedAccessKey};EntityPath={eventHubName}\";\nEventHubProducerAsyncClient producer = new EventHubClientBuilder()\n.connectionString(connectionString)\n.buildAsyncProducer();\n\/\/ Create an event to send.\nEventData data = new EventData(\"Hello world!\".getBytes(UTF_8));\n\/\/ Send that event. This call returns a Mono<Void>, which we subscribe to. It completes successfully when the\n\/\/ event has been delivered to the Event Hub. It completes with an error if an exception occurred while sending\n\/\/ the event.\n\/\/ SendOptions are not specified, so events sent are load balanced between all available partitions in the\n\/\/ Event Hub instance.\nproducer.send(data).subscribe(\n(ignored) -> System.out.println(\"Event sent.\"),\nerror -> {\nSystem.err.println(\"There was an error sending the event: \" + error.toString());\nif (error instanceof AmqpException) {\nAmqpException amqpException = (AmqpException) error;\nSystem.err.println(String.format(\"Is send operation retriable? %s. Error condition: %s\",\namqpException.isTransient(), amqpException.getErrorCondition()));\n}\n}, () -> {\n\/\/ Disposing of our producer and client.\nproducer.close();\n});\n}\n\nEventHubProducerAsyncClient producer = new EventHubClientBuilder()\n.connectionString(connectionString)\n.buildAsyncProducer();\n\/\/ Create an event to send.\nEventData data = new EventData(\"Hello world!\".getBytes(UTF_8));\n\/\/ Send that event. This call returns a Mono<Void>, which we subscribe to. It completes successfully when the\n\/\/ event has been delivered to the Event Hub. It completes with an error if an exception occurred while sending\n\/\/ the event.\n\/\/ SendOptions are not specified, so events sent are load balanced between all available partitions in the\n\/\/ Event Hub instance.\nproducer.send(data).subscribe(\n(ignored) -> System.out.println(\"Event sent.\"),\nerror -> {\nSystem.err.println(\"There was an error sending the event: \" + error.toString());\nif (error instanceof AmqpException) {\nAmqpException amqpException = (AmqpException) error;\nSystem.err.println(String.format(\"Is send operation retriable? %s. Error condition: %s\",\namqpException.isTransient(), amqpException.getErrorCondition()));\n}\n}, () -> {\n\/\/ Disposing of our producer and client.\nproducer.close();\n});\n}","label":[0,0,0,0]}
{"id":822,"original_code":"private BasePrinter escapeCharacter(char c) {\n      if (c == '\"') {\n        return backslashChar(c);\n      }\n      switch (c) {\n        case '\\\\':\n          return backslashChar('\\\\');\n        case '\\r':\n          return backslashChar('r');\n        case '\\n':\n          return backslashChar('n');\n        case '\\t':\n          return backslashChar('t');\n        default:\n          if (c < 32) {\n            \/\/TODO(bazel-team): support \\x escapes\n            return this.append(String.format(\"\\\\x%02x\", (int) c));\n          }\n          return this.append(c); \/\/ no need to support UTF-8\n      } \/\/ endswitch\n    }","code":"private BasePrinter escapeCharacter(char c) {\n      if (c == '\"') {\n        return backslashChar(c);\n      }\n      switch (c) {\n        case '\\\\':\n          return backslashChar('\\\\');\n        case '\\r':\n          return backslashChar('r');\n        case '\\n':\n          return backslashChar('n');\n        case '\\t':\n          return backslashChar('t');\n        default:\n          if (c < 32) {\n           \n            return this.append(String.format(\"\\\\x%02x\", (int) c));\n          }\n          return this.append(c);\n      }\n    }","cleancode":"private baseprinter escapecharacter(char c) { if (c == '\"') { return backslashchar(c); } switch (c) { case '\\\\': return backslashchar('\\\\'); case '\\r': return backslashchar('r'); case '\\n': return backslashchar('n'); case '\\t': return backslashchar('t'); default: if (c < 32) { return this.append(string.format(\"\\\\x%02x\", (int) c)); } return this.append(c); } }","comment":"\/\/todo(bazel-team): support \\x escapes\n\/\/ no need to support utf-8\n\/\/ endswitch","repo":"moroten\/bazel","code_context_2":"default:\nif (c < 32) {\n\/\/TODO(bazel-team): support \\x escapes\nreturn this.append(String.format(\"\\\\x%02x\", (int) c));\n}\n\nreturn this.append(String.format(\"\\\\x%02x\", (int) c));\n}\nreturn this.append(c); \/\/ no need to support UTF-8\n} \/\/ endswitch\n}\n\n}\nreturn this.append(c); \/\/ no need to support UTF-8\n} \/\/ endswitch\n}","code_context_10":"case '\\\\':\nreturn backslashChar('\\\\');\ncase '\\r':\nreturn backslashChar('r');\ncase '\\n':\nreturn backslashChar('n');\ncase '\\t':\nreturn backslashChar('t');\ndefault:\nif (c < 32) {\n\/\/TODO(bazel-team): support \\x escapes\nreturn this.append(String.format(\"\\\\x%02x\", (int) c));\n}\nreturn this.append(c); \/\/ no need to support UTF-8\n} \/\/ endswitch\n}\n\nreturn backslashChar('r');\ncase '\\n':\nreturn backslashChar('n');\ncase '\\t':\nreturn backslashChar('t');\ndefault:\nif (c < 32) {\n\/\/TODO(bazel-team): support \\x escapes\nreturn this.append(String.format(\"\\\\x%02x\", (int) c));\n}\nreturn this.append(c); \/\/ no need to support UTF-8\n} \/\/ endswitch\n}\n\ncase '\\n':\nreturn backslashChar('n');\ncase '\\t':\nreturn backslashChar('t');\ndefault:\nif (c < 32) {\n\/\/TODO(bazel-team): support \\x escapes\nreturn this.append(String.format(\"\\\\x%02x\", (int) c));\n}\nreturn this.append(c); \/\/ no need to support UTF-8\n} \/\/ endswitch\n}","code_context_20":"private BasePrinter escapeCharacter(char c) {\nif (c == '\"') {\nreturn backslashChar(c);\n}\nswitch (c) {\ncase '\\\\':\nreturn backslashChar('\\\\');\ncase '\\r':\nreturn backslashChar('r');\ncase '\\n':\nreturn backslashChar('n');\ncase '\\t':\nreturn backslashChar('t');\ndefault:\nif (c < 32) {\n\/\/TODO(bazel-team): support \\x escapes\nreturn this.append(String.format(\"\\\\x%02x\", (int) c));\n}\nreturn this.append(c); \/\/ no need to support UTF-8\n} \/\/ endswitch\n}\n\nprivate BasePrinter escapeCharacter(char c) {\nif (c == '\"') {\nreturn backslashChar(c);\n}\nswitch (c) {\ncase '\\\\':\nreturn backslashChar('\\\\');\ncase '\\r':\nreturn backslashChar('r');\ncase '\\n':\nreturn backslashChar('n');\ncase '\\t':\nreturn backslashChar('t');\ndefault:\nif (c < 32) {\n\/\/TODO(bazel-team): support \\x escapes\nreturn this.append(String.format(\"\\\\x%02x\", (int) c));\n}\nreturn this.append(c); \/\/ no need to support UTF-8\n} \/\/ endswitch\n}\n\nprivate BasePrinter escapeCharacter(char c) {\nif (c == '\"') {\nreturn backslashChar(c);\n}\nswitch (c) {\ncase '\\\\':\nreturn backslashChar('\\\\');\ncase '\\r':\nreturn backslashChar('r');\ncase '\\n':\nreturn backslashChar('n');\ncase '\\t':\nreturn backslashChar('t');\ndefault:\nif (c < 32) {\n\/\/TODO(bazel-team): support \\x escapes\nreturn this.append(String.format(\"\\\\x%02x\", (int) c));\n}\nreturn this.append(c); \/\/ no need to support UTF-8\n} \/\/ endswitch\n}","label":[0,1,0,0]}
{"id":831,"original_code":"private Pair<ImageView, String> loadImageWithCaption(int fileId, String caption, Map <String,\n            Integer> weaponMap, Integer id) {\n        try {\n            \/\/TODO: USE BELOW WHEN INFO IS CHANGED\n            System.out.println(fileId);\n            var image = new ImageView(myLogic.getImage(fileId));\n            System.out.println(\"**********\");\n            System.out.println(image);\n            weaponMap.put(image.toString(), id);\n            image.setFitWidth(100);\n            image.setFitHeight(100);\n            Pair pair = new Pair<>(image, caption);\n            return pair;\n\/\/            return new Pair<>(image, caption);\n        }\n        catch(Exception e){\n            System.out.println(e);\n            \/\/This shouldn't ever happen\n        }\n        return null;\n    }","code":"private Pair<ImageView, String> loadImageWithCaption(int fileId, String caption, Map <String,\n            Integer> weaponMap, Integer id) {\n        try {\n           \n            System.out.println(fileId);\n            var image = new ImageView(myLogic.getImage(fileId));\n            System.out.println(\"**********\");\n            System.out.println(image);\n            weaponMap.put(image.toString(), id);\n            image.setFitWidth(100);\n            image.setFitHeight(100);\n            Pair pair = new Pair<>(image, caption);\n            return pair;\n        }\n        catch(Exception e){\n            System.out.println(e);\n           \n        }\n        return null;\n    }","cleancode":"private pair<imageview, string> loadimagewithcaption(int fileid, string caption, map <string, integer> weaponmap, integer id) { try { system.out.println(fileid); var image = new imageview(mylogic.getimage(fileid)); system.out.println(\"**********\"); system.out.println(image); weaponmap.put(image.tostring(), id); image.setfitwidth(100); image.setfitheight(100); pair pair = new pair<>(image, caption); return pair; } catch(exception e){ system.out.println(e); } return null; }","comment":"\/\/todo: change filename param to int\n\/\/todo: use below when info is changed\n\/\/ return new pair<>(image, caption);\n\/\/this shouldn't ever happen","repo":"pandawithcat\/VoogaSalad","code_context_2":"private Pair<ImageView, String> loadImageWithCaption(int fileId, String caption, Map <String,\nInteger> weaponMap, Integer id) {\ntry {\n\/\/TODO: USE BELOW WHEN INFO IS CHANGED\nSystem.out.println(fileId);\nvar image = new ImageView(myLogic.getImage(fileId));\nSystem.out.println(\"**********\");\nSystem.out.println(image);\nweaponMap.put(image.toString(), id);\nimage.setFitWidth(100);\nimage.setFitHeight(100);\nPair pair = new Pair<>(image, caption);\nreturn pair;\n\/\/ return new Pair<>(image, caption);\n}\ncatch(Exception e){\nSystem.out.println(e);\n\/\/This shouldn't ever happen\n}\nreturn null;\n}\n\nInteger> weaponMap, Integer id) {\ntry {\n\/\/TODO: USE BELOW WHEN INFO IS CHANGED\nSystem.out.println(fileId);\nvar image = new ImageView(myLogic.getImage(fileId));\n\nPair pair = new Pair<>(image, caption);\nreturn pair;\n\/\/ return new Pair<>(image, caption);\n}\ncatch(Exception e){\n\ncatch(Exception e){\nSystem.out.println(e);\n\/\/This shouldn't ever happen\n}\nreturn null;","code_context_10":"private Pair<ImageView, String> loadImageWithCaption(int fileId, String caption, Map <String,\nInteger> weaponMap, Integer id) {\ntry {\n\/\/TODO: USE BELOW WHEN INFO IS CHANGED\nSystem.out.println(fileId);\nvar image = new ImageView(myLogic.getImage(fileId));\nSystem.out.println(\"**********\");\nSystem.out.println(image);\nweaponMap.put(image.toString(), id);\nimage.setFitWidth(100);\nimage.setFitHeight(100);\nPair pair = new Pair<>(image, caption);\nreturn pair;\n\/\/ return new Pair<>(image, caption);\n}\ncatch(Exception e){\nSystem.out.println(e);\n\/\/This shouldn't ever happen\n}\nreturn null;\n}\n\nprivate Pair<ImageView, String> loadImageWithCaption(int fileId, String caption, Map <String,\nInteger> weaponMap, Integer id) {\ntry {\n\/\/TODO: USE BELOW WHEN INFO IS CHANGED\nSystem.out.println(fileId);\nvar image = new ImageView(myLogic.getImage(fileId));\nSystem.out.println(\"**********\");\nSystem.out.println(image);\nweaponMap.put(image.toString(), id);\nimage.setFitWidth(100);\nimage.setFitHeight(100);\nPair pair = new Pair<>(image, caption);\nreturn pair;\n\/\/ return new Pair<>(image, caption);\n\n\/\/TODO: USE BELOW WHEN INFO IS CHANGED\nSystem.out.println(fileId);\nvar image = new ImageView(myLogic.getImage(fileId));\nSystem.out.println(\"**********\");\nSystem.out.println(image);\nweaponMap.put(image.toString(), id);\nimage.setFitWidth(100);\nimage.setFitHeight(100);\nPair pair = new Pair<>(image, caption);\nreturn pair;\n\/\/ return new Pair<>(image, caption);\n}\ncatch(Exception e){\nSystem.out.println(e);\n\/\/This shouldn't ever happen\n}\nreturn null;\n}\n\nSystem.out.println(image);\nweaponMap.put(image.toString(), id);\nimage.setFitWidth(100);\nimage.setFitHeight(100);\nPair pair = new Pair<>(image, caption);\nreturn pair;\n\/\/ return new Pair<>(image, caption);\n}\ncatch(Exception e){\nSystem.out.println(e);\n\/\/This shouldn't ever happen\n}\nreturn null;\n}","code_context_20":"private Pair<ImageView, String> loadImageWithCaption(int fileId, String caption, Map <String,\nInteger> weaponMap, Integer id) {\ntry {\n\/\/TODO: USE BELOW WHEN INFO IS CHANGED\nSystem.out.println(fileId);\nvar image = new ImageView(myLogic.getImage(fileId));\nSystem.out.println(\"**********\");\nSystem.out.println(image);\nweaponMap.put(image.toString(), id);\nimage.setFitWidth(100);\nimage.setFitHeight(100);\nPair pair = new Pair<>(image, caption);\nreturn pair;\n\/\/ return new Pair<>(image, caption);\n}\ncatch(Exception e){\nSystem.out.println(e);\n\/\/This shouldn't ever happen\n}\nreturn null;\n}\n\nprivate Pair<ImageView, String> loadImageWithCaption(int fileId, String caption, Map <String,\nInteger> weaponMap, Integer id) {\ntry {\n\/\/TODO: USE BELOW WHEN INFO IS CHANGED\nSystem.out.println(fileId);\nvar image = new ImageView(myLogic.getImage(fileId));\nSystem.out.println(\"**********\");\nSystem.out.println(image);\nweaponMap.put(image.toString(), id);\nimage.setFitWidth(100);\nimage.setFitHeight(100);\nPair pair = new Pair<>(image, caption);\nreturn pair;\n\/\/ return new Pair<>(image, caption);\n}\ncatch(Exception e){\nSystem.out.println(e);\n\/\/This shouldn't ever happen\n}\nreturn null;\n}\n\nprivate Pair<ImageView, String> loadImageWithCaption(int fileId, String caption, Map <String,\nInteger> weaponMap, Integer id) {\ntry {\n\/\/TODO: USE BELOW WHEN INFO IS CHANGED\nSystem.out.println(fileId);\nvar image = new ImageView(myLogic.getImage(fileId));\nSystem.out.println(\"**********\");\nSystem.out.println(image);\nweaponMap.put(image.toString(), id);\nimage.setFitWidth(100);\nimage.setFitHeight(100);\nPair pair = new Pair<>(image, caption);\nreturn pair;\n\/\/ return new Pair<>(image, caption);\n}\ncatch(Exception e){\nSystem.out.println(e);\n\/\/This shouldn't ever happen\n}\nreturn null;\n}\n\nprivate Pair<ImageView, String> loadImageWithCaption(int fileId, String caption, Map <String,\nInteger> weaponMap, Integer id) {\ntry {\n\/\/TODO: USE BELOW WHEN INFO IS CHANGED\nSystem.out.println(fileId);\nvar image = new ImageView(myLogic.getImage(fileId));\nSystem.out.println(\"**********\");\nSystem.out.println(image);\nweaponMap.put(image.toString(), id);\nimage.setFitWidth(100);\nimage.setFitHeight(100);\nPair pair = new Pair<>(image, caption);\nreturn pair;\n\/\/ return new Pair<>(image, caption);\n}\ncatch(Exception e){\nSystem.out.println(e);\n\/\/This shouldn't ever happen\n}\nreturn null;\n}","label":[1,0,0,0]}
{"id":25437,"original_code":"@Override\n  public void channelRead0(final ChannelHandlerContext ctx, final RPCMessage msg)\n      throws IOException {\n    switch (msg.getType()) {\n      case RPC_BLOCK_READ_REQUEST:\n        assert msg instanceof RPCBlockReadRequest;\n        mBlockHandler.handleBlockReadRequest(ctx, (RPCBlockReadRequest) msg);\n        break;\n      case RPC_BLOCK_WRITE_REQUEST:\n        assert msg instanceof RPCBlockWriteRequest;\n        mBlockHandler.handleBlockWriteRequest(ctx, (RPCBlockWriteRequest) msg);\n        break;\n      case RPC_FILE_READ_REQUEST:\n        assert msg instanceof RPCFileReadRequest;\n        mUnderFileSystemHandler.handleFileReadRequest(ctx, (RPCFileReadRequest) msg);\n        break;\n      case RPC_FILE_WRITE_REQUEST:\n        assert msg instanceof RPCFileWriteRequest;\n        mUnderFileSystemHandler.handleFileWriteRequest(ctx, (RPCFileWriteRequest) msg);\n        break;\n      case RPC_ERROR_RESPONSE:\n        \/\/ TODO(peis): Fix this, we should not assert here.\n        assert msg instanceof RPCErrorResponse;\n        LOG.error(\"Received an error response from the client: \" + msg.toString());\n        break;\n      default:\n        RPCErrorResponse resp = new RPCErrorResponse(RPCResponse.Status.UNKNOWN_MESSAGE_ERROR);\n        ctx.writeAndFlush(resp);\n        \/\/ TODO(peis): Fix this. We should not throw an exception here.\n        throw new IllegalArgumentException(\n            \"No handler implementation for rpc msg type: \" + msg.getType());\n    }\n  }","code":"@Override\n  public void channelRead0(final ChannelHandlerContext ctx, final RPCMessage msg)\n      throws IOException {\n    switch (msg.getType()) {\n      case RPC_BLOCK_READ_REQUEST:\n        assert msg instanceof RPCBlockReadRequest;\n        mBlockHandler.handleBlockReadRequest(ctx, (RPCBlockReadRequest) msg);\n        break;\n      case RPC_BLOCK_WRITE_REQUEST:\n        assert msg instanceof RPCBlockWriteRequest;\n        mBlockHandler.handleBlockWriteRequest(ctx, (RPCBlockWriteRequest) msg);\n        break;\n      case RPC_FILE_READ_REQUEST:\n        assert msg instanceof RPCFileReadRequest;\n        mUnderFileSystemHandler.handleFileReadRequest(ctx, (RPCFileReadRequest) msg);\n        break;\n      case RPC_FILE_WRITE_REQUEST:\n        assert msg instanceof RPCFileWriteRequest;\n        mUnderFileSystemHandler.handleFileWriteRequest(ctx, (RPCFileWriteRequest) msg);\n        break;\n      case RPC_ERROR_RESPONSE:\n       \n        assert msg instanceof RPCErrorResponse;\n        LOG.error(\"Received an error response from the client: \" + msg.toString());\n        break;\n      default:\n        RPCErrorResponse resp = new RPCErrorResponse(RPCResponse.Status.UNKNOWN_MESSAGE_ERROR);\n        ctx.writeAndFlush(resp);\n       \n        throw new IllegalArgumentException(\n            \"No handler implementation for rpc msg type: \" + msg.getType());\n    }\n  }","cleancode":"@override public void channelread0(final channelhandlercontext ctx, final rpcmessage msg) throws ioexception { switch (msg.gettype()) { case rpc_block_read_request: assert msg instanceof rpcblockreadrequest; mblockhandler.handleblockreadrequest(ctx, (rpcblockreadrequest) msg); break; case rpc_block_write_request: assert msg instanceof rpcblockwriterequest; mblockhandler.handleblockwriterequest(ctx, (rpcblockwriterequest) msg); break; case rpc_file_read_request: assert msg instanceof rpcfilereadrequest; munderfilesystemhandler.handlefilereadrequest(ctx, (rpcfilereadrequest) msg); break; case rpc_file_write_request: assert msg instanceof rpcfilewriterequest; munderfilesystemhandler.handlefilewriterequest(ctx, (rpcfilewriterequest) msg); break; case rpc_error_response: assert msg instanceof rpcerrorresponse; log.error(\"received an error response from the client: \" + msg.tostring()); break; default: rpcerrorresponse resp = new rpcerrorresponse(rpcresponse.status.unknown_message_error); ctx.writeandflush(resp); throw new illegalargumentexception( \"no handler implementation for rpc msg type: \" + msg.gettype()); } }","comment":"\/\/ todo(peis): fix this, we should not assert here.\n\/\/ todo(peis): fix this. we should not throw an exception here.","repo":"ramiyer\/alluxio","code_context_2":"break;\ncase RPC_ERROR_RESPONSE:\n\/\/ TODO(peis): Fix this, we should not assert here.\nassert msg instanceof RPCErrorResponse;\nLOG.error(\"Received an error response from the client: \" + msg.toString());\n\nRPCErrorResponse resp = new RPCErrorResponse(RPCResponse.Status.UNKNOWN_MESSAGE_ERROR);\nctx.writeAndFlush(resp);\n\/\/ TODO(peis): Fix this. We should not throw an exception here.\nthrow new IllegalArgumentException(\n\"No handler implementation for rpc msg type: \" + msg.getType());","code_context_10":"break;\ncase RPC_FILE_READ_REQUEST:\nassert msg instanceof RPCFileReadRequest;\nmUnderFileSystemHandler.handleFileReadRequest(ctx, (RPCFileReadRequest) msg);\nbreak;\ncase RPC_FILE_WRITE_REQUEST:\nassert msg instanceof RPCFileWriteRequest;\nmUnderFileSystemHandler.handleFileWriteRequest(ctx, (RPCFileWriteRequest) msg);\nbreak;\ncase RPC_ERROR_RESPONSE:\n\/\/ TODO(peis): Fix this, we should not assert here.\nassert msg instanceof RPCErrorResponse;\nLOG.error(\"Received an error response from the client: \" + msg.toString());\nbreak;\ndefault:\nRPCErrorResponse resp = new RPCErrorResponse(RPCResponse.Status.UNKNOWN_MESSAGE_ERROR);\nctx.writeAndFlush(resp);\n\/\/ TODO(peis): Fix this. We should not throw an exception here.\nthrow new IllegalArgumentException(\n\"No handler implementation for rpc msg type: \" + msg.getType());\n}\n\nmUnderFileSystemHandler.handleFileWriteRequest(ctx, (RPCFileWriteRequest) msg);\nbreak;\ncase RPC_ERROR_RESPONSE:\n\/\/ TODO(peis): Fix this, we should not assert here.\nassert msg instanceof RPCErrorResponse;\nLOG.error(\"Received an error response from the client: \" + msg.toString());\nbreak;\ndefault:\nRPCErrorResponse resp = new RPCErrorResponse(RPCResponse.Status.UNKNOWN_MESSAGE_ERROR);\nctx.writeAndFlush(resp);\n\/\/ TODO(peis): Fix this. We should not throw an exception here.\nthrow new IllegalArgumentException(\n\"No handler implementation for rpc msg type: \" + msg.getType());\n}\n}","code_context_20":"public void channelRead0(final ChannelHandlerContext ctx, final RPCMessage msg)\nthrows IOException {\nswitch (msg.getType()) {\ncase RPC_BLOCK_READ_REQUEST:\nassert msg instanceof RPCBlockReadRequest;\nmBlockHandler.handleBlockReadRequest(ctx, (RPCBlockReadRequest) msg);\nbreak;\ncase RPC_BLOCK_WRITE_REQUEST:\nassert msg instanceof RPCBlockWriteRequest;\nmBlockHandler.handleBlockWriteRequest(ctx, (RPCBlockWriteRequest) msg);\nbreak;\ncase RPC_FILE_READ_REQUEST:\nassert msg instanceof RPCFileReadRequest;\nmUnderFileSystemHandler.handleFileReadRequest(ctx, (RPCFileReadRequest) msg);\nbreak;\ncase RPC_FILE_WRITE_REQUEST:\nassert msg instanceof RPCFileWriteRequest;\nmUnderFileSystemHandler.handleFileWriteRequest(ctx, (RPCFileWriteRequest) msg);\nbreak;\ncase RPC_ERROR_RESPONSE:\n\/\/ TODO(peis): Fix this, we should not assert here.\nassert msg instanceof RPCErrorResponse;\nLOG.error(\"Received an error response from the client: \" + msg.toString());\nbreak;\ndefault:\nRPCErrorResponse resp = new RPCErrorResponse(RPCResponse.Status.UNKNOWN_MESSAGE_ERROR);\nctx.writeAndFlush(resp);\n\/\/ TODO(peis): Fix this. We should not throw an exception here.\nthrow new IllegalArgumentException(\n\"No handler implementation for rpc msg type: \" + msg.getType());\n}\n}\n\ncase RPC_BLOCK_WRITE_REQUEST:\nassert msg instanceof RPCBlockWriteRequest;\nmBlockHandler.handleBlockWriteRequest(ctx, (RPCBlockWriteRequest) msg);\nbreak;\ncase RPC_FILE_READ_REQUEST:\nassert msg instanceof RPCFileReadRequest;\nmUnderFileSystemHandler.handleFileReadRequest(ctx, (RPCFileReadRequest) msg);\nbreak;\ncase RPC_FILE_WRITE_REQUEST:\nassert msg instanceof RPCFileWriteRequest;\nmUnderFileSystemHandler.handleFileWriteRequest(ctx, (RPCFileWriteRequest) msg);\nbreak;\ncase RPC_ERROR_RESPONSE:\n\/\/ TODO(peis): Fix this, we should not assert here.\nassert msg instanceof RPCErrorResponse;\nLOG.error(\"Received an error response from the client: \" + msg.toString());\nbreak;\ndefault:\nRPCErrorResponse resp = new RPCErrorResponse(RPCResponse.Status.UNKNOWN_MESSAGE_ERROR);\nctx.writeAndFlush(resp);\n\/\/ TODO(peis): Fix this. We should not throw an exception here.\nthrow new IllegalArgumentException(\n\"No handler implementation for rpc msg type: \" + msg.getType());\n}\n}","label":[1,0,1,0]}
{"id":25438,"original_code":"@Override\n  public void exceptionCaught(ChannelHandlerContext ctx, Throwable cause) throws Exception {\n    LOG.warn(\"Exception thrown while processing request\", cause);\n    \/\/ TODO(peis): This doesn't have to be decode error, it can also be any network errors such as\n    \/\/ connection reset. Fix this ALLUXIO-2235.\n    RPCErrorResponse resp = new RPCErrorResponse(RPCResponse.Status.DECODE_ERROR);\n    ChannelFuture channelFuture = ctx.writeAndFlush(resp);\n    \/\/ Close the channel because it is likely a network error.\n    channelFuture.addListener(ChannelFutureListener.CLOSE);\n  }","code":"@Override\n  public void exceptionCaught(ChannelHandlerContext ctx, Throwable cause) throws Exception {\n    LOG.warn(\"Exception thrown while processing request\", cause);\n   \n   \n    RPCErrorResponse resp = new RPCErrorResponse(RPCResponse.Status.DECODE_ERROR);\n    ChannelFuture channelFuture = ctx.writeAndFlush(resp);\n   \n    channelFuture.addListener(ChannelFutureListener.CLOSE);\n  }","cleancode":"@override public void exceptioncaught(channelhandlercontext ctx, throwable cause) throws exception { log.warn(\"exception thrown while processing request\", cause); rpcerrorresponse resp = new rpcerrorresponse(rpcresponse.status.decode_error); channelfuture channelfuture = ctx.writeandflush(resp); channelfuture.addlistener(channelfuturelistener.close); }","comment":"\/\/ todo(peis): this doesn't have to be decode error, it can also be any network errors such as \/\/ connection reset. fix this alluxio-2235.\n\/\/ close the channel because it is likely a network error.","repo":"ramiyer\/alluxio","code_context_2":"public void exceptionCaught(ChannelHandlerContext ctx, Throwable cause) throws Exception {\nLOG.warn(\"Exception thrown while processing request\", cause);\n\/\/ TODO(peis): This doesn't have to be decode error, it can also be any network errors such as\n\/\/ connection reset. Fix this ALLUXIO-2235.\nRPCErrorResponse resp = new RPCErrorResponse(RPCResponse.Status.DECODE_ERROR);\nChannelFuture channelFuture = ctx.writeAndFlush(resp);\n\nRPCErrorResponse resp = new RPCErrorResponse(RPCResponse.Status.DECODE_ERROR);\nChannelFuture channelFuture = ctx.writeAndFlush(resp);\n\/\/ Close the channel because it is likely a network error.\nchannelFuture.addListener(ChannelFutureListener.CLOSE);\n}","code_context_10":"@Override\npublic void exceptionCaught(ChannelHandlerContext ctx, Throwable cause) throws Exception {\nLOG.warn(\"Exception thrown while processing request\", cause);\n\/\/ TODO(peis): This doesn't have to be decode error, it can also be any network errors such as\n\/\/ connection reset. Fix this ALLUXIO-2235.\nRPCErrorResponse resp = new RPCErrorResponse(RPCResponse.Status.DECODE_ERROR);\nChannelFuture channelFuture = ctx.writeAndFlush(resp);\n\/\/ Close the channel because it is likely a network error.\nchannelFuture.addListener(ChannelFutureListener.CLOSE);\n}\n\n@Override\npublic void exceptionCaught(ChannelHandlerContext ctx, Throwable cause) throws Exception {\nLOG.warn(\"Exception thrown while processing request\", cause);\n\/\/ TODO(peis): This doesn't have to be decode error, it can also be any network errors such as\n\/\/ connection reset. Fix this ALLUXIO-2235.\nRPCErrorResponse resp = new RPCErrorResponse(RPCResponse.Status.DECODE_ERROR);\nChannelFuture channelFuture = ctx.writeAndFlush(resp);\n\/\/ Close the channel because it is likely a network error.\nchannelFuture.addListener(ChannelFutureListener.CLOSE);\n}","code_context_20":"@Override\npublic void exceptionCaught(ChannelHandlerContext ctx, Throwable cause) throws Exception {\nLOG.warn(\"Exception thrown while processing request\", cause);\n\/\/ TODO(peis): This doesn't have to be decode error, it can also be any network errors such as\n\/\/ connection reset. Fix this ALLUXIO-2235.\nRPCErrorResponse resp = new RPCErrorResponse(RPCResponse.Status.DECODE_ERROR);\nChannelFuture channelFuture = ctx.writeAndFlush(resp);\n\/\/ Close the channel because it is likely a network error.\nchannelFuture.addListener(ChannelFutureListener.CLOSE);\n}\n\n@Override\npublic void exceptionCaught(ChannelHandlerContext ctx, Throwable cause) throws Exception {\nLOG.warn(\"Exception thrown while processing request\", cause);\n\/\/ TODO(peis): This doesn't have to be decode error, it can also be any network errors such as\n\/\/ connection reset. Fix this ALLUXIO-2235.\nRPCErrorResponse resp = new RPCErrorResponse(RPCResponse.Status.DECODE_ERROR);\nChannelFuture channelFuture = ctx.writeAndFlush(resp);\n\/\/ Close the channel because it is likely a network error.\nchannelFuture.addListener(ChannelFutureListener.CLOSE);\n}","label":[0,0,1,0]}
{"id":17264,"original_code":"public static NavigableMap<String, Object> readAttrs(Buffer buffer, int version) {\n        NavigableMap<String, Object> attrs = new TreeMap<>(String.CASE_INSENSITIVE_ORDER);\n        int flags = buffer.getInt();\n        if (version >= SftpConstants.SFTP_V4) {\n            int type = buffer.getUByte();\n            switch (type) {\n                case SftpConstants.SSH_FILEXFER_TYPE_REGULAR:\n                    attrs.put(\"isRegular\", Boolean.TRUE);\n                    break;\n                case SftpConstants.SSH_FILEXFER_TYPE_DIRECTORY:\n                    attrs.put(\"isDirectory\", Boolean.TRUE);\n                    break;\n                case SftpConstants.SSH_FILEXFER_TYPE_SYMLINK:\n                    attrs.put(\"isSymbolicLink\", Boolean.TRUE);\n                    break;\n                case SftpConstants.SSH_FILEXFER_TYPE_SOCKET:\n                case SftpConstants.SSH_FILEXFER_TYPE_CHAR_DEVICE:\n                case SftpConstants.SSH_FILEXFER_TYPE_BLOCK_DEVICE:\n                case SftpConstants.SSH_FILEXFER_TYPE_FIFO:\n                    attrs.put(\"isOther\", Boolean.TRUE);\n                    break;\n                default:    \/\/ ignored\n            }\n        }\n        if ((flags & SftpConstants.SSH_FILEXFER_ATTR_SIZE) != 0) {\n            attrs.put(\"size\", buffer.getLong());\n        }\n        if (version == SftpConstants.SFTP_V3) {\n            if ((flags & SftpConstants.SSH_FILEXFER_ATTR_UIDGID) != 0) {\n                attrs.put(\"uid\", buffer.getInt());\n                attrs.put(\"gid\", buffer.getInt());\n            }\n        } else {\n            if ((version >= SftpConstants.SFTP_V6) && ((flags & SftpConstants.SSH_FILEXFER_ATTR_ALLOCATION_SIZE) != 0)) {\n                @SuppressWarnings(\"unused\")\n                long allocSize = buffer.getLong();    \/\/ TODO handle allocation size\n            }\n            if ((flags & SftpConstants.SSH_FILEXFER_ATTR_OWNERGROUP) != 0) {\n                attrs.put(\"owner\", new DefaultGroupPrincipal(buffer.getString()));\n                attrs.put(\"group\", new DefaultGroupPrincipal(buffer.getString()));\n            }\n        }\n        if ((flags & SftpConstants.SSH_FILEXFER_ATTR_PERMISSIONS) != 0) {\n            attrs.put(\"permissions\", permissionsToAttributes(buffer.getInt()));\n        }\n        if (version == SftpConstants.SFTP_V3) {\n            if ((flags & SftpConstants.SSH_FILEXFER_ATTR_ACMODTIME) != 0) {\n                attrs.put(\"lastAccessTime\", readTime(buffer, version, flags));\n                attrs.put(\"lastModifiedTime\", readTime(buffer, version, flags));\n            }\n        } else if (version >= SftpConstants.SFTP_V4) {\n            if ((flags & SftpConstants.SSH_FILEXFER_ATTR_ACCESSTIME) != 0) {\n                attrs.put(\"lastAccessTime\", readTime(buffer, version, flags));\n            }\n            if ((flags & SftpConstants.SSH_FILEXFER_ATTR_CREATETIME) != 0) {\n                attrs.put(\"creationTime\", readTime(buffer, version, flags));\n            }\n            if ((flags & SftpConstants.SSH_FILEXFER_ATTR_MODIFYTIME) != 0) {\n                attrs.put(\"lastModifiedTime\", readTime(buffer, version, flags));\n            }\n            if ((version >= SftpConstants.SFTP_V6) && (flags & SftpConstants.SSH_FILEXFER_ATTR_CTIME) != 0) {\n                attrs.put(\"ctime\", readTime(buffer, version, flags));\n            }\n            if ((flags & SftpConstants.SSH_FILEXFER_ATTR_ACL) != 0) {\n                attrs.put(\"acl\", readACLs(buffer, version));\n            }\n            if ((flags & SftpConstants.SSH_FILEXFER_ATTR_BITS) != 0) {\n                @SuppressWarnings(\"unused\")\n                int bits = buffer.getInt();\n                @SuppressWarnings(\"unused\")\n                int valid = 0xffffffff;\n                if (version >= SftpConstants.SFTP_V6) {\n                    valid = buffer.getInt();\n                }\n                \/\/ TODO: handle attrib bits\n            }\n            if (version >= SftpConstants.SFTP_V6) {\n                if ((flags & SftpConstants.SSH_FILEXFER_ATTR_TEXT_HINT) != 0) {\n                    @SuppressWarnings(\"unused\")\n                    boolean text = buffer.getBoolean(); \/\/ TODO: handle text\n                }\n                if ((flags & SftpConstants.SSH_FILEXFER_ATTR_MIME_TYPE) != 0) {\n                    @SuppressWarnings(\"unused\")\n                    String mimeType = buffer.getString(); \/\/ TODO: handle mime-type\n                }\n                if ((flags & SftpConstants.SSH_FILEXFER_ATTR_LINK_COUNT) != 0) {\n                    @SuppressWarnings(\"unused\")\n                    int nlink = buffer.getInt(); \/\/ TODO: handle link-count\n                }\n                if ((flags & SftpConstants.SSH_FILEXFER_ATTR_UNTRANSLATED_NAME) != 0) {\n                    @SuppressWarnings(\"unused\")\n                    String untranslated = buffer.getString(); \/\/ TODO: handle untranslated-name\n                }\n            }\n        }\n        if ((flags & SftpConstants.SSH_FILEXFER_ATTR_EXTENDED) != 0) {\n            attrs.put(\"extended\", readExtensions(buffer));\n        }\n        return attrs;\n    }","code":"public static NavigableMap<String, Object> readAttrs(Buffer buffer, int version) {\n        NavigableMap<String, Object> attrs = new TreeMap<>(String.CASE_INSENSITIVE_ORDER);\n        int flags = buffer.getInt();\n        if (version >= SftpConstants.SFTP_V4) {\n            int type = buffer.getUByte();\n            switch (type) {\n                case SftpConstants.SSH_FILEXFER_TYPE_REGULAR:\n                    attrs.put(\"isRegular\", Boolean.TRUE);\n                    break;\n                case SftpConstants.SSH_FILEXFER_TYPE_DIRECTORY:\n                    attrs.put(\"isDirectory\", Boolean.TRUE);\n                    break;\n                case SftpConstants.SSH_FILEXFER_TYPE_SYMLINK:\n                    attrs.put(\"isSymbolicLink\", Boolean.TRUE);\n                    break;\n                case SftpConstants.SSH_FILEXFER_TYPE_SOCKET:\n                case SftpConstants.SSH_FILEXFER_TYPE_CHAR_DEVICE:\n                case SftpConstants.SSH_FILEXFER_TYPE_BLOCK_DEVICE:\n                case SftpConstants.SSH_FILEXFER_TYPE_FIFO:\n                    attrs.put(\"isOther\", Boolean.TRUE);\n                    break;\n                default:   \n            }\n        }\n        if ((flags & SftpConstants.SSH_FILEXFER_ATTR_SIZE) != 0) {\n            attrs.put(\"size\", buffer.getLong());\n        }\n        if (version == SftpConstants.SFTP_V3) {\n            if ((flags & SftpConstants.SSH_FILEXFER_ATTR_UIDGID) != 0) {\n                attrs.put(\"uid\", buffer.getInt());\n                attrs.put(\"gid\", buffer.getInt());\n            }\n        } else {\n            if ((version >= SftpConstants.SFTP_V6) && ((flags & SftpConstants.SSH_FILEXFER_ATTR_ALLOCATION_SIZE) != 0)) {\n                @SuppressWarnings(\"unused\")\n                long allocSize = buffer.getLong();   \n            }\n            if ((flags & SftpConstants.SSH_FILEXFER_ATTR_OWNERGROUP) != 0) {\n                attrs.put(\"owner\", new DefaultGroupPrincipal(buffer.getString()));\n                attrs.put(\"group\", new DefaultGroupPrincipal(buffer.getString()));\n            }\n        }\n        if ((flags & SftpConstants.SSH_FILEXFER_ATTR_PERMISSIONS) != 0) {\n            attrs.put(\"permissions\", permissionsToAttributes(buffer.getInt()));\n        }\n        if (version == SftpConstants.SFTP_V3) {\n            if ((flags & SftpConstants.SSH_FILEXFER_ATTR_ACMODTIME) != 0) {\n                attrs.put(\"lastAccessTime\", readTime(buffer, version, flags));\n                attrs.put(\"lastModifiedTime\", readTime(buffer, version, flags));\n            }\n        } else if (version >= SftpConstants.SFTP_V4) {\n            if ((flags & SftpConstants.SSH_FILEXFER_ATTR_ACCESSTIME) != 0) {\n                attrs.put(\"lastAccessTime\", readTime(buffer, version, flags));\n            }\n            if ((flags & SftpConstants.SSH_FILEXFER_ATTR_CREATETIME) != 0) {\n                attrs.put(\"creationTime\", readTime(buffer, version, flags));\n            }\n            if ((flags & SftpConstants.SSH_FILEXFER_ATTR_MODIFYTIME) != 0) {\n                attrs.put(\"lastModifiedTime\", readTime(buffer, version, flags));\n            }\n            if ((version >= SftpConstants.SFTP_V6) && (flags & SftpConstants.SSH_FILEXFER_ATTR_CTIME) != 0) {\n                attrs.put(\"ctime\", readTime(buffer, version, flags));\n            }\n            if ((flags & SftpConstants.SSH_FILEXFER_ATTR_ACL) != 0) {\n                attrs.put(\"acl\", readACLs(buffer, version));\n            }\n            if ((flags & SftpConstants.SSH_FILEXFER_ATTR_BITS) != 0) {\n                @SuppressWarnings(\"unused\")\n                int bits = buffer.getInt();\n                @SuppressWarnings(\"unused\")\n                int valid = 0xffffffff;\n                if (version >= SftpConstants.SFTP_V6) {\n                    valid = buffer.getInt();\n                }\n               \n            }\n            if (version >= SftpConstants.SFTP_V6) {\n                if ((flags & SftpConstants.SSH_FILEXFER_ATTR_TEXT_HINT) != 0) {\n                    @SuppressWarnings(\"unused\")\n                    boolean text = buffer.getBoolean();\n                }\n                if ((flags & SftpConstants.SSH_FILEXFER_ATTR_MIME_TYPE) != 0) {\n                    @SuppressWarnings(\"unused\")\n                    String mimeType = buffer.getString();\n                }\n                if ((flags & SftpConstants.SSH_FILEXFER_ATTR_LINK_COUNT) != 0) {\n                    @SuppressWarnings(\"unused\")\n                    int nlink = buffer.getInt();\n                }\n                if ((flags & SftpConstants.SSH_FILEXFER_ATTR_UNTRANSLATED_NAME) != 0) {\n                    @SuppressWarnings(\"unused\")\n                    String untranslated = buffer.getString();\n                }\n            }\n        }\n        if ((flags & SftpConstants.SSH_FILEXFER_ATTR_EXTENDED) != 0) {\n            attrs.put(\"extended\", readExtensions(buffer));\n        }\n        return attrs;\n    }","cleancode":"public static navigablemap<string, object> readattrs(buffer buffer, int version) { navigablemap<string, object> attrs = new treemap<>(string.case_insensitive_order); int flags = buffer.getint(); if (version >= sftpconstants.sftp_v4) { int type = buffer.getubyte(); switch (type) { case sftpconstants.ssh_filexfer_type_regular: attrs.put(\"isregular\", boolean.true); break; case sftpconstants.ssh_filexfer_type_directory: attrs.put(\"isdirectory\", boolean.true); break; case sftpconstants.ssh_filexfer_type_symlink: attrs.put(\"issymboliclink\", boolean.true); break; case sftpconstants.ssh_filexfer_type_socket: case sftpconstants.ssh_filexfer_type_char_device: case sftpconstants.ssh_filexfer_type_block_device: case sftpconstants.ssh_filexfer_type_fifo: attrs.put(\"isother\", boolean.true); break; default: } } if ((flags & sftpconstants.ssh_filexfer_attr_size) != 0) { attrs.put(\"size\", buffer.getlong()); } if (version == sftpconstants.sftp_v3) { if ((flags & sftpconstants.ssh_filexfer_attr_uidgid) != 0) { attrs.put(\"uid\", buffer.getint()); attrs.put(\"gid\", buffer.getint()); } } else { if ((version >= sftpconstants.sftp_v6) && ((flags & sftpconstants.ssh_filexfer_attr_allocation_size) != 0)) { @suppresswarnings(\"unused\") long allocsize = buffer.getlong(); } if ((flags & sftpconstants.ssh_filexfer_attr_ownergroup) != 0) { attrs.put(\"owner\", new defaultgroupprincipal(buffer.getstring())); attrs.put(\"group\", new defaultgroupprincipal(buffer.getstring())); } } if ((flags & sftpconstants.ssh_filexfer_attr_permissions) != 0) { attrs.put(\"permissions\", permissionstoattributes(buffer.getint())); } if (version == sftpconstants.sftp_v3) { if ((flags & sftpconstants.ssh_filexfer_attr_acmodtime) != 0) { attrs.put(\"lastaccesstime\", readtime(buffer, version, flags)); attrs.put(\"lastmodifiedtime\", readtime(buffer, version, flags)); } } else if (version >= sftpconstants.sftp_v4) { if ((flags & sftpconstants.ssh_filexfer_attr_accesstime) != 0) { attrs.put(\"lastaccesstime\", readtime(buffer, version, flags)); } if ((flags & sftpconstants.ssh_filexfer_attr_createtime) != 0) { attrs.put(\"creationtime\", readtime(buffer, version, flags)); } if ((flags & sftpconstants.ssh_filexfer_attr_modifytime) != 0) { attrs.put(\"lastmodifiedtime\", readtime(buffer, version, flags)); } if ((version >= sftpconstants.sftp_v6) && (flags & sftpconstants.ssh_filexfer_attr_ctime) != 0) { attrs.put(\"ctime\", readtime(buffer, version, flags)); } if ((flags & sftpconstants.ssh_filexfer_attr_acl) != 0) { attrs.put(\"acl\", readacls(buffer, version)); } if ((flags & sftpconstants.ssh_filexfer_attr_bits) != 0) { @suppresswarnings(\"unused\") int bits = buffer.getint(); @suppresswarnings(\"unused\") int valid = 0xffffffff; if (version >= sftpconstants.sftp_v6) { valid = buffer.getint(); } } if (version >= sftpconstants.sftp_v6) { if ((flags & sftpconstants.ssh_filexfer_attr_text_hint) != 0) { @suppresswarnings(\"unused\") boolean text = buffer.getboolean(); } if ((flags & sftpconstants.ssh_filexfer_attr_mime_type) != 0) { @suppresswarnings(\"unused\") string mimetype = buffer.getstring(); } if ((flags & sftpconstants.ssh_filexfer_attr_link_count) != 0) { @suppresswarnings(\"unused\") int nlink = buffer.getint(); } if ((flags & sftpconstants.ssh_filexfer_attr_untranslated_name) != 0) { @suppresswarnings(\"unused\") string untranslated = buffer.getstring(); } } } if ((flags & sftpconstants.ssh_filexfer_attr_extended) != 0) { attrs.put(\"extended\", readextensions(buffer)); } return attrs; }","comment":"\/\/ ignored\n\/\/ todo handle allocation size\n\/\/ todo: handle attrib bits\n\/\/ todo: handle text\n\/\/ todo: handle mime-type\n\/\/ todo: handle link-count\n\/\/ todo: handle untranslated-name","repo":"msohn\/mina-sshd","code_context_2":"attrs.put(\"isOther\", Boolean.TRUE);\nbreak;\ndefault: \/\/ ignored\n}\n}\n\nif ((version >= SftpConstants.SFTP_V6) && ((flags & SftpConstants.SSH_FILEXFER_ATTR_ALLOCATION_SIZE) != 0)) {\n@SuppressWarnings(\"unused\")\nlong allocSize = buffer.getLong(); \/\/ TODO handle allocation size\n}\nif ((flags & SftpConstants.SSH_FILEXFER_ATTR_OWNERGROUP) != 0) {\n\nvalid = buffer.getInt();\n}\n\/\/ TODO: handle attrib bits\n}\nif (version >= SftpConstants.SFTP_V6) {\n\nif ((flags & SftpConstants.SSH_FILEXFER_ATTR_TEXT_HINT) != 0) {\n@SuppressWarnings(\"unused\")\nboolean text = buffer.getBoolean(); \/\/ TODO: handle text\n}\nif ((flags & SftpConstants.SSH_FILEXFER_ATTR_MIME_TYPE) != 0) {\n\nif ((flags & SftpConstants.SSH_FILEXFER_ATTR_MIME_TYPE) != 0) {\n@SuppressWarnings(\"unused\")\nString mimeType = buffer.getString(); \/\/ TODO: handle mime-type\n}\nif ((flags & SftpConstants.SSH_FILEXFER_ATTR_LINK_COUNT) != 0) {\n\nif ((flags & SftpConstants.SSH_FILEXFER_ATTR_LINK_COUNT) != 0) {\n@SuppressWarnings(\"unused\")\nint nlink = buffer.getInt(); \/\/ TODO: handle link-count\n}\nif ((flags & SftpConstants.SSH_FILEXFER_ATTR_UNTRANSLATED_NAME) != 0) {\n\nif ((flags & SftpConstants.SSH_FILEXFER_ATTR_UNTRANSLATED_NAME) != 0) {\n@SuppressWarnings(\"unused\")\nString untranslated = buffer.getString(); \/\/ TODO: handle untranslated-name\n}\n}","code_context_10":"break;\ncase SftpConstants.SSH_FILEXFER_TYPE_SYMLINK:\nattrs.put(\"isSymbolicLink\", Boolean.TRUE);\nbreak;\ncase SftpConstants.SSH_FILEXFER_TYPE_SOCKET:\ncase SftpConstants.SSH_FILEXFER_TYPE_CHAR_DEVICE:\ncase SftpConstants.SSH_FILEXFER_TYPE_BLOCK_DEVICE:\ncase SftpConstants.SSH_FILEXFER_TYPE_FIFO:\nattrs.put(\"isOther\", Boolean.TRUE);\nbreak;\ndefault: \/\/ ignored\n}\n}\nif ((flags & SftpConstants.SSH_FILEXFER_ATTR_SIZE) != 0) {\nattrs.put(\"size\", buffer.getLong());\n}\nif (version == SftpConstants.SFTP_V3) {\nif ((flags & SftpConstants.SSH_FILEXFER_ATTR_UIDGID) != 0) {\nattrs.put(\"uid\", buffer.getInt());\nattrs.put(\"gid\", buffer.getInt());\n}\n\nattrs.put(\"size\", buffer.getLong());\n}\nif (version == SftpConstants.SFTP_V3) {\nif ((flags & SftpConstants.SSH_FILEXFER_ATTR_UIDGID) != 0) {\nattrs.put(\"uid\", buffer.getInt());\nattrs.put(\"gid\", buffer.getInt());\n}\n} else {\nif ((version >= SftpConstants.SFTP_V6) && ((flags & SftpConstants.SSH_FILEXFER_ATTR_ALLOCATION_SIZE) != 0)) {\n@SuppressWarnings(\"unused\")\nlong allocSize = buffer.getLong(); \/\/ TODO handle allocation size\n}\nif ((flags & SftpConstants.SSH_FILEXFER_ATTR_OWNERGROUP) != 0) {\nattrs.put(\"owner\", new DefaultGroupPrincipal(buffer.getString()));\nattrs.put(\"group\", new DefaultGroupPrincipal(buffer.getString()));\n}\n}\nif ((flags & SftpConstants.SSH_FILEXFER_ATTR_PERMISSIONS) != 0) {\nattrs.put(\"permissions\", permissionsToAttributes(buffer.getInt()));\n}\nif (version == SftpConstants.SFTP_V3) {\n\nattrs.put(\"acl\", readACLs(buffer, version));\n}\nif ((flags & SftpConstants.SSH_FILEXFER_ATTR_BITS) != 0) {\n@SuppressWarnings(\"unused\")\nint bits = buffer.getInt();\n@SuppressWarnings(\"unused\")\nint valid = 0xffffffff;\nif (version >= SftpConstants.SFTP_V6) {\nvalid = buffer.getInt();\n}\n\/\/ TODO: handle attrib bits\n}\nif (version >= SftpConstants.SFTP_V6) {\nif ((flags & SftpConstants.SSH_FILEXFER_ATTR_TEXT_HINT) != 0) {\n@SuppressWarnings(\"unused\")\nboolean text = buffer.getBoolean(); \/\/ TODO: handle text\n}\nif ((flags & SftpConstants.SSH_FILEXFER_ATTR_MIME_TYPE) != 0) {\n@SuppressWarnings(\"unused\")\nString mimeType = buffer.getString(); \/\/ TODO: handle mime-type\n}\n\n@SuppressWarnings(\"unused\")\nint valid = 0xffffffff;\nif (version >= SftpConstants.SFTP_V6) {\nvalid = buffer.getInt();\n}\n\/\/ TODO: handle attrib bits\n}\nif (version >= SftpConstants.SFTP_V6) {\nif ((flags & SftpConstants.SSH_FILEXFER_ATTR_TEXT_HINT) != 0) {\n@SuppressWarnings(\"unused\")\nboolean text = buffer.getBoolean(); \/\/ TODO: handle text\n}\nif ((flags & SftpConstants.SSH_FILEXFER_ATTR_MIME_TYPE) != 0) {\n@SuppressWarnings(\"unused\")\nString mimeType = buffer.getString(); \/\/ TODO: handle mime-type\n}\nif ((flags & SftpConstants.SSH_FILEXFER_ATTR_LINK_COUNT) != 0) {\n@SuppressWarnings(\"unused\")\nint nlink = buffer.getInt(); \/\/ TODO: handle link-count\n}\nif ((flags & SftpConstants.SSH_FILEXFER_ATTR_UNTRANSLATED_NAME) != 0) {\n\n}\n\/\/ TODO: handle attrib bits\n}\nif (version >= SftpConstants.SFTP_V6) {\nif ((flags & SftpConstants.SSH_FILEXFER_ATTR_TEXT_HINT) != 0) {\n@SuppressWarnings(\"unused\")\nboolean text = buffer.getBoolean(); \/\/ TODO: handle text\n}\nif ((flags & SftpConstants.SSH_FILEXFER_ATTR_MIME_TYPE) != 0) {\n@SuppressWarnings(\"unused\")\nString mimeType = buffer.getString(); \/\/ TODO: handle mime-type\n}\nif ((flags & SftpConstants.SSH_FILEXFER_ATTR_LINK_COUNT) != 0) {\n@SuppressWarnings(\"unused\")\nint nlink = buffer.getInt(); \/\/ TODO: handle link-count\n}\nif ((flags & SftpConstants.SSH_FILEXFER_ATTR_UNTRANSLATED_NAME) != 0) {\n@SuppressWarnings(\"unused\")\nString untranslated = buffer.getString(); \/\/ TODO: handle untranslated-name\n}\n}\n\nif ((flags & SftpConstants.SSH_FILEXFER_ATTR_TEXT_HINT) != 0) {\n@SuppressWarnings(\"unused\")\nboolean text = buffer.getBoolean(); \/\/ TODO: handle text\n}\nif ((flags & SftpConstants.SSH_FILEXFER_ATTR_MIME_TYPE) != 0) {\n@SuppressWarnings(\"unused\")\nString mimeType = buffer.getString(); \/\/ TODO: handle mime-type\n}\nif ((flags & SftpConstants.SSH_FILEXFER_ATTR_LINK_COUNT) != 0) {\n@SuppressWarnings(\"unused\")\nint nlink = buffer.getInt(); \/\/ TODO: handle link-count\n}\nif ((flags & SftpConstants.SSH_FILEXFER_ATTR_UNTRANSLATED_NAME) != 0) {\n@SuppressWarnings(\"unused\")\nString untranslated = buffer.getString(); \/\/ TODO: handle untranslated-name\n}\n}\n}\nif ((flags & SftpConstants.SSH_FILEXFER_ATTR_EXTENDED) != 0) {\nattrs.put(\"extended\", readExtensions(buffer));\n}\n\nif ((flags & SftpConstants.SSH_FILEXFER_ATTR_MIME_TYPE) != 0) {\n@SuppressWarnings(\"unused\")\nString mimeType = buffer.getString(); \/\/ TODO: handle mime-type\n}\nif ((flags & SftpConstants.SSH_FILEXFER_ATTR_LINK_COUNT) != 0) {\n@SuppressWarnings(\"unused\")\nint nlink = buffer.getInt(); \/\/ TODO: handle link-count\n}\nif ((flags & SftpConstants.SSH_FILEXFER_ATTR_UNTRANSLATED_NAME) != 0) {\n@SuppressWarnings(\"unused\")\nString untranslated = buffer.getString(); \/\/ TODO: handle untranslated-name\n}\n}\n}\nif ((flags & SftpConstants.SSH_FILEXFER_ATTR_EXTENDED) != 0) {\nattrs.put(\"extended\", readExtensions(buffer));\n}\nreturn attrs;\n}","code_context_20":"NavigableMap<String, Object> attrs = new TreeMap<>(String.CASE_INSENSITIVE_ORDER);\nint flags = buffer.getInt();\nif (version >= SftpConstants.SFTP_V4) {\nint type = buffer.getUByte();\nswitch (type) {\ncase SftpConstants.SSH_FILEXFER_TYPE_REGULAR:\nattrs.put(\"isRegular\", Boolean.TRUE);\nbreak;\ncase SftpConstants.SSH_FILEXFER_TYPE_DIRECTORY:\nattrs.put(\"isDirectory\", Boolean.TRUE);\nbreak;\ncase SftpConstants.SSH_FILEXFER_TYPE_SYMLINK:\nattrs.put(\"isSymbolicLink\", Boolean.TRUE);\nbreak;\ncase SftpConstants.SSH_FILEXFER_TYPE_SOCKET:\ncase SftpConstants.SSH_FILEXFER_TYPE_CHAR_DEVICE:\ncase SftpConstants.SSH_FILEXFER_TYPE_BLOCK_DEVICE:\ncase SftpConstants.SSH_FILEXFER_TYPE_FIFO:\nattrs.put(\"isOther\", Boolean.TRUE);\nbreak;\ndefault: \/\/ ignored\n}\n}\nif ((flags & SftpConstants.SSH_FILEXFER_ATTR_SIZE) != 0) {\nattrs.put(\"size\", buffer.getLong());\n}\nif (version == SftpConstants.SFTP_V3) {\nif ((flags & SftpConstants.SSH_FILEXFER_ATTR_UIDGID) != 0) {\nattrs.put(\"uid\", buffer.getInt());\nattrs.put(\"gid\", buffer.getInt());\n}\n} else {\nif ((version >= SftpConstants.SFTP_V6) && ((flags & SftpConstants.SSH_FILEXFER_ATTR_ALLOCATION_SIZE) != 0)) {\n@SuppressWarnings(\"unused\")\nlong allocSize = buffer.getLong(); \/\/ TODO handle allocation size\n}\nif ((flags & SftpConstants.SSH_FILEXFER_ATTR_OWNERGROUP) != 0) {\nattrs.put(\"owner\", new DefaultGroupPrincipal(buffer.getString()));\nattrs.put(\"group\", new DefaultGroupPrincipal(buffer.getString()));\n}\n}\n\ncase SftpConstants.SSH_FILEXFER_TYPE_SOCKET:\ncase SftpConstants.SSH_FILEXFER_TYPE_CHAR_DEVICE:\ncase SftpConstants.SSH_FILEXFER_TYPE_BLOCK_DEVICE:\ncase SftpConstants.SSH_FILEXFER_TYPE_FIFO:\nattrs.put(\"isOther\", Boolean.TRUE);\nbreak;\ndefault: \/\/ ignored\n}\n}\nif ((flags & SftpConstants.SSH_FILEXFER_ATTR_SIZE) != 0) {\nattrs.put(\"size\", buffer.getLong());\n}\nif (version == SftpConstants.SFTP_V3) {\nif ((flags & SftpConstants.SSH_FILEXFER_ATTR_UIDGID) != 0) {\nattrs.put(\"uid\", buffer.getInt());\nattrs.put(\"gid\", buffer.getInt());\n}\n} else {\nif ((version >= SftpConstants.SFTP_V6) && ((flags & SftpConstants.SSH_FILEXFER_ATTR_ALLOCATION_SIZE) != 0)) {\n@SuppressWarnings(\"unused\")\nlong allocSize = buffer.getLong(); \/\/ TODO handle allocation size\n}\nif ((flags & SftpConstants.SSH_FILEXFER_ATTR_OWNERGROUP) != 0) {\nattrs.put(\"owner\", new DefaultGroupPrincipal(buffer.getString()));\nattrs.put(\"group\", new DefaultGroupPrincipal(buffer.getString()));\n}\n}\nif ((flags & SftpConstants.SSH_FILEXFER_ATTR_PERMISSIONS) != 0) {\nattrs.put(\"permissions\", permissionsToAttributes(buffer.getInt()));\n}\nif (version == SftpConstants.SFTP_V3) {\nif ((flags & SftpConstants.SSH_FILEXFER_ATTR_ACMODTIME) != 0) {\nattrs.put(\"lastAccessTime\", readTime(buffer, version, flags));\nattrs.put(\"lastModifiedTime\", readTime(buffer, version, flags));\n}\n} else if (version >= SftpConstants.SFTP_V4) {\nif ((flags & SftpConstants.SSH_FILEXFER_ATTR_ACCESSTIME) != 0) {\nattrs.put(\"lastAccessTime\", readTime(buffer, version, flags));\n}\nif ((flags & SftpConstants.SSH_FILEXFER_ATTR_CREATETIME) != 0) {\nattrs.put(\"creationTime\", readTime(buffer, version, flags));\n\nif ((flags & SftpConstants.SSH_FILEXFER_ATTR_CREATETIME) != 0) {\nattrs.put(\"creationTime\", readTime(buffer, version, flags));\n}\nif ((flags & SftpConstants.SSH_FILEXFER_ATTR_MODIFYTIME) != 0) {\nattrs.put(\"lastModifiedTime\", readTime(buffer, version, flags));\n}\nif ((version >= SftpConstants.SFTP_V6) && (flags & SftpConstants.SSH_FILEXFER_ATTR_CTIME) != 0) {\nattrs.put(\"ctime\", readTime(buffer, version, flags));\n}\nif ((flags & SftpConstants.SSH_FILEXFER_ATTR_ACL) != 0) {\nattrs.put(\"acl\", readACLs(buffer, version));\n}\nif ((flags & SftpConstants.SSH_FILEXFER_ATTR_BITS) != 0) {\n@SuppressWarnings(\"unused\")\nint bits = buffer.getInt();\n@SuppressWarnings(\"unused\")\nint valid = 0xffffffff;\nif (version >= SftpConstants.SFTP_V6) {\nvalid = buffer.getInt();\n}\n\/\/ TODO: handle attrib bits\n}\nif (version >= SftpConstants.SFTP_V6) {\nif ((flags & SftpConstants.SSH_FILEXFER_ATTR_TEXT_HINT) != 0) {\n@SuppressWarnings(\"unused\")\nboolean text = buffer.getBoolean(); \/\/ TODO: handle text\n}\nif ((flags & SftpConstants.SSH_FILEXFER_ATTR_MIME_TYPE) != 0) {\n@SuppressWarnings(\"unused\")\nString mimeType = buffer.getString(); \/\/ TODO: handle mime-type\n}\nif ((flags & SftpConstants.SSH_FILEXFER_ATTR_LINK_COUNT) != 0) {\n@SuppressWarnings(\"unused\")\nint nlink = buffer.getInt(); \/\/ TODO: handle link-count\n}\nif ((flags & SftpConstants.SSH_FILEXFER_ATTR_UNTRANSLATED_NAME) != 0) {\n@SuppressWarnings(\"unused\")\nString untranslated = buffer.getString(); \/\/ TODO: handle untranslated-name\n}\n}\n}\n\n}\nif ((version >= SftpConstants.SFTP_V6) && (flags & SftpConstants.SSH_FILEXFER_ATTR_CTIME) != 0) {\nattrs.put(\"ctime\", readTime(buffer, version, flags));\n}\nif ((flags & SftpConstants.SSH_FILEXFER_ATTR_ACL) != 0) {\nattrs.put(\"acl\", readACLs(buffer, version));\n}\nif ((flags & SftpConstants.SSH_FILEXFER_ATTR_BITS) != 0) {\n@SuppressWarnings(\"unused\")\nint bits = buffer.getInt();\n@SuppressWarnings(\"unused\")\nint valid = 0xffffffff;\nif (version >= SftpConstants.SFTP_V6) {\nvalid = buffer.getInt();\n}\n\/\/ TODO: handle attrib bits\n}\nif (version >= SftpConstants.SFTP_V6) {\nif ((flags & SftpConstants.SSH_FILEXFER_ATTR_TEXT_HINT) != 0) {\n@SuppressWarnings(\"unused\")\nboolean text = buffer.getBoolean(); \/\/ TODO: handle text\n}\nif ((flags & SftpConstants.SSH_FILEXFER_ATTR_MIME_TYPE) != 0) {\n@SuppressWarnings(\"unused\")\nString mimeType = buffer.getString(); \/\/ TODO: handle mime-type\n}\nif ((flags & SftpConstants.SSH_FILEXFER_ATTR_LINK_COUNT) != 0) {\n@SuppressWarnings(\"unused\")\nint nlink = buffer.getInt(); \/\/ TODO: handle link-count\n}\nif ((flags & SftpConstants.SSH_FILEXFER_ATTR_UNTRANSLATED_NAME) != 0) {\n@SuppressWarnings(\"unused\")\nString untranslated = buffer.getString(); \/\/ TODO: handle untranslated-name\n}\n}\n}\nif ((flags & SftpConstants.SSH_FILEXFER_ATTR_EXTENDED) != 0) {\nattrs.put(\"extended\", readExtensions(buffer));\n}\nreturn attrs;\n}\n\nif ((flags & SftpConstants.SSH_FILEXFER_ATTR_ACL) != 0) {\nattrs.put(\"acl\", readACLs(buffer, version));\n}\nif ((flags & SftpConstants.SSH_FILEXFER_ATTR_BITS) != 0) {\n@SuppressWarnings(\"unused\")\nint bits = buffer.getInt();\n@SuppressWarnings(\"unused\")\nint valid = 0xffffffff;\nif (version >= SftpConstants.SFTP_V6) {\nvalid = buffer.getInt();\n}\n\/\/ TODO: handle attrib bits\n}\nif (version >= SftpConstants.SFTP_V6) {\nif ((flags & SftpConstants.SSH_FILEXFER_ATTR_TEXT_HINT) != 0) {\n@SuppressWarnings(\"unused\")\nboolean text = buffer.getBoolean(); \/\/ TODO: handle text\n}\nif ((flags & SftpConstants.SSH_FILEXFER_ATTR_MIME_TYPE) != 0) {\n@SuppressWarnings(\"unused\")\nString mimeType = buffer.getString(); \/\/ TODO: handle mime-type\n}\nif ((flags & SftpConstants.SSH_FILEXFER_ATTR_LINK_COUNT) != 0) {\n@SuppressWarnings(\"unused\")\nint nlink = buffer.getInt(); \/\/ TODO: handle link-count\n}\nif ((flags & SftpConstants.SSH_FILEXFER_ATTR_UNTRANSLATED_NAME) != 0) {\n@SuppressWarnings(\"unused\")\nString untranslated = buffer.getString(); \/\/ TODO: handle untranslated-name\n}\n}\n}\nif ((flags & SftpConstants.SSH_FILEXFER_ATTR_EXTENDED) != 0) {\nattrs.put(\"extended\", readExtensions(buffer));\n}\nreturn attrs;\n}\n\n@SuppressWarnings(\"unused\")\nint bits = buffer.getInt();\n@SuppressWarnings(\"unused\")\nint valid = 0xffffffff;\nif (version >= SftpConstants.SFTP_V6) {\nvalid = buffer.getInt();\n}\n\/\/ TODO: handle attrib bits\n}\nif (version >= SftpConstants.SFTP_V6) {\nif ((flags & SftpConstants.SSH_FILEXFER_ATTR_TEXT_HINT) != 0) {\n@SuppressWarnings(\"unused\")\nboolean text = buffer.getBoolean(); \/\/ TODO: handle text\n}\nif ((flags & SftpConstants.SSH_FILEXFER_ATTR_MIME_TYPE) != 0) {\n@SuppressWarnings(\"unused\")\nString mimeType = buffer.getString(); \/\/ TODO: handle mime-type\n}\nif ((flags & SftpConstants.SSH_FILEXFER_ATTR_LINK_COUNT) != 0) {\n@SuppressWarnings(\"unused\")\nint nlink = buffer.getInt(); \/\/ TODO: handle link-count\n}\nif ((flags & SftpConstants.SSH_FILEXFER_ATTR_UNTRANSLATED_NAME) != 0) {\n@SuppressWarnings(\"unused\")\nString untranslated = buffer.getString(); \/\/ TODO: handle untranslated-name\n}\n}\n}\nif ((flags & SftpConstants.SSH_FILEXFER_ATTR_EXTENDED) != 0) {\nattrs.put(\"extended\", readExtensions(buffer));\n}\nreturn attrs;\n}\n\nif (version >= SftpConstants.SFTP_V6) {\nvalid = buffer.getInt();\n}\n\/\/ TODO: handle attrib bits\n}\nif (version >= SftpConstants.SFTP_V6) {\nif ((flags & SftpConstants.SSH_FILEXFER_ATTR_TEXT_HINT) != 0) {\n@SuppressWarnings(\"unused\")\nboolean text = buffer.getBoolean(); \/\/ TODO: handle text\n}\nif ((flags & SftpConstants.SSH_FILEXFER_ATTR_MIME_TYPE) != 0) {\n@SuppressWarnings(\"unused\")\nString mimeType = buffer.getString(); \/\/ TODO: handle mime-type\n}\nif ((flags & SftpConstants.SSH_FILEXFER_ATTR_LINK_COUNT) != 0) {\n@SuppressWarnings(\"unused\")\nint nlink = buffer.getInt(); \/\/ TODO: handle link-count\n}\nif ((flags & SftpConstants.SSH_FILEXFER_ATTR_UNTRANSLATED_NAME) != 0) {\n@SuppressWarnings(\"unused\")\nString untranslated = buffer.getString(); \/\/ TODO: handle untranslated-name\n}\n}\n}\nif ((flags & SftpConstants.SSH_FILEXFER_ATTR_EXTENDED) != 0) {\nattrs.put(\"extended\", readExtensions(buffer));\n}\nreturn attrs;\n}","label":[0,1,0,0]}
{"id":17318,"original_code":"@Override\n    void storeProperties() throws IOException {\n        super.storeProperties();\n        \/\/ Store chnages in manifest\n        storeManifestChanges();\n        \/\/ store localized info\n        if (bundleInfo != null && bundleInfo.isModified()) {\n            bundleInfo.store();\n        } \/\/ XXX else ignore for now but we could save into some default location\n        ProjectXMLManager pxm = getProjectXMLManager();\n        \/\/ Store project.xml changes\n        \/\/ store module dependencies\n        DependencyListModel dependencyModel = getDependenciesListModel();\n        if (dependencyModel.isChanged()) {\n            Set<ModuleDependency> depsToSave = new TreeSet<ModuleDependency>(dependencyModel.getDependencies());\n            logNetBeansAPIUsage(\"DEPENDENCIES\", dependencyModel.getDependencies()); \/\/ NOI18N\n            try {\n                pxm.replaceDependencies(depsToSave);\n            } catch (CyclicDependencyException ex) {\n                throw new IOException(ex);\n            }\n        }\n        Set<String> friends = getFriendListModel().getFriends();\n        Set<String> publicPkgs = getPublicPackagesModel().getSelectedPackages();\n        boolean refreshModuleList = false;\n        if (getPublicPackagesModel().isChanged() || getFriendListModel().isChanged()) {\n            if (friends.size() > 0) { \/\/ store friends packages\n                pxm.replaceFriends(friends, publicPkgs);\n            } else { \/\/ store public packages\n                pxm.replacePublicPackages(publicPkgs);\n            }\n            refreshModuleList = true;\n        }\n        \/\/ store class-path-extensions + its src & javadoc\n        if (cps != null && wrappedJarsListModel != null && wrappedJarsChanged) {\n            final List<Item> cpExtList = ClassPathUiSupport.getList(wrappedJarsListModel);\n            Map<String, String> newCpExt = new HashMap<String, String>();\n            for (Item item : cpExtList) {\n                String binPath = item.getFilePath();\n                if (binPath != null) {\n                    FileObject fo = FileUtil.toFileObject(PropertyUtils.resolveFile(getProjectDirectoryFile(), binPath));\n                    if(fo != null)\n                    {\n                        String runtimePath = ApisupportAntUtils.CPEXT_RUNTIME_RELATIVE_PATH + fo.getNameExt();\n                        newCpExt.put(runtimePath, binPath);\n                    }\n                }\n            }\n            \/\/ delete removed JARs, remove any remaining exported packages and src&javadoc refs left\n            Iterator<Item> it = getCPExtIterator();\n            HashSet<String> jarsSet = new HashSet<String>(newCpExt.values());\n            while (it.hasNext()) {\n                Item item = it.next();\n                if (!jarsSet.contains(item.getFilePath())) {\n                    \/\/ XXX deleting here doesn't work on Windows: \n\/\/                    File f = PropertyUtils.resolveFile(getProjectDirectoryFile(), item.getFilePath());\n\/\/                    FileObject toDel = FileUtil.toFileObject(f);\n\/\/                    if (toDel != null) {\n\/\/                        toDel.delete();\n\/\/                    }\n                    assert item.getReference() != null : \"getCPExtIterator() initializes references to wrapped JARs\";\n                    item.removeSourceAndJavadoc(getUpdateHelper());\n                    getRefHelper().destroyReference(item.getReference());\n                }\n            }\n            cps.encodeToStrings(cpExtList, CPEXT);\n            pxm.replaceClassPathExtensions(newCpExt);\n            wrappedJarsChanged = false;\n        }\n        if (isStandalone()) {\n            ModuleProperties.storePlatform(getHelper(), getActivePlatform());\n            if (javaPlatformChanged) {\n                ModuleProperties.storeJavaPlatform(getHelper(), getEvaluator(), getActiveJavaPlatform(), false);\n            }\n            if (refreshModuleList) {\n                ModuleList.refreshModuleListForRoot(getProjectDirectoryFile());\n            }\n        } else if (isSuiteComponent() && refreshModuleList) {\n            ModuleList.refreshModuleListForRoot(getSuiteDirectory());\n        } else if (isNetBeansOrg()) {\n            if (javaPlatformChanged) {\n                ModuleProperties.storeJavaPlatform(getHelper(), getEvaluator(), getActiveJavaPlatform(), true);\n            }\n            if (refreshModuleList) {\n                ModuleList.refreshModuleListForRoot(ModuleList.findNetBeansOrg(getProjectDirectoryFile()));\n            }\n        }\n    }","code":"@Override\n    void storeProperties() throws IOException {\n        super.storeProperties();\n       \n        storeManifestChanges();\n       \n        if (bundleInfo != null && bundleInfo.isModified()) {\n            bundleInfo.store();\n        }\n        ProjectXMLManager pxm = getProjectXMLManager();\n       \n       \n        DependencyListModel dependencyModel = getDependenciesListModel();\n        if (dependencyModel.isChanged()) {\n            Set<ModuleDependency> depsToSave = new TreeSet<ModuleDependency>(dependencyModel.getDependencies());\n            logNetBeansAPIUsage(\"DEPENDENCIES\", dependencyModel.getDependencies());\n            try {\n                pxm.replaceDependencies(depsToSave);\n            } catch (CyclicDependencyException ex) {\n                throw new IOException(ex);\n            }\n        }\n        Set<String> friends = getFriendListModel().getFriends();\n        Set<String> publicPkgs = getPublicPackagesModel().getSelectedPackages();\n        boolean refreshModuleList = false;\n        if (getPublicPackagesModel().isChanged() || getFriendListModel().isChanged()) {\n            if (friends.size() > 0) {\n                pxm.replaceFriends(friends, publicPkgs);\n            } else {\n                pxm.replacePublicPackages(publicPkgs);\n            }\n            refreshModuleList = true;\n        }\n       \n        if (cps != null && wrappedJarsListModel != null && wrappedJarsChanged) {\n            final List<Item> cpExtList = ClassPathUiSupport.getList(wrappedJarsListModel);\n            Map<String, String> newCpExt = new HashMap<String, String>();\n            for (Item item : cpExtList) {\n                String binPath = item.getFilePath();\n                if (binPath != null) {\n                    FileObject fo = FileUtil.toFileObject(PropertyUtils.resolveFile(getProjectDirectoryFile(), binPath));\n                    if(fo != null)\n                    {\n                        String runtimePath = ApisupportAntUtils.CPEXT_RUNTIME_RELATIVE_PATH + fo.getNameExt();\n                        newCpExt.put(runtimePath, binPath);\n                    }\n                }\n            }\n           \n            Iterator<Item> it = getCPExtIterator();\n            HashSet<String> jarsSet = new HashSet<String>(newCpExt.values());\n            while (it.hasNext()) {\n                Item item = it.next();\n                if (!jarsSet.contains(item.getFilePath())) {\n                   \n                    assert item.getReference() != null : \"getCPExtIterator() initializes references to wrapped JARs\";\n                    item.removeSourceAndJavadoc(getUpdateHelper());\n                    getRefHelper().destroyReference(item.getReference());\n                }\n            }\n            cps.encodeToStrings(cpExtList, CPEXT);\n            pxm.replaceClassPathExtensions(newCpExt);\n            wrappedJarsChanged = false;\n        }\n        if (isStandalone()) {\n            ModuleProperties.storePlatform(getHelper(), getActivePlatform());\n            if (javaPlatformChanged) {\n                ModuleProperties.storeJavaPlatform(getHelper(), getEvaluator(), getActiveJavaPlatform(), false);\n            }\n            if (refreshModuleList) {\n                ModuleList.refreshModuleListForRoot(getProjectDirectoryFile());\n            }\n        } else if (isSuiteComponent() && refreshModuleList) {\n            ModuleList.refreshModuleListForRoot(getSuiteDirectory());\n        } else if (isNetBeansOrg()) {\n            if (javaPlatformChanged) {\n                ModuleProperties.storeJavaPlatform(getHelper(), getEvaluator(), getActiveJavaPlatform(), true);\n            }\n            if (refreshModuleList) {\n                ModuleList.refreshModuleListForRoot(ModuleList.findNetBeansOrg(getProjectDirectoryFile()));\n            }\n        }\n    }","cleancode":"@override void storeproperties() throws ioexception { super.storeproperties(); storemanifestchanges(); if (bundleinfo != null && bundleinfo.ismodified()) { bundleinfo.store(); } projectxmlmanager pxm = getprojectxmlmanager(); dependencylistmodel dependencymodel = getdependencieslistmodel(); if (dependencymodel.ischanged()) { set<moduledependency> depstosave = new treeset<moduledependency>(dependencymodel.getdependencies()); lognetbeansapiusage(\"dependencies\", dependencymodel.getdependencies()); try { pxm.replacedependencies(depstosave); } catch (cyclicdependencyexception ex) { throw new ioexception(ex); } } set<string> friends = getfriendlistmodel().getfriends(); set<string> publicpkgs = getpublicpackagesmodel().getselectedpackages(); boolean refreshmodulelist = false; if (getpublicpackagesmodel().ischanged() || getfriendlistmodel().ischanged()) { if (friends.size() > 0) { pxm.replacefriends(friends, publicpkgs); } else { pxm.replacepublicpackages(publicpkgs); } refreshmodulelist = true; } if (cps != null && wrappedjarslistmodel != null && wrappedjarschanged) { final list<item> cpextlist = classpathuisupport.getlist(wrappedjarslistmodel); map<string, string> newcpext = new hashmap<string, string>(); for (item item : cpextlist) { string binpath = item.getfilepath(); if (binpath != null) { fileobject fo = fileutil.tofileobject(propertyutils.resolvefile(getprojectdirectoryfile(), binpath)); if(fo != null) { string runtimepath = apisupportantutils.cpext_runtime_relative_path + fo.getnameext(); newcpext.put(runtimepath, binpath); } } } iterator<item> it = getcpextiterator(); hashset<string> jarsset = new hashset<string>(newcpext.values()); while (it.hasnext()) { item item = it.next(); if (!jarsset.contains(item.getfilepath())) { assert item.getreference() != null : \"getcpextiterator() initializes references to wrapped jars\"; item.removesourceandjavadoc(getupdatehelper()); getrefhelper().destroyreference(item.getreference()); } } cps.encodetostrings(cpextlist, cpext); pxm.replaceclasspathextensions(newcpext); wrappedjarschanged = false; } if (isstandalone()) { moduleproperties.storeplatform(gethelper(), getactiveplatform()); if (javaplatformchanged) { moduleproperties.storejavaplatform(gethelper(), getevaluator(), getactivejavaplatform(), false); } if (refreshmodulelist) { modulelist.refreshmodulelistforroot(getprojectdirectoryfile()); } } else if (issuitecomponent() && refreshmodulelist) { modulelist.refreshmodulelistforroot(getsuitedirectory()); } else if (isnetbeansorg()) { if (javaplatformchanged) { moduleproperties.storejavaplatform(gethelper(), getevaluator(), getactivejavaplatform(), true); } if (refreshmodulelist) { modulelist.refreshmodulelistforroot(modulelist.findnetbeansorg(getprojectdirectoryfile())); } } }","comment":"\/\/ store chnages in manifest\n\/\/ store localized info\n\/\/ xxx else ignore for now but we could save into some default location\n\/\/ store project.xml changes \/\/ store module dependencies\n\/\/ noi18n\n\/\/ store friends packages\n\/\/ store public packages\n\/\/ store class-path-extensions + its src & javadoc\n\/\/ delete removed jars, remove any remaining exported packages and src&javadoc refs left\n\/\/ xxx deleting here doesn't work on windows: \/\/ file f = propertyutils.resolvefile(getprojectdirectoryfile(), item.getfilepath()); \/\/ fileobject todel = fileutil.tofileobject(f); \/\/ if (todel != null) { \/\/ todel.delete(); \/\/ }","repo":"pokebadgerswithspoon\/incubator-netbeans","code_context_2":"void storeProperties() throws IOException {\nsuper.storeProperties();\n\/\/ Store chnages in manifest\nstoreManifestChanges();\n\/\/ store localized info\n\n\/\/ Store chnages in manifest\nstoreManifestChanges();\n\/\/ store localized info\nif (bundleInfo != null && bundleInfo.isModified()) {\nbundleInfo.store();\n\nif (bundleInfo != null && bundleInfo.isModified()) {\nbundleInfo.store();\n} \/\/ XXX else ignore for now but we could save into some default location\nProjectXMLManager pxm = getProjectXMLManager();\n\/\/ Store project.xml changes\n\n} \/\/ XXX else ignore for now but we could save into some default location\nProjectXMLManager pxm = getProjectXMLManager();\n\/\/ Store project.xml changes\n\/\/ store module dependencies\nDependencyListModel dependencyModel = getDependenciesListModel();\nif (dependencyModel.isChanged()) {\n\nif (dependencyModel.isChanged()) {\nSet<ModuleDependency> depsToSave = new TreeSet<ModuleDependency>(dependencyModel.getDependencies());\nlogNetBeansAPIUsage(\"DEPENDENCIES\", dependencyModel.getDependencies()); \/\/ NOI18N\ntry {\npxm.replaceDependencies(depsToSave);\n\nboolean refreshModuleList = false;\nif (getPublicPackagesModel().isChanged() || getFriendListModel().isChanged()) {\nif (friends.size() > 0) { \/\/ store friends packages\npxm.replaceFriends(friends, publicPkgs);\n} else { \/\/ store public packages\n\nif (friends.size() > 0) { \/\/ store friends packages\npxm.replaceFriends(friends, publicPkgs);\n} else { \/\/ store public packages\npxm.replacePublicPackages(publicPkgs);\n}\n\nrefreshModuleList = true;\n}\n\/\/ store class-path-extensions + its src & javadoc\nif (cps != null && wrappedJarsListModel != null && wrappedJarsChanged) {\nfinal List<Item> cpExtList = ClassPathUiSupport.getList(wrappedJarsListModel);\n\n}\n}\n\/\/ delete removed JARs, remove any remaining exported packages and src&javadoc refs left\nIterator<Item> it = getCPExtIterator();\nHashSet<String> jarsSet = new HashSet<String>(newCpExt.values());\n\nItem item = it.next();\nif (!jarsSet.contains(item.getFilePath())) {\n\/\/ XXX deleting here doesn't work on Windows:\n\/\/ File f = PropertyUtils.resolveFile(getProjectDirectoryFile(), item.getFilePath());\n\/\/ FileObject toDel = FileUtil.toFileObject(f);\n\/\/ if (toDel != null) {\n\/\/ toDel.delete();\n\/\/ }\nassert item.getReference() != null : \"getCPExtIterator() initializes references to wrapped JARs\";\nitem.removeSourceAndJavadoc(getUpdateHelper());","code_context_10":"@Override\nvoid storeProperties() throws IOException {\nsuper.storeProperties();\n\/\/ Store chnages in manifest\nstoreManifestChanges();\n\/\/ store localized info\nif (bundleInfo != null && bundleInfo.isModified()) {\nbundleInfo.store();\n} \/\/ XXX else ignore for now but we could save into some default location\nProjectXMLManager pxm = getProjectXMLManager();\n\/\/ Store project.xml changes\n\/\/ store module dependencies\nDependencyListModel dependencyModel = getDependenciesListModel();\nif (dependencyModel.isChanged()) {\n\n@Override\nvoid storeProperties() throws IOException {\nsuper.storeProperties();\n\/\/ Store chnages in manifest\nstoreManifestChanges();\n\/\/ store localized info\nif (bundleInfo != null && bundleInfo.isModified()) {\nbundleInfo.store();\n} \/\/ XXX else ignore for now but we could save into some default location\nProjectXMLManager pxm = getProjectXMLManager();\n\/\/ Store project.xml changes\n\/\/ store module dependencies\nDependencyListModel dependencyModel = getDependenciesListModel();\nif (dependencyModel.isChanged()) {\nSet<ModuleDependency> depsToSave = new TreeSet<ModuleDependency>(dependencyModel.getDependencies());\nlogNetBeansAPIUsage(\"DEPENDENCIES\", dependencyModel.getDependencies()); \/\/ NOI18N\n\n@Override\nvoid storeProperties() throws IOException {\nsuper.storeProperties();\n\/\/ Store chnages in manifest\nstoreManifestChanges();\n\/\/ store localized info\nif (bundleInfo != null && bundleInfo.isModified()) {\nbundleInfo.store();\n} \/\/ XXX else ignore for now but we could save into some default location\nProjectXMLManager pxm = getProjectXMLManager();\n\/\/ Store project.xml changes\n\/\/ store module dependencies\nDependencyListModel dependencyModel = getDependenciesListModel();\nif (dependencyModel.isChanged()) {\nSet<ModuleDependency> depsToSave = new TreeSet<ModuleDependency>(dependencyModel.getDependencies());\nlogNetBeansAPIUsage(\"DEPENDENCIES\", dependencyModel.getDependencies()); \/\/ NOI18N\ntry {\npxm.replaceDependencies(depsToSave);\n} catch (CyclicDependencyException ex) {\n\n@Override\nvoid storeProperties() throws IOException {\nsuper.storeProperties();\n\/\/ Store chnages in manifest\nstoreManifestChanges();\n\/\/ store localized info\nif (bundleInfo != null && bundleInfo.isModified()) {\nbundleInfo.store();\n} \/\/ XXX else ignore for now but we could save into some default location\nProjectXMLManager pxm = getProjectXMLManager();\n\/\/ Store project.xml changes\n\/\/ store module dependencies\nDependencyListModel dependencyModel = getDependenciesListModel();\nif (dependencyModel.isChanged()) {\nSet<ModuleDependency> depsToSave = new TreeSet<ModuleDependency>(dependencyModel.getDependencies());\nlogNetBeansAPIUsage(\"DEPENDENCIES\", dependencyModel.getDependencies()); \/\/ NOI18N\ntry {\npxm.replaceDependencies(depsToSave);\n} catch (CyclicDependencyException ex) {\nthrow new IOException(ex);\n}\n}\n\n\/\/ store localized info\nif (bundleInfo != null && bundleInfo.isModified()) {\nbundleInfo.store();\n} \/\/ XXX else ignore for now but we could save into some default location\nProjectXMLManager pxm = getProjectXMLManager();\n\/\/ Store project.xml changes\n\/\/ store module dependencies\nDependencyListModel dependencyModel = getDependenciesListModel();\nif (dependencyModel.isChanged()) {\nSet<ModuleDependency> depsToSave = new TreeSet<ModuleDependency>(dependencyModel.getDependencies());\nlogNetBeansAPIUsage(\"DEPENDENCIES\", dependencyModel.getDependencies()); \/\/ NOI18N\ntry {\npxm.replaceDependencies(depsToSave);\n} catch (CyclicDependencyException ex) {\nthrow new IOException(ex);\n}\n}\nSet<String> friends = getFriendListModel().getFriends();\nSet<String> publicPkgs = getPublicPackagesModel().getSelectedPackages();\nboolean refreshModuleList = false;\nif (getPublicPackagesModel().isChanged() || getFriendListModel().isChanged()) {\n\ntry {\npxm.replaceDependencies(depsToSave);\n} catch (CyclicDependencyException ex) {\nthrow new IOException(ex);\n}\n}\nSet<String> friends = getFriendListModel().getFriends();\nSet<String> publicPkgs = getPublicPackagesModel().getSelectedPackages();\nboolean refreshModuleList = false;\nif (getPublicPackagesModel().isChanged() || getFriendListModel().isChanged()) {\nif (friends.size() > 0) { \/\/ store friends packages\npxm.replaceFriends(friends, publicPkgs);\n} else { \/\/ store public packages\npxm.replacePublicPackages(publicPkgs);\n}\nrefreshModuleList = true;\n}\n\/\/ store class-path-extensions + its src & javadoc\nif (cps != null && wrappedJarsListModel != null && wrappedJarsChanged) {\nfinal List<Item> cpExtList = ClassPathUiSupport.getList(wrappedJarsListModel);\nMap<String, String> newCpExt = new HashMap<String, String>();\n\n} catch (CyclicDependencyException ex) {\nthrow new IOException(ex);\n}\n}\nSet<String> friends = getFriendListModel().getFriends();\nSet<String> publicPkgs = getPublicPackagesModel().getSelectedPackages();\nboolean refreshModuleList = false;\nif (getPublicPackagesModel().isChanged() || getFriendListModel().isChanged()) {\nif (friends.size() > 0) { \/\/ store friends packages\npxm.replaceFriends(friends, publicPkgs);\n} else { \/\/ store public packages\npxm.replacePublicPackages(publicPkgs);\n}\nrefreshModuleList = true;\n}\n\/\/ store class-path-extensions + its src & javadoc\nif (cps != null && wrappedJarsListModel != null && wrappedJarsChanged) {\nfinal List<Item> cpExtList = ClassPathUiSupport.getList(wrappedJarsListModel);\nMap<String, String> newCpExt = new HashMap<String, String>();\nfor (Item item : cpExtList) {\nString binPath = item.getFilePath();\n\nSet<String> publicPkgs = getPublicPackagesModel().getSelectedPackages();\nboolean refreshModuleList = false;\nif (getPublicPackagesModel().isChanged() || getFriendListModel().isChanged()) {\nif (friends.size() > 0) { \/\/ store friends packages\npxm.replaceFriends(friends, publicPkgs);\n} else { \/\/ store public packages\npxm.replacePublicPackages(publicPkgs);\n}\nrefreshModuleList = true;\n}\n\/\/ store class-path-extensions + its src & javadoc\nif (cps != null && wrappedJarsListModel != null && wrappedJarsChanged) {\nfinal List<Item> cpExtList = ClassPathUiSupport.getList(wrappedJarsListModel);\nMap<String, String> newCpExt = new HashMap<String, String>();\nfor (Item item : cpExtList) {\nString binPath = item.getFilePath();\nif (binPath != null) {\nFileObject fo = FileUtil.toFileObject(PropertyUtils.resolveFile(getProjectDirectoryFile(), binPath));\nif(fo != null)\n{\nString runtimePath = ApisupportAntUtils.CPEXT_RUNTIME_RELATIVE_PATH + fo.getNameExt();\n\nString binPath = item.getFilePath();\nif (binPath != null) {\nFileObject fo = FileUtil.toFileObject(PropertyUtils.resolveFile(getProjectDirectoryFile(), binPath));\nif(fo != null)\n{\nString runtimePath = ApisupportAntUtils.CPEXT_RUNTIME_RELATIVE_PATH + fo.getNameExt();\nnewCpExt.put(runtimePath, binPath);\n}\n}\n}\n\/\/ delete removed JARs, remove any remaining exported packages and src&javadoc refs left\nIterator<Item> it = getCPExtIterator();\nHashSet<String> jarsSet = new HashSet<String>(newCpExt.values());\nwhile (it.hasNext()) {\nItem item = it.next();\nif (!jarsSet.contains(item.getFilePath())) {\n\/\/ XXX deleting here doesn't work on Windows:\n\/\/ File f = PropertyUtils.resolveFile(getProjectDirectoryFile(), item.getFilePath());\n\/\/ FileObject toDel = FileUtil.toFileObject(f);\n\/\/ if (toDel != null) {\n\/\/ toDel.delete();\n\nnewCpExt.put(runtimePath, binPath);\n}\n}\n}\n\/\/ delete removed JARs, remove any remaining exported packages and src&javadoc refs left\nIterator<Item> it = getCPExtIterator();\nHashSet<String> jarsSet = new HashSet<String>(newCpExt.values());\nwhile (it.hasNext()) {\nItem item = it.next();\nif (!jarsSet.contains(item.getFilePath())) {\n\/\/ XXX deleting here doesn't work on Windows:\n\/\/ File f = PropertyUtils.resolveFile(getProjectDirectoryFile(), item.getFilePath());\n\/\/ FileObject toDel = FileUtil.toFileObject(f);\n\/\/ if (toDel != null) {\n\/\/ toDel.delete();\n\/\/ }\nassert item.getReference() != null : \"getCPExtIterator() initializes references to wrapped JARs\";\nitem.removeSourceAndJavadoc(getUpdateHelper());\ngetRefHelper().destroyReference(item.getReference());\n}\n}\ncps.encodeToStrings(cpExtList, CPEXT);\npxm.replaceClassPathExtensions(newCpExt);\nwrappedJarsChanged = false;\n}\nif (isStandalone()) {","code_context_20":"@Override\nvoid storeProperties() throws IOException {\nsuper.storeProperties();\n\/\/ Store chnages in manifest\nstoreManifestChanges();\n\/\/ store localized info\nif (bundleInfo != null && bundleInfo.isModified()) {\nbundleInfo.store();\n} \/\/ XXX else ignore for now but we could save into some default location\nProjectXMLManager pxm = getProjectXMLManager();\n\/\/ Store project.xml changes\n\/\/ store module dependencies\nDependencyListModel dependencyModel = getDependenciesListModel();\nif (dependencyModel.isChanged()) {\nSet<ModuleDependency> depsToSave = new TreeSet<ModuleDependency>(dependencyModel.getDependencies());\nlogNetBeansAPIUsage(\"DEPENDENCIES\", dependencyModel.getDependencies()); \/\/ NOI18N\ntry {\npxm.replaceDependencies(depsToSave);\n} catch (CyclicDependencyException ex) {\nthrow new IOException(ex);\n}\n}\nSet<String> friends = getFriendListModel().getFriends();\nSet<String> publicPkgs = getPublicPackagesModel().getSelectedPackages();\n\n@Override\nvoid storeProperties() throws IOException {\nsuper.storeProperties();\n\/\/ Store chnages in manifest\nstoreManifestChanges();\n\/\/ store localized info\nif (bundleInfo != null && bundleInfo.isModified()) {\nbundleInfo.store();\n} \/\/ XXX else ignore for now but we could save into some default location\nProjectXMLManager pxm = getProjectXMLManager();\n\/\/ Store project.xml changes\n\/\/ store module dependencies\nDependencyListModel dependencyModel = getDependenciesListModel();\nif (dependencyModel.isChanged()) {\nSet<ModuleDependency> depsToSave = new TreeSet<ModuleDependency>(dependencyModel.getDependencies());\nlogNetBeansAPIUsage(\"DEPENDENCIES\", dependencyModel.getDependencies()); \/\/ NOI18N\ntry {\npxm.replaceDependencies(depsToSave);\n} catch (CyclicDependencyException ex) {\nthrow new IOException(ex);\n}\n}\nSet<String> friends = getFriendListModel().getFriends();\nSet<String> publicPkgs = getPublicPackagesModel().getSelectedPackages();\nboolean refreshModuleList = false;\nif (getPublicPackagesModel().isChanged() || getFriendListModel().isChanged()) {\n\n@Override\nvoid storeProperties() throws IOException {\nsuper.storeProperties();\n\/\/ Store chnages in manifest\nstoreManifestChanges();\n\/\/ store localized info\nif (bundleInfo != null && bundleInfo.isModified()) {\nbundleInfo.store();\n} \/\/ XXX else ignore for now but we could save into some default location\nProjectXMLManager pxm = getProjectXMLManager();\n\/\/ Store project.xml changes\n\/\/ store module dependencies\nDependencyListModel dependencyModel = getDependenciesListModel();\nif (dependencyModel.isChanged()) {\nSet<ModuleDependency> depsToSave = new TreeSet<ModuleDependency>(dependencyModel.getDependencies());\nlogNetBeansAPIUsage(\"DEPENDENCIES\", dependencyModel.getDependencies()); \/\/ NOI18N\ntry {\npxm.replaceDependencies(depsToSave);\n} catch (CyclicDependencyException ex) {\nthrow new IOException(ex);\n}\n}\nSet<String> friends = getFriendListModel().getFriends();\nSet<String> publicPkgs = getPublicPackagesModel().getSelectedPackages();\nboolean refreshModuleList = false;\nif (getPublicPackagesModel().isChanged() || getFriendListModel().isChanged()) {\nif (friends.size() > 0) { \/\/ store friends packages\npxm.replaceFriends(friends, publicPkgs);\n} else { \/\/ store public packages\n\n@Override\nvoid storeProperties() throws IOException {\nsuper.storeProperties();\n\/\/ Store chnages in manifest\nstoreManifestChanges();\n\/\/ store localized info\nif (bundleInfo != null && bundleInfo.isModified()) {\nbundleInfo.store();\n} \/\/ XXX else ignore for now but we could save into some default location\nProjectXMLManager pxm = getProjectXMLManager();\n\/\/ Store project.xml changes\n\/\/ store module dependencies\nDependencyListModel dependencyModel = getDependenciesListModel();\nif (dependencyModel.isChanged()) {\nSet<ModuleDependency> depsToSave = new TreeSet<ModuleDependency>(dependencyModel.getDependencies());\nlogNetBeansAPIUsage(\"DEPENDENCIES\", dependencyModel.getDependencies()); \/\/ NOI18N\ntry {\npxm.replaceDependencies(depsToSave);\n} catch (CyclicDependencyException ex) {\nthrow new IOException(ex);\n}\n}\nSet<String> friends = getFriendListModel().getFriends();\nSet<String> publicPkgs = getPublicPackagesModel().getSelectedPackages();\nboolean refreshModuleList = false;\nif (getPublicPackagesModel().isChanged() || getFriendListModel().isChanged()) {\nif (friends.size() > 0) { \/\/ store friends packages\npxm.replaceFriends(friends, publicPkgs);\n} else { \/\/ store public packages\npxm.replacePublicPackages(publicPkgs);\n}\nrefreshModuleList = true;\n\n@Override\nvoid storeProperties() throws IOException {\nsuper.storeProperties();\n\/\/ Store chnages in manifest\nstoreManifestChanges();\n\/\/ store localized info\nif (bundleInfo != null && bundleInfo.isModified()) {\nbundleInfo.store();\n} \/\/ XXX else ignore for now but we could save into some default location\nProjectXMLManager pxm = getProjectXMLManager();\n\/\/ Store project.xml changes\n\/\/ store module dependencies\nDependencyListModel dependencyModel = getDependenciesListModel();\nif (dependencyModel.isChanged()) {\nSet<ModuleDependency> depsToSave = new TreeSet<ModuleDependency>(dependencyModel.getDependencies());\nlogNetBeansAPIUsage(\"DEPENDENCIES\", dependencyModel.getDependencies()); \/\/ NOI18N\ntry {\npxm.replaceDependencies(depsToSave);\n} catch (CyclicDependencyException ex) {\nthrow new IOException(ex);\n}\n}\nSet<String> friends = getFriendListModel().getFriends();\nSet<String> publicPkgs = getPublicPackagesModel().getSelectedPackages();\nboolean refreshModuleList = false;\nif (getPublicPackagesModel().isChanged() || getFriendListModel().isChanged()) {\nif (friends.size() > 0) { \/\/ store friends packages\npxm.replaceFriends(friends, publicPkgs);\n} else { \/\/ store public packages\npxm.replacePublicPackages(publicPkgs);\n}\nrefreshModuleList = true;\n}\n\/\/ store class-path-extensions + its src & javadoc\nif (cps != null && wrappedJarsListModel != null && wrappedJarsChanged) {\nfinal List<Item> cpExtList = ClassPathUiSupport.getList(wrappedJarsListModel);\n\nif (bundleInfo != null && bundleInfo.isModified()) {\nbundleInfo.store();\n} \/\/ XXX else ignore for now but we could save into some default location\nProjectXMLManager pxm = getProjectXMLManager();\n\/\/ Store project.xml changes\n\/\/ store module dependencies\nDependencyListModel dependencyModel = getDependenciesListModel();\nif (dependencyModel.isChanged()) {\nSet<ModuleDependency> depsToSave = new TreeSet<ModuleDependency>(dependencyModel.getDependencies());\nlogNetBeansAPIUsage(\"DEPENDENCIES\", dependencyModel.getDependencies()); \/\/ NOI18N\ntry {\npxm.replaceDependencies(depsToSave);\n} catch (CyclicDependencyException ex) {\nthrow new IOException(ex);\n}\n}\nSet<String> friends = getFriendListModel().getFriends();\nSet<String> publicPkgs = getPublicPackagesModel().getSelectedPackages();\nboolean refreshModuleList = false;\nif (getPublicPackagesModel().isChanged() || getFriendListModel().isChanged()) {\nif (friends.size() > 0) { \/\/ store friends packages\npxm.replaceFriends(friends, publicPkgs);\n} else { \/\/ store public packages\npxm.replacePublicPackages(publicPkgs);\n}\nrefreshModuleList = true;\n}\n\/\/ store class-path-extensions + its src & javadoc\nif (cps != null && wrappedJarsListModel != null && wrappedJarsChanged) {\nfinal List<Item> cpExtList = ClassPathUiSupport.getList(wrappedJarsListModel);\nMap<String, String> newCpExt = new HashMap<String, String>();\nfor (Item item : cpExtList) {\nString binPath = item.getFilePath();\nif (binPath != null) {\nFileObject fo = FileUtil.toFileObject(PropertyUtils.resolveFile(getProjectDirectoryFile(), binPath));\nif(fo != null)\n{\nString runtimePath = ApisupportAntUtils.CPEXT_RUNTIME_RELATIVE_PATH + fo.getNameExt();\nnewCpExt.put(runtimePath, binPath);\n}\n}\n\n} \/\/ XXX else ignore for now but we could save into some default location\nProjectXMLManager pxm = getProjectXMLManager();\n\/\/ Store project.xml changes\n\/\/ store module dependencies\nDependencyListModel dependencyModel = getDependenciesListModel();\nif (dependencyModel.isChanged()) {\nSet<ModuleDependency> depsToSave = new TreeSet<ModuleDependency>(dependencyModel.getDependencies());\nlogNetBeansAPIUsage(\"DEPENDENCIES\", dependencyModel.getDependencies()); \/\/ NOI18N\ntry {\npxm.replaceDependencies(depsToSave);\n} catch (CyclicDependencyException ex) {\nthrow new IOException(ex);\n}\n}\nSet<String> friends = getFriendListModel().getFriends();\nSet<String> publicPkgs = getPublicPackagesModel().getSelectedPackages();\nboolean refreshModuleList = false;\nif (getPublicPackagesModel().isChanged() || getFriendListModel().isChanged()) {\nif (friends.size() > 0) { \/\/ store friends packages\npxm.replaceFriends(friends, publicPkgs);\n} else { \/\/ store public packages\npxm.replacePublicPackages(publicPkgs);\n}\nrefreshModuleList = true;\n}\n\/\/ store class-path-extensions + its src & javadoc\nif (cps != null && wrappedJarsListModel != null && wrappedJarsChanged) {\nfinal List<Item> cpExtList = ClassPathUiSupport.getList(wrappedJarsListModel);\nMap<String, String> newCpExt = new HashMap<String, String>();\nfor (Item item : cpExtList) {\nString binPath = item.getFilePath();\nif (binPath != null) {\nFileObject fo = FileUtil.toFileObject(PropertyUtils.resolveFile(getProjectDirectoryFile(), binPath));\nif(fo != null)\n{\nString runtimePath = ApisupportAntUtils.CPEXT_RUNTIME_RELATIVE_PATH + fo.getNameExt();\nnewCpExt.put(runtimePath, binPath);\n}\n}\n}\n\/\/ delete removed JARs, remove any remaining exported packages and src&javadoc refs left\n\nif (dependencyModel.isChanged()) {\nSet<ModuleDependency> depsToSave = new TreeSet<ModuleDependency>(dependencyModel.getDependencies());\nlogNetBeansAPIUsage(\"DEPENDENCIES\", dependencyModel.getDependencies()); \/\/ NOI18N\ntry {\npxm.replaceDependencies(depsToSave);\n} catch (CyclicDependencyException ex) {\nthrow new IOException(ex);\n}\n}\nSet<String> friends = getFriendListModel().getFriends();\nSet<String> publicPkgs = getPublicPackagesModel().getSelectedPackages();\nboolean refreshModuleList = false;\nif (getPublicPackagesModel().isChanged() || getFriendListModel().isChanged()) {\nif (friends.size() > 0) { \/\/ store friends packages\npxm.replaceFriends(friends, publicPkgs);\n} else { \/\/ store public packages\npxm.replacePublicPackages(publicPkgs);\n}\nrefreshModuleList = true;\n}\n\/\/ store class-path-extensions + its src & javadoc\nif (cps != null && wrappedJarsListModel != null && wrappedJarsChanged) {\nfinal List<Item> cpExtList = ClassPathUiSupport.getList(wrappedJarsListModel);\nMap<String, String> newCpExt = new HashMap<String, String>();\nfor (Item item : cpExtList) {\nString binPath = item.getFilePath();\nif (binPath != null) {\nFileObject fo = FileUtil.toFileObject(PropertyUtils.resolveFile(getProjectDirectoryFile(), binPath));\nif(fo != null)\n{\nString runtimePath = ApisupportAntUtils.CPEXT_RUNTIME_RELATIVE_PATH + fo.getNameExt();\nnewCpExt.put(runtimePath, binPath);\n}\n}\n}\n\/\/ delete removed JARs, remove any remaining exported packages and src&javadoc refs left\nIterator<Item> it = getCPExtIterator();\nHashSet<String> jarsSet = new HashSet<String>(newCpExt.values());\nwhile (it.hasNext()) {\nItem item = it.next();\nif (!jarsSet.contains(item.getFilePath())) {\n\n} else { \/\/ store public packages\npxm.replacePublicPackages(publicPkgs);\n}\nrefreshModuleList = true;\n}\n\/\/ store class-path-extensions + its src & javadoc\nif (cps != null && wrappedJarsListModel != null && wrappedJarsChanged) {\nfinal List<Item> cpExtList = ClassPathUiSupport.getList(wrappedJarsListModel);\nMap<String, String> newCpExt = new HashMap<String, String>();\nfor (Item item : cpExtList) {\nString binPath = item.getFilePath();\nif (binPath != null) {\nFileObject fo = FileUtil.toFileObject(PropertyUtils.resolveFile(getProjectDirectoryFile(), binPath));\nif(fo != null)\n{\nString runtimePath = ApisupportAntUtils.CPEXT_RUNTIME_RELATIVE_PATH + fo.getNameExt();\nnewCpExt.put(runtimePath, binPath);\n}\n}\n}\n\/\/ delete removed JARs, remove any remaining exported packages and src&javadoc refs left\nIterator<Item> it = getCPExtIterator();\nHashSet<String> jarsSet = new HashSet<String>(newCpExt.values());\nwhile (it.hasNext()) {\nItem item = it.next();\nif (!jarsSet.contains(item.getFilePath())) {\n\/\/ XXX deleting here doesn't work on Windows:\n\/\/ File f = PropertyUtils.resolveFile(getProjectDirectoryFile(), item.getFilePath());\n\/\/ FileObject toDel = FileUtil.toFileObject(f);\n\/\/ if (toDel != null) {\n\/\/ toDel.delete();\n\/\/ }\nassert item.getReference() != null : \"getCPExtIterator() initializes references to wrapped JARs\";\nitem.removeSourceAndJavadoc(getUpdateHelper());\ngetRefHelper().destroyReference(item.getReference());\n}\n}\ncps.encodeToStrings(cpExtList, CPEXT);\npxm.replaceClassPathExtensions(newCpExt);\nwrappedJarsChanged = false;\n}\n\nif (cps != null && wrappedJarsListModel != null && wrappedJarsChanged) {\nfinal List<Item> cpExtList = ClassPathUiSupport.getList(wrappedJarsListModel);\nMap<String, String> newCpExt = new HashMap<String, String>();\nfor (Item item : cpExtList) {\nString binPath = item.getFilePath();\nif (binPath != null) {\nFileObject fo = FileUtil.toFileObject(PropertyUtils.resolveFile(getProjectDirectoryFile(), binPath));\nif(fo != null)\n{\nString runtimePath = ApisupportAntUtils.CPEXT_RUNTIME_RELATIVE_PATH + fo.getNameExt();\nnewCpExt.put(runtimePath, binPath);\n}\n}\n}\n\/\/ delete removed JARs, remove any remaining exported packages and src&javadoc refs left\nIterator<Item> it = getCPExtIterator();\nHashSet<String> jarsSet = new HashSet<String>(newCpExt.values());\nwhile (it.hasNext()) {\nItem item = it.next();\nif (!jarsSet.contains(item.getFilePath())) {\n\/\/ XXX deleting here doesn't work on Windows:\n\/\/ File f = PropertyUtils.resolveFile(getProjectDirectoryFile(), item.getFilePath());\n\/\/ FileObject toDel = FileUtil.toFileObject(f);\n\/\/ if (toDel != null) {\n\/\/ toDel.delete();\n\/\/ }\nassert item.getReference() != null : \"getCPExtIterator() initializes references to wrapped JARs\";\nitem.removeSourceAndJavadoc(getUpdateHelper());\ngetRefHelper().destroyReference(item.getReference());\n}\n}\ncps.encodeToStrings(cpExtList, CPEXT);\npxm.replaceClassPathExtensions(newCpExt);\nwrappedJarsChanged = false;\n}\nif (isStandalone()) {\nModuleProperties.storePlatform(getHelper(), getActivePlatform());\nif (javaPlatformChanged) {\nModuleProperties.storeJavaPlatform(getHelper(), getEvaluator(), getActiveJavaPlatform(), false);\n}\nif (refreshModuleList) {\nModuleList.refreshModuleListForRoot(getProjectDirectoryFile());\n}\n} else if (isSuiteComponent() && refreshModuleList) {\nModuleList.refreshModuleListForRoot(getSuiteDirectory());\n} else if (isNetBeansOrg()) {","label":[1,0,1,0]}
{"id":17373,"original_code":"public void deleteByUserId(int userId) {\n        try {\n            DeleteBuilder<UserRequest, Long> deleteBuilder = dao.deleteBuilder();\n            deleteBuilder.where().eq(QMUserColumns.ID, userId);\n            if (deleteBuilder.delete() > 0) {\n                \/\/TODO VT need to think how to send ID to observers\n                notifyObserversDeletedById(userId);\n            }\n        } catch (SQLException e) {\n            ErrorUtils.logError(e);\n        }\n    }","code":"public void deleteByUserId(int userId) {\n        try {\n            DeleteBuilder<UserRequest, Long> deleteBuilder = dao.deleteBuilder();\n            deleteBuilder.where().eq(QMUserColumns.ID, userId);\n            if (deleteBuilder.delete() > 0) {\n               \n                notifyObserversDeletedById(userId);\n            }\n        } catch (SQLException e) {\n            ErrorUtils.logError(e);\n        }\n    }","cleancode":"public void deletebyuserid(int userid) { try { deletebuilder<userrequest, long> deletebuilder = dao.deletebuilder(); deletebuilder.where().eq(qmusercolumns.id, userid); if (deletebuilder.delete() > 0) { notifyobserversdeletedbyid(userid); } } catch (sqlexception e) { errorutils.logerror(e); } }","comment":"\/\/todo vt need to think how to send id to observers","repo":"philz127\/CAPSTONE","code_context_2":"deleteBuilder.where().eq(QMUserColumns.ID, userId);\nif (deleteBuilder.delete() > 0) {\n\/\/TODO VT need to think how to send ID to observers\nnotifyObserversDeletedById(userId);\n}","code_context_10":"public void deleteByUserId(int userId) {\ntry {\nDeleteBuilder<UserRequest, Long> deleteBuilder = dao.deleteBuilder();\ndeleteBuilder.where().eq(QMUserColumns.ID, userId);\nif (deleteBuilder.delete() > 0) {\n\/\/TODO VT need to think how to send ID to observers\nnotifyObserversDeletedById(userId);\n}\n} catch (SQLException e) {\nErrorUtils.logError(e);\n}\n}","code_context_20":"public void deleteByUserId(int userId) {\ntry {\nDeleteBuilder<UserRequest, Long> deleteBuilder = dao.deleteBuilder();\ndeleteBuilder.where().eq(QMUserColumns.ID, userId);\nif (deleteBuilder.delete() > 0) {\n\/\/TODO VT need to think how to send ID to observers\nnotifyObserversDeletedById(userId);\n}\n} catch (SQLException e) {\nErrorUtils.logError(e);\n}\n}","label":[1,0,0,0]}
{"id":25568,"original_code":"@Deprecated\n  public boolean isValidShortNumberForRegion(String shortNumber, String regionDialingFrom) {\n    PhoneMetadata phoneMetadata =\n        MetadataManager.getShortNumberMetadataForRegion(regionDialingFrom);\n    if (phoneMetadata == null) {\n      return false;\n    }\n    PhoneNumberDesc generalDesc = phoneMetadata.getGeneralDesc();\n    if (!matchesPossibleNumberAndNationalNumber(shortNumber, generalDesc)) {\n      return false;\n    }\n    PhoneNumberDesc shortNumberDesc = phoneMetadata.getShortCode();\n    return matchesPossibleNumberAndNationalNumber(shortNumber, shortNumberDesc);\n  }","code":"@Deprecated\n  public boolean isValidShortNumberForRegion(String shortNumber, String regionDialingFrom) {\n    PhoneMetadata phoneMetadata =\n        MetadataManager.getShortNumberMetadataForRegion(regionDialingFrom);\n    if (phoneMetadata == null) {\n      return false;\n    }\n    PhoneNumberDesc generalDesc = phoneMetadata.getGeneralDesc();\n    if (!matchesPossibleNumberAndNationalNumber(shortNumber, generalDesc)) {\n      return false;\n    }\n    PhoneNumberDesc shortNumberDesc = phoneMetadata.getShortCode();\n    return matchesPossibleNumberAndNationalNumber(shortNumber, shortNumberDesc);\n  }","cleancode":"@deprecated public boolean isvalidshortnumberforregion(string shortnumber, string regiondialingfrom) { phonemetadata phonemetadata = metadatamanager.getshortnumbermetadataforregion(regiondialingfrom); if (phonemetadata == null) { return false; } phonenumberdesc generaldesc = phonemetadata.getgeneraldesc(); if (!matchespossiblenumberandnationalnumber(shortnumber, generaldesc)) { return false; } phonenumberdesc shortnumberdesc = phonemetadata.getshortcode(); return matchespossiblenumberandnationalnumber(shortnumber, shortnumberdesc); }","comment":"\/** * tests whether a short number matches a valid pattern in a region. note that this doesn't verify * the number is actually in use, which is impossible to tell by just looking at the number * itself. * * @param shortnumber the short number to check as a string * @param regiondialingfrom the region from which the number is dialed * @return whether the short number matches a valid pattern * @deprecated anyone who was using it and passing in a string with whitespace (or other * formatting characters) would have been getting the wrong result. you should parse * the string to phonenumber and use the method * {@code #isvalidshortnumberforregion(phonenumber, string)}. this method will be * removed in the next release. *\/","repo":"nickbarban\/libphonenumber","code_context_2":"@Deprecated\npublic boolean isValidShortNumberForRegion(String shortNumber, String regionDialingFrom) {\nPhoneMetadata phoneMetadata =\nMetadataManager.getShortNumberMetadataForRegion(regionDialingFrom);\nif (phoneMetadata == null) {\nreturn false;\n}\nPhoneNumberDesc generalDesc = phoneMetadata.getGeneralDesc();\nif (!matchesPossibleNumberAndNationalNumber(shortNumber, generalDesc)) {\nreturn false;\n}\nPhoneNumberDesc shortNumberDesc = phoneMetadata.getShortCode();\nreturn matchesPossibleNumberAndNationalNumber(shortNumber, shortNumberDesc);\n}","code_context_10":"@Deprecated\npublic boolean isValidShortNumberForRegion(String shortNumber, String regionDialingFrom) {\nPhoneMetadata phoneMetadata =\nMetadataManager.getShortNumberMetadataForRegion(regionDialingFrom);\nif (phoneMetadata == null) {\nreturn false;\n}\nPhoneNumberDesc generalDesc = phoneMetadata.getGeneralDesc();\nif (!matchesPossibleNumberAndNationalNumber(shortNumber, generalDesc)) {\nreturn false;\n}\nPhoneNumberDesc shortNumberDesc = phoneMetadata.getShortCode();\nreturn matchesPossibleNumberAndNationalNumber(shortNumber, shortNumberDesc);\n}","code_context_20":"@Deprecated\npublic boolean isValidShortNumberForRegion(String shortNumber, String regionDialingFrom) {\nPhoneMetadata phoneMetadata =\nMetadataManager.getShortNumberMetadataForRegion(regionDialingFrom);\nif (phoneMetadata == null) {\nreturn false;\n}\nPhoneNumberDesc generalDesc = phoneMetadata.getGeneralDesc();\nif (!matchesPossibleNumberAndNationalNumber(shortNumber, generalDesc)) {\nreturn false;\n}\nPhoneNumberDesc shortNumberDesc = phoneMetadata.getShortCode();\nreturn matchesPossibleNumberAndNationalNumber(shortNumber, shortNumberDesc);\n}","label":[0,0,0,0]}
{"id":33777,"original_code":"private List<AnnotatedAttributeValuePair> getAttributeValuePairs(JsonOutcome outcome, JsonReference reference) {\n        Optional<String> docNameTrue = getFirstDocname(reference);\n        String docName = docNameTrue.orElse(outcome.getShortTitle());\n        \/\/ we use the highlighted text to put the table caption\n        String highlightedText = outcome.getOutcomeDescription();\n        Arm arm1 = getAssignedArm(outcome.getItemArmIdGrp1(), outcome.getGrp1ArmName());\n        Arm arm2 = getAssignedArm(outcome.getItemArmIdGrp2(), outcome.getGrp2ArmName());\n        \/\/ outcome values\n        Attribute ovAttribute = attributes.getFromName(\"Outcome value\");\n        AnnotatedAttributeValuePair ov1 = new AnnotatedAttributeValuePair(ovAttribute, outcome.getData3(),\n                docName, arm1, \"\", highlightedText, \"\", 0);\n        AnnotatedAttributeValuePair ov2 = new AnnotatedAttributeValuePair(ovAttribute, outcome.getData4(),\n                docName, arm2, \"\", highlightedText, \"\", 0);\n        \/\/ timepoints\n        Attribute timepointAttribute = attributes.getFromName(\"Longest follow up\");\n        AnnotatedAttributeValuePair tp1 = new AnnotatedAttributeValuePair(timepointAttribute, outcome.getTimepointString(),\n                docName, arm1, \"\", highlightedText, \"\", 0);\n        AnnotatedAttributeValuePair tp2 = new AnnotatedAttributeValuePair(timepointAttribute, outcome.getTimepointString(),\n                docName, arm2, \"\", highlightedText, \"\", 0);\n        \/\/ timepoint units\n        Attribute timepointUnitAttribute = attributes.getFromName(\"Longest follow up (metric)\");\n        AnnotatedAttributeValuePair tpUnit1 = new AnnotatedAttributeValuePair(timepointUnitAttribute, outcome.getItemTimepointMetric(),\n                docName, arm1, \"\", highlightedText, \"\", 0);\n        AnnotatedAttributeValuePair tpUnit2 = new AnnotatedAttributeValuePair(timepointUnitAttribute, outcome.getItemTimepointMetric(),\n                docName, arm2, \"\", highlightedText, \"\", 0);\n        \/\/ sample size\n        Attribute samplesizeAttribute = attributes.getFromName(\"Individual-level analysed\");\n        AnnotatedAttributeValuePair ss1 = new AnnotatedAttributeValuePair(samplesizeAttribute, outcome.getData1(),\n                docName, arm1, \"\", highlightedText, \"\", 0);\n        AnnotatedAttributeValuePair ss2 = new AnnotatedAttributeValuePair(samplesizeAttribute, outcome.getData2(),\n                docName, arm2, \"\", highlightedText, \"\", 0);\n        \/\/ TODO: anything else?\n        return Lists.newArrayList(ov1, ov2, tp1, tp2, tpUnit1, tpUnit2, ss1, ss2);\n    }","code":"private List<AnnotatedAttributeValuePair> getAttributeValuePairs(JsonOutcome outcome, JsonReference reference) {\n        Optional<String> docNameTrue = getFirstDocname(reference);\n        String docName = docNameTrue.orElse(outcome.getShortTitle());\n       \n        String highlightedText = outcome.getOutcomeDescription();\n        Arm arm1 = getAssignedArm(outcome.getItemArmIdGrp1(), outcome.getGrp1ArmName());\n        Arm arm2 = getAssignedArm(outcome.getItemArmIdGrp2(), outcome.getGrp2ArmName());\n       \n        Attribute ovAttribute = attributes.getFromName(\"Outcome value\");\n        AnnotatedAttributeValuePair ov1 = new AnnotatedAttributeValuePair(ovAttribute, outcome.getData3(),\n                docName, arm1, \"\", highlightedText, \"\", 0);\n        AnnotatedAttributeValuePair ov2 = new AnnotatedAttributeValuePair(ovAttribute, outcome.getData4(),\n                docName, arm2, \"\", highlightedText, \"\", 0);\n       \n        Attribute timepointAttribute = attributes.getFromName(\"Longest follow up\");\n        AnnotatedAttributeValuePair tp1 = new AnnotatedAttributeValuePair(timepointAttribute, outcome.getTimepointString(),\n                docName, arm1, \"\", highlightedText, \"\", 0);\n        AnnotatedAttributeValuePair tp2 = new AnnotatedAttributeValuePair(timepointAttribute, outcome.getTimepointString(),\n                docName, arm2, \"\", highlightedText, \"\", 0);\n       \n        Attribute timepointUnitAttribute = attributes.getFromName(\"Longest follow up (metric)\");\n        AnnotatedAttributeValuePair tpUnit1 = new AnnotatedAttributeValuePair(timepointUnitAttribute, outcome.getItemTimepointMetric(),\n                docName, arm1, \"\", highlightedText, \"\", 0);\n        AnnotatedAttributeValuePair tpUnit2 = new AnnotatedAttributeValuePair(timepointUnitAttribute, outcome.getItemTimepointMetric(),\n                docName, arm2, \"\", highlightedText, \"\", 0);\n       \n        Attribute samplesizeAttribute = attributes.getFromName(\"Individual-level analysed\");\n        AnnotatedAttributeValuePair ss1 = new AnnotatedAttributeValuePair(samplesizeAttribute, outcome.getData1(),\n                docName, arm1, \"\", highlightedText, \"\", 0);\n        AnnotatedAttributeValuePair ss2 = new AnnotatedAttributeValuePair(samplesizeAttribute, outcome.getData2(),\n                docName, arm2, \"\", highlightedText, \"\", 0);\n       \n        return Lists.newArrayList(ov1, ov2, tp1, tp2, tpUnit1, tpUnit2, ss1, ss2);\n    }","cleancode":"private list<annotatedattributevaluepair> getattributevaluepairs(jsonoutcome outcome, jsonreference reference) { optional<string> docnametrue = getfirstdocname(reference); string docname = docnametrue.orelse(outcome.getshorttitle()); string highlightedtext = outcome.getoutcomedescription(); arm arm1 = getassignedarm(outcome.getitemarmidgrp1(), outcome.getgrp1armname()); arm arm2 = getassignedarm(outcome.getitemarmidgrp2(), outcome.getgrp2armname()); attribute ovattribute = attributes.getfromname(\"outcome value\"); annotatedattributevaluepair ov1 = new annotatedattributevaluepair(ovattribute, outcome.getdata3(), docname, arm1, \"\", highlightedtext, \"\", 0); annotatedattributevaluepair ov2 = new annotatedattributevaluepair(ovattribute, outcome.getdata4(), docname, arm2, \"\", highlightedtext, \"\", 0); attribute timepointattribute = attributes.getfromname(\"longest follow up\"); annotatedattributevaluepair tp1 = new annotatedattributevaluepair(timepointattribute, outcome.gettimepointstring(), docname, arm1, \"\", highlightedtext, \"\", 0); annotatedattributevaluepair tp2 = new annotatedattributevaluepair(timepointattribute, outcome.gettimepointstring(), docname, arm2, \"\", highlightedtext, \"\", 0); attribute timepointunitattribute = attributes.getfromname(\"longest follow up (metric)\"); annotatedattributevaluepair tpunit1 = new annotatedattributevaluepair(timepointunitattribute, outcome.getitemtimepointmetric(), docname, arm1, \"\", highlightedtext, \"\", 0); annotatedattributevaluepair tpunit2 = new annotatedattributevaluepair(timepointunitattribute, outcome.getitemtimepointmetric(), docname, arm2, \"\", highlightedtext, \"\", 0); attribute samplesizeattribute = attributes.getfromname(\"individual-level analysed\"); annotatedattributevaluepair ss1 = new annotatedattributevaluepair(samplesizeattribute, outcome.getdata1(), docname, arm1, \"\", highlightedtext, \"\", 0); annotatedattributevaluepair ss2 = new annotatedattributevaluepair(samplesizeattribute, outcome.getdata2(), docname, arm2, \"\", highlightedtext, \"\", 0); return lists.newarraylist(ov1, ov2, tp1, tp2, tpunit1, tpunit2, ss1, ss2); }","comment":"\/\/ we use the highlighted text to put the table caption\n\/\/ outcome values\n\/\/ timepoints\n\/\/ timepoint units\n\/\/ sample size\n\/\/ todo: anything else?","repo":"ouyangzhiping\/Info-extract","code_context_2":"Optional<String> docNameTrue = getFirstDocname(reference);\nString docName = docNameTrue.orElse(outcome.getShortTitle());\n\/\/ we use the highlighted text to put the table caption\nString highlightedText = outcome.getOutcomeDescription();\nArm arm1 = getAssignedArm(outcome.getItemArmIdGrp1(), outcome.getGrp1ArmName());\n\nArm arm1 = getAssignedArm(outcome.getItemArmIdGrp1(), outcome.getGrp1ArmName());\nArm arm2 = getAssignedArm(outcome.getItemArmIdGrp2(), outcome.getGrp2ArmName());\n\/\/ outcome values\nAttribute ovAttribute = attributes.getFromName(\"Outcome value\");\nAnnotatedAttributeValuePair ov1 = new AnnotatedAttributeValuePair(ovAttribute, outcome.getData3(),\n\nAnnotatedAttributeValuePair ov2 = new AnnotatedAttributeValuePair(ovAttribute, outcome.getData4(),\ndocName, arm2, \"\", highlightedText, \"\", 0);\n\/\/ timepoints\nAttribute timepointAttribute = attributes.getFromName(\"Longest follow up\");\nAnnotatedAttributeValuePair tp1 = new AnnotatedAttributeValuePair(timepointAttribute, outcome.getTimepointString(),\n\nAnnotatedAttributeValuePair tp2 = new AnnotatedAttributeValuePair(timepointAttribute, outcome.getTimepointString(),\ndocName, arm2, \"\", highlightedText, \"\", 0);\n\/\/ timepoint units\nAttribute timepointUnitAttribute = attributes.getFromName(\"Longest follow up (metric)\");\nAnnotatedAttributeValuePair tpUnit1 = new AnnotatedAttributeValuePair(timepointUnitAttribute, outcome.getItemTimepointMetric(),\n\nAnnotatedAttributeValuePair tpUnit2 = new AnnotatedAttributeValuePair(timepointUnitAttribute, outcome.getItemTimepointMetric(),\ndocName, arm2, \"\", highlightedText, \"\", 0);\n\/\/ sample size\nAttribute samplesizeAttribute = attributes.getFromName(\"Individual-level analysed\");\nAnnotatedAttributeValuePair ss1 = new AnnotatedAttributeValuePair(samplesizeAttribute, outcome.getData1(),\n\nAnnotatedAttributeValuePair ss2 = new AnnotatedAttributeValuePair(samplesizeAttribute, outcome.getData2(),\ndocName, arm2, \"\", highlightedText, \"\", 0);\n\/\/ TODO: anything else?\nreturn Lists.newArrayList(ov1, ov2, tp1, tp2, tpUnit1, tpUnit2, ss1, ss2);\n}","code_context_10":"private List<AnnotatedAttributeValuePair> getAttributeValuePairs(JsonOutcome outcome, JsonReference reference) {\nOptional<String> docNameTrue = getFirstDocname(reference);\nString docName = docNameTrue.orElse(outcome.getShortTitle());\n\/\/ we use the highlighted text to put the table caption\nString highlightedText = outcome.getOutcomeDescription();\nArm arm1 = getAssignedArm(outcome.getItemArmIdGrp1(), outcome.getGrp1ArmName());\nArm arm2 = getAssignedArm(outcome.getItemArmIdGrp2(), outcome.getGrp2ArmName());\n\/\/ outcome values\nAttribute ovAttribute = attributes.getFromName(\"Outcome value\");\nAnnotatedAttributeValuePair ov1 = new AnnotatedAttributeValuePair(ovAttribute, outcome.getData3(),\ndocName, arm1, \"\", highlightedText, \"\", 0);\nAnnotatedAttributeValuePair ov2 = new AnnotatedAttributeValuePair(ovAttribute, outcome.getData4(),\ndocName, arm2, \"\", highlightedText, \"\", 0);\n\/\/ timepoints\n\nprivate List<AnnotatedAttributeValuePair> getAttributeValuePairs(JsonOutcome outcome, JsonReference reference) {\nOptional<String> docNameTrue = getFirstDocname(reference);\nString docName = docNameTrue.orElse(outcome.getShortTitle());\n\/\/ we use the highlighted text to put the table caption\nString highlightedText = outcome.getOutcomeDescription();\nArm arm1 = getAssignedArm(outcome.getItemArmIdGrp1(), outcome.getGrp1ArmName());\nArm arm2 = getAssignedArm(outcome.getItemArmIdGrp2(), outcome.getGrp2ArmName());\n\/\/ outcome values\nAttribute ovAttribute = attributes.getFromName(\"Outcome value\");\nAnnotatedAttributeValuePair ov1 = new AnnotatedAttributeValuePair(ovAttribute, outcome.getData3(),\ndocName, arm1, \"\", highlightedText, \"\", 0);\nAnnotatedAttributeValuePair ov2 = new AnnotatedAttributeValuePair(ovAttribute, outcome.getData4(),\ndocName, arm2, \"\", highlightedText, \"\", 0);\n\/\/ timepoints\nAttribute timepointAttribute = attributes.getFromName(\"Longest follow up\");\nAnnotatedAttributeValuePair tp1 = new AnnotatedAttributeValuePair(timepointAttribute, outcome.getTimepointString(),\ndocName, arm1, \"\", highlightedText, \"\", 0);\nAnnotatedAttributeValuePair tp2 = new AnnotatedAttributeValuePair(timepointAttribute, outcome.getTimepointString(),\n\n\/\/ we use the highlighted text to put the table caption\nString highlightedText = outcome.getOutcomeDescription();\nArm arm1 = getAssignedArm(outcome.getItemArmIdGrp1(), outcome.getGrp1ArmName());\nArm arm2 = getAssignedArm(outcome.getItemArmIdGrp2(), outcome.getGrp2ArmName());\n\/\/ outcome values\nAttribute ovAttribute = attributes.getFromName(\"Outcome value\");\nAnnotatedAttributeValuePair ov1 = new AnnotatedAttributeValuePair(ovAttribute, outcome.getData3(),\ndocName, arm1, \"\", highlightedText, \"\", 0);\nAnnotatedAttributeValuePair ov2 = new AnnotatedAttributeValuePair(ovAttribute, outcome.getData4(),\ndocName, arm2, \"\", highlightedText, \"\", 0);\n\/\/ timepoints\nAttribute timepointAttribute = attributes.getFromName(\"Longest follow up\");\nAnnotatedAttributeValuePair tp1 = new AnnotatedAttributeValuePair(timepointAttribute, outcome.getTimepointString(),\ndocName, arm1, \"\", highlightedText, \"\", 0);\nAnnotatedAttributeValuePair tp2 = new AnnotatedAttributeValuePair(timepointAttribute, outcome.getTimepointString(),\ndocName, arm2, \"\", highlightedText, \"\", 0);\n\/\/ timepoint units\nAttribute timepointUnitAttribute = attributes.getFromName(\"Longest follow up (metric)\");\nAnnotatedAttributeValuePair tpUnit1 = new AnnotatedAttributeValuePair(timepointUnitAttribute, outcome.getItemTimepointMetric(),\ndocName, arm1, \"\", highlightedText, \"\", 0);\nAnnotatedAttributeValuePair tpUnit2 = new AnnotatedAttributeValuePair(timepointUnitAttribute, outcome.getItemTimepointMetric(),\n\nAnnotatedAttributeValuePair ov1 = new AnnotatedAttributeValuePair(ovAttribute, outcome.getData3(),\ndocName, arm1, \"\", highlightedText, \"\", 0);\nAnnotatedAttributeValuePair ov2 = new AnnotatedAttributeValuePair(ovAttribute, outcome.getData4(),\ndocName, arm2, \"\", highlightedText, \"\", 0);\n\/\/ timepoints\nAttribute timepointAttribute = attributes.getFromName(\"Longest follow up\");\nAnnotatedAttributeValuePair tp1 = new AnnotatedAttributeValuePair(timepointAttribute, outcome.getTimepointString(),\ndocName, arm1, \"\", highlightedText, \"\", 0);\nAnnotatedAttributeValuePair tp2 = new AnnotatedAttributeValuePair(timepointAttribute, outcome.getTimepointString(),\ndocName, arm2, \"\", highlightedText, \"\", 0);\n\/\/ timepoint units\nAttribute timepointUnitAttribute = attributes.getFromName(\"Longest follow up (metric)\");\nAnnotatedAttributeValuePair tpUnit1 = new AnnotatedAttributeValuePair(timepointUnitAttribute, outcome.getItemTimepointMetric(),\ndocName, arm1, \"\", highlightedText, \"\", 0);\nAnnotatedAttributeValuePair tpUnit2 = new AnnotatedAttributeValuePair(timepointUnitAttribute, outcome.getItemTimepointMetric(),\ndocName, arm2, \"\", highlightedText, \"\", 0);\n\/\/ sample size\nAttribute samplesizeAttribute = attributes.getFromName(\"Individual-level analysed\");\nAnnotatedAttributeValuePair ss1 = new AnnotatedAttributeValuePair(samplesizeAttribute, outcome.getData1(),\ndocName, arm1, \"\", highlightedText, \"\", 0);\nAnnotatedAttributeValuePair ss2 = new AnnotatedAttributeValuePair(samplesizeAttribute, outcome.getData2(),\n\nAnnotatedAttributeValuePair tp1 = new AnnotatedAttributeValuePair(timepointAttribute, outcome.getTimepointString(),\ndocName, arm1, \"\", highlightedText, \"\", 0);\nAnnotatedAttributeValuePair tp2 = new AnnotatedAttributeValuePair(timepointAttribute, outcome.getTimepointString(),\ndocName, arm2, \"\", highlightedText, \"\", 0);\n\/\/ timepoint units\nAttribute timepointUnitAttribute = attributes.getFromName(\"Longest follow up (metric)\");\nAnnotatedAttributeValuePair tpUnit1 = new AnnotatedAttributeValuePair(timepointUnitAttribute, outcome.getItemTimepointMetric(),\ndocName, arm1, \"\", highlightedText, \"\", 0);\nAnnotatedAttributeValuePair tpUnit2 = new AnnotatedAttributeValuePair(timepointUnitAttribute, outcome.getItemTimepointMetric(),\ndocName, arm2, \"\", highlightedText, \"\", 0);\n\/\/ sample size\nAttribute samplesizeAttribute = attributes.getFromName(\"Individual-level analysed\");\nAnnotatedAttributeValuePair ss1 = new AnnotatedAttributeValuePair(samplesizeAttribute, outcome.getData1(),\ndocName, arm1, \"\", highlightedText, \"\", 0);\nAnnotatedAttributeValuePair ss2 = new AnnotatedAttributeValuePair(samplesizeAttribute, outcome.getData2(),\ndocName, arm2, \"\", highlightedText, \"\", 0);\n\/\/ TODO: anything else?\nreturn Lists.newArrayList(ov1, ov2, tp1, tp2, tpUnit1, tpUnit2, ss1, ss2);\n}\n\nAnnotatedAttributeValuePair tpUnit1 = new AnnotatedAttributeValuePair(timepointUnitAttribute, outcome.getItemTimepointMetric(),\ndocName, arm1, \"\", highlightedText, \"\", 0);\nAnnotatedAttributeValuePair tpUnit2 = new AnnotatedAttributeValuePair(timepointUnitAttribute, outcome.getItemTimepointMetric(),\ndocName, arm2, \"\", highlightedText, \"\", 0);\n\/\/ sample size\nAttribute samplesizeAttribute = attributes.getFromName(\"Individual-level analysed\");\nAnnotatedAttributeValuePair ss1 = new AnnotatedAttributeValuePair(samplesizeAttribute, outcome.getData1(),\ndocName, arm1, \"\", highlightedText, \"\", 0);\nAnnotatedAttributeValuePair ss2 = new AnnotatedAttributeValuePair(samplesizeAttribute, outcome.getData2(),\ndocName, arm2, \"\", highlightedText, \"\", 0);\n\/\/ TODO: anything else?\nreturn Lists.newArrayList(ov1, ov2, tp1, tp2, tpUnit1, tpUnit2, ss1, ss2);\n}","code_context_20":"private List<AnnotatedAttributeValuePair> getAttributeValuePairs(JsonOutcome outcome, JsonReference reference) {\nOptional<String> docNameTrue = getFirstDocname(reference);\nString docName = docNameTrue.orElse(outcome.getShortTitle());\n\/\/ we use the highlighted text to put the table caption\nString highlightedText = outcome.getOutcomeDescription();\nArm arm1 = getAssignedArm(outcome.getItemArmIdGrp1(), outcome.getGrp1ArmName());\nArm arm2 = getAssignedArm(outcome.getItemArmIdGrp2(), outcome.getGrp2ArmName());\n\/\/ outcome values\nAttribute ovAttribute = attributes.getFromName(\"Outcome value\");\nAnnotatedAttributeValuePair ov1 = new AnnotatedAttributeValuePair(ovAttribute, outcome.getData3(),\ndocName, arm1, \"\", highlightedText, \"\", 0);\nAnnotatedAttributeValuePair ov2 = new AnnotatedAttributeValuePair(ovAttribute, outcome.getData4(),\ndocName, arm2, \"\", highlightedText, \"\", 0);\n\/\/ timepoints\nAttribute timepointAttribute = attributes.getFromName(\"Longest follow up\");\nAnnotatedAttributeValuePair tp1 = new AnnotatedAttributeValuePair(timepointAttribute, outcome.getTimepointString(),\ndocName, arm1, \"\", highlightedText, \"\", 0);\nAnnotatedAttributeValuePair tp2 = new AnnotatedAttributeValuePair(timepointAttribute, outcome.getTimepointString(),\ndocName, arm2, \"\", highlightedText, \"\", 0);\n\/\/ timepoint units\nAttribute timepointUnitAttribute = attributes.getFromName(\"Longest follow up (metric)\");\nAnnotatedAttributeValuePair tpUnit1 = new AnnotatedAttributeValuePair(timepointUnitAttribute, outcome.getItemTimepointMetric(),\ndocName, arm1, \"\", highlightedText, \"\", 0);\nAnnotatedAttributeValuePair tpUnit2 = new AnnotatedAttributeValuePair(timepointUnitAttribute, outcome.getItemTimepointMetric(),\n\nprivate List<AnnotatedAttributeValuePair> getAttributeValuePairs(JsonOutcome outcome, JsonReference reference) {\nOptional<String> docNameTrue = getFirstDocname(reference);\nString docName = docNameTrue.orElse(outcome.getShortTitle());\n\/\/ we use the highlighted text to put the table caption\nString highlightedText = outcome.getOutcomeDescription();\nArm arm1 = getAssignedArm(outcome.getItemArmIdGrp1(), outcome.getGrp1ArmName());\nArm arm2 = getAssignedArm(outcome.getItemArmIdGrp2(), outcome.getGrp2ArmName());\n\/\/ outcome values\nAttribute ovAttribute = attributes.getFromName(\"Outcome value\");\nAnnotatedAttributeValuePair ov1 = new AnnotatedAttributeValuePair(ovAttribute, outcome.getData3(),\ndocName, arm1, \"\", highlightedText, \"\", 0);\nAnnotatedAttributeValuePair ov2 = new AnnotatedAttributeValuePair(ovAttribute, outcome.getData4(),\ndocName, arm2, \"\", highlightedText, \"\", 0);\n\/\/ timepoints\nAttribute timepointAttribute = attributes.getFromName(\"Longest follow up\");\nAnnotatedAttributeValuePair tp1 = new AnnotatedAttributeValuePair(timepointAttribute, outcome.getTimepointString(),\ndocName, arm1, \"\", highlightedText, \"\", 0);\nAnnotatedAttributeValuePair tp2 = new AnnotatedAttributeValuePair(timepointAttribute, outcome.getTimepointString(),\ndocName, arm2, \"\", highlightedText, \"\", 0);\n\/\/ timepoint units\nAttribute timepointUnitAttribute = attributes.getFromName(\"Longest follow up (metric)\");\nAnnotatedAttributeValuePair tpUnit1 = new AnnotatedAttributeValuePair(timepointUnitAttribute, outcome.getItemTimepointMetric(),\ndocName, arm1, \"\", highlightedText, \"\", 0);\nAnnotatedAttributeValuePair tpUnit2 = new AnnotatedAttributeValuePair(timepointUnitAttribute, outcome.getItemTimepointMetric(),\ndocName, arm2, \"\", highlightedText, \"\", 0);\n\/\/ sample size\nAttribute samplesizeAttribute = attributes.getFromName(\"Individual-level analysed\");\nAnnotatedAttributeValuePair ss1 = new AnnotatedAttributeValuePair(samplesizeAttribute, outcome.getData1(),\n\nprivate List<AnnotatedAttributeValuePair> getAttributeValuePairs(JsonOutcome outcome, JsonReference reference) {\nOptional<String> docNameTrue = getFirstDocname(reference);\nString docName = docNameTrue.orElse(outcome.getShortTitle());\n\/\/ we use the highlighted text to put the table caption\nString highlightedText = outcome.getOutcomeDescription();\nArm arm1 = getAssignedArm(outcome.getItemArmIdGrp1(), outcome.getGrp1ArmName());\nArm arm2 = getAssignedArm(outcome.getItemArmIdGrp2(), outcome.getGrp2ArmName());\n\/\/ outcome values\nAttribute ovAttribute = attributes.getFromName(\"Outcome value\");\nAnnotatedAttributeValuePair ov1 = new AnnotatedAttributeValuePair(ovAttribute, outcome.getData3(),\ndocName, arm1, \"\", highlightedText, \"\", 0);\nAnnotatedAttributeValuePair ov2 = new AnnotatedAttributeValuePair(ovAttribute, outcome.getData4(),\ndocName, arm2, \"\", highlightedText, \"\", 0);\n\/\/ timepoints\nAttribute timepointAttribute = attributes.getFromName(\"Longest follow up\");\nAnnotatedAttributeValuePair tp1 = new AnnotatedAttributeValuePair(timepointAttribute, outcome.getTimepointString(),\ndocName, arm1, \"\", highlightedText, \"\", 0);\nAnnotatedAttributeValuePair tp2 = new AnnotatedAttributeValuePair(timepointAttribute, outcome.getTimepointString(),\ndocName, arm2, \"\", highlightedText, \"\", 0);\n\/\/ timepoint units\nAttribute timepointUnitAttribute = attributes.getFromName(\"Longest follow up (metric)\");\nAnnotatedAttributeValuePair tpUnit1 = new AnnotatedAttributeValuePair(timepointUnitAttribute, outcome.getItemTimepointMetric(),\ndocName, arm1, \"\", highlightedText, \"\", 0);\nAnnotatedAttributeValuePair tpUnit2 = new AnnotatedAttributeValuePair(timepointUnitAttribute, outcome.getItemTimepointMetric(),\ndocName, arm2, \"\", highlightedText, \"\", 0);\n\/\/ sample size\nAttribute samplesizeAttribute = attributes.getFromName(\"Individual-level analysed\");\nAnnotatedAttributeValuePair ss1 = new AnnotatedAttributeValuePair(samplesizeAttribute, outcome.getData1(),\ndocName, arm1, \"\", highlightedText, \"\", 0);\nAnnotatedAttributeValuePair ss2 = new AnnotatedAttributeValuePair(samplesizeAttribute, outcome.getData2(),\ndocName, arm2, \"\", highlightedText, \"\", 0);\n\/\/ TODO: anything else?\nreturn Lists.newArrayList(ov1, ov2, tp1, tp2, tpUnit1, tpUnit2, ss1, ss2);\n}\n\nprivate List<AnnotatedAttributeValuePair> getAttributeValuePairs(JsonOutcome outcome, JsonReference reference) {\nOptional<String> docNameTrue = getFirstDocname(reference);\nString docName = docNameTrue.orElse(outcome.getShortTitle());\n\/\/ we use the highlighted text to put the table caption\nString highlightedText = outcome.getOutcomeDescription();\nArm arm1 = getAssignedArm(outcome.getItemArmIdGrp1(), outcome.getGrp1ArmName());\nArm arm2 = getAssignedArm(outcome.getItemArmIdGrp2(), outcome.getGrp2ArmName());\n\/\/ outcome values\nAttribute ovAttribute = attributes.getFromName(\"Outcome value\");\nAnnotatedAttributeValuePair ov1 = new AnnotatedAttributeValuePair(ovAttribute, outcome.getData3(),\ndocName, arm1, \"\", highlightedText, \"\", 0);\nAnnotatedAttributeValuePair ov2 = new AnnotatedAttributeValuePair(ovAttribute, outcome.getData4(),\ndocName, arm2, \"\", highlightedText, \"\", 0);\n\/\/ timepoints\nAttribute timepointAttribute = attributes.getFromName(\"Longest follow up\");\nAnnotatedAttributeValuePair tp1 = new AnnotatedAttributeValuePair(timepointAttribute, outcome.getTimepointString(),\ndocName, arm1, \"\", highlightedText, \"\", 0);\nAnnotatedAttributeValuePair tp2 = new AnnotatedAttributeValuePair(timepointAttribute, outcome.getTimepointString(),\ndocName, arm2, \"\", highlightedText, \"\", 0);\n\/\/ timepoint units\nAttribute timepointUnitAttribute = attributes.getFromName(\"Longest follow up (metric)\");\nAnnotatedAttributeValuePair tpUnit1 = new AnnotatedAttributeValuePair(timepointUnitAttribute, outcome.getItemTimepointMetric(),\ndocName, arm1, \"\", highlightedText, \"\", 0);\nAnnotatedAttributeValuePair tpUnit2 = new AnnotatedAttributeValuePair(timepointUnitAttribute, outcome.getItemTimepointMetric(),\ndocName, arm2, \"\", highlightedText, \"\", 0);\n\/\/ sample size\nAttribute samplesizeAttribute = attributes.getFromName(\"Individual-level analysed\");\nAnnotatedAttributeValuePair ss1 = new AnnotatedAttributeValuePair(samplesizeAttribute, outcome.getData1(),\ndocName, arm1, \"\", highlightedText, \"\", 0);\nAnnotatedAttributeValuePair ss2 = new AnnotatedAttributeValuePair(samplesizeAttribute, outcome.getData2(),\ndocName, arm2, \"\", highlightedText, \"\", 0);\n\/\/ TODO: anything else?\nreturn Lists.newArrayList(ov1, ov2, tp1, tp2, tpUnit1, tpUnit2, ss1, ss2);\n}\n\nArm arm1 = getAssignedArm(outcome.getItemArmIdGrp1(), outcome.getGrp1ArmName());\nArm arm2 = getAssignedArm(outcome.getItemArmIdGrp2(), outcome.getGrp2ArmName());\n\/\/ outcome values\nAttribute ovAttribute = attributes.getFromName(\"Outcome value\");\nAnnotatedAttributeValuePair ov1 = new AnnotatedAttributeValuePair(ovAttribute, outcome.getData3(),\ndocName, arm1, \"\", highlightedText, \"\", 0);\nAnnotatedAttributeValuePair ov2 = new AnnotatedAttributeValuePair(ovAttribute, outcome.getData4(),\ndocName, arm2, \"\", highlightedText, \"\", 0);\n\/\/ timepoints\nAttribute timepointAttribute = attributes.getFromName(\"Longest follow up\");\nAnnotatedAttributeValuePair tp1 = new AnnotatedAttributeValuePair(timepointAttribute, outcome.getTimepointString(),\ndocName, arm1, \"\", highlightedText, \"\", 0);\nAnnotatedAttributeValuePair tp2 = new AnnotatedAttributeValuePair(timepointAttribute, outcome.getTimepointString(),\ndocName, arm2, \"\", highlightedText, \"\", 0);\n\/\/ timepoint units\nAttribute timepointUnitAttribute = attributes.getFromName(\"Longest follow up (metric)\");\nAnnotatedAttributeValuePair tpUnit1 = new AnnotatedAttributeValuePair(timepointUnitAttribute, outcome.getItemTimepointMetric(),\ndocName, arm1, \"\", highlightedText, \"\", 0);\nAnnotatedAttributeValuePair tpUnit2 = new AnnotatedAttributeValuePair(timepointUnitAttribute, outcome.getItemTimepointMetric(),\ndocName, arm2, \"\", highlightedText, \"\", 0);\n\/\/ sample size\nAttribute samplesizeAttribute = attributes.getFromName(\"Individual-level analysed\");\nAnnotatedAttributeValuePair ss1 = new AnnotatedAttributeValuePair(samplesizeAttribute, outcome.getData1(),\ndocName, arm1, \"\", highlightedText, \"\", 0);\nAnnotatedAttributeValuePair ss2 = new AnnotatedAttributeValuePair(samplesizeAttribute, outcome.getData2(),\ndocName, arm2, \"\", highlightedText, \"\", 0);\n\/\/ TODO: anything else?\nreturn Lists.newArrayList(ov1, ov2, tp1, tp2, tpUnit1, tpUnit2, ss1, ss2);\n}\n\nAnnotatedAttributeValuePair ov2 = new AnnotatedAttributeValuePair(ovAttribute, outcome.getData4(),\ndocName, arm2, \"\", highlightedText, \"\", 0);\n\/\/ timepoints\nAttribute timepointAttribute = attributes.getFromName(\"Longest follow up\");\nAnnotatedAttributeValuePair tp1 = new AnnotatedAttributeValuePair(timepointAttribute, outcome.getTimepointString(),\ndocName, arm1, \"\", highlightedText, \"\", 0);\nAnnotatedAttributeValuePair tp2 = new AnnotatedAttributeValuePair(timepointAttribute, outcome.getTimepointString(),\ndocName, arm2, \"\", highlightedText, \"\", 0);\n\/\/ timepoint units\nAttribute timepointUnitAttribute = attributes.getFromName(\"Longest follow up (metric)\");\nAnnotatedAttributeValuePair tpUnit1 = new AnnotatedAttributeValuePair(timepointUnitAttribute, outcome.getItemTimepointMetric(),\ndocName, arm1, \"\", highlightedText, \"\", 0);\nAnnotatedAttributeValuePair tpUnit2 = new AnnotatedAttributeValuePair(timepointUnitAttribute, outcome.getItemTimepointMetric(),\ndocName, arm2, \"\", highlightedText, \"\", 0);\n\/\/ sample size\nAttribute samplesizeAttribute = attributes.getFromName(\"Individual-level analysed\");\nAnnotatedAttributeValuePair ss1 = new AnnotatedAttributeValuePair(samplesizeAttribute, outcome.getData1(),\ndocName, arm1, \"\", highlightedText, \"\", 0);\nAnnotatedAttributeValuePair ss2 = new AnnotatedAttributeValuePair(samplesizeAttribute, outcome.getData2(),\ndocName, arm2, \"\", highlightedText, \"\", 0);\n\/\/ TODO: anything else?\nreturn Lists.newArrayList(ov1, ov2, tp1, tp2, tpUnit1, tpUnit2, ss1, ss2);\n}","label":[1,0,0,0]}
{"id":33859,"original_code":"public void sortRows(AlignmentTrack.SortOption option, double location) {\n        if (alignmentRows == null) {\n            return;\n        }\n        for (AlignmentInterval.Row row : alignmentRows) {\n            if (option == AlignmentTrack.SortOption.NUCELOTIDE) {\n                \/\/ TODO -- why is this here?\n            }\n            row.updateScore(option, location, this);\n        }\n        Collections.sort(alignmentRows, new Comparator<Row>() {\n            public int compare(AlignmentInterval.Row arg0, AlignmentInterval.Row arg1) {\n                if (arg0.getScore() > arg1.getScore()) {\n                    return 1;\n                } else if (arg0.getScore() > arg1.getScore()) {\n                    return -1;\n                }\n                return 0;\n            }\n        });\n    }","code":"public void sortRows(AlignmentTrack.SortOption option, double location) {\n        if (alignmentRows == null) {\n            return;\n        }\n        for (AlignmentInterval.Row row : alignmentRows) {\n            if (option == AlignmentTrack.SortOption.NUCELOTIDE) {\n               \n            }\n            row.updateScore(option, location, this);\n        }\n        Collections.sort(alignmentRows, new Comparator<Row>() {\n            public int compare(AlignmentInterval.Row arg0, AlignmentInterval.Row arg1) {\n                if (arg0.getScore() > arg1.getScore()) {\n                    return 1;\n                } else if (arg0.getScore() > arg1.getScore()) {\n                    return -1;\n                }\n                return 0;\n            }\n        });\n    }","cleancode":"public void sortrows(alignmenttrack.sortoption option, double location) { if (alignmentrows == null) { return; } for (alignmentinterval.row row : alignmentrows) { if (option == alignmenttrack.sortoption.nucelotide) { } row.updatescore(option, location, this); } collections.sort(alignmentrows, new comparator<row>() { public int compare(alignmentinterval.row arg0, alignmentinterval.row arg1) { if (arg0.getscore() > arg1.getscore()) { return 1; } else if (arg0.getscore() > arg1.getscore()) { return -1; } return 0; } }); }","comment":"\/\/ todo -- why is this here?","repo":"nrgene\/NRGene-IGV","code_context_2":"for (AlignmentInterval.Row row : alignmentRows) {\nif (option == AlignmentTrack.SortOption.NUCELOTIDE) {\n\/\/ TODO -- why is this here?\n}\nrow.updateScore(option, location, this);","code_context_10":"public void sortRows(AlignmentTrack.SortOption option, double location) {\nif (alignmentRows == null) {\nreturn;\n}\nfor (AlignmentInterval.Row row : alignmentRows) {\nif (option == AlignmentTrack.SortOption.NUCELOTIDE) {\n\/\/ TODO -- why is this here?\n}\nrow.updateScore(option, location, this);\n}\nCollections.sort(alignmentRows, new Comparator<Row>() {\npublic int compare(AlignmentInterval.Row arg0, AlignmentInterval.Row arg1) {\nif (arg0.getScore() > arg1.getScore()) {\nreturn 1;\n} else if (arg0.getScore() > arg1.getScore()) {\nreturn -1;\n}","code_context_20":"public void sortRows(AlignmentTrack.SortOption option, double location) {\nif (alignmentRows == null) {\nreturn;\n}\nfor (AlignmentInterval.Row row : alignmentRows) {\nif (option == AlignmentTrack.SortOption.NUCELOTIDE) {\n\/\/ TODO -- why is this here?\n}\nrow.updateScore(option, location, this);\n}\nCollections.sort(alignmentRows, new Comparator<Row>() {\npublic int compare(AlignmentInterval.Row arg0, AlignmentInterval.Row arg1) {\nif (arg0.getScore() > arg1.getScore()) {\nreturn 1;\n} else if (arg0.getScore() > arg1.getScore()) {\nreturn -1;\n}\nreturn 0;\n}\n});\n}","label":[1,0,0,0]}
{"id":17516,"original_code":"public native byte [] getClientIp();","code":"public native byte [] getClientIp();","cleancode":"public native byte [] getclientip();","comment":"\/\/ get client ip address. ipv6 is not tested yet. (code for ipv6 maybe buggy)","repo":"recolic\/hbase-2.1.0","code_context_2":"public native byte [] getClientIp();","code_context_10":"public native byte [] getClientIp();","code_context_20":"public native byte [] getClientIp();","label":[0,0,1,0]}
{"id":25782,"original_code":"public static List<JSONObject> constructRokuNativeElements(JSONObject elementObj) {\n\t\tList<JSONObject> elements = new ArrayList<>();\n\t\tJSONArray valueArr = (JSONArray) elementObj.get(\"value\");\n\t\tif (valueArr == null) {\n\t\t\treturn elements;\n\t\t}\n\t\tfor (int i = 0; i < valueArr.size(); i++) {\n\t\t\tString[] boundsComponents = { \"0\", \"0\", \"0\", \"0\" };\n\t\t\tString text = \"\";\n\t\t\tJSONObject valueObj = (JSONObject) valueArr.get(i);\n\t\t\tJSONArray attrArr = (JSONArray) valueObj.get(\"Attrs\");\n\t\t\tfor (int i2 = 0; i2 < attrArr.size(); i2++) {\n\t\t\t\tJSONObject attrObj = (JSONObject) attrArr.get(i2);\n\t\t\t\tJSONObject nameObj = (JSONObject) attrObj.get(\"Name\");\n\t\t\t\tif (nameObj.containsValue(\"bounds\")) {\n\t\t\t\t\tString boundsStr = (String) attrObj.get(\"Value\");\n\t\t\t\t\tboundsStr = boundsStr.replace(\"{\", \"\").replace(\"}\", \"\");\n\t\t\t\t\tboundsComponents = boundsStr.split(\", \");\n\t\t\t\t}\n\t\t\t\tif (nameObj.containsValue(\"text\")) {\n\t\t\t\t\ttext = (String) attrObj.get(\"Value\");\n\t\t\t\t}\n\t\t\t}\n\t\t\telements.add(constructRokuNativeElementJSON(elementObj, text, boundsComponents));\n\t\t}\n\t\treturn elements;\n\t}","code":"public static List<JSONObject> constructRokuNativeElements(JSONObject elementObj) {\n\t\tList<JSONObject> elements = new ArrayList<>();\n\t\tJSONArray valueArr = (JSONArray) elementObj.get(\"value\");\n\t\tif (valueArr == null) {\n\t\t\treturn elements;\n\t\t}\n\t\tfor (int i = 0; i < valueArr.size(); i++) {\n\t\t\tString[] boundsComponents = { \"0\", \"0\", \"0\", \"0\" };\n\t\t\tString text = \"\";\n\t\t\tJSONObject valueObj = (JSONObject) valueArr.get(i);\n\t\t\tJSONArray attrArr = (JSONArray) valueObj.get(\"Attrs\");\n\t\t\tfor (int i2 = 0; i2 < attrArr.size(); i2++) {\n\t\t\t\tJSONObject attrObj = (JSONObject) attrArr.get(i2);\n\t\t\t\tJSONObject nameObj = (JSONObject) attrObj.get(\"Name\");\n\t\t\t\tif (nameObj.containsValue(\"bounds\")) {\n\t\t\t\t\tString boundsStr = (String) attrObj.get(\"Value\");\n\t\t\t\t\tboundsStr = boundsStr.replace(\"{\", \"\").replace(\"}\", \"\");\n\t\t\t\t\tboundsComponents = boundsStr.split(\", \");\n\t\t\t\t}\n\t\t\t\tif (nameObj.containsValue(\"text\")) {\n\t\t\t\t\ttext = (String) attrObj.get(\"Value\");\n\t\t\t\t}\n\t\t\t}\n\t\t\telements.add(constructRokuNativeElementJSON(elementObj, text, boundsComponents));\n\t\t}\n\t\treturn elements;\n\t}","cleancode":"public static list<jsonobject> constructrokunativeelements(jsonobject elementobj) { list<jsonobject> elements = new arraylist<>(); jsonarray valuearr = (jsonarray) elementobj.get(\"value\"); if (valuearr == null) { return elements; } for (int i = 0; i < valuearr.size(); i++) { string[] boundscomponents = { \"0\", \"0\", \"0\", \"0\" }; string text = \"\"; jsonobject valueobj = (jsonobject) valuearr.get(i); jsonarray attrarr = (jsonarray) valueobj.get(\"attrs\"); for (int i2 = 0; i2 < attrarr.size(); i2++) { jsonobject attrobj = (jsonobject) attrarr.get(i2); jsonobject nameobj = (jsonobject) attrobj.get(\"name\"); if (nameobj.containsvalue(\"bounds\")) { string boundsstr = (string) attrobj.get(\"value\"); boundsstr = boundsstr.replace(\"{\", \"\").replace(\"}\", \"\"); boundscomponents = boundsstr.split(\", \"); } if (nameobj.containsvalue(\"text\")) { text = (string) attrobj.get(\"value\"); } } elements.add(constructrokunativeelementjson(elementobj, text, boundscomponents)); } return elements; }","comment":"\/\/ todo - cleanup redundancies","repo":"mohanakrishna12\/rokuality-server","code_context_2":"public static List<JSONObject> constructRokuNativeElements(JSONObject elementObj) {\nList<JSONObject> elements = new ArrayList<>();\nJSONArray valueArr = (JSONArray) elementObj.get(\"value\");\nif (valueArr == null) {\nreturn elements;\n}\nfor (int i = 0; i < valueArr.size(); i++) {\nString[] boundsComponents = { \"0\", \"0\", \"0\", \"0\" };\nString text = \"\";\nJSONObject valueObj = (JSONObject) valueArr.get(i);\nJSONArray attrArr = (JSONArray) valueObj.get(\"Attrs\");\nfor (int i2 = 0; i2 < attrArr.size(); i2++) {\nJSONObject attrObj = (JSONObject) attrArr.get(i2);\nJSONObject nameObj = (JSONObject) attrObj.get(\"Name\");\nif (nameObj.containsValue(\"bounds\")) {\nString boundsStr = (String) attrObj.get(\"Value\");\nboundsStr = boundsStr.replace(\"{\", \"\").replace(\"}\", \"\");\nboundsComponents = boundsStr.split(\", \");\n}\nif (nameObj.containsValue(\"text\")) {\ntext = (String) attrObj.get(\"Value\");\n}\n}\nelements.add(constructRokuNativeElementJSON(elementObj, text, boundsComponents));\n}\nreturn elements;\n}","code_context_10":"public static List<JSONObject> constructRokuNativeElements(JSONObject elementObj) {\nList<JSONObject> elements = new ArrayList<>();\nJSONArray valueArr = (JSONArray) elementObj.get(\"value\");\nif (valueArr == null) {\nreturn elements;\n}\nfor (int i = 0; i < valueArr.size(); i++) {\nString[] boundsComponents = { \"0\", \"0\", \"0\", \"0\" };\nString text = \"\";\nJSONObject valueObj = (JSONObject) valueArr.get(i);\nJSONArray attrArr = (JSONArray) valueObj.get(\"Attrs\");\nfor (int i2 = 0; i2 < attrArr.size(); i2++) {\nJSONObject attrObj = (JSONObject) attrArr.get(i2);\nJSONObject nameObj = (JSONObject) attrObj.get(\"Name\");\nif (nameObj.containsValue(\"bounds\")) {\nString boundsStr = (String) attrObj.get(\"Value\");\nboundsStr = boundsStr.replace(\"{\", \"\").replace(\"}\", \"\");\nboundsComponents = boundsStr.split(\", \");\n}\nif (nameObj.containsValue(\"text\")) {\ntext = (String) attrObj.get(\"Value\");\n}\n}\nelements.add(constructRokuNativeElementJSON(elementObj, text, boundsComponents));\n}\nreturn elements;\n}","code_context_20":"public static List<JSONObject> constructRokuNativeElements(JSONObject elementObj) {\nList<JSONObject> elements = new ArrayList<>();\nJSONArray valueArr = (JSONArray) elementObj.get(\"value\");\nif (valueArr == null) {\nreturn elements;\n}\nfor (int i = 0; i < valueArr.size(); i++) {\nString[] boundsComponents = { \"0\", \"0\", \"0\", \"0\" };\nString text = \"\";\nJSONObject valueObj = (JSONObject) valueArr.get(i);\nJSONArray attrArr = (JSONArray) valueObj.get(\"Attrs\");\nfor (int i2 = 0; i2 < attrArr.size(); i2++) {\nJSONObject attrObj = (JSONObject) attrArr.get(i2);\nJSONObject nameObj = (JSONObject) attrObj.get(\"Name\");\nif (nameObj.containsValue(\"bounds\")) {\nString boundsStr = (String) attrObj.get(\"Value\");\nboundsStr = boundsStr.replace(\"{\", \"\").replace(\"}\", \"\");\nboundsComponents = boundsStr.split(\", \");\n}\nif (nameObj.containsValue(\"text\")) {\ntext = (String) attrObj.get(\"Value\");\n}\n}\nelements.add(constructRokuNativeElementJSON(elementObj, text, boundsComponents));\n}\nreturn elements;\n}","label":[0,1,0,0]}
{"id":1229,"original_code":"@Test\n  public void testReadFailure() throws IOException {\n    \/\/ TODO (lwhite): These tests don't fail. What was their intent?\n    Table table1 =\n        Table.read()\n            .csv(CsvReadOptions.builder(\"..\/data\/read_failure_test.csv\").minimizeColumnSizes());\n    table1.structure(); \/\/ just make sure the import completed\n    ShortColumn test = table1.shortColumn(\"Test\");\n    \/\/ TODO(lwhite): Better tests\n    assertNotNull(test.summary());\n  }","code":"@Test\n  public void testReadFailure() throws IOException {\n   \n    Table table1 =\n        Table.read()\n            .csv(CsvReadOptions.builder(\"..\/data\/read_failure_test.csv\").minimizeColumnSizes());\n    table1.structure();\n    ShortColumn test = table1.shortColumn(\"Test\");\n   \n    assertNotNull(test.summary());\n  }","cleancode":"@test public void testreadfailure() throws ioexception { table table1 = table.read() .csv(csvreadoptions.builder(\"..\/data\/read_failure_test.csv\").minimizecolumnsizes()); table1.structure(); shortcolumn test = table1.shortcolumn(\"test\"); assertnotnull(test.summary()); }","comment":"\/\/ todo (lwhite): these tests don't fail. what was their intent?\n\/\/ just make sure the import completed\n\/\/ todo(lwhite): better tests","repo":"rayeaster\/tablesaw","code_context_2":"@Test\npublic void testReadFailure() throws IOException {\n\/\/ TODO (lwhite): These tests don't fail. What was their intent?\nTable table1 =\nTable.read()\n\nTable.read()\n.csv(CsvReadOptions.builder(\"..\/data\/read_failure_test.csv\").minimizeColumnSizes());\ntable1.structure(); \/\/ just make sure the import completed\nShortColumn test = table1.shortColumn(\"Test\");\n\/\/ TODO(lwhite): Better tests\n\ntable1.structure(); \/\/ just make sure the import completed\nShortColumn test = table1.shortColumn(\"Test\");\n\/\/ TODO(lwhite): Better tests\nassertNotNull(test.summary());\n}","code_context_10":"@Test\npublic void testReadFailure() throws IOException {\n\/\/ TODO (lwhite): These tests don't fail. What was their intent?\nTable table1 =\nTable.read()\n.csv(CsvReadOptions.builder(\"..\/data\/read_failure_test.csv\").minimizeColumnSizes());\ntable1.structure(); \/\/ just make sure the import completed\nShortColumn test = table1.shortColumn(\"Test\");\n\/\/ TODO(lwhite): Better tests\nassertNotNull(test.summary());\n}\n\n@Test\npublic void testReadFailure() throws IOException {\n\/\/ TODO (lwhite): These tests don't fail. What was their intent?\nTable table1 =\nTable.read()\n.csv(CsvReadOptions.builder(\"..\/data\/read_failure_test.csv\").minimizeColumnSizes());\ntable1.structure(); \/\/ just make sure the import completed\nShortColumn test = table1.shortColumn(\"Test\");\n\/\/ TODO(lwhite): Better tests\nassertNotNull(test.summary());\n}\n\n@Test\npublic void testReadFailure() throws IOException {\n\/\/ TODO (lwhite): These tests don't fail. What was their intent?\nTable table1 =\nTable.read()\n.csv(CsvReadOptions.builder(\"..\/data\/read_failure_test.csv\").minimizeColumnSizes());\ntable1.structure(); \/\/ just make sure the import completed\nShortColumn test = table1.shortColumn(\"Test\");\n\/\/ TODO(lwhite): Better tests\nassertNotNull(test.summary());\n}","code_context_20":"@Test\npublic void testReadFailure() throws IOException {\n\/\/ TODO (lwhite): These tests don't fail. What was their intent?\nTable table1 =\nTable.read()\n.csv(CsvReadOptions.builder(\"..\/data\/read_failure_test.csv\").minimizeColumnSizes());\ntable1.structure(); \/\/ just make sure the import completed\nShortColumn test = table1.shortColumn(\"Test\");\n\/\/ TODO(lwhite): Better tests\nassertNotNull(test.summary());\n}\n\n@Test\npublic void testReadFailure() throws IOException {\n\/\/ TODO (lwhite): These tests don't fail. What was their intent?\nTable table1 =\nTable.read()\n.csv(CsvReadOptions.builder(\"..\/data\/read_failure_test.csv\").minimizeColumnSizes());\ntable1.structure(); \/\/ just make sure the import completed\nShortColumn test = table1.shortColumn(\"Test\");\n\/\/ TODO(lwhite): Better tests\nassertNotNull(test.summary());\n}\n\n@Test\npublic void testReadFailure() throws IOException {\n\/\/ TODO (lwhite): These tests don't fail. What was their intent?\nTable table1 =\nTable.read()\n.csv(CsvReadOptions.builder(\"..\/data\/read_failure_test.csv\").minimizeColumnSizes());\ntable1.structure(); \/\/ just make sure the import completed\nShortColumn test = table1.shortColumn(\"Test\");\n\/\/ TODO(lwhite): Better tests\nassertNotNull(test.summary());\n}","label":[0,0,0,1]}
{"id":34107,"original_code":"public void copyFrom(OutputProperties opsrc)\n    throws TransformerException\n  {\n   \/\/ Bugzilla 6157: recover from xsl:output statements\n    \/\/ checkDuplicates(opsrc);\n    copyFrom(opsrc.getProperties());\n  }","code":"public void copyFrom(OutputProperties opsrc)\n    throws TransformerException\n  {\n  \n   \n    copyFrom(opsrc.getProperties());\n  }","cleancode":"public void copyfrom(outputproperties opsrc) throws transformerexception { copyfrom(opsrc.getproperties()); }","comment":"\/** * copy the keys and values from the source to this object. this will * not copy the default values. this is meant to be used by going from * a higher precedence object to a lower precedence object, so that if a * key already exists, this method will not reset it. * * @param opsrc non-null reference to an outputproperties. *\/\n\/\/ bugzilla 6157: recover from xsl:output statements \/\/ checkduplicates(opsrc);","repo":"oradian\/xalan-j","code_context_2":"public void copyFrom(OutputProperties opsrc)\nthrows TransformerException\n{\n\/\/ Bugzilla 6157: recover from xsl:output statements\n\/\/ checkDuplicates(opsrc);\ncopyFrom(opsrc.getProperties());\n}\n\nthrows TransformerException\n{\n\/\/ Bugzilla 6157: recover from xsl:output statements\n\/\/ checkDuplicates(opsrc);\ncopyFrom(opsrc.getProperties());\n}","code_context_10":"public void copyFrom(OutputProperties opsrc)\nthrows TransformerException\n{\n\/\/ Bugzilla 6157: recover from xsl:output statements\n\/\/ checkDuplicates(opsrc);\ncopyFrom(opsrc.getProperties());\n}\n\npublic void copyFrom(OutputProperties opsrc)\nthrows TransformerException\n{\n\/\/ Bugzilla 6157: recover from xsl:output statements\n\/\/ checkDuplicates(opsrc);\ncopyFrom(opsrc.getProperties());\n}","code_context_20":"public void copyFrom(OutputProperties opsrc)\nthrows TransformerException\n{\n\/\/ Bugzilla 6157: recover from xsl:output statements\n\/\/ checkDuplicates(opsrc);\ncopyFrom(opsrc.getProperties());\n}\n\npublic void copyFrom(OutputProperties opsrc)\nthrows TransformerException\n{\n\/\/ Bugzilla 6157: recover from xsl:output statements\n\/\/ checkDuplicates(opsrc);\ncopyFrom(opsrc.getProperties());\n}","label":[0,0,1,0]}
{"id":25919,"original_code":"private void buildDependencyTree( Queue<DependencyNode> nodeQueue, boolean full, boolean online, Session session, Map<String, Profile> profiles, PomFileLoader loader, Log log )\n\t\t{\n\t\t\tint neededLevels = full ? -1 : 1;\n\t\t\twhile( !nodeQueue.isEmpty() )\n\t\t\t{\n\t\t\t\tDependencyNode node = nodeQueue.poll();\n\t\t\t\tif( neededLevels >= 0 && node.getLevel() >= neededLevels )\n\t\t\t\t\tcontinue;\n\t\t\t\tnode.collectDependencyManagement( profiles, session.projects(), log );\n\t\t\t\tMap<DependencyKey, RawDependency> localDependencies = getHierarchicalDependencies( session, node.getProject(), null, online, profiles, log );\n\t\t\t\tif( localDependencies == null )\n\t\t\t\t\tcontinue;\n\t\t\t\tfor( Entry<DependencyKey, RawDependency> e : localDependencies.entrySet() )\n\t\t\t\t{\n\t\t\t\t\tDependencyKey dependencyKey = e.getKey();\n\t\t\t\t\tRawDependency dependency = e.getValue();\n\t\t\t\t\tif( dependency.isOptional() && !node.isRoot() )\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\tGroupArtifact ga = new GroupArtifact( dependencyKey.getGroupId(), dependencyKey.getArtifactId() );\n\t\t\t\t\tif( isGroupArtifactExcluded( node, ga ) )\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\tDependencyNode existingNode = node.searchNodeForGroupArtifact( ga );\n\t\t\t\t\tif( existingNode != null )\n\t\t\t\t\t{\n\t\t\t\t\t\tif( existingNode.getLevel() <= node.getLevel() + 1 )\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\telse\n\t\t\t\t\t\t\texistingNode.removeFromParent();\n\t\t\t\t\t}\n\t\t\t\t\tfinal Optional<VersionScope> optionalVs = getVersionScopeFromDependencyManagement( node, dependencyKey, dependency );\n\t\t\t\t\tfinal VersionScope vs;\n\t\t\t\t\tif(optionalVs.isPresent() )\n\t\t\t\t\t{\n\t\t\t\t\t\tvs = optionalVs.get();\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\tvs = dependency.getVs();\n\t\t\t\t\t\tif( node.isRoot() )\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tif(vs.getScope() == null) {\n\t\t\t\t\t\t\t\tvs.setScope( Scope.COMPILE );\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tScope scope = Scope.getScopeTransformation( node.getVs().getScope(), dependency.getVs().getScope() );\n\t\t\t\t\t\t\tif(scope == null )\n\t\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t\tvs.setScope( scope );\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tScope scope = vs.getScope();\n\t\t\t\t\tassert scope != null;\n\t\t\t\t\tassert vs.getVersion() != null : \"null version of dependency \" + dependencyKey + \" -> \" + dependency + \" (for project \" + project + \")\";\n\t\t\t\t\tif( scope == Scope.IMPORT || scope == Scope.SYSTEM )\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\/\/ get remote repositories\n\t\t\t\t\tList<Repository> additionalRepos = getProjectRepositories( session, node.getProject(), log );\n\t\t\t\t\tGav dependencyGav = new Gav( dependencyKey.getGroupId(), dependencyKey.getArtifactId(), vs.getVersion() );\n\t\t\t\t\tProject childProject = null;\n\t\t\t\t\tif( neededLevels < 0 || node.getLevel() >= neededLevels )\n\t\t\t\t\t{\n\t\t\t\t\t\tchildProject = session.projects().forGav( dependencyGav );\n\t\t\t\t\t\tif( childProject == null )\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tFile pomFile = loader.loadPomFileForGav( dependencyGav, additionalRepos, log );\n\t\t\t\t\t\t\tif( pomFile == null )\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tlog.html( Tools.errorMessage( \"cannot fetch project \" + dependencyGav + \" referenced in \" + node.getProject() ) );\n\t\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tPomAnalysis analysis = new PomAnalysis( session, loader, null, false, log );\n\t\t\t\t\t\t\tanalysis.addFile( pomFile );\n\t\t\t\t\t\t\tSet<Project> loadedProjects = analysis.loadProjects();\n\t\t\t\t\t\t\tif( loadedProjects.size() != 1 )\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tlog.html( Tools.errorMessage( \"cannot fetch project \" + dependencyGav + \" referenced in \" + node.getProject() ) );\n\t\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tchildProject = loadedProjects.iterator().next();\n\t\t\t\t\t\t\tanalysis.completeLoadedProjects();\n\t\t\t\t\t\t\tanalysis.addCompletedProjectsToSession();\n\t\t\t\t\t\t\tSet<Project> addedToGraph = analysis.addCompletedProjectsToGraph();\n\t\t\t\t\t\t\tif( !addedToGraph.contains( childProject ) )\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tlog.html( Tools.errorMessage( \"cannot fetch project \" + dependencyGav + \" referenced in \" + node.getProject() ) );\n\t\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif( childProject == null )\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\/\/ TODO : use specified repositories if needed !\n\t\t\t\t\t\t\tlog.html( Tools.warningMessage( \"cannot fetch project \" + dependencyGav + \" referenced in \" + node.getProject() + (dependency.isOptional() ? \" (this is an optional dependency)\" : \"\") ) );\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tDependencyNode child = new DependencyNode( childProject, dependencyKey, vs );\n\t\t\t\t\tchild.addExclusions( dependency.getExclusions() );\n\t\t\t\t\tnode.addChild( child );\n\t\t\t\t\tDependencyManagement dm = node.getLocalManagement( dependencyKey );\n\t\t\t\t\tif( dm != null )\n\t\t\t\t\t\tchild.addExclusions( dm.getExclusions() );\n\t\t\t\t\t\/\/FIXME is always false\n\t\t\t\t\tif( scope == Scope.SYSTEM )\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\/\/ TODO it seems to me that transitive dependency policy only\n\t\t\t\t\t\/\/ applies to jar artifacts, is that true ??\n\t\t\t\t\t\/\/ if( \"jar\".equals( dependencyKey.getType() ) )\n\t\t\t\t\tnodeQueue.add( child );\n\t\t\t\t}\n\t\t\t}\n\t\t}","code":"private void buildDependencyTree( Queue<DependencyNode> nodeQueue, boolean full, boolean online, Session session, Map<String, Profile> profiles, PomFileLoader loader, Log log )\n\t\t{\n\t\t\tint neededLevels = full ? -1 : 1;\n\t\t\twhile( !nodeQueue.isEmpty() )\n\t\t\t{\n\t\t\t\tDependencyNode node = nodeQueue.poll();\n\t\t\t\tif( neededLevels >= 0 && node.getLevel() >= neededLevels )\n\t\t\t\t\tcontinue;\n\t\t\t\tnode.collectDependencyManagement( profiles, session.projects(), log );\n\t\t\t\tMap<DependencyKey, RawDependency> localDependencies = getHierarchicalDependencies( session, node.getProject(), null, online, profiles, log );\n\t\t\t\tif( localDependencies == null )\n\t\t\t\t\tcontinue;\n\t\t\t\tfor( Entry<DependencyKey, RawDependency> e : localDependencies.entrySet() )\n\t\t\t\t{\n\t\t\t\t\tDependencyKey dependencyKey = e.getKey();\n\t\t\t\t\tRawDependency dependency = e.getValue();\n\t\t\t\t\tif( dependency.isOptional() && !node.isRoot() )\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\tGroupArtifact ga = new GroupArtifact( dependencyKey.getGroupId(), dependencyKey.getArtifactId() );\n\t\t\t\t\tif( isGroupArtifactExcluded( node, ga ) )\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\tDependencyNode existingNode = node.searchNodeForGroupArtifact( ga );\n\t\t\t\t\tif( existingNode != null )\n\t\t\t\t\t{\n\t\t\t\t\t\tif( existingNode.getLevel() <= node.getLevel() + 1 )\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\telse\n\t\t\t\t\t\t\texistingNode.removeFromParent();\n\t\t\t\t\t}\n\t\t\t\t\tfinal Optional<VersionScope> optionalVs = getVersionScopeFromDependencyManagement( node, dependencyKey, dependency );\n\t\t\t\t\tfinal VersionScope vs;\n\t\t\t\t\tif(optionalVs.isPresent() )\n\t\t\t\t\t{\n\t\t\t\t\t\tvs = optionalVs.get();\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\tvs = dependency.getVs();\n\t\t\t\t\t\tif( node.isRoot() )\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tif(vs.getScope() == null) {\n\t\t\t\t\t\t\t\tvs.setScope( Scope.COMPILE );\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tScope scope = Scope.getScopeTransformation( node.getVs().getScope(), dependency.getVs().getScope() );\n\t\t\t\t\t\t\tif(scope == null )\n\t\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t\tvs.setScope( scope );\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tScope scope = vs.getScope();\n\t\t\t\t\tassert scope != null;\n\t\t\t\t\tassert vs.getVersion() != null : \"null version of dependency \" + dependencyKey + \" -> \" + dependency + \" (for project \" + project + \")\";\n\t\t\t\t\tif( scope == Scope.IMPORT || scope == Scope.SYSTEM )\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\n\t\t\t\t\tList<Repository> additionalRepos = getProjectRepositories( session, node.getProject(), log );\n\t\t\t\t\tGav dependencyGav = new Gav( dependencyKey.getGroupId(), dependencyKey.getArtifactId(), vs.getVersion() );\n\t\t\t\t\tProject childProject = null;\n\t\t\t\t\tif( neededLevels < 0 || node.getLevel() >= neededLevels )\n\t\t\t\t\t{\n\t\t\t\t\t\tchildProject = session.projects().forGav( dependencyGav );\n\t\t\t\t\t\tif( childProject == null )\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tFile pomFile = loader.loadPomFileForGav( dependencyGav, additionalRepos, log );\n\t\t\t\t\t\t\tif( pomFile == null )\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tlog.html( Tools.errorMessage( \"cannot fetch project \" + dependencyGav + \" referenced in \" + node.getProject() ) );\n\t\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tPomAnalysis analysis = new PomAnalysis( session, loader, null, false, log );\n\t\t\t\t\t\t\tanalysis.addFile( pomFile );\n\t\t\t\t\t\t\tSet<Project> loadedProjects = analysis.loadProjects();\n\t\t\t\t\t\t\tif( loadedProjects.size() != 1 )\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tlog.html( Tools.errorMessage( \"cannot fetch project \" + dependencyGav + \" referenced in \" + node.getProject() ) );\n\t\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tchildProject = loadedProjects.iterator().next();\n\t\t\t\t\t\t\tanalysis.completeLoadedProjects();\n\t\t\t\t\t\t\tanalysis.addCompletedProjectsToSession();\n\t\t\t\t\t\t\tSet<Project> addedToGraph = analysis.addCompletedProjectsToGraph();\n\t\t\t\t\t\t\tif( !addedToGraph.contains( childProject ) )\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tlog.html( Tools.errorMessage( \"cannot fetch project \" + dependencyGav + \" referenced in \" + node.getProject() ) );\n\t\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif( childProject == null )\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\n\t\t\t\t\t\t\tlog.html( Tools.warningMessage( \"cannot fetch project \" + dependencyGav + \" referenced in \" + node.getProject() + (dependency.isOptional() ? \" (this is an optional dependency)\" : \"\") ) );\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tDependencyNode child = new DependencyNode( childProject, dependencyKey, vs );\n\t\t\t\t\tchild.addExclusions( dependency.getExclusions() );\n\t\t\t\t\tnode.addChild( child );\n\t\t\t\t\tDependencyManagement dm = node.getLocalManagement( dependencyKey );\n\t\t\t\t\tif( dm != null )\n\t\t\t\t\t\tchild.addExclusions( dm.getExclusions() );\n\t\t\t\t\n\t\t\t\t\tif( scope == Scope.SYSTEM )\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\n\t\t\t\t\n\t\t\t\t\n\t\t\t\t\tnodeQueue.add( child );\n\t\t\t\t}\n\t\t\t}\n\t\t}","cleancode":"private void builddependencytree( queue<dependencynode> nodequeue, boolean full, boolean online, session session, map<string, profile> profiles, pomfileloader loader, log log ) { int neededlevels = full ? -1 : 1; while( !nodequeue.isempty() ) { dependencynode node = nodequeue.poll(); if( neededlevels >= 0 && node.getlevel() >= neededlevels ) continue; node.collectdependencymanagement( profiles, session.projects(), log ); map<dependencykey, rawdependency> localdependencies = gethierarchicaldependencies( session, node.getproject(), null, online, profiles, log ); if( localdependencies == null ) continue; for( entry<dependencykey, rawdependency> e : localdependencies.entryset() ) { dependencykey dependencykey = e.getkey(); rawdependency dependency = e.getvalue(); if( dependency.isoptional() && !node.isroot() ) continue; groupartifact ga = new groupartifact( dependencykey.getgroupid(), dependencykey.getartifactid() ); if( isgroupartifactexcluded( node, ga ) ) continue; dependencynode existingnode = node.searchnodeforgroupartifact( ga ); if( existingnode != null ) { if( existingnode.getlevel() <= node.getlevel() + 1 ) continue; else existingnode.removefromparent(); } final optional<versionscope> optionalvs = getversionscopefromdependencymanagement( node, dependencykey, dependency ); final versionscope vs; if(optionalvs.ispresent() ) { vs = optionalvs.get(); } else { vs = dependency.getvs(); if( node.isroot() ) { if(vs.getscope() == null) { vs.setscope( scope.compile ); } } else { scope scope = scope.getscopetransformation( node.getvs().getscope(), dependency.getvs().getscope() ); if(scope == null ) continue; vs.setscope( scope ); } } scope scope = vs.getscope(); assert scope != null; assert vs.getversion() != null : \"null version of dependency \" + dependencykey + \" -> \" + dependency + \" (for project \" + project + \")\"; if( scope == scope.import || scope == scope.system ) continue; list<repository> additionalrepos = getprojectrepositories( session, node.getproject(), log ); gav dependencygav = new gav( dependencykey.getgroupid(), dependencykey.getartifactid(), vs.getversion() ); project childproject = null; if( neededlevels < 0 || node.getlevel() >= neededlevels ) { childproject = session.projects().forgav( dependencygav ); if( childproject == null ) { file pomfile = loader.loadpomfileforgav( dependencygav, additionalrepos, log ); if( pomfile == null ) { log.html( tools.errormessage( \"cannot fetch project \" + dependencygav + \" referenced in \" + node.getproject() ) ); continue; } pomanalysis analysis = new pomanalysis( session, loader, null, false, log ); analysis.addfile( pomfile ); set<project> loadedprojects = analysis.loadprojects(); if( loadedprojects.size() != 1 ) { log.html( tools.errormessage( \"cannot fetch project \" + dependencygav + \" referenced in \" + node.getproject() ) ); continue; } childproject = loadedprojects.iterator().next(); analysis.completeloadedprojects(); analysis.addcompletedprojectstosession(); set<project> addedtograph = analysis.addcompletedprojectstograph(); if( !addedtograph.contains( childproject ) ) { log.html( tools.errormessage( \"cannot fetch project \" + dependencygav + \" referenced in \" + node.getproject() ) ); continue; } } if( childproject == null ) { log.html( tools.warningmessage( \"cannot fetch project \" + dependencygav + \" referenced in \" + node.getproject() + (dependency.isoptional() ? \" (this is an optional dependency)\" : \"\") ) ); continue; } } dependencynode child = new dependencynode( childproject, dependencykey, vs ); child.addexclusions( dependency.getexclusions() ); node.addchild( child ); dependencymanagement dm = node.getlocalmanagement( dependencykey ); if( dm != null ) child.addexclusions( dm.getexclusions() ); if( scope == scope.system ) continue; nodequeue.add( child ); } } }","comment":"\/\/ get remote repositories\n\/\/ todo : use specified repositories if needed !\n\/\/fixme is always false\n\/\/ todo it seems to me that transitive dependency policy only \/\/ applies to jar artifacts, is that true ?? \/\/ if( \"jar\".equals( dependencykey.gettype() ) )","repo":"mpicque\/pom-explorer","code_context_2":"if( scope == Scope.IMPORT || scope == Scope.SYSTEM )\ncontinue;\n\/\/ get remote repositories\nList<Repository> additionalRepos = getProjectRepositories( session, node.getProject(), log );\nGav dependencyGav = new Gav( dependencyKey.getGroupId(), dependencyKey.getArtifactId(), vs.getVersion() );\n\nif( childProject == null )\n{\n\/\/ TODO : use specified repositories if needed !\nlog.html( Tools.warningMessage( \"cannot fetch project \" + dependencyGav + \" referenced in \" + node.getProject() + (dependency.isOptional() ? \" (this is an optional dependency)\" : \"\") ) );\ncontinue;\n\nif( dm != null )\nchild.addExclusions( dm.getExclusions() );\n\/\/FIXME is always false\nif( scope == Scope.SYSTEM )\ncontinue;\n\nif( scope == Scope.SYSTEM )\ncontinue;\n\/\/ TODO it seems to me that transitive dependency policy only\n\/\/ applies to jar artifacts, is that true ??\n\/\/ if( \"jar\".equals( dependencyKey.getType() ) )\nnodeQueue.add( child );\n}","code_context_10":"if(scope == null )\ncontinue;\nvs.setScope( scope );\n}\n}\nScope scope = vs.getScope();\nassert scope != null;\nassert vs.getVersion() != null : \"null version of dependency \" + dependencyKey + \" -> \" + dependency + \" (for project \" + project + \")\";\nif( scope == Scope.IMPORT || scope == Scope.SYSTEM )\ncontinue;\n\/\/ get remote repositories\nList<Repository> additionalRepos = getProjectRepositories( session, node.getProject(), log );\nGav dependencyGav = new Gav( dependencyKey.getGroupId(), dependencyKey.getArtifactId(), vs.getVersion() );\nProject childProject = null;\nif( neededLevels < 0 || node.getLevel() >= neededLevels )\n{\nchildProject = session.projects().forGav( dependencyGav );\nif( childProject == null )\n{\nFile pomFile = loader.loadPomFileForGav( dependencyGav, additionalRepos, log );\nif( pomFile == null )\n\nanalysis.addCompletedProjectsToSession();\nSet<Project> addedToGraph = analysis.addCompletedProjectsToGraph();\nif( !addedToGraph.contains( childProject ) )\n{\nlog.html( Tools.errorMessage( \"cannot fetch project \" + dependencyGav + \" referenced in \" + node.getProject() ) );\ncontinue;\n}\n}\nif( childProject == null )\n{\n\/\/ TODO : use specified repositories if needed !\nlog.html( Tools.warningMessage( \"cannot fetch project \" + dependencyGav + \" referenced in \" + node.getProject() + (dependency.isOptional() ? \" (this is an optional dependency)\" : \"\") ) );\ncontinue;\n}\n}\nDependencyNode child = new DependencyNode( childProject, dependencyKey, vs );\nchild.addExclusions( dependency.getExclusions() );\nnode.addChild( child );\nDependencyManagement dm = node.getLocalManagement( dependencyKey );\nif( dm != null )\nchild.addExclusions( dm.getExclusions() );\n\nlog.html( Tools.warningMessage( \"cannot fetch project \" + dependencyGav + \" referenced in \" + node.getProject() + (dependency.isOptional() ? \" (this is an optional dependency)\" : \"\") ) );\ncontinue;\n}\n}\nDependencyNode child = new DependencyNode( childProject, dependencyKey, vs );\nchild.addExclusions( dependency.getExclusions() );\nnode.addChild( child );\nDependencyManagement dm = node.getLocalManagement( dependencyKey );\nif( dm != null )\nchild.addExclusions( dm.getExclusions() );\n\/\/FIXME is always false\nif( scope == Scope.SYSTEM )\ncontinue;\n\/\/ TODO it seems to me that transitive dependency policy only\n\/\/ applies to jar artifacts, is that true ??\n\/\/ if( \"jar\".equals( dependencyKey.getType() ) )\nnodeQueue.add( child );\n}\n}\n}\n\n}\nDependencyNode child = new DependencyNode( childProject, dependencyKey, vs );\nchild.addExclusions( dependency.getExclusions() );\nnode.addChild( child );\nDependencyManagement dm = node.getLocalManagement( dependencyKey );\nif( dm != null )\nchild.addExclusions( dm.getExclusions() );\n\/\/FIXME is always false\nif( scope == Scope.SYSTEM )\ncontinue;\n\/\/ TODO it seems to me that transitive dependency policy only\n\/\/ applies to jar artifacts, is that true ??\n\/\/ if( \"jar\".equals( dependencyKey.getType() ) )\nnodeQueue.add( child );\n}\n}\n}","code_context_20":"vs = dependency.getVs();\nif( node.isRoot() )\n{\nif(vs.getScope() == null) {\nvs.setScope( Scope.COMPILE );\n}\n}\nelse\n{\nScope scope = Scope.getScopeTransformation( node.getVs().getScope(), dependency.getVs().getScope() );\nif(scope == null )\ncontinue;\nvs.setScope( scope );\n}\n}\nScope scope = vs.getScope();\nassert scope != null;\nassert vs.getVersion() != null : \"null version of dependency \" + dependencyKey + \" -> \" + dependency + \" (for project \" + project + \")\";\nif( scope == Scope.IMPORT || scope == Scope.SYSTEM )\ncontinue;\n\/\/ get remote repositories\nList<Repository> additionalRepos = getProjectRepositories( session, node.getProject(), log );\nGav dependencyGav = new Gav( dependencyKey.getGroupId(), dependencyKey.getArtifactId(), vs.getVersion() );\nProject childProject = null;\nif( neededLevels < 0 || node.getLevel() >= neededLevels )\n{\nchildProject = session.projects().forGav( dependencyGav );\nif( childProject == null )\n{\nFile pomFile = loader.loadPomFileForGav( dependencyGav, additionalRepos, log );\nif( pomFile == null )\n{\nlog.html( Tools.errorMessage( \"cannot fetch project \" + dependencyGav + \" referenced in \" + node.getProject() ) );\ncontinue;\n}\nPomAnalysis analysis = new PomAnalysis( session, loader, null, false, log );\nanalysis.addFile( pomFile );\nSet<Project> loadedProjects = analysis.loadProjects();\nif( loadedProjects.size() != 1 )\n{\nlog.html( Tools.errorMessage( \"cannot fetch project \" + dependencyGav + \" referenced in \" + node.getProject() ) );\n\nPomAnalysis analysis = new PomAnalysis( session, loader, null, false, log );\nanalysis.addFile( pomFile );\nSet<Project> loadedProjects = analysis.loadProjects();\nif( loadedProjects.size() != 1 )\n{\nlog.html( Tools.errorMessage( \"cannot fetch project \" + dependencyGav + \" referenced in \" + node.getProject() ) );\ncontinue;\n}\nchildProject = loadedProjects.iterator().next();\nanalysis.completeLoadedProjects();\nanalysis.addCompletedProjectsToSession();\nSet<Project> addedToGraph = analysis.addCompletedProjectsToGraph();\nif( !addedToGraph.contains( childProject ) )\n{\nlog.html( Tools.errorMessage( \"cannot fetch project \" + dependencyGav + \" referenced in \" + node.getProject() ) );\ncontinue;\n}\n}\nif( childProject == null )\n{\n\/\/ TODO : use specified repositories if needed !\nlog.html( Tools.warningMessage( \"cannot fetch project \" + dependencyGav + \" referenced in \" + node.getProject() + (dependency.isOptional() ? \" (this is an optional dependency)\" : \"\") ) );\ncontinue;\n}\n}\nDependencyNode child = new DependencyNode( childProject, dependencyKey, vs );\nchild.addExclusions( dependency.getExclusions() );\nnode.addChild( child );\nDependencyManagement dm = node.getLocalManagement( dependencyKey );\nif( dm != null )\nchild.addExclusions( dm.getExclusions() );\n\/\/FIXME is always false\nif( scope == Scope.SYSTEM )\ncontinue;\n\/\/ TODO it seems to me that transitive dependency policy only\n\/\/ applies to jar artifacts, is that true ??\n\/\/ if( \"jar\".equals( dependencyKey.getType() ) )\nnodeQueue.add( child );\n}\n}\n}\n\nSet<Project> addedToGraph = analysis.addCompletedProjectsToGraph();\nif( !addedToGraph.contains( childProject ) )\n{\nlog.html( Tools.errorMessage( \"cannot fetch project \" + dependencyGav + \" referenced in \" + node.getProject() ) );\ncontinue;\n}\n}\nif( childProject == null )\n{\n\/\/ TODO : use specified repositories if needed !\nlog.html( Tools.warningMessage( \"cannot fetch project \" + dependencyGav + \" referenced in \" + node.getProject() + (dependency.isOptional() ? \" (this is an optional dependency)\" : \"\") ) );\ncontinue;\n}\n}\nDependencyNode child = new DependencyNode( childProject, dependencyKey, vs );\nchild.addExclusions( dependency.getExclusions() );\nnode.addChild( child );\nDependencyManagement dm = node.getLocalManagement( dependencyKey );\nif( dm != null )\nchild.addExclusions( dm.getExclusions() );\n\/\/FIXME is always false\nif( scope == Scope.SYSTEM )\ncontinue;\n\/\/ TODO it seems to me that transitive dependency policy only\n\/\/ applies to jar artifacts, is that true ??\n\/\/ if( \"jar\".equals( dependencyKey.getType() ) )\nnodeQueue.add( child );\n}\n}\n}\n\nlog.html( Tools.errorMessage( \"cannot fetch project \" + dependencyGav + \" referenced in \" + node.getProject() ) );\ncontinue;\n}\n}\nif( childProject == null )\n{\n\/\/ TODO : use specified repositories if needed !\nlog.html( Tools.warningMessage( \"cannot fetch project \" + dependencyGav + \" referenced in \" + node.getProject() + (dependency.isOptional() ? \" (this is an optional dependency)\" : \"\") ) );\ncontinue;\n}\n}\nDependencyNode child = new DependencyNode( childProject, dependencyKey, vs );\nchild.addExclusions( dependency.getExclusions() );\nnode.addChild( child );\nDependencyManagement dm = node.getLocalManagement( dependencyKey );\nif( dm != null )\nchild.addExclusions( dm.getExclusions() );\n\/\/FIXME is always false\nif( scope == Scope.SYSTEM )\ncontinue;\n\/\/ TODO it seems to me that transitive dependency policy only\n\/\/ applies to jar artifacts, is that true ??\n\/\/ if( \"jar\".equals( dependencyKey.getType() ) )\nnodeQueue.add( child );\n}\n}\n}","label":[1,1,1,0]}
{"id":34120,"original_code":"private void setupViewPager(ViewPager viewPager) {\n        \/\/ TODO: see if we can replace the words with icons in the future\n        mSectionsPageAdapter.addFragment(new HomeFragment(), \"Home\");\n        mSectionsPageAdapter.addFragment(new SettingsFragment(), \"Settings\");\n        viewPager.setAdapter(mSectionsPageAdapter);\n    }","code":"private void setupViewPager(ViewPager viewPager) {\n       \n        mSectionsPageAdapter.addFragment(new HomeFragment(), \"Home\");\n        mSectionsPageAdapter.addFragment(new SettingsFragment(), \"Settings\");\n        viewPager.setAdapter(mSectionsPageAdapter);\n    }","cleancode":"private void setupviewpager(viewpager viewpager) { msectionspageadapter.addfragment(new homefragment(), \"home\"); msectionspageadapter.addfragment(new settingsfragment(), \"settings\"); viewpager.setadapter(msectionspageadapter); }","comment":"\/\/ todo: see if we can replace the words with icons in the future","repo":"mo-morgan\/Food-Radar","code_context_2":"private void setupViewPager(ViewPager viewPager) {\n\/\/ TODO: see if we can replace the words with icons in the future\nmSectionsPageAdapter.addFragment(new HomeFragment(), \"Home\");\nmSectionsPageAdapter.addFragment(new SettingsFragment(), \"Settings\");","code_context_10":"private void setupViewPager(ViewPager viewPager) {\n\/\/ TODO: see if we can replace the words with icons in the future\nmSectionsPageAdapter.addFragment(new HomeFragment(), \"Home\");\nmSectionsPageAdapter.addFragment(new SettingsFragment(), \"Settings\");\nviewPager.setAdapter(mSectionsPageAdapter);\n}","code_context_20":"private void setupViewPager(ViewPager viewPager) {\n\/\/ TODO: see if we can replace the words with icons in the future\nmSectionsPageAdapter.addFragment(new HomeFragment(), \"Home\");\nmSectionsPageAdapter.addFragment(new SettingsFragment(), \"Settings\");\nviewPager.setAdapter(mSectionsPageAdapter);\n}","label":[1,0,0,0]}
{"id":1432,"original_code":"@Override\n\tpublic void onDestroy() {\n\t    super.onDestroy();  \/\/ Always call the superclass\n\t    \/\/ probably not needed, onStop closes the socket, which should make the thread stop (?)\n\t    if (recvAsyncTask != null)\n\t    \trecvAsyncTask.cancel(true);\n\t    recvAsyncTask = null;\n\t}","code":"@Override\n\tpublic void onDestroy() {\n\t    super.onDestroy(); \n\t   \n\t    if (recvAsyncTask != null)\n\t    \trecvAsyncTask.cancel(true);\n\t    recvAsyncTask = null;\n\t}","cleancode":"@override public void ondestroy() { super.ondestroy(); if (recvasynctask != null) recvasynctask.cancel(true); recvasynctask = null; }","comment":"\/\/ always call the superclass\n\/\/ probably not needed, onstop closes the socket, which should make the thread stop (?)","repo":"phques\/androidpush","code_context_2":"@Override\npublic void onDestroy() {\nsuper.onDestroy(); \/\/ Always call the superclass\n\/\/ probably not needed, onStop closes the socket, which should make the thread stop (?)\nif (recvAsyncTask != null)\n\npublic void onDestroy() {\nsuper.onDestroy(); \/\/ Always call the superclass\n\/\/ probably not needed, onStop closes the socket, which should make the thread stop (?)\nif (recvAsyncTask != null)\nrecvAsyncTask.cancel(true);","code_context_10":"@Override\npublic void onDestroy() {\nsuper.onDestroy(); \/\/ Always call the superclass\n\/\/ probably not needed, onStop closes the socket, which should make the thread stop (?)\nif (recvAsyncTask != null)\nrecvAsyncTask.cancel(true);\nrecvAsyncTask = null;\n}\n\n@Override\npublic void onDestroy() {\nsuper.onDestroy(); \/\/ Always call the superclass\n\/\/ probably not needed, onStop closes the socket, which should make the thread stop (?)\nif (recvAsyncTask != null)\nrecvAsyncTask.cancel(true);\nrecvAsyncTask = null;\n}","code_context_20":"@Override\npublic void onDestroy() {\nsuper.onDestroy(); \/\/ Always call the superclass\n\/\/ probably not needed, onStop closes the socket, which should make the thread stop (?)\nif (recvAsyncTask != null)\nrecvAsyncTask.cancel(true);\nrecvAsyncTask = null;\n}\n\n@Override\npublic void onDestroy() {\nsuper.onDestroy(); \/\/ Always call the superclass\n\/\/ probably not needed, onStop closes the socket, which should make the thread stop (?)\nif (recvAsyncTask != null)\nrecvAsyncTask.cancel(true);\nrecvAsyncTask = null;\n}","label":[1,0,0,0]}
{"id":1435,"original_code":"public static CashierTransaction fromJson(\n    \t\tfinal Cashier cashier,\n    \t\tfinal JsonCommand command) {\n        final Integer txnType = command.integerValueOfParameterNamed(\"txnType\");\n        final BigDecimal txnAmount = command.bigDecimalValueOfParameterNamed(\"txnAmount\");\n        final LocalDate txnDate = command.localDateValueOfParameterNamed(\"txnDate\");\n        final String entityType = command.stringValueOfParameterNamed(\"entityType\");\n        final String txnNote = command.stringValueOfParameterNamed(\"txnNote\");\n        final Long entityId = command.longValueOfParameterNamed(\"entityId\");\n        final String currencyCode = command.stringValueOfParameterNamed(\"currencyCode\");\n        \/\/ TODO: get client\/loan\/savings details\n        return new CashierTransaction (cashier, txnType, txnAmount, txnDate, \n        \t\tentityType, entityId, txnNote, currencyCode);\n    }","code":"public static CashierTransaction fromJson(\n    \t\tfinal Cashier cashier,\n    \t\tfinal JsonCommand command) {\n        final Integer txnType = command.integerValueOfParameterNamed(\"txnType\");\n        final BigDecimal txnAmount = command.bigDecimalValueOfParameterNamed(\"txnAmount\");\n        final LocalDate txnDate = command.localDateValueOfParameterNamed(\"txnDate\");\n        final String entityType = command.stringValueOfParameterNamed(\"entityType\");\n        final String txnNote = command.stringValueOfParameterNamed(\"txnNote\");\n        final Long entityId = command.longValueOfParameterNamed(\"entityId\");\n        final String currencyCode = command.stringValueOfParameterNamed(\"currencyCode\");\n       \n        return new CashierTransaction (cashier, txnType, txnAmount, txnDate, \n        \t\tentityType, entityId, txnNote, currencyCode);\n    }","cleancode":"public static cashiertransaction fromjson( final cashier cashier, final jsoncommand command) { final integer txntype = command.integervalueofparameternamed(\"txntype\"); final bigdecimal txnamount = command.bigdecimalvalueofparameternamed(\"txnamount\"); final localdate txndate = command.localdatevalueofparameternamed(\"txndate\"); final string entitytype = command.stringvalueofparameternamed(\"entitytype\"); final string txnnote = command.stringvalueofparameternamed(\"txnnote\"); final long entityid = command.longvalueofparameternamed(\"entityid\"); final string currencycode = command.stringvalueofparameternamed(\"currencycode\"); return new cashiertransaction (cashier, txntype, txnamount, txndate, entitytype, entityid, txnnote, currencycode); }","comment":"\/\/ todo: get client\/loan\/savings details","repo":"raghuvissu\/GST","code_context_2":"final Long entityId = command.longValueOfParameterNamed(\"entityId\");\nfinal String currencyCode = command.stringValueOfParameterNamed(\"currencyCode\");\n\/\/ TODO: get client\/loan\/savings details\nreturn new CashierTransaction (cashier, txnType, txnAmount, txnDate,\nentityType, entityId, txnNote, currencyCode);","code_context_10":"public static CashierTransaction fromJson(\nfinal Cashier cashier,\nfinal JsonCommand command) {\nfinal Integer txnType = command.integerValueOfParameterNamed(\"txnType\");\nfinal BigDecimal txnAmount = command.bigDecimalValueOfParameterNamed(\"txnAmount\");\nfinal LocalDate txnDate = command.localDateValueOfParameterNamed(\"txnDate\");\nfinal String entityType = command.stringValueOfParameterNamed(\"entityType\");\nfinal String txnNote = command.stringValueOfParameterNamed(\"txnNote\");\nfinal Long entityId = command.longValueOfParameterNamed(\"entityId\");\nfinal String currencyCode = command.stringValueOfParameterNamed(\"currencyCode\");\n\/\/ TODO: get client\/loan\/savings details\nreturn new CashierTransaction (cashier, txnType, txnAmount, txnDate,\nentityType, entityId, txnNote, currencyCode);\n}","code_context_20":"public static CashierTransaction fromJson(\nfinal Cashier cashier,\nfinal JsonCommand command) {\nfinal Integer txnType = command.integerValueOfParameterNamed(\"txnType\");\nfinal BigDecimal txnAmount = command.bigDecimalValueOfParameterNamed(\"txnAmount\");\nfinal LocalDate txnDate = command.localDateValueOfParameterNamed(\"txnDate\");\nfinal String entityType = command.stringValueOfParameterNamed(\"entityType\");\nfinal String txnNote = command.stringValueOfParameterNamed(\"txnNote\");\nfinal Long entityId = command.longValueOfParameterNamed(\"entityId\");\nfinal String currencyCode = command.stringValueOfParameterNamed(\"currencyCode\");\n\/\/ TODO: get client\/loan\/savings details\nreturn new CashierTransaction (cashier, txnType, txnAmount, txnDate,\nentityType, entityId, txnNote, currencyCode);\n}","label":[0,1,0,0]}
{"id":1463,"original_code":"public void parse(InputStream file) throws IOException, TikaException {\n        ByteArrayOutputStream xmpraw = new ByteArrayOutputStream();\n        if (!scanner.parse(file, xmpraw)) {\n            return;\n        }\n        Reader decoded = new InputStreamReader(\n                new ByteArrayInputStream(xmpraw.toByteArray()),\n                DEFAULT_XMP_CHARSET);\n        try {\n            XMPMetadata xmp = XMPMetadata.load(new InputSource(decoded));\n            XMPSchemaDublinCore dc = xmp.getDublinCoreSchema();\n            if (dc != null) {\n                if (dc.getTitle() != null) {\n                    metadata.set(DublinCore.TITLE, dc.getTitle());\n                }\n                if (dc.getDescription() != null) {\n                    metadata.set(DublinCore.DESCRIPTION, dc.getDescription());\n                }\n                if (dc.getCreators() != null && dc.getCreators().size() > 0) {\n                    metadata.set(DublinCore.CREATOR, joinCreators(dc.getCreators()));\n                }\n                if (dc.getSubjects() != null && dc.getSubjects().size() > 0) {\n                    Iterator<String> keywords = dc.getSubjects().iterator();\n                    while (keywords.hasNext()) {\n                        metadata.add(DublinCore.SUBJECT, keywords.next());\n                    }\n                    \/\/ TODO should we set KEYWORDS too?\n                    \/\/ All tested photo managers set the same in Iptc.Application2.Keywords and Xmp.dc.subject\n                }\n            }\n        } catch (IOException e) {\n            \/\/ Could not parse embedded XMP metadata. That's not a serious\n            \/\/ problem, so we'll just ignore the issue for now.\n            \/\/ TODO: Make error handling like this configurable.\n        }\n    }","code":"public void parse(InputStream file) throws IOException, TikaException {\n        ByteArrayOutputStream xmpraw = new ByteArrayOutputStream();\n        if (!scanner.parse(file, xmpraw)) {\n            return;\n        }\n        Reader decoded = new InputStreamReader(\n                new ByteArrayInputStream(xmpraw.toByteArray()),\n                DEFAULT_XMP_CHARSET);\n        try {\n            XMPMetadata xmp = XMPMetadata.load(new InputSource(decoded));\n            XMPSchemaDublinCore dc = xmp.getDublinCoreSchema();\n            if (dc != null) {\n                if (dc.getTitle() != null) {\n                    metadata.set(DublinCore.TITLE, dc.getTitle());\n                }\n                if (dc.getDescription() != null) {\n                    metadata.set(DublinCore.DESCRIPTION, dc.getDescription());\n                }\n                if (dc.getCreators() != null && dc.getCreators().size() > 0) {\n                    metadata.set(DublinCore.CREATOR, joinCreators(dc.getCreators()));\n                }\n                if (dc.getSubjects() != null && dc.getSubjects().size() > 0) {\n                    Iterator<String> keywords = dc.getSubjects().iterator();\n                    while (keywords.hasNext()) {\n                        metadata.add(DublinCore.SUBJECT, keywords.next());\n                    }\n                   \n                   \n                }\n            }\n        } catch (IOException e) {\n           \n           \n           \n        }\n    }","cleancode":"public void parse(inputstream file) throws ioexception, tikaexception { bytearrayoutputstream xmpraw = new bytearrayoutputstream(); if (!scanner.parse(file, xmpraw)) { return; } reader decoded = new inputstreamreader( new bytearrayinputstream(xmpraw.tobytearray()), default_xmp_charset); try { xmpmetadata xmp = xmpmetadata.load(new inputsource(decoded)); xmpschemadublincore dc = xmp.getdublincoreschema(); if (dc != null) { if (dc.gettitle() != null) { metadata.set(dublincore.title, dc.gettitle()); } if (dc.getdescription() != null) { metadata.set(dublincore.description, dc.getdescription()); } if (dc.getcreators() != null && dc.getcreators().size() > 0) { metadata.set(dublincore.creator, joincreators(dc.getcreators())); } if (dc.getsubjects() != null && dc.getsubjects().size() > 0) { iterator<string> keywords = dc.getsubjects().iterator(); while (keywords.hasnext()) { metadata.add(dublincore.subject, keywords.next()); } } } } catch (ioexception e) { } }","comment":"\/\/ todo should we set keywords too? \/\/ all tested photo managers set the same in iptc.application2.keywords and xmp.dc.subject\n\/\/ could not parse embedded xmp metadata. that's not a serious \/\/ problem, so we'll just ignore the issue for now. \/\/ todo: make error handling like this configurable.","repo":"ontometrics\/tika","code_context_2":"metadata.add(DublinCore.SUBJECT, keywords.next());\n}\n\/\/ TODO should we set KEYWORDS too?\n\/\/ All tested photo managers set the same in Iptc.Application2.Keywords and Xmp.dc.subject\n}\n}\n\n}\n} catch (IOException e) {\n\/\/ Could not parse embedded XMP metadata. That's not a serious\n\/\/ problem, so we'll just ignore the issue for now.\n\/\/ TODO: Make error handling like this configurable.\n}\n}","code_context_10":"metadata.set(DublinCore.DESCRIPTION, dc.getDescription());\n}\nif (dc.getCreators() != null && dc.getCreators().size() > 0) {\nmetadata.set(DublinCore.CREATOR, joinCreators(dc.getCreators()));\n}\nif (dc.getSubjects() != null && dc.getSubjects().size() > 0) {\nIterator<String> keywords = dc.getSubjects().iterator();\nwhile (keywords.hasNext()) {\nmetadata.add(DublinCore.SUBJECT, keywords.next());\n}\n\/\/ TODO should we set KEYWORDS too?\n\/\/ All tested photo managers set the same in Iptc.Application2.Keywords and Xmp.dc.subject\n}\n}\n} catch (IOException e) {\n\/\/ Could not parse embedded XMP metadata. That's not a serious\n\/\/ problem, so we'll just ignore the issue for now.\n\/\/ TODO: Make error handling like this configurable.\n}\n}\n\nif (dc.getSubjects() != null && dc.getSubjects().size() > 0) {\nIterator<String> keywords = dc.getSubjects().iterator();\nwhile (keywords.hasNext()) {\nmetadata.add(DublinCore.SUBJECT, keywords.next());\n}\n\/\/ TODO should we set KEYWORDS too?\n\/\/ All tested photo managers set the same in Iptc.Application2.Keywords and Xmp.dc.subject\n}\n}\n} catch (IOException e) {\n\/\/ Could not parse embedded XMP metadata. That's not a serious\n\/\/ problem, so we'll just ignore the issue for now.\n\/\/ TODO: Make error handling like this configurable.\n}\n}","code_context_20":"new ByteArrayInputStream(xmpraw.toByteArray()),\nDEFAULT_XMP_CHARSET);\ntry {\nXMPMetadata xmp = XMPMetadata.load(new InputSource(decoded));\nXMPSchemaDublinCore dc = xmp.getDublinCoreSchema();\nif (dc != null) {\nif (dc.getTitle() != null) {\nmetadata.set(DublinCore.TITLE, dc.getTitle());\n}\nif (dc.getDescription() != null) {\nmetadata.set(DublinCore.DESCRIPTION, dc.getDescription());\n}\nif (dc.getCreators() != null && dc.getCreators().size() > 0) {\nmetadata.set(DublinCore.CREATOR, joinCreators(dc.getCreators()));\n}\nif (dc.getSubjects() != null && dc.getSubjects().size() > 0) {\nIterator<String> keywords = dc.getSubjects().iterator();\nwhile (keywords.hasNext()) {\nmetadata.add(DublinCore.SUBJECT, keywords.next());\n}\n\/\/ TODO should we set KEYWORDS too?\n\/\/ All tested photo managers set the same in Iptc.Application2.Keywords and Xmp.dc.subject\n}\n}\n} catch (IOException e) {\n\/\/ Could not parse embedded XMP metadata. That's not a serious\n\/\/ problem, so we'll just ignore the issue for now.\n\/\/ TODO: Make error handling like this configurable.\n}\n}\n\nif (dc != null) {\nif (dc.getTitle() != null) {\nmetadata.set(DublinCore.TITLE, dc.getTitle());\n}\nif (dc.getDescription() != null) {\nmetadata.set(DublinCore.DESCRIPTION, dc.getDescription());\n}\nif (dc.getCreators() != null && dc.getCreators().size() > 0) {\nmetadata.set(DublinCore.CREATOR, joinCreators(dc.getCreators()));\n}\nif (dc.getSubjects() != null && dc.getSubjects().size() > 0) {\nIterator<String> keywords = dc.getSubjects().iterator();\nwhile (keywords.hasNext()) {\nmetadata.add(DublinCore.SUBJECT, keywords.next());\n}\n\/\/ TODO should we set KEYWORDS too?\n\/\/ All tested photo managers set the same in Iptc.Application2.Keywords and Xmp.dc.subject\n}\n}\n} catch (IOException e) {\n\/\/ Could not parse embedded XMP metadata. That's not a serious\n\/\/ problem, so we'll just ignore the issue for now.\n\/\/ TODO: Make error handling like this configurable.\n}\n}","label":[1,1,0,0]}
{"id":9676,"original_code":"@Override\n    public List<Movie> getMoviesRatedByUser(int userId) {\n        \/\/ TODO: write query to retrieve all movies rated by user with id userId\n        List<Movie> movies = new LinkedList<Movie>();\n        Genre genre0 = new Genre(0, \"genre0\");\n        Genre genre1 = new Genre(1, \"genre1\");\n        Genre genre2 = new Genre(2, \"genre2\");\n        movies.add(new Movie(0, \"Titre 0\", Arrays.asList(new Genre[]{genre0, genre1})));\n        movies.add(new Movie(3, \"Titre 3\", Arrays.asList(new Genre[]{genre0, genre1, genre2})));\n        return movies;\n    }","code":"@Override\n    public List<Movie> getMoviesRatedByUser(int userId) {\n       \n        List<Movie> movies = new LinkedList<Movie>();\n        Genre genre0 = new Genre(0, \"genre0\");\n        Genre genre1 = new Genre(1, \"genre1\");\n        Genre genre2 = new Genre(2, \"genre2\");\n        movies.add(new Movie(0, \"Titre 0\", Arrays.asList(new Genre[]{genre0, genre1})));\n        movies.add(new Movie(3, \"Titre 3\", Arrays.asList(new Genre[]{genre0, genre1, genre2})));\n        return movies;\n    }","cleancode":"@override public list<movie> getmoviesratedbyuser(int userid) { list<movie> movies = new linkedlist<movie>(); genre genre0 = new genre(0, \"genre0\"); genre genre1 = new genre(1, \"genre1\"); genre genre2 = new genre(2, \"genre2\"); movies.add(new movie(0, \"titre 0\", arrays.aslist(new genre[]{genre0, genre1}))); movies.add(new movie(3, \"titre 3\", arrays.aslist(new genre[]{genre0, genre1, genre2}))); return movies; }","comment":"\/\/ todo: write query to retrieve all movies rated by user with id userid","repo":"quentinceschin123456\/MovieRecommender","code_context_2":"@Override\npublic List<Movie> getMoviesRatedByUser(int userId) {\n\/\/ TODO: write query to retrieve all movies rated by user with id userId\nList<Movie> movies = new LinkedList<Movie>();\nGenre genre0 = new Genre(0, \"genre0\");","code_context_10":"@Override\npublic List<Movie> getMoviesRatedByUser(int userId) {\n\/\/ TODO: write query to retrieve all movies rated by user with id userId\nList<Movie> movies = new LinkedList<Movie>();\nGenre genre0 = new Genre(0, \"genre0\");\nGenre genre1 = new Genre(1, \"genre1\");\nGenre genre2 = new Genre(2, \"genre2\");\nmovies.add(new Movie(0, \"Titre 0\", Arrays.asList(new Genre[]{genre0, genre1})));\nmovies.add(new Movie(3, \"Titre 3\", Arrays.asList(new Genre[]{genre0, genre1, genre2})));\nreturn movies;\n}","code_context_20":"@Override\npublic List<Movie> getMoviesRatedByUser(int userId) {\n\/\/ TODO: write query to retrieve all movies rated by user with id userId\nList<Movie> movies = new LinkedList<Movie>();\nGenre genre0 = new Genre(0, \"genre0\");\nGenre genre1 = new Genre(1, \"genre1\");\nGenre genre2 = new Genre(2, \"genre2\");\nmovies.add(new Movie(0, \"Titre 0\", Arrays.asList(new Genre[]{genre0, genre1})));\nmovies.add(new Movie(3, \"Titre 3\", Arrays.asList(new Genre[]{genre0, genre1, genre2})));\nreturn movies;\n}","label":[0,1,0,0]}
{"id":1545,"original_code":"public void execute(List<String> statements) throws MetaStoreException {\n    for (String statement : statements) {\n      execute(statement);\n    }\n  }","code":"public void execute(List<String> statements) throws MetaStoreException {\n    for (String statement : statements) {\n      execute(statement);\n    }\n  }","cleancode":"public void execute(list<string> statements) throws metastoreexception { for (string statement : statements) { execute(statement); } }","comment":"\/\/todo: optimize","repo":"plusplusjiajia\/SSM","code_context_2":"public void execute(List<String> statements) throws MetaStoreException {\nfor (String statement : statements) {\nexecute(statement);\n}\n}","code_context_10":"public void execute(List<String> statements) throws MetaStoreException {\nfor (String statement : statements) {\nexecute(statement);\n}\n}","code_context_20":"public void execute(List<String> statements) throws MetaStoreException {\nfor (String statement : statements) {\nexecute(statement);\n}\n}","label":[1,0,0,0]}
{"id":9749,"original_code":"@Test\n  public void testGetFormatted ()\n  {\n    IMutableCurrencyValue aCV = new CurrencyValue (ECurrency.EUR, MathHelper.toBigDecimal (5));\n    if (EJavaVersion.JDK_9.isSupportedVersion ())\n      assertEquals (\"5,00\" + CURRENCY_SPACE + \"\u20ac\", aCV.getCurrencyFormatted ());\n    else\n      assertEquals (\"\u20ac\" + CURRENCY_SPACE + \"5,00\", aCV.getCurrencyFormatted ());\n    aCV = new CurrencyValue (ECurrency.EUR, new BigDecimal (\"5.12\"));\n    if (EJavaVersion.JDK_9.isSupportedVersion ())\n      assertEquals (\"5,12\" + CURRENCY_SPACE + \"\u20ac\", aCV.getCurrencyFormatted ());\n    else\n      assertEquals (\"\u20ac\" + CURRENCY_SPACE + \"5,12\", aCV.getCurrencyFormatted ());\n    aCV = new CurrencyValue (ECurrency.USD, new BigDecimal (\"5.12\"));\n    assertEquals (\"$5.12\", aCV.getCurrencyFormatted ());\n    for (final ECurrency eCurrency : ECurrency.values ())\n    {\n      aCV = new CurrencyValue (eCurrency, new BigDecimal (\"5.12\"));\n      final String sCurrencyFormatted = aCV.getCurrencyFormatted ();\n      assertNotNull (sCurrencyFormatted);\n      final String sValueFormatted = aCV.getValueFormatted ();\n      assertNotNull (sValueFormatted);\n      assertTrue (sValueFormatted, sValueFormatted.indexOf (CurrencyHelper.getCurrencySymbol (eCurrency)) < 0);\n      CommonsTestHelper.testGetClone (aCV);\n      \/\/ There seems to be a bug in the optimizer of 1.6.0_45 so that the output\n      \/\/ values are sometimes reordered - dunno why :(\n      LOGGER.info (\"[\" + sCurrencyFormatted + \"][\" + sValueFormatted + \"]\");\n    }\n  }","code":"@Test\n  public void testGetFormatted ()\n  {\n    IMutableCurrencyValue aCV = new CurrencyValue (ECurrency.EUR, MathHelper.toBigDecimal (5));\n    if (EJavaVersion.JDK_9.isSupportedVersion ())\n      assertEquals (\"5,00\" + CURRENCY_SPACE + \"\u20ac\", aCV.getCurrencyFormatted ());\n    else\n      assertEquals (\"\u20ac\" + CURRENCY_SPACE + \"5,00\", aCV.getCurrencyFormatted ());\n    aCV = new CurrencyValue (ECurrency.EUR, new BigDecimal (\"5.12\"));\n    if (EJavaVersion.JDK_9.isSupportedVersion ())\n      assertEquals (\"5,12\" + CURRENCY_SPACE + \"\u20ac\", aCV.getCurrencyFormatted ());\n    else\n      assertEquals (\"\u20ac\" + CURRENCY_SPACE + \"5,12\", aCV.getCurrencyFormatted ());\n    aCV = new CurrencyValue (ECurrency.USD, new BigDecimal (\"5.12\"));\n    assertEquals (\"$5.12\", aCV.getCurrencyFormatted ());\n    for (final ECurrency eCurrency : ECurrency.values ())\n    {\n      aCV = new CurrencyValue (eCurrency, new BigDecimal (\"5.12\"));\n      final String sCurrencyFormatted = aCV.getCurrencyFormatted ();\n      assertNotNull (sCurrencyFormatted);\n      final String sValueFormatted = aCV.getValueFormatted ();\n      assertNotNull (sValueFormatted);\n      assertTrue (sValueFormatted, sValueFormatted.indexOf (CurrencyHelper.getCurrencySymbol (eCurrency)) < 0);\n      CommonsTestHelper.testGetClone (aCV);\n     \n     \n      LOGGER.info (\"[\" + sCurrencyFormatted + \"][\" + sValueFormatted + \"]\");\n    }\n  }","cleancode":"@test public void testgetformatted () { imutablecurrencyvalue acv = new currencyvalue (ecurrency.eur, mathhelper.tobigdecimal (5)); if (ejavaversion.jdk_9.issupportedversion ()) assertequals (\"5,00\" + currency_space + \"\u20ac\", acv.getcurrencyformatted ()); else assertequals (\"\u20ac\" + currency_space + \"5,00\", acv.getcurrencyformatted ()); acv = new currencyvalue (ecurrency.eur, new bigdecimal (\"5.12\")); if (ejavaversion.jdk_9.issupportedversion ()) assertequals (\"5,12\" + currency_space + \"\u20ac\", acv.getcurrencyformatted ()); else assertequals (\"\u20ac\" + currency_space + \"5,12\", acv.getcurrencyformatted ()); acv = new currencyvalue (ecurrency.usd, new bigdecimal (\"5.12\")); assertequals (\"$5.12\", acv.getcurrencyformatted ()); for (final ecurrency ecurrency : ecurrency.values ()) { acv = new currencyvalue (ecurrency, new bigdecimal (\"5.12\")); final string scurrencyformatted = acv.getcurrencyformatted (); assertnotnull (scurrencyformatted); final string svalueformatted = acv.getvalueformatted (); assertnotnull (svalueformatted); asserttrue (svalueformatted, svalueformatted.indexof (currencyhelper.getcurrencysymbol (ecurrency)) < 0); commonstesthelper.testgetclone (acv); logger.info (\"[\" + scurrencyformatted + \"][\" + svalueformatted + \"]\"); } }","comment":"\/\/ there seems to be a bug in the optimizer of 1.6.0_45 so that the output \/\/ values are sometimes reordered - dunno why :(","repo":"phax\/ph-masterdata","code_context_2":"assertTrue (sValueFormatted, sValueFormatted.indexOf (CurrencyHelper.getCurrencySymbol (eCurrency)) < 0);\nCommonsTestHelper.testGetClone (aCV);\n\/\/ There seems to be a bug in the optimizer of 1.6.0_45 so that the output\n\/\/ values are sometimes reordered - dunno why :(\nLOGGER.info (\"[\" + sCurrencyFormatted + \"][\" + sValueFormatted + \"]\");\n}","code_context_10":"assertEquals (\"$5.12\", aCV.getCurrencyFormatted ());\nfor (final ECurrency eCurrency : ECurrency.values ())\n{\naCV = new CurrencyValue (eCurrency, new BigDecimal (\"5.12\"));\nfinal String sCurrencyFormatted = aCV.getCurrencyFormatted ();\nassertNotNull (sCurrencyFormatted);\nfinal String sValueFormatted = aCV.getValueFormatted ();\nassertNotNull (sValueFormatted);\nassertTrue (sValueFormatted, sValueFormatted.indexOf (CurrencyHelper.getCurrencySymbol (eCurrency)) < 0);\nCommonsTestHelper.testGetClone (aCV);\n\/\/ There seems to be a bug in the optimizer of 1.6.0_45 so that the output\n\/\/ values are sometimes reordered - dunno why :(\nLOGGER.info (\"[\" + sCurrencyFormatted + \"][\" + sValueFormatted + \"]\");\n}\n}","code_context_20":"if (EJavaVersion.JDK_9.isSupportedVersion ())\nassertEquals (\"5,00\" + CURRENCY_SPACE + \"\u20ac\", aCV.getCurrencyFormatted ());\nelse\nassertEquals (\"\u20ac\" + CURRENCY_SPACE + \"5,00\", aCV.getCurrencyFormatted ());\naCV = new CurrencyValue (ECurrency.EUR, new BigDecimal (\"5.12\"));\nif (EJavaVersion.JDK_9.isSupportedVersion ())\nassertEquals (\"5,12\" + CURRENCY_SPACE + \"\u20ac\", aCV.getCurrencyFormatted ());\nelse\nassertEquals (\"\u20ac\" + CURRENCY_SPACE + \"5,12\", aCV.getCurrencyFormatted ());\naCV = new CurrencyValue (ECurrency.USD, new BigDecimal (\"5.12\"));\nassertEquals (\"$5.12\", aCV.getCurrencyFormatted ());\nfor (final ECurrency eCurrency : ECurrency.values ())\n{\naCV = new CurrencyValue (eCurrency, new BigDecimal (\"5.12\"));\nfinal String sCurrencyFormatted = aCV.getCurrencyFormatted ();\nassertNotNull (sCurrencyFormatted);\nfinal String sValueFormatted = aCV.getValueFormatted ();\nassertNotNull (sValueFormatted);\nassertTrue (sValueFormatted, sValueFormatted.indexOf (CurrencyHelper.getCurrencySymbol (eCurrency)) < 0);\nCommonsTestHelper.testGetClone (aCV);\n\/\/ There seems to be a bug in the optimizer of 1.6.0_45 so that the output\n\/\/ values are sometimes reordered - dunno why :(\nLOGGER.info (\"[\" + sCurrencyFormatted + \"][\" + sValueFormatted + \"]\");\n}\n}","label":[0,0,1,0]}
{"id":34357,"original_code":"List<CandidateField> findCandidateFieldsForType(@NonNull Object source) {\n        \/\/ At this point source class represents the true polymorphic type of the document\n        Class<?> sourceClass = source.getClass();\n        \/\/ Lock a thread wanting to find information about the same type\n        \/\/ So that this information retrieval is only done once\n        \/\/ Ignore this warning, this class reference will be on the heap\n        List<CandidateField> candidateFields = this.encryptedFieldsMap.get(sourceClass);\n        if (candidateFields != null) {\n            \/\/ The cache is already aware of this type, return candidate fields for it\n            return candidateFields;\n        }\n        \/\/ Don't bother with primitives\n        if (ClassUtils.isPrimitiveOrWrapper(sourceClass)) return Collections.emptyList();\n        \/\/ If it is not known, scan each field for annotation or Appsmith type\n        List<CandidateField> finalCandidateFields = new ArrayList<>();\n        synchronized (sourceClass) {\n            ReflectionUtils.doWithFields(sourceClass, field -> {\n                if (field.getAnnotation(Encrypted.class) != null) {\n                    CandidateField candidateField = new CandidateField(field, CandidateField.Type.ANNOTATED_FIELD);\n                    finalCandidateFields.add(candidateField);\n                } else if (AppsmithDomain.class.isAssignableFrom(field.getType())) {\n                    CandidateField candidateField = null;\n                    field.setAccessible(true);\n                    Object fieldValue = ReflectionUtils.getField(field, source);\n                    if (fieldValue == null) {\n                        if (this.encryptedFieldsMap.containsKey(field.getType())) {\n                            \/\/ If this field is null, but the cache has a non-empty list of candidates already,\n                            \/\/ then this is an appsmith field with known annotations\n                            candidateField = new CandidateField(field, CandidateField.Type.APPSMITH_FIELD_KNOWN);\n                        } else {\n                            \/\/ If it is null and the cache is not aware of the field, this is still a prospect,\n                            \/\/ but with an unknown type (could also be polymorphic)\n                            candidateField = new CandidateField(field, CandidateField.Type.APPSMITH_FIELD_UNKNOWN);\n                        }\n                    } else {\n                        \/\/ If an object exists, check if the object type is the same as the field type\n                        CandidateField.Type appsmithFieldType;\n                        if (field.getType().getCanonicalName().equals(fieldValue.getClass().getCanonicalName())) {\n                            \/\/ If they match, then this is going to be an appsmith known field\n                            appsmithFieldType = CandidateField.Type.APPSMITH_FIELD_KNOWN;\n                        } else {\n                            \/\/ If not, then this field is polymorphic,\n                            \/\/ it will need to be checked for type every time\n                            appsmithFieldType = CandidateField.Type.APPSMITH_FIELD_POLYMORPHIC;\n                        }\n                        \/\/ Now, go into field type and repeat\n                        List<CandidateField> candidateFieldsForType = findCandidateFieldsForType(fieldValue);\n                        if (appsmithFieldType.equals(CandidateField.Type.APPSMITH_FIELD_POLYMORPHIC)\n                                || !candidateFieldsForType.isEmpty()) {\n                            \/\/ This type only qualifies as a candidate if it is polymorphic,\n                            \/\/ or has a list of candidates\n                            candidateField = new CandidateField(field, appsmithFieldType);\n                        }\n                    }\n                    field.setAccessible(false);\n                    if (candidateField != null) {\n                        \/\/ This will only ever be null if the field value is populated,\n                        \/\/ and is known to be a non-encryption related field\n                        finalCandidateFields.add(candidateField);\n                    }\n                } else if (Collection.class.isAssignableFrom(field.getType()) &&\n                        field.getGenericType() instanceof ParameterizedType) {\n                    \/\/ If this is a collection, check if the Type parameter is an AppsmithDomain\n                    Type[] typeArguments;\n                    ParameterizedType parameterizedType = (ParameterizedType) field.getGenericType();\n                    typeArguments = parameterizedType.getActualTypeArguments();\n                    Class<?> subFieldType;\n                    try {\n                        subFieldType = (Class<?>) typeArguments[0];\n                    } catch (ClassCastException|ArrayIndexOutOfBoundsException e) {\n                        subFieldType = null;\n                    }\n                    if(subFieldType != null) {\n                        if (this.encryptedFieldsMap.containsKey(subFieldType)) {\n                            \/\/ This is a known type, it should necessarily be of AppsmithDomain type\n                            assert AppsmithDomain.class.isAssignableFrom(subFieldType);\n                            final List<CandidateField> existingSubTypeCandidates = this.encryptedFieldsMap.get(subFieldType);\n                            if (!existingSubTypeCandidates.isEmpty()) {\n                                finalCandidateFields.add(new CandidateField(field, CandidateField.Type.APPSMITH_COLLECTION_KNOWN));\n                            }\n                        } else if (AppsmithDomain.class.isAssignableFrom(subFieldType)) {\n                            \/\/ If the type is not known, then this is either not parsed yet, or has polymorphic implementations\n                            field.setAccessible(true);\n                            Object fieldValue = ReflectionUtils.getField(field, source);\n                            Collection<?> collection = (Collection<?>) fieldValue;\n                            if (collection == null || collection.isEmpty()) {\n                                finalCandidateFields.add(new CandidateField(field, CandidateField.Type.APPSMITH_COLLECTION_UNKNOWN));\n                            } else {\n                                for (final Object o : collection) {\n                                    if (o == null) {\n                                        continue;\n                                    }\n                                    if (o.getClass().getCanonicalName().equals(subFieldType.getTypeName())) {\n                                        final List<CandidateField> candidateFieldsForListMember = findCandidateFieldsForType(o);\n                                        if (candidateFieldsForListMember != null && !candidateFieldsForListMember.isEmpty()) {\n                                            finalCandidateFields.add(new CandidateField(field, CandidateField.Type.APPSMITH_COLLECTION_KNOWN));\n                                        }\n                                    } else {\n                                        finalCandidateFields.add(new CandidateField(field, CandidateField.Type.APPSMITH_COLLECTION_POLYMORPHIC));\n                                    }\n                                    break;\n                                }\n                            }\n                            field.setAccessible(false);\n                        }\n                    }\n                    \/\/ TODO Add support for nested collections\n                } else if (Map.class.isAssignableFrom(field.getType()) &&\n                        field.getGenericType() instanceof ParameterizedType) {\n                    Type[] typeArguments;\n                    ParameterizedType parameterizedType = (ParameterizedType) field.getGenericType();\n                    typeArguments = parameterizedType.getActualTypeArguments();\n                    Class<?> subFieldType = (Class<?>) typeArguments[1];\n                    if (this.encryptedFieldsMap.containsKey(subFieldType)) {\n                        \/\/ This is a known type, it should necessarily be of AppsmithDomain type\n                        assert AppsmithDomain.class.isAssignableFrom(subFieldType);\n                        final List<CandidateField> existingSubTypeCandidates = this.encryptedFieldsMap.get(subFieldType);\n                        if (!existingSubTypeCandidates.isEmpty()) {\n                            finalCandidateFields.add(new CandidateField(field, CandidateField.Type.APPSMITH_MAP_KNOWN));\n                        }\n                    } else if (AppsmithDomain.class.isAssignableFrom(subFieldType)) {\n                        \/\/ If the type is not known, then this is either not parsed yet, or has polymorphic implementations\n                        field.setAccessible(true);\n                        Object fieldValue = ReflectionUtils.getField(field, source);\n                        Map<?, ?> map = (Map<?, ?>) fieldValue;\n                        if (map == null || map.isEmpty()) {\n                            finalCandidateFields.add(new CandidateField(field, CandidateField.Type.APPSMITH_MAP_UNKNOWN));\n                        } else {\n                            for (Map.Entry<?, ?> entry : map.entrySet()) {\n                                final Object value = entry.getValue();\n                                if (value == null) {\n                                    continue;\n                                }\n                                if (value.getClass().getCanonicalName().equals(subFieldType.getTypeName())) {\n                                    final List<CandidateField> candidateFieldsForListMember = findCandidateFieldsForType(value);\n                                    if (candidateFieldsForListMember != null && !candidateFieldsForListMember.isEmpty()) {\n                                        finalCandidateFields.add(new CandidateField(field, CandidateField.Type.APPSMITH_MAP_KNOWN));\n                                    }\n                                } else {\n                                    finalCandidateFields.add(new CandidateField(field, CandidateField.Type.APPSMITH_MAP_POLYMORPHIC));\n                                }\n                                break;\n                            }\n                        }\n                        field.setAccessible(false);\n                    }\n                }\n            }, field -> field.getAnnotation(Encrypted.class) != null ||\n                    AppsmithDomain.class.isAssignableFrom(field.getType()) ||\n                    Collection.class.isAssignableFrom(field.getType()) ||\n                    Map.class.isAssignableFrom(field.getType()));\n        }\n        \/\/ Update cache for next use\n        encryptedFieldsMap.put(sourceClass, finalCandidateFields);\n        return finalCandidateFields;\n    }","code":"List<CandidateField> findCandidateFieldsForType(@NonNull Object source) {\n       \n        Class<?> sourceClass = source.getClass();\n       \n       \n       \n        List<CandidateField> candidateFields = this.encryptedFieldsMap.get(sourceClass);\n        if (candidateFields != null) {\n           \n            return candidateFields;\n        }\n       \n        if (ClassUtils.isPrimitiveOrWrapper(sourceClass)) return Collections.emptyList();\n       \n        List<CandidateField> finalCandidateFields = new ArrayList<>();\n        synchronized (sourceClass) {\n            ReflectionUtils.doWithFields(sourceClass, field -> {\n                if (field.getAnnotation(Encrypted.class) != null) {\n                    CandidateField candidateField = new CandidateField(field, CandidateField.Type.ANNOTATED_FIELD);\n                    finalCandidateFields.add(candidateField);\n                } else if (AppsmithDomain.class.isAssignableFrom(field.getType())) {\n                    CandidateField candidateField = null;\n                    field.setAccessible(true);\n                    Object fieldValue = ReflectionUtils.getField(field, source);\n                    if (fieldValue == null) {\n                        if (this.encryptedFieldsMap.containsKey(field.getType())) {\n                           \n                           \n                            candidateField = new CandidateField(field, CandidateField.Type.APPSMITH_FIELD_KNOWN);\n                        } else {\n                           \n                           \n                            candidateField = new CandidateField(field, CandidateField.Type.APPSMITH_FIELD_UNKNOWN);\n                        }\n                    } else {\n                       \n                        CandidateField.Type appsmithFieldType;\n                        if (field.getType().getCanonicalName().equals(fieldValue.getClass().getCanonicalName())) {\n                           \n                            appsmithFieldType = CandidateField.Type.APPSMITH_FIELD_KNOWN;\n                        } else {\n                           \n                           \n                            appsmithFieldType = CandidateField.Type.APPSMITH_FIELD_POLYMORPHIC;\n                        }\n                       \n                        List<CandidateField> candidateFieldsForType = findCandidateFieldsForType(fieldValue);\n                        if (appsmithFieldType.equals(CandidateField.Type.APPSMITH_FIELD_POLYMORPHIC)\n                                || !candidateFieldsForType.isEmpty()) {\n                           \n                           \n                            candidateField = new CandidateField(field, appsmithFieldType);\n                        }\n                    }\n                    field.setAccessible(false);\n                    if (candidateField != null) {\n                       \n                       \n                        finalCandidateFields.add(candidateField);\n                    }\n                } else if (Collection.class.isAssignableFrom(field.getType()) &&\n                        field.getGenericType() instanceof ParameterizedType) {\n                   \n                    Type[] typeArguments;\n                    ParameterizedType parameterizedType = (ParameterizedType) field.getGenericType();\n                    typeArguments = parameterizedType.getActualTypeArguments();\n                    Class<?> subFieldType;\n                    try {\n                        subFieldType = (Class<?>) typeArguments[0];\n                    } catch (ClassCastException|ArrayIndexOutOfBoundsException e) {\n                        subFieldType = null;\n                    }\n                    if(subFieldType != null) {\n                        if (this.encryptedFieldsMap.containsKey(subFieldType)) {\n                           \n                            assert AppsmithDomain.class.isAssignableFrom(subFieldType);\n                            final List<CandidateField> existingSubTypeCandidates = this.encryptedFieldsMap.get(subFieldType);\n                            if (!existingSubTypeCandidates.isEmpty()) {\n                                finalCandidateFields.add(new CandidateField(field, CandidateField.Type.APPSMITH_COLLECTION_KNOWN));\n                            }\n                        } else if (AppsmithDomain.class.isAssignableFrom(subFieldType)) {\n                           \n                            field.setAccessible(true);\n                            Object fieldValue = ReflectionUtils.getField(field, source);\n                            Collection<?> collection = (Collection<?>) fieldValue;\n                            if (collection == null || collection.isEmpty()) {\n                                finalCandidateFields.add(new CandidateField(field, CandidateField.Type.APPSMITH_COLLECTION_UNKNOWN));\n                            } else {\n                                for (final Object o : collection) {\n                                    if (o == null) {\n                                        continue;\n                                    }\n                                    if (o.getClass().getCanonicalName().equals(subFieldType.getTypeName())) {\n                                        final List<CandidateField> candidateFieldsForListMember = findCandidateFieldsForType(o);\n                                        if (candidateFieldsForListMember != null && !candidateFieldsForListMember.isEmpty()) {\n                                            finalCandidateFields.add(new CandidateField(field, CandidateField.Type.APPSMITH_COLLECTION_KNOWN));\n                                        }\n                                    } else {\n                                        finalCandidateFields.add(new CandidateField(field, CandidateField.Type.APPSMITH_COLLECTION_POLYMORPHIC));\n                                    }\n                                    break;\n                                }\n                            }\n                            field.setAccessible(false);\n                        }\n                    }\n                   \n                } else if (Map.class.isAssignableFrom(field.getType()) &&\n                        field.getGenericType() instanceof ParameterizedType) {\n                    Type[] typeArguments;\n                    ParameterizedType parameterizedType = (ParameterizedType) field.getGenericType();\n                    typeArguments = parameterizedType.getActualTypeArguments();\n                    Class<?> subFieldType = (Class<?>) typeArguments[1];\n                    if (this.encryptedFieldsMap.containsKey(subFieldType)) {\n                       \n                        assert AppsmithDomain.class.isAssignableFrom(subFieldType);\n                        final List<CandidateField> existingSubTypeCandidates = this.encryptedFieldsMap.get(subFieldType);\n                        if (!existingSubTypeCandidates.isEmpty()) {\n                            finalCandidateFields.add(new CandidateField(field, CandidateField.Type.APPSMITH_MAP_KNOWN));\n                        }\n                    } else if (AppsmithDomain.class.isAssignableFrom(subFieldType)) {\n                       \n                        field.setAccessible(true);\n                        Object fieldValue = ReflectionUtils.getField(field, source);\n                        Map<?, ?> map = (Map<?, ?>) fieldValue;\n                        if (map == null || map.isEmpty()) {\n                            finalCandidateFields.add(new CandidateField(field, CandidateField.Type.APPSMITH_MAP_UNKNOWN));\n                        } else {\n                            for (Map.Entry<?, ?> entry : map.entrySet()) {\n                                final Object value = entry.getValue();\n                                if (value == null) {\n                                    continue;\n                                }\n                                if (value.getClass().getCanonicalName().equals(subFieldType.getTypeName())) {\n                                    final List<CandidateField> candidateFieldsForListMember = findCandidateFieldsForType(value);\n                                    if (candidateFieldsForListMember != null && !candidateFieldsForListMember.isEmpty()) {\n                                        finalCandidateFields.add(new CandidateField(field, CandidateField.Type.APPSMITH_MAP_KNOWN));\n                                    }\n                                } else {\n                                    finalCandidateFields.add(new CandidateField(field, CandidateField.Type.APPSMITH_MAP_POLYMORPHIC));\n                                }\n                                break;\n                            }\n                        }\n                        field.setAccessible(false);\n                    }\n                }\n            }, field -> field.getAnnotation(Encrypted.class) != null ||\n                    AppsmithDomain.class.isAssignableFrom(field.getType()) ||\n                    Collection.class.isAssignableFrom(field.getType()) ||\n                    Map.class.isAssignableFrom(field.getType()));\n        }\n       \n        encryptedFieldsMap.put(sourceClass, finalCandidateFields);\n        return finalCandidateFields;\n    }","cleancode":"list<candidatefield> findcandidatefieldsfortype(@nonnull object source) { class<?> sourceclass = source.getclass(); list<candidatefield> candidatefields = this.encryptedfieldsmap.get(sourceclass); if (candidatefields != null) { return candidatefields; } if (classutils.isprimitiveorwrapper(sourceclass)) return collections.emptylist(); list<candidatefield> finalcandidatefields = new arraylist<>(); synchronized (sourceclass) { reflectionutils.dowithfields(sourceclass, field -> { if (field.getannotation(encrypted.class) != null) { candidatefield candidatefield = new candidatefield(field, candidatefield.type.annotated_field); finalcandidatefields.add(candidatefield); } else if (appsmithdomain.class.isassignablefrom(field.gettype())) { candidatefield candidatefield = null; field.setaccessible(true); object fieldvalue = reflectionutils.getfield(field, source); if (fieldvalue == null) { if (this.encryptedfieldsmap.containskey(field.gettype())) { candidatefield = new candidatefield(field, candidatefield.type.appsmith_field_known); } else { candidatefield = new candidatefield(field, candidatefield.type.appsmith_field_unknown); } } else { candidatefield.type appsmithfieldtype; if (field.gettype().getcanonicalname().equals(fieldvalue.getclass().getcanonicalname())) { appsmithfieldtype = candidatefield.type.appsmith_field_known; } else { appsmithfieldtype = candidatefield.type.appsmith_field_polymorphic; } list<candidatefield> candidatefieldsfortype = findcandidatefieldsfortype(fieldvalue); if (appsmithfieldtype.equals(candidatefield.type.appsmith_field_polymorphic) || !candidatefieldsfortype.isempty()) { candidatefield = new candidatefield(field, appsmithfieldtype); } } field.setaccessible(false); if (candidatefield != null) { finalcandidatefields.add(candidatefield); } } else if (collection.class.isassignablefrom(field.gettype()) && field.getgenerictype() instanceof parameterizedtype) { type[] typearguments; parameterizedtype parameterizedtype = (parameterizedtype) field.getgenerictype(); typearguments = parameterizedtype.getactualtypearguments(); class<?> subfieldtype; try { subfieldtype = (class<?>) typearguments[0]; } catch (classcastexception|arrayindexoutofboundsexception e) { subfieldtype = null; } if(subfieldtype != null) { if (this.encryptedfieldsmap.containskey(subfieldtype)) { assert appsmithdomain.class.isassignablefrom(subfieldtype); final list<candidatefield> existingsubtypecandidates = this.encryptedfieldsmap.get(subfieldtype); if (!existingsubtypecandidates.isempty()) { finalcandidatefields.add(new candidatefield(field, candidatefield.type.appsmith_collection_known)); } } else if (appsmithdomain.class.isassignablefrom(subfieldtype)) { field.setaccessible(true); object fieldvalue = reflectionutils.getfield(field, source); collection<?> collection = (collection<?>) fieldvalue; if (collection == null || collection.isempty()) { finalcandidatefields.add(new candidatefield(field, candidatefield.type.appsmith_collection_unknown)); } else { for (final object o : collection) { if (o == null) { continue; } if (o.getclass().getcanonicalname().equals(subfieldtype.gettypename())) { final list<candidatefield> candidatefieldsforlistmember = findcandidatefieldsfortype(o); if (candidatefieldsforlistmember != null && !candidatefieldsforlistmember.isempty()) { finalcandidatefields.add(new candidatefield(field, candidatefield.type.appsmith_collection_known)); } } else { finalcandidatefields.add(new candidatefield(field, candidatefield.type.appsmith_collection_polymorphic)); } break; } } field.setaccessible(false); } } } else if (map.class.isassignablefrom(field.gettype()) && field.getgenerictype() instanceof parameterizedtype) { type[] typearguments; parameterizedtype parameterizedtype = (parameterizedtype) field.getgenerictype(); typearguments = parameterizedtype.getactualtypearguments(); class<?> subfieldtype = (class<?>) typearguments[1]; if (this.encryptedfieldsmap.containskey(subfieldtype)) { assert appsmithdomain.class.isassignablefrom(subfieldtype); final list<candidatefield> existingsubtypecandidates = this.encryptedfieldsmap.get(subfieldtype); if (!existingsubtypecandidates.isempty()) { finalcandidatefields.add(new candidatefield(field, candidatefield.type.appsmith_map_known)); } } else if (appsmithdomain.class.isassignablefrom(subfieldtype)) { field.setaccessible(true); object fieldvalue = reflectionutils.getfield(field, source); map<?, ?> map = (map<?, ?>) fieldvalue; if (map == null || map.isempty()) { finalcandidatefields.add(new candidatefield(field, candidatefield.type.appsmith_map_unknown)); } else { for (map.entry<?, ?> entry : map.entryset()) { final object value = entry.getvalue(); if (value == null) { continue; } if (value.getclass().getcanonicalname().equals(subfieldtype.gettypename())) { final list<candidatefield> candidatefieldsforlistmember = findcandidatefieldsfortype(value); if (candidatefieldsforlistmember != null && !candidatefieldsforlistmember.isempty()) { finalcandidatefields.add(new candidatefield(field, candidatefield.type.appsmith_map_known)); } } else { finalcandidatefields.add(new candidatefield(field, candidatefield.type.appsmith_map_polymorphic)); } break; } } field.setaccessible(false); } } }, field -> field.getannotation(encrypted.class) != null || appsmithdomain.class.isassignablefrom(field.gettype()) || collection.class.isassignablefrom(field.gettype()) || map.class.isassignablefrom(field.gettype())); } encryptedfieldsmap.put(sourceclass, finalcandidatefields); return finalcandidatefields; }","comment":"\/** * this method finds all the candidate fields for a given type * candidate fields will ony ever be fields that have either been directly annotated, * or are custom appsmith types (and can hence have fields annotated for encryption within them), * or are parameterized collections of custom appsmith types, * or are parameterized maps with custom appsmith type values (keys are not scanned for encrypted fields) * * @param source document that needs to be checked for encrypted annotations * @return list of candidate fields for the given type and null if this list can not be found at this time *\/\n\/\/ at this point source class represents the true polymorphic type of the document\n\/\/ lock a thread wanting to find information about the same type \/\/ so that this information retrieval is only done once \/\/ ignore this warning, this class reference will be on the heap\n\/\/ the cache is already aware of this type, return candidate fields for it\n\/\/ don't bother with primitives\n\/\/ if it is not known, scan each field for annotation or appsmith type\n\/\/ if this field is null, but the cache has a non-empty list of candidates already, \/\/ then this is an appsmith field with known annotations\n\/\/ if it is null and the cache is not aware of the field, this is still a prospect, \/\/ but with an unknown type (could also be polymorphic)\n\/\/ if an object exists, check if the object type is the same as the field type\n\/\/ if they match, then this is going to be an appsmith known field\n\/\/ if not, then this field is polymorphic, \/\/ it will need to be checked for type every time\n\/\/ now, go into field type and repeat\n\/\/ this type only qualifies as a candidate if it is polymorphic, \/\/ or has a list of candidates\n\/\/ this will only ever be null if the field value is populated, \/\/ and is known to be a non-encryption related field\n\/\/ if this is a collection, check if the type parameter is an appsmithdomain\n\/\/ this is a known type, it should necessarily be of appsmithdomain type\n\/\/ if the type is not known, then this is either not parsed yet, or has polymorphic implementations\n\/\/ todo add support for nested collections\n\/\/ this is a known type, it should necessarily be of appsmithdomain type\n\/\/ if the type is not known, then this is either not parsed yet, or has polymorphic implementations\n\/\/ update cache for next use","repo":"profencer\/appsmith","code_context_2":"List<CandidateField> findCandidateFieldsForType(@NonNull Object source) {\n\/\/ At this point source class represents the true polymorphic type of the document\nClass<?> sourceClass = source.getClass();\n\/\/ Lock a thread wanting to find information about the same type\n\/\/ So that this information retrieval is only done once\n\/\/ Ignore this warning, this class reference will be on the heap\nList<CandidateField> candidateFields = this.encryptedFieldsMap.get(sourceClass);\nif (candidateFields != null) {\n\/\/ The cache is already aware of this type, return candidate fields for it\nreturn candidateFields;\n}\n\/\/ Don't bother with primitives\nif (ClassUtils.isPrimitiveOrWrapper(sourceClass)) return Collections.emptyList();\n\/\/ If it is not known, scan each field for annotation or Appsmith type\nList<CandidateField> finalCandidateFields = new ArrayList<>();\nsynchronized (sourceClass) {\nReflectionUtils.doWithFields(sourceClass, field -> {\nif (field.getAnnotation(Encrypted.class) != null) {\nCandidateField candidateField = new CandidateField(field, CandidateField.Type.ANNOTATED_FIELD);\nfinalCandidateFields.add(candidateField);\n} else if (AppsmithDomain.class.isAssignableFrom(field.getType())) {\nCandidateField candidateField = null;\nfield.setAccessible(true);\nObject fieldValue = ReflectionUtils.getField(field, source);\nif (fieldValue == null) {\nif (this.encryptedFieldsMap.containsKey(field.getType())) {\n\/\/ If this field is null, but the cache has a non-empty list of candidates already,\n\/\/ then this is an appsmith field with known annotations\ncandidateField = new CandidateField(field, CandidateField.Type.APPSMITH_FIELD_KNOWN);\n} else {\n\/\/ If it is null and the cache is not aware of the field, this is still a prospect,\n\/\/ but with an unknown type (could also be polymorphic)\ncandidateField = new CandidateField(field, CandidateField.Type.APPSMITH_FIELD_UNKNOWN);\n}\n} else {\n\/\/ If an object exists, check if the object type is the same as the field type\nCandidateField.Type appsmithFieldType;\nif (field.getType().getCanonicalName().equals(fieldValue.getClass().getCanonicalName())) {\n\/\/ If they match, then this is going to be an appsmith known field\nappsmithFieldType = CandidateField.Type.APPSMITH_FIELD_KNOWN;\n} else {\n\/\/ If not, then this field is polymorphic,\n\/\/ it will need to be checked for type every time\nappsmithFieldType = CandidateField.Type.APPSMITH_FIELD_POLYMORPHIC;\n}\n\/\/ Now, go into field type and repeat\nList<CandidateField> candidateFieldsForType = findCandidateFieldsForType(fieldValue);\nif (appsmithFieldType.equals(CandidateField.Type.APPSMITH_FIELD_POLYMORPHIC)\n|| !candidateFieldsForType.isEmpty()) {\n\/\/ This type only qualifies as a candidate if it is polymorphic,\n\/\/ or has a list of candidates\ncandidateField = new CandidateField(field, appsmithFieldType);\n}\n}\nfield.setAccessible(false);\nif (candidateField != null) {\n\/\/ This will only ever be null if the field value is populated,\n\/\/ and is known to be a non-encryption related field\nfinalCandidateFields.add(candidateField);\n}\n} else if (Collection.class.isAssignableFrom(field.getType()) &&\nfield.getGenericType() instanceof ParameterizedType) {\n\/\/ If this is a collection, check if the Type parameter is an AppsmithDomain\nType[] typeArguments;\nParameterizedType parameterizedType = (ParameterizedType) field.getGenericType();\ntypeArguments = parameterizedType.getActualTypeArguments();\nClass<?> subFieldType;\ntry {\nsubFieldType = (Class<?>) typeArguments[0];\n} catch (ClassCastException|ArrayIndexOutOfBoundsException e) {\nsubFieldType = null;\n}\nif(subFieldType != null) {\nif (this.encryptedFieldsMap.containsKey(subFieldType)) {\n\/\/ This is a known type, it should necessarily be of AppsmithDomain type\nassert AppsmithDomain.class.isAssignableFrom(subFieldType);\nfinal List<CandidateField> existingSubTypeCandidates = this.encryptedFieldsMap.get(subFieldType);\nif (!existingSubTypeCandidates.isEmpty()) {\nfinalCandidateFields.add(new CandidateField(field, CandidateField.Type.APPSMITH_COLLECTION_KNOWN));\n}\n} else if (AppsmithDomain.class.isAssignableFrom(subFieldType)) {\n\/\/ If the type is not known, then this is either not parsed yet, or has polymorphic implementations\nfield.setAccessible(true);\nObject fieldValue = ReflectionUtils.getField(field, source);\nCollection<?> collection = (Collection<?>) fieldValue;\nif (collection == null || collection.isEmpty()) {\nfinalCandidateFields.add(new CandidateField(field, CandidateField.Type.APPSMITH_COLLECTION_UNKNOWN));\n} else {\nfor (final Object o : collection) {\nif (o == null) {\ncontinue;\n}\nif (o.getClass().getCanonicalName().equals(subFieldType.getTypeName())) {\nfinal List<CandidateField> candidateFieldsForListMember = findCandidateFieldsForType(o);\nif (candidateFieldsForListMember != null && !candidateFieldsForListMember.isEmpty()) {\nfinalCandidateFields.add(new CandidateField(field, CandidateField.Type.APPSMITH_COLLECTION_KNOWN));\n}\n} else {\nfinalCandidateFields.add(new CandidateField(field, CandidateField.Type.APPSMITH_COLLECTION_POLYMORPHIC));\n}\nbreak;\n}\n}\nfield.setAccessible(false);\n}\n}\n\/\/ TODO Add support for nested collections\n} else if (Map.class.isAssignableFrom(field.getType()) &&\nfield.getGenericType() instanceof ParameterizedType) {\nType[] typeArguments;\nParameterizedType parameterizedType = (ParameterizedType) field.getGenericType();\ntypeArguments = parameterizedType.getActualTypeArguments();\nClass<?> subFieldType = (Class<?>) typeArguments[1];\nif (this.encryptedFieldsMap.containsKey(subFieldType)) {\n\/\/ This is a known type, it should necessarily be of AppsmithDomain type\nassert AppsmithDomain.class.isAssignableFrom(subFieldType);\nfinal List<CandidateField> existingSubTypeCandidates = this.encryptedFieldsMap.get(subFieldType);\nif (!existingSubTypeCandidates.isEmpty()) {\nfinalCandidateFields.add(new CandidateField(field, CandidateField.Type.APPSMITH_MAP_KNOWN));\n}\n} else if (AppsmithDomain.class.isAssignableFrom(subFieldType)) {\n\/\/ If the type is not known, then this is either not parsed yet, or has polymorphic implementations\nfield.setAccessible(true);\nObject fieldValue = ReflectionUtils.getField(field, source);\nMap<?, ?> map = (Map<?, ?>) fieldValue;\nif (map == null || map.isEmpty()) {\nfinalCandidateFields.add(new CandidateField(field, CandidateField.Type.APPSMITH_MAP_UNKNOWN));\n} else {\nfor (Map.Entry<?, ?> entry : map.entrySet()) {\nfinal Object value = entry.getValue();\nif (value == null) {\ncontinue;\n}\nif (value.getClass().getCanonicalName().equals(subFieldType.getTypeName())) {\nfinal List<CandidateField> candidateFieldsForListMember = findCandidateFieldsForType(value);\nif (candidateFieldsForListMember != null && !candidateFieldsForListMember.isEmpty()) {\nfinalCandidateFields.add(new CandidateField(field, CandidateField.Type.APPSMITH_MAP_KNOWN));\n}\n} else {\nfinalCandidateFields.add(new CandidateField(field, CandidateField.Type.APPSMITH_MAP_POLYMORPHIC));\n}\nbreak;\n}\n}\nfield.setAccessible(false);\n}\n}\n}, field -> field.getAnnotation(Encrypted.class) != null ||\nAppsmithDomain.class.isAssignableFrom(field.getType()) ||\nCollection.class.isAssignableFrom(field.getType()) ||\nMap.class.isAssignableFrom(field.getType()));\n}\n\/\/ Update cache for next use\nencryptedFieldsMap.put(sourceClass, finalCandidateFields);\nreturn finalCandidateFields;\n}\n\nList<CandidateField> findCandidateFieldsForType(@NonNull Object source) {\n\/\/ At this point source class represents the true polymorphic type of the document\nClass<?> sourceClass = source.getClass();\n\/\/ Lock a thread wanting to find information about the same type\n\n\/\/ At this point source class represents the true polymorphic type of the document\nClass<?> sourceClass = source.getClass();\n\/\/ Lock a thread wanting to find information about the same type\n\/\/ So that this information retrieval is only done once\n\/\/ Ignore this warning, this class reference will be on the heap\nList<CandidateField> candidateFields = this.encryptedFieldsMap.get(sourceClass);\nif (candidateFields != null) {\n\nList<CandidateField> candidateFields = this.encryptedFieldsMap.get(sourceClass);\nif (candidateFields != null) {\n\/\/ The cache is already aware of this type, return candidate fields for it\nreturn candidateFields;\n}\n\nreturn candidateFields;\n}\n\/\/ Don't bother with primitives\nif (ClassUtils.isPrimitiveOrWrapper(sourceClass)) return Collections.emptyList();\n\/\/ If it is not known, scan each field for annotation or Appsmith type\n\n\/\/ Don't bother with primitives\nif (ClassUtils.isPrimitiveOrWrapper(sourceClass)) return Collections.emptyList();\n\/\/ If it is not known, scan each field for annotation or Appsmith type\nList<CandidateField> finalCandidateFields = new ArrayList<>();\nsynchronized (sourceClass) {\n\nif (fieldValue == null) {\nif (this.encryptedFieldsMap.containsKey(field.getType())) {\n\/\/ If this field is null, but the cache has a non-empty list of candidates already,\n\/\/ then this is an appsmith field with known annotations\ncandidateField = new CandidateField(field, CandidateField.Type.APPSMITH_FIELD_KNOWN);\n} else {\n\ncandidateField = new CandidateField(field, CandidateField.Type.APPSMITH_FIELD_KNOWN);\n} else {\n\/\/ If it is null and the cache is not aware of the field, this is still a prospect,\n\/\/ but with an unknown type (could also be polymorphic)\ncandidateField = new CandidateField(field, CandidateField.Type.APPSMITH_FIELD_UNKNOWN);\n}\n\n}\n} else {\n\/\/ If an object exists, check if the object type is the same as the field type\nCandidateField.Type appsmithFieldType;\nif (field.getType().getCanonicalName().equals(fieldValue.getClass().getCanonicalName())) {\n\nCandidateField.Type appsmithFieldType;\nif (field.getType().getCanonicalName().equals(fieldValue.getClass().getCanonicalName())) {\n\/\/ If they match, then this is going to be an appsmith known field\nappsmithFieldType = CandidateField.Type.APPSMITH_FIELD_KNOWN;\n} else {\n\nappsmithFieldType = CandidateField.Type.APPSMITH_FIELD_KNOWN;\n} else {\n\/\/ If not, then this field is polymorphic,\n\/\/ it will need to be checked for type every time\nappsmithFieldType = CandidateField.Type.APPSMITH_FIELD_POLYMORPHIC;\n}\n\nappsmithFieldType = CandidateField.Type.APPSMITH_FIELD_POLYMORPHIC;\n}\n\/\/ Now, go into field type and repeat\nList<CandidateField> candidateFieldsForType = findCandidateFieldsForType(fieldValue);\nif (appsmithFieldType.equals(CandidateField.Type.APPSMITH_FIELD_POLYMORPHIC)\n\nif (appsmithFieldType.equals(CandidateField.Type.APPSMITH_FIELD_POLYMORPHIC)\n|| !candidateFieldsForType.isEmpty()) {\n\/\/ This type only qualifies as a candidate if it is polymorphic,\n\/\/ or has a list of candidates\ncandidateField = new CandidateField(field, appsmithFieldType);\n}\n\nfield.setAccessible(false);\nif (candidateField != null) {\n\/\/ This will only ever be null if the field value is populated,\n\/\/ and is known to be a non-encryption related field\nfinalCandidateFields.add(candidateField);\n}\n\n} else if (Collection.class.isAssignableFrom(field.getType()) &&\nfield.getGenericType() instanceof ParameterizedType) {\n\/\/ If this is a collection, check if the Type parameter is an AppsmithDomain\nType[] typeArguments;\nParameterizedType parameterizedType = (ParameterizedType) field.getGenericType();\n\nif(subFieldType != null) {\nif (this.encryptedFieldsMap.containsKey(subFieldType)) {\n\/\/ This is a known type, it should necessarily be of AppsmithDomain type\nassert AppsmithDomain.class.isAssignableFrom(subFieldType);\nfinal List<CandidateField> existingSubTypeCandidates = this.encryptedFieldsMap.get(subFieldType);\n\n}\n} else if (AppsmithDomain.class.isAssignableFrom(subFieldType)) {\n\/\/ If the type is not known, then this is either not parsed yet, or has polymorphic implementations\nfield.setAccessible(true);\nObject fieldValue = ReflectionUtils.getField(field, source);\n\n}\n}\n\/\/ TODO Add support for nested collections\n} else if (Map.class.isAssignableFrom(field.getType()) &&\nfield.getGenericType() instanceof ParameterizedType) {\n\nif(subFieldType != null) {\nif (this.encryptedFieldsMap.containsKey(subFieldType)) {\n\/\/ This is a known type, it should necessarily be of AppsmithDomain type\nassert AppsmithDomain.class.isAssignableFrom(subFieldType);\nfinal List<CandidateField> existingSubTypeCandidates = this.encryptedFieldsMap.get(subFieldType);\n\n}\n} else if (AppsmithDomain.class.isAssignableFrom(subFieldType)) {\n\/\/ If the type is not known, then this is either not parsed yet, or has polymorphic implementations\nfield.setAccessible(true);\nObject fieldValue = ReflectionUtils.getField(field, source);\n\nMap.class.isAssignableFrom(field.getType()));\n}\n\/\/ Update cache for next use\nencryptedFieldsMap.put(sourceClass, finalCandidateFields);\nreturn finalCandidateFields;","code_context_10":"List<CandidateField> findCandidateFieldsForType(@NonNull Object source) {\n\/\/ At this point source class represents the true polymorphic type of the document\nClass<?> sourceClass = source.getClass();\n\/\/ Lock a thread wanting to find information about the same type\n\/\/ So that this information retrieval is only done once\n\/\/ Ignore this warning, this class reference will be on the heap\nList<CandidateField> candidateFields = this.encryptedFieldsMap.get(sourceClass);\nif (candidateFields != null) {\n\/\/ The cache is already aware of this type, return candidate fields for it\nreturn candidateFields;\n}\n\/\/ Don't bother with primitives\nif (ClassUtils.isPrimitiveOrWrapper(sourceClass)) return Collections.emptyList();\n\/\/ If it is not known, scan each field for annotation or Appsmith type\nList<CandidateField> finalCandidateFields = new ArrayList<>();\nsynchronized (sourceClass) {\nReflectionUtils.doWithFields(sourceClass, field -> {\nif (field.getAnnotation(Encrypted.class) != null) {\nCandidateField candidateField = new CandidateField(field, CandidateField.Type.ANNOTATED_FIELD);\nfinalCandidateFields.add(candidateField);\n} else if (AppsmithDomain.class.isAssignableFrom(field.getType())) {\nCandidateField candidateField = null;\nfield.setAccessible(true);\nObject fieldValue = ReflectionUtils.getField(field, source);\nif (fieldValue == null) {\nif (this.encryptedFieldsMap.containsKey(field.getType())) {\n\/\/ If this field is null, but the cache has a non-empty list of candidates already,\n\/\/ then this is an appsmith field with known annotations\ncandidateField = new CandidateField(field, CandidateField.Type.APPSMITH_FIELD_KNOWN);\n} else {\n\/\/ If it is null and the cache is not aware of the field, this is still a prospect,\n\/\/ but with an unknown type (could also be polymorphic)\ncandidateField = new CandidateField(field, CandidateField.Type.APPSMITH_FIELD_UNKNOWN);\n}\n} else {\n\/\/ If an object exists, check if the object type is the same as the field type\nCandidateField.Type appsmithFieldType;\nif (field.getType().getCanonicalName().equals(fieldValue.getClass().getCanonicalName())) {\n\/\/ If they match, then this is going to be an appsmith known field\nappsmithFieldType = CandidateField.Type.APPSMITH_FIELD_KNOWN;\n} else {\n\/\/ If not, then this field is polymorphic,\n\/\/ it will need to be checked for type every time\nappsmithFieldType = CandidateField.Type.APPSMITH_FIELD_POLYMORPHIC;\n}\n\/\/ Now, go into field type and repeat\nList<CandidateField> candidateFieldsForType = findCandidateFieldsForType(fieldValue);\nif (appsmithFieldType.equals(CandidateField.Type.APPSMITH_FIELD_POLYMORPHIC)\n|| !candidateFieldsForType.isEmpty()) {\n\/\/ This type only qualifies as a candidate if it is polymorphic,\n\/\/ or has a list of candidates\ncandidateField = new CandidateField(field, appsmithFieldType);\n}\n}\nfield.setAccessible(false);\nif (candidateField != null) {\n\/\/ This will only ever be null if the field value is populated,\n\/\/ and is known to be a non-encryption related field\nfinalCandidateFields.add(candidateField);\n}\n} else if (Collection.class.isAssignableFrom(field.getType()) &&\nfield.getGenericType() instanceof ParameterizedType) {\n\/\/ If this is a collection, check if the Type parameter is an AppsmithDomain\nType[] typeArguments;\nParameterizedType parameterizedType = (ParameterizedType) field.getGenericType();\ntypeArguments = parameterizedType.getActualTypeArguments();\nClass<?> subFieldType;\ntry {\nsubFieldType = (Class<?>) typeArguments[0];\n} catch (ClassCastException|ArrayIndexOutOfBoundsException e) {\nsubFieldType = null;\n}\nif(subFieldType != null) {\nif (this.encryptedFieldsMap.containsKey(subFieldType)) {\n\/\/ This is a known type, it should necessarily be of AppsmithDomain type\nassert AppsmithDomain.class.isAssignableFrom(subFieldType);\nfinal List<CandidateField> existingSubTypeCandidates = this.encryptedFieldsMap.get(subFieldType);\nif (!existingSubTypeCandidates.isEmpty()) {\nfinalCandidateFields.add(new CandidateField(field, CandidateField.Type.APPSMITH_COLLECTION_KNOWN));\n}\n} else if (AppsmithDomain.class.isAssignableFrom(subFieldType)) {\n\/\/ If the type is not known, then this is either not parsed yet, or has polymorphic implementations\nfield.setAccessible(true);\nObject fieldValue = ReflectionUtils.getField(field, source);\nCollection<?> collection = (Collection<?>) fieldValue;\nif (collection == null || collection.isEmpty()) {\nfinalCandidateFields.add(new CandidateField(field, CandidateField.Type.APPSMITH_COLLECTION_UNKNOWN));\n} else {\nfor (final Object o : collection) {\nif (o == null) {\ncontinue;\n}\nif (o.getClass().getCanonicalName().equals(subFieldType.getTypeName())) {\nfinal List<CandidateField> candidateFieldsForListMember = findCandidateFieldsForType(o);\nif (candidateFieldsForListMember != null && !candidateFieldsForListMember.isEmpty()) {\nfinalCandidateFields.add(new CandidateField(field, CandidateField.Type.APPSMITH_COLLECTION_KNOWN));\n}\n} else {\nfinalCandidateFields.add(new CandidateField(field, CandidateField.Type.APPSMITH_COLLECTION_POLYMORPHIC));\n}\nbreak;\n}\n}\nfield.setAccessible(false);\n}\n}\n\/\/ TODO Add support for nested collections\n} else if (Map.class.isAssignableFrom(field.getType()) &&\nfield.getGenericType() instanceof ParameterizedType) {\nType[] typeArguments;\nParameterizedType parameterizedType = (ParameterizedType) field.getGenericType();\ntypeArguments = parameterizedType.getActualTypeArguments();\nClass<?> subFieldType = (Class<?>) typeArguments[1];\nif (this.encryptedFieldsMap.containsKey(subFieldType)) {\n\/\/ This is a known type, it should necessarily be of AppsmithDomain type\nassert AppsmithDomain.class.isAssignableFrom(subFieldType);\nfinal List<CandidateField> existingSubTypeCandidates = this.encryptedFieldsMap.get(subFieldType);\nif (!existingSubTypeCandidates.isEmpty()) {\nfinalCandidateFields.add(new CandidateField(field, CandidateField.Type.APPSMITH_MAP_KNOWN));\n}\n} else if (AppsmithDomain.class.isAssignableFrom(subFieldType)) {\n\/\/ If the type is not known, then this is either not parsed yet, or has polymorphic implementations\nfield.setAccessible(true);\nObject fieldValue = ReflectionUtils.getField(field, source);\nMap<?, ?> map = (Map<?, ?>) fieldValue;\nif (map == null || map.isEmpty()) {\nfinalCandidateFields.add(new CandidateField(field, CandidateField.Type.APPSMITH_MAP_UNKNOWN));\n} else {\nfor (Map.Entry<?, ?> entry : map.entrySet()) {\nfinal Object value = entry.getValue();\nif (value == null) {\ncontinue;\n}\nif (value.getClass().getCanonicalName().equals(subFieldType.getTypeName())) {\nfinal List<CandidateField> candidateFieldsForListMember = findCandidateFieldsForType(value);\nif (candidateFieldsForListMember != null && !candidateFieldsForListMember.isEmpty()) {\nfinalCandidateFields.add(new CandidateField(field, CandidateField.Type.APPSMITH_MAP_KNOWN));\n}\n} else {\nfinalCandidateFields.add(new CandidateField(field, CandidateField.Type.APPSMITH_MAP_POLYMORPHIC));\n}\nbreak;\n}\n}\nfield.setAccessible(false);\n}\n}\n}, field -> field.getAnnotation(Encrypted.class) != null ||\nAppsmithDomain.class.isAssignableFrom(field.getType()) ||\nCollection.class.isAssignableFrom(field.getType()) ||\nMap.class.isAssignableFrom(field.getType()));\n}\n\/\/ Update cache for next use\nencryptedFieldsMap.put(sourceClass, finalCandidateFields);\nreturn finalCandidateFields;\n}\n\nList<CandidateField> findCandidateFieldsForType(@NonNull Object source) {\n\/\/ At this point source class represents the true polymorphic type of the document\nClass<?> sourceClass = source.getClass();\n\/\/ Lock a thread wanting to find information about the same type\n\/\/ So that this information retrieval is only done once\n\/\/ Ignore this warning, this class reference will be on the heap\nList<CandidateField> candidateFields = this.encryptedFieldsMap.get(sourceClass);\nif (candidateFields != null) {\n\/\/ The cache is already aware of this type, return candidate fields for it\nreturn candidateFields;\n}\n\/\/ Don't bother with primitives\n\nList<CandidateField> findCandidateFieldsForType(@NonNull Object source) {\n\/\/ At this point source class represents the true polymorphic type of the document\nClass<?> sourceClass = source.getClass();\n\/\/ Lock a thread wanting to find information about the same type\n\/\/ So that this information retrieval is only done once\n\/\/ Ignore this warning, this class reference will be on the heap\nList<CandidateField> candidateFields = this.encryptedFieldsMap.get(sourceClass);\nif (candidateFields != null) {\n\/\/ The cache is already aware of this type, return candidate fields for it\nreturn candidateFields;\n}\n\/\/ Don't bother with primitives\nif (ClassUtils.isPrimitiveOrWrapper(sourceClass)) return Collections.emptyList();\n\/\/ If it is not known, scan each field for annotation or Appsmith type\nList<CandidateField> finalCandidateFields = new ArrayList<>();\nsynchronized (sourceClass) {\n\nList<CandidateField> findCandidateFieldsForType(@NonNull Object source) {\n\/\/ At this point source class represents the true polymorphic type of the document\nClass<?> sourceClass = source.getClass();\n\/\/ Lock a thread wanting to find information about the same type\n\/\/ So that this information retrieval is only done once\n\/\/ Ignore this warning, this class reference will be on the heap\nList<CandidateField> candidateFields = this.encryptedFieldsMap.get(sourceClass);\nif (candidateFields != null) {\n\/\/ The cache is already aware of this type, return candidate fields for it\nreturn candidateFields;\n}\n\/\/ Don't bother with primitives\nif (ClassUtils.isPrimitiveOrWrapper(sourceClass)) return Collections.emptyList();\n\/\/ If it is not known, scan each field for annotation or Appsmith type\nList<CandidateField> finalCandidateFields = new ArrayList<>();\nsynchronized (sourceClass) {\nReflectionUtils.doWithFields(sourceClass, field -> {\nif (field.getAnnotation(Encrypted.class) != null) {\nCandidateField candidateField = new CandidateField(field, CandidateField.Type.ANNOTATED_FIELD);\n\n\/\/ At this point source class represents the true polymorphic type of the document\nClass<?> sourceClass = source.getClass();\n\/\/ Lock a thread wanting to find information about the same type\n\/\/ So that this information retrieval is only done once\n\/\/ Ignore this warning, this class reference will be on the heap\nList<CandidateField> candidateFields = this.encryptedFieldsMap.get(sourceClass);\nif (candidateFields != null) {\n\/\/ The cache is already aware of this type, return candidate fields for it\nreturn candidateFields;\n}\n\/\/ Don't bother with primitives\nif (ClassUtils.isPrimitiveOrWrapper(sourceClass)) return Collections.emptyList();\n\/\/ If it is not known, scan each field for annotation or Appsmith type\nList<CandidateField> finalCandidateFields = new ArrayList<>();\nsynchronized (sourceClass) {\nReflectionUtils.doWithFields(sourceClass, field -> {\nif (field.getAnnotation(Encrypted.class) != null) {\nCandidateField candidateField = new CandidateField(field, CandidateField.Type.ANNOTATED_FIELD);\nfinalCandidateFields.add(candidateField);\n} else if (AppsmithDomain.class.isAssignableFrom(field.getType())) {\nCandidateField candidateField = null;\n\n\/\/ Lock a thread wanting to find information about the same type\n\/\/ So that this information retrieval is only done once\n\/\/ Ignore this warning, this class reference will be on the heap\nList<CandidateField> candidateFields = this.encryptedFieldsMap.get(sourceClass);\nif (candidateFields != null) {\n\/\/ The cache is already aware of this type, return candidate fields for it\nreturn candidateFields;\n}\n\/\/ Don't bother with primitives\nif (ClassUtils.isPrimitiveOrWrapper(sourceClass)) return Collections.emptyList();\n\/\/ If it is not known, scan each field for annotation or Appsmith type\nList<CandidateField> finalCandidateFields = new ArrayList<>();\nsynchronized (sourceClass) {\nReflectionUtils.doWithFields(sourceClass, field -> {\nif (field.getAnnotation(Encrypted.class) != null) {\nCandidateField candidateField = new CandidateField(field, CandidateField.Type.ANNOTATED_FIELD);\nfinalCandidateFields.add(candidateField);\n} else if (AppsmithDomain.class.isAssignableFrom(field.getType())) {\nCandidateField candidateField = null;\nfield.setAccessible(true);\nObject fieldValue = ReflectionUtils.getField(field, source);\n\nReflectionUtils.doWithFields(sourceClass, field -> {\nif (field.getAnnotation(Encrypted.class) != null) {\nCandidateField candidateField = new CandidateField(field, CandidateField.Type.ANNOTATED_FIELD);\nfinalCandidateFields.add(candidateField);\n} else if (AppsmithDomain.class.isAssignableFrom(field.getType())) {\nCandidateField candidateField = null;\nfield.setAccessible(true);\nObject fieldValue = ReflectionUtils.getField(field, source);\nif (fieldValue == null) {\nif (this.encryptedFieldsMap.containsKey(field.getType())) {\n\/\/ If this field is null, but the cache has a non-empty list of candidates already,\n\/\/ then this is an appsmith field with known annotations\ncandidateField = new CandidateField(field, CandidateField.Type.APPSMITH_FIELD_KNOWN);\n} else {\n\/\/ If it is null and the cache is not aware of the field, this is still a prospect,\n\/\/ but with an unknown type (could also be polymorphic)\ncandidateField = new CandidateField(field, CandidateField.Type.APPSMITH_FIELD_UNKNOWN);\n}\n} else {\n\/\/ If an object exists, check if the object type is the same as the field type\nCandidateField.Type appsmithFieldType;\nif (field.getType().getCanonicalName().equals(fieldValue.getClass().getCanonicalName())) {\n\n} else if (AppsmithDomain.class.isAssignableFrom(field.getType())) {\nCandidateField candidateField = null;\nfield.setAccessible(true);\nObject fieldValue = ReflectionUtils.getField(field, source);\nif (fieldValue == null) {\nif (this.encryptedFieldsMap.containsKey(field.getType())) {\n\/\/ If this field is null, but the cache has a non-empty list of candidates already,\n\/\/ then this is an appsmith field with known annotations\ncandidateField = new CandidateField(field, CandidateField.Type.APPSMITH_FIELD_KNOWN);\n} else {\n\/\/ If it is null and the cache is not aware of the field, this is still a prospect,\n\/\/ but with an unknown type (could also be polymorphic)\ncandidateField = new CandidateField(field, CandidateField.Type.APPSMITH_FIELD_UNKNOWN);\n}\n} else {\n\/\/ If an object exists, check if the object type is the same as the field type\nCandidateField.Type appsmithFieldType;\nif (field.getType().getCanonicalName().equals(fieldValue.getClass().getCanonicalName())) {\n\/\/ If they match, then this is going to be an appsmith known field\nappsmithFieldType = CandidateField.Type.APPSMITH_FIELD_KNOWN;\n} else {\n\/\/ If not, then this field is polymorphic,\n\nif (this.encryptedFieldsMap.containsKey(field.getType())) {\n\/\/ If this field is null, but the cache has a non-empty list of candidates already,\n\/\/ then this is an appsmith field with known annotations\ncandidateField = new CandidateField(field, CandidateField.Type.APPSMITH_FIELD_KNOWN);\n} else {\n\/\/ If it is null and the cache is not aware of the field, this is still a prospect,\n\/\/ but with an unknown type (could also be polymorphic)\ncandidateField = new CandidateField(field, CandidateField.Type.APPSMITH_FIELD_UNKNOWN);\n}\n} else {\n\/\/ If an object exists, check if the object type is the same as the field type\nCandidateField.Type appsmithFieldType;\nif (field.getType().getCanonicalName().equals(fieldValue.getClass().getCanonicalName())) {\n\/\/ If they match, then this is going to be an appsmith known field\nappsmithFieldType = CandidateField.Type.APPSMITH_FIELD_KNOWN;\n} else {\n\/\/ If not, then this field is polymorphic,\n\/\/ it will need to be checked for type every time\nappsmithFieldType = CandidateField.Type.APPSMITH_FIELD_POLYMORPHIC;\n}\n\/\/ Now, go into field type and repeat\n\ncandidateField = new CandidateField(field, CandidateField.Type.APPSMITH_FIELD_KNOWN);\n} else {\n\/\/ If it is null and the cache is not aware of the field, this is still a prospect,\n\/\/ but with an unknown type (could also be polymorphic)\ncandidateField = new CandidateField(field, CandidateField.Type.APPSMITH_FIELD_UNKNOWN);\n}\n} else {\n\/\/ If an object exists, check if the object type is the same as the field type\nCandidateField.Type appsmithFieldType;\nif (field.getType().getCanonicalName().equals(fieldValue.getClass().getCanonicalName())) {\n\/\/ If they match, then this is going to be an appsmith known field\nappsmithFieldType = CandidateField.Type.APPSMITH_FIELD_KNOWN;\n} else {\n\/\/ If not, then this field is polymorphic,\n\/\/ it will need to be checked for type every time\nappsmithFieldType = CandidateField.Type.APPSMITH_FIELD_POLYMORPHIC;\n}\n\/\/ Now, go into field type and repeat\nList<CandidateField> candidateFieldsForType = findCandidateFieldsForType(fieldValue);\nif (appsmithFieldType.equals(CandidateField.Type.APPSMITH_FIELD_POLYMORPHIC)\n|| !candidateFieldsForType.isEmpty()) {\n\n\/\/ but with an unknown type (could also be polymorphic)\ncandidateField = new CandidateField(field, CandidateField.Type.APPSMITH_FIELD_UNKNOWN);\n}\n} else {\n\/\/ If an object exists, check if the object type is the same as the field type\nCandidateField.Type appsmithFieldType;\nif (field.getType().getCanonicalName().equals(fieldValue.getClass().getCanonicalName())) {\n\/\/ If they match, then this is going to be an appsmith known field\nappsmithFieldType = CandidateField.Type.APPSMITH_FIELD_KNOWN;\n} else {\n\/\/ If not, then this field is polymorphic,\n\/\/ it will need to be checked for type every time\nappsmithFieldType = CandidateField.Type.APPSMITH_FIELD_POLYMORPHIC;\n}\n\/\/ Now, go into field type and repeat\nList<CandidateField> candidateFieldsForType = findCandidateFieldsForType(fieldValue);\nif (appsmithFieldType.equals(CandidateField.Type.APPSMITH_FIELD_POLYMORPHIC)\n|| !candidateFieldsForType.isEmpty()) {\n\/\/ This type only qualifies as a candidate if it is polymorphic,\n\/\/ or has a list of candidates\ncandidateField = new CandidateField(field, appsmithFieldType);\n}\n\n\/\/ If an object exists, check if the object type is the same as the field type\nCandidateField.Type appsmithFieldType;\nif (field.getType().getCanonicalName().equals(fieldValue.getClass().getCanonicalName())) {\n\/\/ If they match, then this is going to be an appsmith known field\nappsmithFieldType = CandidateField.Type.APPSMITH_FIELD_KNOWN;\n} else {\n\/\/ If not, then this field is polymorphic,\n\/\/ it will need to be checked for type every time\nappsmithFieldType = CandidateField.Type.APPSMITH_FIELD_POLYMORPHIC;\n}\n\/\/ Now, go into field type and repeat\nList<CandidateField> candidateFieldsForType = findCandidateFieldsForType(fieldValue);\nif (appsmithFieldType.equals(CandidateField.Type.APPSMITH_FIELD_POLYMORPHIC)\n|| !candidateFieldsForType.isEmpty()) {\n\/\/ This type only qualifies as a candidate if it is polymorphic,\n\/\/ or has a list of candidates\ncandidateField = new CandidateField(field, appsmithFieldType);\n}\n}\nfield.setAccessible(false);\nif (candidateField != null) {\n\nappsmithFieldType = CandidateField.Type.APPSMITH_FIELD_KNOWN;\n} else {\n\/\/ If not, then this field is polymorphic,\n\/\/ it will need to be checked for type every time\nappsmithFieldType = CandidateField.Type.APPSMITH_FIELD_POLYMORPHIC;\n}\n\/\/ Now, go into field type and repeat\nList<CandidateField> candidateFieldsForType = findCandidateFieldsForType(fieldValue);\nif (appsmithFieldType.equals(CandidateField.Type.APPSMITH_FIELD_POLYMORPHIC)\n|| !candidateFieldsForType.isEmpty()) {\n\/\/ This type only qualifies as a candidate if it is polymorphic,\n\/\/ or has a list of candidates\ncandidateField = new CandidateField(field, appsmithFieldType);\n}\n}\nfield.setAccessible(false);\nif (candidateField != null) {\n\/\/ This will only ever be null if the field value is populated,\n\/\/ and is known to be a non-encryption related field\nfinalCandidateFields.add(candidateField);\n}\n} else if (Collection.class.isAssignableFrom(field.getType()) &&\n\nList<CandidateField> candidateFieldsForType = findCandidateFieldsForType(fieldValue);\nif (appsmithFieldType.equals(CandidateField.Type.APPSMITH_FIELD_POLYMORPHIC)\n|| !candidateFieldsForType.isEmpty()) {\n\/\/ This type only qualifies as a candidate if it is polymorphic,\n\/\/ or has a list of candidates\ncandidateField = new CandidateField(field, appsmithFieldType);\n}\n}\nfield.setAccessible(false);\nif (candidateField != null) {\n\/\/ This will only ever be null if the field value is populated,\n\/\/ and is known to be a non-encryption related field\nfinalCandidateFields.add(candidateField);\n}\n} else if (Collection.class.isAssignableFrom(field.getType()) &&\nfield.getGenericType() instanceof ParameterizedType) {\n\/\/ If this is a collection, check if the Type parameter is an AppsmithDomain\nType[] typeArguments;\nParameterizedType parameterizedType = (ParameterizedType) field.getGenericType();\ntypeArguments = parameterizedType.getActualTypeArguments();\nClass<?> subFieldType;\ntry {\n\n}\n}\nfield.setAccessible(false);\nif (candidateField != null) {\n\/\/ This will only ever be null if the field value is populated,\n\/\/ and is known to be a non-encryption related field\nfinalCandidateFields.add(candidateField);\n}\n} else if (Collection.class.isAssignableFrom(field.getType()) &&\nfield.getGenericType() instanceof ParameterizedType) {\n\/\/ If this is a collection, check if the Type parameter is an AppsmithDomain\nType[] typeArguments;\nParameterizedType parameterizedType = (ParameterizedType) field.getGenericType();\ntypeArguments = parameterizedType.getActualTypeArguments();\nClass<?> subFieldType;\ntry {\nsubFieldType = (Class<?>) typeArguments[0];\n} catch (ClassCastException|ArrayIndexOutOfBoundsException e) {\nsubFieldType = null;\n}\nif(subFieldType != null) {\n\nParameterizedType parameterizedType = (ParameterizedType) field.getGenericType();\ntypeArguments = parameterizedType.getActualTypeArguments();\nClass<?> subFieldType;\ntry {\nsubFieldType = (Class<?>) typeArguments[0];\n} catch (ClassCastException|ArrayIndexOutOfBoundsException e) {\nsubFieldType = null;\n}\nif(subFieldType != null) {\nif (this.encryptedFieldsMap.containsKey(subFieldType)) {\n\/\/ This is a known type, it should necessarily be of AppsmithDomain type\nassert AppsmithDomain.class.isAssignableFrom(subFieldType);\nfinal List<CandidateField> existingSubTypeCandidates = this.encryptedFieldsMap.get(subFieldType);\nif (!existingSubTypeCandidates.isEmpty()) {\nfinalCandidateFields.add(new CandidateField(field, CandidateField.Type.APPSMITH_COLLECTION_KNOWN));\n}\n} else if (AppsmithDomain.class.isAssignableFrom(subFieldType)) {\n\/\/ If the type is not known, then this is either not parsed yet, or has polymorphic implementations\nfield.setAccessible(true);\nObject fieldValue = ReflectionUtils.getField(field, source);\nCollection<?> collection = (Collection<?>) fieldValue;\n\n}\nif(subFieldType != null) {\nif (this.encryptedFieldsMap.containsKey(subFieldType)) {\n\/\/ This is a known type, it should necessarily be of AppsmithDomain type\nassert AppsmithDomain.class.isAssignableFrom(subFieldType);\nfinal List<CandidateField> existingSubTypeCandidates = this.encryptedFieldsMap.get(subFieldType);\nif (!existingSubTypeCandidates.isEmpty()) {\nfinalCandidateFields.add(new CandidateField(field, CandidateField.Type.APPSMITH_COLLECTION_KNOWN));\n}\n} else if (AppsmithDomain.class.isAssignableFrom(subFieldType)) {\n\/\/ If the type is not known, then this is either not parsed yet, or has polymorphic implementations\nfield.setAccessible(true);\nObject fieldValue = ReflectionUtils.getField(field, source);\nCollection<?> collection = (Collection<?>) fieldValue;\nif (collection == null || collection.isEmpty()) {\nfinalCandidateFields.add(new CandidateField(field, CandidateField.Type.APPSMITH_COLLECTION_UNKNOWN));\n} else {\nfor (final Object o : collection) {\nif (o == null) {\ncontinue;\n}\n\n}\n} else {\nfinalCandidateFields.add(new CandidateField(field, CandidateField.Type.APPSMITH_COLLECTION_POLYMORPHIC));\n}\nbreak;\n}\n}\nfield.setAccessible(false);\n}\n}\n\/\/ TODO Add support for nested collections\n} else if (Map.class.isAssignableFrom(field.getType()) &&\nfield.getGenericType() instanceof ParameterizedType) {\nType[] typeArguments;\nParameterizedType parameterizedType = (ParameterizedType) field.getGenericType();\ntypeArguments = parameterizedType.getActualTypeArguments();\nClass<?> subFieldType = (Class<?>) typeArguments[1];\nif (this.encryptedFieldsMap.containsKey(subFieldType)) {\n\/\/ This is a known type, it should necessarily be of AppsmithDomain type\nassert AppsmithDomain.class.isAssignableFrom(subFieldType);\nfinal List<CandidateField> existingSubTypeCandidates = this.encryptedFieldsMap.get(subFieldType);\n\nParameterizedType parameterizedType = (ParameterizedType) field.getGenericType();\ntypeArguments = parameterizedType.getActualTypeArguments();\nClass<?> subFieldType;\ntry {\nsubFieldType = (Class<?>) typeArguments[0];\n} catch (ClassCastException|ArrayIndexOutOfBoundsException e) {\nsubFieldType = null;\n}\nif(subFieldType != null) {\nif (this.encryptedFieldsMap.containsKey(subFieldType)) {\n\/\/ This is a known type, it should necessarily be of AppsmithDomain type\nassert AppsmithDomain.class.isAssignableFrom(subFieldType);\nfinal List<CandidateField> existingSubTypeCandidates = this.encryptedFieldsMap.get(subFieldType);\nif (!existingSubTypeCandidates.isEmpty()) {\nfinalCandidateFields.add(new CandidateField(field, CandidateField.Type.APPSMITH_COLLECTION_KNOWN));\n}\n} else if (AppsmithDomain.class.isAssignableFrom(subFieldType)) {\n\/\/ If the type is not known, then this is either not parsed yet, or has polymorphic implementations\nfield.setAccessible(true);\nObject fieldValue = ReflectionUtils.getField(field, source);\nCollection<?> collection = (Collection<?>) fieldValue;\n\n}\nif(subFieldType != null) {\nif (this.encryptedFieldsMap.containsKey(subFieldType)) {\n\/\/ This is a known type, it should necessarily be of AppsmithDomain type\nassert AppsmithDomain.class.isAssignableFrom(subFieldType);\nfinal List<CandidateField> existingSubTypeCandidates = this.encryptedFieldsMap.get(subFieldType);\nif (!existingSubTypeCandidates.isEmpty()) {\nfinalCandidateFields.add(new CandidateField(field, CandidateField.Type.APPSMITH_COLLECTION_KNOWN));\n}\n} else if (AppsmithDomain.class.isAssignableFrom(subFieldType)) {\n\/\/ If the type is not known, then this is either not parsed yet, or has polymorphic implementations\nfield.setAccessible(true);\nObject fieldValue = ReflectionUtils.getField(field, source);\nCollection<?> collection = (Collection<?>) fieldValue;\nif (collection == null || collection.isEmpty()) {\nfinalCandidateFields.add(new CandidateField(field, CandidateField.Type.APPSMITH_COLLECTION_UNKNOWN));\n} else {\nfor (final Object o : collection) {\nif (o == null) {\ncontinue;\n}\n\n}\n}\nfield.setAccessible(false);\n}\n}\n}, field -> field.getAnnotation(Encrypted.class) != null ||\nAppsmithDomain.class.isAssignableFrom(field.getType()) ||\nCollection.class.isAssignableFrom(field.getType()) ||\nMap.class.isAssignableFrom(field.getType()));\n}\n\/\/ Update cache for next use\nencryptedFieldsMap.put(sourceClass, finalCandidateFields);\nreturn finalCandidateFields;\n}","code_context_20":"List<CandidateField> findCandidateFieldsForType(@NonNull Object source) {\n\/\/ At this point source class represents the true polymorphic type of the document\nClass<?> sourceClass = source.getClass();\n\/\/ Lock a thread wanting to find information about the same type\n\/\/ So that this information retrieval is only done once\n\/\/ Ignore this warning, this class reference will be on the heap\nList<CandidateField> candidateFields = this.encryptedFieldsMap.get(sourceClass);\nif (candidateFields != null) {\n\/\/ The cache is already aware of this type, return candidate fields for it\nreturn candidateFields;\n}\n\/\/ Don't bother with primitives\nif (ClassUtils.isPrimitiveOrWrapper(sourceClass)) return Collections.emptyList();\n\/\/ If it is not known, scan each field for annotation or Appsmith type\nList<CandidateField> finalCandidateFields = new ArrayList<>();\nsynchronized (sourceClass) {\nReflectionUtils.doWithFields(sourceClass, field -> {\nif (field.getAnnotation(Encrypted.class) != null) {\nCandidateField candidateField = new CandidateField(field, CandidateField.Type.ANNOTATED_FIELD);\nfinalCandidateFields.add(candidateField);\n} else if (AppsmithDomain.class.isAssignableFrom(field.getType())) {\nCandidateField candidateField = null;\nfield.setAccessible(true);\nObject fieldValue = ReflectionUtils.getField(field, source);\nif (fieldValue == null) {\nif (this.encryptedFieldsMap.containsKey(field.getType())) {\n\/\/ If this field is null, but the cache has a non-empty list of candidates already,\n\/\/ then this is an appsmith field with known annotations\ncandidateField = new CandidateField(field, CandidateField.Type.APPSMITH_FIELD_KNOWN);\n} else {\n\/\/ If it is null and the cache is not aware of the field, this is still a prospect,\n\/\/ but with an unknown type (could also be polymorphic)\ncandidateField = new CandidateField(field, CandidateField.Type.APPSMITH_FIELD_UNKNOWN);\n}\n} else {\n\/\/ If an object exists, check if the object type is the same as the field type\nCandidateField.Type appsmithFieldType;\nif (field.getType().getCanonicalName().equals(fieldValue.getClass().getCanonicalName())) {\n\/\/ If they match, then this is going to be an appsmith known field\nappsmithFieldType = CandidateField.Type.APPSMITH_FIELD_KNOWN;\n} else {\n\/\/ If not, then this field is polymorphic,\n\/\/ it will need to be checked for type every time\nappsmithFieldType = CandidateField.Type.APPSMITH_FIELD_POLYMORPHIC;\n}\n\/\/ Now, go into field type and repeat\nList<CandidateField> candidateFieldsForType = findCandidateFieldsForType(fieldValue);\nif (appsmithFieldType.equals(CandidateField.Type.APPSMITH_FIELD_POLYMORPHIC)\n|| !candidateFieldsForType.isEmpty()) {\n\/\/ This type only qualifies as a candidate if it is polymorphic,\n\/\/ or has a list of candidates\ncandidateField = new CandidateField(field, appsmithFieldType);\n}\n}\nfield.setAccessible(false);\nif (candidateField != null) {\n\/\/ This will only ever be null if the field value is populated,\n\/\/ and is known to be a non-encryption related field\nfinalCandidateFields.add(candidateField);\n}\n} else if (Collection.class.isAssignableFrom(field.getType()) &&\nfield.getGenericType() instanceof ParameterizedType) {\n\/\/ If this is a collection, check if the Type parameter is an AppsmithDomain\nType[] typeArguments;\nParameterizedType parameterizedType = (ParameterizedType) field.getGenericType();\ntypeArguments = parameterizedType.getActualTypeArguments();\nClass<?> subFieldType;\ntry {\nsubFieldType = (Class<?>) typeArguments[0];\n} catch (ClassCastException|ArrayIndexOutOfBoundsException e) {\nsubFieldType = null;\n}\nif(subFieldType != null) {\nif (this.encryptedFieldsMap.containsKey(subFieldType)) {\n\/\/ This is a known type, it should necessarily be of AppsmithDomain type\nassert AppsmithDomain.class.isAssignableFrom(subFieldType);\nfinal List<CandidateField> existingSubTypeCandidates = this.encryptedFieldsMap.get(subFieldType);\nif (!existingSubTypeCandidates.isEmpty()) {\nfinalCandidateFields.add(new CandidateField(field, CandidateField.Type.APPSMITH_COLLECTION_KNOWN));\n}\n} else if (AppsmithDomain.class.isAssignableFrom(subFieldType)) {\n\/\/ If the type is not known, then this is either not parsed yet, or has polymorphic implementations\nfield.setAccessible(true);\nObject fieldValue = ReflectionUtils.getField(field, source);\nCollection<?> collection = (Collection<?>) fieldValue;\nif (collection == null || collection.isEmpty()) {\nfinalCandidateFields.add(new CandidateField(field, CandidateField.Type.APPSMITH_COLLECTION_UNKNOWN));\n} else {\nfor (final Object o : collection) {\nif (o == null) {\ncontinue;\n}\nif (o.getClass().getCanonicalName().equals(subFieldType.getTypeName())) {\nfinal List<CandidateField> candidateFieldsForListMember = findCandidateFieldsForType(o);\nif (candidateFieldsForListMember != null && !candidateFieldsForListMember.isEmpty()) {\nfinalCandidateFields.add(new CandidateField(field, CandidateField.Type.APPSMITH_COLLECTION_KNOWN));\n}\n} else {\nfinalCandidateFields.add(new CandidateField(field, CandidateField.Type.APPSMITH_COLLECTION_POLYMORPHIC));\n}\nbreak;\n}\n}\nfield.setAccessible(false);\n}\n}\n\/\/ TODO Add support for nested collections\n} else if (Map.class.isAssignableFrom(field.getType()) &&\nfield.getGenericType() instanceof ParameterizedType) {\nType[] typeArguments;\nParameterizedType parameterizedType = (ParameterizedType) field.getGenericType();\ntypeArguments = parameterizedType.getActualTypeArguments();\nClass<?> subFieldType = (Class<?>) typeArguments[1];\nif (this.encryptedFieldsMap.containsKey(subFieldType)) {\n\/\/ This is a known type, it should necessarily be of AppsmithDomain type\nassert AppsmithDomain.class.isAssignableFrom(subFieldType);\nfinal List<CandidateField> existingSubTypeCandidates = this.encryptedFieldsMap.get(subFieldType);\nif (!existingSubTypeCandidates.isEmpty()) {\nfinalCandidateFields.add(new CandidateField(field, CandidateField.Type.APPSMITH_MAP_KNOWN));\n}\n} else if (AppsmithDomain.class.isAssignableFrom(subFieldType)) {\n\/\/ If the type is not known, then this is either not parsed yet, or has polymorphic implementations\nfield.setAccessible(true);\nObject fieldValue = ReflectionUtils.getField(field, source);\nMap<?, ?> map = (Map<?, ?>) fieldValue;\nif (map == null || map.isEmpty()) {\nfinalCandidateFields.add(new CandidateField(field, CandidateField.Type.APPSMITH_MAP_UNKNOWN));\n} else {\nfor (Map.Entry<?, ?> entry : map.entrySet()) {\nfinal Object value = entry.getValue();\nif (value == null) {\ncontinue;\n}\nif (value.getClass().getCanonicalName().equals(subFieldType.getTypeName())) {\nfinal List<CandidateField> candidateFieldsForListMember = findCandidateFieldsForType(value);\nif (candidateFieldsForListMember != null && !candidateFieldsForListMember.isEmpty()) {\nfinalCandidateFields.add(new CandidateField(field, CandidateField.Type.APPSMITH_MAP_KNOWN));\n}\n} else {\nfinalCandidateFields.add(new CandidateField(field, CandidateField.Type.APPSMITH_MAP_POLYMORPHIC));\n}\nbreak;\n}\n}\nfield.setAccessible(false);\n}\n}\n}, field -> field.getAnnotation(Encrypted.class) != null ||\nAppsmithDomain.class.isAssignableFrom(field.getType()) ||\nCollection.class.isAssignableFrom(field.getType()) ||\nMap.class.isAssignableFrom(field.getType()));\n}\n\/\/ Update cache for next use\nencryptedFieldsMap.put(sourceClass, finalCandidateFields);\nreturn finalCandidateFields;\n}\n\nList<CandidateField> findCandidateFieldsForType(@NonNull Object source) {\n\/\/ At this point source class represents the true polymorphic type of the document\nClass<?> sourceClass = source.getClass();\n\/\/ Lock a thread wanting to find information about the same type\n\/\/ So that this information retrieval is only done once\n\/\/ Ignore this warning, this class reference will be on the heap\nList<CandidateField> candidateFields = this.encryptedFieldsMap.get(sourceClass);\nif (candidateFields != null) {\n\/\/ The cache is already aware of this type, return candidate fields for it\nreturn candidateFields;\n}\n\/\/ Don't bother with primitives\nif (ClassUtils.isPrimitiveOrWrapper(sourceClass)) return Collections.emptyList();\n\/\/ If it is not known, scan each field for annotation or Appsmith type\nList<CandidateField> finalCandidateFields = new ArrayList<>();\nsynchronized (sourceClass) {\nReflectionUtils.doWithFields(sourceClass, field -> {\nif (field.getAnnotation(Encrypted.class) != null) {\nCandidateField candidateField = new CandidateField(field, CandidateField.Type.ANNOTATED_FIELD);\nfinalCandidateFields.add(candidateField);\n} else if (AppsmithDomain.class.isAssignableFrom(field.getType())) {\nCandidateField candidateField = null;\n\nList<CandidateField> findCandidateFieldsForType(@NonNull Object source) {\n\/\/ At this point source class represents the true polymorphic type of the document\nClass<?> sourceClass = source.getClass();\n\/\/ Lock a thread wanting to find information about the same type\n\/\/ So that this information retrieval is only done once\n\/\/ Ignore this warning, this class reference will be on the heap\nList<CandidateField> candidateFields = this.encryptedFieldsMap.get(sourceClass);\nif (candidateFields != null) {\n\/\/ The cache is already aware of this type, return candidate fields for it\nreturn candidateFields;\n}\n\/\/ Don't bother with primitives\nif (ClassUtils.isPrimitiveOrWrapper(sourceClass)) return Collections.emptyList();\n\/\/ If it is not known, scan each field for annotation or Appsmith type\nList<CandidateField> finalCandidateFields = new ArrayList<>();\nsynchronized (sourceClass) {\nReflectionUtils.doWithFields(sourceClass, field -> {\nif (field.getAnnotation(Encrypted.class) != null) {\nCandidateField candidateField = new CandidateField(field, CandidateField.Type.ANNOTATED_FIELD);\nfinalCandidateFields.add(candidateField);\n} else if (AppsmithDomain.class.isAssignableFrom(field.getType())) {\nCandidateField candidateField = null;\nfield.setAccessible(true);\nObject fieldValue = ReflectionUtils.getField(field, source);\nif (fieldValue == null) {\nif (this.encryptedFieldsMap.containsKey(field.getType())) {\n\nList<CandidateField> findCandidateFieldsForType(@NonNull Object source) {\n\/\/ At this point source class represents the true polymorphic type of the document\nClass<?> sourceClass = source.getClass();\n\/\/ Lock a thread wanting to find information about the same type\n\/\/ So that this information retrieval is only done once\n\/\/ Ignore this warning, this class reference will be on the heap\nList<CandidateField> candidateFields = this.encryptedFieldsMap.get(sourceClass);\nif (candidateFields != null) {\n\/\/ The cache is already aware of this type, return candidate fields for it\nreturn candidateFields;\n}\n\/\/ Don't bother with primitives\nif (ClassUtils.isPrimitiveOrWrapper(sourceClass)) return Collections.emptyList();\n\/\/ If it is not known, scan each field for annotation or Appsmith type\nList<CandidateField> finalCandidateFields = new ArrayList<>();\nsynchronized (sourceClass) {\nReflectionUtils.doWithFields(sourceClass, field -> {\nif (field.getAnnotation(Encrypted.class) != null) {\nCandidateField candidateField = new CandidateField(field, CandidateField.Type.ANNOTATED_FIELD);\nfinalCandidateFields.add(candidateField);\n} else if (AppsmithDomain.class.isAssignableFrom(field.getType())) {\nCandidateField candidateField = null;\nfield.setAccessible(true);\nObject fieldValue = ReflectionUtils.getField(field, source);\nif (fieldValue == null) {\nif (this.encryptedFieldsMap.containsKey(field.getType())) {\n\/\/ If this field is null, but the cache has a non-empty list of candidates already,\n\/\/ then this is an appsmith field with known annotations\ncandidateField = new CandidateField(field, CandidateField.Type.APPSMITH_FIELD_KNOWN);\n\nList<CandidateField> findCandidateFieldsForType(@NonNull Object source) {\n\/\/ At this point source class represents the true polymorphic type of the document\nClass<?> sourceClass = source.getClass();\n\/\/ Lock a thread wanting to find information about the same type\n\/\/ So that this information retrieval is only done once\n\/\/ Ignore this warning, this class reference will be on the heap\nList<CandidateField> candidateFields = this.encryptedFieldsMap.get(sourceClass);\nif (candidateFields != null) {\n\/\/ The cache is already aware of this type, return candidate fields for it\nreturn candidateFields;\n}\n\/\/ Don't bother with primitives\nif (ClassUtils.isPrimitiveOrWrapper(sourceClass)) return Collections.emptyList();\n\/\/ If it is not known, scan each field for annotation or Appsmith type\nList<CandidateField> finalCandidateFields = new ArrayList<>();\nsynchronized (sourceClass) {\nReflectionUtils.doWithFields(sourceClass, field -> {\nif (field.getAnnotation(Encrypted.class) != null) {\nCandidateField candidateField = new CandidateField(field, CandidateField.Type.ANNOTATED_FIELD);\nfinalCandidateFields.add(candidateField);\n} else if (AppsmithDomain.class.isAssignableFrom(field.getType())) {\nCandidateField candidateField = null;\nfield.setAccessible(true);\nObject fieldValue = ReflectionUtils.getField(field, source);\nif (fieldValue == null) {\nif (this.encryptedFieldsMap.containsKey(field.getType())) {\n\/\/ If this field is null, but the cache has a non-empty list of candidates already,\n\/\/ then this is an appsmith field with known annotations\ncandidateField = new CandidateField(field, CandidateField.Type.APPSMITH_FIELD_KNOWN);\n} else {\n\/\/ If it is null and the cache is not aware of the field, this is still a prospect,\n\/\/ but with an unknown type (could also be polymorphic)\n\nList<CandidateField> findCandidateFieldsForType(@NonNull Object source) {\n\/\/ At this point source class represents the true polymorphic type of the document\nClass<?> sourceClass = source.getClass();\n\/\/ Lock a thread wanting to find information about the same type\n\/\/ So that this information retrieval is only done once\n\/\/ Ignore this warning, this class reference will be on the heap\nList<CandidateField> candidateFields = this.encryptedFieldsMap.get(sourceClass);\nif (candidateFields != null) {\n\/\/ The cache is already aware of this type, return candidate fields for it\nreturn candidateFields;\n}\n\/\/ Don't bother with primitives\nif (ClassUtils.isPrimitiveOrWrapper(sourceClass)) return Collections.emptyList();\n\/\/ If it is not known, scan each field for annotation or Appsmith type\nList<CandidateField> finalCandidateFields = new ArrayList<>();\nsynchronized (sourceClass) {\nReflectionUtils.doWithFields(sourceClass, field -> {\nif (field.getAnnotation(Encrypted.class) != null) {\nCandidateField candidateField = new CandidateField(field, CandidateField.Type.ANNOTATED_FIELD);\nfinalCandidateFields.add(candidateField);\n} else if (AppsmithDomain.class.isAssignableFrom(field.getType())) {\nCandidateField candidateField = null;\nfield.setAccessible(true);\nObject fieldValue = ReflectionUtils.getField(field, source);\nif (fieldValue == null) {\nif (this.encryptedFieldsMap.containsKey(field.getType())) {\n\/\/ If this field is null, but the cache has a non-empty list of candidates already,\n\/\/ then this is an appsmith field with known annotations\ncandidateField = new CandidateField(field, CandidateField.Type.APPSMITH_FIELD_KNOWN);\n} else {\n\/\/ If it is null and the cache is not aware of the field, this is still a prospect,\n\/\/ but with an unknown type (could also be polymorphic)\ncandidateField = new CandidateField(field, CandidateField.Type.APPSMITH_FIELD_UNKNOWN);\n}\n\nList<CandidateField> candidateFields = this.encryptedFieldsMap.get(sourceClass);\nif (candidateFields != null) {\n\/\/ The cache is already aware of this type, return candidate fields for it\nreturn candidateFields;\n}\n\/\/ Don't bother with primitives\nif (ClassUtils.isPrimitiveOrWrapper(sourceClass)) return Collections.emptyList();\n\/\/ If it is not known, scan each field for annotation or Appsmith type\nList<CandidateField> finalCandidateFields = new ArrayList<>();\nsynchronized (sourceClass) {\nReflectionUtils.doWithFields(sourceClass, field -> {\nif (field.getAnnotation(Encrypted.class) != null) {\nCandidateField candidateField = new CandidateField(field, CandidateField.Type.ANNOTATED_FIELD);\nfinalCandidateFields.add(candidateField);\n} else if (AppsmithDomain.class.isAssignableFrom(field.getType())) {\nCandidateField candidateField = null;\nfield.setAccessible(true);\nObject fieldValue = ReflectionUtils.getField(field, source);\nif (fieldValue == null) {\nif (this.encryptedFieldsMap.containsKey(field.getType())) {\n\/\/ If this field is null, but the cache has a non-empty list of candidates already,\n\/\/ then this is an appsmith field with known annotations\ncandidateField = new CandidateField(field, CandidateField.Type.APPSMITH_FIELD_KNOWN);\n} else {\n\/\/ If it is null and the cache is not aware of the field, this is still a prospect,\n\/\/ but with an unknown type (could also be polymorphic)\ncandidateField = new CandidateField(field, CandidateField.Type.APPSMITH_FIELD_UNKNOWN);\n}\n} else {\n\/\/ If an object exists, check if the object type is the same as the field type\nCandidateField.Type appsmithFieldType;\nif (field.getType().getCanonicalName().equals(fieldValue.getClass().getCanonicalName())) {\n\/\/ If they match, then this is going to be an appsmith known field\nappsmithFieldType = CandidateField.Type.APPSMITH_FIELD_KNOWN;\n} else {\n\/\/ If not, then this field is polymorphic,\n\/\/ it will need to be checked for type every time\nappsmithFieldType = CandidateField.Type.APPSMITH_FIELD_POLYMORPHIC;\n}\n\/\/ Now, go into field type and repeat\nList<CandidateField> candidateFieldsForType = findCandidateFieldsForType(fieldValue);\nif (appsmithFieldType.equals(CandidateField.Type.APPSMITH_FIELD_POLYMORPHIC)\n\n}\n\/\/ Don't bother with primitives\nif (ClassUtils.isPrimitiveOrWrapper(sourceClass)) return Collections.emptyList();\n\/\/ If it is not known, scan each field for annotation or Appsmith type\nList<CandidateField> finalCandidateFields = new ArrayList<>();\nsynchronized (sourceClass) {\nReflectionUtils.doWithFields(sourceClass, field -> {\nif (field.getAnnotation(Encrypted.class) != null) {\nCandidateField candidateField = new CandidateField(field, CandidateField.Type.ANNOTATED_FIELD);\nfinalCandidateFields.add(candidateField);\n} else if (AppsmithDomain.class.isAssignableFrom(field.getType())) {\nCandidateField candidateField = null;\nfield.setAccessible(true);\nObject fieldValue = ReflectionUtils.getField(field, source);\nif (fieldValue == null) {\nif (this.encryptedFieldsMap.containsKey(field.getType())) {\n\/\/ If this field is null, but the cache has a non-empty list of candidates already,\n\/\/ then this is an appsmith field with known annotations\ncandidateField = new CandidateField(field, CandidateField.Type.APPSMITH_FIELD_KNOWN);\n} else {\n\/\/ If it is null and the cache is not aware of the field, this is still a prospect,\n\/\/ but with an unknown type (could also be polymorphic)\ncandidateField = new CandidateField(field, CandidateField.Type.APPSMITH_FIELD_UNKNOWN);\n}\n} else {\n\/\/ If an object exists, check if the object type is the same as the field type\nCandidateField.Type appsmithFieldType;\nif (field.getType().getCanonicalName().equals(fieldValue.getClass().getCanonicalName())) {\n\/\/ If they match, then this is going to be an appsmith known field\nappsmithFieldType = CandidateField.Type.APPSMITH_FIELD_KNOWN;\n} else {\n\/\/ If not, then this field is polymorphic,\n\/\/ it will need to be checked for type every time\nappsmithFieldType = CandidateField.Type.APPSMITH_FIELD_POLYMORPHIC;\n}\n\/\/ Now, go into field type and repeat\nList<CandidateField> candidateFieldsForType = findCandidateFieldsForType(fieldValue);\nif (appsmithFieldType.equals(CandidateField.Type.APPSMITH_FIELD_POLYMORPHIC)\n|| !candidateFieldsForType.isEmpty()) {\n\/\/ This type only qualifies as a candidate if it is polymorphic,\n\/\/ or has a list of candidates\ncandidateField = new CandidateField(field, appsmithFieldType);\n\nsynchronized (sourceClass) {\nReflectionUtils.doWithFields(sourceClass, field -> {\nif (field.getAnnotation(Encrypted.class) != null) {\nCandidateField candidateField = new CandidateField(field, CandidateField.Type.ANNOTATED_FIELD);\nfinalCandidateFields.add(candidateField);\n} else if (AppsmithDomain.class.isAssignableFrom(field.getType())) {\nCandidateField candidateField = null;\nfield.setAccessible(true);\nObject fieldValue = ReflectionUtils.getField(field, source);\nif (fieldValue == null) {\nif (this.encryptedFieldsMap.containsKey(field.getType())) {\n\/\/ If this field is null, but the cache has a non-empty list of candidates already,\n\/\/ then this is an appsmith field with known annotations\ncandidateField = new CandidateField(field, CandidateField.Type.APPSMITH_FIELD_KNOWN);\n} else {\n\/\/ If it is null and the cache is not aware of the field, this is still a prospect,\n\/\/ but with an unknown type (could also be polymorphic)\ncandidateField = new CandidateField(field, CandidateField.Type.APPSMITH_FIELD_UNKNOWN);\n}\n} else {\n\/\/ If an object exists, check if the object type is the same as the field type\nCandidateField.Type appsmithFieldType;\nif (field.getType().getCanonicalName().equals(fieldValue.getClass().getCanonicalName())) {\n\/\/ If they match, then this is going to be an appsmith known field\nappsmithFieldType = CandidateField.Type.APPSMITH_FIELD_KNOWN;\n} else {\n\/\/ If not, then this field is polymorphic,\n\/\/ it will need to be checked for type every time\nappsmithFieldType = CandidateField.Type.APPSMITH_FIELD_POLYMORPHIC;\n}\n\/\/ Now, go into field type and repeat\nList<CandidateField> candidateFieldsForType = findCandidateFieldsForType(fieldValue);\nif (appsmithFieldType.equals(CandidateField.Type.APPSMITH_FIELD_POLYMORPHIC)\n|| !candidateFieldsForType.isEmpty()) {\n\/\/ This type only qualifies as a candidate if it is polymorphic,\n\/\/ or has a list of candidates\ncandidateField = new CandidateField(field, appsmithFieldType);\n}\n}\nfield.setAccessible(false);\nif (candidateField != null) {\n\nCandidateField candidateField = new CandidateField(field, CandidateField.Type.ANNOTATED_FIELD);\nfinalCandidateFields.add(candidateField);\n} else if (AppsmithDomain.class.isAssignableFrom(field.getType())) {\nCandidateField candidateField = null;\nfield.setAccessible(true);\nObject fieldValue = ReflectionUtils.getField(field, source);\nif (fieldValue == null) {\nif (this.encryptedFieldsMap.containsKey(field.getType())) {\n\/\/ If this field is null, but the cache has a non-empty list of candidates already,\n\/\/ then this is an appsmith field with known annotations\ncandidateField = new CandidateField(field, CandidateField.Type.APPSMITH_FIELD_KNOWN);\n} else {\n\/\/ If it is null and the cache is not aware of the field, this is still a prospect,\n\/\/ but with an unknown type (could also be polymorphic)\ncandidateField = new CandidateField(field, CandidateField.Type.APPSMITH_FIELD_UNKNOWN);\n}\n} else {\n\/\/ If an object exists, check if the object type is the same as the field type\nCandidateField.Type appsmithFieldType;\nif (field.getType().getCanonicalName().equals(fieldValue.getClass().getCanonicalName())) {\n\/\/ If they match, then this is going to be an appsmith known field\nappsmithFieldType = CandidateField.Type.APPSMITH_FIELD_KNOWN;\n} else {\n\/\/ If not, then this field is polymorphic,\n\/\/ it will need to be checked for type every time\nappsmithFieldType = CandidateField.Type.APPSMITH_FIELD_POLYMORPHIC;\n}\n\/\/ Now, go into field type and repeat\nList<CandidateField> candidateFieldsForType = findCandidateFieldsForType(fieldValue);\nif (appsmithFieldType.equals(CandidateField.Type.APPSMITH_FIELD_POLYMORPHIC)\n|| !candidateFieldsForType.isEmpty()) {\n\/\/ This type only qualifies as a candidate if it is polymorphic,\n\/\/ or has a list of candidates\ncandidateField = new CandidateField(field, appsmithFieldType);\n}\n}\nfield.setAccessible(false);\nif (candidateField != null) {\n\/\/ This will only ever be null if the field value is populated,\n\/\/ and is known to be a non-encryption related field\nfinalCandidateFields.add(candidateField);\n\nCandidateField candidateField = null;\nfield.setAccessible(true);\nObject fieldValue = ReflectionUtils.getField(field, source);\nif (fieldValue == null) {\nif (this.encryptedFieldsMap.containsKey(field.getType())) {\n\/\/ If this field is null, but the cache has a non-empty list of candidates already,\n\/\/ then this is an appsmith field with known annotations\ncandidateField = new CandidateField(field, CandidateField.Type.APPSMITH_FIELD_KNOWN);\n} else {\n\/\/ If it is null and the cache is not aware of the field, this is still a prospect,\n\/\/ but with an unknown type (could also be polymorphic)\ncandidateField = new CandidateField(field, CandidateField.Type.APPSMITH_FIELD_UNKNOWN);\n}\n} else {\n\/\/ If an object exists, check if the object type is the same as the field type\nCandidateField.Type appsmithFieldType;\nif (field.getType().getCanonicalName().equals(fieldValue.getClass().getCanonicalName())) {\n\/\/ If they match, then this is going to be an appsmith known field\nappsmithFieldType = CandidateField.Type.APPSMITH_FIELD_KNOWN;\n} else {\n\/\/ If not, then this field is polymorphic,\n\/\/ it will need to be checked for type every time\nappsmithFieldType = CandidateField.Type.APPSMITH_FIELD_POLYMORPHIC;\n}\n\/\/ Now, go into field type and repeat\nList<CandidateField> candidateFieldsForType = findCandidateFieldsForType(fieldValue);\nif (appsmithFieldType.equals(CandidateField.Type.APPSMITH_FIELD_POLYMORPHIC)\n|| !candidateFieldsForType.isEmpty()) {\n\/\/ This type only qualifies as a candidate if it is polymorphic,\n\/\/ or has a list of candidates\ncandidateField = new CandidateField(field, appsmithFieldType);\n}\n}\nfield.setAccessible(false);\nif (candidateField != null) {\n\/\/ This will only ever be null if the field value is populated,\n\/\/ and is known to be a non-encryption related field\nfinalCandidateFields.add(candidateField);\n}\n} else if (Collection.class.isAssignableFrom(field.getType()) &&\nfield.getGenericType() instanceof ParameterizedType) {\n\/\/ If this is a collection, check if the Type parameter is an AppsmithDomain\n\nif (this.encryptedFieldsMap.containsKey(field.getType())) {\n\/\/ If this field is null, but the cache has a non-empty list of candidates already,\n\/\/ then this is an appsmith field with known annotations\ncandidateField = new CandidateField(field, CandidateField.Type.APPSMITH_FIELD_KNOWN);\n} else {\n\/\/ If it is null and the cache is not aware of the field, this is still a prospect,\n\/\/ but with an unknown type (could also be polymorphic)\ncandidateField = new CandidateField(field, CandidateField.Type.APPSMITH_FIELD_UNKNOWN);\n}\n} else {\n\/\/ If an object exists, check if the object type is the same as the field type\nCandidateField.Type appsmithFieldType;\nif (field.getType().getCanonicalName().equals(fieldValue.getClass().getCanonicalName())) {\n\/\/ If they match, then this is going to be an appsmith known field\nappsmithFieldType = CandidateField.Type.APPSMITH_FIELD_KNOWN;\n} else {\n\/\/ If not, then this field is polymorphic,\n\/\/ it will need to be checked for type every time\nappsmithFieldType = CandidateField.Type.APPSMITH_FIELD_POLYMORPHIC;\n}\n\/\/ Now, go into field type and repeat\nList<CandidateField> candidateFieldsForType = findCandidateFieldsForType(fieldValue);\nif (appsmithFieldType.equals(CandidateField.Type.APPSMITH_FIELD_POLYMORPHIC)\n|| !candidateFieldsForType.isEmpty()) {\n\/\/ This type only qualifies as a candidate if it is polymorphic,\n\/\/ or has a list of candidates\ncandidateField = new CandidateField(field, appsmithFieldType);\n}\n}\nfield.setAccessible(false);\nif (candidateField != null) {\n\/\/ This will only ever be null if the field value is populated,\n\/\/ and is known to be a non-encryption related field\nfinalCandidateFields.add(candidateField);\n}\n} else if (Collection.class.isAssignableFrom(field.getType()) &&\nfield.getGenericType() instanceof ParameterizedType) {\n\/\/ If this is a collection, check if the Type parameter is an AppsmithDomain\nType[] typeArguments;\nParameterizedType parameterizedType = (ParameterizedType) field.getGenericType();\ntypeArguments = parameterizedType.getActualTypeArguments();\n\n} else {\n\/\/ If it is null and the cache is not aware of the field, this is still a prospect,\n\/\/ but with an unknown type (could also be polymorphic)\ncandidateField = new CandidateField(field, CandidateField.Type.APPSMITH_FIELD_UNKNOWN);\n}\n} else {\n\/\/ If an object exists, check if the object type is the same as the field type\nCandidateField.Type appsmithFieldType;\nif (field.getType().getCanonicalName().equals(fieldValue.getClass().getCanonicalName())) {\n\/\/ If they match, then this is going to be an appsmith known field\nappsmithFieldType = CandidateField.Type.APPSMITH_FIELD_KNOWN;\n} else {\n\/\/ If not, then this field is polymorphic,\n\/\/ it will need to be checked for type every time\nappsmithFieldType = CandidateField.Type.APPSMITH_FIELD_POLYMORPHIC;\n}\n\/\/ Now, go into field type and repeat\nList<CandidateField> candidateFieldsForType = findCandidateFieldsForType(fieldValue);\nif (appsmithFieldType.equals(CandidateField.Type.APPSMITH_FIELD_POLYMORPHIC)\n|| !candidateFieldsForType.isEmpty()) {\n\/\/ This type only qualifies as a candidate if it is polymorphic,\n\/\/ or has a list of candidates\ncandidateField = new CandidateField(field, appsmithFieldType);\n}\n}\nfield.setAccessible(false);\nif (candidateField != null) {\n\/\/ This will only ever be null if the field value is populated,\n\/\/ and is known to be a non-encryption related field\nfinalCandidateFields.add(candidateField);\n}\n} else if (Collection.class.isAssignableFrom(field.getType()) &&\nfield.getGenericType() instanceof ParameterizedType) {\n\/\/ If this is a collection, check if the Type parameter is an AppsmithDomain\nType[] typeArguments;\nParameterizedType parameterizedType = (ParameterizedType) field.getGenericType();\ntypeArguments = parameterizedType.getActualTypeArguments();\nClass<?> subFieldType;\ntry {\nsubFieldType = (Class<?>) typeArguments[0];\n} catch (ClassCastException|ArrayIndexOutOfBoundsException e) {\nsubFieldType = null;\n\nCandidateField.Type appsmithFieldType;\nif (field.getType().getCanonicalName().equals(fieldValue.getClass().getCanonicalName())) {\n\/\/ If they match, then this is going to be an appsmith known field\nappsmithFieldType = CandidateField.Type.APPSMITH_FIELD_KNOWN;\n} else {\n\/\/ If not, then this field is polymorphic,\n\/\/ it will need to be checked for type every time\nappsmithFieldType = CandidateField.Type.APPSMITH_FIELD_POLYMORPHIC;\n}\n\/\/ Now, go into field type and repeat\nList<CandidateField> candidateFieldsForType = findCandidateFieldsForType(fieldValue);\nif (appsmithFieldType.equals(CandidateField.Type.APPSMITH_FIELD_POLYMORPHIC)\n|| !candidateFieldsForType.isEmpty()) {\n\/\/ This type only qualifies as a candidate if it is polymorphic,\n\/\/ or has a list of candidates\ncandidateField = new CandidateField(field, appsmithFieldType);\n}\n}\nfield.setAccessible(false);\nif (candidateField != null) {\n\/\/ This will only ever be null if the field value is populated,\n\/\/ and is known to be a non-encryption related field\nfinalCandidateFields.add(candidateField);\n}\n} else if (Collection.class.isAssignableFrom(field.getType()) &&\nfield.getGenericType() instanceof ParameterizedType) {\n\/\/ If this is a collection, check if the Type parameter is an AppsmithDomain\nType[] typeArguments;\nParameterizedType parameterizedType = (ParameterizedType) field.getGenericType();\ntypeArguments = parameterizedType.getActualTypeArguments();\nClass<?> subFieldType;\ntry {\nsubFieldType = (Class<?>) typeArguments[0];\n} catch (ClassCastException|ArrayIndexOutOfBoundsException e) {\nsubFieldType = null;\n}\nif(subFieldType != null) {\nif (this.encryptedFieldsMap.containsKey(subFieldType)) {\n\/\/ This is a known type, it should necessarily be of AppsmithDomain type\nassert AppsmithDomain.class.isAssignableFrom(subFieldType);\nfinal List<CandidateField> existingSubTypeCandidates = this.encryptedFieldsMap.get(subFieldType);\nif (!existingSubTypeCandidates.isEmpty()) {\n\n\/\/ it will need to be checked for type every time\nappsmithFieldType = CandidateField.Type.APPSMITH_FIELD_POLYMORPHIC;\n}\n\/\/ Now, go into field type and repeat\nList<CandidateField> candidateFieldsForType = findCandidateFieldsForType(fieldValue);\nif (appsmithFieldType.equals(CandidateField.Type.APPSMITH_FIELD_POLYMORPHIC)\n|| !candidateFieldsForType.isEmpty()) {\n\/\/ This type only qualifies as a candidate if it is polymorphic,\n\/\/ or has a list of candidates\ncandidateField = new CandidateField(field, appsmithFieldType);\n}\n}\nfield.setAccessible(false);\nif (candidateField != null) {\n\/\/ This will only ever be null if the field value is populated,\n\/\/ and is known to be a non-encryption related field\nfinalCandidateFields.add(candidateField);\n}\n} else if (Collection.class.isAssignableFrom(field.getType()) &&\nfield.getGenericType() instanceof ParameterizedType) {\n\/\/ If this is a collection, check if the Type parameter is an AppsmithDomain\nType[] typeArguments;\nParameterizedType parameterizedType = (ParameterizedType) field.getGenericType();\ntypeArguments = parameterizedType.getActualTypeArguments();\nClass<?> subFieldType;\ntry {\nsubFieldType = (Class<?>) typeArguments[0];\n} catch (ClassCastException|ArrayIndexOutOfBoundsException e) {\nsubFieldType = null;\n}\nif(subFieldType != null) {\nif (this.encryptedFieldsMap.containsKey(subFieldType)) {\n\/\/ This is a known type, it should necessarily be of AppsmithDomain type\nassert AppsmithDomain.class.isAssignableFrom(subFieldType);\nfinal List<CandidateField> existingSubTypeCandidates = this.encryptedFieldsMap.get(subFieldType);\nif (!existingSubTypeCandidates.isEmpty()) {\nfinalCandidateFields.add(new CandidateField(field, CandidateField.Type.APPSMITH_COLLECTION_KNOWN));\n}\n} else if (AppsmithDomain.class.isAssignableFrom(subFieldType)) {\n\/\/ If the type is not known, then this is either not parsed yet, or has polymorphic implementations\nfield.setAccessible(true);\n\nfield.setAccessible(false);\nif (candidateField != null) {\n\/\/ This will only ever be null if the field value is populated,\n\/\/ and is known to be a non-encryption related field\nfinalCandidateFields.add(candidateField);\n}\n} else if (Collection.class.isAssignableFrom(field.getType()) &&\nfield.getGenericType() instanceof ParameterizedType) {\n\/\/ If this is a collection, check if the Type parameter is an AppsmithDomain\nType[] typeArguments;\nParameterizedType parameterizedType = (ParameterizedType) field.getGenericType();\ntypeArguments = parameterizedType.getActualTypeArguments();\nClass<?> subFieldType;\ntry {\nsubFieldType = (Class<?>) typeArguments[0];\n} catch (ClassCastException|ArrayIndexOutOfBoundsException e) {\nsubFieldType = null;\n}\nif(subFieldType != null) {\nif (this.encryptedFieldsMap.containsKey(subFieldType)) {\n\/\/ This is a known type, it should necessarily be of AppsmithDomain type\nassert AppsmithDomain.class.isAssignableFrom(subFieldType);\nfinal List<CandidateField> existingSubTypeCandidates = this.encryptedFieldsMap.get(subFieldType);\nif (!existingSubTypeCandidates.isEmpty()) {\nfinalCandidateFields.add(new CandidateField(field, CandidateField.Type.APPSMITH_COLLECTION_KNOWN));\n}\n} else if (AppsmithDomain.class.isAssignableFrom(subFieldType)) {\n\/\/ If the type is not known, then this is either not parsed yet, or has polymorphic implementations\nfield.setAccessible(true);\nObject fieldValue = ReflectionUtils.getField(field, source);\nCollection<?> collection = (Collection<?>) fieldValue;\nif (collection == null || collection.isEmpty()) {\nfinalCandidateFields.add(new CandidateField(field, CandidateField.Type.APPSMITH_COLLECTION_UNKNOWN));\n} else {\nfor (final Object o : collection) {\nif (o == null) {\ncontinue;\n}\nif (o.getClass().getCanonicalName().equals(subFieldType.getTypeName())) {\nfinal List<CandidateField> candidateFieldsForListMember = findCandidateFieldsForType(o);\nif (candidateFieldsForListMember != null && !candidateFieldsForListMember.isEmpty()) {\n\nfield.getGenericType() instanceof ParameterizedType) {\n\/\/ If this is a collection, check if the Type parameter is an AppsmithDomain\nType[] typeArguments;\nParameterizedType parameterizedType = (ParameterizedType) field.getGenericType();\ntypeArguments = parameterizedType.getActualTypeArguments();\nClass<?> subFieldType;\ntry {\nsubFieldType = (Class<?>) typeArguments[0];\n} catch (ClassCastException|ArrayIndexOutOfBoundsException e) {\nsubFieldType = null;\n}\nif(subFieldType != null) {\nif (this.encryptedFieldsMap.containsKey(subFieldType)) {\n\/\/ This is a known type, it should necessarily be of AppsmithDomain type\nassert AppsmithDomain.class.isAssignableFrom(subFieldType);\nfinal List<CandidateField> existingSubTypeCandidates = this.encryptedFieldsMap.get(subFieldType);\nif (!existingSubTypeCandidates.isEmpty()) {\nfinalCandidateFields.add(new CandidateField(field, CandidateField.Type.APPSMITH_COLLECTION_KNOWN));\n}\n} else if (AppsmithDomain.class.isAssignableFrom(subFieldType)) {\n\/\/ If the type is not known, then this is either not parsed yet, or has polymorphic implementations\nfield.setAccessible(true);\nObject fieldValue = ReflectionUtils.getField(field, source);\nCollection<?> collection = (Collection<?>) fieldValue;\nif (collection == null || collection.isEmpty()) {\nfinalCandidateFields.add(new CandidateField(field, CandidateField.Type.APPSMITH_COLLECTION_UNKNOWN));\n} else {\nfor (final Object o : collection) {\nif (o == null) {\ncontinue;\n}\nif (o.getClass().getCanonicalName().equals(subFieldType.getTypeName())) {\nfinal List<CandidateField> candidateFieldsForListMember = findCandidateFieldsForType(o);\nif (candidateFieldsForListMember != null && !candidateFieldsForListMember.isEmpty()) {\nfinalCandidateFields.add(new CandidateField(field, CandidateField.Type.APPSMITH_COLLECTION_KNOWN));\n}\n} else {\nfinalCandidateFields.add(new CandidateField(field, CandidateField.Type.APPSMITH_COLLECTION_POLYMORPHIC));\n}\nbreak;\n}\n\nfinalCandidateFields.add(new CandidateField(field, CandidateField.Type.APPSMITH_COLLECTION_UNKNOWN));\n} else {\nfor (final Object o : collection) {\nif (o == null) {\ncontinue;\n}\nif (o.getClass().getCanonicalName().equals(subFieldType.getTypeName())) {\nfinal List<CandidateField> candidateFieldsForListMember = findCandidateFieldsForType(o);\nif (candidateFieldsForListMember != null && !candidateFieldsForListMember.isEmpty()) {\nfinalCandidateFields.add(new CandidateField(field, CandidateField.Type.APPSMITH_COLLECTION_KNOWN));\n}\n} else {\nfinalCandidateFields.add(new CandidateField(field, CandidateField.Type.APPSMITH_COLLECTION_POLYMORPHIC));\n}\nbreak;\n}\n}\nfield.setAccessible(false);\n}\n}\n\/\/ TODO Add support for nested collections\n} else if (Map.class.isAssignableFrom(field.getType()) &&\nfield.getGenericType() instanceof ParameterizedType) {\nType[] typeArguments;\nParameterizedType parameterizedType = (ParameterizedType) field.getGenericType();\ntypeArguments = parameterizedType.getActualTypeArguments();\nClass<?> subFieldType = (Class<?>) typeArguments[1];\nif (this.encryptedFieldsMap.containsKey(subFieldType)) {\n\/\/ This is a known type, it should necessarily be of AppsmithDomain type\nassert AppsmithDomain.class.isAssignableFrom(subFieldType);\nfinal List<CandidateField> existingSubTypeCandidates = this.encryptedFieldsMap.get(subFieldType);\nif (!existingSubTypeCandidates.isEmpty()) {\nfinalCandidateFields.add(new CandidateField(field, CandidateField.Type.APPSMITH_MAP_KNOWN));\n}\n} else if (AppsmithDomain.class.isAssignableFrom(subFieldType)) {\n\/\/ If the type is not known, then this is either not parsed yet, or has polymorphic implementations\nfield.setAccessible(true);\nObject fieldValue = ReflectionUtils.getField(field, source);\nMap<?, ?> map = (Map<?, ?>) fieldValue;\nif (map == null || map.isEmpty()) {\nfinalCandidateFields.add(new CandidateField(field, CandidateField.Type.APPSMITH_MAP_UNKNOWN));\n\nfield.setAccessible(false);\nif (candidateField != null) {\n\/\/ This will only ever be null if the field value is populated,\n\/\/ and is known to be a non-encryption related field\nfinalCandidateFields.add(candidateField);\n}\n} else if (Collection.class.isAssignableFrom(field.getType()) &&\nfield.getGenericType() instanceof ParameterizedType) {\n\/\/ If this is a collection, check if the Type parameter is an AppsmithDomain\nType[] typeArguments;\nParameterizedType parameterizedType = (ParameterizedType) field.getGenericType();\ntypeArguments = parameterizedType.getActualTypeArguments();\nClass<?> subFieldType;\ntry {\nsubFieldType = (Class<?>) typeArguments[0];\n} catch (ClassCastException|ArrayIndexOutOfBoundsException e) {\nsubFieldType = null;\n}\nif(subFieldType != null) {\nif (this.encryptedFieldsMap.containsKey(subFieldType)) {\n\/\/ This is a known type, it should necessarily be of AppsmithDomain type\nassert AppsmithDomain.class.isAssignableFrom(subFieldType);\nfinal List<CandidateField> existingSubTypeCandidates = this.encryptedFieldsMap.get(subFieldType);\nif (!existingSubTypeCandidates.isEmpty()) {\nfinalCandidateFields.add(new CandidateField(field, CandidateField.Type.APPSMITH_COLLECTION_KNOWN));\n}\n} else if (AppsmithDomain.class.isAssignableFrom(subFieldType)) {\n\/\/ If the type is not known, then this is either not parsed yet, or has polymorphic implementations\nfield.setAccessible(true);\nObject fieldValue = ReflectionUtils.getField(field, source);\nCollection<?> collection = (Collection<?>) fieldValue;\nif (collection == null || collection.isEmpty()) {\nfinalCandidateFields.add(new CandidateField(field, CandidateField.Type.APPSMITH_COLLECTION_UNKNOWN));\n} else {\nfor (final Object o : collection) {\nif (o == null) {\ncontinue;\n}\nif (o.getClass().getCanonicalName().equals(subFieldType.getTypeName())) {\nfinal List<CandidateField> candidateFieldsForListMember = findCandidateFieldsForType(o);\nif (candidateFieldsForListMember != null && !candidateFieldsForListMember.isEmpty()) {\n\nfield.getGenericType() instanceof ParameterizedType) {\n\/\/ If this is a collection, check if the Type parameter is an AppsmithDomain\nType[] typeArguments;\nParameterizedType parameterizedType = (ParameterizedType) field.getGenericType();\ntypeArguments = parameterizedType.getActualTypeArguments();\nClass<?> subFieldType;\ntry {\nsubFieldType = (Class<?>) typeArguments[0];\n} catch (ClassCastException|ArrayIndexOutOfBoundsException e) {\nsubFieldType = null;\n}\nif(subFieldType != null) {\nif (this.encryptedFieldsMap.containsKey(subFieldType)) {\n\/\/ This is a known type, it should necessarily be of AppsmithDomain type\nassert AppsmithDomain.class.isAssignableFrom(subFieldType);\nfinal List<CandidateField> existingSubTypeCandidates = this.encryptedFieldsMap.get(subFieldType);\nif (!existingSubTypeCandidates.isEmpty()) {\nfinalCandidateFields.add(new CandidateField(field, CandidateField.Type.APPSMITH_COLLECTION_KNOWN));\n}\n} else if (AppsmithDomain.class.isAssignableFrom(subFieldType)) {\n\/\/ If the type is not known, then this is either not parsed yet, or has polymorphic implementations\nfield.setAccessible(true);\nObject fieldValue = ReflectionUtils.getField(field, source);\nCollection<?> collection = (Collection<?>) fieldValue;\nif (collection == null || collection.isEmpty()) {\nfinalCandidateFields.add(new CandidateField(field, CandidateField.Type.APPSMITH_COLLECTION_UNKNOWN));\n} else {\nfor (final Object o : collection) {\nif (o == null) {\ncontinue;\n}\nif (o.getClass().getCanonicalName().equals(subFieldType.getTypeName())) {\nfinal List<CandidateField> candidateFieldsForListMember = findCandidateFieldsForType(o);\nif (candidateFieldsForListMember != null && !candidateFieldsForListMember.isEmpty()) {\nfinalCandidateFields.add(new CandidateField(field, CandidateField.Type.APPSMITH_COLLECTION_KNOWN));\n}\n} else {\nfinalCandidateFields.add(new CandidateField(field, CandidateField.Type.APPSMITH_COLLECTION_POLYMORPHIC));\n}\nbreak;\n}\n\n}\nif (value.getClass().getCanonicalName().equals(subFieldType.getTypeName())) {\nfinal List<CandidateField> candidateFieldsForListMember = findCandidateFieldsForType(value);\nif (candidateFieldsForListMember != null && !candidateFieldsForListMember.isEmpty()) {\nfinalCandidateFields.add(new CandidateField(field, CandidateField.Type.APPSMITH_MAP_KNOWN));\n}\n} else {\nfinalCandidateFields.add(new CandidateField(field, CandidateField.Type.APPSMITH_MAP_POLYMORPHIC));\n}\nbreak;\n}\n}\nfield.setAccessible(false);\n}\n}\n}, field -> field.getAnnotation(Encrypted.class) != null ||\nAppsmithDomain.class.isAssignableFrom(field.getType()) ||\nCollection.class.isAssignableFrom(field.getType()) ||\nMap.class.isAssignableFrom(field.getType()));\n}\n\/\/ Update cache for next use\nencryptedFieldsMap.put(sourceClass, finalCandidateFields);\nreturn finalCandidateFields;\n}","label":[0,1,0,0]}
{"id":1644,"original_code":"public static void setFirstDateAsDCT(SieveDocument doc) {\n    if (doc.getDocstamp() == null) {\n      for (Timex nextTimex : doc.getTimexes()) {\n        if (nextTimex.getType().equals(Timex.Type.DATE)) {\n          nextTimex.setDocumentFunction(DocumentFunction.CREATION_TIME);\n          doc.addCreationTime(nextTimex);\n          break;\n        }\n      }\n    }\n  }","code":"public static void setFirstDateAsDCT(SieveDocument doc) {\n    if (doc.getDocstamp() == null) {\n      for (Timex nextTimex : doc.getTimexes()) {\n        if (nextTimex.getType().equals(Timex.Type.DATE)) {\n          nextTimex.setDocumentFunction(DocumentFunction.CREATION_TIME);\n          doc.addCreationTime(nextTimex);\n          break;\n        }\n      }\n    }\n  }","cleancode":"public static void setfirstdateasdct(sievedocument doc) { if (doc.getdocstamp() == null) { for (timex nexttimex : doc.gettimexes()) { if (nexttimex.gettype().equals(timex.type.date)) { nexttimex.setdocumentfunction(documentfunction.creation_time); doc.addcreationtime(nexttimex); break; } } } }","comment":"\/** * @desc sets the first timex of type date in the document timex list as the * document creation time todo: make sure \"first\" in list is necessarily * first that appears in document! should be, unless the relevant string * is somehow dropped during sentence tokenization. *\/","repo":"nchambers\/caevo","code_context_2":"public static void setFirstDateAsDCT(SieveDocument doc) {\nif (doc.getDocstamp() == null) {\nfor (Timex nextTimex : doc.getTimexes()) {\nif (nextTimex.getType().equals(Timex.Type.DATE)) {\nnextTimex.setDocumentFunction(DocumentFunction.CREATION_TIME);\ndoc.addCreationTime(nextTimex);\nbreak;\n}\n}\n}\n}","code_context_10":"public static void setFirstDateAsDCT(SieveDocument doc) {\nif (doc.getDocstamp() == null) {\nfor (Timex nextTimex : doc.getTimexes()) {\nif (nextTimex.getType().equals(Timex.Type.DATE)) {\nnextTimex.setDocumentFunction(DocumentFunction.CREATION_TIME);\ndoc.addCreationTime(nextTimex);\nbreak;\n}\n}\n}\n}","code_context_20":"public static void setFirstDateAsDCT(SieveDocument doc) {\nif (doc.getDocstamp() == null) {\nfor (Timex nextTimex : doc.getTimexes()) {\nif (nextTimex.getType().equals(Timex.Type.DATE)) {\nnextTimex.setDocumentFunction(DocumentFunction.CREATION_TIME);\ndoc.addCreationTime(nextTimex);\nbreak;\n}\n}\n}\n}","label":[1,0,0,0]}
{"id":26251,"original_code":"public SetterType determineSetterType(String expression) {\n       \/\/ TODO: if (expression.contains(\"setb\")) return SetterType.BUILDER;\n       if(expression.contains(\"setf\"))\n           return SetterType.FIELD;\n       return SetterType.METHOD;\n    }","code":"public SetterType determineSetterType(String expression) {\n      \n       if(expression.contains(\"setf\"))\n           return SetterType.FIELD;\n       return SetterType.METHOD;\n    }","cleancode":"public settertype determinesettertype(string expression) { if(expression.contains(\"setf\")) return settertype.field; return settertype.method; }","comment":"\/** * a setterwriter expression is one of the following * * \/\/ set: * \/\/ setf: * \/\/ setb: * * @param expression * @return *\/\n\/\/ todo: if (expression.contains(\"setb\")) return settertype.builder;","repo":"nndi-oss\/intellij-just-sett","code_context_2":"public SetterType determineSetterType(String expression) {\n\/\/ TODO: if (expression.contains(\"setb\")) return SetterType.BUILDER;\nif(expression.contains(\"setf\"))\nreturn SetterType.FIELD;\nreturn SetterType.METHOD;\n}\n\npublic SetterType determineSetterType(String expression) {\n\/\/ TODO: if (expression.contains(\"setb\")) return SetterType.BUILDER;\nif(expression.contains(\"setf\"))\nreturn SetterType.FIELD;","code_context_10":"public SetterType determineSetterType(String expression) {\n\/\/ TODO: if (expression.contains(\"setb\")) return SetterType.BUILDER;\nif(expression.contains(\"setf\"))\nreturn SetterType.FIELD;\nreturn SetterType.METHOD;\n}\n\npublic SetterType determineSetterType(String expression) {\n\/\/ TODO: if (expression.contains(\"setb\")) return SetterType.BUILDER;\nif(expression.contains(\"setf\"))\nreturn SetterType.FIELD;\nreturn SetterType.METHOD;\n}","code_context_20":"public SetterType determineSetterType(String expression) {\n\/\/ TODO: if (expression.contains(\"setb\")) return SetterType.BUILDER;\nif(expression.contains(\"setf\"))\nreturn SetterType.FIELD;\nreturn SetterType.METHOD;\n}\n\npublic SetterType determineSetterType(String expression) {\n\/\/ TODO: if (expression.contains(\"setb\")) return SetterType.BUILDER;\nif(expression.contains(\"setf\"))\nreturn SetterType.FIELD;\nreturn SetterType.METHOD;\n}","label":[0,1,0,0]}
{"id":1701,"original_code":"public static boolean isPasswordValid(String password) {\n        \/\/TODO: Replace this with your own logic\n        return password.length() > 4;\n    }","code":"public static boolean isPasswordValid(String password) {\n       \n        return password.length() > 4;\n    }","cleancode":"public static boolean ispasswordvalid(string password) { return password.length() > 4; }","comment":"\/\/todo: replace this with your own logic","repo":"neiplz\/Pedometer","code_context_2":"public static boolean isPasswordValid(String password) {\n\/\/TODO: Replace this with your own logic\nreturn password.length() > 4;\n}","code_context_10":"public static boolean isPasswordValid(String password) {\n\/\/TODO: Replace this with your own logic\nreturn password.length() > 4;\n}","code_context_20":"public static boolean isPasswordValid(String password) {\n\/\/TODO: Replace this with your own logic\nreturn password.length() > 4;\n}","label":[1,0,0,0]}
{"id":26305,"original_code":"private void updateRule() {\n        Recur.Builder<LocalDate> rBuilder = new Recur.Builder<>();\n        switch (frequencyBox.getValue()) {\n            case DAILY:\n                rBuilder.frequency(net.fortuna.ical4j.model.Recur.Frequency.DAILY);\n                break;\n            case MONTHLY:\n                rBuilder.frequency(net.fortuna.ical4j.model.Recur.Frequency.MONTHLY);\n                break;\n            case WEEKLY:\n                rBuilder.frequency(net.fortuna.ical4j.model.Recur.Frequency.WEEKLY);\n                break;\n            case YEARLY:\n                rBuilder.frequency(net.fortuna.ical4j.model.Recur.Frequency.YEARLY);\n                break;\n            default:\n                break;\n        }\n        int interval = repeatCountSpinner.getValue();\n        if (interval > 1) {\n            rBuilder.interval(interval);\n        } else {\n            rBuilder.interval(0);\n        }\n        if (endsOnButton.isSelected()) {\n            LocalDate date = endsOnDatePicker.getValue();\n            rBuilder.until(date);\n        }\n        if (endsAfterButton.isSelected()) {\n            rBuilder.count(endsAfterCounterSpinner.getValue());\n        }\n        if (frequencyBox.getValue() == Frequency.MONTHLY) {\n            if (repeatByDayOfTheMonth.isSelected()) {\n                int value = getSkinnable().getStartDate().getDayOfMonth();\n                rBuilder.monthList(new NumberList(value, value, false));\n            } else {\n                LocalDate localDate = getSkinnable().getStartDate();\n                \/\/ TODO: use zone id of context (entry, calendar)\n                ZonedDateTime zonedDateTime = ZonedDateTime.of(localDate,\n                        LocalTime.now(), ZoneId.systemDefault());\n                int hits = 1;\n                ZonedDateTime current = zonedDateTime.withDayOfMonth(1);\n                do {\n                    if (current.getDayOfWeek()\n                            .equals(zonedDateTime.getDayOfWeek())) {\n                        hits++;\n                    }\n                    current = current.plusDays(1);\n                } while (current.toLocalDate().isBefore(localDate));\n                WeekDayList weekdays = new WeekDayList();\n                switch (zonedDateTime.getDayOfWeek()) {\n                    case FRIDAY:\n                        weekdays.add(new WeekDay(WeekDay.FR, hits));\n                        break;\n                    case MONDAY:\n                        weekdays.add(new WeekDay(WeekDay.MO, hits));\n                        break;\n                    case SATURDAY:\n                        weekdays.add(new WeekDay(WeekDay.SA, hits));\n                        break;\n                    case SUNDAY:\n                        weekdays.add(new WeekDay(WeekDay.SU, hits));\n                        break;\n                    case THURSDAY:\n                        weekdays.add(new WeekDay(WeekDay.TH, hits));\n                        break;\n                    case TUESDAY:\n                        weekdays.add(new WeekDay(WeekDay.TU, hits));\n                        break;\n                    case WEDNESDAY:\n                        weekdays.add(new WeekDay(WeekDay.WE, hits));\n                        break;\n                    default:\n                        break;\n                }\n                rBuilder.dayList(weekdays);\n            }\n        }\n        if (frequencyBox.getValue() == Frequency.WEEKLY) {\n            \/*\n             * Weekdays MO, TU, .... SU\n             *\/\n            WeekDayList weekdays = new WeekDayList();\n            maybeAddWeekday(weekdays, WeekDay.MO,\n                    weekDayMondayButton);\n            maybeAddWeekday(weekdays, WeekDay.TU,\n                    weekDayTuesdayButton);\n            maybeAddWeekday(weekdays, WeekDay.WE,\n                    weekDayWednesdayButton);\n            maybeAddWeekday(weekdays, WeekDay.TH,\n                    weekDayThursdayButton);\n            maybeAddWeekday(weekdays, WeekDay.FR,\n                    weekDayFridayButton);\n            maybeAddWeekday(weekdays, WeekDay.SA,\n                    weekDaySaturdayButton);\n            maybeAddWeekday(weekdays, WeekDay.SU,\n                    weekDaySundayButton);\n            rBuilder.dayList(weekdays);\n        }\n        Recur<LocalDate> rule = rBuilder.build();\n        getSkinnable().setRecurrenceRule(rule.toString());\n        if (LoggingDomain.RECURRENCE.isLoggable(Level.FINE)) {\n            LoggingDomain.RECURRENCE.fine(\n                    \"test dumping 10 recurrences starting with today's date\");\n            LocalDate today = LocalDate.of(2015, 8, 18);\n            List<LocalDate> dates = rule.getDates(today, today, LocalDate.MAX, 10);\n            for (LocalDate repeatingDate : dates) {\n                LoggingDomain.RECURRENCE.fine(repeatingDate.toString());\n            }\n        }\n    }","code":"private void updateRule() {\n        Recur.Builder<LocalDate> rBuilder = new Recur.Builder<>();\n        switch (frequencyBox.getValue()) {\n            case DAILY:\n                rBuilder.frequency(net.fortuna.ical4j.model.Recur.Frequency.DAILY);\n                break;\n            case MONTHLY:\n                rBuilder.frequency(net.fortuna.ical4j.model.Recur.Frequency.MONTHLY);\n                break;\n            case WEEKLY:\n                rBuilder.frequency(net.fortuna.ical4j.model.Recur.Frequency.WEEKLY);\n                break;\n            case YEARLY:\n                rBuilder.frequency(net.fortuna.ical4j.model.Recur.Frequency.YEARLY);\n                break;\n            default:\n                break;\n        }\n        int interval = repeatCountSpinner.getValue();\n        if (interval > 1) {\n            rBuilder.interval(interval);\n        } else {\n            rBuilder.interval(0);\n        }\n        if (endsOnButton.isSelected()) {\n            LocalDate date = endsOnDatePicker.getValue();\n            rBuilder.until(date);\n        }\n        if (endsAfterButton.isSelected()) {\n            rBuilder.count(endsAfterCounterSpinner.getValue());\n        }\n        if (frequencyBox.getValue() == Frequency.MONTHLY) {\n            if (repeatByDayOfTheMonth.isSelected()) {\n                int value = getSkinnable().getStartDate().getDayOfMonth();\n                rBuilder.monthList(new NumberList(value, value, false));\n            } else {\n                LocalDate localDate = getSkinnable().getStartDate();\n               \n                ZonedDateTime zonedDateTime = ZonedDateTime.of(localDate,\n                        LocalTime.now(), ZoneId.systemDefault());\n                int hits = 1;\n                ZonedDateTime current = zonedDateTime.withDayOfMonth(1);\n                do {\n                    if (current.getDayOfWeek()\n                            .equals(zonedDateTime.getDayOfWeek())) {\n                        hits++;\n                    }\n                    current = current.plusDays(1);\n                } while (current.toLocalDate().isBefore(localDate));\n                WeekDayList weekdays = new WeekDayList();\n                switch (zonedDateTime.getDayOfWeek()) {\n                    case FRIDAY:\n                        weekdays.add(new WeekDay(WeekDay.FR, hits));\n                        break;\n                    case MONDAY:\n                        weekdays.add(new WeekDay(WeekDay.MO, hits));\n                        break;\n                    case SATURDAY:\n                        weekdays.add(new WeekDay(WeekDay.SA, hits));\n                        break;\n                    case SUNDAY:\n                        weekdays.add(new WeekDay(WeekDay.SU, hits));\n                        break;\n                    case THURSDAY:\n                        weekdays.add(new WeekDay(WeekDay.TH, hits));\n                        break;\n                    case TUESDAY:\n                        weekdays.add(new WeekDay(WeekDay.TU, hits));\n                        break;\n                    case WEDNESDAY:\n                        weekdays.add(new WeekDay(WeekDay.WE, hits));\n                        break;\n                    default:\n                        break;\n                }\n                rBuilder.dayList(weekdays);\n            }\n        }\n        if (frequencyBox.getValue() == Frequency.WEEKLY) {\n           \n            WeekDayList weekdays = new WeekDayList();\n            maybeAddWeekday(weekdays, WeekDay.MO,\n                    weekDayMondayButton);\n            maybeAddWeekday(weekdays, WeekDay.TU,\n                    weekDayTuesdayButton);\n            maybeAddWeekday(weekdays, WeekDay.WE,\n                    weekDayWednesdayButton);\n            maybeAddWeekday(weekdays, WeekDay.TH,\n                    weekDayThursdayButton);\n            maybeAddWeekday(weekdays, WeekDay.FR,\n                    weekDayFridayButton);\n            maybeAddWeekday(weekdays, WeekDay.SA,\n                    weekDaySaturdayButton);\n            maybeAddWeekday(weekdays, WeekDay.SU,\n                    weekDaySundayButton);\n            rBuilder.dayList(weekdays);\n        }\n        Recur<LocalDate> rule = rBuilder.build();\n        getSkinnable().setRecurrenceRule(rule.toString());\n        if (LoggingDomain.RECURRENCE.isLoggable(Level.FINE)) {\n            LoggingDomain.RECURRENCE.fine(\n                    \"test dumping 10 recurrences starting with today's date\");\n            LocalDate today = LocalDate.of(2015, 8, 18);\n            List<LocalDate> dates = rule.getDates(today, today, LocalDate.MAX, 10);\n            for (LocalDate repeatingDate : dates) {\n                LoggingDomain.RECURRENCE.fine(repeatingDate.toString());\n            }\n        }\n    }","cleancode":"private void updaterule() { recur.builder<localdate> rbuilder = new recur.builder<>(); switch (frequencybox.getvalue()) { case daily: rbuilder.frequency(net.fortuna.ical4j.model.recur.frequency.daily); break; case monthly: rbuilder.frequency(net.fortuna.ical4j.model.recur.frequency.monthly); break; case weekly: rbuilder.frequency(net.fortuna.ical4j.model.recur.frequency.weekly); break; case yearly: rbuilder.frequency(net.fortuna.ical4j.model.recur.frequency.yearly); break; default: break; } int interval = repeatcountspinner.getvalue(); if (interval > 1) { rbuilder.interval(interval); } else { rbuilder.interval(0); } if (endsonbutton.isselected()) { localdate date = endsondatepicker.getvalue(); rbuilder.until(date); } if (endsafterbutton.isselected()) { rbuilder.count(endsaftercounterspinner.getvalue()); } if (frequencybox.getvalue() == frequency.monthly) { if (repeatbydayofthemonth.isselected()) { int value = getskinnable().getstartdate().getdayofmonth(); rbuilder.monthlist(new numberlist(value, value, false)); } else { localdate localdate = getskinnable().getstartdate(); zoneddatetime zoneddatetime = zoneddatetime.of(localdate, localtime.now(), zoneid.systemdefault()); int hits = 1; zoneddatetime current = zoneddatetime.withdayofmonth(1); do { if (current.getdayofweek() .equals(zoneddatetime.getdayofweek())) { hits++; } current = current.plusdays(1); } while (current.tolocaldate().isbefore(localdate)); weekdaylist weekdays = new weekdaylist(); switch (zoneddatetime.getdayofweek()) { case friday: weekdays.add(new weekday(weekday.fr, hits)); break; case monday: weekdays.add(new weekday(weekday.mo, hits)); break; case saturday: weekdays.add(new weekday(weekday.sa, hits)); break; case sunday: weekdays.add(new weekday(weekday.su, hits)); break; case thursday: weekdays.add(new weekday(weekday.th, hits)); break; case tuesday: weekdays.add(new weekday(weekday.tu, hits)); break; case wednesday: weekdays.add(new weekday(weekday.we, hits)); break; default: break; } rbuilder.daylist(weekdays); } } if (frequencybox.getvalue() == frequency.weekly) { weekdaylist weekdays = new weekdaylist(); maybeaddweekday(weekdays, weekday.mo, weekdaymondaybutton); maybeaddweekday(weekdays, weekday.tu, weekdaytuesdaybutton); maybeaddweekday(weekdays, weekday.we, weekdaywednesdaybutton); maybeaddweekday(weekdays, weekday.th, weekdaythursdaybutton); maybeaddweekday(weekdays, weekday.fr, weekdayfridaybutton); maybeaddweekday(weekdays, weekday.sa, weekdaysaturdaybutton); maybeaddweekday(weekdays, weekday.su, weekdaysundaybutton); rbuilder.daylist(weekdays); } recur<localdate> rule = rbuilder.build(); getskinnable().setrecurrencerule(rule.tostring()); if (loggingdomain.recurrence.isloggable(level.fine)) { loggingdomain.recurrence.fine( \"test dumping 10 recurrences starting with today's date\"); localdate today = localdate.of(2015, 8, 18); list<localdate> dates = rule.getdates(today, today, localdate.max, 10); for (localdate repeatingdate : dates) { loggingdomain.recurrence.fine(repeatingdate.tostring()); } } }","comment":"\/\/ todo: use zone id of context (entry, calendar)\n\/* * weekdays mo, tu, .... su *\/","repo":"mwkroening\/CalendarFX","code_context_2":"} else {\nLocalDate localDate = getSkinnable().getStartDate();\n\/\/ TODO: use zone id of context (entry, calendar)\nZonedDateTime zonedDateTime = ZonedDateTime.of(localDate,\nLocalTime.now(), ZoneId.systemDefault());\n\n}\nif (frequencyBox.getValue() == Frequency.WEEKLY) {\n\/*\n* Weekdays MO, TU, .... SU\n*\/\nWeekDayList weekdays = new WeekDayList();\nmaybeAddWeekday(weekdays, WeekDay.MO,","code_context_10":"}\nif (endsAfterButton.isSelected()) {\nrBuilder.count(endsAfterCounterSpinner.getValue());\n}\nif (frequencyBox.getValue() == Frequency.MONTHLY) {\nif (repeatByDayOfTheMonth.isSelected()) {\nint value = getSkinnable().getStartDate().getDayOfMonth();\nrBuilder.monthList(new NumberList(value, value, false));\n} else {\nLocalDate localDate = getSkinnable().getStartDate();\n\/\/ TODO: use zone id of context (entry, calendar)\nZonedDateTime zonedDateTime = ZonedDateTime.of(localDate,\nLocalTime.now(), ZoneId.systemDefault());\nint hits = 1;\nZonedDateTime current = zonedDateTime.withDayOfMonth(1);\ndo {\nif (current.getDayOfWeek()\n.equals(zonedDateTime.getDayOfWeek())) {\nhits++;\n}\ncurrent = current.plusDays(1);\n\ncase WEDNESDAY:\nweekdays.add(new WeekDay(WeekDay.WE, hits));\nbreak;\ndefault:\nbreak;\n}\nrBuilder.dayList(weekdays);\n}\n}\nif (frequencyBox.getValue() == Frequency.WEEKLY) {\n\/*\n* Weekdays MO, TU, .... SU\n*\/\nWeekDayList weekdays = new WeekDayList();\nmaybeAddWeekday(weekdays, WeekDay.MO,\nweekDayMondayButton);\nmaybeAddWeekday(weekdays, WeekDay.TU,\nweekDayTuesdayButton);\nmaybeAddWeekday(weekdays, WeekDay.WE,\nweekDayWednesdayButton);\nmaybeAddWeekday(weekdays, WeekDay.TH,\nweekDayThursdayButton);\nmaybeAddWeekday(weekdays, WeekDay.FR,","code_context_20":"}\nint interval = repeatCountSpinner.getValue();\nif (interval > 1) {\nrBuilder.interval(interval);\n} else {\nrBuilder.interval(0);\n}\nif (endsOnButton.isSelected()) {\nLocalDate date = endsOnDatePicker.getValue();\nrBuilder.until(date);\n}\nif (endsAfterButton.isSelected()) {\nrBuilder.count(endsAfterCounterSpinner.getValue());\n}\nif (frequencyBox.getValue() == Frequency.MONTHLY) {\nif (repeatByDayOfTheMonth.isSelected()) {\nint value = getSkinnable().getStartDate().getDayOfMonth();\nrBuilder.monthList(new NumberList(value, value, false));\n} else {\nLocalDate localDate = getSkinnable().getStartDate();\n\/\/ TODO: use zone id of context (entry, calendar)\nZonedDateTime zonedDateTime = ZonedDateTime.of(localDate,\nLocalTime.now(), ZoneId.systemDefault());\nint hits = 1;\nZonedDateTime current = zonedDateTime.withDayOfMonth(1);\ndo {\nif (current.getDayOfWeek()\n.equals(zonedDateTime.getDayOfWeek())) {\nhits++;\n}\ncurrent = current.plusDays(1);\n} while (current.toLocalDate().isBefore(localDate));\nWeekDayList weekdays = new WeekDayList();\nswitch (zonedDateTime.getDayOfWeek()) {\ncase FRIDAY:\nweekdays.add(new WeekDay(WeekDay.FR, hits));\nbreak;\ncase MONDAY:\nweekdays.add(new WeekDay(WeekDay.MO, hits));\nbreak;\ncase SATURDAY:\n\nbreak;\ncase SUNDAY:\nweekdays.add(new WeekDay(WeekDay.SU, hits));\nbreak;\ncase THURSDAY:\nweekdays.add(new WeekDay(WeekDay.TH, hits));\nbreak;\ncase TUESDAY:\nweekdays.add(new WeekDay(WeekDay.TU, hits));\nbreak;\ncase WEDNESDAY:\nweekdays.add(new WeekDay(WeekDay.WE, hits));\nbreak;\ndefault:\nbreak;\n}\nrBuilder.dayList(weekdays);\n}\n}\nif (frequencyBox.getValue() == Frequency.WEEKLY) {\n\/*\n* Weekdays MO, TU, .... SU\n*\/\nWeekDayList weekdays = new WeekDayList();\nmaybeAddWeekday(weekdays, WeekDay.MO,\nweekDayMondayButton);\nmaybeAddWeekday(weekdays, WeekDay.TU,\nweekDayTuesdayButton);\nmaybeAddWeekday(weekdays, WeekDay.WE,\nweekDayWednesdayButton);\nmaybeAddWeekday(weekdays, WeekDay.TH,\nweekDayThursdayButton);\nmaybeAddWeekday(weekdays, WeekDay.FR,\nweekDayFridayButton);\nmaybeAddWeekday(weekdays, WeekDay.SA,\nweekDaySaturdayButton);\nmaybeAddWeekday(weekdays, WeekDay.SU,\nweekDaySundayButton);\nrBuilder.dayList(weekdays);\n}\nRecur<LocalDate> rule = rBuilder.build();\ngetSkinnable().setRecurrenceRule(rule.toString());\nif (LoggingDomain.RECURRENCE.isLoggable(Level.FINE)) {","label":[0,1,0,0]}
{"id":18334,"original_code":"private boolean checkDoorIsSealed(World world, BlockPosition pos, int meta)\n    {\n        \/\/TODO: door corners\n        return ((meta & 8) == 8\n                ||\n                ((meta & 4) >> 2 == (meta & 1) && checkDoorSeal(world, pos.getPositionAtOffset(0, 0, 1), meta)\n                        && checkDoorSeal(world, pos.getPositionAtOffset(0, 0, -1), meta))\n                ||\n                (meta & 4) >> 2 != (meta & 1) && checkDoorSeal(world, pos.getPositionAtOffset(1, 0, 0), meta)\n                        && checkDoorSeal(world, pos.getPositionAtOffset(-1, 0, 0), meta));\n    }","code":"private boolean checkDoorIsSealed(World world, BlockPosition pos, int meta)\n    {\n       \n        return ((meta & 8) == 8\n                ||\n                ((meta & 4) >> 2 == (meta & 1) && checkDoorSeal(world, pos.getPositionAtOffset(0, 0, 1), meta)\n                        && checkDoorSeal(world, pos.getPositionAtOffset(0, 0, -1), meta))\n                ||\n                (meta & 4) >> 2 != (meta & 1) && checkDoorSeal(world, pos.getPositionAtOffset(1, 0, 0), meta)\n                        && checkDoorSeal(world, pos.getPositionAtOffset(-1, 0, 0), meta));\n    }","cleancode":"private boolean checkdoorissealed(world world, blockposition pos, int meta) { return ((meta & 8) == 8 || ((meta & 4) >> 2 == (meta & 1) && checkdoorseal(world, pos.getpositionatoffset(0, 0, 1), meta) && checkdoorseal(world, pos.getpositionatoffset(0, 0, -1), meta)) || (meta & 4) >> 2 != (meta & 1) && checkdoorseal(world, pos.getpositionatoffset(1, 0, 0), meta) && checkdoorseal(world, pos.getpositionatoffset(-1, 0, 0), meta)); }","comment":"\/\/todo unit test, document, cleanup\n\/\/todo: door corners","repo":"phit\/AdvancedRocketry","code_context_2":"private boolean checkDoorIsSealed(World world, BlockPosition pos, int meta)\n{\n\/\/TODO: door corners\nreturn ((meta & 8) == 8\n||\n((meta & 4) >> 2 == (meta & 1) && checkDoorSeal(world, pos.getPositionAtOffset(0, 0, 1), meta)\n&& checkDoorSeal(world, pos.getPositionAtOffset(0, 0, -1), meta))\n||\n(meta & 4) >> 2 != (meta & 1) && checkDoorSeal(world, pos.getPositionAtOffset(1, 0, 0), meta)\n&& checkDoorSeal(world, pos.getPositionAtOffset(-1, 0, 0), meta));\n}\n\nprivate boolean checkDoorIsSealed(World world, BlockPosition pos, int meta)\n{\n\/\/TODO: door corners\nreturn ((meta & 8) == 8\n||","code_context_10":"private boolean checkDoorIsSealed(World world, BlockPosition pos, int meta)\n{\n\/\/TODO: door corners\nreturn ((meta & 8) == 8\n||\n((meta & 4) >> 2 == (meta & 1) && checkDoorSeal(world, pos.getPositionAtOffset(0, 0, 1), meta)\n&& checkDoorSeal(world, pos.getPositionAtOffset(0, 0, -1), meta))\n||\n(meta & 4) >> 2 != (meta & 1) && checkDoorSeal(world, pos.getPositionAtOffset(1, 0, 0), meta)\n&& checkDoorSeal(world, pos.getPositionAtOffset(-1, 0, 0), meta));\n}\n\nprivate boolean checkDoorIsSealed(World world, BlockPosition pos, int meta)\n{\n\/\/TODO: door corners\nreturn ((meta & 8) == 8\n||\n((meta & 4) >> 2 == (meta & 1) && checkDoorSeal(world, pos.getPositionAtOffset(0, 0, 1), meta)\n&& checkDoorSeal(world, pos.getPositionAtOffset(0, 0, -1), meta))\n||\n(meta & 4) >> 2 != (meta & 1) && checkDoorSeal(world, pos.getPositionAtOffset(1, 0, 0), meta)\n&& checkDoorSeal(world, pos.getPositionAtOffset(-1, 0, 0), meta));\n}","code_context_20":"private boolean checkDoorIsSealed(World world, BlockPosition pos, int meta)\n{\n\/\/TODO: door corners\nreturn ((meta & 8) == 8\n||\n((meta & 4) >> 2 == (meta & 1) && checkDoorSeal(world, pos.getPositionAtOffset(0, 0, 1), meta)\n&& checkDoorSeal(world, pos.getPositionAtOffset(0, 0, -1), meta))\n||\n(meta & 4) >> 2 != (meta & 1) && checkDoorSeal(world, pos.getPositionAtOffset(1, 0, 0), meta)\n&& checkDoorSeal(world, pos.getPositionAtOffset(-1, 0, 0), meta));\n}\n\nprivate boolean checkDoorIsSealed(World world, BlockPosition pos, int meta)\n{\n\/\/TODO: door corners\nreturn ((meta & 8) == 8\n||\n((meta & 4) >> 2 == (meta & 1) && checkDoorSeal(world, pos.getPositionAtOffset(0, 0, 1), meta)\n&& checkDoorSeal(world, pos.getPositionAtOffset(0, 0, -1), meta))\n||\n(meta & 4) >> 2 != (meta & 1) && checkDoorSeal(world, pos.getPositionAtOffset(1, 0, 0), meta)\n&& checkDoorSeal(world, pos.getPositionAtOffset(-1, 0, 0), meta));\n}","label":[1,0,0,0]}
{"id":18335,"original_code":"private boolean checkDoorSeal(World world, BlockPosition pos, int meta)\n    {\n        Block otherBlock = world.getBlock(pos.x, pos.y, pos.z);\n        int otherMeta = world.getBlockMetadata(pos.x, pos.y, pos.z);\n        return (otherBlock == AdvancedRocketryBlocks.blockAirLock && (otherMeta & 1) == (meta & 1)) ||\n                (otherBlock != AdvancedRocketryBlocks.blockAirLock && isBlockSealed(world, pos));\n    }","code":"private boolean checkDoorSeal(World world, BlockPosition pos, int meta)\n    {\n        Block otherBlock = world.getBlock(pos.x, pos.y, pos.z);\n        int otherMeta = world.getBlockMetadata(pos.x, pos.y, pos.z);\n        return (otherBlock == AdvancedRocketryBlocks.blockAirLock && (otherMeta & 1) == (meta & 1)) ||\n                (otherBlock != AdvancedRocketryBlocks.blockAirLock && isBlockSealed(world, pos));\n    }","cleancode":"private boolean checkdoorseal(world world, blockposition pos, int meta) { block otherblock = world.getblock(pos.x, pos.y, pos.z); int othermeta = world.getblockmetadata(pos.x, pos.y, pos.z); return (otherblock == advancedrocketryblocks.blockairlock && (othermeta & 1) == (meta & 1)) || (otherblock != advancedrocketryblocks.blockairlock && isblocksealed(world, pos)); }","comment":"\/\/todo unit test, document, cleanup","repo":"phit\/AdvancedRocketry","code_context_2":"private boolean checkDoorSeal(World world, BlockPosition pos, int meta)\n{\nBlock otherBlock = world.getBlock(pos.x, pos.y, pos.z);\nint otherMeta = world.getBlockMetadata(pos.x, pos.y, pos.z);\nreturn (otherBlock == AdvancedRocketryBlocks.blockAirLock && (otherMeta & 1) == (meta & 1)) ||\n(otherBlock != AdvancedRocketryBlocks.blockAirLock && isBlockSealed(world, pos));\n}","code_context_10":"private boolean checkDoorSeal(World world, BlockPosition pos, int meta)\n{\nBlock otherBlock = world.getBlock(pos.x, pos.y, pos.z);\nint otherMeta = world.getBlockMetadata(pos.x, pos.y, pos.z);\nreturn (otherBlock == AdvancedRocketryBlocks.blockAirLock && (otherMeta & 1) == (meta & 1)) ||\n(otherBlock != AdvancedRocketryBlocks.blockAirLock && isBlockSealed(world, pos));\n}","code_context_20":"private boolean checkDoorSeal(World world, BlockPosition pos, int meta)\n{\nBlock otherBlock = world.getBlock(pos.x, pos.y, pos.z);\nint otherMeta = world.getBlockMetadata(pos.x, pos.y, pos.z);\nreturn (otherBlock == AdvancedRocketryBlocks.blockAirLock && (otherMeta & 1) == (meta & 1)) ||\n(otherBlock != AdvancedRocketryBlocks.blockAirLock && isBlockSealed(world, pos));\n}","label":[0,0,0,0]}
{"id":34826,"original_code":"@Test(enabled=false)\n    public void testGetFutureConfigWhenReady() throws Exception {\n        MyPolicy policy = new MyPolicy(MutableMap.builder()\n                .put(TestEntity.CONF_NAME, DependentConfiguration.whenDone(Callables.returning(\"aval\")))\n                .build());\n        app.policies().add(policy);\n        assertEquals(policy.getConfig(TestEntity.CONF_NAME), \"aval\");\n    }","code":"@Test(enabled=false)\n    public void testGetFutureConfigWhenReady() throws Exception {\n        MyPolicy policy = new MyPolicy(MutableMap.builder()\n                .put(TestEntity.CONF_NAME, DependentConfiguration.whenDone(Callables.returning(\"aval\")))\n                .build());\n        app.policies().add(policy);\n        assertEquals(policy.getConfig(TestEntity.CONF_NAME), \"aval\");\n    }","cleancode":"@test(enabled=false) public void testgetfutureconfigwhenready() throws exception { mypolicy policy = new mypolicy(mutablemap.builder() .put(testentity.conf_name, dependentconfiguration.whendone(callables.returning(\"aval\"))) .build()); app.policies().add(policy); assertequals(policy.getconfig(testentity.conf_name), \"aval\"); }","comment":"\/\/ fixme should we support this now?","repo":"nakomis\/incubator-brooklyn","code_context_2":"@Test(enabled=false)\npublic void testGetFutureConfigWhenReady() throws Exception {\nMyPolicy policy = new MyPolicy(MutableMap.builder()\n.put(TestEntity.CONF_NAME, DependentConfiguration.whenDone(Callables.returning(\"aval\")))\n.build());\napp.policies().add(policy);\nassertEquals(policy.getConfig(TestEntity.CONF_NAME), \"aval\");\n}","code_context_10":"@Test(enabled=false)\npublic void testGetFutureConfigWhenReady() throws Exception {\nMyPolicy policy = new MyPolicy(MutableMap.builder()\n.put(TestEntity.CONF_NAME, DependentConfiguration.whenDone(Callables.returning(\"aval\")))\n.build());\napp.policies().add(policy);\nassertEquals(policy.getConfig(TestEntity.CONF_NAME), \"aval\");\n}","code_context_20":"@Test(enabled=false)\npublic void testGetFutureConfigWhenReady() throws Exception {\nMyPolicy policy = new MyPolicy(MutableMap.builder()\n.put(TestEntity.CONF_NAME, DependentConfiguration.whenDone(Callables.returning(\"aval\")))\n.build());\napp.policies().add(policy);\nassertEquals(policy.getConfig(TestEntity.CONF_NAME), \"aval\");\n}","label":[1,0,0,0]}
{"id":34827,"original_code":"@Test(enabled=false)\n    public void testGetFutureConfigBlocksUntilReady() throws Exception {\n        final CountDownLatch latch = new CountDownLatch(1);\n        MyPolicy policy = new MyPolicy(MutableMap.builder()\n                .put(TestEntity.CONF_NAME, DependentConfiguration.whenDone(new Callable<String>() {\n                        public String call() {\n                            try {\n                                latch.await(); return \"aval\";\n                            } catch (InterruptedException e) {\n                                throw Exceptions.propagate(e);\n                            }\n                        }}))\n                .build());\n        app.policies().add(policy);\n        Thread t = new Thread(new Runnable() {\n                public void run() {\n                    try {\n                        Thread.sleep(10+EARLY_RETURN_GRACE); latch.countDown();\n                    } catch (InterruptedException e) {\n                        throw Exceptions.propagate(e);\n                    }\n                }});\n        try {\n            long starttime = System.currentTimeMillis();\n            t.start();\n            assertEquals(policy.getConfig(TestEntity.CONF_NAME), \"aval\");\n            long endtime = System.currentTimeMillis();\n            assertTrue((endtime - starttime) >= 10, \"starttime=\"+starttime+\"; endtime=\"+endtime);\n        } finally {\n            t.interrupt();\n        }\n    }","code":"@Test(enabled=false)\n    public void testGetFutureConfigBlocksUntilReady() throws Exception {\n        final CountDownLatch latch = new CountDownLatch(1);\n        MyPolicy policy = new MyPolicy(MutableMap.builder()\n                .put(TestEntity.CONF_NAME, DependentConfiguration.whenDone(new Callable<String>() {\n                        public String call() {\n                            try {\n                                latch.await(); return \"aval\";\n                            } catch (InterruptedException e) {\n                                throw Exceptions.propagate(e);\n                            }\n                        }}))\n                .build());\n        app.policies().add(policy);\n        Thread t = new Thread(new Runnable() {\n                public void run() {\n                    try {\n                        Thread.sleep(10+EARLY_RETURN_GRACE); latch.countDown();\n                    } catch (InterruptedException e) {\n                        throw Exceptions.propagate(e);\n                    }\n                }});\n        try {\n            long starttime = System.currentTimeMillis();\n            t.start();\n            assertEquals(policy.getConfig(TestEntity.CONF_NAME), \"aval\");\n            long endtime = System.currentTimeMillis();\n            assertTrue((endtime - starttime) >= 10, \"starttime=\"+starttime+\"; endtime=\"+endtime);\n        } finally {\n            t.interrupt();\n        }\n    }","cleancode":"@test(enabled=false) public void testgetfutureconfigblocksuntilready() throws exception { final countdownlatch latch = new countdownlatch(1); mypolicy policy = new mypolicy(mutablemap.builder() .put(testentity.conf_name, dependentconfiguration.whendone(new callable<string>() { public string call() { try { latch.await(); return \"aval\"; } catch (interruptedexception e) { throw exceptions.propagate(e); } }})) .build()); app.policies().add(policy); thread t = new thread(new runnable() { public void run() { try { thread.sleep(10+early_return_grace); latch.countdown(); } catch (interruptedexception e) { throw exceptions.propagate(e); } }}); try { long starttime = system.currenttimemillis(); t.start(); assertequals(policy.getconfig(testentity.conf_name), \"aval\"); long endtime = system.currenttimemillis(); asserttrue((endtime - starttime) >= 10, \"starttime=\"+starttime+\"; endtime=\"+endtime); } finally { t.interrupt(); } }","comment":"\/\/ fixme should we support this now?","repo":"nakomis\/incubator-brooklyn","code_context_2":"@Test(enabled=false)\npublic void testGetFutureConfigBlocksUntilReady() throws Exception {\nfinal CountDownLatch latch = new CountDownLatch(1);\nMyPolicy policy = new MyPolicy(MutableMap.builder()\n.put(TestEntity.CONF_NAME, DependentConfiguration.whenDone(new Callable<String>() {\npublic String call() {\ntry {\nlatch.await(); return \"aval\";\n} catch (InterruptedException e) {\nthrow Exceptions.propagate(e);\n}\n}}))\n.build());\napp.policies().add(policy);\nThread t = new Thread(new Runnable() {\npublic void run() {\ntry {\nThread.sleep(10+EARLY_RETURN_GRACE); latch.countDown();\n} catch (InterruptedException e) {\nthrow Exceptions.propagate(e);\n}\n}});\ntry {\nlong starttime = System.currentTimeMillis();\nt.start();\nassertEquals(policy.getConfig(TestEntity.CONF_NAME), \"aval\");\nlong endtime = System.currentTimeMillis();\nassertTrue((endtime - starttime) >= 10, \"starttime=\"+starttime+\"; endtime=\"+endtime);\n} finally {\nt.interrupt();\n}\n}","code_context_10":"@Test(enabled=false)\npublic void testGetFutureConfigBlocksUntilReady() throws Exception {\nfinal CountDownLatch latch = new CountDownLatch(1);\nMyPolicy policy = new MyPolicy(MutableMap.builder()\n.put(TestEntity.CONF_NAME, DependentConfiguration.whenDone(new Callable<String>() {\npublic String call() {\ntry {\nlatch.await(); return \"aval\";\n} catch (InterruptedException e) {\nthrow Exceptions.propagate(e);\n}\n}}))\n.build());\napp.policies().add(policy);\nThread t = new Thread(new Runnable() {\npublic void run() {\ntry {\nThread.sleep(10+EARLY_RETURN_GRACE); latch.countDown();\n} catch (InterruptedException e) {\nthrow Exceptions.propagate(e);\n}\n}});\ntry {\nlong starttime = System.currentTimeMillis();\nt.start();\nassertEquals(policy.getConfig(TestEntity.CONF_NAME), \"aval\");\nlong endtime = System.currentTimeMillis();\nassertTrue((endtime - starttime) >= 10, \"starttime=\"+starttime+\"; endtime=\"+endtime);\n} finally {\nt.interrupt();\n}\n}","code_context_20":"@Test(enabled=false)\npublic void testGetFutureConfigBlocksUntilReady() throws Exception {\nfinal CountDownLatch latch = new CountDownLatch(1);\nMyPolicy policy = new MyPolicy(MutableMap.builder()\n.put(TestEntity.CONF_NAME, DependentConfiguration.whenDone(new Callable<String>() {\npublic String call() {\ntry {\nlatch.await(); return \"aval\";\n} catch (InterruptedException e) {\nthrow Exceptions.propagate(e);\n}\n}}))\n.build());\napp.policies().add(policy);\nThread t = new Thread(new Runnable() {\npublic void run() {\ntry {\nThread.sleep(10+EARLY_RETURN_GRACE); latch.countDown();\n} catch (InterruptedException e) {\nthrow Exceptions.propagate(e);\n}\n}});\ntry {\nlong starttime = System.currentTimeMillis();\nt.start();\nassertEquals(policy.getConfig(TestEntity.CONF_NAME), \"aval\");\nlong endtime = System.currentTimeMillis();\nassertTrue((endtime - starttime) >= 10, \"starttime=\"+starttime+\"; endtime=\"+endtime);\n} finally {\nt.interrupt();\n}\n}","label":[1,0,0,0]}
{"id":18502,"original_code":"public void testUpdate() {\n        \/\/ Note: painting code, cannot test\n    }","code":"public void testUpdate() {\n       \n    }","cleancode":"public void testupdate() { }","comment":"\/\/ note: painting code, cannot test","repo":"qinFamily\/freeVM","code_context_2":"public void testUpdate() {\n\/\/ Note: painting code, cannot test\n}","code_context_10":"public void testUpdate() {\n\/\/ Note: painting code, cannot test\n}","code_context_20":"public void testUpdate() {\n\/\/ Note: painting code, cannot test\n}","label":[0,0,0,1]}
{"id":18503,"original_code":"public void testPaint() {\n        \/\/ Note: painting code, cannot test\n    }","code":"public void testPaint() {\n       \n    }","cleancode":"public void testpaint() { }","comment":"\/\/ note: painting code, cannot test","repo":"qinFamily\/freeVM","code_context_2":"public void testPaint() {\n\/\/ Note: painting code, cannot test\n}","code_context_10":"public void testPaint() {\n\/\/ Note: painting code, cannot test\n}","code_context_20":"public void testPaint() {\n\/\/ Note: painting code, cannot test\n}","label":[0,0,0,1]}
{"id":18504,"original_code":"public void testPaintContentBorderBottomEdge() {\n        \/\/ Note: painting code, cannot test\n    }","code":"public void testPaintContentBorderBottomEdge() {\n       \n    }","cleancode":"public void testpaintcontentborderbottomedge() { }","comment":"\/\/ note: painting code, cannot test","repo":"qinFamily\/freeVM","code_context_2":"public void testPaintContentBorderBottomEdge() {\n\/\/ Note: painting code, cannot test\n}","code_context_10":"public void testPaintContentBorderBottomEdge() {\n\/\/ Note: painting code, cannot test\n}","code_context_20":"public void testPaintContentBorderBottomEdge() {\n\/\/ Note: painting code, cannot test\n}","label":[0,0,0,1]}
{"id":18505,"original_code":"public void testPaintContentBorderLeftEdge() {\n        \/\/ Note: painting code, cannot test\n    }","code":"public void testPaintContentBorderLeftEdge() {\n       \n    }","cleancode":"public void testpaintcontentborderleftedge() { }","comment":"\/\/ note: painting code, cannot test","repo":"qinFamily\/freeVM","code_context_2":"public void testPaintContentBorderLeftEdge() {\n\/\/ Note: painting code, cannot test\n}","code_context_10":"public void testPaintContentBorderLeftEdge() {\n\/\/ Note: painting code, cannot test\n}","code_context_20":"public void testPaintContentBorderLeftEdge() {\n\/\/ Note: painting code, cannot test\n}","label":[0,0,0,1]}
{"id":18506,"original_code":"public void testPaintContentBorderRightEdge() {\n        \/\/ Note: painting code, cannot test\n    }","code":"public void testPaintContentBorderRightEdge() {\n       \n    }","cleancode":"public void testpaintcontentborderrightedge() { }","comment":"\/\/ note: painting code, cannot test","repo":"qinFamily\/freeVM","code_context_2":"public void testPaintContentBorderRightEdge() {\n\/\/ Note: painting code, cannot test\n}","code_context_10":"public void testPaintContentBorderRightEdge() {\n\/\/ Note: painting code, cannot test\n}","code_context_20":"public void testPaintContentBorderRightEdge() {\n\/\/ Note: painting code, cannot test\n}","label":[0,0,0,1]}
{"id":18507,"original_code":"public void testPaintContentBorderTopEdge() {\n        \/\/ Note: painting code, cannot test\n    }","code":"public void testPaintContentBorderTopEdge() {\n       \n    }","cleancode":"public void testpaintcontentbordertopedge() { }","comment":"\/\/ note: painting code, cannot test","repo":"qinFamily\/freeVM","code_context_2":"public void testPaintContentBorderTopEdge() {\n\/\/ Note: painting code, cannot test\n}","code_context_10":"public void testPaintContentBorderTopEdge() {\n\/\/ Note: painting code, cannot test\n}","code_context_20":"public void testPaintContentBorderTopEdge() {\n\/\/ Note: painting code, cannot test\n}","label":[0,0,0,1]}
{"id":18508,"original_code":"public void testPaintFocusIndicator() {\n        \/\/ Note: painting code, cannot test\n    }","code":"public void testPaintFocusIndicator() {\n       \n    }","cleancode":"public void testpaintfocusindicator() { }","comment":"\/\/ note: painting code, cannot test","repo":"qinFamily\/freeVM","code_context_2":"public void testPaintFocusIndicator() {\n\/\/ Note: painting code, cannot test\n}","code_context_10":"public void testPaintFocusIndicator() {\n\/\/ Note: painting code, cannot test\n}","code_context_20":"public void testPaintFocusIndicator() {\n\/\/ Note: painting code, cannot test\n}","label":[0,0,0,1]}
{"id":18509,"original_code":"public void testPaintTabBackground() {\n        \/\/ Note: painting code, cannot test\n    }","code":"public void testPaintTabBackground() {\n       \n    }","cleancode":"public void testpainttabbackground() { }","comment":"\/\/ note: painting code, cannot test","repo":"qinFamily\/freeVM","code_context_2":"public void testPaintTabBackground() {\n\/\/ Note: painting code, cannot test\n}","code_context_10":"public void testPaintTabBackground() {\n\/\/ Note: painting code, cannot test\n}","code_context_20":"public void testPaintTabBackground() {\n\/\/ Note: painting code, cannot test\n}","label":[0,0,0,1]}
{"id":18510,"original_code":"public void testPaintTabBorder() {\n        \/\/ Note: painting code, cannot test\n    }","code":"public void testPaintTabBorder() {\n       \n    }","cleancode":"public void testpainttabborder() { }","comment":"\/\/ note: painting code, cannot test","repo":"qinFamily\/freeVM","code_context_2":"public void testPaintTabBorder() {\n\/\/ Note: painting code, cannot test\n}","code_context_10":"public void testPaintTabBorder() {\n\/\/ Note: painting code, cannot test\n}","code_context_20":"public void testPaintTabBorder() {\n\/\/ Note: painting code, cannot test\n}","label":[0,0,0,1]}
{"id":18511,"original_code":"public void testPaintHighlightBelowTab() {\n        \/\/ Note: painting code, cannot test\n    }","code":"public void testPaintHighlightBelowTab() {\n       \n    }","cleancode":"public void testpainthighlightbelowtab() { }","comment":"\/\/ note: painting code, cannot test","repo":"qinFamily\/freeVM","code_context_2":"public void testPaintHighlightBelowTab() {\n\/\/ Note: painting code, cannot test\n}","code_context_10":"public void testPaintHighlightBelowTab() {\n\/\/ Note: painting code, cannot test\n}","code_context_20":"public void testPaintHighlightBelowTab() {\n\/\/ Note: painting code, cannot test\n}","label":[0,0,0,1]}
{"id":18512,"original_code":"public void testPaintBottomTabBorder() {\n        \/\/ Note: painting code, cannot test\n    }","code":"public void testPaintBottomTabBorder() {\n       \n    }","cleancode":"public void testpaintbottomtabborder() { }","comment":"\/\/ note: painting code, cannot test","repo":"qinFamily\/freeVM","code_context_2":"public void testPaintBottomTabBorder() {\n\/\/ Note: painting code, cannot test\n}","code_context_10":"public void testPaintBottomTabBorder() {\n\/\/ Note: painting code, cannot test\n}","code_context_20":"public void testPaintBottomTabBorder() {\n\/\/ Note: painting code, cannot test\n}","label":[0,0,0,1]}
{"id":18513,"original_code":"public void testPaintLeftTabBorder() {\n        \/\/ Note: painting code, cannot test\n    }","code":"public void testPaintLeftTabBorder() {\n       \n    }","cleancode":"public void testpaintlefttabborder() { }","comment":"\/\/ note: painting code, cannot test","repo":"qinFamily\/freeVM","code_context_2":"public void testPaintLeftTabBorder() {\n\/\/ Note: painting code, cannot test\n}","code_context_10":"public void testPaintLeftTabBorder() {\n\/\/ Note: painting code, cannot test\n}","code_context_20":"public void testPaintLeftTabBorder() {\n\/\/ Note: painting code, cannot test\n}","label":[0,0,0,1]}
{"id":18514,"original_code":"public void testPaintRightTabBorder() {\n        \/\/ Note: painting code, cannot test\n    }","code":"public void testPaintRightTabBorder() {\n       \n    }","cleancode":"public void testpaintrighttabborder() { }","comment":"\/\/ note: painting code, cannot test","repo":"qinFamily\/freeVM","code_context_2":"public void testPaintRightTabBorder() {\n\/\/ Note: painting code, cannot test\n}","code_context_10":"public void testPaintRightTabBorder() {\n\/\/ Note: painting code, cannot test\n}","code_context_20":"public void testPaintRightTabBorder() {\n\/\/ Note: painting code, cannot test\n}","label":[0,0,0,1]}
{"id":18515,"original_code":"public void testPaintTopTabBorder() {\n        \/\/ Note: painting code, cannot test\n    }","code":"public void testPaintTopTabBorder() {\n       \n    }","cleancode":"public void testpainttoptabborder() { }","comment":"\/\/ note: painting code, cannot test","repo":"qinFamily\/freeVM","code_context_2":"public void testPaintTopTabBorder() {\n\/\/ Note: painting code, cannot test\n}","code_context_10":"public void testPaintTopTabBorder() {\n\/\/ Note: painting code, cannot test\n}","code_context_20":"public void testPaintTopTabBorder() {\n\/\/ Note: painting code, cannot test\n}","label":[0,0,0,1]}
{"id":18636,"original_code":"@Override\n    public Set<JavaPlatform> instantiate() throws IOException {\n        \/\/TODO: Download (in background?)\n        String downloadedFolder = (String) wizard.getProperty(DiscoPlatformIt.PROP_DOWNLOAD);\n        if (downloadedFolder != null) {\n            File f = new File(downloadedFolder);\n            if (!f.isDirectory()) {\n                \/\/open the file manager for the parent folder\n                Desktop.getDesktop().open(f.getParentFile());\n                return Collections.EMPTY_SET;\n            }\n            String name = state.selection.getJavaPlatformDisplayName();\n            return Collections.singleton(J2SEPlatformUtils.register(new File(downloadedFolder), name));\n        } else {\n            \/\/TODO: notifcation?\n            return Collections.EMPTY_SET;\n        }\n    }","code":"@Override\n    public Set<JavaPlatform> instantiate() throws IOException {\n       \n        String downloadedFolder = (String) wizard.getProperty(DiscoPlatformIt.PROP_DOWNLOAD);\n        if (downloadedFolder != null) {\n            File f = new File(downloadedFolder);\n            if (!f.isDirectory()) {\n               \n                Desktop.getDesktop().open(f.getParentFile());\n                return Collections.EMPTY_SET;\n            }\n            String name = state.selection.getJavaPlatformDisplayName();\n            return Collections.singleton(J2SEPlatformUtils.register(new File(downloadedFolder), name));\n        } else {\n           \n            return Collections.EMPTY_SET;\n        }\n    }","cleancode":"@override public set<javaplatform> instantiate() throws ioexception { string downloadedfolder = (string) wizard.getproperty(discoplatformit.prop_download); if (downloadedfolder != null) { file f = new file(downloadedfolder); if (!f.isdirectory()) { desktop.getdesktop().open(f.getparentfile()); return collections.empty_set; } string name = state.selection.getjavaplatformdisplayname(); return collections.singleton(j2seplatformutils.register(new file(downloadedfolder), name)); } else { return collections.empty_set; } }","comment":"\/\/todo: download (in background?)\n\/\/open the file manager for the parent folder\n\/\/todo: notifcation?","repo":"oyarzun\/incubator-netbeans","code_context_2":"@Override\npublic Set<JavaPlatform> instantiate() throws IOException {\n\/\/TODO: Download (in background?)\nString downloadedFolder = (String) wizard.getProperty(DiscoPlatformIt.PROP_DOWNLOAD);\nif (downloadedFolder != null) {\n\nFile f = new File(downloadedFolder);\nif (!f.isDirectory()) {\n\/\/open the file manager for the parent folder\nDesktop.getDesktop().open(f.getParentFile());\nreturn Collections.EMPTY_SET;\n\nreturn Collections.singleton(J2SEPlatformUtils.register(new File(downloadedFolder), name));\n} else {\n\/\/TODO: notifcation?\nreturn Collections.EMPTY_SET;\n}","code_context_10":"@Override\npublic Set<JavaPlatform> instantiate() throws IOException {\n\/\/TODO: Download (in background?)\nString downloadedFolder = (String) wizard.getProperty(DiscoPlatformIt.PROP_DOWNLOAD);\nif (downloadedFolder != null) {\nFile f = new File(downloadedFolder);\nif (!f.isDirectory()) {\n\/\/open the file manager for the parent folder\nDesktop.getDesktop().open(f.getParentFile());\nreturn Collections.EMPTY_SET;\n}\nString name = state.selection.getJavaPlatformDisplayName();\nreturn Collections.singleton(J2SEPlatformUtils.register(new File(downloadedFolder), name));\n\n@Override\npublic Set<JavaPlatform> instantiate() throws IOException {\n\/\/TODO: Download (in background?)\nString downloadedFolder = (String) wizard.getProperty(DiscoPlatformIt.PROP_DOWNLOAD);\nif (downloadedFolder != null) {\nFile f = new File(downloadedFolder);\nif (!f.isDirectory()) {\n\/\/open the file manager for the parent folder\nDesktop.getDesktop().open(f.getParentFile());\nreturn Collections.EMPTY_SET;\n}\nString name = state.selection.getJavaPlatformDisplayName();\nreturn Collections.singleton(J2SEPlatformUtils.register(new File(downloadedFolder), name));\n} else {\n\/\/TODO: notifcation?\nreturn Collections.EMPTY_SET;\n}\n}\n\nif (downloadedFolder != null) {\nFile f = new File(downloadedFolder);\nif (!f.isDirectory()) {\n\/\/open the file manager for the parent folder\nDesktop.getDesktop().open(f.getParentFile());\nreturn Collections.EMPTY_SET;\n}\nString name = state.selection.getJavaPlatformDisplayName();\nreturn Collections.singleton(J2SEPlatformUtils.register(new File(downloadedFolder), name));\n} else {\n\/\/TODO: notifcation?\nreturn Collections.EMPTY_SET;\n}\n}","code_context_20":"@Override\npublic Set<JavaPlatform> instantiate() throws IOException {\n\/\/TODO: Download (in background?)\nString downloadedFolder = (String) wizard.getProperty(DiscoPlatformIt.PROP_DOWNLOAD);\nif (downloadedFolder != null) {\nFile f = new File(downloadedFolder);\nif (!f.isDirectory()) {\n\/\/open the file manager for the parent folder\nDesktop.getDesktop().open(f.getParentFile());\nreturn Collections.EMPTY_SET;\n}\nString name = state.selection.getJavaPlatformDisplayName();\nreturn Collections.singleton(J2SEPlatformUtils.register(new File(downloadedFolder), name));\n} else {\n\/\/TODO: notifcation?\nreturn Collections.EMPTY_SET;\n}\n}\n\n@Override\npublic Set<JavaPlatform> instantiate() throws IOException {\n\/\/TODO: Download (in background?)\nString downloadedFolder = (String) wizard.getProperty(DiscoPlatformIt.PROP_DOWNLOAD);\nif (downloadedFolder != null) {\nFile f = new File(downloadedFolder);\nif (!f.isDirectory()) {\n\/\/open the file manager for the parent folder\nDesktop.getDesktop().open(f.getParentFile());\nreturn Collections.EMPTY_SET;\n}\nString name = state.selection.getJavaPlatformDisplayName();\nreturn Collections.singleton(J2SEPlatformUtils.register(new File(downloadedFolder), name));\n} else {\n\/\/TODO: notifcation?\nreturn Collections.EMPTY_SET;\n}\n}\n\n@Override\npublic Set<JavaPlatform> instantiate() throws IOException {\n\/\/TODO: Download (in background?)\nString downloadedFolder = (String) wizard.getProperty(DiscoPlatformIt.PROP_DOWNLOAD);\nif (downloadedFolder != null) {\nFile f = new File(downloadedFolder);\nif (!f.isDirectory()) {\n\/\/open the file manager for the parent folder\nDesktop.getDesktop().open(f.getParentFile());\nreturn Collections.EMPTY_SET;\n}\nString name = state.selection.getJavaPlatformDisplayName();\nreturn Collections.singleton(J2SEPlatformUtils.register(new File(downloadedFolder), name));\n} else {\n\/\/TODO: notifcation?\nreturn Collections.EMPTY_SET;\n}\n}","label":[1,1,0,0]}
{"id":2277,"original_code":"@SuppressWarnings(\"unused\")\n\tprivate void receive() {\n\t\t\/\/ TODO 7: [Optional] Fill with your own implementation for handling\n\t\t\/\/ asynchronous data from the driver layer to the device service\n\t\tModbusDevice device = null;\n\t\tString result = \"\";\n\t\tResourceOperation operation = null;\n\t\tobjectCache.putReadings(device, operation, result);\n\t}","code":"@SuppressWarnings(\"unused\")\n\tprivate void receive() {\n\t\n\t\n\t\tModbusDevice device = null;\n\t\tString result = \"\";\n\t\tResourceOperation operation = null;\n\t\tobjectCache.putReadings(device, operation, result);\n\t}","cleancode":"@suppresswarnings(\"unused\") private void receive() { modbusdevice device = null; string result = \"\"; resourceoperation operation = null; objectcache.putreadings(device, operation, result); }","comment":"\/\/ todo 7: [optional] fill with your own implementation for handling \/\/ asynchronous data from the driver layer to the device service","repo":"pk-80\/device-modbus","code_context_2":"@SuppressWarnings(\"unused\")\nprivate void receive() {\n\/\/ TODO 7: [Optional] Fill with your own implementation for handling\n\/\/ asynchronous data from the driver layer to the device service\nModbusDevice device = null;\nString result = \"\";","code_context_10":"@SuppressWarnings(\"unused\")\nprivate void receive() {\n\/\/ TODO 7: [Optional] Fill with your own implementation for handling\n\/\/ asynchronous data from the driver layer to the device service\nModbusDevice device = null;\nString result = \"\";\nResourceOperation operation = null;\nobjectCache.putReadings(device, operation, result);\n}","code_context_20":"@SuppressWarnings(\"unused\")\nprivate void receive() {\n\/\/ TODO 7: [Optional] Fill with your own implementation for handling\n\/\/ asynchronous data from the driver layer to the device service\nModbusDevice device = null;\nString result = \"\";\nResourceOperation operation = null;\nobjectCache.putReadings(device, operation, result);\n}","label":[0,1,0,0]}
{"id":18772,"original_code":"private void initState(){\n        \/\/TODO Switch s and w\n        this.s = BigDecimal.ONE; \/\/new BigDecimal(this.cloudsNum); \/\/ @todo ERRO? (x = BigDecimal.ONE)\n        this.w = super.getInitValue();\n        \/\/Clear message received buffer\n        this.msgRcvBuffer = new HashMap<String, Message<?>>();\n    }","code":"private void initState(){\n       \n        this.s = BigDecimal.ONE;\n        this.w = super.getInitValue();\n       \n        this.msgRcvBuffer = new HashMap<String, Message<?>>();\n    }","cleancode":"private void initstate(){ this.s = bigdecimal.one; this.w = super.getinitvalue(); this.msgrcvbuffer = new hashmap<string, message<?>>(); }","comment":"\/\/todo switch s and w\n\/\/new bigdecimal(this.cloudsnum); \/\/ @todo erro? (x = bigdecimal.one)\n\/\/clear message received buffer","repo":"pcjesus\/NetworkSimulator","code_context_2":"private void initState(){\n\/\/TODO Switch s and w\nthis.s = BigDecimal.ONE; \/\/new BigDecimal(this.cloudsNum); \/\/ @todo ERRO? (x = BigDecimal.ONE)\nthis.w = super.getInitValue();\n\nprivate void initState(){\n\/\/TODO Switch s and w\nthis.s = BigDecimal.ONE; \/\/new BigDecimal(this.cloudsNum); \/\/ @todo ERRO? (x = BigDecimal.ONE)\nthis.w = super.getInitValue();\n\/\/Clear message received buffer\n\nthis.s = BigDecimal.ONE; \/\/new BigDecimal(this.cloudsNum); \/\/ @todo ERRO? (x = BigDecimal.ONE)\nthis.w = super.getInitValue();\n\/\/Clear message received buffer\nthis.msgRcvBuffer = new HashMap<String, Message<?>>();\n}","code_context_10":"private void initState(){\n\/\/TODO Switch s and w\nthis.s = BigDecimal.ONE; \/\/new BigDecimal(this.cloudsNum); \/\/ @todo ERRO? (x = BigDecimal.ONE)\nthis.w = super.getInitValue();\n\/\/Clear message received buffer\nthis.msgRcvBuffer = new HashMap<String, Message<?>>();\n}\n\nprivate void initState(){\n\/\/TODO Switch s and w\nthis.s = BigDecimal.ONE; \/\/new BigDecimal(this.cloudsNum); \/\/ @todo ERRO? (x = BigDecimal.ONE)\nthis.w = super.getInitValue();\n\/\/Clear message received buffer\nthis.msgRcvBuffer = new HashMap<String, Message<?>>();\n}\n\nprivate void initState(){\n\/\/TODO Switch s and w\nthis.s = BigDecimal.ONE; \/\/new BigDecimal(this.cloudsNum); \/\/ @todo ERRO? (x = BigDecimal.ONE)\nthis.w = super.getInitValue();\n\/\/Clear message received buffer\nthis.msgRcvBuffer = new HashMap<String, Message<?>>();\n}","code_context_20":"private void initState(){\n\/\/TODO Switch s and w\nthis.s = BigDecimal.ONE; \/\/new BigDecimal(this.cloudsNum); \/\/ @todo ERRO? (x = BigDecimal.ONE)\nthis.w = super.getInitValue();\n\/\/Clear message received buffer\nthis.msgRcvBuffer = new HashMap<String, Message<?>>();\n}\n\nprivate void initState(){\n\/\/TODO Switch s and w\nthis.s = BigDecimal.ONE; \/\/new BigDecimal(this.cloudsNum); \/\/ @todo ERRO? (x = BigDecimal.ONE)\nthis.w = super.getInitValue();\n\/\/Clear message received buffer\nthis.msgRcvBuffer = new HashMap<String, Message<?>>();\n}\n\nprivate void initState(){\n\/\/TODO Switch s and w\nthis.s = BigDecimal.ONE; \/\/new BigDecimal(this.cloudsNum); \/\/ @todo ERRO? (x = BigDecimal.ONE)\nthis.w = super.getInitValue();\n\/\/Clear message received buffer\nthis.msgRcvBuffer = new HashMap<String, Message<?>>();\n}","label":[1,1,0,0]}
{"id":10767,"original_code":"@Override\n\tpublic void shutdown() throws Exception {\n\t\tsynchronized (shutDownLock) {\n\t\t\t\/\/ This is problematic as the user code class loader is not\n\t\t\t\/\/ available at this point.\n\t\t\tfor (Savepoint savepoint : savepoints.values()) {\n\t\t\t\ttry {\n\t\t\t\t\tsavepoint.dispose();\n\t\t\t\t} catch (Throwable t) {\n\t\t\t\t\tLOG.warn(\"Failed to dispose savepoint \" + savepoint.getCheckpointId(), t);\n\t\t\t\t}\n\t\t\t}\n\t\t\tsavepoints.clear();\n\t\t\t\/\/ Remove shutdown hook to prevent resource leaks, unless this is\n\t\t\t\/\/ invoked by the shutdown hook itself.\n\t\t\tif (shutdownHook != null && shutdownHook != Thread.currentThread()) {\n\t\t\t\ttry {\n\t\t\t\t\tRuntime.getRuntime().removeShutdownHook(shutdownHook);\n\t\t\t\t} catch (IllegalStateException ignored) {\n\t\t\t\t\t\/\/ Race, JVM is in shutdown already, we can safely ignore this\n\t\t\t\t} catch (Throwable t) {\n\t\t\t\t\tLOG.warn(\"Failed to unregister shut down hook.\");\n\t\t\t\t}\n\t\t\t}\n\t\t\tshutDown = true;\n\t\t}\n\t}","code":"@Override\n\tpublic void shutdown() throws Exception {\n\t\tsynchronized (shutDownLock) {\n\t\t\n\t\t\n\t\t\tfor (Savepoint savepoint : savepoints.values()) {\n\t\t\t\ttry {\n\t\t\t\t\tsavepoint.dispose();\n\t\t\t\t} catch (Throwable t) {\n\t\t\t\t\tLOG.warn(\"Failed to dispose savepoint \" + savepoint.getCheckpointId(), t);\n\t\t\t\t}\n\t\t\t}\n\t\t\tsavepoints.clear();\n\t\t\n\t\t\n\t\t\tif (shutdownHook != null && shutdownHook != Thread.currentThread()) {\n\t\t\t\ttry {\n\t\t\t\t\tRuntime.getRuntime().removeShutdownHook(shutdownHook);\n\t\t\t\t} catch (IllegalStateException ignored) {\n\t\t\t\t\n\t\t\t\t} catch (Throwable t) {\n\t\t\t\t\tLOG.warn(\"Failed to unregister shut down hook.\");\n\t\t\t\t}\n\t\t\t}\n\t\t\tshutDown = true;\n\t\t}\n\t}","cleancode":"@override public void shutdown() throws exception { synchronized (shutdownlock) { for (savepoint savepoint : savepoints.values()) { try { savepoint.dispose(); } catch (throwable t) { log.warn(\"failed to dispose savepoint \" + savepoint.getcheckpointid(), t); } } savepoints.clear(); if (shutdownhook != null && shutdownhook != thread.currentthread()) { try { runtime.getruntime().removeshutdownhook(shutdownhook); } catch (illegalstateexception ignored) { } catch (throwable t) { log.warn(\"failed to unregister shut down hook.\"); } } shutdown = true; } }","comment":"\/\/ this is problematic as the user code class loader is not \/\/ available at this point.\n\/\/ remove shutdown hook to prevent resource leaks, unless this is \/\/ invoked by the shutdown hook itself.\n\/\/ race, jvm is in shutdown already, we can safely ignore this","repo":"qingdao81\/flink","code_context_2":"public void shutdown() throws Exception {\nsynchronized (shutDownLock) {\n\/\/ This is problematic as the user code class loader is not\n\/\/ available at this point.\nfor (Savepoint savepoint : savepoints.values()) {\ntry {\n\n}\nsavepoints.clear();\n\/\/ Remove shutdown hook to prevent resource leaks, unless this is\n\/\/ invoked by the shutdown hook itself.\nif (shutdownHook != null && shutdownHook != Thread.currentThread()) {\ntry {\n\nRuntime.getRuntime().removeShutdownHook(shutdownHook);\n} catch (IllegalStateException ignored) {\n\/\/ Race, JVM is in shutdown already, we can safely ignore this\n} catch (Throwable t) {\nLOG.warn(\"Failed to unregister shut down hook.\");","code_context_10":"@Override\npublic void shutdown() throws Exception {\nsynchronized (shutDownLock) {\n\/\/ This is problematic as the user code class loader is not\n\/\/ available at this point.\nfor (Savepoint savepoint : savepoints.values()) {\ntry {\nsavepoint.dispose();\n} catch (Throwable t) {\nLOG.warn(\"Failed to dispose savepoint \" + savepoint.getCheckpointId(), t);\n}\n}\nsavepoints.clear();\n\/\/ Remove shutdown hook to prevent resource leaks, unless this is\n\/\/ invoked by the shutdown hook itself.\n\n\/\/ This is problematic as the user code class loader is not\n\/\/ available at this point.\nfor (Savepoint savepoint : savepoints.values()) {\ntry {\nsavepoint.dispose();\n} catch (Throwable t) {\nLOG.warn(\"Failed to dispose savepoint \" + savepoint.getCheckpointId(), t);\n}\n}\nsavepoints.clear();\n\/\/ Remove shutdown hook to prevent resource leaks, unless this is\n\/\/ invoked by the shutdown hook itself.\nif (shutdownHook != null && shutdownHook != Thread.currentThread()) {\ntry {\nRuntime.getRuntime().removeShutdownHook(shutdownHook);\n} catch (IllegalStateException ignored) {\n\/\/ Race, JVM is in shutdown already, we can safely ignore this\n} catch (Throwable t) {\nLOG.warn(\"Failed to unregister shut down hook.\");\n}\n}\nshutDown = true;\n\nLOG.warn(\"Failed to dispose savepoint \" + savepoint.getCheckpointId(), t);\n}\n}\nsavepoints.clear();\n\/\/ Remove shutdown hook to prevent resource leaks, unless this is\n\/\/ invoked by the shutdown hook itself.\nif (shutdownHook != null && shutdownHook != Thread.currentThread()) {\ntry {\nRuntime.getRuntime().removeShutdownHook(shutdownHook);\n} catch (IllegalStateException ignored) {\n\/\/ Race, JVM is in shutdown already, we can safely ignore this\n} catch (Throwable t) {\nLOG.warn(\"Failed to unregister shut down hook.\");\n}\n}\nshutDown = true;\n}\n}","code_context_20":"@Override\npublic void shutdown() throws Exception {\nsynchronized (shutDownLock) {\n\/\/ This is problematic as the user code class loader is not\n\/\/ available at this point.\nfor (Savepoint savepoint : savepoints.values()) {\ntry {\nsavepoint.dispose();\n} catch (Throwable t) {\nLOG.warn(\"Failed to dispose savepoint \" + savepoint.getCheckpointId(), t);\n}\n}\nsavepoints.clear();\n\/\/ Remove shutdown hook to prevent resource leaks, unless this is\n\/\/ invoked by the shutdown hook itself.\nif (shutdownHook != null && shutdownHook != Thread.currentThread()) {\ntry {\nRuntime.getRuntime().removeShutdownHook(shutdownHook);\n} catch (IllegalStateException ignored) {\n\/\/ Race, JVM is in shutdown already, we can safely ignore this\n} catch (Throwable t) {\nLOG.warn(\"Failed to unregister shut down hook.\");\n}\n}\nshutDown = true;\n\n@Override\npublic void shutdown() throws Exception {\nsynchronized (shutDownLock) {\n\/\/ This is problematic as the user code class loader is not\n\/\/ available at this point.\nfor (Savepoint savepoint : savepoints.values()) {\ntry {\nsavepoint.dispose();\n} catch (Throwable t) {\nLOG.warn(\"Failed to dispose savepoint \" + savepoint.getCheckpointId(), t);\n}\n}\nsavepoints.clear();\n\/\/ Remove shutdown hook to prevent resource leaks, unless this is\n\/\/ invoked by the shutdown hook itself.\nif (shutdownHook != null && shutdownHook != Thread.currentThread()) {\ntry {\nRuntime.getRuntime().removeShutdownHook(shutdownHook);\n} catch (IllegalStateException ignored) {\n\/\/ Race, JVM is in shutdown already, we can safely ignore this\n} catch (Throwable t) {\nLOG.warn(\"Failed to unregister shut down hook.\");\n}\n}\nshutDown = true;\n}\n}\n\n@Override\npublic void shutdown() throws Exception {\nsynchronized (shutDownLock) {\n\/\/ This is problematic as the user code class loader is not\n\/\/ available at this point.\nfor (Savepoint savepoint : savepoints.values()) {\ntry {\nsavepoint.dispose();\n} catch (Throwable t) {\nLOG.warn(\"Failed to dispose savepoint \" + savepoint.getCheckpointId(), t);\n}\n}\nsavepoints.clear();\n\/\/ Remove shutdown hook to prevent resource leaks, unless this is\n\/\/ invoked by the shutdown hook itself.\nif (shutdownHook != null && shutdownHook != Thread.currentThread()) {\ntry {\nRuntime.getRuntime().removeShutdownHook(shutdownHook);\n} catch (IllegalStateException ignored) {\n\/\/ Race, JVM is in shutdown already, we can safely ignore this\n} catch (Throwable t) {\nLOG.warn(\"Failed to unregister shut down hook.\");\n}\n}\nshutDown = true;\n}\n}","label":[0,0,1,0]}
{"id":2671,"original_code":"public void beginStep() {\n        \/\/ TODO: probably, we don't need to synchronize data here,\n        \/\/ because this method is always called from the same thread\n        \/\/ Synchronize all cached data\n        synchronized (readData) {\n            synchronized (writeData) {\n                super.beginStep();\n            }\n        }\n    }","code":"public void beginStep() {\n       \n       \n       \n        synchronized (readData) {\n            synchronized (writeData) {\n                super.beginStep();\n            }\n        }\n    }","cleancode":"public void beginstep() { synchronized (readdata) { synchronized (writedata) { super.beginstep(); } } }","comment":"\/** * does nothing *\/\n\/\/ todo: probably, we don't need to synchronize data here, \/\/ because this method is always called from the same thread \/\/ synchronize all cached data","repo":"monadius\/spark-abm","code_context_2":"public void beginStep() {\n\/\/ TODO: probably, we don't need to synchronize data here,\n\/\/ because this method is always called from the same thread\n\/\/ Synchronize all cached data\nsynchronized (readData) {\nsynchronized (writeData) {\nsuper.beginStep();\n}\n}\n}\n\npublic void beginStep() {\n\/\/ TODO: probably, we don't need to synchronize data here,\n\/\/ because this method is always called from the same thread\n\/\/ Synchronize all cached data\nsynchronized (readData) {\nsynchronized (writeData) {","code_context_10":"public void beginStep() {\n\/\/ TODO: probably, we don't need to synchronize data here,\n\/\/ because this method is always called from the same thread\n\/\/ Synchronize all cached data\nsynchronized (readData) {\nsynchronized (writeData) {\nsuper.beginStep();\n}\n}\n}\n\npublic void beginStep() {\n\/\/ TODO: probably, we don't need to synchronize data here,\n\/\/ because this method is always called from the same thread\n\/\/ Synchronize all cached data\nsynchronized (readData) {\nsynchronized (writeData) {\nsuper.beginStep();\n}\n}\n}","code_context_20":"public void beginStep() {\n\/\/ TODO: probably, we don't need to synchronize data here,\n\/\/ because this method is always called from the same thread\n\/\/ Synchronize all cached data\nsynchronized (readData) {\nsynchronized (writeData) {\nsuper.beginStep();\n}\n}\n}\n\npublic void beginStep() {\n\/\/ TODO: probably, we don't need to synchronize data here,\n\/\/ because this method is always called from the same thread\n\/\/ Synchronize all cached data\nsynchronized (readData) {\nsynchronized (writeData) {\nsuper.beginStep();\n}\n}\n}","label":[1,0,0,0]}
{"id":2740,"original_code":"public static String jsDtobasestr(int base, double dParam) {\n        if (!(2 <= base && base <= 36)) {\n            throw new IllegalArgumentException(\"Bad base: \" + base);\n        }\n        double d = dParam;\n        \/* Check for Infinity and NaN *\/\n        if (Double.isNaN(d)) {\n            return \"NaN\";\n        } else if (Double.isInfinite(d)) {\n            return (d > 0.0) ? \"Infinity\" : \"-Infinity\";\n        } else if (d == 0) {\n            \/\/ ALERT: should it distinguish -0.0 from +0.0 ?\n            return \"0\";\n        }\n        boolean negative;\n        if (d >= 0.0) {\n            negative = false;\n        } else {\n            negative = true;\n            d = -d;\n        }\n        \/* Get the integer part of d including '-' sign. *\/\n        String intDigits;\n        double dfloor = Math.floor(d);\n        long lfloor = (long) dfloor;\n        if (lfloor == dfloor) {\n            \/\/ int part fits long\n            if (lfloor == 0 && negative) {\n                intDigits = \"-0\"; \/\/ CWirth fix\n            } else {\n                intDigits = Long.toString((negative) ? -lfloor : lfloor, base);\n            }\n        } else {\n            \/\/ BigInteger should be used\n            long floorBits = Double.doubleToLongBits(dfloor);\n            int exp = (int) (floorBits >> Exp_shiftL) & Exp_mask_shifted;\n            long mantissa;\n            if (exp == 0) {\n                mantissa = (floorBits & Frac_maskL) << 1;\n            } else {\n                mantissa = (floorBits & Frac_maskL) | Exp_msk1L;\n            }\n            if (negative) {\n                mantissa = -mantissa;\n            }\n            exp -= 1075;\n            BigInteger x = BigInteger.valueOf(mantissa);\n            if (exp > 0) {\n                x = x.shiftLeft(exp);\n            } else if (exp < 0) {\n                x = x.shiftRight(-exp);\n            }\n            intDigits = x.toString(base);\n        }\n        if (d == dfloor) {\n            \/\/ No fraction part\n            return intDigits;\n        } else {\n            \/* We have a fraction. *\/\n            StringBuilder buffer; \/* The output string *\/\n            int digit;\n            double df; \/* The fractional part of d *\/\n            BigInteger b;\n            buffer = new StringBuilder();\n            buffer.append(intDigits).append('.');\n            df = d - dfloor;\n            long dBits = Double.doubleToLongBits(d);\n            int word0 = (int) (dBits >> 32);\n            int word1 = (int) (dBits);\n            int[] e = new int[1];\n            int[] bbits = new int[1];\n            b = d2b(df, e, bbits);\n            \/* At this point df = b * 2^e. e must be less than zero because 0 < df < 1. *\/\n            int s2 = -(word0 >>> Exp_shift1 & Exp_mask >> Exp_shift1);\n            if (s2 == 0) {\n                s2 = -1;\n            }\n            s2 += Bias + P;\n            \/* 1\/2^s2 = (nextDouble(d) - d)\/2 *\/\n            BigInteger mlo = BigInteger.ONE;\n            BigInteger mhi = mlo;\n            if ((word1 == 0) && ((word0 & Bndry_mask) == 0) && ((word0 & (Exp_mask & Exp_mask << 1)) != 0)) {\n                \/*\n                 * The special case. Here we want to be within a quarter of the last input\n                 * significant digit instead of one half of it when the output string's value is\n                 * less than d.\n                 *\/\n                s2 += Log2P;\n                mhi = BigInteger.valueOf(1 << Log2P);\n            }\n            b = b.shiftLeft(e[0] + s2);\n            BigInteger s = BigInteger.ONE;\n            s = s.shiftLeft(s2);\n            \/*\n             * @formatter:off\n             * At this point we have the following:\n             * s = 2^s2;\n             * 1 > df = b\/2^s2 > 0;\n             * (d - prevDouble(d))\/2 = mlo\/2^s2;\n             * (nextDouble(d) - d)\/2 = mhi\/2^s2.\n             * @formatter:on\n             *\/\n            BigInteger bigBase = BigInteger.valueOf(base);\n            boolean done = false;\n            do {\n                b = b.multiply(bigBase);\n                BigInteger[] divResult = b.divideAndRemainder(s);\n                b = divResult[1];\n                digit = (char) (divResult[0].intValue());\n                if (mlo == mhi) {\n                    mlo = mhi = mlo.multiply(bigBase);\n                } else {\n                    mlo = mlo.multiply(bigBase);\n                    mhi = mhi.multiply(bigBase);\n                }\n                \/* Do we yet have the shortest string that will round to d? *\/\n                int j = b.compareTo(mlo);\n                \/* j is b\/2^s2 compared with mlo\/2^s2. *\/\n                BigInteger delta = s.subtract(mhi);\n                int j1 = (delta.signum() <= 0) ? 1 : b.compareTo(delta);\n                \/* j1 is b\/2^s2 compared with 1 - mhi\/2^s2. *\/\n                if (j1 == 0 && ((word1 & 1) == 0)) {\n                    if (j > 0) {\n                        digit++;\n                    }\n                    done = true;\n                } else if (j < 0 || (j == 0 && ((word1 & 1) == 0))) {\n                    if (j1 > 0) {\n                        \/*\n                         * Either dig or dig+1 would work here as the least significant digit. Use\n                         * whichever would produce an output value closer to d.\n                         *\/\n                        b = b.shiftLeft(1);\n                        j1 = b.compareTo(s);\n                        if (j1 > 0) {\n                            \/*\n                             * The even test (|| (j1 == 0 && (digit & 1))) is not here because it\n                             * messes up odd base output such as 3.5 in base 3.\n                             *\/\n                            digit++;\n                        }\n                    }\n                    done = true;\n                } else if (j1 > 0) {\n                    digit++;\n                    done = true;\n                }\n                buffer.append(basedigit(digit));\n            } while (!done);\n            return buffer.toString();\n        }\n    }","code":"public static String jsDtobasestr(int base, double dParam) {\n        if (!(2 <= base && base <= 36)) {\n            throw new IllegalArgumentException(\"Bad base: \" + base);\n        }\n        double d = dParam;\n       \n        if (Double.isNaN(d)) {\n            return \"NaN\";\n        } else if (Double.isInfinite(d)) {\n            return (d > 0.0) ? \"Infinity\" : \"-Infinity\";\n        } else if (d == 0) {\n           \n            return \"0\";\n        }\n        boolean negative;\n        if (d >= 0.0) {\n            negative = false;\n        } else {\n            negative = true;\n            d = -d;\n        }\n       \n        String intDigits;\n        double dfloor = Math.floor(d);\n        long lfloor = (long) dfloor;\n        if (lfloor == dfloor) {\n           \n            if (lfloor == 0 && negative) {\n                intDigits = \"-0\";\n            } else {\n                intDigits = Long.toString((negative) ? -lfloor : lfloor, base);\n            }\n        } else {\n           \n            long floorBits = Double.doubleToLongBits(dfloor);\n            int exp = (int) (floorBits >> Exp_shiftL) & Exp_mask_shifted;\n            long mantissa;\n            if (exp == 0) {\n                mantissa = (floorBits & Frac_maskL) << 1;\n            } else {\n                mantissa = (floorBits & Frac_maskL) | Exp_msk1L;\n            }\n            if (negative) {\n                mantissa = -mantissa;\n            }\n            exp -= 1075;\n            BigInteger x = BigInteger.valueOf(mantissa);\n            if (exp > 0) {\n                x = x.shiftLeft(exp);\n            } else if (exp < 0) {\n                x = x.shiftRight(-exp);\n            }\n            intDigits = x.toString(base);\n        }\n        if (d == dfloor) {\n           \n            return intDigits;\n        } else {\n           \n            StringBuilder buffer;\n            int digit;\n            double df;\n            BigInteger b;\n            buffer = new StringBuilder();\n            buffer.append(intDigits).append('.');\n            df = d - dfloor;\n            long dBits = Double.doubleToLongBits(d);\n            int word0 = (int) (dBits >> 32);\n            int word1 = (int) (dBits);\n            int[] e = new int[1];\n            int[] bbits = new int[1];\n            b = d2b(df, e, bbits);\n           \n            int s2 = -(word0 >>> Exp_shift1 & Exp_mask >> Exp_shift1);\n            if (s2 == 0) {\n                s2 = -1;\n            }\n            s2 += Bias + P;\n           \n            BigInteger mlo = BigInteger.ONE;\n            BigInteger mhi = mlo;\n            if ((word1 == 0) && ((word0 & Bndry_mask) == 0) && ((word0 & (Exp_mask & Exp_mask << 1)) != 0)) {\n               \n                s2 += Log2P;\n                mhi = BigInteger.valueOf(1 << Log2P);\n            }\n            b = b.shiftLeft(e[0] + s2);\n            BigInteger s = BigInteger.ONE;\n            s = s.shiftLeft(s2);\n           \n            BigInteger bigBase = BigInteger.valueOf(base);\n            boolean done = false;\n            do {\n                b = b.multiply(bigBase);\n                BigInteger[] divResult = b.divideAndRemainder(s);\n                b = divResult[1];\n                digit = (char) (divResult[0].intValue());\n                if (mlo == mhi) {\n                    mlo = mhi = mlo.multiply(bigBase);\n                } else {\n                    mlo = mlo.multiply(bigBase);\n                    mhi = mhi.multiply(bigBase);\n                }\n               \n                int j = b.compareTo(mlo);\n               \n                BigInteger delta = s.subtract(mhi);\n                int j1 = (delta.signum() <= 0) ? 1 : b.compareTo(delta);\n               \n                if (j1 == 0 && ((word1 & 1) == 0)) {\n                    if (j > 0) {\n                        digit++;\n                    }\n                    done = true;\n                } else if (j < 0 || (j == 0 && ((word1 & 1) == 0))) {\n                    if (j1 > 0) {\n                       \n                        b = b.shiftLeft(1);\n                        j1 = b.compareTo(s);\n                        if (j1 > 0) {\n                           \n                            digit++;\n                        }\n                    }\n                    done = true;\n                } else if (j1 > 0) {\n                    digit++;\n                    done = true;\n                }\n                buffer.append(basedigit(digit));\n            } while (!done);\n            return buffer.toString();\n        }\n    }","cleancode":"public static string jsdtobasestr(int base, double dparam) { if (!(2 <= base && base <= 36)) { throw new illegalargumentexception(\"bad base: \" + base); } double d = dparam; if (double.isnan(d)) { return \"nan\"; } else if (double.isinfinite(d)) { return (d > 0.0) ? \"infinity\" : \"-infinity\"; } else if (d == 0) { return \"0\"; } boolean negative; if (d >= 0.0) { negative = false; } else { negative = true; d = -d; } string intdigits; double dfloor = math.floor(d); long lfloor = (long) dfloor; if (lfloor == dfloor) { if (lfloor == 0 && negative) { intdigits = \"-0\"; } else { intdigits = long.tostring((negative) ? -lfloor : lfloor, base); } } else { long floorbits = double.doubletolongbits(dfloor); int exp = (int) (floorbits >> exp_shiftl) & exp_mask_shifted; long mantissa; if (exp == 0) { mantissa = (floorbits & frac_maskl) << 1; } else { mantissa = (floorbits & frac_maskl) | exp_msk1l; } if (negative) { mantissa = -mantissa; } exp -= 1075; biginteger x = biginteger.valueof(mantissa); if (exp > 0) { x = x.shiftleft(exp); } else if (exp < 0) { x = x.shiftright(-exp); } intdigits = x.tostring(base); } if (d == dfloor) { return intdigits; } else { stringbuilder buffer; int digit; double df; biginteger b; buffer = new stringbuilder(); buffer.append(intdigits).append('.'); df = d - dfloor; long dbits = double.doubletolongbits(d); int word0 = (int) (dbits >> 32); int word1 = (int) (dbits); int[] e = new int[1]; int[] bbits = new int[1]; b = d2b(df, e, bbits); int s2 = -(word0 >>> exp_shift1 & exp_mask >> exp_shift1); if (s2 == 0) { s2 = -1; } s2 += bias + p; biginteger mlo = biginteger.one; biginteger mhi = mlo; if ((word1 == 0) && ((word0 & bndry_mask) == 0) && ((word0 & (exp_mask & exp_mask << 1)) != 0)) { s2 += log2p; mhi = biginteger.valueof(1 << log2p); } b = b.shiftleft(e[0] + s2); biginteger s = biginteger.one; s = s.shiftleft(s2); biginteger bigbase = biginteger.valueof(base); boolean done = false; do { b = b.multiply(bigbase); biginteger[] divresult = b.divideandremainder(s); b = divresult[1]; digit = (char) (divresult[0].intvalue()); if (mlo == mhi) { mlo = mhi = mlo.multiply(bigbase); } else { mlo = mlo.multiply(bigbase); mhi = mhi.multiply(bigbase); } int j = b.compareto(mlo); biginteger delta = s.subtract(mhi); int j1 = (delta.signum() <= 0) ? 1 : b.compareto(delta); if (j1 == 0 && ((word1 & 1) == 0)) { if (j > 0) { digit++; } done = true; } else if (j < 0 || (j == 0 && ((word1 & 1) == 0))) { if (j1 > 0) { b = b.shiftleft(1); j1 = b.compareto(s); if (j1 > 0) { digit++; } } done = true; } else if (j1 > 0) { digit++; done = true; } buffer.append(basedigit(digit)); } while (!done); return buffer.tostring(); } }","comment":"\/* check for infinity and nan *\/\n\/\/ alert: should it distinguish -0.0 from +0.0 ?\n\/* get the integer part of d including '-' sign. *\/\n\/\/ int part fits long\n\/\/ cwirth fix\n\/\/ biginteger should be used\n\/\/ no fraction part\n\/* we have a fraction. *\/\n\/* the output string *\/\n\/* the fractional part of d *\/\n\/* at this point df = b * 2^e. e must be less than zero because 0 < df < 1. *\/\n\/* 1\/2^s2 = (nextdouble(d) - d)\/2 *\/\n\/* * the special case. here we want to be within a quarter of the last input * significant digit instead of one half of it when the output string's value is * less than d. *\/\n\/* * @formatter:off * at this point we have the following: * s = 2^s2; * 1 > df = b\/2^s2 > 0; * (d - prevdouble(d))\/2 = mlo\/2^s2; * (nextdouble(d) - d)\/2 = mhi\/2^s2. * @formatter:on *\/\n\/* do we yet have the shortest string that will round to d? *\/\n\/* j is b\/2^s2 compared with mlo\/2^s2. *\/\n\/* j1 is b\/2^s2 compared with 1 - mhi\/2^s2. *\/\n\/* * either dig or dig+1 would work here as the least significant digit. use * whichever would produce an output value closer to d. *\/\n\/* * the even test (|| (j1 == 0 && (digit & 1))) is not here because it * messes up odd base output such as 3.5 in base 3. *\/","repo":"pitbox46\/graaljs-forge","code_context_2":"}\ndouble d = dParam;\n\/* Check for Infinity and NaN *\/\nif (Double.isNaN(d)) {\nreturn \"NaN\";\n\nreturn (d > 0.0) ? \"Infinity\" : \"-Infinity\";\n} else if (d == 0) {\n\/\/ ALERT: should it distinguish -0.0 from +0.0 ?\nreturn \"0\";\n}\n\nd = -d;\n}\n\/* Get the integer part of d including '-' sign. *\/\nString intDigits;\ndouble dfloor = Math.floor(d);\n\nlong lfloor = (long) dfloor;\nif (lfloor == dfloor) {\n\/\/ int part fits long\nif (lfloor == 0 && negative) {\nintDigits = \"-0\"; \/\/ CWirth fix\n\n\/\/ int part fits long\nif (lfloor == 0 && negative) {\nintDigits = \"-0\"; \/\/ CWirth fix\n} else {\nintDigits = Long.toString((negative) ? -lfloor : lfloor, base);\n\n}\n} else {\n\/\/ BigInteger should be used\nlong floorBits = Double.doubleToLongBits(dfloor);\nint exp = (int) (floorBits >> Exp_shiftL) & Exp_mask_shifted;\n\n}\nif (d == dfloor) {\n\/\/ No fraction part\nreturn intDigits;\n} else {\n\nreturn intDigits;\n} else {\n\/* We have a fraction. *\/\nStringBuilder buffer; \/* The output string *\/\nint digit;\n\n} else {\n\/* We have a fraction. *\/\nStringBuilder buffer; \/* The output string *\/\nint digit;\ndouble df; \/* The fractional part of d *\/\n\nStringBuilder buffer; \/* The output string *\/\nint digit;\ndouble df; \/* The fractional part of d *\/\nBigInteger b;\nbuffer = new StringBuilder();\n\nint[] bbits = new int[1];\nb = d2b(df, e, bbits);\n\/* At this point df = b * 2^e. e must be less than zero because 0 < df < 1. *\/\nint s2 = -(word0 >>> Exp_shift1 & Exp_mask >> Exp_shift1);\nif (s2 == 0) {\n\n}\ns2 += Bias + P;\n\/* 1\/2^s2 = (nextDouble(d) - d)\/2 *\/\nBigInteger mlo = BigInteger.ONE;\nBigInteger mhi = mlo;\n\n}\ndouble d = dParam;\n\/* Check for Infinity and NaN *\/\nif (Double.isNaN(d)) {\nreturn \"NaN\";\n} else if (Double.isInfinite(d)) {\nreturn (d > 0.0) ? \"Infinity\" : \"-Infinity\";\n} else if (d == 0) {\n\/\/ ALERT: should it distinguish -0.0 from +0.0 ?\n\n}\ndouble d = dParam;\n\/* Check for Infinity and NaN *\/\nif (Double.isNaN(d)) {\nreturn \"NaN\";\n} else if (Double.isInfinite(d)) {\nreturn (d > 0.0) ? \"Infinity\" : \"-Infinity\";\n} else if (d == 0) {\n\/\/ ALERT: should it distinguish -0.0 from +0.0 ?\nreturn \"0\";\n}\nboolean negative;\nif (d >= 0.0) {\n\nmhi = mhi.multiply(bigBase);\n}\n\/* Do we yet have the shortest string that will round to d? *\/\nint j = b.compareTo(mlo);\n\/* j is b\/2^s2 compared with mlo\/2^s2. *\/\n\n\/* Do we yet have the shortest string that will round to d? *\/\nint j = b.compareTo(mlo);\n\/* j is b\/2^s2 compared with mlo\/2^s2. *\/\nBigInteger delta = s.subtract(mhi);\nint j1 = (delta.signum() <= 0) ? 1 : b.compareTo(delta);\n\nBigInteger delta = s.subtract(mhi);\nint j1 = (delta.signum() <= 0) ? 1 : b.compareTo(delta);\n\/* j1 is b\/2^s2 compared with 1 - mhi\/2^s2. *\/\nif (j1 == 0 && ((word1 & 1) == 0)) {\nif (j > 0) {\n\n}\ndouble d = dParam;\n\/* Check for Infinity and NaN *\/\nif (Double.isNaN(d)) {\nreturn \"NaN\";\n} else if (Double.isInfinite(d)) {\nreturn (d > 0.0) ? \"Infinity\" : \"-Infinity\";\n} else if (d == 0) {\n\n}\ndouble d = dParam;\n\/* Check for Infinity and NaN *\/\nif (Double.isNaN(d)) {\nreturn \"NaN\";\n} else if (Double.isInfinite(d)) {\nreturn (d > 0.0) ? \"Infinity\" : \"-Infinity\";\n} else if (d == 0) {","code_context_10":"public static String jsDtobasestr(int base, double dParam) {\nif (!(2 <= base && base <= 36)) {\nthrow new IllegalArgumentException(\"Bad base: \" + base);\n}\ndouble d = dParam;\n\/* Check for Infinity and NaN *\/\nif (Double.isNaN(d)) {\nreturn \"NaN\";\n} else if (Double.isInfinite(d)) {\nreturn (d > 0.0) ? \"Infinity\" : \"-Infinity\";\n} else if (d == 0) {\n\/\/ ALERT: should it distinguish -0.0 from +0.0 ?\nreturn \"0\";\n}\nboolean negative;\nif (d >= 0.0) {\n\nif (!(2 <= base && base <= 36)) {\nthrow new IllegalArgumentException(\"Bad base: \" + base);\n}\ndouble d = dParam;\n\/* Check for Infinity and NaN *\/\nif (Double.isNaN(d)) {\nreturn \"NaN\";\n} else if (Double.isInfinite(d)) {\nreturn (d > 0.0) ? \"Infinity\" : \"-Infinity\";\n} else if (d == 0) {\n\/\/ ALERT: should it distinguish -0.0 from +0.0 ?\nreturn \"0\";\n}\nboolean negative;\nif (d >= 0.0) {\nnegative = false;\n} else {\nnegative = true;\nd = -d;\n}\n\/* Get the integer part of d including '-' sign. *\/\n\n\/\/ ALERT: should it distinguish -0.0 from +0.0 ?\nreturn \"0\";\n}\nboolean negative;\nif (d >= 0.0) {\nnegative = false;\n} else {\nnegative = true;\nd = -d;\n}\n\/* Get the integer part of d including '-' sign. *\/\nString intDigits;\ndouble dfloor = Math.floor(d);\nlong lfloor = (long) dfloor;\nif (lfloor == dfloor) {\n\/\/ int part fits long\nif (lfloor == 0 && negative) {\nintDigits = \"-0\"; \/\/ CWirth fix\n} else {\nintDigits = Long.toString((negative) ? -lfloor : lfloor, base);\n}\n\nnegative = false;\n} else {\nnegative = true;\nd = -d;\n}\n\/* Get the integer part of d including '-' sign. *\/\nString intDigits;\ndouble dfloor = Math.floor(d);\nlong lfloor = (long) dfloor;\nif (lfloor == dfloor) {\n\/\/ int part fits long\nif (lfloor == 0 && negative) {\nintDigits = \"-0\"; \/\/ CWirth fix\n} else {\nintDigits = Long.toString((negative) ? -lfloor : lfloor, base);\n}\n} else {\n\/\/ BigInteger should be used\nlong floorBits = Double.doubleToLongBits(dfloor);\nint exp = (int) (floorBits >> Exp_shiftL) & Exp_mask_shifted;\nlong mantissa;\n\nnegative = true;\nd = -d;\n}\n\/* Get the integer part of d including '-' sign. *\/\nString intDigits;\ndouble dfloor = Math.floor(d);\nlong lfloor = (long) dfloor;\nif (lfloor == dfloor) {\n\/\/ int part fits long\nif (lfloor == 0 && negative) {\nintDigits = \"-0\"; \/\/ CWirth fix\n} else {\nintDigits = Long.toString((negative) ? -lfloor : lfloor, base);\n}\n} else {\n\/\/ BigInteger should be used\nlong floorBits = Double.doubleToLongBits(dfloor);\nint exp = (int) (floorBits >> Exp_shiftL) & Exp_mask_shifted;\nlong mantissa;\nif (exp == 0) {\nmantissa = (floorBits & Frac_maskL) << 1;\n\ndouble dfloor = Math.floor(d);\nlong lfloor = (long) dfloor;\nif (lfloor == dfloor) {\n\/\/ int part fits long\nif (lfloor == 0 && negative) {\nintDigits = \"-0\"; \/\/ CWirth fix\n} else {\nintDigits = Long.toString((negative) ? -lfloor : lfloor, base);\n}\n} else {\n\/\/ BigInteger should be used\nlong floorBits = Double.doubleToLongBits(dfloor);\nint exp = (int) (floorBits >> Exp_shiftL) & Exp_mask_shifted;\nlong mantissa;\nif (exp == 0) {\nmantissa = (floorBits & Frac_maskL) << 1;\n} else {\nmantissa = (floorBits & Frac_maskL) | Exp_msk1L;\n}\nif (negative) {\nmantissa = -mantissa;\n\nexp -= 1075;\nBigInteger x = BigInteger.valueOf(mantissa);\nif (exp > 0) {\nx = x.shiftLeft(exp);\n} else if (exp < 0) {\nx = x.shiftRight(-exp);\n}\nintDigits = x.toString(base);\n}\nif (d == dfloor) {\n\/\/ No fraction part\nreturn intDigits;\n} else {\n\/* We have a fraction. *\/\nStringBuilder buffer; \/* The output string *\/\nint digit;\ndouble df; \/* The fractional part of d *\/\nBigInteger b;\nbuffer = new StringBuilder();\nbuffer.append(intDigits).append('.');\ndf = d - dfloor;\n\nx = x.shiftLeft(exp);\n} else if (exp < 0) {\nx = x.shiftRight(-exp);\n}\nintDigits = x.toString(base);\n}\nif (d == dfloor) {\n\/\/ No fraction part\nreturn intDigits;\n} else {\n\/* We have a fraction. *\/\nStringBuilder buffer; \/* The output string *\/\nint digit;\ndouble df; \/* The fractional part of d *\/\nBigInteger b;\nbuffer = new StringBuilder();\nbuffer.append(intDigits).append('.');\ndf = d - dfloor;\nlong dBits = Double.doubleToLongBits(d);\nint word0 = (int) (dBits >> 32);\nint word1 = (int) (dBits);\n\n} else if (exp < 0) {\nx = x.shiftRight(-exp);\n}\nintDigits = x.toString(base);\n}\nif (d == dfloor) {\n\/\/ No fraction part\nreturn intDigits;\n} else {\n\/* We have a fraction. *\/\nStringBuilder buffer; \/* The output string *\/\nint digit;\ndouble df; \/* The fractional part of d *\/\nBigInteger b;\nbuffer = new StringBuilder();\nbuffer.append(intDigits).append('.');\ndf = d - dfloor;\nlong dBits = Double.doubleToLongBits(d);\nint word0 = (int) (dBits >> 32);\nint word1 = (int) (dBits);\nint[] e = new int[1];\n\n}\nintDigits = x.toString(base);\n}\nif (d == dfloor) {\n\/\/ No fraction part\nreturn intDigits;\n} else {\n\/* We have a fraction. *\/\nStringBuilder buffer; \/* The output string *\/\nint digit;\ndouble df; \/* The fractional part of d *\/\nBigInteger b;\nbuffer = new StringBuilder();\nbuffer.append(intDigits).append('.');\ndf = d - dfloor;\nlong dBits = Double.doubleToLongBits(d);\nint word0 = (int) (dBits >> 32);\nint word1 = (int) (dBits);\nint[] e = new int[1];\nint[] bbits = new int[1];\nb = d2b(df, e, bbits);\n\nBigInteger b;\nbuffer = new StringBuilder();\nbuffer.append(intDigits).append('.');\ndf = d - dfloor;\nlong dBits = Double.doubleToLongBits(d);\nint word0 = (int) (dBits >> 32);\nint word1 = (int) (dBits);\nint[] e = new int[1];\nint[] bbits = new int[1];\nb = d2b(df, e, bbits);\n\/* At this point df = b * 2^e. e must be less than zero because 0 < df < 1. *\/\nint s2 = -(word0 >>> Exp_shift1 & Exp_mask >> Exp_shift1);\nif (s2 == 0) {\ns2 = -1;\n}\ns2 += Bias + P;\n\/* 1\/2^s2 = (nextDouble(d) - d)\/2 *\/\nBigInteger mlo = BigInteger.ONE;\nBigInteger mhi = mlo;\nif ((word1 == 0) && ((word0 & Bndry_mask) == 0) && ((word0 & (Exp_mask & Exp_mask << 1)) != 0)) {\n\/*\n\nint word1 = (int) (dBits);\nint[] e = new int[1];\nint[] bbits = new int[1];\nb = d2b(df, e, bbits);\n\/* At this point df = b * 2^e. e must be less than zero because 0 < df < 1. *\/\nint s2 = -(word0 >>> Exp_shift1 & Exp_mask >> Exp_shift1);\nif (s2 == 0) {\ns2 = -1;\n}\ns2 += Bias + P;\n\/* 1\/2^s2 = (nextDouble(d) - d)\/2 *\/\nBigInteger mlo = BigInteger.ONE;\nBigInteger mhi = mlo;\nif ((word1 == 0) && ((word0 & Bndry_mask) == 0) && ((word0 & (Exp_mask & Exp_mask << 1)) != 0)) {\n\/*\n* The special case. Here we want to be within a quarter of the last input\n* significant digit instead of one half of it when the output string's value is\n* less than d.\n*\/\ns2 += Log2P;\nmhi = BigInteger.valueOf(1 << Log2P);\n\npublic static String jsDtobasestr(int base, double dParam) {\nif (!(2 <= base && base <= 36)) {\nthrow new IllegalArgumentException(\"Bad base: \" + base);\n}\ndouble d = dParam;\n\/* Check for Infinity and NaN *\/\nif (Double.isNaN(d)) {\nreturn \"NaN\";\n} else if (Double.isInfinite(d)) {\nreturn (d > 0.0) ? \"Infinity\" : \"-Infinity\";\n} else if (d == 0) {\n\/\/ ALERT: should it distinguish -0.0 from +0.0 ?\nreturn \"0\";\n}\nboolean negative;\nif (d >= 0.0) {\nnegative = false;\n} else {\nnegative = true;\nd = -d;\n\npublic static String jsDtobasestr(int base, double dParam) {\nif (!(2 <= base && base <= 36)) {\nthrow new IllegalArgumentException(\"Bad base: \" + base);\n}\ndouble d = dParam;\n\/* Check for Infinity and NaN *\/\nif (Double.isNaN(d)) {\nreturn \"NaN\";\n} else if (Double.isInfinite(d)) {\nreturn (d > 0.0) ? \"Infinity\" : \"-Infinity\";\n} else if (d == 0) {\n\/\/ ALERT: should it distinguish -0.0 from +0.0 ?\nreturn \"0\";\n}\nboolean negative;\nif (d >= 0.0) {\nnegative = false;\n} else {\nnegative = true;\nd = -d;\n}\n\/* Get the integer part of d including '-' sign. *\/\nString intDigits;\ndouble dfloor = Math.floor(d);\n\nb = b.multiply(bigBase);\nBigInteger[] divResult = b.divideAndRemainder(s);\nb = divResult[1];\ndigit = (char) (divResult[0].intValue());\nif (mlo == mhi) {\nmlo = mhi = mlo.multiply(bigBase);\n} else {\nmlo = mlo.multiply(bigBase);\nmhi = mhi.multiply(bigBase);\n}\n\/* Do we yet have the shortest string that will round to d? *\/\nint j = b.compareTo(mlo);\n\/* j is b\/2^s2 compared with mlo\/2^s2. *\/\nBigInteger delta = s.subtract(mhi);\nint j1 = (delta.signum() <= 0) ? 1 : b.compareTo(delta);\n\/* j1 is b\/2^s2 compared with 1 - mhi\/2^s2. *\/\nif (j1 == 0 && ((word1 & 1) == 0)) {\nif (j > 0) {\ndigit++;\n}\ndone = true;\n\nb = divResult[1];\ndigit = (char) (divResult[0].intValue());\nif (mlo == mhi) {\nmlo = mhi = mlo.multiply(bigBase);\n} else {\nmlo = mlo.multiply(bigBase);\nmhi = mhi.multiply(bigBase);\n}\n\/* Do we yet have the shortest string that will round to d? *\/\nint j = b.compareTo(mlo);\n\/* j is b\/2^s2 compared with mlo\/2^s2. *\/\nBigInteger delta = s.subtract(mhi);\nint j1 = (delta.signum() <= 0) ? 1 : b.compareTo(delta);\n\/* j1 is b\/2^s2 compared with 1 - mhi\/2^s2. *\/\nif (j1 == 0 && ((word1 & 1) == 0)) {\nif (j > 0) {\ndigit++;\n}\ndone = true;\n} else if (j < 0 || (j == 0 && ((word1 & 1) == 0))) {\nif (j1 > 0) {\n\nmlo = mhi = mlo.multiply(bigBase);\n} else {\nmlo = mlo.multiply(bigBase);\nmhi = mhi.multiply(bigBase);\n}\n\/* Do we yet have the shortest string that will round to d? *\/\nint j = b.compareTo(mlo);\n\/* j is b\/2^s2 compared with mlo\/2^s2. *\/\nBigInteger delta = s.subtract(mhi);\nint j1 = (delta.signum() <= 0) ? 1 : b.compareTo(delta);\n\/* j1 is b\/2^s2 compared with 1 - mhi\/2^s2. *\/\nif (j1 == 0 && ((word1 & 1) == 0)) {\nif (j > 0) {\ndigit++;\n}\ndone = true;\n} else if (j < 0 || (j == 0 && ((word1 & 1) == 0))) {\nif (j1 > 0) {\n\/*\n* Either dig or dig+1 would work here as the least significant digit. Use\n* whichever would produce an output value closer to d.\n\npublic static String jsDtobasestr(int base, double dParam) {\nif (!(2 <= base && base <= 36)) {\nthrow new IllegalArgumentException(\"Bad base: \" + base);\n}\ndouble d = dParam;\n\/* Check for Infinity and NaN *\/\nif (Double.isNaN(d)) {\nreturn \"NaN\";\n} else if (Double.isInfinite(d)) {\nreturn (d > 0.0) ? \"Infinity\" : \"-Infinity\";\n} else if (d == 0) {\n\/\/ ALERT: should it distinguish -0.0 from +0.0 ?\nreturn \"0\";\n}\nboolean negative;\nif (d >= 0.0) {\nnegative = false;\n} else {\nnegative = true;\n\npublic static String jsDtobasestr(int base, double dParam) {\nif (!(2 <= base && base <= 36)) {\nthrow new IllegalArgumentException(\"Bad base: \" + base);\n}\ndouble d = dParam;\n\/* Check for Infinity and NaN *\/\nif (Double.isNaN(d)) {\nreturn \"NaN\";\n} else if (Double.isInfinite(d)) {\nreturn (d > 0.0) ? \"Infinity\" : \"-Infinity\";\n} else if (d == 0) {\n\/\/ ALERT: should it distinguish -0.0 from +0.0 ?\nreturn \"0\";\n}\nboolean negative;\nif (d >= 0.0) {\nnegative = false;\n} else {\nnegative = true;","code_context_20":"public static String jsDtobasestr(int base, double dParam) {\nif (!(2 <= base && base <= 36)) {\nthrow new IllegalArgumentException(\"Bad base: \" + base);\n}\ndouble d = dParam;\n\/* Check for Infinity and NaN *\/\nif (Double.isNaN(d)) {\nreturn \"NaN\";\n} else if (Double.isInfinite(d)) {\nreturn (d > 0.0) ? \"Infinity\" : \"-Infinity\";\n} else if (d == 0) {\n\/\/ ALERT: should it distinguish -0.0 from +0.0 ?\nreturn \"0\";\n}\nboolean negative;\nif (d >= 0.0) {\nnegative = false;\n} else {\nnegative = true;\nd = -d;\n}\n\/* Get the integer part of d including '-' sign. *\/\nString intDigits;\ndouble dfloor = Math.floor(d);\nlong lfloor = (long) dfloor;\nif (lfloor == dfloor) {\n\npublic static String jsDtobasestr(int base, double dParam) {\nif (!(2 <= base && base <= 36)) {\nthrow new IllegalArgumentException(\"Bad base: \" + base);\n}\ndouble d = dParam;\n\/* Check for Infinity and NaN *\/\nif (Double.isNaN(d)) {\nreturn \"NaN\";\n} else if (Double.isInfinite(d)) {\nreturn (d > 0.0) ? \"Infinity\" : \"-Infinity\";\n} else if (d == 0) {\n\/\/ ALERT: should it distinguish -0.0 from +0.0 ?\nreturn \"0\";\n}\nboolean negative;\nif (d >= 0.0) {\nnegative = false;\n} else {\nnegative = true;\nd = -d;\n}\n\/* Get the integer part of d including '-' sign. *\/\nString intDigits;\ndouble dfloor = Math.floor(d);\nlong lfloor = (long) dfloor;\nif (lfloor == dfloor) {\n\/\/ int part fits long\nif (lfloor == 0 && negative) {\nintDigits = \"-0\"; \/\/ CWirth fix\n} else {\nintDigits = Long.toString((negative) ? -lfloor : lfloor, base);\n}\n\nif (!(2 <= base && base <= 36)) {\nthrow new IllegalArgumentException(\"Bad base: \" + base);\n}\ndouble d = dParam;\n\/* Check for Infinity and NaN *\/\nif (Double.isNaN(d)) {\nreturn \"NaN\";\n} else if (Double.isInfinite(d)) {\nreturn (d > 0.0) ? \"Infinity\" : \"-Infinity\";\n} else if (d == 0) {\n\/\/ ALERT: should it distinguish -0.0 from +0.0 ?\nreturn \"0\";\n}\nboolean negative;\nif (d >= 0.0) {\nnegative = false;\n} else {\nnegative = true;\nd = -d;\n}\n\/* Get the integer part of d including '-' sign. *\/\nString intDigits;\ndouble dfloor = Math.floor(d);\nlong lfloor = (long) dfloor;\nif (lfloor == dfloor) {\n\/\/ int part fits long\nif (lfloor == 0 && negative) {\nintDigits = \"-0\"; \/\/ CWirth fix\n} else {\nintDigits = Long.toString((negative) ? -lfloor : lfloor, base);\n}\n} else {\n\/\/ BigInteger should be used\nlong floorBits = Double.doubleToLongBits(dfloor);\nint exp = (int) (floorBits >> Exp_shiftL) & Exp_mask_shifted;\nlong mantissa;\nif (exp == 0) {\nmantissa = (floorBits & Frac_maskL) << 1;\n} else {\nmantissa = (floorBits & Frac_maskL) | Exp_msk1L;\n}\n\nif (Double.isNaN(d)) {\nreturn \"NaN\";\n} else if (Double.isInfinite(d)) {\nreturn (d > 0.0) ? \"Infinity\" : \"-Infinity\";\n} else if (d == 0) {\n\/\/ ALERT: should it distinguish -0.0 from +0.0 ?\nreturn \"0\";\n}\nboolean negative;\nif (d >= 0.0) {\nnegative = false;\n} else {\nnegative = true;\nd = -d;\n}\n\/* Get the integer part of d including '-' sign. *\/\nString intDigits;\ndouble dfloor = Math.floor(d);\nlong lfloor = (long) dfloor;\nif (lfloor == dfloor) {\n\/\/ int part fits long\nif (lfloor == 0 && negative) {\nintDigits = \"-0\"; \/\/ CWirth fix\n} else {\nintDigits = Long.toString((negative) ? -lfloor : lfloor, base);\n}\n} else {\n\/\/ BigInteger should be used\nlong floorBits = Double.doubleToLongBits(dfloor);\nint exp = (int) (floorBits >> Exp_shiftL) & Exp_mask_shifted;\nlong mantissa;\nif (exp == 0) {\nmantissa = (floorBits & Frac_maskL) << 1;\n} else {\nmantissa = (floorBits & Frac_maskL) | Exp_msk1L;\n}\nif (negative) {\nmantissa = -mantissa;\n}\nexp -= 1075;\nBigInteger x = BigInteger.valueOf(mantissa);\n\n} else if (Double.isInfinite(d)) {\nreturn (d > 0.0) ? \"Infinity\" : \"-Infinity\";\n} else if (d == 0) {\n\/\/ ALERT: should it distinguish -0.0 from +0.0 ?\nreturn \"0\";\n}\nboolean negative;\nif (d >= 0.0) {\nnegative = false;\n} else {\nnegative = true;\nd = -d;\n}\n\/* Get the integer part of d including '-' sign. *\/\nString intDigits;\ndouble dfloor = Math.floor(d);\nlong lfloor = (long) dfloor;\nif (lfloor == dfloor) {\n\/\/ int part fits long\nif (lfloor == 0 && negative) {\nintDigits = \"-0\"; \/\/ CWirth fix\n} else {\nintDigits = Long.toString((negative) ? -lfloor : lfloor, base);\n}\n} else {\n\/\/ BigInteger should be used\nlong floorBits = Double.doubleToLongBits(dfloor);\nint exp = (int) (floorBits >> Exp_shiftL) & Exp_mask_shifted;\nlong mantissa;\nif (exp == 0) {\nmantissa = (floorBits & Frac_maskL) << 1;\n} else {\nmantissa = (floorBits & Frac_maskL) | Exp_msk1L;\n}\nif (negative) {\nmantissa = -mantissa;\n}\nexp -= 1075;\nBigInteger x = BigInteger.valueOf(mantissa);\nif (exp > 0) {\nx = x.shiftLeft(exp);\n\n}\nboolean negative;\nif (d >= 0.0) {\nnegative = false;\n} else {\nnegative = true;\nd = -d;\n}\n\/* Get the integer part of d including '-' sign. *\/\nString intDigits;\ndouble dfloor = Math.floor(d);\nlong lfloor = (long) dfloor;\nif (lfloor == dfloor) {\n\/\/ int part fits long\nif (lfloor == 0 && negative) {\nintDigits = \"-0\"; \/\/ CWirth fix\n} else {\nintDigits = Long.toString((negative) ? -lfloor : lfloor, base);\n}\n} else {\n\/\/ BigInteger should be used\nlong floorBits = Double.doubleToLongBits(dfloor);\nint exp = (int) (floorBits >> Exp_shiftL) & Exp_mask_shifted;\nlong mantissa;\nif (exp == 0) {\nmantissa = (floorBits & Frac_maskL) << 1;\n} else {\nmantissa = (floorBits & Frac_maskL) | Exp_msk1L;\n}\nif (negative) {\nmantissa = -mantissa;\n}\nexp -= 1075;\nBigInteger x = BigInteger.valueOf(mantissa);\nif (exp > 0) {\nx = x.shiftLeft(exp);\n} else if (exp < 0) {\nx = x.shiftRight(-exp);\n}\nintDigits = x.toString(base);\n}\n\nint exp = (int) (floorBits >> Exp_shiftL) & Exp_mask_shifted;\nlong mantissa;\nif (exp == 0) {\nmantissa = (floorBits & Frac_maskL) << 1;\n} else {\nmantissa = (floorBits & Frac_maskL) | Exp_msk1L;\n}\nif (negative) {\nmantissa = -mantissa;\n}\nexp -= 1075;\nBigInteger x = BigInteger.valueOf(mantissa);\nif (exp > 0) {\nx = x.shiftLeft(exp);\n} else if (exp < 0) {\nx = x.shiftRight(-exp);\n}\nintDigits = x.toString(base);\n}\nif (d == dfloor) {\n\/\/ No fraction part\nreturn intDigits;\n} else {\n\/* We have a fraction. *\/\nStringBuilder buffer; \/* The output string *\/\nint digit;\ndouble df; \/* The fractional part of d *\/\nBigInteger b;\nbuffer = new StringBuilder();\nbuffer.append(intDigits).append('.');\ndf = d - dfloor;\nlong dBits = Double.doubleToLongBits(d);\nint word0 = (int) (dBits >> 32);\nint word1 = (int) (dBits);\nint[] e = new int[1];\nint[] bbits = new int[1];\nb = d2b(df, e, bbits);\n\/* At this point df = b * 2^e. e must be less than zero because 0 < df < 1. *\/\nint s2 = -(word0 >>> Exp_shift1 & Exp_mask >> Exp_shift1);\nif (s2 == 0) {\ns2 = -1;\n\nmantissa = (floorBits & Frac_maskL) << 1;\n} else {\nmantissa = (floorBits & Frac_maskL) | Exp_msk1L;\n}\nif (negative) {\nmantissa = -mantissa;\n}\nexp -= 1075;\nBigInteger x = BigInteger.valueOf(mantissa);\nif (exp > 0) {\nx = x.shiftLeft(exp);\n} else if (exp < 0) {\nx = x.shiftRight(-exp);\n}\nintDigits = x.toString(base);\n}\nif (d == dfloor) {\n\/\/ No fraction part\nreturn intDigits;\n} else {\n\/* We have a fraction. *\/\nStringBuilder buffer; \/* The output string *\/\nint digit;\ndouble df; \/* The fractional part of d *\/\nBigInteger b;\nbuffer = new StringBuilder();\nbuffer.append(intDigits).append('.');\ndf = d - dfloor;\nlong dBits = Double.doubleToLongBits(d);\nint word0 = (int) (dBits >> 32);\nint word1 = (int) (dBits);\nint[] e = new int[1];\nint[] bbits = new int[1];\nb = d2b(df, e, bbits);\n\/* At this point df = b * 2^e. e must be less than zero because 0 < df < 1. *\/\nint s2 = -(word0 >>> Exp_shift1 & Exp_mask >> Exp_shift1);\nif (s2 == 0) {\ns2 = -1;\n}\ns2 += Bias + P;\n\/* 1\/2^s2 = (nextDouble(d) - d)\/2 *\/\n\n} else {\nmantissa = (floorBits & Frac_maskL) | Exp_msk1L;\n}\nif (negative) {\nmantissa = -mantissa;\n}\nexp -= 1075;\nBigInteger x = BigInteger.valueOf(mantissa);\nif (exp > 0) {\nx = x.shiftLeft(exp);\n} else if (exp < 0) {\nx = x.shiftRight(-exp);\n}\nintDigits = x.toString(base);\n}\nif (d == dfloor) {\n\/\/ No fraction part\nreturn intDigits;\n} else {\n\/* We have a fraction. *\/\nStringBuilder buffer; \/* The output string *\/\nint digit;\ndouble df; \/* The fractional part of d *\/\nBigInteger b;\nbuffer = new StringBuilder();\nbuffer.append(intDigits).append('.');\ndf = d - dfloor;\nlong dBits = Double.doubleToLongBits(d);\nint word0 = (int) (dBits >> 32);\nint word1 = (int) (dBits);\nint[] e = new int[1];\nint[] bbits = new int[1];\nb = d2b(df, e, bbits);\n\/* At this point df = b * 2^e. e must be less than zero because 0 < df < 1. *\/\nint s2 = -(word0 >>> Exp_shift1 & Exp_mask >> Exp_shift1);\nif (s2 == 0) {\ns2 = -1;\n}\ns2 += Bias + P;\n\/* 1\/2^s2 = (nextDouble(d) - d)\/2 *\/\nBigInteger mlo = BigInteger.ONE;\n\n}\nif (negative) {\nmantissa = -mantissa;\n}\nexp -= 1075;\nBigInteger x = BigInteger.valueOf(mantissa);\nif (exp > 0) {\nx = x.shiftLeft(exp);\n} else if (exp < 0) {\nx = x.shiftRight(-exp);\n}\nintDigits = x.toString(base);\n}\nif (d == dfloor) {\n\/\/ No fraction part\nreturn intDigits;\n} else {\n\/* We have a fraction. *\/\nStringBuilder buffer; \/* The output string *\/\nint digit;\ndouble df; \/* The fractional part of d *\/\nBigInteger b;\nbuffer = new StringBuilder();\nbuffer.append(intDigits).append('.');\ndf = d - dfloor;\nlong dBits = Double.doubleToLongBits(d);\nint word0 = (int) (dBits >> 32);\nint word1 = (int) (dBits);\nint[] e = new int[1];\nint[] bbits = new int[1];\nb = d2b(df, e, bbits);\n\/* At this point df = b * 2^e. e must be less than zero because 0 < df < 1. *\/\nint s2 = -(word0 >>> Exp_shift1 & Exp_mask >> Exp_shift1);\nif (s2 == 0) {\ns2 = -1;\n}\ns2 += Bias + P;\n\/* 1\/2^s2 = (nextDouble(d) - d)\/2 *\/\nBigInteger mlo = BigInteger.ONE;\nBigInteger mhi = mlo;\nif ((word1 == 0) && ((word0 & Bndry_mask) == 0) && ((word0 & (Exp_mask & Exp_mask << 1)) != 0)) {\n\nintDigits = x.toString(base);\n}\nif (d == dfloor) {\n\/\/ No fraction part\nreturn intDigits;\n} else {\n\/* We have a fraction. *\/\nStringBuilder buffer; \/* The output string *\/\nint digit;\ndouble df; \/* The fractional part of d *\/\nBigInteger b;\nbuffer = new StringBuilder();\nbuffer.append(intDigits).append('.');\ndf = d - dfloor;\nlong dBits = Double.doubleToLongBits(d);\nint word0 = (int) (dBits >> 32);\nint word1 = (int) (dBits);\nint[] e = new int[1];\nint[] bbits = new int[1];\nb = d2b(df, e, bbits);\n\/* At this point df = b * 2^e. e must be less than zero because 0 < df < 1. *\/\nint s2 = -(word0 >>> Exp_shift1 & Exp_mask >> Exp_shift1);\nif (s2 == 0) {\ns2 = -1;\n}\ns2 += Bias + P;\n\/* 1\/2^s2 = (nextDouble(d) - d)\/2 *\/\nBigInteger mlo = BigInteger.ONE;\nBigInteger mhi = mlo;\nif ((word1 == 0) && ((word0 & Bndry_mask) == 0) && ((word0 & (Exp_mask & Exp_mask << 1)) != 0)) {\n\/*\n* The special case. Here we want to be within a quarter of the last input\n* significant digit instead of one half of it when the output string's value is\n* less than d.\n*\/\ns2 += Log2P;\nmhi = BigInteger.valueOf(1 << Log2P);\n}\nb = b.shiftLeft(e[0] + s2);\nBigInteger s = BigInteger.ONE;\ns = s.shiftLeft(s2);\n\n\/* We have a fraction. *\/\nStringBuilder buffer; \/* The output string *\/\nint digit;\ndouble df; \/* The fractional part of d *\/\nBigInteger b;\nbuffer = new StringBuilder();\nbuffer.append(intDigits).append('.');\ndf = d - dfloor;\nlong dBits = Double.doubleToLongBits(d);\nint word0 = (int) (dBits >> 32);\nint word1 = (int) (dBits);\nint[] e = new int[1];\nint[] bbits = new int[1];\nb = d2b(df, e, bbits);\n\/* At this point df = b * 2^e. e must be less than zero because 0 < df < 1. *\/\nint s2 = -(word0 >>> Exp_shift1 & Exp_mask >> Exp_shift1);\nif (s2 == 0) {\ns2 = -1;\n}\ns2 += Bias + P;\n\/* 1\/2^s2 = (nextDouble(d) - d)\/2 *\/\nBigInteger mlo = BigInteger.ONE;\nBigInteger mhi = mlo;\nif ((word1 == 0) && ((word0 & Bndry_mask) == 0) && ((word0 & (Exp_mask & Exp_mask << 1)) != 0)) {\n\/*\n* The special case. Here we want to be within a quarter of the last input\n* significant digit instead of one half of it when the output string's value is\n* less than d.\n*\/\ns2 += Log2P;\nmhi = BigInteger.valueOf(1 << Log2P);\n}\nb = b.shiftLeft(e[0] + s2);\nBigInteger s = BigInteger.ONE;\ns = s.shiftLeft(s2);\n\/*\n* @formatter:off\n* At this point we have the following:\n* s = 2^s2;\n* 1 > df = b\/2^s2 > 0;\n* (d - prevDouble(d))\/2 = mlo\/2^s2;\n\npublic static String jsDtobasestr(int base, double dParam) {\nif (!(2 <= base && base <= 36)) {\nthrow new IllegalArgumentException(\"Bad base: \" + base);\n}\ndouble d = dParam;\n\/* Check for Infinity and NaN *\/\nif (Double.isNaN(d)) {\nreturn \"NaN\";\n} else if (Double.isInfinite(d)) {\nreturn (d > 0.0) ? \"Infinity\" : \"-Infinity\";\n} else if (d == 0) {\n\/\/ ALERT: should it distinguish -0.0 from +0.0 ?\nreturn \"0\";\n}\nboolean negative;\nif (d >= 0.0) {\nnegative = false;\n} else {\nnegative = true;\nd = -d;\n}\n\/* Get the integer part of d including '-' sign. *\/\nString intDigits;\ndouble dfloor = Math.floor(d);\nlong lfloor = (long) dfloor;\nif (lfloor == dfloor) {\n\/\/ int part fits long\nif (lfloor == 0 && negative) {\nintDigits = \"-0\"; \/\/ CWirth fix\n} else {\n\npublic static String jsDtobasestr(int base, double dParam) {\nif (!(2 <= base && base <= 36)) {\nthrow new IllegalArgumentException(\"Bad base: \" + base);\n}\ndouble d = dParam;\n\/* Check for Infinity and NaN *\/\nif (Double.isNaN(d)) {\nreturn \"NaN\";\n} else if (Double.isInfinite(d)) {\nreturn (d > 0.0) ? \"Infinity\" : \"-Infinity\";\n} else if (d == 0) {\n\/\/ ALERT: should it distinguish -0.0 from +0.0 ?\nreturn \"0\";\n}\nboolean negative;\nif (d >= 0.0) {\nnegative = false;\n} else {\nnegative = true;\nd = -d;\n}\n\/* Get the integer part of d including '-' sign. *\/\nString intDigits;\ndouble dfloor = Math.floor(d);\nlong lfloor = (long) dfloor;\nif (lfloor == dfloor) {\n\/\/ int part fits long\nif (lfloor == 0 && negative) {\nintDigits = \"-0\"; \/\/ CWirth fix\n} else {\nintDigits = Long.toString((negative) ? -lfloor : lfloor, base);\n}\n} else {\n\/\/ BigInteger should be used\n\n* At this point we have the following:\n* s = 2^s2;\n* 1 > df = b\/2^s2 > 0;\n* (d - prevDouble(d))\/2 = mlo\/2^s2;\n* (nextDouble(d) - d)\/2 = mhi\/2^s2.\n* @formatter:on\n*\/\nBigInteger bigBase = BigInteger.valueOf(base);\nboolean done = false;\ndo {\nb = b.multiply(bigBase);\nBigInteger[] divResult = b.divideAndRemainder(s);\nb = divResult[1];\ndigit = (char) (divResult[0].intValue());\nif (mlo == mhi) {\nmlo = mhi = mlo.multiply(bigBase);\n} else {\nmlo = mlo.multiply(bigBase);\nmhi = mhi.multiply(bigBase);\n}\n\/* Do we yet have the shortest string that will round to d? *\/\nint j = b.compareTo(mlo);\n\/* j is b\/2^s2 compared with mlo\/2^s2. *\/\nBigInteger delta = s.subtract(mhi);\nint j1 = (delta.signum() <= 0) ? 1 : b.compareTo(delta);\n\/* j1 is b\/2^s2 compared with 1 - mhi\/2^s2. *\/\nif (j1 == 0 && ((word1 & 1) == 0)) {\nif (j > 0) {\ndigit++;\n}\ndone = true;\n} else if (j < 0 || (j == 0 && ((word1 & 1) == 0))) {\nif (j1 > 0) {\n\/*\n* Either dig or dig+1 would work here as the least significant digit. Use\n* whichever would produce an output value closer to d.\n*\/\nb = b.shiftLeft(1);\nj1 = b.compareTo(s);\nif (j1 > 0) {\n\/*\n\n* 1 > df = b\/2^s2 > 0;\n* (d - prevDouble(d))\/2 = mlo\/2^s2;\n* (nextDouble(d) - d)\/2 = mhi\/2^s2.\n* @formatter:on\n*\/\nBigInteger bigBase = BigInteger.valueOf(base);\nboolean done = false;\ndo {\nb = b.multiply(bigBase);\nBigInteger[] divResult = b.divideAndRemainder(s);\nb = divResult[1];\ndigit = (char) (divResult[0].intValue());\nif (mlo == mhi) {\nmlo = mhi = mlo.multiply(bigBase);\n} else {\nmlo = mlo.multiply(bigBase);\nmhi = mhi.multiply(bigBase);\n}\n\/* Do we yet have the shortest string that will round to d? *\/\nint j = b.compareTo(mlo);\n\/* j is b\/2^s2 compared with mlo\/2^s2. *\/\nBigInteger delta = s.subtract(mhi);\nint j1 = (delta.signum() <= 0) ? 1 : b.compareTo(delta);\n\/* j1 is b\/2^s2 compared with 1 - mhi\/2^s2. *\/\nif (j1 == 0 && ((word1 & 1) == 0)) {\nif (j > 0) {\ndigit++;\n}\ndone = true;\n} else if (j < 0 || (j == 0 && ((word1 & 1) == 0))) {\nif (j1 > 0) {\n\/*\n* Either dig or dig+1 would work here as the least significant digit. Use\n* whichever would produce an output value closer to d.\n*\/\nb = b.shiftLeft(1);\nj1 = b.compareTo(s);\nif (j1 > 0) {\n\/*\n* The even test (|| (j1 == 0 && (digit & 1))) is not here because it\n* messes up odd base output such as 3.5 in base 3.\n\n* @formatter:on\n*\/\nBigInteger bigBase = BigInteger.valueOf(base);\nboolean done = false;\ndo {\nb = b.multiply(bigBase);\nBigInteger[] divResult = b.divideAndRemainder(s);\nb = divResult[1];\ndigit = (char) (divResult[0].intValue());\nif (mlo == mhi) {\nmlo = mhi = mlo.multiply(bigBase);\n} else {\nmlo = mlo.multiply(bigBase);\nmhi = mhi.multiply(bigBase);\n}\n\/* Do we yet have the shortest string that will round to d? *\/\nint j = b.compareTo(mlo);\n\/* j is b\/2^s2 compared with mlo\/2^s2. *\/\nBigInteger delta = s.subtract(mhi);\nint j1 = (delta.signum() <= 0) ? 1 : b.compareTo(delta);\n\/* j1 is b\/2^s2 compared with 1 - mhi\/2^s2. *\/\nif (j1 == 0 && ((word1 & 1) == 0)) {\nif (j > 0) {\ndigit++;\n}\ndone = true;\n} else if (j < 0 || (j == 0 && ((word1 & 1) == 0))) {\nif (j1 > 0) {\n\/*\n* Either dig or dig+1 would work here as the least significant digit. Use\n* whichever would produce an output value closer to d.\n*\/\nb = b.shiftLeft(1);\nj1 = b.compareTo(s);\nif (j1 > 0) {\n\/*\n* The even test (|| (j1 == 0 && (digit & 1))) is not here because it\n* messes up odd base output such as 3.5 in base 3.\n*\/\ndigit++;\n}\n\npublic static String jsDtobasestr(int base, double dParam) {\nif (!(2 <= base && base <= 36)) {\nthrow new IllegalArgumentException(\"Bad base: \" + base);\n}\ndouble d = dParam;\n\/* Check for Infinity and NaN *\/\nif (Double.isNaN(d)) {\nreturn \"NaN\";\n} else if (Double.isInfinite(d)) {\nreturn (d > 0.0) ? \"Infinity\" : \"-Infinity\";\n} else if (d == 0) {\n\/\/ ALERT: should it distinguish -0.0 from +0.0 ?\nreturn \"0\";\n}\nboolean negative;\nif (d >= 0.0) {\nnegative = false;\n} else {\nnegative = true;\nd = -d;\n}\n\/* Get the integer part of d including '-' sign. *\/\nString intDigits;\ndouble dfloor = Math.floor(d);\nlong lfloor = (long) dfloor;\nif (lfloor == dfloor) {\n\/\/ int part fits long\nif (lfloor == 0 && negative) {\nintDigits = \"-0\"; \/\/ CWirth fix\n\npublic static String jsDtobasestr(int base, double dParam) {\nif (!(2 <= base && base <= 36)) {\nthrow new IllegalArgumentException(\"Bad base: \" + base);\n}\ndouble d = dParam;\n\/* Check for Infinity and NaN *\/\nif (Double.isNaN(d)) {\nreturn \"NaN\";\n} else if (Double.isInfinite(d)) {\nreturn (d > 0.0) ? \"Infinity\" : \"-Infinity\";\n} else if (d == 0) {\n\/\/ ALERT: should it distinguish -0.0 from +0.0 ?\nreturn \"0\";\n}\nboolean negative;\nif (d >= 0.0) {\nnegative = false;\n} else {\nnegative = true;\nd = -d;\n}\n\/* Get the integer part of d including '-' sign. *\/\nString intDigits;\ndouble dfloor = Math.floor(d);\nlong lfloor = (long) dfloor;\nif (lfloor == dfloor) {\n\/\/ int part fits long\nif (lfloor == 0 && negative) {\nintDigits = \"-0\"; \/\/ CWirth fix","label":[1,0,0,0]}
{"id":11112,"original_code":"@Override\n  public final boolean equals(final Object other) {\n    if (!(other instanceof Production)) {\n      return false;\n    }\n    \/\/ XXX NOTE: this assumes that the reference of the generator value does not change!\n    final Production otherProduction = (Production) other;\n    return this.id == otherProduction.id\n        && this.ownClass.equals(otherProduction.ownClass)\n        && this.generatorValue == otherProduction.generatorValue;\n  }","code":"@Override\n  public final boolean equals(final Object other) {\n    if (!(other instanceof Production)) {\n      return false;\n    }\n   \n    final Production otherProduction = (Production) other;\n    return this.id == otherProduction.id\n        && this.ownClass.equals(otherProduction.ownClass)\n        && this.generatorValue == otherProduction.generatorValue;\n  }","cleancode":"@override public final boolean equals(final object other) { if (!(other instanceof production)) { return false; } final production otherproduction = (production) other; return this.id == otherproduction.id && this.ownclass.equals(otherproduction.ownclass) && this.generatorvalue == otherproduction.generatorvalue; }","comment":"\/\/ xxx note: this assumes that the reference of the generator value does not change!","repo":"mskamp\/StarSmith","code_context_2":"return false;\n}\n\/\/ XXX NOTE: this assumes that the reference of the generator value does not change!\nfinal Production otherProduction = (Production) other;\nreturn this.id == otherProduction.id","code_context_10":"@Override\npublic final boolean equals(final Object other) {\nif (!(other instanceof Production)) {\nreturn false;\n}\n\/\/ XXX NOTE: this assumes that the reference of the generator value does not change!\nfinal Production otherProduction = (Production) other;\nreturn this.id == otherProduction.id\n&& this.ownClass.equals(otherProduction.ownClass)\n&& this.generatorValue == otherProduction.generatorValue;\n}","code_context_20":"@Override\npublic final boolean equals(final Object other) {\nif (!(other instanceof Production)) {\nreturn false;\n}\n\/\/ XXX NOTE: this assumes that the reference of the generator value does not change!\nfinal Production otherProduction = (Production) other;\nreturn this.id == otherProduction.id\n&& this.ownClass.equals(otherProduction.ownClass)\n&& this.generatorValue == otherProduction.generatorValue;\n}","label":[1,0,0,0]}
{"id":2951,"original_code":"private boolean shouldRollToNewFile() {\n      \/\/ TODO: ORC file now not support target file size before closed\n      return !format.equals(FileFormat.ORC) &&\n          currentRows % ROWS_DIVISOR == 0 && length(currentWriter) >= targetFileSize;\n    }","code":"private boolean shouldRollToNewFile() {\n     \n      return !format.equals(FileFormat.ORC) &&\n          currentRows % ROWS_DIVISOR == 0 && length(currentWriter) >= targetFileSize;\n    }","cleancode":"private boolean shouldrolltonewfile() { return !format.equals(fileformat.orc) && currentrows % rows_divisor == 0 && length(currentwriter) >= targetfilesize; }","comment":"\/\/ todo: orc file now not support target file size before closed","repo":"rajarshisarkar\/iceberg","code_context_2":"private boolean shouldRollToNewFile() {\n\/\/ TODO: ORC file now not support target file size before closed\nreturn !format.equals(FileFormat.ORC) &&\ncurrentRows % ROWS_DIVISOR == 0 && length(currentWriter) >= targetFileSize;","code_context_10":"private boolean shouldRollToNewFile() {\n\/\/ TODO: ORC file now not support target file size before closed\nreturn !format.equals(FileFormat.ORC) &&\ncurrentRows % ROWS_DIVISOR == 0 && length(currentWriter) >= targetFileSize;\n}","code_context_20":"private boolean shouldRollToNewFile() {\n\/\/ TODO: ORC file now not support target file size before closed\nreturn !format.equals(FileFormat.ORC) &&\ncurrentRows % ROWS_DIVISOR == 0 && length(currentWriter) >= targetFileSize;\n}","label":[0,1,0,0]}
{"id":19374,"original_code":"boolean isAlreadyLogged(StackTraceElement[] stack)\n\t{\n\t\tHashStackTraceElement hse = new HashStackTraceElement(stack);\n\t\t\/\/ Ok, it's block the code, but for a small period\n\t\tsynchronized (this)\n\t\t{\n\t\t\t\/\/ Detect with the precalculated hash value\n\t\t\treturn !logged.add(hse);\n\t\t}\n\t}","code":"boolean isAlreadyLogged(StackTraceElement[] stack)\n\t{\n\t\tHashStackTraceElement hse = new HashStackTraceElement(stack);\n\t\n\t\tsynchronized (this)\n\t\t{\n\t\t\n\t\t\treturn !logged.add(hse);\n\t\t}\n\t}","cleancode":"boolean isalreadylogged(stacktraceelement[] stack) { hashstacktraceelement hse = new hashstacktraceelement(stack); synchronized (this) { return !logged.add(hse); } }","comment":"\/\/ warning : use synchronized. is it possible to reduce the blocking part ?\n\/\/ ok, it's block the code, but for a small period\n\/\/ detect with the precalculated hash value","repo":"octo-online\/reactive-aud","code_context_2":"boolean isAlreadyLogged(StackTraceElement[] stack)\n{\nHashStackTraceElement hse = new HashStackTraceElement(stack);\n\/\/ Ok, it's block the code, but for a small period\nsynchronized (this)\n{\n\/\/ Detect with the precalculated hash value\nreturn !logged.add(hse);\n}\n}\n\n{\nHashStackTraceElement hse = new HashStackTraceElement(stack);\n\/\/ Ok, it's block the code, but for a small period\nsynchronized (this)\n{\n\nsynchronized (this)\n{\n\/\/ Detect with the precalculated hash value\nreturn !logged.add(hse);\n}","code_context_10":"boolean isAlreadyLogged(StackTraceElement[] stack)\n{\nHashStackTraceElement hse = new HashStackTraceElement(stack);\n\/\/ Ok, it's block the code, but for a small period\nsynchronized (this)\n{\n\/\/ Detect with the precalculated hash value\nreturn !logged.add(hse);\n}\n}\n\nboolean isAlreadyLogged(StackTraceElement[] stack)\n{\nHashStackTraceElement hse = new HashStackTraceElement(stack);\n\/\/ Ok, it's block the code, but for a small period\nsynchronized (this)\n{\n\/\/ Detect with the precalculated hash value\nreturn !logged.add(hse);\n}\n}\n\nboolean isAlreadyLogged(StackTraceElement[] stack)\n{\nHashStackTraceElement hse = new HashStackTraceElement(stack);\n\/\/ Ok, it's block the code, but for a small period\nsynchronized (this)\n{\n\/\/ Detect with the precalculated hash value\nreturn !logged.add(hse);\n}\n}","code_context_20":"boolean isAlreadyLogged(StackTraceElement[] stack)\n{\nHashStackTraceElement hse = new HashStackTraceElement(stack);\n\/\/ Ok, it's block the code, but for a small period\nsynchronized (this)\n{\n\/\/ Detect with the precalculated hash value\nreturn !logged.add(hse);\n}\n}\n\nboolean isAlreadyLogged(StackTraceElement[] stack)\n{\nHashStackTraceElement hse = new HashStackTraceElement(stack);\n\/\/ Ok, it's block the code, but for a small period\nsynchronized (this)\n{\n\/\/ Detect with the precalculated hash value\nreturn !logged.add(hse);\n}\n}\n\nboolean isAlreadyLogged(StackTraceElement[] stack)\n{\nHashStackTraceElement hse = new HashStackTraceElement(stack);\n\/\/ Ok, it's block the code, but for a small period\nsynchronized (this)\n{\n\/\/ Detect with the precalculated hash value\nreturn !logged.add(hse);\n}\n}","label":[1,0,0,0]}
{"id":2992,"original_code":"public int doEndTag()\n        throws JspTagException\n    {\n        HttpServletRequest request = (HttpServletRequest)super.pageContext.getRequest();\n        RequestProperties reqState = (RequestProperties)request.getAttribute(SECTION_REQUESTPROPS);\n        PrivateLabel     privLabel = (reqState != null)? reqState.getPrivateLabel() : RequestProperties.NullPrivateLabel;\n        JspWriter              out = super.pageContext.getOut();\n        String                   s = this.getSection().toLowerCase();\n        \/* ignore blank section definitions *\/\n        if (StringTools.isBlank(s)) {\n            \/\/ -- ignore\n            return EVAL_PAGE;\n        }\n        \/* not a match? *\/\n        if (!this.isMatch()) {\n            \/\/ -- ignore\n            return EVAL_PAGE;\n        }\n        \/\/ --------------------------------------------------------------------\n        \/* \"onload='...'\" *\/\n        if (s.equalsIgnoreCase(SECTION_BODY_ONLOAD)) {\n            String bodyOnLoad = (String)request.getAttribute(SECTION_BODY_ONLOAD);\n            if (!StringTools.isBlank(bodyOnLoad)) {\n                try {\n                    out.print(bodyOnLoad);\n                } catch (IOException ioe) {\n                    throw new JspTagException(ioe.toString());\n                }\n            }\n            return EVAL_PAGE;\n        }\n        \/* \"onunload='...'\" *\/\n        if (s.equalsIgnoreCase(SECTION_BODY_ONUNLOAD)) {\n            String bodyOnUnload = (String)request.getAttribute(SECTION_BODY_ONUNLOAD);\n            if (!StringTools.isBlank(bodyOnUnload)) {\n                try {\n                    out.print(bodyOnUnload);\n                } catch (IOException ioe) {\n                    throw new JspTagException(ioe.toString());\n                }\n            }\n            return EVAL_PAGE;\n        }\n        \/\/ --------------------------------------------------------------------\n        \/* expandMenu style *\/\n        if (s.equalsIgnoreCase(SECTION_MENU_STYLE)) {\n            try {\n                ExpandMenu.writeStyle(out, reqState);\n            } catch (IOException ioe) {\n                throw new JspTagException(ioe.toString());\n            }\n            return EVAL_PAGE;\n        }\n        \/* expandMenu javascript *\/\n        if (s.equalsIgnoreCase(SECTION_MENU_JAVASCRIPT)) {\n            try {\n                ExpandMenu.writeJavaScript(out, reqState);\n            } catch (IOException ioe) {\n                throw new JspTagException(ioe.toString());\n            }\n            return EVAL_PAGE;\n        }\n        \/* expandMenu *\/\n        if (s.equalsIgnoreCase(SECTION_MENU)) {\n            try {\n                ExpandMenu.writeMenu(out, reqState, \n                    null\/*menuID*\/, true\/*expandableMenu*\/, \n                    false\/*showIcon*\/, ExpandMenu.DESC_LONG, false\/*showMenuHelp*\/);\n            } catch (IOException ioe) {\n                throw new JspTagException(ioe.toString());\n            }\n            return EVAL_PAGE;\n        }\n        \/\/ --------------------------------------------------------------------\n        \/* content table class *\/\n        if (s.equalsIgnoreCase(SECTION_CONTENT_CLASS_TABLE)) {\n            HTMLOutput content = (HTMLOutput)request.getAttribute(SECTION_CONTENT_BODY);\n            if (content != null) {\n                try {\n                    String tableClass = content.getTableClass();\n                    out.write(!StringTools.isBlank(tableClass)? tableClass : \"contentTableClass\");\n                } catch (IOException ioe) {\n                    throw new JspTagException(ioe.toString());\n                }\n            }\n            return EVAL_PAGE;\n        }\n        \/* content cell class *\/\n        if (s.equalsIgnoreCase(SECTION_CONTENT_CLASS_CELL)) {\n            HTMLOutput content = (HTMLOutput)request.getAttribute(SECTION_CONTENT_BODY);\n            if (content != null) {\n                try {\n                    String cellClass = content.getCellClass();\n                    out.write(!StringTools.isBlank(cellClass)? cellClass : \"contentCellClass\");\n                } catch (IOException ioe) {\n                    throw new JspTagException(ioe.toString());\n                }\n            }\n            return EVAL_PAGE;\n        }\n        \/* content message id *\/\n        if (s.equalsIgnoreCase(SECTION_CONTENT_ID_MESSAGE)) {\n            try {\n                out.write(CommonServlet.ID_CONTENT_MESSAGE);\n            } catch (IOException ioe) {\n                throw new JspTagException(ioe.toString());\n            }\n            return EVAL_PAGE;\n        }\n        \/* content message class *\/\n        if (s.equalsIgnoreCase(SECTION_CONTENT_CLASS_MESSAGE)) {\n            try {\n                out.write(CommonServlet.CSS_CONTENT_MESSAGE);\n            } catch (IOException ioe) {\n                throw new JspTagException(ioe.toString());\n            }\n            return EVAL_PAGE;\n        }\n        \/* content menubar *\/\n        if (s.equalsIgnoreCase(SECTION_CONTENT_MENUBAR)) {\n            HTMLOutput content = (HTMLOutput)request.getAttribute(SECTION_CONTENT_BODY);\n            if (content != null) {\n                String contentClass = content.getTableClass();\n                try {\n                    if (ListTools.contains(CommonServlet.CSS_MENUBAR_OK,contentClass)) {\n                        MenuBar.writeTableRow(out, reqState.getPageName(), reqState);\n                    } else {\n                        out.write(\"<!-- no menubar ['\"+contentClass+\"'] -->\");\n                    }\n                } catch (IOException ioe) {\n                    throw new JspTagException(ioe.toString());\n                }\n            }\n            return EVAL_PAGE;\n        }\n        \/* content message *\/\n        if (s.equalsIgnoreCase(SECTION_CONTENT_MESSAGE)) {\n            HTMLOutput content = (HTMLOutput)request.getAttribute(SECTION_CONTENT_BODY);\n            String msg = (content != null)? StringTools.trim(content.getTableMessage()) : \"\";\n            try {\n                out.write(msg); \/\/ TODO: HTML encode?\n            } catch (IOException ioe) {\n                throw new JspTagException(ioe.toString());\n            }\n            return EVAL_PAGE;\n        }\n        \/\/ --------------------------------------------------------------------\n        \/* request context path *\/\n        if (s.equalsIgnoreCase(SECTION_REQUEST_CONTEXT)) {\n            try {\n                out.write(request.getContextPath());\n            } catch (IOException ioe) {\n                throw new JspTagException(ioe.toString());\n            }\n            return EVAL_PAGE;\n        }\n        \/\/ --------------------------------------------------------------------\n        \/* CSS file *\/\n        if (s.equalsIgnoreCase(SECTION_CSSFILE)) {\n            String cssFilePath = this.getArg();\n            if (!StringTools.isBlank(cssFilePath)) {\n                try {\n                    PrintWriter pw = new PrintWriter(out, out.isAutoFlush());\n                    WebPageAdaptor.writeCssLink(pw, reqState, cssFilePath, null);\n                } catch (IOException ioe) {\n                    throw new JspTagException(ioe.toString());\n                }\n            }\n            return EVAL_PAGE;\n        }\n        \/\/ --------------------------------------------------------------------\n        \/* Banner Image Height *\/\n        if (s.equalsIgnoreCase(SECTION_BANNER_WIDTH)) {\n            \/\/ key suffix\n            String kSfx = StringTools.trim(this.getArg());\n            \/\/ property values\n            String bannerWidth = privLabel.getStringProperty(PrivateLabel.PROP_Banner_width   + kSfx, null);\n            if (StringTools.isBlank(bannerWidth)) {\n                bannerWidth = privLabel.getStringProperty(PrivateLabel.PROP_Banner_imageWidth + kSfx, null);\n            }\n            \/\/ minimum valie\n            if (StringTools.isBlank(bannerWidth)) {\n                bannerWidth = this.hasDefault()? this.getDefault() : \"100%\";\n            } else\n            if (!bannerWidth.endsWith(\"%\")) {\n                int W = StringTools.parseInt(bannerWidth, 0);\n                bannerWidth = String.valueOf((W < MIN_BANNER_WIDTH)? MIN_BANNER_WIDTH : W);\n            }\n            \/\/ generate html\n            try {\n                out.write(bannerWidth);\n            } catch (IOException ioe) {\n                throw new JspTagException(ioe.toString());\n            }\n            return EVAL_PAGE;\n        }\n        \/* Banner Style *\/\n        if (s.equalsIgnoreCase(SECTION_BANNER_STYLE)) {\n            \/\/ key suffix\n            String kSfx = StringTools.trim(this.getArg());\n            \/\/ property values\n            String bannerStyle = privLabel.getStringProperty(PrivateLabel.PROP_Banner_style + kSfx, null);\n            \/\/ generate html\n            if (!StringTools.isBlank(bannerStyle)) {\n                try {\n                    out.write(bannerStyle);\n                } catch (IOException ioe) {\n                    throw new JspTagException(ioe.toString());\n                }\n            } else\n            if (this.hasDefault()) {\n                try {\n                    out.write(this.getDefault());\n                } catch (IOException ioe) {\n                    throw new JspTagException(ioe.toString());\n                }\n            }\n            return EVAL_PAGE;\n        }\n        \/* Banner Image *\/\n        if (s.equalsIgnoreCase(SECTION_BANNER_IMAGE)) {\n            \/\/ key suffix\n            String kSfx      = StringTools.trim(this.getArg());\n            \/\/ property values\n            String imgLink   = privLabel.getStringProperty(PrivateLabel.PROP_Banner_imageLink   + kSfx, null);\n            String imgSrc    = privLabel.getStringProperty(PrivateLabel.PROP_Banner_imageSource + kSfx, null);\n            String imgWidth  = privLabel.getStringProperty(PrivateLabel.PROP_Banner_imageWidth  + kSfx, null);\n            String imgHeight = privLabel.getStringProperty(PrivateLabel.PROP_Banner_imageHeight + kSfx, null);\n            \/\/ generate html\n            if (!StringTools.isBlank(imgSrc)) {\n                StringBuffer sb = new StringBuffer();\n                if (!StringTools.isBlank(imgLink)) { \n                    sb.append(\"<a href='\").append(imgLink).append(\"' target='_blank'>\"); \n                }\n                sb.append(\"<img src='\").append(imgSrc).append(\"' border='0'\");\n                if (!StringTools.isBlank(imgWidth)) {\n                    sb.append(\" width='\").append(imgWidth).append(\"'\");\n                }\n                if (!StringTools.isBlank(imgHeight)) {\n                    sb.append(\" height='\").append(imgHeight).append(\"'\");\n                }\n                sb.append(\">\");\n                if (!StringTools.isBlank(imgLink)) {\n                    sb.append(\"<\/a>\");\n                }\n                try {\n                    out.write(sb.toString());\n                } catch (IOException ioe) {\n                    throw new JspTagException(ioe.toString());\n                }\n            } else\n            if (this.hasDefault()) {\n                try {\n                    out.write(this.getDefault());\n                } catch (IOException ioe) {\n                    throw new JspTagException(ioe.toString());\n                }\n            }\n            return EVAL_PAGE;\n        }\n        \/* Banner Image *\/\n        if (s.equalsIgnoreCase(SECTION_BANNER_IMAGE_SOURCE)) {\n            \/\/ key suffix\n            String kSfx      = StringTools.trim(this.getArg());\n            \/\/ property values\n            String imgSrc    = privLabel.getStringProperty(PrivateLabel.PROP_Banner_imageSource + kSfx, null);\n            \/\/ generate html\n            if (!StringTools.isBlank(imgSrc)) {\n                \/\/Print.sysPrintln(\"Property Image Source: \" + imgSrc);\n                try {\n                    out.write(imgSrc);\n                } catch (IOException ioe) {\n                    throw new JspTagException(ioe.toString());\n                }\n            } else\n            if (this.hasDefault()) {\n                \/\/Print.sysPrintln(\"Default Image Source: \" + this.getDefault());\n                try {\n                    out.write(this.getDefault());\n                } catch (IOException ioe) {\n                    throw new JspTagException(ioe.toString());\n                }\n            }\n            return EVAL_PAGE;\n        }\n        \/* Banner Image Height *\/\n        if (s.equalsIgnoreCase(SECTION_BANNER_IMAGE_WIDTH)) {\n            \/\/ key suffix\n            String kSfx      = StringTools.trim(this.getArg());\n            \/\/ property values\n            String imgWidth  = privLabel.getStringProperty(PrivateLabel.PROP_Banner_imageWidth  + kSfx, null);\n            \/\/ generate html\n            if (!StringTools.isBlank(imgWidth)) {\n                try {\n                    out.write(imgWidth);\n                } catch (IOException ioe) {\n                    throw new JspTagException(ioe.toString());\n                }\n            } else\n            if (this.hasDefault()) {\n                try {\n                    out.write(this.getDefault());\n                } catch (IOException ioe) {\n                    throw new JspTagException(ioe.toString());\n                }\n            }\n            return EVAL_PAGE;\n        }\n        \/* Banner Image Height *\/\n        if (s.equalsIgnoreCase(SECTION_BANNER_IMAGE_HEIGHT)) {\n            \/\/ key suffix\n            String kSfx      = StringTools.trim(this.getArg());\n            \/\/ property values\n            String imgHeight = privLabel.getStringProperty(PrivateLabel.PROP_Banner_imageHeight + kSfx, null);\n            \/\/ generate html\n            if (!StringTools.isBlank(imgHeight)) {\n                try {\n                    out.write(imgHeight);\n                } catch (IOException ioe) {\n                    throw new JspTagException(ioe.toString());\n                }\n            } else\n            if (this.hasDefault()) {\n                try {\n                    out.write(this.getDefault());\n                } catch (IOException ioe) {\n                    throw new JspTagException(ioe.toString());\n                }\n            }\n            return EVAL_PAGE;\n        }\n        \/\/ --------------------------------------------------------------------\n        \/* JavaScript *\/\n        if (s.equalsIgnoreCase(SECTION_JAVASCRIPT)) {\n            try {\n                \/\/ always write \"utils.js\"\n                JavaScriptTools.writeUtilsJS(out, request);\n                \/\/ check for other javascript \n                Object obj = request.getAttribute(SECTION_JAVASCRIPT);\n                if (obj instanceof HTMLOutput) {\n                    ((HTMLOutput)obj).write(out); \n                } else {\n                    out.write(\"<!-- Unexpected section type '\" + s + \"' [\" + StringTools.className(obj) + \"] -->\"); \n                }\n            } catch (IOException ioe) {\n                throw new JspTagException(ioe.toString());\n            }\n            return EVAL_PAGE;\n        }\n        \/\/ --------------------------------------------------------------------\n        \/* current page name *\/\n        if (s.equalsIgnoreCase(SECTION_PAGE_NAME)) { \/\/ \"pagename\"\n            String pageName = reqState.getPageName();\n            if (!StringTools.isBlank(pageName)) {\n                try {\n                    out.write(pageName);\n                } catch (IOException ioe) {\n                    throw new JspTagException(ioe.toString());\n                }\n            }\n            return EVAL_PAGE;\n        }\n        \/\/ --------------------------------------------------------------------\n        \/* Page URL *\/\n        if (s.equalsIgnoreCase(SECTION_PAGE_URL)) { \/\/ \"pageurl\"\n            String pageName = this.getArg();\n            String cmd      = null;\n            String cmdArg   = null;\n            WebPage wp = privLabel.getWebPage(pageName);\n            String url = (wp != null)? wp.encodePageURL(reqState,cmd,cmdArg) : null;\n            if (!StringTools.isBlank(url)) {\n                try {\n                    out.write(url);\n                } catch (IOException ioe) {\n                    throw new JspTagException(ioe.toString());\n                }\n            }\n            return EVAL_PAGE;\n        }\n        \/\/ --------------------------------------------------------------------\n        \/* HTMLOutput *\/\n        try {\n            Object obj = request.getAttribute(s);\n            if (obj == null) {\n                out.write(\"<!-- Undefined section '\" + s + \"' -->\"); \n            } else\n            if (obj instanceof HTMLOutput) {\n                ((HTMLOutput)obj).write(out); \n            } else {\n                out.write(\"<!-- Unexpected section type '\" + s + \"' [\" + StringTools.className(obj) + \"] -->\"); \n            }\n        } catch (IOException ioe) {\n            throw new JspTagException(ioe.toString());\n        }\n        return EVAL_PAGE;\n    }","code":"public int doEndTag()\n        throws JspTagException\n    {\n        HttpServletRequest request = (HttpServletRequest)super.pageContext.getRequest();\n        RequestProperties reqState = (RequestProperties)request.getAttribute(SECTION_REQUESTPROPS);\n        PrivateLabel     privLabel = (reqState != null)? reqState.getPrivateLabel() : RequestProperties.NullPrivateLabel;\n        JspWriter              out = super.pageContext.getOut();\n        String                   s = this.getSection().toLowerCase();\n       \n        if (StringTools.isBlank(s)) {\n           \n            return EVAL_PAGE;\n        }\n       \n        if (!this.isMatch()) {\n           \n            return EVAL_PAGE;\n        }\n       \n       \n        if (s.equalsIgnoreCase(SECTION_BODY_ONLOAD)) {\n            String bodyOnLoad = (String)request.getAttribute(SECTION_BODY_ONLOAD);\n            if (!StringTools.isBlank(bodyOnLoad)) {\n                try {\n                    out.print(bodyOnLoad);\n                } catch (IOException ioe) {\n                    throw new JspTagException(ioe.toString());\n                }\n            }\n            return EVAL_PAGE;\n        }\n       \n        if (s.equalsIgnoreCase(SECTION_BODY_ONUNLOAD)) {\n            String bodyOnUnload = (String)request.getAttribute(SECTION_BODY_ONUNLOAD);\n            if (!StringTools.isBlank(bodyOnUnload)) {\n                try {\n                    out.print(bodyOnUnload);\n                } catch (IOException ioe) {\n                    throw new JspTagException(ioe.toString());\n                }\n            }\n            return EVAL_PAGE;\n        }\n       \n       \n        if (s.equalsIgnoreCase(SECTION_MENU_STYLE)) {\n            try {\n                ExpandMenu.writeStyle(out, reqState);\n            } catch (IOException ioe) {\n                throw new JspTagException(ioe.toString());\n            }\n            return EVAL_PAGE;\n        }\n       \n        if (s.equalsIgnoreCase(SECTION_MENU_JAVASCRIPT)) {\n            try {\n                ExpandMenu.writeJavaScript(out, reqState);\n            } catch (IOException ioe) {\n                throw new JspTagException(ioe.toString());\n            }\n            return EVAL_PAGE;\n        }\n       \n        if (s.equalsIgnoreCase(SECTION_MENU)) {\n            try {\n                ExpandMenu.writeMenu(out, reqState, \n                    nul, tru, \n                    fals, ExpandMenu.DESC_LONG, fals);\n            } catch (IOException ioe) {\n                throw new JspTagException(ioe.toString());\n            }\n            return EVAL_PAGE;\n        }\n       \n       \n        if (s.equalsIgnoreCase(SECTION_CONTENT_CLASS_TABLE)) {\n            HTMLOutput content = (HTMLOutput)request.getAttribute(SECTION_CONTENT_BODY);\n            if (content != null) {\n                try {\n                    String tableClass = content.getTableClass();\n                    out.write(!StringTools.isBlank(tableClass)? tableClass : \"contentTableClass\");\n                } catch (IOException ioe) {\n                    throw new JspTagException(ioe.toString());\n                }\n            }\n            return EVAL_PAGE;\n        }\n       \n        if (s.equalsIgnoreCase(SECTION_CONTENT_CLASS_CELL)) {\n            HTMLOutput content = (HTMLOutput)request.getAttribute(SECTION_CONTENT_BODY);\n            if (content != null) {\n                try {\n                    String cellClass = content.getCellClass();\n                    out.write(!StringTools.isBlank(cellClass)? cellClass : \"contentCellClass\");\n                } catch (IOException ioe) {\n                    throw new JspTagException(ioe.toString());\n                }\n            }\n            return EVAL_PAGE;\n        }\n       \n        if (s.equalsIgnoreCase(SECTION_CONTENT_ID_MESSAGE)) {\n            try {\n                out.write(CommonServlet.ID_CONTENT_MESSAGE);\n            } catch (IOException ioe) {\n                throw new JspTagException(ioe.toString());\n            }\n            return EVAL_PAGE;\n        }\n       \n        if (s.equalsIgnoreCase(SECTION_CONTENT_CLASS_MESSAGE)) {\n            try {\n                out.write(CommonServlet.CSS_CONTENT_MESSAGE);\n            } catch (IOException ioe) {\n                throw new JspTagException(ioe.toString());\n            }\n            return EVAL_PAGE;\n        }\n       \n        if (s.equalsIgnoreCase(SECTION_CONTENT_MENUBAR)) {\n            HTMLOutput content = (HTMLOutput)request.getAttribute(SECTION_CONTENT_BODY);\n            if (content != null) {\n                String contentClass = content.getTableClass();\n                try {\n                    if (ListTools.contains(CommonServlet.CSS_MENUBAR_OK,contentClass)) {\n                        MenuBar.writeTableRow(out, reqState.getPageName(), reqState);\n                    } else {\n                        out.write(\"<!-- no menubar ['\"+contentClass+\"'] -->\");\n                    }\n                } catch (IOException ioe) {\n                    throw new JspTagException(ioe.toString());\n                }\n            }\n            return EVAL_PAGE;\n        }\n       \n        if (s.equalsIgnoreCase(SECTION_CONTENT_MESSAGE)) {\n            HTMLOutput content = (HTMLOutput)request.getAttribute(SECTION_CONTENT_BODY);\n            String msg = (content != null)? StringTools.trim(content.getTableMessage()) : \"\";\n            try {\n                out.write(msg);\n            } catch (IOException ioe) {\n                throw new JspTagException(ioe.toString());\n            }\n            return EVAL_PAGE;\n        }\n       \n       \n        if (s.equalsIgnoreCase(SECTION_REQUEST_CONTEXT)) {\n            try {\n                out.write(request.getContextPath());\n            } catch (IOException ioe) {\n                throw new JspTagException(ioe.toString());\n            }\n            return EVAL_PAGE;\n        }\n       \n       \n        if (s.equalsIgnoreCase(SECTION_CSSFILE)) {\n            String cssFilePath = this.getArg();\n            if (!StringTools.isBlank(cssFilePath)) {\n                try {\n                    PrintWriter pw = new PrintWriter(out, out.isAutoFlush());\n                    WebPageAdaptor.writeCssLink(pw, reqState, cssFilePath, null);\n                } catch (IOException ioe) {\n                    throw new JspTagException(ioe.toString());\n                }\n            }\n            return EVAL_PAGE;\n        }\n       \n       \n        if (s.equalsIgnoreCase(SECTION_BANNER_WIDTH)) {\n           \n            String kSfx = StringTools.trim(this.getArg());\n           \n            String bannerWidth = privLabel.getStringProperty(PrivateLabel.PROP_Banner_width   + kSfx, null);\n            if (StringTools.isBlank(bannerWidth)) {\n                bannerWidth = privLabel.getStringProperty(PrivateLabel.PROP_Banner_imageWidth + kSfx, null);\n            }\n           \n            if (StringTools.isBlank(bannerWidth)) {\n                bannerWidth = this.hasDefault()? this.getDefault() : \"100%\";\n            } else\n            if (!bannerWidth.endsWith(\"%\")) {\n                int W = StringTools.parseInt(bannerWidth, 0);\n                bannerWidth = String.valueOf((W < MIN_BANNER_WIDTH)? MIN_BANNER_WIDTH : W);\n            }\n           \n            try {\n                out.write(bannerWidth);\n            } catch (IOException ioe) {\n                throw new JspTagException(ioe.toString());\n            }\n            return EVAL_PAGE;\n        }\n       \n        if (s.equalsIgnoreCase(SECTION_BANNER_STYLE)) {\n           \n            String kSfx = StringTools.trim(this.getArg());\n           \n            String bannerStyle = privLabel.getStringProperty(PrivateLabel.PROP_Banner_style + kSfx, null);\n           \n            if (!StringTools.isBlank(bannerStyle)) {\n                try {\n                    out.write(bannerStyle);\n                } catch (IOException ioe) {\n                    throw new JspTagException(ioe.toString());\n                }\n            } else\n            if (this.hasDefault()) {\n                try {\n                    out.write(this.getDefault());\n                } catch (IOException ioe) {\n                    throw new JspTagException(ioe.toString());\n                }\n            }\n            return EVAL_PAGE;\n        }\n       \n        if (s.equalsIgnoreCase(SECTION_BANNER_IMAGE)) {\n           \n            String kSfx      = StringTools.trim(this.getArg());\n           \n            String imgLink   = privLabel.getStringProperty(PrivateLabel.PROP_Banner_imageLink   + kSfx, null);\n            String imgSrc    = privLabel.getStringProperty(PrivateLabel.PROP_Banner_imageSource + kSfx, null);\n            String imgWidth  = privLabel.getStringProperty(PrivateLabel.PROP_Banner_imageWidth  + kSfx, null);\n            String imgHeight = privLabel.getStringProperty(PrivateLabel.PROP_Banner_imageHeight + kSfx, null);\n           \n            if (!StringTools.isBlank(imgSrc)) {\n                StringBuffer sb = new StringBuffer();\n                if (!StringTools.isBlank(imgLink)) { \n                    sb.append(\"<a href='\").append(imgLink).append(\"' target='_blank'>\"); \n                }\n                sb.append(\"<img src='\").append(imgSrc).append(\"' border='0'\");\n                if (!StringTools.isBlank(imgWidth)) {\n                    sb.append(\" width='\").append(imgWidth).append(\"'\");\n                }\n                if (!StringTools.isBlank(imgHeight)) {\n                    sb.append(\" height='\").append(imgHeight).append(\"'\");\n                }\n                sb.append(\">\");\n                if (!StringTools.isBlank(imgLink)) {\n                    sb.append(\"<\/a>\");\n                }\n                try {\n                    out.write(sb.toString());\n                } catch (IOException ioe) {\n                    throw new JspTagException(ioe.toString());\n                }\n            } else\n            if (this.hasDefault()) {\n                try {\n                    out.write(this.getDefault());\n                } catch (IOException ioe) {\n                    throw new JspTagException(ioe.toString());\n                }\n            }\n            return EVAL_PAGE;\n        }\n       \n        if (s.equalsIgnoreCase(SECTION_BANNER_IMAGE_SOURCE)) {\n           \n            String kSfx      = StringTools.trim(this.getArg());\n           \n            String imgSrc    = privLabel.getStringProperty(PrivateLabel.PROP_Banner_imageSource + kSfx, null);\n           \n            if (!StringTools.isBlank(imgSrc)) {\n               \n                try {\n                    out.write(imgSrc);\n                } catch (IOException ioe) {\n                    throw new JspTagException(ioe.toString());\n                }\n            } else\n            if (this.hasDefault()) {\n               \n                try {\n                    out.write(this.getDefault());\n                } catch (IOException ioe) {\n                    throw new JspTagException(ioe.toString());\n                }\n            }\n            return EVAL_PAGE;\n        }\n       \n        if (s.equalsIgnoreCase(SECTION_BANNER_IMAGE_WIDTH)) {\n           \n            String kSfx      = StringTools.trim(this.getArg());\n           \n            String imgWidth  = privLabel.getStringProperty(PrivateLabel.PROP_Banner_imageWidth  + kSfx, null);\n           \n            if (!StringTools.isBlank(imgWidth)) {\n                try {\n                    out.write(imgWidth);\n                } catch (IOException ioe) {\n                    throw new JspTagException(ioe.toString());\n                }\n            } else\n            if (this.hasDefault()) {\n                try {\n                    out.write(this.getDefault());\n                } catch (IOException ioe) {\n                    throw new JspTagException(ioe.toString());\n                }\n            }\n            return EVAL_PAGE;\n        }\n       \n        if (s.equalsIgnoreCase(SECTION_BANNER_IMAGE_HEIGHT)) {\n           \n            String kSfx      = StringTools.trim(this.getArg());\n           \n            String imgHeight = privLabel.getStringProperty(PrivateLabel.PROP_Banner_imageHeight + kSfx, null);\n           \n            if (!StringTools.isBlank(imgHeight)) {\n                try {\n                    out.write(imgHeight);\n                } catch (IOException ioe) {\n                    throw new JspTagException(ioe.toString());\n                }\n            } else\n            if (this.hasDefault()) {\n                try {\n                    out.write(this.getDefault());\n                } catch (IOException ioe) {\n                    throw new JspTagException(ioe.toString());\n                }\n            }\n            return EVAL_PAGE;\n        }\n       \n       \n        if (s.equalsIgnoreCase(SECTION_JAVASCRIPT)) {\n            try {\n               \n                JavaScriptTools.writeUtilsJS(out, request);\n               \n                Object obj = request.getAttribute(SECTION_JAVASCRIPT);\n                if (obj instanceof HTMLOutput) {\n                    ((HTMLOutput)obj).write(out); \n                } else {\n                    out.write(\"<!-- Unexpected section type '\" + s + \"' [\" + StringTools.className(obj) + \"] -->\"); \n                }\n            } catch (IOException ioe) {\n                throw new JspTagException(ioe.toString());\n            }\n            return EVAL_PAGE;\n        }\n       \n       \n        if (s.equalsIgnoreCase(SECTION_PAGE_NAME)) {\n            String pageName = reqState.getPageName();\n            if (!StringTools.isBlank(pageName)) {\n                try {\n                    out.write(pageName);\n                } catch (IOException ioe) {\n                    throw new JspTagException(ioe.toString());\n                }\n            }\n            return EVAL_PAGE;\n        }\n       \n       \n        if (s.equalsIgnoreCase(SECTION_PAGE_URL)) {\n            String pageName = this.getArg();\n            String cmd      = null;\n            String cmdArg   = null;\n            WebPage wp = privLabel.getWebPage(pageName);\n            String url = (wp != null)? wp.encodePageURL(reqState,cmd,cmdArg) : null;\n            if (!StringTools.isBlank(url)) {\n                try {\n                    out.write(url);\n                } catch (IOException ioe) {\n                    throw new JspTagException(ioe.toString());\n                }\n            }\n            return EVAL_PAGE;\n        }\n       \n       \n        try {\n            Object obj = request.getAttribute(s);\n            if (obj == null) {\n                out.write(\"<!-- Undefined section '\" + s + \"' -->\"); \n            } else\n            if (obj instanceof HTMLOutput) {\n                ((HTMLOutput)obj).write(out); \n            } else {\n                out.write(\"<!-- Unexpected section type '\" + s + \"' [\" + StringTools.className(obj) + \"] -->\"); \n            }\n        } catch (IOException ioe) {\n            throw new JspTagException(ioe.toString());\n        }\n        return EVAL_PAGE;\n    }","cleancode":"public int doendtag() throws jsptagexception { httpservletrequest request = (httpservletrequest)super.pagecontext.getrequest(); requestproperties reqstate = (requestproperties)request.getattribute(section_requestprops); privatelabel privlabel = (reqstate != null)? reqstate.getprivatelabel() : requestproperties.nullprivatelabel; jspwriter out = super.pagecontext.getout(); string s = this.getsection().tolowercase(); if (stringtools.isblank(s)) { return eval_page; } if (!this.ismatch()) { return eval_page; } if (s.equalsignorecase(section_body_onload)) { string bodyonload = (string)request.getattribute(section_body_onload); if (!stringtools.isblank(bodyonload)) { try { out.print(bodyonload); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } } return eval_page; } if (s.equalsignorecase(section_body_onunload)) { string bodyonunload = (string)request.getattribute(section_body_onunload); if (!stringtools.isblank(bodyonunload)) { try { out.print(bodyonunload); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } } return eval_page; } if (s.equalsignorecase(section_menu_style)) { try { expandmenu.writestyle(out, reqstate); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } return eval_page; } if (s.equalsignorecase(section_menu_javascript)) { try { expandmenu.writejavascript(out, reqstate); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } return eval_page; } if (s.equalsignorecase(section_menu)) { try { expandmenu.writemenu(out, reqstate, nul, tru, fals, expandmenu.desc_long, fals); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } return eval_page; } if (s.equalsignorecase(section_content_class_table)) { htmloutput content = (htmloutput)request.getattribute(section_content_body); if (content != null) { try { string tableclass = content.gettableclass(); out.write(!stringtools.isblank(tableclass)? tableclass : \"contenttableclass\"); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } } return eval_page; } if (s.equalsignorecase(section_content_class_cell)) { htmloutput content = (htmloutput)request.getattribute(section_content_body); if (content != null) { try { string cellclass = content.getcellclass(); out.write(!stringtools.isblank(cellclass)? cellclass : \"contentcellclass\"); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } } return eval_page; } if (s.equalsignorecase(section_content_id_message)) { try { out.write(commonservlet.id_content_message); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } return eval_page; } if (s.equalsignorecase(section_content_class_message)) { try { out.write(commonservlet.css_content_message); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } return eval_page; } if (s.equalsignorecase(section_content_menubar)) { htmloutput content = (htmloutput)request.getattribute(section_content_body); if (content != null) { string contentclass = content.gettableclass(); try { if (listtools.contains(commonservlet.css_menubar_ok,contentclass)) { menubar.writetablerow(out, reqstate.getpagename(), reqstate); } else { out.write(\"<!-- no menubar ['\"+contentclass+\"'] -->\"); } } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } } return eval_page; } if (s.equalsignorecase(section_content_message)) { htmloutput content = (htmloutput)request.getattribute(section_content_body); string msg = (content != null)? stringtools.trim(content.gettablemessage()) : \"\"; try { out.write(msg); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } return eval_page; } if (s.equalsignorecase(section_request_context)) { try { out.write(request.getcontextpath()); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } return eval_page; } if (s.equalsignorecase(section_cssfile)) { string cssfilepath = this.getarg(); if (!stringtools.isblank(cssfilepath)) { try { printwriter pw = new printwriter(out, out.isautoflush()); webpageadaptor.writecsslink(pw, reqstate, cssfilepath, null); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } } return eval_page; } if (s.equalsignorecase(section_banner_width)) { string ksfx = stringtools.trim(this.getarg()); string bannerwidth = privlabel.getstringproperty(privatelabel.prop_banner_width + ksfx, null); if (stringtools.isblank(bannerwidth)) { bannerwidth = privlabel.getstringproperty(privatelabel.prop_banner_imagewidth + ksfx, null); } if (stringtools.isblank(bannerwidth)) { bannerwidth = this.hasdefault()? this.getdefault() : \"100%\"; } else if (!bannerwidth.endswith(\"%\")) { int w = stringtools.parseint(bannerwidth, 0); bannerwidth = string.valueof((w < min_banner_width)? min_banner_width : w); } try { out.write(bannerwidth); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } return eval_page; } if (s.equalsignorecase(section_banner_style)) { string ksfx = stringtools.trim(this.getarg()); string bannerstyle = privlabel.getstringproperty(privatelabel.prop_banner_style + ksfx, null); if (!stringtools.isblank(bannerstyle)) { try { out.write(bannerstyle); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } } else if (this.hasdefault()) { try { out.write(this.getdefault()); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } } return eval_page; } if (s.equalsignorecase(section_banner_image)) { string ksfx = stringtools.trim(this.getarg()); string imglink = privlabel.getstringproperty(privatelabel.prop_banner_imagelink + ksfx, null); string imgsrc = privlabel.getstringproperty(privatelabel.prop_banner_imagesource + ksfx, null); string imgwidth = privlabel.getstringproperty(privatelabel.prop_banner_imagewidth + ksfx, null); string imgheight = privlabel.getstringproperty(privatelabel.prop_banner_imageheight + ksfx, null); if (!stringtools.isblank(imgsrc)) { stringbuffer sb = new stringbuffer(); if (!stringtools.isblank(imglink)) { sb.append(\"<a href='\").append(imglink).append(\"' target='_blank'>\"); } sb.append(\"<img src='\").append(imgsrc).append(\"' border='0'\"); if (!stringtools.isblank(imgwidth)) { sb.append(\" width='\").append(imgwidth).append(\"'\"); } if (!stringtools.isblank(imgheight)) { sb.append(\" height='\").append(imgheight).append(\"'\"); } sb.append(\">\"); if (!stringtools.isblank(imglink)) { sb.append(\"<\/a>\"); } try { out.write(sb.tostring()); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } } else if (this.hasdefault()) { try { out.write(this.getdefault()); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } } return eval_page; } if (s.equalsignorecase(section_banner_image_source)) { string ksfx = stringtools.trim(this.getarg()); string imgsrc = privlabel.getstringproperty(privatelabel.prop_banner_imagesource + ksfx, null); if (!stringtools.isblank(imgsrc)) { try { out.write(imgsrc); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } } else if (this.hasdefault()) { try { out.write(this.getdefault()); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } } return eval_page; } if (s.equalsignorecase(section_banner_image_width)) { string ksfx = stringtools.trim(this.getarg()); string imgwidth = privlabel.getstringproperty(privatelabel.prop_banner_imagewidth + ksfx, null); if (!stringtools.isblank(imgwidth)) { try { out.write(imgwidth); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } } else if (this.hasdefault()) { try { out.write(this.getdefault()); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } } return eval_page; } if (s.equalsignorecase(section_banner_image_height)) { string ksfx = stringtools.trim(this.getarg()); string imgheight = privlabel.getstringproperty(privatelabel.prop_banner_imageheight + ksfx, null); if (!stringtools.isblank(imgheight)) { try { out.write(imgheight); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } } else if (this.hasdefault()) { try { out.write(this.getdefault()); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } } return eval_page; } if (s.equalsignorecase(section_javascript)) { try { javascripttools.writeutilsjs(out, request); object obj = request.getattribute(section_javascript); if (obj instanceof htmloutput) { ((htmloutput)obj).write(out); } else { out.write(\"<!-- unexpected section type '\" + s + \"' [\" + stringtools.classname(obj) + \"] -->\"); } } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } return eval_page; } if (s.equalsignorecase(section_page_name)) { string pagename = reqstate.getpagename(); if (!stringtools.isblank(pagename)) { try { out.write(pagename); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } } return eval_page; } if (s.equalsignorecase(section_page_url)) { string pagename = this.getarg(); string cmd = null; string cmdarg = null; webpage wp = privlabel.getwebpage(pagename); string url = (wp != null)? wp.encodepageurl(reqstate,cmd,cmdarg) : null; if (!stringtools.isblank(url)) { try { out.write(url); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } } return eval_page; } try { object obj = request.getattribute(s); if (obj == null) { out.write(\"<!-- undefined section '\" + s + \"' -->\"); } else if (obj instanceof htmloutput) { ((htmloutput)obj).write(out); } else { out.write(\"<!-- unexpected section type '\" + s + \"' [\" + stringtools.classname(obj) + \"] -->\"); } } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } return eval_page; }","comment":"\/* ignore blank section definitions *\/\n\/\/ -- ignore\n\/* not a match? *\/\n\/\/ -- ignore\n\/\/ -------------------------------------------------------------------- \/* \"onload='...'\" *\/\n\/* \"onunload='...'\" *\/\n\/\/ -------------------------------------------------------------------- \/* expandmenu style *\/\n\/* expandmenu javascript *\/\n\/* expandmenu *\/\n\/*menuid*\/\n\/*expandablemenu*\/\n\/*showicon*\/\n\/*showmenuhelp*\/\n\/\/ -------------------------------------------------------------------- \/* content table class *\/\n\/* content cell class *\/\n\/* content message id *\/\n\/* content message class *\/\n\/* content menubar *\/\n\/* content message *\/\n\/\/ todo: html encode?\n\/\/ -------------------------------------------------------------------- \/* request context path *\/\n\/\/ -------------------------------------------------------------------- \/* css file *\/\n\/\/ -------------------------------------------------------------------- \/* banner image height *\/\n\/\/ key suffix\n\/\/ property values\n\/\/ minimum valie\n\/\/ generate html\n\/* banner style *\/\n\/\/ key suffix\n\/\/ property values\n\/\/ generate html\n\/* banner image *\/\n\/\/ key suffix\n\/\/ property values\n\/\/ generate html\n\/* banner image *\/\n\/\/ key suffix\n\/\/ property values\n\/\/ generate html\n\/\/print.sysprintln(\"property image source: \" + imgsrc);\n\/\/print.sysprintln(\"default image source: \" + this.getdefault());\n\/* banner image height *\/\n\/\/ key suffix\n\/\/ property values\n\/\/ generate html\n\/* banner image height *\/\n\/\/ key suffix\n\/\/ property values\n\/\/ generate html\n\/\/ -------------------------------------------------------------------- \/* javascript *\/\n\/\/ always write \"utils.js\"\n\/\/ check for other javascript\n\/\/ -------------------------------------------------------------------- \/* current page name *\/\n\/\/ \"pagename\"\n\/\/ -------------------------------------------------------------------- \/* page url *\/\n\/\/ \"pageurl\"\n\/\/ -------------------------------------------------------------------- \/* htmloutput *\/","repo":"paragp\/GTS-PreUAT","code_context_2":"JspWriter out = super.pageContext.getOut();\nString s = this.getSection().toLowerCase();\n\/* ignore blank section definitions *\/\nif (StringTools.isBlank(s)) {\n\/\/ -- ignore\n\n\/* ignore blank section definitions *\/\nif (StringTools.isBlank(s)) {\n\/\/ -- ignore\nreturn EVAL_PAGE;\n}\n\nreturn EVAL_PAGE;\n}\n\/* not a match? *\/\nif (!this.isMatch()) {\n\/\/ -- ignore\n\n\/* ignore blank section definitions *\/\nif (StringTools.isBlank(s)) {\n\/\/ -- ignore\nreturn EVAL_PAGE;\n}\n\nreturn EVAL_PAGE;\n}\n\/\/ --------------------------------------------------------------------\n\/* \"onload='...'\" *\/\nif (s.equalsIgnoreCase(SECTION_BODY_ONLOAD)) {\nString bodyOnLoad = (String)request.getAttribute(SECTION_BODY_ONLOAD);\n\nreturn EVAL_PAGE;\n}\n\/* \"onunload='...'\" *\/\nif (s.equalsIgnoreCase(SECTION_BODY_ONUNLOAD)) {\nString bodyOnUnload = (String)request.getAttribute(SECTION_BODY_ONUNLOAD);\n\nreturn EVAL_PAGE;\n}\n\/\/ --------------------------------------------------------------------\n\/* \"onload='...'\" *\/\nif (s.equalsIgnoreCase(SECTION_BODY_ONLOAD)) {\nString bodyOnLoad = (String)request.getAttribute(SECTION_BODY_ONLOAD);\n\nreturn EVAL_PAGE;\n}\n\/* expandMenu javascript *\/\nif (s.equalsIgnoreCase(SECTION_MENU_JAVASCRIPT)) {\ntry {\n\nreturn EVAL_PAGE;\n}\n\/* expandMenu *\/\nif (s.equalsIgnoreCase(SECTION_MENU)) {\ntry {\n\ntry {\nExpandMenu.writeMenu(out, reqState,\nnull\/*menuID*\/, true\/*expandableMenu*\/,\nfalse\/*showIcon*\/, ExpandMenu.DESC_LONG, false\/*showMenuHelp*\/);\n} catch (IOException ioe) {\n\ntry {\nExpandMenu.writeMenu(out, reqState,\nnull\/*menuID*\/, true\/*expandableMenu*\/,\nfalse\/*showIcon*\/, ExpandMenu.DESC_LONG, false\/*showMenuHelp*\/);\n} catch (IOException ioe) {\n\nExpandMenu.writeMenu(out, reqState,\nnull\/*menuID*\/, true\/*expandableMenu*\/,\nfalse\/*showIcon*\/, ExpandMenu.DESC_LONG, false\/*showMenuHelp*\/);\n} catch (IOException ioe) {\nthrow new JspTagException(ioe.toString());\n\nExpandMenu.writeMenu(out, reqState,\nnull\/*menuID*\/, true\/*expandableMenu*\/,\nfalse\/*showIcon*\/, ExpandMenu.DESC_LONG, false\/*showMenuHelp*\/);\n} catch (IOException ioe) {\nthrow new JspTagException(ioe.toString());\n\nreturn EVAL_PAGE;\n}\n\/\/ --------------------------------------------------------------------\n\/* \"onload='...'\" *\/\nif (s.equalsIgnoreCase(SECTION_BODY_ONLOAD)) {\nString bodyOnLoad = (String)request.getAttribute(SECTION_BODY_ONLOAD);\n\nreturn EVAL_PAGE;\n}\n\/* content cell class *\/\nif (s.equalsIgnoreCase(SECTION_CONTENT_CLASS_CELL)) {\nHTMLOutput content = (HTMLOutput)request.getAttribute(SECTION_CONTENT_BODY);\n\nreturn EVAL_PAGE;\n}\n\/* content message id *\/\nif (s.equalsIgnoreCase(SECTION_CONTENT_ID_MESSAGE)) {\ntry {\n\nreturn EVAL_PAGE;\n}\n\/* content message class *\/\nif (s.equalsIgnoreCase(SECTION_CONTENT_CLASS_MESSAGE)) {\ntry {\n\nreturn EVAL_PAGE;\n}\n\/* content menubar *\/\nif (s.equalsIgnoreCase(SECTION_CONTENT_MENUBAR)) {\nHTMLOutput content = (HTMLOutput)request.getAttribute(SECTION_CONTENT_BODY);\n\nreturn EVAL_PAGE;\n}\n\/* content message *\/\nif (s.equalsIgnoreCase(SECTION_CONTENT_MESSAGE)) {\nHTMLOutput content = (HTMLOutput)request.getAttribute(SECTION_CONTENT_BODY);\n\nString msg = (content != null)? StringTools.trim(content.getTableMessage()) : \"\";\ntry {\nout.write(msg); \/\/ TODO: HTML encode?\n} catch (IOException ioe) {\nthrow new JspTagException(ioe.toString());\n\nreturn EVAL_PAGE;\n}\n\/\/ --------------------------------------------------------------------\n\/* \"onload='...'\" *\/\nif (s.equalsIgnoreCase(SECTION_BODY_ONLOAD)) {\nString bodyOnLoad = (String)request.getAttribute(SECTION_BODY_ONLOAD);\n\nreturn EVAL_PAGE;\n}\n\/\/ --------------------------------------------------------------------\n\/* \"onload='...'\" *\/\nif (s.equalsIgnoreCase(SECTION_BODY_ONLOAD)) {\nString bodyOnLoad = (String)request.getAttribute(SECTION_BODY_ONLOAD);\n\nreturn EVAL_PAGE;\n}\n\/\/ --------------------------------------------------------------------\n\/* \"onload='...'\" *\/\nif (s.equalsIgnoreCase(SECTION_BODY_ONLOAD)) {\nString bodyOnLoad = (String)request.getAttribute(SECTION_BODY_ONLOAD);\n\n\/* Banner Image Height *\/\nif (s.equalsIgnoreCase(SECTION_BANNER_WIDTH)) {\n\/\/ key suffix\nString kSfx = StringTools.trim(this.getArg());\n\/\/ property values\n\n\/\/ key suffix\nString kSfx = StringTools.trim(this.getArg());\n\/\/ property values\nString bannerWidth = privLabel.getStringProperty(PrivateLabel.PROP_Banner_width + kSfx, null);\nif (StringTools.isBlank(bannerWidth)) {\n\nbannerWidth = privLabel.getStringProperty(PrivateLabel.PROP_Banner_imageWidth + kSfx, null);\n}\n\/\/ minimum valie\nif (StringTools.isBlank(bannerWidth)) {\nbannerWidth = this.hasDefault()? this.getDefault() : \"100%\";\n\nbannerWidth = String.valueOf((W < MIN_BANNER_WIDTH)? MIN_BANNER_WIDTH : W);\n}\n\/\/ generate html\ntry {\nout.write(bannerWidth);\n\nreturn EVAL_PAGE;\n}\n\/* Banner Style *\/\nif (s.equalsIgnoreCase(SECTION_BANNER_STYLE)) {\n\/\/ key suffix\n\n\/* Banner Image Height *\/\nif (s.equalsIgnoreCase(SECTION_BANNER_WIDTH)) {\n\/\/ key suffix\nString kSfx = StringTools.trim(this.getArg());\n\/\/ property values\n\n\/\/ key suffix\nString kSfx = StringTools.trim(this.getArg());\n\/\/ property values\nString bannerWidth = privLabel.getStringProperty(PrivateLabel.PROP_Banner_width + kSfx, null);\nif (StringTools.isBlank(bannerWidth)) {\n\nbannerWidth = String.valueOf((W < MIN_BANNER_WIDTH)? MIN_BANNER_WIDTH : W);\n}\n\/\/ generate html\ntry {\nout.write(bannerWidth);\n\nreturn EVAL_PAGE;\n}\n\/* Banner Image *\/\nif (s.equalsIgnoreCase(SECTION_BANNER_IMAGE)) {\n\/\/ key suffix\n\n\/* Banner Image Height *\/\nif (s.equalsIgnoreCase(SECTION_BANNER_WIDTH)) {\n\/\/ key suffix\nString kSfx = StringTools.trim(this.getArg());\n\/\/ property values\n\n\/\/ key suffix\nString kSfx = StringTools.trim(this.getArg());\n\/\/ property values\nString bannerWidth = privLabel.getStringProperty(PrivateLabel.PROP_Banner_width + kSfx, null);\nif (StringTools.isBlank(bannerWidth)) {\n\nbannerWidth = String.valueOf((W < MIN_BANNER_WIDTH)? MIN_BANNER_WIDTH : W);\n}\n\/\/ generate html\ntry {\nout.write(bannerWidth);\n\nreturn EVAL_PAGE;\n}\n\/* Banner Image *\/\nif (s.equalsIgnoreCase(SECTION_BANNER_IMAGE)) {\n\/\/ key suffix\n\n\/* Banner Image Height *\/\nif (s.equalsIgnoreCase(SECTION_BANNER_WIDTH)) {\n\/\/ key suffix\nString kSfx = StringTools.trim(this.getArg());\n\/\/ property values\n\n\/\/ key suffix\nString kSfx = StringTools.trim(this.getArg());\n\/\/ property values\nString bannerWidth = privLabel.getStringProperty(PrivateLabel.PROP_Banner_width + kSfx, null);\nif (StringTools.isBlank(bannerWidth)) {\n\nbannerWidth = String.valueOf((W < MIN_BANNER_WIDTH)? MIN_BANNER_WIDTH : W);\n}\n\/\/ generate html\ntry {\nout.write(bannerWidth);\n\n\/\/ generate html\nif (!StringTools.isBlank(imgSrc)) {\n\/\/Print.sysPrintln(\"Property Image Source: \" + imgSrc);\ntry {\nout.write(imgSrc);\n\n} else\nif (this.hasDefault()) {\n\/\/Print.sysPrintln(\"Default Image Source: \" + this.getDefault());\ntry {\nout.write(this.getDefault());\n\n}\n\/\/ --------------------------------------------------------------------\n\/* Banner Image Height *\/\nif (s.equalsIgnoreCase(SECTION_BANNER_WIDTH)) {\n\/\/ key suffix\n\n\/* Banner Image Height *\/\nif (s.equalsIgnoreCase(SECTION_BANNER_WIDTH)) {\n\/\/ key suffix\nString kSfx = StringTools.trim(this.getArg());\n\/\/ property values\n\n\/\/ key suffix\nString kSfx = StringTools.trim(this.getArg());\n\/\/ property values\nString bannerWidth = privLabel.getStringProperty(PrivateLabel.PROP_Banner_width + kSfx, null);\nif (StringTools.isBlank(bannerWidth)) {\n\nbannerWidth = String.valueOf((W < MIN_BANNER_WIDTH)? MIN_BANNER_WIDTH : W);\n}\n\/\/ generate html\ntry {\nout.write(bannerWidth);\n\n}\n\/\/ --------------------------------------------------------------------\n\/* Banner Image Height *\/\nif (s.equalsIgnoreCase(SECTION_BANNER_WIDTH)) {\n\/\/ key suffix\n\n\/* Banner Image Height *\/\nif (s.equalsIgnoreCase(SECTION_BANNER_WIDTH)) {\n\/\/ key suffix\nString kSfx = StringTools.trim(this.getArg());\n\/\/ property values\n\n\/\/ key suffix\nString kSfx = StringTools.trim(this.getArg());\n\/\/ property values\nString bannerWidth = privLabel.getStringProperty(PrivateLabel.PROP_Banner_width + kSfx, null);\nif (StringTools.isBlank(bannerWidth)) {\n\nbannerWidth = String.valueOf((W < MIN_BANNER_WIDTH)? MIN_BANNER_WIDTH : W);\n}\n\/\/ generate html\ntry {\nout.write(bannerWidth);\n\nreturn EVAL_PAGE;\n}\n\/\/ --------------------------------------------------------------------\n\/* \"onload='...'\" *\/\nif (s.equalsIgnoreCase(SECTION_BODY_ONLOAD)) {\nString bodyOnLoad = (String)request.getAttribute(SECTION_BODY_ONLOAD);\n\nif (s.equalsIgnoreCase(SECTION_JAVASCRIPT)) {\ntry {\n\/\/ always write \"utils.js\"\nJavaScriptTools.writeUtilsJS(out, request);\n\/\/ check for other javascript\n\n\/\/ always write \"utils.js\"\nJavaScriptTools.writeUtilsJS(out, request);\n\/\/ check for other javascript\nObject obj = request.getAttribute(SECTION_JAVASCRIPT);\nif (obj instanceof HTMLOutput) {\n\nreturn EVAL_PAGE;\n}\n\/\/ --------------------------------------------------------------------\n\/* \"onload='...'\" *\/\nif (s.equalsIgnoreCase(SECTION_BODY_ONLOAD)) {\nString bodyOnLoad = (String)request.getAttribute(SECTION_BODY_ONLOAD);\n\n\/\/ --------------------------------------------------------------------\n\/* current page name *\/\nif (s.equalsIgnoreCase(SECTION_PAGE_NAME)) { \/\/ \"pagename\"\nString pageName = reqState.getPageName();\nif (!StringTools.isBlank(pageName)) {\n\nreturn EVAL_PAGE;\n}\n\/\/ --------------------------------------------------------------------\n\/* \"onload='...'\" *\/\nif (s.equalsIgnoreCase(SECTION_BODY_ONLOAD)) {\nString bodyOnLoad = (String)request.getAttribute(SECTION_BODY_ONLOAD);\n\n\/\/ --------------------------------------------------------------------\n\/* Page URL *\/\nif (s.equalsIgnoreCase(SECTION_PAGE_URL)) { \/\/ \"pageurl\"\nString pageName = this.getArg();\nString cmd = null;\n\nreturn EVAL_PAGE;\n}\n\/\/ --------------------------------------------------------------------\n\/* \"onload='...'\" *\/\nif (s.equalsIgnoreCase(SECTION_BODY_ONLOAD)) {\nString bodyOnLoad = (String)request.getAttribute(SECTION_BODY_ONLOAD);","code_context_10":"public int doEndTag()\nthrows JspTagException\n{\nHttpServletRequest request = (HttpServletRequest)super.pageContext.getRequest();\nRequestProperties reqState = (RequestProperties)request.getAttribute(SECTION_REQUESTPROPS);\nPrivateLabel privLabel = (reqState != null)? reqState.getPrivateLabel() : RequestProperties.NullPrivateLabel;\nJspWriter out = super.pageContext.getOut();\nString s = this.getSection().toLowerCase();\n\/* ignore blank section definitions *\/\nif (StringTools.isBlank(s)) {\n\/\/ -- ignore\nreturn EVAL_PAGE;\n}\n\/* not a match? *\/\nif (!this.isMatch()) {\n\/\/ -- ignore\nreturn EVAL_PAGE;\n}\n\/\/ --------------------------------------------------------------------\n\npublic int doEndTag()\nthrows JspTagException\n{\nHttpServletRequest request = (HttpServletRequest)super.pageContext.getRequest();\nRequestProperties reqState = (RequestProperties)request.getAttribute(SECTION_REQUESTPROPS);\nPrivateLabel privLabel = (reqState != null)? reqState.getPrivateLabel() : RequestProperties.NullPrivateLabel;\nJspWriter out = super.pageContext.getOut();\nString s = this.getSection().toLowerCase();\n\/* ignore blank section definitions *\/\nif (StringTools.isBlank(s)) {\n\/\/ -- ignore\nreturn EVAL_PAGE;\n}\n\/* not a match? *\/\nif (!this.isMatch()) {\n\/\/ -- ignore\nreturn EVAL_PAGE;\n}\n\/\/ --------------------------------------------------------------------\n\/* \"onload='...'\" *\/\nif (s.equalsIgnoreCase(SECTION_BODY_ONLOAD)) {\n\nHttpServletRequest request = (HttpServletRequest)super.pageContext.getRequest();\nRequestProperties reqState = (RequestProperties)request.getAttribute(SECTION_REQUESTPROPS);\nPrivateLabel privLabel = (reqState != null)? reqState.getPrivateLabel() : RequestProperties.NullPrivateLabel;\nJspWriter out = super.pageContext.getOut();\nString s = this.getSection().toLowerCase();\n\/* ignore blank section definitions *\/\nif (StringTools.isBlank(s)) {\n\/\/ -- ignore\nreturn EVAL_PAGE;\n}\n\/* not a match? *\/\nif (!this.isMatch()) {\n\/\/ -- ignore\nreturn EVAL_PAGE;\n}\n\/\/ --------------------------------------------------------------------\n\/* \"onload='...'\" *\/\nif (s.equalsIgnoreCase(SECTION_BODY_ONLOAD)) {\nString bodyOnLoad = (String)request.getAttribute(SECTION_BODY_ONLOAD);\nif (!StringTools.isBlank(bodyOnLoad)) {\ntry {\n\npublic int doEndTag()\nthrows JspTagException\n{\nHttpServletRequest request = (HttpServletRequest)super.pageContext.getRequest();\nRequestProperties reqState = (RequestProperties)request.getAttribute(SECTION_REQUESTPROPS);\nPrivateLabel privLabel = (reqState != null)? reqState.getPrivateLabel() : RequestProperties.NullPrivateLabel;\nJspWriter out = super.pageContext.getOut();\nString s = this.getSection().toLowerCase();\n\/* ignore blank section definitions *\/\nif (StringTools.isBlank(s)) {\n\/\/ -- ignore\nreturn EVAL_PAGE;\n}\n\/* not a match? *\/\nif (!this.isMatch()) {\n\/\/ -- ignore\nreturn EVAL_PAGE;\n}\n\/\/ --------------------------------------------------------------------\n\/* \"onload='...'\" *\/\nif (s.equalsIgnoreCase(SECTION_BODY_ONLOAD)) {\n\n\/* ignore blank section definitions *\/\nif (StringTools.isBlank(s)) {\n\/\/ -- ignore\nreturn EVAL_PAGE;\n}\n\/* not a match? *\/\nif (!this.isMatch()) {\n\/\/ -- ignore\nreturn EVAL_PAGE;\n}\n\/\/ --------------------------------------------------------------------\n\/* \"onload='...'\" *\/\nif (s.equalsIgnoreCase(SECTION_BODY_ONLOAD)) {\nString bodyOnLoad = (String)request.getAttribute(SECTION_BODY_ONLOAD);\nif (!StringTools.isBlank(bodyOnLoad)) {\ntry {\nout.print(bodyOnLoad);\n} catch (IOException ioe) {\nthrow new JspTagException(ioe.toString());\n}\n}\nreturn EVAL_PAGE;\n\nString bodyOnLoad = (String)request.getAttribute(SECTION_BODY_ONLOAD);\nif (!StringTools.isBlank(bodyOnLoad)) {\ntry {\nout.print(bodyOnLoad);\n} catch (IOException ioe) {\nthrow new JspTagException(ioe.toString());\n}\n}\nreturn EVAL_PAGE;\n}\n\/* \"onunload='...'\" *\/\nif (s.equalsIgnoreCase(SECTION_BODY_ONUNLOAD)) {\nString bodyOnUnload = (String)request.getAttribute(SECTION_BODY_ONUNLOAD);\nif (!StringTools.isBlank(bodyOnUnload)) {\ntry {\nout.print(bodyOnUnload);\n} catch (IOException ioe) {\nthrow new JspTagException(ioe.toString());\n}\n}\nreturn EVAL_PAGE;\n\n\/* ignore blank section definitions *\/\nif (StringTools.isBlank(s)) {\n\/\/ -- ignore\nreturn EVAL_PAGE;\n}\n\/* not a match? *\/\nif (!this.isMatch()) {\n\/\/ -- ignore\nreturn EVAL_PAGE;\n}\n\/\/ --------------------------------------------------------------------\n\/* \"onload='...'\" *\/\nif (s.equalsIgnoreCase(SECTION_BODY_ONLOAD)) {\nString bodyOnLoad = (String)request.getAttribute(SECTION_BODY_ONLOAD);\nif (!StringTools.isBlank(bodyOnLoad)) {\ntry {\nout.print(bodyOnLoad);\n} catch (IOException ioe) {\nthrow new JspTagException(ioe.toString());\n}\n}\nreturn EVAL_PAGE;\n\n\/\/ --------------------------------------------------------------------\n\/* expandMenu style *\/\nif (s.equalsIgnoreCase(SECTION_MENU_STYLE)) {\ntry {\nExpandMenu.writeStyle(out, reqState);\n} catch (IOException ioe) {\nthrow new JspTagException(ioe.toString());\n}\nreturn EVAL_PAGE;\n}\n\/* expandMenu javascript *\/\nif (s.equalsIgnoreCase(SECTION_MENU_JAVASCRIPT)) {\ntry {\nExpandMenu.writeJavaScript(out, reqState);\n} catch (IOException ioe) {\nthrow new JspTagException(ioe.toString());\n}\nreturn EVAL_PAGE;\n}\n\/* expandMenu *\/\nif (s.equalsIgnoreCase(SECTION_MENU)) {\n\n}\n\/* expandMenu javascript *\/\nif (s.equalsIgnoreCase(SECTION_MENU_JAVASCRIPT)) {\ntry {\nExpandMenu.writeJavaScript(out, reqState);\n} catch (IOException ioe) {\nthrow new JspTagException(ioe.toString());\n}\nreturn EVAL_PAGE;\n}\n\/* expandMenu *\/\nif (s.equalsIgnoreCase(SECTION_MENU)) {\ntry {\nExpandMenu.writeMenu(out, reqState,\nnull\/*menuID*\/, true\/*expandableMenu*\/,\nfalse\/*showIcon*\/, ExpandMenu.DESC_LONG, false\/*showMenuHelp*\/);\n} catch (IOException ioe) {\nthrow new JspTagException(ioe.toString());\n}\nreturn EVAL_PAGE;\n}\n\nExpandMenu.writeJavaScript(out, reqState);\n} catch (IOException ioe) {\nthrow new JspTagException(ioe.toString());\n}\nreturn EVAL_PAGE;\n}\n\/* expandMenu *\/\nif (s.equalsIgnoreCase(SECTION_MENU)) {\ntry {\nExpandMenu.writeMenu(out, reqState,\nnull\/*menuID*\/, true\/*expandableMenu*\/,\nfalse\/*showIcon*\/, ExpandMenu.DESC_LONG, false\/*showMenuHelp*\/);\n} catch (IOException ioe) {\nthrow new JspTagException(ioe.toString());\n}\nreturn EVAL_PAGE;\n}\n\/\/ --------------------------------------------------------------------\n\/* content table class *\/\nif (s.equalsIgnoreCase(SECTION_CONTENT_CLASS_TABLE)) {\nHTMLOutput content = (HTMLOutput)request.getAttribute(SECTION_CONTENT_BODY);\n\nExpandMenu.writeJavaScript(out, reqState);\n} catch (IOException ioe) {\nthrow new JspTagException(ioe.toString());\n}\nreturn EVAL_PAGE;\n}\n\/* expandMenu *\/\nif (s.equalsIgnoreCase(SECTION_MENU)) {\ntry {\nExpandMenu.writeMenu(out, reqState,\nnull\/*menuID*\/, true\/*expandableMenu*\/,\nfalse\/*showIcon*\/, ExpandMenu.DESC_LONG, false\/*showMenuHelp*\/);\n} catch (IOException ioe) {\nthrow new JspTagException(ioe.toString());\n}\nreturn EVAL_PAGE;\n}\n\/\/ --------------------------------------------------------------------\n\/* content table class *\/\nif (s.equalsIgnoreCase(SECTION_CONTENT_CLASS_TABLE)) {\nHTMLOutput content = (HTMLOutput)request.getAttribute(SECTION_CONTENT_BODY);\n\n} catch (IOException ioe) {\nthrow new JspTagException(ioe.toString());\n}\nreturn EVAL_PAGE;\n}\n\/* expandMenu *\/\nif (s.equalsIgnoreCase(SECTION_MENU)) {\ntry {\nExpandMenu.writeMenu(out, reqState,\nnull\/*menuID*\/, true\/*expandableMenu*\/,\nfalse\/*showIcon*\/, ExpandMenu.DESC_LONG, false\/*showMenuHelp*\/);\n} catch (IOException ioe) {\nthrow new JspTagException(ioe.toString());\n}\nreturn EVAL_PAGE;\n}\n\/\/ --------------------------------------------------------------------\n\/* content table class *\/\nif (s.equalsIgnoreCase(SECTION_CONTENT_CLASS_TABLE)) {\nHTMLOutput content = (HTMLOutput)request.getAttribute(SECTION_CONTENT_BODY);\nif (content != null) {\n\n} catch (IOException ioe) {\nthrow new JspTagException(ioe.toString());\n}\nreturn EVAL_PAGE;\n}\n\/* expandMenu *\/\nif (s.equalsIgnoreCase(SECTION_MENU)) {\ntry {\nExpandMenu.writeMenu(out, reqState,\nnull\/*menuID*\/, true\/*expandableMenu*\/,\nfalse\/*showIcon*\/, ExpandMenu.DESC_LONG, false\/*showMenuHelp*\/);\n} catch (IOException ioe) {\nthrow new JspTagException(ioe.toString());\n}\nreturn EVAL_PAGE;\n}\n\/\/ --------------------------------------------------------------------\n\/* content table class *\/\nif (s.equalsIgnoreCase(SECTION_CONTENT_CLASS_TABLE)) {\nHTMLOutput content = (HTMLOutput)request.getAttribute(SECTION_CONTENT_BODY);\nif (content != null) {\n\n\/* ignore blank section definitions *\/\nif (StringTools.isBlank(s)) {\n\/\/ -- ignore\nreturn EVAL_PAGE;\n}\n\/* not a match? *\/\nif (!this.isMatch()) {\n\/\/ -- ignore\nreturn EVAL_PAGE;\n}\n\/\/ --------------------------------------------------------------------\n\/* \"onload='...'\" *\/\nif (s.equalsIgnoreCase(SECTION_BODY_ONLOAD)) {\nString bodyOnLoad = (String)request.getAttribute(SECTION_BODY_ONLOAD);\nif (!StringTools.isBlank(bodyOnLoad)) {\ntry {\nout.print(bodyOnLoad);\n} catch (IOException ioe) {\nthrow new JspTagException(ioe.toString());\n}\n}\nreturn EVAL_PAGE;\n\nif (content != null) {\ntry {\nString tableClass = content.getTableClass();\nout.write(!StringTools.isBlank(tableClass)? tableClass : \"contentTableClass\");\n} catch (IOException ioe) {\nthrow new JspTagException(ioe.toString());\n}\n}\nreturn EVAL_PAGE;\n}\n\/* content cell class *\/\nif (s.equalsIgnoreCase(SECTION_CONTENT_CLASS_CELL)) {\nHTMLOutput content = (HTMLOutput)request.getAttribute(SECTION_CONTENT_BODY);\nif (content != null) {\ntry {\nString cellClass = content.getCellClass();\nout.write(!StringTools.isBlank(cellClass)? cellClass : \"contentCellClass\");\n} catch (IOException ioe) {\nthrow new JspTagException(ioe.toString());\n}\n}\n\nif (content != null) {\ntry {\nString cellClass = content.getCellClass();\nout.write(!StringTools.isBlank(cellClass)? cellClass : \"contentCellClass\");\n} catch (IOException ioe) {\nthrow new JspTagException(ioe.toString());\n}\n}\nreturn EVAL_PAGE;\n}\n\/* content message id *\/\nif (s.equalsIgnoreCase(SECTION_CONTENT_ID_MESSAGE)) {\ntry {\nout.write(CommonServlet.ID_CONTENT_MESSAGE);\n} catch (IOException ioe) {\nthrow new JspTagException(ioe.toString());\n}\nreturn EVAL_PAGE;\n}\n\/* content message class *\/\nif (s.equalsIgnoreCase(SECTION_CONTENT_CLASS_MESSAGE)) {\n\n}\n\/* content message id *\/\nif (s.equalsIgnoreCase(SECTION_CONTENT_ID_MESSAGE)) {\ntry {\nout.write(CommonServlet.ID_CONTENT_MESSAGE);\n} catch (IOException ioe) {\nthrow new JspTagException(ioe.toString());\n}\nreturn EVAL_PAGE;\n}\n\/* content message class *\/\nif (s.equalsIgnoreCase(SECTION_CONTENT_CLASS_MESSAGE)) {\ntry {\nout.write(CommonServlet.CSS_CONTENT_MESSAGE);\n} catch (IOException ioe) {\nthrow new JspTagException(ioe.toString());\n}\nreturn EVAL_PAGE;\n}\n\/* content menubar *\/\nif (s.equalsIgnoreCase(SECTION_CONTENT_MENUBAR)) {\n\n}\n\/* content message class *\/\nif (s.equalsIgnoreCase(SECTION_CONTENT_CLASS_MESSAGE)) {\ntry {\nout.write(CommonServlet.CSS_CONTENT_MESSAGE);\n} catch (IOException ioe) {\nthrow new JspTagException(ioe.toString());\n}\nreturn EVAL_PAGE;\n}\n\/* content menubar *\/\nif (s.equalsIgnoreCase(SECTION_CONTENT_MENUBAR)) {\nHTMLOutput content = (HTMLOutput)request.getAttribute(SECTION_CONTENT_BODY);\nif (content != null) {\nString contentClass = content.getTableClass();\ntry {\nif (ListTools.contains(CommonServlet.CSS_MENUBAR_OK,contentClass)) {\nMenuBar.writeTableRow(out, reqState.getPageName(), reqState);\n} else {\nout.write(\"<!-- no menubar ['\"+contentClass+\"'] -->\");\n}\n\nMenuBar.writeTableRow(out, reqState.getPageName(), reqState);\n} else {\nout.write(\"<!-- no menubar ['\"+contentClass+\"'] -->\");\n}\n} catch (IOException ioe) {\nthrow new JspTagException(ioe.toString());\n}\n}\nreturn EVAL_PAGE;\n}\n\/* content message *\/\nif (s.equalsIgnoreCase(SECTION_CONTENT_MESSAGE)) {\nHTMLOutput content = (HTMLOutput)request.getAttribute(SECTION_CONTENT_BODY);\nString msg = (content != null)? StringTools.trim(content.getTableMessage()) : \"\";\ntry {\nout.write(msg); \/\/ TODO: HTML encode?\n} catch (IOException ioe) {\nthrow new JspTagException(ioe.toString());\n}\nreturn EVAL_PAGE;\n}\n\nthrow new JspTagException(ioe.toString());\n}\n}\nreturn EVAL_PAGE;\n}\n\/* content message *\/\nif (s.equalsIgnoreCase(SECTION_CONTENT_MESSAGE)) {\nHTMLOutput content = (HTMLOutput)request.getAttribute(SECTION_CONTENT_BODY);\nString msg = (content != null)? StringTools.trim(content.getTableMessage()) : \"\";\ntry {\nout.write(msg); \/\/ TODO: HTML encode?\n} catch (IOException ioe) {\nthrow new JspTagException(ioe.toString());\n}\nreturn EVAL_PAGE;\n}\n\/\/ --------------------------------------------------------------------\n\/* request context path *\/\nif (s.equalsIgnoreCase(SECTION_REQUEST_CONTEXT)) {\ntry {\nout.write(request.getContextPath());\n\n\/* ignore blank section definitions *\/\nif (StringTools.isBlank(s)) {\n\/\/ -- ignore\nreturn EVAL_PAGE;\n}\n\/* not a match? *\/\nif (!this.isMatch()) {\n\/\/ -- ignore\nreturn EVAL_PAGE;\n}\n\/\/ --------------------------------------------------------------------\n\/* \"onload='...'\" *\/\nif (s.equalsIgnoreCase(SECTION_BODY_ONLOAD)) {\nString bodyOnLoad = (String)request.getAttribute(SECTION_BODY_ONLOAD);\nif (!StringTools.isBlank(bodyOnLoad)) {\ntry {\nout.print(bodyOnLoad);\n} catch (IOException ioe) {\nthrow new JspTagException(ioe.toString());\n}\n}\nreturn EVAL_PAGE;\n\n\/* ignore blank section definitions *\/\nif (StringTools.isBlank(s)) {\n\/\/ -- ignore\nreturn EVAL_PAGE;\n}\n\/* not a match? *\/\nif (!this.isMatch()) {\n\/\/ -- ignore\nreturn EVAL_PAGE;\n}\n\/\/ --------------------------------------------------------------------\n\/* \"onload='...'\" *\/\nif (s.equalsIgnoreCase(SECTION_BODY_ONLOAD)) {\nString bodyOnLoad = (String)request.getAttribute(SECTION_BODY_ONLOAD);\nif (!StringTools.isBlank(bodyOnLoad)) {\ntry {\nout.print(bodyOnLoad);\n} catch (IOException ioe) {\nthrow new JspTagException(ioe.toString());\n}\n}\nreturn EVAL_PAGE;\n\n\/* ignore blank section definitions *\/\nif (StringTools.isBlank(s)) {\n\/\/ -- ignore\nreturn EVAL_PAGE;\n}\n\/* not a match? *\/\nif (!this.isMatch()) {\n\/\/ -- ignore\nreturn EVAL_PAGE;\n}\n\/\/ --------------------------------------------------------------------\n\/* \"onload='...'\" *\/\nif (s.equalsIgnoreCase(SECTION_BODY_ONLOAD)) {\nString bodyOnLoad = (String)request.getAttribute(SECTION_BODY_ONLOAD);\nif (!StringTools.isBlank(bodyOnLoad)) {\ntry {\nout.print(bodyOnLoad);\n} catch (IOException ioe) {\nthrow new JspTagException(ioe.toString());\n}\n}\nreturn EVAL_PAGE;\n\nWebPageAdaptor.writeCssLink(pw, reqState, cssFilePath, null);\n} catch (IOException ioe) {\nthrow new JspTagException(ioe.toString());\n}\n}\nreturn EVAL_PAGE;\n}\n\/\/ --------------------------------------------------------------------\n\/* Banner Image Height *\/\nif (s.equalsIgnoreCase(SECTION_BANNER_WIDTH)) {\n\/\/ key suffix\nString kSfx = StringTools.trim(this.getArg());\n\/\/ property values\nString bannerWidth = privLabel.getStringProperty(PrivateLabel.PROP_Banner_width + kSfx, null);\nif (StringTools.isBlank(bannerWidth)) {\nbannerWidth = privLabel.getStringProperty(PrivateLabel.PROP_Banner_imageWidth + kSfx, null);\n}\n\/\/ minimum valie\nif (StringTools.isBlank(bannerWidth)) {\nbannerWidth = this.hasDefault()? this.getDefault() : \"100%\";\n} else\n\nthrow new JspTagException(ioe.toString());\n}\n}\nreturn EVAL_PAGE;\n}\n\/\/ --------------------------------------------------------------------\n\/* Banner Image Height *\/\nif (s.equalsIgnoreCase(SECTION_BANNER_WIDTH)) {\n\/\/ key suffix\nString kSfx = StringTools.trim(this.getArg());\n\/\/ property values\nString bannerWidth = privLabel.getStringProperty(PrivateLabel.PROP_Banner_width + kSfx, null);\nif (StringTools.isBlank(bannerWidth)) {\nbannerWidth = privLabel.getStringProperty(PrivateLabel.PROP_Banner_imageWidth + kSfx, null);\n}\n\/\/ minimum valie\nif (StringTools.isBlank(bannerWidth)) {\nbannerWidth = this.hasDefault()? this.getDefault() : \"100%\";\n} else\nif (!bannerWidth.endsWith(\"%\")) {\nint W = StringTools.parseInt(bannerWidth, 0);\n\n\/\/ --------------------------------------------------------------------\n\/* Banner Image Height *\/\nif (s.equalsIgnoreCase(SECTION_BANNER_WIDTH)) {\n\/\/ key suffix\nString kSfx = StringTools.trim(this.getArg());\n\/\/ property values\nString bannerWidth = privLabel.getStringProperty(PrivateLabel.PROP_Banner_width + kSfx, null);\nif (StringTools.isBlank(bannerWidth)) {\nbannerWidth = privLabel.getStringProperty(PrivateLabel.PROP_Banner_imageWidth + kSfx, null);\n}\n\/\/ minimum valie\nif (StringTools.isBlank(bannerWidth)) {\nbannerWidth = this.hasDefault()? this.getDefault() : \"100%\";\n} else\nif (!bannerWidth.endsWith(\"%\")) {\nint W = StringTools.parseInt(bannerWidth, 0);\nbannerWidth = String.valueOf((W < MIN_BANNER_WIDTH)? MIN_BANNER_WIDTH : W);\n}\n\/\/ generate html\ntry {\nout.write(bannerWidth);\n\nbannerWidth = privLabel.getStringProperty(PrivateLabel.PROP_Banner_imageWidth + kSfx, null);\n}\n\/\/ minimum valie\nif (StringTools.isBlank(bannerWidth)) {\nbannerWidth = this.hasDefault()? this.getDefault() : \"100%\";\n} else\nif (!bannerWidth.endsWith(\"%\")) {\nint W = StringTools.parseInt(bannerWidth, 0);\nbannerWidth = String.valueOf((W < MIN_BANNER_WIDTH)? MIN_BANNER_WIDTH : W);\n}\n\/\/ generate html\ntry {\nout.write(bannerWidth);\n} catch (IOException ioe) {\nthrow new JspTagException(ioe.toString());\n}\nreturn EVAL_PAGE;\n}\n\/* Banner Style *\/\nif (s.equalsIgnoreCase(SECTION_BANNER_STYLE)) {\n\/\/ key suffix\n\nbannerWidth = String.valueOf((W < MIN_BANNER_WIDTH)? MIN_BANNER_WIDTH : W);\n}\n\/\/ generate html\ntry {\nout.write(bannerWidth);\n} catch (IOException ioe) {\nthrow new JspTagException(ioe.toString());\n}\nreturn EVAL_PAGE;\n}\n\/* Banner Style *\/\nif (s.equalsIgnoreCase(SECTION_BANNER_STYLE)) {\n\/\/ key suffix\nString kSfx = StringTools.trim(this.getArg());\n\/\/ property values\nString bannerStyle = privLabel.getStringProperty(PrivateLabel.PROP_Banner_style + kSfx, null);\n\/\/ generate html\nif (!StringTools.isBlank(bannerStyle)) {\ntry {\nout.write(bannerStyle);\n} catch (IOException ioe) {\n\nWebPageAdaptor.writeCssLink(pw, reqState, cssFilePath, null);\n} catch (IOException ioe) {\nthrow new JspTagException(ioe.toString());\n}\n}\nreturn EVAL_PAGE;\n}\n\/\/ --------------------------------------------------------------------\n\/* Banner Image Height *\/\nif (s.equalsIgnoreCase(SECTION_BANNER_WIDTH)) {\n\/\/ key suffix\nString kSfx = StringTools.trim(this.getArg());\n\/\/ property values\nString bannerWidth = privLabel.getStringProperty(PrivateLabel.PROP_Banner_width + kSfx, null);\nif (StringTools.isBlank(bannerWidth)) {\nbannerWidth = privLabel.getStringProperty(PrivateLabel.PROP_Banner_imageWidth + kSfx, null);\n}\n\/\/ minimum valie\nif (StringTools.isBlank(bannerWidth)) {\nbannerWidth = this.hasDefault()? this.getDefault() : \"100%\";\n} else\n\nthrow new JspTagException(ioe.toString());\n}\n}\nreturn EVAL_PAGE;\n}\n\/\/ --------------------------------------------------------------------\n\/* Banner Image Height *\/\nif (s.equalsIgnoreCase(SECTION_BANNER_WIDTH)) {\n\/\/ key suffix\nString kSfx = StringTools.trim(this.getArg());\n\/\/ property values\nString bannerWidth = privLabel.getStringProperty(PrivateLabel.PROP_Banner_width + kSfx, null);\nif (StringTools.isBlank(bannerWidth)) {\nbannerWidth = privLabel.getStringProperty(PrivateLabel.PROP_Banner_imageWidth + kSfx, null);\n}\n\/\/ minimum valie\nif (StringTools.isBlank(bannerWidth)) {\nbannerWidth = this.hasDefault()? this.getDefault() : \"100%\";\n} else\nif (!bannerWidth.endsWith(\"%\")) {\nint W = StringTools.parseInt(bannerWidth, 0);\n\nbannerWidth = privLabel.getStringProperty(PrivateLabel.PROP_Banner_imageWidth + kSfx, null);\n}\n\/\/ minimum valie\nif (StringTools.isBlank(bannerWidth)) {\nbannerWidth = this.hasDefault()? this.getDefault() : \"100%\";\n} else\nif (!bannerWidth.endsWith(\"%\")) {\nint W = StringTools.parseInt(bannerWidth, 0);\nbannerWidth = String.valueOf((W < MIN_BANNER_WIDTH)? MIN_BANNER_WIDTH : W);\n}\n\/\/ generate html\ntry {\nout.write(bannerWidth);\n} catch (IOException ioe) {\nthrow new JspTagException(ioe.toString());\n}\nreturn EVAL_PAGE;\n}\n\/* Banner Style *\/\nif (s.equalsIgnoreCase(SECTION_BANNER_STYLE)) {\n\/\/ key suffix\n\n} else\nif (this.hasDefault()) {\ntry {\nout.write(this.getDefault());\n} catch (IOException ioe) {\nthrow new JspTagException(ioe.toString());\n}\n}\nreturn EVAL_PAGE;\n}\n\/* Banner Image *\/\nif (s.equalsIgnoreCase(SECTION_BANNER_IMAGE)) {\n\/\/ key suffix\nString kSfx = StringTools.trim(this.getArg());\n\/\/ property values\nString imgLink = privLabel.getStringProperty(PrivateLabel.PROP_Banner_imageLink + kSfx, null);\nString imgSrc = privLabel.getStringProperty(PrivateLabel.PROP_Banner_imageSource + kSfx, null);\nString imgWidth = privLabel.getStringProperty(PrivateLabel.PROP_Banner_imageWidth + kSfx, null);\nString imgHeight = privLabel.getStringProperty(PrivateLabel.PROP_Banner_imageHeight + kSfx, null);\n\/\/ generate html\nif (!StringTools.isBlank(imgSrc)) {\n\nWebPageAdaptor.writeCssLink(pw, reqState, cssFilePath, null);\n} catch (IOException ioe) {\nthrow new JspTagException(ioe.toString());\n}\n}\nreturn EVAL_PAGE;\n}\n\/\/ --------------------------------------------------------------------\n\/* Banner Image Height *\/\nif (s.equalsIgnoreCase(SECTION_BANNER_WIDTH)) {\n\/\/ key suffix\nString kSfx = StringTools.trim(this.getArg());\n\/\/ property values\nString bannerWidth = privLabel.getStringProperty(PrivateLabel.PROP_Banner_width + kSfx, null);\nif (StringTools.isBlank(bannerWidth)) {\nbannerWidth = privLabel.getStringProperty(PrivateLabel.PROP_Banner_imageWidth + kSfx, null);\n}\n\/\/ minimum valie\nif (StringTools.isBlank(bannerWidth)) {\nbannerWidth = this.hasDefault()? this.getDefault() : \"100%\";\n} else\n\nthrow new JspTagException(ioe.toString());\n}\n}\nreturn EVAL_PAGE;\n}\n\/\/ --------------------------------------------------------------------\n\/* Banner Image Height *\/\nif (s.equalsIgnoreCase(SECTION_BANNER_WIDTH)) {\n\/\/ key suffix\nString kSfx = StringTools.trim(this.getArg());\n\/\/ property values\nString bannerWidth = privLabel.getStringProperty(PrivateLabel.PROP_Banner_width + kSfx, null);\nif (StringTools.isBlank(bannerWidth)) {\nbannerWidth = privLabel.getStringProperty(PrivateLabel.PROP_Banner_imageWidth + kSfx, null);\n}\n\/\/ minimum valie\nif (StringTools.isBlank(bannerWidth)) {\nbannerWidth = this.hasDefault()? this.getDefault() : \"100%\";\n} else\nif (!bannerWidth.endsWith(\"%\")) {\nint W = StringTools.parseInt(bannerWidth, 0);\n\nbannerWidth = privLabel.getStringProperty(PrivateLabel.PROP_Banner_imageWidth + kSfx, null);\n}\n\/\/ minimum valie\nif (StringTools.isBlank(bannerWidth)) {\nbannerWidth = this.hasDefault()? this.getDefault() : \"100%\";\n} else\nif (!bannerWidth.endsWith(\"%\")) {\nint W = StringTools.parseInt(bannerWidth, 0);\nbannerWidth = String.valueOf((W < MIN_BANNER_WIDTH)? MIN_BANNER_WIDTH : W);\n}\n\/\/ generate html\ntry {\nout.write(bannerWidth);\n} catch (IOException ioe) {\nthrow new JspTagException(ioe.toString());\n}\nreturn EVAL_PAGE;\n}\n\/* Banner Style *\/\nif (s.equalsIgnoreCase(SECTION_BANNER_STYLE)) {\n\/\/ key suffix\n\n} else\nif (this.hasDefault()) {\ntry {\nout.write(this.getDefault());\n} catch (IOException ioe) {\nthrow new JspTagException(ioe.toString());\n}\n}\nreturn EVAL_PAGE;\n}\n\/* Banner Image *\/\nif (s.equalsIgnoreCase(SECTION_BANNER_IMAGE)) {\n\/\/ key suffix\nString kSfx = StringTools.trim(this.getArg());\n\/\/ property values\nString imgLink = privLabel.getStringProperty(PrivateLabel.PROP_Banner_imageLink + kSfx, null);\nString imgSrc = privLabel.getStringProperty(PrivateLabel.PROP_Banner_imageSource + kSfx, null);\nString imgWidth = privLabel.getStringProperty(PrivateLabel.PROP_Banner_imageWidth + kSfx, null);\nString imgHeight = privLabel.getStringProperty(PrivateLabel.PROP_Banner_imageHeight + kSfx, null);\n\/\/ generate html\nif (!StringTools.isBlank(imgSrc)) {\n\nWebPageAdaptor.writeCssLink(pw, reqState, cssFilePath, null);\n} catch (IOException ioe) {\nthrow new JspTagException(ioe.toString());\n}\n}\nreturn EVAL_PAGE;\n}\n\/\/ --------------------------------------------------------------------\n\/* Banner Image Height *\/\nif (s.equalsIgnoreCase(SECTION_BANNER_WIDTH)) {\n\/\/ key suffix\nString kSfx = StringTools.trim(this.getArg());\n\/\/ property values\nString bannerWidth = privLabel.getStringProperty(PrivateLabel.PROP_Banner_width + kSfx, null);\nif (StringTools.isBlank(bannerWidth)) {\nbannerWidth = privLabel.getStringProperty(PrivateLabel.PROP_Banner_imageWidth + kSfx, null);\n}\n\/\/ minimum valie\nif (StringTools.isBlank(bannerWidth)) {\nbannerWidth = this.hasDefault()? this.getDefault() : \"100%\";\n} else\n\nthrow new JspTagException(ioe.toString());\n}\n}\nreturn EVAL_PAGE;\n}\n\/\/ --------------------------------------------------------------------\n\/* Banner Image Height *\/\nif (s.equalsIgnoreCase(SECTION_BANNER_WIDTH)) {\n\/\/ key suffix\nString kSfx = StringTools.trim(this.getArg());\n\/\/ property values\nString bannerWidth = privLabel.getStringProperty(PrivateLabel.PROP_Banner_width + kSfx, null);\nif (StringTools.isBlank(bannerWidth)) {\nbannerWidth = privLabel.getStringProperty(PrivateLabel.PROP_Banner_imageWidth + kSfx, null);\n}\n\/\/ minimum valie\nif (StringTools.isBlank(bannerWidth)) {\nbannerWidth = this.hasDefault()? this.getDefault() : \"100%\";\n} else\nif (!bannerWidth.endsWith(\"%\")) {\nint W = StringTools.parseInt(bannerWidth, 0);\n\nbannerWidth = privLabel.getStringProperty(PrivateLabel.PROP_Banner_imageWidth + kSfx, null);\n}\n\/\/ minimum valie\nif (StringTools.isBlank(bannerWidth)) {\nbannerWidth = this.hasDefault()? this.getDefault() : \"100%\";\n} else\nif (!bannerWidth.endsWith(\"%\")) {\nint W = StringTools.parseInt(bannerWidth, 0);\nbannerWidth = String.valueOf((W < MIN_BANNER_WIDTH)? MIN_BANNER_WIDTH : W);\n}\n\/\/ generate html\ntry {\nout.write(bannerWidth);\n} catch (IOException ioe) {\nthrow new JspTagException(ioe.toString());\n}\nreturn EVAL_PAGE;\n}\n\/* Banner Style *\/\nif (s.equalsIgnoreCase(SECTION_BANNER_STYLE)) {\n\/\/ key suffix\n\nreturn EVAL_PAGE;\n}\n\/* Banner Image *\/\nif (s.equalsIgnoreCase(SECTION_BANNER_IMAGE_SOURCE)) {\n\/\/ key suffix\nString kSfx = StringTools.trim(this.getArg());\n\/\/ property values\nString imgSrc = privLabel.getStringProperty(PrivateLabel.PROP_Banner_imageSource + kSfx, null);\n\/\/ generate html\nif (!StringTools.isBlank(imgSrc)) {\n\/\/Print.sysPrintln(\"Property Image Source: \" + imgSrc);\ntry {\nout.write(imgSrc);\n} catch (IOException ioe) {\nthrow new JspTagException(ioe.toString());\n}\n} else\nif (this.hasDefault()) {\n\/\/Print.sysPrintln(\"Default Image Source: \" + this.getDefault());\ntry {\nout.write(this.getDefault());\n\n\/\/ generate html\nif (!StringTools.isBlank(imgSrc)) {\n\/\/Print.sysPrintln(\"Property Image Source: \" + imgSrc);\ntry {\nout.write(imgSrc);\n} catch (IOException ioe) {\nthrow new JspTagException(ioe.toString());\n}\n} else\nif (this.hasDefault()) {\n\/\/Print.sysPrintln(\"Default Image Source: \" + this.getDefault());\ntry {\nout.write(this.getDefault());\n} catch (IOException ioe) {\nthrow new JspTagException(ioe.toString());\n}\n}\nreturn EVAL_PAGE;\n}\n\/* Banner Image Height *\/\nif (s.equalsIgnoreCase(SECTION_BANNER_IMAGE_WIDTH)) {\n\ntry {\nPrintWriter pw = new PrintWriter(out, out.isAutoFlush());\nWebPageAdaptor.writeCssLink(pw, reqState, cssFilePath, null);\n} catch (IOException ioe) {\nthrow new JspTagException(ioe.toString());\n}\n}\nreturn EVAL_PAGE;\n}\n\/\/ --------------------------------------------------------------------\n\/* Banner Image Height *\/\nif (s.equalsIgnoreCase(SECTION_BANNER_WIDTH)) {\n\/\/ key suffix\nString kSfx = StringTools.trim(this.getArg());\n\/\/ property values\nString bannerWidth = privLabel.getStringProperty(PrivateLabel.PROP_Banner_width + kSfx, null);\nif (StringTools.isBlank(bannerWidth)) {\nbannerWidth = privLabel.getStringProperty(PrivateLabel.PROP_Banner_imageWidth + kSfx, null);\n}\n\/\/ minimum valie\nif (StringTools.isBlank(bannerWidth)) {\n\nWebPageAdaptor.writeCssLink(pw, reqState, cssFilePath, null);\n} catch (IOException ioe) {\nthrow new JspTagException(ioe.toString());\n}\n}\nreturn EVAL_PAGE;\n}\n\/\/ --------------------------------------------------------------------\n\/* Banner Image Height *\/\nif (s.equalsIgnoreCase(SECTION_BANNER_WIDTH)) {\n\/\/ key suffix\nString kSfx = StringTools.trim(this.getArg());\n\/\/ property values\nString bannerWidth = privLabel.getStringProperty(PrivateLabel.PROP_Banner_width + kSfx, null);\nif (StringTools.isBlank(bannerWidth)) {\nbannerWidth = privLabel.getStringProperty(PrivateLabel.PROP_Banner_imageWidth + kSfx, null);\n}\n\/\/ minimum valie\nif (StringTools.isBlank(bannerWidth)) {\nbannerWidth = this.hasDefault()? this.getDefault() : \"100%\";\n} else\n\nthrow new JspTagException(ioe.toString());\n}\n}\nreturn EVAL_PAGE;\n}\n\/\/ --------------------------------------------------------------------\n\/* Banner Image Height *\/\nif (s.equalsIgnoreCase(SECTION_BANNER_WIDTH)) {\n\/\/ key suffix\nString kSfx = StringTools.trim(this.getArg());\n\/\/ property values\nString bannerWidth = privLabel.getStringProperty(PrivateLabel.PROP_Banner_width + kSfx, null);\nif (StringTools.isBlank(bannerWidth)) {\nbannerWidth = privLabel.getStringProperty(PrivateLabel.PROP_Banner_imageWidth + kSfx, null);\n}\n\/\/ minimum valie\nif (StringTools.isBlank(bannerWidth)) {\nbannerWidth = this.hasDefault()? this.getDefault() : \"100%\";\n} else\nif (!bannerWidth.endsWith(\"%\")) {\nint W = StringTools.parseInt(bannerWidth, 0);\n\nbannerWidth = privLabel.getStringProperty(PrivateLabel.PROP_Banner_imageWidth + kSfx, null);\n}\n\/\/ minimum valie\nif (StringTools.isBlank(bannerWidth)) {\nbannerWidth = this.hasDefault()? this.getDefault() : \"100%\";\n} else\nif (!bannerWidth.endsWith(\"%\")) {\nint W = StringTools.parseInt(bannerWidth, 0);\nbannerWidth = String.valueOf((W < MIN_BANNER_WIDTH)? MIN_BANNER_WIDTH : W);\n}\n\/\/ generate html\ntry {\nout.write(bannerWidth);\n} catch (IOException ioe) {\nthrow new JspTagException(ioe.toString());\n}\nreturn EVAL_PAGE;\n}\n\/* Banner Style *\/\nif (s.equalsIgnoreCase(SECTION_BANNER_STYLE)) {\n\/\/ key suffix\n\ntry {\nPrintWriter pw = new PrintWriter(out, out.isAutoFlush());\nWebPageAdaptor.writeCssLink(pw, reqState, cssFilePath, null);\n} catch (IOException ioe) {\nthrow new JspTagException(ioe.toString());\n}\n}\nreturn EVAL_PAGE;\n}\n\/\/ --------------------------------------------------------------------\n\/* Banner Image Height *\/\nif (s.equalsIgnoreCase(SECTION_BANNER_WIDTH)) {\n\/\/ key suffix\nString kSfx = StringTools.trim(this.getArg());\n\/\/ property values\nString bannerWidth = privLabel.getStringProperty(PrivateLabel.PROP_Banner_width + kSfx, null);\nif (StringTools.isBlank(bannerWidth)) {\nbannerWidth = privLabel.getStringProperty(PrivateLabel.PROP_Banner_imageWidth + kSfx, null);\n}\n\/\/ minimum valie\nif (StringTools.isBlank(bannerWidth)) {\n\nWebPageAdaptor.writeCssLink(pw, reqState, cssFilePath, null);\n} catch (IOException ioe) {\nthrow new JspTagException(ioe.toString());\n}\n}\nreturn EVAL_PAGE;\n}\n\/\/ --------------------------------------------------------------------\n\/* Banner Image Height *\/\nif (s.equalsIgnoreCase(SECTION_BANNER_WIDTH)) {\n\/\/ key suffix\nString kSfx = StringTools.trim(this.getArg());\n\/\/ property values\nString bannerWidth = privLabel.getStringProperty(PrivateLabel.PROP_Banner_width + kSfx, null);\nif (StringTools.isBlank(bannerWidth)) {\nbannerWidth = privLabel.getStringProperty(PrivateLabel.PROP_Banner_imageWidth + kSfx, null);\n}\n\/\/ minimum valie\nif (StringTools.isBlank(bannerWidth)) {\nbannerWidth = this.hasDefault()? this.getDefault() : \"100%\";\n} else\n\nthrow new JspTagException(ioe.toString());\n}\n}\nreturn EVAL_PAGE;\n}\n\/\/ --------------------------------------------------------------------\n\/* Banner Image Height *\/\nif (s.equalsIgnoreCase(SECTION_BANNER_WIDTH)) {\n\/\/ key suffix\nString kSfx = StringTools.trim(this.getArg());\n\/\/ property values\nString bannerWidth = privLabel.getStringProperty(PrivateLabel.PROP_Banner_width + kSfx, null);\nif (StringTools.isBlank(bannerWidth)) {\nbannerWidth = privLabel.getStringProperty(PrivateLabel.PROP_Banner_imageWidth + kSfx, null);\n}\n\/\/ minimum valie\nif (StringTools.isBlank(bannerWidth)) {\nbannerWidth = this.hasDefault()? this.getDefault() : \"100%\";\n} else\nif (!bannerWidth.endsWith(\"%\")) {\nint W = StringTools.parseInt(bannerWidth, 0);\n\nbannerWidth = privLabel.getStringProperty(PrivateLabel.PROP_Banner_imageWidth + kSfx, null);\n}\n\/\/ minimum valie\nif (StringTools.isBlank(bannerWidth)) {\nbannerWidth = this.hasDefault()? this.getDefault() : \"100%\";\n} else\nif (!bannerWidth.endsWith(\"%\")) {\nint W = StringTools.parseInt(bannerWidth, 0);\nbannerWidth = String.valueOf((W < MIN_BANNER_WIDTH)? MIN_BANNER_WIDTH : W);\n}\n\/\/ generate html\ntry {\nout.write(bannerWidth);\n} catch (IOException ioe) {\nthrow new JspTagException(ioe.toString());\n}\nreturn EVAL_PAGE;\n}\n\/* Banner Style *\/\nif (s.equalsIgnoreCase(SECTION_BANNER_STYLE)) {\n\/\/ key suffix\n\n\/* ignore blank section definitions *\/\nif (StringTools.isBlank(s)) {\n\/\/ -- ignore\nreturn EVAL_PAGE;\n}\n\/* not a match? *\/\nif (!this.isMatch()) {\n\/\/ -- ignore\nreturn EVAL_PAGE;\n}\n\/\/ --------------------------------------------------------------------\n\/* \"onload='...'\" *\/\nif (s.equalsIgnoreCase(SECTION_BODY_ONLOAD)) {\nString bodyOnLoad = (String)request.getAttribute(SECTION_BODY_ONLOAD);\nif (!StringTools.isBlank(bodyOnLoad)) {\ntry {\nout.print(bodyOnLoad);\n} catch (IOException ioe) {\nthrow new JspTagException(ioe.toString());\n}\n}\nreturn EVAL_PAGE;\n\n} catch (IOException ioe) {\nthrow new JspTagException(ioe.toString());\n}\n}\nreturn EVAL_PAGE;\n}\n\/\/ --------------------------------------------------------------------\n\/* JavaScript *\/\nif (s.equalsIgnoreCase(SECTION_JAVASCRIPT)) {\ntry {\n\/\/ always write \"utils.js\"\nJavaScriptTools.writeUtilsJS(out, request);\n\/\/ check for other javascript\nObject obj = request.getAttribute(SECTION_JAVASCRIPT);\nif (obj instanceof HTMLOutput) {\n((HTMLOutput)obj).write(out);\n} else {\nout.write(\"<!-- Unexpected section type '\" + s + \"' [\" + StringTools.className(obj) + \"] -->\");\n}\n} catch (IOException ioe) {\nthrow new JspTagException(ioe.toString());\n\n}\n}\nreturn EVAL_PAGE;\n}\n\/\/ --------------------------------------------------------------------\n\/* JavaScript *\/\nif (s.equalsIgnoreCase(SECTION_JAVASCRIPT)) {\ntry {\n\/\/ always write \"utils.js\"\nJavaScriptTools.writeUtilsJS(out, request);\n\/\/ check for other javascript\nObject obj = request.getAttribute(SECTION_JAVASCRIPT);\nif (obj instanceof HTMLOutput) {\n((HTMLOutput)obj).write(out);\n} else {\nout.write(\"<!-- Unexpected section type '\" + s + \"' [\" + StringTools.className(obj) + \"] -->\");\n}\n} catch (IOException ioe) {\nthrow new JspTagException(ioe.toString());\n}\nreturn EVAL_PAGE;\n\n\/* ignore blank section definitions *\/\nif (StringTools.isBlank(s)) {\n\/\/ -- ignore\nreturn EVAL_PAGE;\n}\n\/* not a match? *\/\nif (!this.isMatch()) {\n\/\/ -- ignore\nreturn EVAL_PAGE;\n}\n\/\/ --------------------------------------------------------------------\n\/* \"onload='...'\" *\/\nif (s.equalsIgnoreCase(SECTION_BODY_ONLOAD)) {\nString bodyOnLoad = (String)request.getAttribute(SECTION_BODY_ONLOAD);\nif (!StringTools.isBlank(bodyOnLoad)) {\ntry {\nout.print(bodyOnLoad);\n} catch (IOException ioe) {\nthrow new JspTagException(ioe.toString());\n}\n}\nreturn EVAL_PAGE;\n\n} else {\nout.write(\"<!-- Unexpected section type '\" + s + \"' [\" + StringTools.className(obj) + \"] -->\");\n}\n} catch (IOException ioe) {\nthrow new JspTagException(ioe.toString());\n}\nreturn EVAL_PAGE;\n}\n\/\/ --------------------------------------------------------------------\n\/* current page name *\/\nif (s.equalsIgnoreCase(SECTION_PAGE_NAME)) { \/\/ \"pagename\"\nString pageName = reqState.getPageName();\nif (!StringTools.isBlank(pageName)) {\ntry {\nout.write(pageName);\n} catch (IOException ioe) {\nthrow new JspTagException(ioe.toString());\n}\n}\nreturn EVAL_PAGE;\n}\n\n\/* ignore blank section definitions *\/\nif (StringTools.isBlank(s)) {\n\/\/ -- ignore\nreturn EVAL_PAGE;\n}\n\/* not a match? *\/\nif (!this.isMatch()) {\n\/\/ -- ignore\nreturn EVAL_PAGE;\n}\n\/\/ --------------------------------------------------------------------\n\/* \"onload='...'\" *\/\nif (s.equalsIgnoreCase(SECTION_BODY_ONLOAD)) {\nString bodyOnLoad = (String)request.getAttribute(SECTION_BODY_ONLOAD);\nif (!StringTools.isBlank(bodyOnLoad)) {\ntry {\nout.print(bodyOnLoad);\n} catch (IOException ioe) {\nthrow new JspTagException(ioe.toString());\n}\n}\nreturn EVAL_PAGE;\n\ntry {\nout.write(pageName);\n} catch (IOException ioe) {\nthrow new JspTagException(ioe.toString());\n}\n}\nreturn EVAL_PAGE;\n}\n\/\/ --------------------------------------------------------------------\n\/* Page URL *\/\nif (s.equalsIgnoreCase(SECTION_PAGE_URL)) { \/\/ \"pageurl\"\nString pageName = this.getArg();\nString cmd = null;\nString cmdArg = null;\nWebPage wp = privLabel.getWebPage(pageName);\nString url = (wp != null)? wp.encodePageURL(reqState,cmd,cmdArg) : null;\nif (!StringTools.isBlank(url)) {\ntry {\nout.write(url);\n} catch (IOException ioe) {\nthrow new JspTagException(ioe.toString());\n\n\/* ignore blank section definitions *\/\nif (StringTools.isBlank(s)) {\n\/\/ -- ignore\nreturn EVAL_PAGE;\n}\n\/* not a match? *\/\nif (!this.isMatch()) {\n\/\/ -- ignore\nreturn EVAL_PAGE;\n}\n\/\/ --------------------------------------------------------------------\n\/* \"onload='...'\" *\/\nif (s.equalsIgnoreCase(SECTION_BODY_ONLOAD)) {\nString bodyOnLoad = (String)request.getAttribute(SECTION_BODY_ONLOAD);\nif (!StringTools.isBlank(bodyOnLoad)) {\ntry {\nout.print(bodyOnLoad);\n} catch (IOException ioe) {\nthrow new JspTagException(ioe.toString());\n}\n}\nreturn EVAL_PAGE;","code_context_20":"public int doEndTag()\nthrows JspTagException\n{\nHttpServletRequest request = (HttpServletRequest)super.pageContext.getRequest();\nRequestProperties reqState = (RequestProperties)request.getAttribute(SECTION_REQUESTPROPS);\nPrivateLabel privLabel = (reqState != null)? reqState.getPrivateLabel() : RequestProperties.NullPrivateLabel;\nJspWriter out = super.pageContext.getOut();\nString s = this.getSection().toLowerCase();\n\/* ignore blank section definitions *\/\nif (StringTools.isBlank(s)) {\n\/\/ -- ignore\nreturn EVAL_PAGE;\n}\n\/* not a match? *\/\nif (!this.isMatch()) {\n\/\/ -- ignore\nreturn EVAL_PAGE;\n}\n\/\/ --------------------------------------------------------------------\n\/* \"onload='...'\" *\/\nif (s.equalsIgnoreCase(SECTION_BODY_ONLOAD)) {\nString bodyOnLoad = (String)request.getAttribute(SECTION_BODY_ONLOAD);\nif (!StringTools.isBlank(bodyOnLoad)) {\ntry {\nout.print(bodyOnLoad);\n} catch (IOException ioe) {\nthrow new JspTagException(ioe.toString());\n}\n}\n\npublic int doEndTag()\nthrows JspTagException\n{\nHttpServletRequest request = (HttpServletRequest)super.pageContext.getRequest();\nRequestProperties reqState = (RequestProperties)request.getAttribute(SECTION_REQUESTPROPS);\nPrivateLabel privLabel = (reqState != null)? reqState.getPrivateLabel() : RequestProperties.NullPrivateLabel;\nJspWriter out = super.pageContext.getOut();\nString s = this.getSection().toLowerCase();\n\/* ignore blank section definitions *\/\nif (StringTools.isBlank(s)) {\n\/\/ -- ignore\nreturn EVAL_PAGE;\n}\n\/* not a match? *\/\nif (!this.isMatch()) {\n\/\/ -- ignore\nreturn EVAL_PAGE;\n}\n\/\/ --------------------------------------------------------------------\n\/* \"onload='...'\" *\/\nif (s.equalsIgnoreCase(SECTION_BODY_ONLOAD)) {\nString bodyOnLoad = (String)request.getAttribute(SECTION_BODY_ONLOAD);\nif (!StringTools.isBlank(bodyOnLoad)) {\ntry {\nout.print(bodyOnLoad);\n} catch (IOException ioe) {\nthrow new JspTagException(ioe.toString());\n}\n}\nreturn EVAL_PAGE;\n}\n\npublic int doEndTag()\nthrows JspTagException\n{\nHttpServletRequest request = (HttpServletRequest)super.pageContext.getRequest();\nRequestProperties reqState = (RequestProperties)request.getAttribute(SECTION_REQUESTPROPS);\nPrivateLabel privLabel = (reqState != null)? reqState.getPrivateLabel() : RequestProperties.NullPrivateLabel;\nJspWriter out = super.pageContext.getOut();\nString s = this.getSection().toLowerCase();\n\/* ignore blank section definitions *\/\nif (StringTools.isBlank(s)) {\n\/\/ -- ignore\nreturn EVAL_PAGE;\n}\n\/* not a match? *\/\nif (!this.isMatch()) {\n\/\/ -- ignore\nreturn EVAL_PAGE;\n}\n\/\/ --------------------------------------------------------------------\n\/* \"onload='...'\" *\/\nif (s.equalsIgnoreCase(SECTION_BODY_ONLOAD)) {\nString bodyOnLoad = (String)request.getAttribute(SECTION_BODY_ONLOAD);\nif (!StringTools.isBlank(bodyOnLoad)) {\ntry {\nout.print(bodyOnLoad);\n} catch (IOException ioe) {\nthrow new JspTagException(ioe.toString());\n}\n}\nreturn EVAL_PAGE;\n}\n\/* \"onunload='...'\" *\/\nif (s.equalsIgnoreCase(SECTION_BODY_ONUNLOAD)) {\nString bodyOnUnload = (String)request.getAttribute(SECTION_BODY_ONUNLOAD);\n\npublic int doEndTag()\nthrows JspTagException\n{\nHttpServletRequest request = (HttpServletRequest)super.pageContext.getRequest();\nRequestProperties reqState = (RequestProperties)request.getAttribute(SECTION_REQUESTPROPS);\nPrivateLabel privLabel = (reqState != null)? reqState.getPrivateLabel() : RequestProperties.NullPrivateLabel;\nJspWriter out = super.pageContext.getOut();\nString s = this.getSection().toLowerCase();\n\/* ignore blank section definitions *\/\nif (StringTools.isBlank(s)) {\n\/\/ -- ignore\nreturn EVAL_PAGE;\n}\n\/* not a match? *\/\nif (!this.isMatch()) {\n\/\/ -- ignore\nreturn EVAL_PAGE;\n}\n\/\/ --------------------------------------------------------------------\n\/* \"onload='...'\" *\/\nif (s.equalsIgnoreCase(SECTION_BODY_ONLOAD)) {\nString bodyOnLoad = (String)request.getAttribute(SECTION_BODY_ONLOAD);\nif (!StringTools.isBlank(bodyOnLoad)) {\ntry {\nout.print(bodyOnLoad);\n} catch (IOException ioe) {\nthrow new JspTagException(ioe.toString());\n}\n}\nreturn EVAL_PAGE;\n}\n\npublic int doEndTag()\nthrows JspTagException\n{\nHttpServletRequest request = (HttpServletRequest)super.pageContext.getRequest();\nRequestProperties reqState = (RequestProperties)request.getAttribute(SECTION_REQUESTPROPS);\nPrivateLabel privLabel = (reqState != null)? reqState.getPrivateLabel() : RequestProperties.NullPrivateLabel;\nJspWriter out = super.pageContext.getOut();\nString s = this.getSection().toLowerCase();\n\/* ignore blank section definitions *\/\nif (StringTools.isBlank(s)) {\n\/\/ -- ignore\nreturn EVAL_PAGE;\n}\n\/* not a match? *\/\nif (!this.isMatch()) {\n\/\/ -- ignore\nreturn EVAL_PAGE;\n}\n\/\/ --------------------------------------------------------------------\n\/* \"onload='...'\" *\/\nif (s.equalsIgnoreCase(SECTION_BODY_ONLOAD)) {\nString bodyOnLoad = (String)request.getAttribute(SECTION_BODY_ONLOAD);\nif (!StringTools.isBlank(bodyOnLoad)) {\ntry {\nout.print(bodyOnLoad);\n} catch (IOException ioe) {\nthrow new JspTagException(ioe.toString());\n}\n}\nreturn EVAL_PAGE;\n}\n\/* \"onunload='...'\" *\/\nif (s.equalsIgnoreCase(SECTION_BODY_ONUNLOAD)) {\nString bodyOnUnload = (String)request.getAttribute(SECTION_BODY_ONUNLOAD);\nif (!StringTools.isBlank(bodyOnUnload)) {\ntry {\nout.print(bodyOnUnload);\n} catch (IOException ioe) {\nthrow new JspTagException(ioe.toString());\n}\n\nreturn EVAL_PAGE;\n}\n\/* not a match? *\/\nif (!this.isMatch()) {\n\/\/ -- ignore\nreturn EVAL_PAGE;\n}\n\/\/ --------------------------------------------------------------------\n\/* \"onload='...'\" *\/\nif (s.equalsIgnoreCase(SECTION_BODY_ONLOAD)) {\nString bodyOnLoad = (String)request.getAttribute(SECTION_BODY_ONLOAD);\nif (!StringTools.isBlank(bodyOnLoad)) {\ntry {\nout.print(bodyOnLoad);\n} catch (IOException ioe) {\nthrow new JspTagException(ioe.toString());\n}\n}\nreturn EVAL_PAGE;\n}\n\/* \"onunload='...'\" *\/\nif (s.equalsIgnoreCase(SECTION_BODY_ONUNLOAD)) {\nString bodyOnUnload = (String)request.getAttribute(SECTION_BODY_ONUNLOAD);\nif (!StringTools.isBlank(bodyOnUnload)) {\ntry {\nout.print(bodyOnUnload);\n} catch (IOException ioe) {\nthrow new JspTagException(ioe.toString());\n}\n}\nreturn EVAL_PAGE;\n}\n\/\/ --------------------------------------------------------------------\n\/* expandMenu style *\/\nif (s.equalsIgnoreCase(SECTION_MENU_STYLE)) {\ntry {\nExpandMenu.writeStyle(out, reqState);\n} catch (IOException ioe) {\nthrow new JspTagException(ioe.toString());\n}\nreturn EVAL_PAGE;\n\npublic int doEndTag()\nthrows JspTagException\n{\nHttpServletRequest request = (HttpServletRequest)super.pageContext.getRequest();\nRequestProperties reqState = (RequestProperties)request.getAttribute(SECTION_REQUESTPROPS);\nPrivateLabel privLabel = (reqState != null)? reqState.getPrivateLabel() : RequestProperties.NullPrivateLabel;\nJspWriter out = super.pageContext.getOut();\nString s = this.getSection().toLowerCase();\n\/* ignore blank section definitions *\/\nif (StringTools.isBlank(s)) {\n\/\/ -- ignore\nreturn EVAL_PAGE;\n}\n\/* not a match? *\/\nif (!this.isMatch()) {\n\/\/ -- ignore\nreturn EVAL_PAGE;\n}\n\/\/ --------------------------------------------------------------------\n\/* \"onload='...'\" *\/\nif (s.equalsIgnoreCase(SECTION_BODY_ONLOAD)) {\nString bodyOnLoad = (String)request.getAttribute(SECTION_BODY_ONLOAD);\nif (!StringTools.isBlank(bodyOnLoad)) {\ntry {\nout.print(bodyOnLoad);\n} catch (IOException ioe) {\nthrow new JspTagException(ioe.toString());\n}\n}\nreturn EVAL_PAGE;\n}\n\/* \"onunload='...'\" *\/\nif (s.equalsIgnoreCase(SECTION_BODY_ONUNLOAD)) {\nString bodyOnUnload = (String)request.getAttribute(SECTION_BODY_ONUNLOAD);\nif (!StringTools.isBlank(bodyOnUnload)) {\ntry {\nout.print(bodyOnUnload);\n} catch (IOException ioe) {\nthrow new JspTagException(ioe.toString());\n}\n\nString bodyOnUnload = (String)request.getAttribute(SECTION_BODY_ONUNLOAD);\nif (!StringTools.isBlank(bodyOnUnload)) {\ntry {\nout.print(bodyOnUnload);\n} catch (IOException ioe) {\nthrow new JspTagException(ioe.toString());\n}\n}\nreturn EVAL_PAGE;\n}\n\/\/ --------------------------------------------------------------------\n\/* expandMenu style *\/\nif (s.equalsIgnoreCase(SECTION_MENU_STYLE)) {\ntry {\nExpandMenu.writeStyle(out, reqState);\n} catch (IOException ioe) {\nthrow new JspTagException(ioe.toString());\n}\nreturn EVAL_PAGE;\n}\n\/* expandMenu javascript *\/\nif (s.equalsIgnoreCase(SECTION_MENU_JAVASCRIPT)) {\ntry {\nExpandMenu.writeJavaScript(out, reqState);\n} catch (IOException ioe) {\nthrow new JspTagException(ioe.toString());\n}\nreturn EVAL_PAGE;\n}\n\/* expandMenu *\/\nif (s.equalsIgnoreCase(SECTION_MENU)) {\ntry {\nExpandMenu.writeMenu(out, reqState,\nnull\/*menuID*\/, true\/*expandableMenu*\/,\nfalse\/*showIcon*\/, ExpandMenu.DESC_LONG, false\/*showMenuHelp*\/);\n} catch (IOException ioe) {\nthrow new JspTagException(ioe.toString());\n}\nreturn EVAL_PAGE;\n}\n\/\/ --------------------------------------------------------------------\n\n}\n\/\/ --------------------------------------------------------------------\n\/* expandMenu style *\/\nif (s.equalsIgnoreCase(SECTION_MENU_STYLE)) {\ntry {\nExpandMenu.writeStyle(out, reqState);\n} catch (IOException ioe) {\nthrow new JspTagException(ioe.toString());\n}\nreturn EVAL_PAGE;\n}\n\/* expandMenu javascript *\/\nif (s.equalsIgnoreCase(SECTION_MENU_JAVASCRIPT)) {\ntry {\nExpandMenu.writeJavaScript(out, reqState);\n} catch (IOException ioe) {\nthrow new JspTagException(ioe.toString());\n}\nreturn EVAL_PAGE;\n}\n\/* expandMenu *\/\nif (s.equalsIgnoreCase(SECTION_MENU)) {\ntry {\nExpandMenu.writeMenu(out, reqState,\nnull\/*menuID*\/, true\/*expandableMenu*\/,\nfalse\/*showIcon*\/, ExpandMenu.DESC_LONG, false\/*showMenuHelp*\/);\n} catch (IOException ioe) {\nthrow new JspTagException(ioe.toString());\n}\nreturn EVAL_PAGE;\n}\n\/\/ --------------------------------------------------------------------\n\/* content table class *\/\nif (s.equalsIgnoreCase(SECTION_CONTENT_CLASS_TABLE)) {\nHTMLOutput content = (HTMLOutput)request.getAttribute(SECTION_CONTENT_BODY);\nif (content != null) {\ntry {\nString tableClass = content.getTableClass();\nout.write(!StringTools.isBlank(tableClass)? tableClass : \"contentTableClass\");\n} catch (IOException ioe) {\nthrow new JspTagException(ioe.toString());\n\ntry {\nExpandMenu.writeStyle(out, reqState);\n} catch (IOException ioe) {\nthrow new JspTagException(ioe.toString());\n}\nreturn EVAL_PAGE;\n}\n\/* expandMenu javascript *\/\nif (s.equalsIgnoreCase(SECTION_MENU_JAVASCRIPT)) {\ntry {\nExpandMenu.writeJavaScript(out, reqState);\n} catch (IOException ioe) {\nthrow new JspTagException(ioe.toString());\n}\nreturn EVAL_PAGE;\n}\n\/* expandMenu *\/\nif (s.equalsIgnoreCase(SECTION_MENU)) {\ntry {\nExpandMenu.writeMenu(out, reqState,\nnull\/*menuID*\/, true\/*expandableMenu*\/,\nfalse\/*showIcon*\/, ExpandMenu.DESC_LONG, false\/*showMenuHelp*\/);\n} catch (IOException ioe) {\nthrow new JspTagException(ioe.toString());\n}\nreturn EVAL_PAGE;\n}\n\/\/ --------------------------------------------------------------------\n\/* content table class *\/\nif (s.equalsIgnoreCase(SECTION_CONTENT_CLASS_TABLE)) {\nHTMLOutput content = (HTMLOutput)request.getAttribute(SECTION_CONTENT_BODY);\nif (content != null) {\ntry {\nString tableClass = content.getTableClass();\nout.write(!StringTools.isBlank(tableClass)? tableClass : \"contentTableClass\");\n} catch (IOException ioe) {\nthrow new JspTagException(ioe.toString());\n}\n}\nreturn EVAL_PAGE;\n}\n\ntry {\nExpandMenu.writeStyle(out, reqState);\n} catch (IOException ioe) {\nthrow new JspTagException(ioe.toString());\n}\nreturn EVAL_PAGE;\n}\n\/* expandMenu javascript *\/\nif (s.equalsIgnoreCase(SECTION_MENU_JAVASCRIPT)) {\ntry {\nExpandMenu.writeJavaScript(out, reqState);\n} catch (IOException ioe) {\nthrow new JspTagException(ioe.toString());\n}\nreturn EVAL_PAGE;\n}\n\/* expandMenu *\/\nif (s.equalsIgnoreCase(SECTION_MENU)) {\ntry {\nExpandMenu.writeMenu(out, reqState,\nnull\/*menuID*\/, true\/*expandableMenu*\/,\nfalse\/*showIcon*\/, ExpandMenu.DESC_LONG, false\/*showMenuHelp*\/);\n} catch (IOException ioe) {\nthrow new JspTagException(ioe.toString());\n}\nreturn EVAL_PAGE;\n}\n\/\/ --------------------------------------------------------------------\n\/* content table class *\/\nif (s.equalsIgnoreCase(SECTION_CONTENT_CLASS_TABLE)) {\nHTMLOutput content = (HTMLOutput)request.getAttribute(SECTION_CONTENT_BODY);\nif (content != null) {\ntry {\nString tableClass = content.getTableClass();\nout.write(!StringTools.isBlank(tableClass)? tableClass : \"contentTableClass\");\n} catch (IOException ioe) {\nthrow new JspTagException(ioe.toString());\n}\n}\nreturn EVAL_PAGE;\n}\n\nExpandMenu.writeStyle(out, reqState);\n} catch (IOException ioe) {\nthrow new JspTagException(ioe.toString());\n}\nreturn EVAL_PAGE;\n}\n\/* expandMenu javascript *\/\nif (s.equalsIgnoreCase(SECTION_MENU_JAVASCRIPT)) {\ntry {\nExpandMenu.writeJavaScript(out, reqState);\n} catch (IOException ioe) {\nthrow new JspTagException(ioe.toString());\n}\nreturn EVAL_PAGE;\n}\n\/* expandMenu *\/\nif (s.equalsIgnoreCase(SECTION_MENU)) {\ntry {\nExpandMenu.writeMenu(out, reqState,\nnull\/*menuID*\/, true\/*expandableMenu*\/,\nfalse\/*showIcon*\/, ExpandMenu.DESC_LONG, false\/*showMenuHelp*\/);\n} catch (IOException ioe) {\nthrow new JspTagException(ioe.toString());\n}\nreturn EVAL_PAGE;\n}\n\/\/ --------------------------------------------------------------------\n\/* content table class *\/\nif (s.equalsIgnoreCase(SECTION_CONTENT_CLASS_TABLE)) {\nHTMLOutput content = (HTMLOutput)request.getAttribute(SECTION_CONTENT_BODY);\nif (content != null) {\ntry {\nString tableClass = content.getTableClass();\nout.write(!StringTools.isBlank(tableClass)? tableClass : \"contentTableClass\");\n} catch (IOException ioe) {\nthrow new JspTagException(ioe.toString());\n}\n}\nreturn EVAL_PAGE;\n}\n\/* content cell class *\/\n\nExpandMenu.writeStyle(out, reqState);\n} catch (IOException ioe) {\nthrow new JspTagException(ioe.toString());\n}\nreturn EVAL_PAGE;\n}\n\/* expandMenu javascript *\/\nif (s.equalsIgnoreCase(SECTION_MENU_JAVASCRIPT)) {\ntry {\nExpandMenu.writeJavaScript(out, reqState);\n} catch (IOException ioe) {\nthrow new JspTagException(ioe.toString());\n}\nreturn EVAL_PAGE;\n}\n\/* expandMenu *\/\nif (s.equalsIgnoreCase(SECTION_MENU)) {\ntry {\nExpandMenu.writeMenu(out, reqState,\nnull\/*menuID*\/, true\/*expandableMenu*\/,\nfalse\/*showIcon*\/, ExpandMenu.DESC_LONG, false\/*showMenuHelp*\/);\n} catch (IOException ioe) {\nthrow new JspTagException(ioe.toString());\n}\nreturn EVAL_PAGE;\n}\n\/\/ --------------------------------------------------------------------\n\/* content table class *\/\nif (s.equalsIgnoreCase(SECTION_CONTENT_CLASS_TABLE)) {\nHTMLOutput content = (HTMLOutput)request.getAttribute(SECTION_CONTENT_BODY);\nif (content != null) {\ntry {\nString tableClass = content.getTableClass();\nout.write(!StringTools.isBlank(tableClass)? tableClass : \"contentTableClass\");\n} catch (IOException ioe) {\nthrow new JspTagException(ioe.toString());\n}\n}\nreturn EVAL_PAGE;\n}\n\/* content cell class *\/\n\npublic int doEndTag()\nthrows JspTagException\n{\nHttpServletRequest request = (HttpServletRequest)super.pageContext.getRequest();\nRequestProperties reqState = (RequestProperties)request.getAttribute(SECTION_REQUESTPROPS);\nPrivateLabel privLabel = (reqState != null)? reqState.getPrivateLabel() : RequestProperties.NullPrivateLabel;\nJspWriter out = super.pageContext.getOut();\nString s = this.getSection().toLowerCase();\n\/* ignore blank section definitions *\/\nif (StringTools.isBlank(s)) {\n\/\/ -- ignore\nreturn EVAL_PAGE;\n}\n\/* not a match? *\/\nif (!this.isMatch()) {\n\/\/ -- ignore\nreturn EVAL_PAGE;\n}\n\/\/ --------------------------------------------------------------------\n\/* \"onload='...'\" *\/\nif (s.equalsIgnoreCase(SECTION_BODY_ONLOAD)) {\nString bodyOnLoad = (String)request.getAttribute(SECTION_BODY_ONLOAD);\nif (!StringTools.isBlank(bodyOnLoad)) {\ntry {\nout.print(bodyOnLoad);\n} catch (IOException ioe) {\nthrow new JspTagException(ioe.toString());\n}\n}\nreturn EVAL_PAGE;\n}\n\/* \"onunload='...'\" *\/\nif (s.equalsIgnoreCase(SECTION_BODY_ONUNLOAD)) {\nString bodyOnUnload = (String)request.getAttribute(SECTION_BODY_ONUNLOAD);\nif (!StringTools.isBlank(bodyOnUnload)) {\ntry {\nout.print(bodyOnUnload);\n} catch (IOException ioe) {\nthrow new JspTagException(ioe.toString());\n}\n\nfalse\/*showIcon*\/, ExpandMenu.DESC_LONG, false\/*showMenuHelp*\/);\n} catch (IOException ioe) {\nthrow new JspTagException(ioe.toString());\n}\nreturn EVAL_PAGE;\n}\n\/\/ --------------------------------------------------------------------\n\/* content table class *\/\nif (s.equalsIgnoreCase(SECTION_CONTENT_CLASS_TABLE)) {\nHTMLOutput content = (HTMLOutput)request.getAttribute(SECTION_CONTENT_BODY);\nif (content != null) {\ntry {\nString tableClass = content.getTableClass();\nout.write(!StringTools.isBlank(tableClass)? tableClass : \"contentTableClass\");\n} catch (IOException ioe) {\nthrow new JspTagException(ioe.toString());\n}\n}\nreturn EVAL_PAGE;\n}\n\/* content cell class *\/\nif (s.equalsIgnoreCase(SECTION_CONTENT_CLASS_CELL)) {\nHTMLOutput content = (HTMLOutput)request.getAttribute(SECTION_CONTENT_BODY);\nif (content != null) {\ntry {\nString cellClass = content.getCellClass();\nout.write(!StringTools.isBlank(cellClass)? cellClass : \"contentCellClass\");\n} catch (IOException ioe) {\nthrow new JspTagException(ioe.toString());\n}\n}\nreturn EVAL_PAGE;\n}\n\/* content message id *\/\nif (s.equalsIgnoreCase(SECTION_CONTENT_ID_MESSAGE)) {\ntry {\nout.write(CommonServlet.ID_CONTENT_MESSAGE);\n} catch (IOException ioe) {\nthrow new JspTagException(ioe.toString());\n}\nreturn EVAL_PAGE;\n\nout.write(!StringTools.isBlank(tableClass)? tableClass : \"contentTableClass\");\n} catch (IOException ioe) {\nthrow new JspTagException(ioe.toString());\n}\n}\nreturn EVAL_PAGE;\n}\n\/* content cell class *\/\nif (s.equalsIgnoreCase(SECTION_CONTENT_CLASS_CELL)) {\nHTMLOutput content = (HTMLOutput)request.getAttribute(SECTION_CONTENT_BODY);\nif (content != null) {\ntry {\nString cellClass = content.getCellClass();\nout.write(!StringTools.isBlank(cellClass)? cellClass : \"contentCellClass\");\n} catch (IOException ioe) {\nthrow new JspTagException(ioe.toString());\n}\n}\nreturn EVAL_PAGE;\n}\n\/* content message id *\/\nif (s.equalsIgnoreCase(SECTION_CONTENT_ID_MESSAGE)) {\ntry {\nout.write(CommonServlet.ID_CONTENT_MESSAGE);\n} catch (IOException ioe) {\nthrow new JspTagException(ioe.toString());\n}\nreturn EVAL_PAGE;\n}\n\/* content message class *\/\nif (s.equalsIgnoreCase(SECTION_CONTENT_CLASS_MESSAGE)) {\ntry {\nout.write(CommonServlet.CSS_CONTENT_MESSAGE);\n} catch (IOException ioe) {\nthrow new JspTagException(ioe.toString());\n}\nreturn EVAL_PAGE;\n}\n\/* content menubar *\/\nif (s.equalsIgnoreCase(SECTION_CONTENT_MENUBAR)) {\nHTMLOutput content = (HTMLOutput)request.getAttribute(SECTION_CONTENT_BODY);\n\nHTMLOutput content = (HTMLOutput)request.getAttribute(SECTION_CONTENT_BODY);\nif (content != null) {\ntry {\nString cellClass = content.getCellClass();\nout.write(!StringTools.isBlank(cellClass)? cellClass : \"contentCellClass\");\n} catch (IOException ioe) {\nthrow new JspTagException(ioe.toString());\n}\n}\nreturn EVAL_PAGE;\n}\n\/* content message id *\/\nif (s.equalsIgnoreCase(SECTION_CONTENT_ID_MESSAGE)) {\ntry {\nout.write(CommonServlet.ID_CONTENT_MESSAGE);\n} catch (IOException ioe) {\nthrow new JspTagException(ioe.toString());\n}\nreturn EVAL_PAGE;\n}\n\/* content message class *\/\nif (s.equalsIgnoreCase(SECTION_CONTENT_CLASS_MESSAGE)) {\ntry {\nout.write(CommonServlet.CSS_CONTENT_MESSAGE);\n} catch (IOException ioe) {\nthrow new JspTagException(ioe.toString());\n}\nreturn EVAL_PAGE;\n}\n\/* content menubar *\/\nif (s.equalsIgnoreCase(SECTION_CONTENT_MENUBAR)) {\nHTMLOutput content = (HTMLOutput)request.getAttribute(SECTION_CONTENT_BODY);\nif (content != null) {\nString contentClass = content.getTableClass();\ntry {\nif (ListTools.contains(CommonServlet.CSS_MENUBAR_OK,contentClass)) {\nMenuBar.writeTableRow(out, reqState.getPageName(), reqState);\n} else {\nout.write(\"<!-- no menubar ['\"+contentClass+\"'] -->\");\n}\n} catch (IOException ioe) {\n\nreturn EVAL_PAGE;\n}\n\/* content message id *\/\nif (s.equalsIgnoreCase(SECTION_CONTENT_ID_MESSAGE)) {\ntry {\nout.write(CommonServlet.ID_CONTENT_MESSAGE);\n} catch (IOException ioe) {\nthrow new JspTagException(ioe.toString());\n}\nreturn EVAL_PAGE;\n}\n\/* content message class *\/\nif (s.equalsIgnoreCase(SECTION_CONTENT_CLASS_MESSAGE)) {\ntry {\nout.write(CommonServlet.CSS_CONTENT_MESSAGE);\n} catch (IOException ioe) {\nthrow new JspTagException(ioe.toString());\n}\nreturn EVAL_PAGE;\n}\n\/* content menubar *\/\nif (s.equalsIgnoreCase(SECTION_CONTENT_MENUBAR)) {\nHTMLOutput content = (HTMLOutput)request.getAttribute(SECTION_CONTENT_BODY);\nif (content != null) {\nString contentClass = content.getTableClass();\ntry {\nif (ListTools.contains(CommonServlet.CSS_MENUBAR_OK,contentClass)) {\nMenuBar.writeTableRow(out, reqState.getPageName(), reqState);\n} else {\nout.write(\"<!-- no menubar ['\"+contentClass+\"'] -->\");\n}\n} catch (IOException ioe) {\nthrow new JspTagException(ioe.toString());\n}\n}\nreturn EVAL_PAGE;\n}\n\/* content message *\/\nif (s.equalsIgnoreCase(SECTION_CONTENT_MESSAGE)) {\nHTMLOutput content = (HTMLOutput)request.getAttribute(SECTION_CONTENT_BODY);\nString msg = (content != null)? StringTools.trim(content.getTableMessage()) : \"\";\n\n}\nreturn EVAL_PAGE;\n}\n\/* content menubar *\/\nif (s.equalsIgnoreCase(SECTION_CONTENT_MENUBAR)) {\nHTMLOutput content = (HTMLOutput)request.getAttribute(SECTION_CONTENT_BODY);\nif (content != null) {\nString contentClass = content.getTableClass();\ntry {\nif (ListTools.contains(CommonServlet.CSS_MENUBAR_OK,contentClass)) {\nMenuBar.writeTableRow(out, reqState.getPageName(), reqState);\n} else {\nout.write(\"<!-- no menubar ['\"+contentClass+\"'] -->\");\n}\n} catch (IOException ioe) {\nthrow new JspTagException(ioe.toString());\n}\n}\nreturn EVAL_PAGE;\n}\n\/* content message *\/\nif (s.equalsIgnoreCase(SECTION_CONTENT_MESSAGE)) {\nHTMLOutput content = (HTMLOutput)request.getAttribute(SECTION_CONTENT_BODY);\nString msg = (content != null)? StringTools.trim(content.getTableMessage()) : \"\";\ntry {\nout.write(msg); \/\/ TODO: HTML encode?\n} catch (IOException ioe) {\nthrow new JspTagException(ioe.toString());\n}\nreturn EVAL_PAGE;\n}\n\/\/ --------------------------------------------------------------------\n\/* request context path *\/\nif (s.equalsIgnoreCase(SECTION_REQUEST_CONTEXT)) {\ntry {\nout.write(request.getContextPath());\n} catch (IOException ioe) {\nthrow new JspTagException(ioe.toString());\n}\nreturn EVAL_PAGE;\n}\n\nHTMLOutput content = (HTMLOutput)request.getAttribute(SECTION_CONTENT_BODY);\nif (content != null) {\nString contentClass = content.getTableClass();\ntry {\nif (ListTools.contains(CommonServlet.CSS_MENUBAR_OK,contentClass)) {\nMenuBar.writeTableRow(out, reqState.getPageName(), reqState);\n} else {\nout.write(\"<!-- no menubar ['\"+contentClass+\"'] -->\");\n}\n} catch (IOException ioe) {\nthrow new JspTagException(ioe.toString());\n}\n}\nreturn EVAL_PAGE;\n}\n\/* content message *\/\nif (s.equalsIgnoreCase(SECTION_CONTENT_MESSAGE)) {\nHTMLOutput content = (HTMLOutput)request.getAttribute(SECTION_CONTENT_BODY);\nString msg = (content != null)? StringTools.trim(content.getTableMessage()) : \"\";\ntry {\nout.write(msg); \/\/ TODO: HTML encode?\n} catch (IOException ioe) {\nthrow new JspTagException(ioe.toString());\n}\nreturn EVAL_PAGE;\n}\n\/\/ --------------------------------------------------------------------\n\/* request context path *\/\nif (s.equalsIgnoreCase(SECTION_REQUEST_CONTEXT)) {\ntry {\nout.write(request.getContextPath());\n} catch (IOException ioe) {\nthrow new JspTagException(ioe.toString());\n}\nreturn EVAL_PAGE;\n}\n\/\/ --------------------------------------------------------------------\n\/* CSS file *\/\nif (s.equalsIgnoreCase(SECTION_CSSFILE)) {\nString cssFilePath = this.getArg();\nif (!StringTools.isBlank(cssFilePath)) {\n\npublic int doEndTag()\nthrows JspTagException\n{\nHttpServletRequest request = (HttpServletRequest)super.pageContext.getRequest();\nRequestProperties reqState = (RequestProperties)request.getAttribute(SECTION_REQUESTPROPS);\nPrivateLabel privLabel = (reqState != null)? reqState.getPrivateLabel() : RequestProperties.NullPrivateLabel;\nJspWriter out = super.pageContext.getOut();\nString s = this.getSection().toLowerCase();\n\/* ignore blank section definitions *\/\nif (StringTools.isBlank(s)) {\n\/\/ -- ignore\nreturn EVAL_PAGE;\n}\n\/* not a match? *\/\nif (!this.isMatch()) {\n\/\/ -- ignore\nreturn EVAL_PAGE;\n}\n\/\/ --------------------------------------------------------------------\n\/* \"onload='...'\" *\/\nif (s.equalsIgnoreCase(SECTION_BODY_ONLOAD)) {\nString bodyOnLoad = (String)request.getAttribute(SECTION_BODY_ONLOAD);\nif (!StringTools.isBlank(bodyOnLoad)) {\ntry {\nout.print(bodyOnLoad);\n} catch (IOException ioe) {\nthrow new JspTagException(ioe.toString());\n}\n}\nreturn EVAL_PAGE;\n}\n\/* \"onunload='...'\" *\/\nif (s.equalsIgnoreCase(SECTION_BODY_ONUNLOAD)) {\nString bodyOnUnload = (String)request.getAttribute(SECTION_BODY_ONUNLOAD);\nif (!StringTools.isBlank(bodyOnUnload)) {\ntry {\nout.print(bodyOnUnload);\n} catch (IOException ioe) {\nthrow new JspTagException(ioe.toString());\n}\n\npublic int doEndTag()\nthrows JspTagException\n{\nHttpServletRequest request = (HttpServletRequest)super.pageContext.getRequest();\nRequestProperties reqState = (RequestProperties)request.getAttribute(SECTION_REQUESTPROPS);\nPrivateLabel privLabel = (reqState != null)? reqState.getPrivateLabel() : RequestProperties.NullPrivateLabel;\nJspWriter out = super.pageContext.getOut();\nString s = this.getSection().toLowerCase();\n\/* ignore blank section definitions *\/\nif (StringTools.isBlank(s)) {\n\/\/ -- ignore\nreturn EVAL_PAGE;\n}\n\/* not a match? *\/\nif (!this.isMatch()) {\n\/\/ -- ignore\nreturn EVAL_PAGE;\n}\n\/\/ --------------------------------------------------------------------\n\/* \"onload='...'\" *\/\nif (s.equalsIgnoreCase(SECTION_BODY_ONLOAD)) {\nString bodyOnLoad = (String)request.getAttribute(SECTION_BODY_ONLOAD);\nif (!StringTools.isBlank(bodyOnLoad)) {\ntry {\nout.print(bodyOnLoad);\n} catch (IOException ioe) {\nthrow new JspTagException(ioe.toString());\n}\n}\nreturn EVAL_PAGE;\n}\n\/* \"onunload='...'\" *\/\nif (s.equalsIgnoreCase(SECTION_BODY_ONUNLOAD)) {\nString bodyOnUnload = (String)request.getAttribute(SECTION_BODY_ONUNLOAD);\nif (!StringTools.isBlank(bodyOnUnload)) {\ntry {\nout.print(bodyOnUnload);\n} catch (IOException ioe) {\nthrow new JspTagException(ioe.toString());\n}\n\npublic int doEndTag()\nthrows JspTagException\n{\nHttpServletRequest request = (HttpServletRequest)super.pageContext.getRequest();\nRequestProperties reqState = (RequestProperties)request.getAttribute(SECTION_REQUESTPROPS);\nPrivateLabel privLabel = (reqState != null)? reqState.getPrivateLabel() : RequestProperties.NullPrivateLabel;\nJspWriter out = super.pageContext.getOut();\nString s = this.getSection().toLowerCase();\n\/* ignore blank section definitions *\/\nif (StringTools.isBlank(s)) {\n\/\/ -- ignore\nreturn EVAL_PAGE;\n}\n\/* not a match? *\/\nif (!this.isMatch()) {\n\/\/ -- ignore\nreturn EVAL_PAGE;\n}\n\/\/ --------------------------------------------------------------------\n\/* \"onload='...'\" *\/\nif (s.equalsIgnoreCase(SECTION_BODY_ONLOAD)) {\nString bodyOnLoad = (String)request.getAttribute(SECTION_BODY_ONLOAD);\nif (!StringTools.isBlank(bodyOnLoad)) {\ntry {\nout.print(bodyOnLoad);\n} catch (IOException ioe) {\nthrow new JspTagException(ioe.toString());\n}\n}\nreturn EVAL_PAGE;\n}\n\/* \"onunload='...'\" *\/\nif (s.equalsIgnoreCase(SECTION_BODY_ONUNLOAD)) {\nString bodyOnUnload = (String)request.getAttribute(SECTION_BODY_ONUNLOAD);\nif (!StringTools.isBlank(bodyOnUnload)) {\ntry {\nout.print(bodyOnUnload);\n} catch (IOException ioe) {\nthrow new JspTagException(ioe.toString());\n}\n\n}\nreturn EVAL_PAGE;\n}\n\/\/ --------------------------------------------------------------------\n\/* CSS file *\/\nif (s.equalsIgnoreCase(SECTION_CSSFILE)) {\nString cssFilePath = this.getArg();\nif (!StringTools.isBlank(cssFilePath)) {\ntry {\nPrintWriter pw = new PrintWriter(out, out.isAutoFlush());\nWebPageAdaptor.writeCssLink(pw, reqState, cssFilePath, null);\n} catch (IOException ioe) {\nthrow new JspTagException(ioe.toString());\n}\n}\nreturn EVAL_PAGE;\n}\n\/\/ --------------------------------------------------------------------\n\/* Banner Image Height *\/\nif (s.equalsIgnoreCase(SECTION_BANNER_WIDTH)) {\n\/\/ key suffix\nString kSfx = StringTools.trim(this.getArg());\n\/\/ property values\nString bannerWidth = privLabel.getStringProperty(PrivateLabel.PROP_Banner_width + kSfx, null);\nif (StringTools.isBlank(bannerWidth)) {\nbannerWidth = privLabel.getStringProperty(PrivateLabel.PROP_Banner_imageWidth + kSfx, null);\n}\n\/\/ minimum valie\nif (StringTools.isBlank(bannerWidth)) {\nbannerWidth = this.hasDefault()? this.getDefault() : \"100%\";\n} else\nif (!bannerWidth.endsWith(\"%\")) {\nint W = StringTools.parseInt(bannerWidth, 0);\nbannerWidth = String.valueOf((W < MIN_BANNER_WIDTH)? MIN_BANNER_WIDTH : W);\n}\n\/\/ generate html\ntry {\nout.write(bannerWidth);\n} catch (IOException ioe) {\nthrow new JspTagException(ioe.toString());\n}\n\n}\n\/\/ --------------------------------------------------------------------\n\/* CSS file *\/\nif (s.equalsIgnoreCase(SECTION_CSSFILE)) {\nString cssFilePath = this.getArg();\nif (!StringTools.isBlank(cssFilePath)) {\ntry {\nPrintWriter pw = new PrintWriter(out, out.isAutoFlush());\nWebPageAdaptor.writeCssLink(pw, reqState, cssFilePath, null);\n} catch (IOException ioe) {\nthrow new JspTagException(ioe.toString());\n}\n}\nreturn EVAL_PAGE;\n}\n\/\/ --------------------------------------------------------------------\n\/* Banner Image Height *\/\nif (s.equalsIgnoreCase(SECTION_BANNER_WIDTH)) {\n\/\/ key suffix\nString kSfx = StringTools.trim(this.getArg());\n\/\/ property values\nString bannerWidth = privLabel.getStringProperty(PrivateLabel.PROP_Banner_width + kSfx, null);\nif (StringTools.isBlank(bannerWidth)) {\nbannerWidth = privLabel.getStringProperty(PrivateLabel.PROP_Banner_imageWidth + kSfx, null);\n}\n\/\/ minimum valie\nif (StringTools.isBlank(bannerWidth)) {\nbannerWidth = this.hasDefault()? this.getDefault() : \"100%\";\n} else\nif (!bannerWidth.endsWith(\"%\")) {\nint W = StringTools.parseInt(bannerWidth, 0);\nbannerWidth = String.valueOf((W < MIN_BANNER_WIDTH)? MIN_BANNER_WIDTH : W);\n}\n\/\/ generate html\ntry {\nout.write(bannerWidth);\n} catch (IOException ioe) {\nthrow new JspTagException(ioe.toString());\n}\nreturn EVAL_PAGE;\n}\n\nif (!StringTools.isBlank(cssFilePath)) {\ntry {\nPrintWriter pw = new PrintWriter(out, out.isAutoFlush());\nWebPageAdaptor.writeCssLink(pw, reqState, cssFilePath, null);\n} catch (IOException ioe) {\nthrow new JspTagException(ioe.toString());\n}\n}\nreturn EVAL_PAGE;\n}\n\/\/ --------------------------------------------------------------------\n\/* Banner Image Height *\/\nif (s.equalsIgnoreCase(SECTION_BANNER_WIDTH)) {\n\/\/ key suffix\nString kSfx = StringTools.trim(this.getArg());\n\/\/ property values\nString bannerWidth = privLabel.getStringProperty(PrivateLabel.PROP_Banner_width + kSfx, null);\nif (StringTools.isBlank(bannerWidth)) {\nbannerWidth = privLabel.getStringProperty(PrivateLabel.PROP_Banner_imageWidth + kSfx, null);\n}\n\/\/ minimum valie\nif (StringTools.isBlank(bannerWidth)) {\nbannerWidth = this.hasDefault()? this.getDefault() : \"100%\";\n} else\nif (!bannerWidth.endsWith(\"%\")) {\nint W = StringTools.parseInt(bannerWidth, 0);\nbannerWidth = String.valueOf((W < MIN_BANNER_WIDTH)? MIN_BANNER_WIDTH : W);\n}\n\/\/ generate html\ntry {\nout.write(bannerWidth);\n} catch (IOException ioe) {\nthrow new JspTagException(ioe.toString());\n}\nreturn EVAL_PAGE;\n}\n\/* Banner Style *\/\nif (s.equalsIgnoreCase(SECTION_BANNER_STYLE)) {\n\/\/ key suffix\nString kSfx = StringTools.trim(this.getArg());\n\/\/ property values\n\nreturn EVAL_PAGE;\n}\n\/\/ --------------------------------------------------------------------\n\/* Banner Image Height *\/\nif (s.equalsIgnoreCase(SECTION_BANNER_WIDTH)) {\n\/\/ key suffix\nString kSfx = StringTools.trim(this.getArg());\n\/\/ property values\nString bannerWidth = privLabel.getStringProperty(PrivateLabel.PROP_Banner_width + kSfx, null);\nif (StringTools.isBlank(bannerWidth)) {\nbannerWidth = privLabel.getStringProperty(PrivateLabel.PROP_Banner_imageWidth + kSfx, null);\n}\n\/\/ minimum valie\nif (StringTools.isBlank(bannerWidth)) {\nbannerWidth = this.hasDefault()? this.getDefault() : \"100%\";\n} else\nif (!bannerWidth.endsWith(\"%\")) {\nint W = StringTools.parseInt(bannerWidth, 0);\nbannerWidth = String.valueOf((W < MIN_BANNER_WIDTH)? MIN_BANNER_WIDTH : W);\n}\n\/\/ generate html\ntry {\nout.write(bannerWidth);\n} catch (IOException ioe) {\nthrow new JspTagException(ioe.toString());\n}\nreturn EVAL_PAGE;\n}\n\/* Banner Style *\/\nif (s.equalsIgnoreCase(SECTION_BANNER_STYLE)) {\n\/\/ key suffix\nString kSfx = StringTools.trim(this.getArg());\n\/\/ property values\nString bannerStyle = privLabel.getStringProperty(PrivateLabel.PROP_Banner_style + kSfx, null);\n\/\/ generate html\nif (!StringTools.isBlank(bannerStyle)) {\ntry {\nout.write(bannerStyle);\n} catch (IOException ioe) {\nthrow new JspTagException(ioe.toString());\n}\n\nString bannerWidth = privLabel.getStringProperty(PrivateLabel.PROP_Banner_width + kSfx, null);\nif (StringTools.isBlank(bannerWidth)) {\nbannerWidth = privLabel.getStringProperty(PrivateLabel.PROP_Banner_imageWidth + kSfx, null);\n}\n\/\/ minimum valie\nif (StringTools.isBlank(bannerWidth)) {\nbannerWidth = this.hasDefault()? this.getDefault() : \"100%\";\n} else\nif (!bannerWidth.endsWith(\"%\")) {\nint W = StringTools.parseInt(bannerWidth, 0);\nbannerWidth = String.valueOf((W < MIN_BANNER_WIDTH)? MIN_BANNER_WIDTH : W);\n}\n\/\/ generate html\ntry {\nout.write(bannerWidth);\n} catch (IOException ioe) {\nthrow new JspTagException(ioe.toString());\n}\nreturn EVAL_PAGE;\n}\n\/* Banner Style *\/\nif (s.equalsIgnoreCase(SECTION_BANNER_STYLE)) {\n\/\/ key suffix\nString kSfx = StringTools.trim(this.getArg());\n\/\/ property values\nString bannerStyle = privLabel.getStringProperty(PrivateLabel.PROP_Banner_style + kSfx, null);\n\/\/ generate html\nif (!StringTools.isBlank(bannerStyle)) {\ntry {\nout.write(bannerStyle);\n} catch (IOException ioe) {\nthrow new JspTagException(ioe.toString());\n}\n} else\nif (this.hasDefault()) {\ntry {\nout.write(this.getDefault());\n} catch (IOException ioe) {\nthrow new JspTagException(ioe.toString());\n}\n}\n\n}\nreturn EVAL_PAGE;\n}\n\/\/ --------------------------------------------------------------------\n\/* CSS file *\/\nif (s.equalsIgnoreCase(SECTION_CSSFILE)) {\nString cssFilePath = this.getArg();\nif (!StringTools.isBlank(cssFilePath)) {\ntry {\nPrintWriter pw = new PrintWriter(out, out.isAutoFlush());\nWebPageAdaptor.writeCssLink(pw, reqState, cssFilePath, null);\n} catch (IOException ioe) {\nthrow new JspTagException(ioe.toString());\n}\n}\nreturn EVAL_PAGE;\n}\n\/\/ --------------------------------------------------------------------\n\/* Banner Image Height *\/\nif (s.equalsIgnoreCase(SECTION_BANNER_WIDTH)) {\n\/\/ key suffix\nString kSfx = StringTools.trim(this.getArg());\n\/\/ property values\nString bannerWidth = privLabel.getStringProperty(PrivateLabel.PROP_Banner_width + kSfx, null);\nif (StringTools.isBlank(bannerWidth)) {\nbannerWidth = privLabel.getStringProperty(PrivateLabel.PROP_Banner_imageWidth + kSfx, null);\n}\n\/\/ minimum valie\nif (StringTools.isBlank(bannerWidth)) {\nbannerWidth = this.hasDefault()? this.getDefault() : \"100%\";\n} else\nif (!bannerWidth.endsWith(\"%\")) {\nint W = StringTools.parseInt(bannerWidth, 0);\nbannerWidth = String.valueOf((W < MIN_BANNER_WIDTH)? MIN_BANNER_WIDTH : W);\n}\n\/\/ generate html\ntry {\nout.write(bannerWidth);\n} catch (IOException ioe) {\nthrow new JspTagException(ioe.toString());\n}\n\n}\n\/\/ --------------------------------------------------------------------\n\/* CSS file *\/\nif (s.equalsIgnoreCase(SECTION_CSSFILE)) {\nString cssFilePath = this.getArg();\nif (!StringTools.isBlank(cssFilePath)) {\ntry {\nPrintWriter pw = new PrintWriter(out, out.isAutoFlush());\nWebPageAdaptor.writeCssLink(pw, reqState, cssFilePath, null);\n} catch (IOException ioe) {\nthrow new JspTagException(ioe.toString());\n}\n}\nreturn EVAL_PAGE;\n}\n\/\/ --------------------------------------------------------------------\n\/* Banner Image Height *\/\nif (s.equalsIgnoreCase(SECTION_BANNER_WIDTH)) {\n\/\/ key suffix\nString kSfx = StringTools.trim(this.getArg());\n\/\/ property values\nString bannerWidth = privLabel.getStringProperty(PrivateLabel.PROP_Banner_width + kSfx, null);\nif (StringTools.isBlank(bannerWidth)) {\nbannerWidth = privLabel.getStringProperty(PrivateLabel.PROP_Banner_imageWidth + kSfx, null);\n}\n\/\/ minimum valie\nif (StringTools.isBlank(bannerWidth)) {\nbannerWidth = this.hasDefault()? this.getDefault() : \"100%\";\n} else\nif (!bannerWidth.endsWith(\"%\")) {\nint W = StringTools.parseInt(bannerWidth, 0);\nbannerWidth = String.valueOf((W < MIN_BANNER_WIDTH)? MIN_BANNER_WIDTH : W);\n}\n\/\/ generate html\ntry {\nout.write(bannerWidth);\n} catch (IOException ioe) {\nthrow new JspTagException(ioe.toString());\n}\nreturn EVAL_PAGE;\n}\n\nreturn EVAL_PAGE;\n}\n\/\/ --------------------------------------------------------------------\n\/* Banner Image Height *\/\nif (s.equalsIgnoreCase(SECTION_BANNER_WIDTH)) {\n\/\/ key suffix\nString kSfx = StringTools.trim(this.getArg());\n\/\/ property values\nString bannerWidth = privLabel.getStringProperty(PrivateLabel.PROP_Banner_width + kSfx, null);\nif (StringTools.isBlank(bannerWidth)) {\nbannerWidth = privLabel.getStringProperty(PrivateLabel.PROP_Banner_imageWidth + kSfx, null);\n}\n\/\/ minimum valie\nif (StringTools.isBlank(bannerWidth)) {\nbannerWidth = this.hasDefault()? this.getDefault() : \"100%\";\n} else\nif (!bannerWidth.endsWith(\"%\")) {\nint W = StringTools.parseInt(bannerWidth, 0);\nbannerWidth = String.valueOf((W < MIN_BANNER_WIDTH)? MIN_BANNER_WIDTH : W);\n}\n\/\/ generate html\ntry {\nout.write(bannerWidth);\n} catch (IOException ioe) {\nthrow new JspTagException(ioe.toString());\n}\nreturn EVAL_PAGE;\n}\n\/* Banner Style *\/\nif (s.equalsIgnoreCase(SECTION_BANNER_STYLE)) {\n\/\/ key suffix\nString kSfx = StringTools.trim(this.getArg());\n\/\/ property values\nString bannerStyle = privLabel.getStringProperty(PrivateLabel.PROP_Banner_style + kSfx, null);\n\/\/ generate html\nif (!StringTools.isBlank(bannerStyle)) {\ntry {\nout.write(bannerStyle);\n} catch (IOException ioe) {\nthrow new JspTagException(ioe.toString());\n}\n\nString kSfx = StringTools.trim(this.getArg());\n\/\/ property values\nString bannerStyle = privLabel.getStringProperty(PrivateLabel.PROP_Banner_style + kSfx, null);\n\/\/ generate html\nif (!StringTools.isBlank(bannerStyle)) {\ntry {\nout.write(bannerStyle);\n} catch (IOException ioe) {\nthrow new JspTagException(ioe.toString());\n}\n} else\nif (this.hasDefault()) {\ntry {\nout.write(this.getDefault());\n} catch (IOException ioe) {\nthrow new JspTagException(ioe.toString());\n}\n}\nreturn EVAL_PAGE;\n}\n\/* Banner Image *\/\nif (s.equalsIgnoreCase(SECTION_BANNER_IMAGE)) {\n\/\/ key suffix\nString kSfx = StringTools.trim(this.getArg());\n\/\/ property values\nString imgLink = privLabel.getStringProperty(PrivateLabel.PROP_Banner_imageLink + kSfx, null);\nString imgSrc = privLabel.getStringProperty(PrivateLabel.PROP_Banner_imageSource + kSfx, null);\nString imgWidth = privLabel.getStringProperty(PrivateLabel.PROP_Banner_imageWidth + kSfx, null);\nString imgHeight = privLabel.getStringProperty(PrivateLabel.PROP_Banner_imageHeight + kSfx, null);\n\/\/ generate html\nif (!StringTools.isBlank(imgSrc)) {\nStringBuffer sb = new StringBuffer();\nif (!StringTools.isBlank(imgLink)) {\nsb.append(\"<a href='\").append(imgLink).append(\"' target='_blank'>\");\n}\nsb.append(\"<img src='\").append(imgSrc).append(\"' border='0'\");\nif (!StringTools.isBlank(imgWidth)) {\nsb.append(\" width='\").append(imgWidth).append(\"'\");\n}\nif (!StringTools.isBlank(imgHeight)) {\nsb.append(\" height='\").append(imgHeight).append(\"'\");\n\n}\nreturn EVAL_PAGE;\n}\n\/\/ --------------------------------------------------------------------\n\/* CSS file *\/\nif (s.equalsIgnoreCase(SECTION_CSSFILE)) {\nString cssFilePath = this.getArg();\nif (!StringTools.isBlank(cssFilePath)) {\ntry {\nPrintWriter pw = new PrintWriter(out, out.isAutoFlush());\nWebPageAdaptor.writeCssLink(pw, reqState, cssFilePath, null);\n} catch (IOException ioe) {\nthrow new JspTagException(ioe.toString());\n}\n}\nreturn EVAL_PAGE;\n}\n\/\/ --------------------------------------------------------------------\n\/* Banner Image Height *\/\nif (s.equalsIgnoreCase(SECTION_BANNER_WIDTH)) {\n\/\/ key suffix\nString kSfx = StringTools.trim(this.getArg());\n\/\/ property values\nString bannerWidth = privLabel.getStringProperty(PrivateLabel.PROP_Banner_width + kSfx, null);\nif (StringTools.isBlank(bannerWidth)) {\nbannerWidth = privLabel.getStringProperty(PrivateLabel.PROP_Banner_imageWidth + kSfx, null);\n}\n\/\/ minimum valie\nif (StringTools.isBlank(bannerWidth)) {\nbannerWidth = this.hasDefault()? this.getDefault() : \"100%\";\n} else\nif (!bannerWidth.endsWith(\"%\")) {\nint W = StringTools.parseInt(bannerWidth, 0);\nbannerWidth = String.valueOf((W < MIN_BANNER_WIDTH)? MIN_BANNER_WIDTH : W);\n}\n\/\/ generate html\ntry {\nout.write(bannerWidth);\n} catch (IOException ioe) {\nthrow new JspTagException(ioe.toString());\n}\n\n}\n\/\/ --------------------------------------------------------------------\n\/* CSS file *\/\nif (s.equalsIgnoreCase(SECTION_CSSFILE)) {\nString cssFilePath = this.getArg();\nif (!StringTools.isBlank(cssFilePath)) {\ntry {\nPrintWriter pw = new PrintWriter(out, out.isAutoFlush());\nWebPageAdaptor.writeCssLink(pw, reqState, cssFilePath, null);\n} catch (IOException ioe) {\nthrow new JspTagException(ioe.toString());\n}\n}\nreturn EVAL_PAGE;\n}\n\/\/ --------------------------------------------------------------------\n\/* Banner Image Height *\/\nif (s.equalsIgnoreCase(SECTION_BANNER_WIDTH)) {\n\/\/ key suffix\nString kSfx = StringTools.trim(this.getArg());\n\/\/ property values\nString bannerWidth = privLabel.getStringProperty(PrivateLabel.PROP_Banner_width + kSfx, null);\nif (StringTools.isBlank(bannerWidth)) {\nbannerWidth = privLabel.getStringProperty(PrivateLabel.PROP_Banner_imageWidth + kSfx, null);\n}\n\/\/ minimum valie\nif (StringTools.isBlank(bannerWidth)) {\nbannerWidth = this.hasDefault()? this.getDefault() : \"100%\";\n} else\nif (!bannerWidth.endsWith(\"%\")) {\nint W = StringTools.parseInt(bannerWidth, 0);\nbannerWidth = String.valueOf((W < MIN_BANNER_WIDTH)? MIN_BANNER_WIDTH : W);\n}\n\/\/ generate html\ntry {\nout.write(bannerWidth);\n} catch (IOException ioe) {\nthrow new JspTagException(ioe.toString());\n}\nreturn EVAL_PAGE;\n}\n\nreturn EVAL_PAGE;\n}\n\/\/ --------------------------------------------------------------------\n\/* Banner Image Height *\/\nif (s.equalsIgnoreCase(SECTION_BANNER_WIDTH)) {\n\/\/ key suffix\nString kSfx = StringTools.trim(this.getArg());\n\/\/ property values\nString bannerWidth = privLabel.getStringProperty(PrivateLabel.PROP_Banner_width + kSfx, null);\nif (StringTools.isBlank(bannerWidth)) {\nbannerWidth = privLabel.getStringProperty(PrivateLabel.PROP_Banner_imageWidth + kSfx, null);\n}\n\/\/ minimum valie\nif (StringTools.isBlank(bannerWidth)) {\nbannerWidth = this.hasDefault()? this.getDefault() : \"100%\";\n} else\nif (!bannerWidth.endsWith(\"%\")) {\nint W = StringTools.parseInt(bannerWidth, 0);\nbannerWidth = String.valueOf((W < MIN_BANNER_WIDTH)? MIN_BANNER_WIDTH : W);\n}\n\/\/ generate html\ntry {\nout.write(bannerWidth);\n} catch (IOException ioe) {\nthrow new JspTagException(ioe.toString());\n}\nreturn EVAL_PAGE;\n}\n\/* Banner Style *\/\nif (s.equalsIgnoreCase(SECTION_BANNER_STYLE)) {\n\/\/ key suffix\nString kSfx = StringTools.trim(this.getArg());\n\/\/ property values\nString bannerStyle = privLabel.getStringProperty(PrivateLabel.PROP_Banner_style + kSfx, null);\n\/\/ generate html\nif (!StringTools.isBlank(bannerStyle)) {\ntry {\nout.write(bannerStyle);\n} catch (IOException ioe) {\nthrow new JspTagException(ioe.toString());\n}\n\nString kSfx = StringTools.trim(this.getArg());\n\/\/ property values\nString bannerStyle = privLabel.getStringProperty(PrivateLabel.PROP_Banner_style + kSfx, null);\n\/\/ generate html\nif (!StringTools.isBlank(bannerStyle)) {\ntry {\nout.write(bannerStyle);\n} catch (IOException ioe) {\nthrow new JspTagException(ioe.toString());\n}\n} else\nif (this.hasDefault()) {\ntry {\nout.write(this.getDefault());\n} catch (IOException ioe) {\nthrow new JspTagException(ioe.toString());\n}\n}\nreturn EVAL_PAGE;\n}\n\/* Banner Image *\/\nif (s.equalsIgnoreCase(SECTION_BANNER_IMAGE)) {\n\/\/ key suffix\nString kSfx = StringTools.trim(this.getArg());\n\/\/ property values\nString imgLink = privLabel.getStringProperty(PrivateLabel.PROP_Banner_imageLink + kSfx, null);\nString imgSrc = privLabel.getStringProperty(PrivateLabel.PROP_Banner_imageSource + kSfx, null);\nString imgWidth = privLabel.getStringProperty(PrivateLabel.PROP_Banner_imageWidth + kSfx, null);\nString imgHeight = privLabel.getStringProperty(PrivateLabel.PROP_Banner_imageHeight + kSfx, null);\n\/\/ generate html\nif (!StringTools.isBlank(imgSrc)) {\nStringBuffer sb = new StringBuffer();\nif (!StringTools.isBlank(imgLink)) {\nsb.append(\"<a href='\").append(imgLink).append(\"' target='_blank'>\");\n}\nsb.append(\"<img src='\").append(imgSrc).append(\"' border='0'\");\nif (!StringTools.isBlank(imgWidth)) {\nsb.append(\" width='\").append(imgWidth).append(\"'\");\n}\nif (!StringTools.isBlank(imgHeight)) {\nsb.append(\" height='\").append(imgHeight).append(\"'\");\n\n}\nreturn EVAL_PAGE;\n}\n\/\/ --------------------------------------------------------------------\n\/* CSS file *\/\nif (s.equalsIgnoreCase(SECTION_CSSFILE)) {\nString cssFilePath = this.getArg();\nif (!StringTools.isBlank(cssFilePath)) {\ntry {\nPrintWriter pw = new PrintWriter(out, out.isAutoFlush());\nWebPageAdaptor.writeCssLink(pw, reqState, cssFilePath, null);\n} catch (IOException ioe) {\nthrow new JspTagException(ioe.toString());\n}\n}\nreturn EVAL_PAGE;\n}\n\/\/ --------------------------------------------------------------------\n\/* Banner Image Height *\/\nif (s.equalsIgnoreCase(SECTION_BANNER_WIDTH)) {\n\/\/ key suffix\nString kSfx = StringTools.trim(this.getArg());\n\/\/ property values\nString bannerWidth = privLabel.getStringProperty(PrivateLabel.PROP_Banner_width + kSfx, null);\nif (StringTools.isBlank(bannerWidth)) {\nbannerWidth = privLabel.getStringProperty(PrivateLabel.PROP_Banner_imageWidth + kSfx, null);\n}\n\/\/ minimum valie\nif (StringTools.isBlank(bannerWidth)) {\nbannerWidth = this.hasDefault()? this.getDefault() : \"100%\";\n} else\nif (!bannerWidth.endsWith(\"%\")) {\nint W = StringTools.parseInt(bannerWidth, 0);\nbannerWidth = String.valueOf((W < MIN_BANNER_WIDTH)? MIN_BANNER_WIDTH : W);\n}\n\/\/ generate html\ntry {\nout.write(bannerWidth);\n} catch (IOException ioe) {\nthrow new JspTagException(ioe.toString());\n}\n\n}\n\/\/ --------------------------------------------------------------------\n\/* CSS file *\/\nif (s.equalsIgnoreCase(SECTION_CSSFILE)) {\nString cssFilePath = this.getArg();\nif (!StringTools.isBlank(cssFilePath)) {\ntry {\nPrintWriter pw = new PrintWriter(out, out.isAutoFlush());\nWebPageAdaptor.writeCssLink(pw, reqState, cssFilePath, null);\n} catch (IOException ioe) {\nthrow new JspTagException(ioe.toString());\n}\n}\nreturn EVAL_PAGE;\n}\n\/\/ --------------------------------------------------------------------\n\/* Banner Image Height *\/\nif (s.equalsIgnoreCase(SECTION_BANNER_WIDTH)) {\n\/\/ key suffix\nString kSfx = StringTools.trim(this.getArg());\n\/\/ property values\nString bannerWidth = privLabel.getStringProperty(PrivateLabel.PROP_Banner_width + kSfx, null);\nif (StringTools.isBlank(bannerWidth)) {\nbannerWidth = privLabel.getStringProperty(PrivateLabel.PROP_Banner_imageWidth + kSfx, null);\n}\n\/\/ minimum valie\nif (StringTools.isBlank(bannerWidth)) {\nbannerWidth = this.hasDefault()? this.getDefault() : \"100%\";\n} else\nif (!bannerWidth.endsWith(\"%\")) {\nint W = StringTools.parseInt(bannerWidth, 0);\nbannerWidth = String.valueOf((W < MIN_BANNER_WIDTH)? MIN_BANNER_WIDTH : W);\n}\n\/\/ generate html\ntry {\nout.write(bannerWidth);\n} catch (IOException ioe) {\nthrow new JspTagException(ioe.toString());\n}\nreturn EVAL_PAGE;\n}\n\nreturn EVAL_PAGE;\n}\n\/\/ --------------------------------------------------------------------\n\/* Banner Image Height *\/\nif (s.equalsIgnoreCase(SECTION_BANNER_WIDTH)) {\n\/\/ key suffix\nString kSfx = StringTools.trim(this.getArg());\n\/\/ property values\nString bannerWidth = privLabel.getStringProperty(PrivateLabel.PROP_Banner_width + kSfx, null);\nif (StringTools.isBlank(bannerWidth)) {\nbannerWidth = privLabel.getStringProperty(PrivateLabel.PROP_Banner_imageWidth + kSfx, null);\n}\n\/\/ minimum valie\nif (StringTools.isBlank(bannerWidth)) {\nbannerWidth = this.hasDefault()? this.getDefault() : \"100%\";\n} else\nif (!bannerWidth.endsWith(\"%\")) {\nint W = StringTools.parseInt(bannerWidth, 0);\nbannerWidth = String.valueOf((W < MIN_BANNER_WIDTH)? MIN_BANNER_WIDTH : W);\n}\n\/\/ generate html\ntry {\nout.write(bannerWidth);\n} catch (IOException ioe) {\nthrow new JspTagException(ioe.toString());\n}\nreturn EVAL_PAGE;\n}\n\/* Banner Style *\/\nif (s.equalsIgnoreCase(SECTION_BANNER_STYLE)) {\n\/\/ key suffix\nString kSfx = StringTools.trim(this.getArg());\n\/\/ property values\nString bannerStyle = privLabel.getStringProperty(PrivateLabel.PROP_Banner_style + kSfx, null);\n\/\/ generate html\nif (!StringTools.isBlank(bannerStyle)) {\ntry {\nout.write(bannerStyle);\n} catch (IOException ioe) {\nthrow new JspTagException(ioe.toString());\n}\n\nthrow new JspTagException(ioe.toString());\n}\n} else\nif (this.hasDefault()) {\ntry {\nout.write(this.getDefault());\n} catch (IOException ioe) {\nthrow new JspTagException(ioe.toString());\n}\n}\nreturn EVAL_PAGE;\n}\n\/* Banner Image *\/\nif (s.equalsIgnoreCase(SECTION_BANNER_IMAGE_SOURCE)) {\n\/\/ key suffix\nString kSfx = StringTools.trim(this.getArg());\n\/\/ property values\nString imgSrc = privLabel.getStringProperty(PrivateLabel.PROP_Banner_imageSource + kSfx, null);\n\/\/ generate html\nif (!StringTools.isBlank(imgSrc)) {\n\/\/Print.sysPrintln(\"Property Image Source: \" + imgSrc);\ntry {\nout.write(imgSrc);\n} catch (IOException ioe) {\nthrow new JspTagException(ioe.toString());\n}\n} else\nif (this.hasDefault()) {\n\/\/Print.sysPrintln(\"Default Image Source: \" + this.getDefault());\ntry {\nout.write(this.getDefault());\n} catch (IOException ioe) {\nthrow new JspTagException(ioe.toString());\n}\n}\nreturn EVAL_PAGE;\n}\n\/* Banner Image Height *\/\nif (s.equalsIgnoreCase(SECTION_BANNER_IMAGE_WIDTH)) {\n\/\/ key suffix\nString kSfx = StringTools.trim(this.getArg());\n\n}\n}\nreturn EVAL_PAGE;\n}\n\/* Banner Image *\/\nif (s.equalsIgnoreCase(SECTION_BANNER_IMAGE_SOURCE)) {\n\/\/ key suffix\nString kSfx = StringTools.trim(this.getArg());\n\/\/ property values\nString imgSrc = privLabel.getStringProperty(PrivateLabel.PROP_Banner_imageSource + kSfx, null);\n\/\/ generate html\nif (!StringTools.isBlank(imgSrc)) {\n\/\/Print.sysPrintln(\"Property Image Source: \" + imgSrc);\ntry {\nout.write(imgSrc);\n} catch (IOException ioe) {\nthrow new JspTagException(ioe.toString());\n}\n} else\nif (this.hasDefault()) {\n\/\/Print.sysPrintln(\"Default Image Source: \" + this.getDefault());\ntry {\nout.write(this.getDefault());\n} catch (IOException ioe) {\nthrow new JspTagException(ioe.toString());\n}\n}\nreturn EVAL_PAGE;\n}\n\/* Banner Image Height *\/\nif (s.equalsIgnoreCase(SECTION_BANNER_IMAGE_WIDTH)) {\n\/\/ key suffix\nString kSfx = StringTools.trim(this.getArg());\n\/\/ property values\nString imgWidth = privLabel.getStringProperty(PrivateLabel.PROP_Banner_imageWidth + kSfx, null);\n\/\/ generate html\nif (!StringTools.isBlank(imgWidth)) {\ntry {\nout.write(imgWidth);\n} catch (IOException ioe) {\nthrow new JspTagException(ioe.toString());\n\n} catch (IOException ioe) {\nthrow new JspTagException(ioe.toString());\n}\nreturn EVAL_PAGE;\n}\n\/\/ --------------------------------------------------------------------\n\/* CSS file *\/\nif (s.equalsIgnoreCase(SECTION_CSSFILE)) {\nString cssFilePath = this.getArg();\nif (!StringTools.isBlank(cssFilePath)) {\ntry {\nPrintWriter pw = new PrintWriter(out, out.isAutoFlush());\nWebPageAdaptor.writeCssLink(pw, reqState, cssFilePath, null);\n} catch (IOException ioe) {\nthrow new JspTagException(ioe.toString());\n}\n}\nreturn EVAL_PAGE;\n}\n\/\/ --------------------------------------------------------------------\n\/* Banner Image Height *\/\nif (s.equalsIgnoreCase(SECTION_BANNER_WIDTH)) {\n\/\/ key suffix\nString kSfx = StringTools.trim(this.getArg());\n\/\/ property values\nString bannerWidth = privLabel.getStringProperty(PrivateLabel.PROP_Banner_width + kSfx, null);\nif (StringTools.isBlank(bannerWidth)) {\nbannerWidth = privLabel.getStringProperty(PrivateLabel.PROP_Banner_imageWidth + kSfx, null);\n}\n\/\/ minimum valie\nif (StringTools.isBlank(bannerWidth)) {\nbannerWidth = this.hasDefault()? this.getDefault() : \"100%\";\n} else\nif (!bannerWidth.endsWith(\"%\")) {\nint W = StringTools.parseInt(bannerWidth, 0);\nbannerWidth = String.valueOf((W < MIN_BANNER_WIDTH)? MIN_BANNER_WIDTH : W);\n}\n\/\/ generate html\ntry {\nout.write(bannerWidth);\n} catch (IOException ioe) {\n\n}\nreturn EVAL_PAGE;\n}\n\/\/ --------------------------------------------------------------------\n\/* CSS file *\/\nif (s.equalsIgnoreCase(SECTION_CSSFILE)) {\nString cssFilePath = this.getArg();\nif (!StringTools.isBlank(cssFilePath)) {\ntry {\nPrintWriter pw = new PrintWriter(out, out.isAutoFlush());\nWebPageAdaptor.writeCssLink(pw, reqState, cssFilePath, null);\n} catch (IOException ioe) {\nthrow new JspTagException(ioe.toString());\n}\n}\nreturn EVAL_PAGE;\n}\n\/\/ --------------------------------------------------------------------\n\/* Banner Image Height *\/\nif (s.equalsIgnoreCase(SECTION_BANNER_WIDTH)) {\n\/\/ key suffix\nString kSfx = StringTools.trim(this.getArg());\n\/\/ property values\nString bannerWidth = privLabel.getStringProperty(PrivateLabel.PROP_Banner_width + kSfx, null);\nif (StringTools.isBlank(bannerWidth)) {\nbannerWidth = privLabel.getStringProperty(PrivateLabel.PROP_Banner_imageWidth + kSfx, null);\n}\n\/\/ minimum valie\nif (StringTools.isBlank(bannerWidth)) {\nbannerWidth = this.hasDefault()? this.getDefault() : \"100%\";\n} else\nif (!bannerWidth.endsWith(\"%\")) {\nint W = StringTools.parseInt(bannerWidth, 0);\nbannerWidth = String.valueOf((W < MIN_BANNER_WIDTH)? MIN_BANNER_WIDTH : W);\n}\n\/\/ generate html\ntry {\nout.write(bannerWidth);\n} catch (IOException ioe) {\nthrow new JspTagException(ioe.toString());\n}\n\n}\n\/\/ --------------------------------------------------------------------\n\/* CSS file *\/\nif (s.equalsIgnoreCase(SECTION_CSSFILE)) {\nString cssFilePath = this.getArg();\nif (!StringTools.isBlank(cssFilePath)) {\ntry {\nPrintWriter pw = new PrintWriter(out, out.isAutoFlush());\nWebPageAdaptor.writeCssLink(pw, reqState, cssFilePath, null);\n} catch (IOException ioe) {\nthrow new JspTagException(ioe.toString());\n}\n}\nreturn EVAL_PAGE;\n}\n\/\/ --------------------------------------------------------------------\n\/* Banner Image Height *\/\nif (s.equalsIgnoreCase(SECTION_BANNER_WIDTH)) {\n\/\/ key suffix\nString kSfx = StringTools.trim(this.getArg());\n\/\/ property values\nString bannerWidth = privLabel.getStringProperty(PrivateLabel.PROP_Banner_width + kSfx, null);\nif (StringTools.isBlank(bannerWidth)) {\nbannerWidth = privLabel.getStringProperty(PrivateLabel.PROP_Banner_imageWidth + kSfx, null);\n}\n\/\/ minimum valie\nif (StringTools.isBlank(bannerWidth)) {\nbannerWidth = this.hasDefault()? this.getDefault() : \"100%\";\n} else\nif (!bannerWidth.endsWith(\"%\")) {\nint W = StringTools.parseInt(bannerWidth, 0);\nbannerWidth = String.valueOf((W < MIN_BANNER_WIDTH)? MIN_BANNER_WIDTH : W);\n}\n\/\/ generate html\ntry {\nout.write(bannerWidth);\n} catch (IOException ioe) {\nthrow new JspTagException(ioe.toString());\n}\nreturn EVAL_PAGE;\n}\n\nreturn EVAL_PAGE;\n}\n\/\/ --------------------------------------------------------------------\n\/* Banner Image Height *\/\nif (s.equalsIgnoreCase(SECTION_BANNER_WIDTH)) {\n\/\/ key suffix\nString kSfx = StringTools.trim(this.getArg());\n\/\/ property values\nString bannerWidth = privLabel.getStringProperty(PrivateLabel.PROP_Banner_width + kSfx, null);\nif (StringTools.isBlank(bannerWidth)) {\nbannerWidth = privLabel.getStringProperty(PrivateLabel.PROP_Banner_imageWidth + kSfx, null);\n}\n\/\/ minimum valie\nif (StringTools.isBlank(bannerWidth)) {\nbannerWidth = this.hasDefault()? this.getDefault() : \"100%\";\n} else\nif (!bannerWidth.endsWith(\"%\")) {\nint W = StringTools.parseInt(bannerWidth, 0);\nbannerWidth = String.valueOf((W < MIN_BANNER_WIDTH)? MIN_BANNER_WIDTH : W);\n}\n\/\/ generate html\ntry {\nout.write(bannerWidth);\n} catch (IOException ioe) {\nthrow new JspTagException(ioe.toString());\n}\nreturn EVAL_PAGE;\n}\n\/* Banner Style *\/\nif (s.equalsIgnoreCase(SECTION_BANNER_STYLE)) {\n\/\/ key suffix\nString kSfx = StringTools.trim(this.getArg());\n\/\/ property values\nString bannerStyle = privLabel.getStringProperty(PrivateLabel.PROP_Banner_style + kSfx, null);\n\/\/ generate html\nif (!StringTools.isBlank(bannerStyle)) {\ntry {\nout.write(bannerStyle);\n} catch (IOException ioe) {\nthrow new JspTagException(ioe.toString());\n}\n\n} catch (IOException ioe) {\nthrow new JspTagException(ioe.toString());\n}\nreturn EVAL_PAGE;\n}\n\/\/ --------------------------------------------------------------------\n\/* CSS file *\/\nif (s.equalsIgnoreCase(SECTION_CSSFILE)) {\nString cssFilePath = this.getArg();\nif (!StringTools.isBlank(cssFilePath)) {\ntry {\nPrintWriter pw = new PrintWriter(out, out.isAutoFlush());\nWebPageAdaptor.writeCssLink(pw, reqState, cssFilePath, null);\n} catch (IOException ioe) {\nthrow new JspTagException(ioe.toString());\n}\n}\nreturn EVAL_PAGE;\n}\n\/\/ --------------------------------------------------------------------\n\/* Banner Image Height *\/\nif (s.equalsIgnoreCase(SECTION_BANNER_WIDTH)) {\n\/\/ key suffix\nString kSfx = StringTools.trim(this.getArg());\n\/\/ property values\nString bannerWidth = privLabel.getStringProperty(PrivateLabel.PROP_Banner_width + kSfx, null);\nif (StringTools.isBlank(bannerWidth)) {\nbannerWidth = privLabel.getStringProperty(PrivateLabel.PROP_Banner_imageWidth + kSfx, null);\n}\n\/\/ minimum valie\nif (StringTools.isBlank(bannerWidth)) {\nbannerWidth = this.hasDefault()? this.getDefault() : \"100%\";\n} else\nif (!bannerWidth.endsWith(\"%\")) {\nint W = StringTools.parseInt(bannerWidth, 0);\nbannerWidth = String.valueOf((W < MIN_BANNER_WIDTH)? MIN_BANNER_WIDTH : W);\n}\n\/\/ generate html\ntry {\nout.write(bannerWidth);\n} catch (IOException ioe) {\n\n}\nreturn EVAL_PAGE;\n}\n\/\/ --------------------------------------------------------------------\n\/* CSS file *\/\nif (s.equalsIgnoreCase(SECTION_CSSFILE)) {\nString cssFilePath = this.getArg();\nif (!StringTools.isBlank(cssFilePath)) {\ntry {\nPrintWriter pw = new PrintWriter(out, out.isAutoFlush());\nWebPageAdaptor.writeCssLink(pw, reqState, cssFilePath, null);\n} catch (IOException ioe) {\nthrow new JspTagException(ioe.toString());\n}\n}\nreturn EVAL_PAGE;\n}\n\/\/ --------------------------------------------------------------------\n\/* Banner Image Height *\/\nif (s.equalsIgnoreCase(SECTION_BANNER_WIDTH)) {\n\/\/ key suffix\nString kSfx = StringTools.trim(this.getArg());\n\/\/ property values\nString bannerWidth = privLabel.getStringProperty(PrivateLabel.PROP_Banner_width + kSfx, null);\nif (StringTools.isBlank(bannerWidth)) {\nbannerWidth = privLabel.getStringProperty(PrivateLabel.PROP_Banner_imageWidth + kSfx, null);\n}\n\/\/ minimum valie\nif (StringTools.isBlank(bannerWidth)) {\nbannerWidth = this.hasDefault()? this.getDefault() : \"100%\";\n} else\nif (!bannerWidth.endsWith(\"%\")) {\nint W = StringTools.parseInt(bannerWidth, 0);\nbannerWidth = String.valueOf((W < MIN_BANNER_WIDTH)? MIN_BANNER_WIDTH : W);\n}\n\/\/ generate html\ntry {\nout.write(bannerWidth);\n} catch (IOException ioe) {\nthrow new JspTagException(ioe.toString());\n}\n\n}\n\/\/ --------------------------------------------------------------------\n\/* CSS file *\/\nif (s.equalsIgnoreCase(SECTION_CSSFILE)) {\nString cssFilePath = this.getArg();\nif (!StringTools.isBlank(cssFilePath)) {\ntry {\nPrintWriter pw = new PrintWriter(out, out.isAutoFlush());\nWebPageAdaptor.writeCssLink(pw, reqState, cssFilePath, null);\n} catch (IOException ioe) {\nthrow new JspTagException(ioe.toString());\n}\n}\nreturn EVAL_PAGE;\n}\n\/\/ --------------------------------------------------------------------\n\/* Banner Image Height *\/\nif (s.equalsIgnoreCase(SECTION_BANNER_WIDTH)) {\n\/\/ key suffix\nString kSfx = StringTools.trim(this.getArg());\n\/\/ property values\nString bannerWidth = privLabel.getStringProperty(PrivateLabel.PROP_Banner_width + kSfx, null);\nif (StringTools.isBlank(bannerWidth)) {\nbannerWidth = privLabel.getStringProperty(PrivateLabel.PROP_Banner_imageWidth + kSfx, null);\n}\n\/\/ minimum valie\nif (StringTools.isBlank(bannerWidth)) {\nbannerWidth = this.hasDefault()? this.getDefault() : \"100%\";\n} else\nif (!bannerWidth.endsWith(\"%\")) {\nint W = StringTools.parseInt(bannerWidth, 0);\nbannerWidth = String.valueOf((W < MIN_BANNER_WIDTH)? MIN_BANNER_WIDTH : W);\n}\n\/\/ generate html\ntry {\nout.write(bannerWidth);\n} catch (IOException ioe) {\nthrow new JspTagException(ioe.toString());\n}\nreturn EVAL_PAGE;\n}\n\nreturn EVAL_PAGE;\n}\n\/\/ --------------------------------------------------------------------\n\/* Banner Image Height *\/\nif (s.equalsIgnoreCase(SECTION_BANNER_WIDTH)) {\n\/\/ key suffix\nString kSfx = StringTools.trim(this.getArg());\n\/\/ property values\nString bannerWidth = privLabel.getStringProperty(PrivateLabel.PROP_Banner_width + kSfx, null);\nif (StringTools.isBlank(bannerWidth)) {\nbannerWidth = privLabel.getStringProperty(PrivateLabel.PROP_Banner_imageWidth + kSfx, null);\n}\n\/\/ minimum valie\nif (StringTools.isBlank(bannerWidth)) {\nbannerWidth = this.hasDefault()? this.getDefault() : \"100%\";\n} else\nif (!bannerWidth.endsWith(\"%\")) {\nint W = StringTools.parseInt(bannerWidth, 0);\nbannerWidth = String.valueOf((W < MIN_BANNER_WIDTH)? MIN_BANNER_WIDTH : W);\n}\n\/\/ generate html\ntry {\nout.write(bannerWidth);\n} catch (IOException ioe) {\nthrow new JspTagException(ioe.toString());\n}\nreturn EVAL_PAGE;\n}\n\/* Banner Style *\/\nif (s.equalsIgnoreCase(SECTION_BANNER_STYLE)) {\n\/\/ key suffix\nString kSfx = StringTools.trim(this.getArg());\n\/\/ property values\nString bannerStyle = privLabel.getStringProperty(PrivateLabel.PROP_Banner_style + kSfx, null);\n\/\/ generate html\nif (!StringTools.isBlank(bannerStyle)) {\ntry {\nout.write(bannerStyle);\n} catch (IOException ioe) {\nthrow new JspTagException(ioe.toString());\n}\n\npublic int doEndTag()\nthrows JspTagException\n{\nHttpServletRequest request = (HttpServletRequest)super.pageContext.getRequest();\nRequestProperties reqState = (RequestProperties)request.getAttribute(SECTION_REQUESTPROPS);\nPrivateLabel privLabel = (reqState != null)? reqState.getPrivateLabel() : RequestProperties.NullPrivateLabel;\nJspWriter out = super.pageContext.getOut();\nString s = this.getSection().toLowerCase();\n\/* ignore blank section definitions *\/\nif (StringTools.isBlank(s)) {\n\/\/ -- ignore\nreturn EVAL_PAGE;\n}\n\/* not a match? *\/\nif (!this.isMatch()) {\n\/\/ -- ignore\nreturn EVAL_PAGE;\n}\n\/\/ --------------------------------------------------------------------\n\/* \"onload='...'\" *\/\nif (s.equalsIgnoreCase(SECTION_BODY_ONLOAD)) {\nString bodyOnLoad = (String)request.getAttribute(SECTION_BODY_ONLOAD);\nif (!StringTools.isBlank(bodyOnLoad)) {\ntry {\nout.print(bodyOnLoad);\n} catch (IOException ioe) {\nthrow new JspTagException(ioe.toString());\n}\n}\nreturn EVAL_PAGE;\n}\n\/* \"onunload='...'\" *\/\nif (s.equalsIgnoreCase(SECTION_BODY_ONUNLOAD)) {\nString bodyOnUnload = (String)request.getAttribute(SECTION_BODY_ONUNLOAD);\nif (!StringTools.isBlank(bodyOnUnload)) {\ntry {\nout.print(bodyOnUnload);\n} catch (IOException ioe) {\nthrow new JspTagException(ioe.toString());\n}\n\nif (!StringTools.isBlank(imgHeight)) {\ntry {\nout.write(imgHeight);\n} catch (IOException ioe) {\nthrow new JspTagException(ioe.toString());\n}\n} else\nif (this.hasDefault()) {\ntry {\nout.write(this.getDefault());\n} catch (IOException ioe) {\nthrow new JspTagException(ioe.toString());\n}\n}\nreturn EVAL_PAGE;\n}\n\/\/ --------------------------------------------------------------------\n\/* JavaScript *\/\nif (s.equalsIgnoreCase(SECTION_JAVASCRIPT)) {\ntry {\n\/\/ always write \"utils.js\"\nJavaScriptTools.writeUtilsJS(out, request);\n\/\/ check for other javascript\nObject obj = request.getAttribute(SECTION_JAVASCRIPT);\nif (obj instanceof HTMLOutput) {\n((HTMLOutput)obj).write(out);\n} else {\nout.write(\"<!-- Unexpected section type '\" + s + \"' [\" + StringTools.className(obj) + \"] -->\");\n}\n} catch (IOException ioe) {\nthrow new JspTagException(ioe.toString());\n}\nreturn EVAL_PAGE;\n}\n\/\/ --------------------------------------------------------------------\n\/* current page name *\/\nif (s.equalsIgnoreCase(SECTION_PAGE_NAME)) { \/\/ \"pagename\"\nString pageName = reqState.getPageName();\nif (!StringTools.isBlank(pageName)) {\ntry {\nout.write(pageName);\n\nout.write(imgHeight);\n} catch (IOException ioe) {\nthrow new JspTagException(ioe.toString());\n}\n} else\nif (this.hasDefault()) {\ntry {\nout.write(this.getDefault());\n} catch (IOException ioe) {\nthrow new JspTagException(ioe.toString());\n}\n}\nreturn EVAL_PAGE;\n}\n\/\/ --------------------------------------------------------------------\n\/* JavaScript *\/\nif (s.equalsIgnoreCase(SECTION_JAVASCRIPT)) {\ntry {\n\/\/ always write \"utils.js\"\nJavaScriptTools.writeUtilsJS(out, request);\n\/\/ check for other javascript\nObject obj = request.getAttribute(SECTION_JAVASCRIPT);\nif (obj instanceof HTMLOutput) {\n((HTMLOutput)obj).write(out);\n} else {\nout.write(\"<!-- Unexpected section type '\" + s + \"' [\" + StringTools.className(obj) + \"] -->\");\n}\n} catch (IOException ioe) {\nthrow new JspTagException(ioe.toString());\n}\nreturn EVAL_PAGE;\n}\n\/\/ --------------------------------------------------------------------\n\/* current page name *\/\nif (s.equalsIgnoreCase(SECTION_PAGE_NAME)) { \/\/ \"pagename\"\nString pageName = reqState.getPageName();\nif (!StringTools.isBlank(pageName)) {\ntry {\nout.write(pageName);\n} catch (IOException ioe) {\nthrow new JspTagException(ioe.toString());\n\npublic int doEndTag()\nthrows JspTagException\n{\nHttpServletRequest request = (HttpServletRequest)super.pageContext.getRequest();\nRequestProperties reqState = (RequestProperties)request.getAttribute(SECTION_REQUESTPROPS);\nPrivateLabel privLabel = (reqState != null)? reqState.getPrivateLabel() : RequestProperties.NullPrivateLabel;\nJspWriter out = super.pageContext.getOut();\nString s = this.getSection().toLowerCase();\n\/* ignore blank section definitions *\/\nif (StringTools.isBlank(s)) {\n\/\/ -- ignore\nreturn EVAL_PAGE;\n}\n\/* not a match? *\/\nif (!this.isMatch()) {\n\/\/ -- ignore\nreturn EVAL_PAGE;\n}\n\/\/ --------------------------------------------------------------------\n\/* \"onload='...'\" *\/\nif (s.equalsIgnoreCase(SECTION_BODY_ONLOAD)) {\nString bodyOnLoad = (String)request.getAttribute(SECTION_BODY_ONLOAD);\nif (!StringTools.isBlank(bodyOnLoad)) {\ntry {\nout.print(bodyOnLoad);\n} catch (IOException ioe) {\nthrow new JspTagException(ioe.toString());\n}\n}\nreturn EVAL_PAGE;\n}\n\/* \"onunload='...'\" *\/\nif (s.equalsIgnoreCase(SECTION_BODY_ONUNLOAD)) {\nString bodyOnUnload = (String)request.getAttribute(SECTION_BODY_ONUNLOAD);\nif (!StringTools.isBlank(bodyOnUnload)) {\ntry {\nout.print(bodyOnUnload);\n} catch (IOException ioe) {\nthrow new JspTagException(ioe.toString());\n}\n\n\/\/ --------------------------------------------------------------------\n\/* JavaScript *\/\nif (s.equalsIgnoreCase(SECTION_JAVASCRIPT)) {\ntry {\n\/\/ always write \"utils.js\"\nJavaScriptTools.writeUtilsJS(out, request);\n\/\/ check for other javascript\nObject obj = request.getAttribute(SECTION_JAVASCRIPT);\nif (obj instanceof HTMLOutput) {\n((HTMLOutput)obj).write(out);\n} else {\nout.write(\"<!-- Unexpected section type '\" + s + \"' [\" + StringTools.className(obj) + \"] -->\");\n}\n} catch (IOException ioe) {\nthrow new JspTagException(ioe.toString());\n}\nreturn EVAL_PAGE;\n}\n\/\/ --------------------------------------------------------------------\n\/* current page name *\/\nif (s.equalsIgnoreCase(SECTION_PAGE_NAME)) { \/\/ \"pagename\"\nString pageName = reqState.getPageName();\nif (!StringTools.isBlank(pageName)) {\ntry {\nout.write(pageName);\n} catch (IOException ioe) {\nthrow new JspTagException(ioe.toString());\n}\n}\nreturn EVAL_PAGE;\n}\n\/\/ --------------------------------------------------------------------\n\/* Page URL *\/\nif (s.equalsIgnoreCase(SECTION_PAGE_URL)) { \/\/ \"pageurl\"\nString pageName = this.getArg();\nString cmd = null;\nString cmdArg = null;\nWebPage wp = privLabel.getWebPage(pageName);\nString url = (wp != null)? wp.encodePageURL(reqState,cmd,cmdArg) : null;\nif (!StringTools.isBlank(url)) {\ntry {\n\npublic int doEndTag()\nthrows JspTagException\n{\nHttpServletRequest request = (HttpServletRequest)super.pageContext.getRequest();\nRequestProperties reqState = (RequestProperties)request.getAttribute(SECTION_REQUESTPROPS);\nPrivateLabel privLabel = (reqState != null)? reqState.getPrivateLabel() : RequestProperties.NullPrivateLabel;\nJspWriter out = super.pageContext.getOut();\nString s = this.getSection().toLowerCase();\n\/* ignore blank section definitions *\/\nif (StringTools.isBlank(s)) {\n\/\/ -- ignore\nreturn EVAL_PAGE;\n}\n\/* not a match? *\/\nif (!this.isMatch()) {\n\/\/ -- ignore\nreturn EVAL_PAGE;\n}\n\/\/ --------------------------------------------------------------------\n\/* \"onload='...'\" *\/\nif (s.equalsIgnoreCase(SECTION_BODY_ONLOAD)) {\nString bodyOnLoad = (String)request.getAttribute(SECTION_BODY_ONLOAD);\nif (!StringTools.isBlank(bodyOnLoad)) {\ntry {\nout.print(bodyOnLoad);\n} catch (IOException ioe) {\nthrow new JspTagException(ioe.toString());\n}\n}\nreturn EVAL_PAGE;\n}\n\/* \"onunload='...'\" *\/\nif (s.equalsIgnoreCase(SECTION_BODY_ONUNLOAD)) {\nString bodyOnUnload = (String)request.getAttribute(SECTION_BODY_ONUNLOAD);\nif (!StringTools.isBlank(bodyOnUnload)) {\ntry {\nout.print(bodyOnUnload);\n} catch (IOException ioe) {\nthrow new JspTagException(ioe.toString());\n}\n\n} catch (IOException ioe) {\nthrow new JspTagException(ioe.toString());\n}\nreturn EVAL_PAGE;\n}\n\/\/ --------------------------------------------------------------------\n\/* current page name *\/\nif (s.equalsIgnoreCase(SECTION_PAGE_NAME)) { \/\/ \"pagename\"\nString pageName = reqState.getPageName();\nif (!StringTools.isBlank(pageName)) {\ntry {\nout.write(pageName);\n} catch (IOException ioe) {\nthrow new JspTagException(ioe.toString());\n}\n}\nreturn EVAL_PAGE;\n}\n\/\/ --------------------------------------------------------------------\n\/* Page URL *\/\nif (s.equalsIgnoreCase(SECTION_PAGE_URL)) { \/\/ \"pageurl\"\nString pageName = this.getArg();\nString cmd = null;\nString cmdArg = null;\nWebPage wp = privLabel.getWebPage(pageName);\nString url = (wp != null)? wp.encodePageURL(reqState,cmd,cmdArg) : null;\nif (!StringTools.isBlank(url)) {\ntry {\nout.write(url);\n} catch (IOException ioe) {\nthrow new JspTagException(ioe.toString());\n}\n}\nreturn EVAL_PAGE;\n}\n\/\/ --------------------------------------------------------------------\n\/* HTMLOutput *\/\ntry {\nObject obj = request.getAttribute(s);\nif (obj == null) {\nout.write(\"<!-- Undefined section '\" + s + \"' -->\");\n\npublic int doEndTag()\nthrows JspTagException\n{\nHttpServletRequest request = (HttpServletRequest)super.pageContext.getRequest();\nRequestProperties reqState = (RequestProperties)request.getAttribute(SECTION_REQUESTPROPS);\nPrivateLabel privLabel = (reqState != null)? reqState.getPrivateLabel() : RequestProperties.NullPrivateLabel;\nJspWriter out = super.pageContext.getOut();\nString s = this.getSection().toLowerCase();\n\/* ignore blank section definitions *\/\nif (StringTools.isBlank(s)) {\n\/\/ -- ignore\nreturn EVAL_PAGE;\n}\n\/* not a match? *\/\nif (!this.isMatch()) {\n\/\/ -- ignore\nreturn EVAL_PAGE;\n}\n\/\/ --------------------------------------------------------------------\n\/* \"onload='...'\" *\/\nif (s.equalsIgnoreCase(SECTION_BODY_ONLOAD)) {\nString bodyOnLoad = (String)request.getAttribute(SECTION_BODY_ONLOAD);\nif (!StringTools.isBlank(bodyOnLoad)) {\ntry {\nout.print(bodyOnLoad);\n} catch (IOException ioe) {\nthrow new JspTagException(ioe.toString());\n}\n}\nreturn EVAL_PAGE;\n}\n\/* \"onunload='...'\" *\/\nif (s.equalsIgnoreCase(SECTION_BODY_ONUNLOAD)) {\nString bodyOnUnload = (String)request.getAttribute(SECTION_BODY_ONUNLOAD);\nif (!StringTools.isBlank(bodyOnUnload)) {\ntry {\nout.print(bodyOnUnload);\n} catch (IOException ioe) {\nthrow new JspTagException(ioe.toString());\n}","label":[1,0,0,0]}
{"id":19480,"original_code":"synchronized boolean acceptFrame(\n        @NotNull VP8Frame frame,\n        int incomingIndex,\n        int externalTargetIndex, long receivedMs)\n    {\n        \/\/ We make local copies of the externalTemporalLayerIdTarget and the\n        \/\/ externalEncodingTarget (as they may be updated by some other\n        \/\/ thread).\n        int externalTemporalLayerIdTarget\n            = RtpLayerDesc.getTidFromIndex(externalTargetIndex);\n        int externalEncodingIdTarget\n            = RtpLayerDesc.getEidFromIndex(externalTargetIndex);\n        if (externalEncodingIdTarget != internalEncodingIdTarget)\n        {\n            \/\/ The externalEncodingIdTarget has changed since accept last\n            \/\/ run; perhaps we should request a keyframe.\n            internalEncodingIdTarget = externalEncodingIdTarget;\n            if (externalEncodingIdTarget > SUSPENDED_ENCODING_ID)\n            {\n                needsKeyframe = true;\n            }\n        }\n        if (externalEncodingIdTarget < 0\n            || externalTemporalLayerIdTarget < 0)\n        {\n            \/\/ We stop forwarding immediately. We will need a keyframe in order\n            \/\/ to resume.\n            currentEncodingId = SUSPENDED_ENCODING_ID;\n            return false;\n        }\n        int temporalLayerIdOfFrame = frame.getTemporalLayer();\n        if (temporalLayerIdOfFrame < 0)\n        {\n            \/\/ temporal scalability is not enabled. Pretend that\n            \/\/ this is the base temporal layer.\n            temporalLayerIdOfFrame = 0;\n        }\n        int encodingId = RtpLayerDesc.getEidFromIndex(incomingIndex);\n        if (frame.isKeyframe())\n        {\n            logger.debug(() -> \"Quality filter got keyframe for stream \"\n                    + frame.getSsrc());\n            return acceptKeyframe(encodingId, receivedMs);\n        }\n        else if (currentEncodingId > SUSPENDED_ENCODING_ID)\n        {\n            if (isOutOfSwitchingPhase(receivedMs) && isPossibleToSwitch(encodingId))\n            {\n                \/\/ XXX(george) i've noticed some \"rogue\" base layer keyframes\n                \/\/ that trigger this. what happens is the client sends a base\n                \/\/ layer key frame, the bridge switches to that layer because\n                \/\/ for all it knows it may be the only keyframe sent by the\n                \/\/ client engine. then the bridge notices that packets from the\n                \/\/ higher quality streams are flowing and execution ends-up\n                \/\/ here. it is a mystery why the engine is \"leaking\" base layer\n                \/\/ key frames\n                needsKeyframe = true;\n            }\n            if (encodingId != currentEncodingId)\n            {\n                \/\/ for non-keyframes, we can't route anything but the current encoding\n                return false;\n            }\n            \/\/ This branch reads the {@link #currentEncodingId} and it\n            \/\/ filters packets based on their temporal layer.\n            if (currentEncodingId > externalEncodingIdTarget)\n            {\n                \/\/ pending downscale, decrease the frame rate until we\n                \/\/ downscale.\n                return temporalLayerIdOfFrame < 1;\n            }\n            else if (currentEncodingId < externalEncodingIdTarget)\n            {\n                \/\/ pending upscale, increase the frame rate until we upscale.\n                return true;\n            }\n            else\n            {\n                \/\/ The currentSpatialLayerId matches exactly the target\n                \/\/ currentSpatialLayerId.\n                return temporalLayerIdOfFrame <= externalTemporalLayerIdTarget;\n            }\n        }\n        else\n        {\n            \/\/ In this branch we're not processing a keyframe and the\n            \/\/ currentSpatialLayerId is in suspended state, which means we need\n            \/\/ a keyframe to start streaming again. Reaching this point also\n            \/\/ means that we want to forward something (because both\n            \/\/ externalEncodingIdTarget and externalTemporalLayerIdTarget\n            \/\/ are greater than 0) so we set the request keyframe flag.\n            \/\/ assert needsKeyframe == true;\n            return false;\n        }\n    }","code":"synchronized boolean acceptFrame(\n        @NotNull VP8Frame frame,\n        int incomingIndex,\n        int externalTargetIndex, long receivedMs)\n    {\n       \n       \n       \n        int externalTemporalLayerIdTarget\n            = RtpLayerDesc.getTidFromIndex(externalTargetIndex);\n        int externalEncodingIdTarget\n            = RtpLayerDesc.getEidFromIndex(externalTargetIndex);\n        if (externalEncodingIdTarget != internalEncodingIdTarget)\n        {\n           \n           \n            internalEncodingIdTarget = externalEncodingIdTarget;\n            if (externalEncodingIdTarget > SUSPENDED_ENCODING_ID)\n            {\n                needsKeyframe = true;\n            }\n        }\n        if (externalEncodingIdTarget < 0\n            || externalTemporalLayerIdTarget < 0)\n        {\n           \n           \n            currentEncodingId = SUSPENDED_ENCODING_ID;\n            return false;\n        }\n        int temporalLayerIdOfFrame = frame.getTemporalLayer();\n        if (temporalLayerIdOfFrame < 0)\n        {\n           \n           \n            temporalLayerIdOfFrame = 0;\n        }\n        int encodingId = RtpLayerDesc.getEidFromIndex(incomingIndex);\n        if (frame.isKeyframe())\n        {\n            logger.debug(() -> \"Quality filter got keyframe for stream \"\n                    + frame.getSsrc());\n            return acceptKeyframe(encodingId, receivedMs);\n        }\n        else if (currentEncodingId > SUSPENDED_ENCODING_ID)\n        {\n            if (isOutOfSwitchingPhase(receivedMs) && isPossibleToSwitch(encodingId))\n            {\n               \n               \n               \n               \n               \n               \n               \n               \n                needsKeyframe = true;\n            }\n            if (encodingId != currentEncodingId)\n            {\n               \n                return false;\n            }\n           \n           \n            if (currentEncodingId > externalEncodingIdTarget)\n            {\n               \n               \n                return temporalLayerIdOfFrame < 1;\n            }\n            else if (currentEncodingId < externalEncodingIdTarget)\n            {\n               \n                return true;\n            }\n            else\n            {\n               \n               \n                return temporalLayerIdOfFrame <= externalTemporalLayerIdTarget;\n            }\n        }\n        else\n        {\n           \n           \n           \n           \n           \n           \n           \n            return false;\n        }\n    }","cleancode":"synchronized boolean acceptframe( @notnull vp8frame frame, int incomingindex, int externaltargetindex, long receivedms) { int externaltemporallayeridtarget = rtplayerdesc.gettidfromindex(externaltargetindex); int externalencodingidtarget = rtplayerdesc.geteidfromindex(externaltargetindex); if (externalencodingidtarget != internalencodingidtarget) { internalencodingidtarget = externalencodingidtarget; if (externalencodingidtarget > suspended_encoding_id) { needskeyframe = true; } } if (externalencodingidtarget < 0 || externaltemporallayeridtarget < 0) { currentencodingid = suspended_encoding_id; return false; } int temporallayeridofframe = frame.gettemporallayer(); if (temporallayeridofframe < 0) { temporallayeridofframe = 0; } int encodingid = rtplayerdesc.geteidfromindex(incomingindex); if (frame.iskeyframe()) { logger.debug(() -> \"quality filter got keyframe for stream \" + frame.getssrc()); return acceptkeyframe(encodingid, receivedms); } else if (currentencodingid > suspended_encoding_id) { if (isoutofswitchingphase(receivedms) && ispossibletoswitch(encodingid)) { needskeyframe = true; } if (encodingid != currentencodingid) { return false; } if (currentencodingid > externalencodingidtarget) { return temporallayeridofframe < 1; } else if (currentencodingid < externalencodingidtarget) { return true; } else { return temporallayeridofframe <= externaltemporallayeridtarget; } } else { return false; } }","comment":"\/** * determines whether to accept or drop a vp8 frame. * * note that, at the time of this writing, there's no practical need for a * synchronized keyword because there's only one thread accessing this * method at a time. * * @param frame the vp8 frame. * @param incomingindex the quality index of the incoming rtp packet * @param externaltargetindex the target quality index that the user of this * instance wants to achieve. * @param receivedms the current time (in millis) * @return true to accept the vp8 frame, otherwise false. *\/\n\/\/ we make local copies of the externaltemporallayeridtarget and the \/\/ externalencodingtarget (as they may be updated by some other \/\/ thread).\n\/\/ the externalencodingidtarget has changed since accept last \/\/ run; perhaps we should request a keyframe.\n\/\/ we stop forwarding immediately. we will need a keyframe in order \/\/ to resume.\n\/\/ temporal scalability is not enabled. pretend that \/\/ this is the base temporal layer.\n\/\/ xxx(george) i've noticed some \"rogue\" base layer keyframes \/\/ that trigger this. what happens is the client sends a base \/\/ layer key frame, the bridge switches to that layer because \/\/ for all it knows it may be the only keyframe sent by the \/\/ client engine. then the bridge notices that packets from the \/\/ higher quality streams are flowing and execution ends-up \/\/ here. it is a mystery why the engine is \"leaking\" base layer \/\/ key frames\n\/\/ for non-keyframes, we can't route anything but the current encoding\n\/\/ this branch reads the {@link #currentencodingid} and it \/\/ filters packets based on their temporal layer.\n\/\/ pending downscale, decrease the frame rate until we \/\/ downscale.\n\/\/ pending upscale, increase the frame rate until we upscale.\n\/\/ the currentspatiallayerid matches exactly the target \/\/ currentspatiallayerid.\n\/\/ in this branch we're not processing a keyframe and the \/\/ currentspatiallayerid is in suspended state, which means we need \/\/ a keyframe to start streaming again. reaching this point also \/\/ means that we want to forward something (because both \/\/ externalencodingidtarget and externaltemporallayeridtarget \/\/ are greater than 0) so we set the request keyframe flag. \/\/ assert needskeyframe == true;","repo":"ngi-nix\/jitsi-videobridge","code_context_2":"synchronized boolean acceptFrame(\n@NotNull VP8Frame frame,\nint incomingIndex,\nint externalTargetIndex, long receivedMs)\n{\n\/\/ We make local copies of the externalTemporalLayerIdTarget and the\n\/\/ externalEncodingTarget (as they may be updated by some other\n\/\/ thread).\nint externalTemporalLayerIdTarget\n= RtpLayerDesc.getTidFromIndex(externalTargetIndex);\nint externalEncodingIdTarget\n= RtpLayerDesc.getEidFromIndex(externalTargetIndex);\nif (externalEncodingIdTarget != internalEncodingIdTarget)\n{\n\/\/ The externalEncodingIdTarget has changed since accept last\n\/\/ run; perhaps we should request a keyframe.\ninternalEncodingIdTarget = externalEncodingIdTarget;\nif (externalEncodingIdTarget > SUSPENDED_ENCODING_ID)\n{\nneedsKeyframe = true;\n}\n}\nif (externalEncodingIdTarget < 0\n|| externalTemporalLayerIdTarget < 0)\n{\n\/\/ We stop forwarding immediately. We will need a keyframe in order\n\/\/ to resume.\ncurrentEncodingId = SUSPENDED_ENCODING_ID;\nreturn false;\n}\nint temporalLayerIdOfFrame = frame.getTemporalLayer();\nif (temporalLayerIdOfFrame < 0)\n{\n\/\/ temporal scalability is not enabled. Pretend that\n\/\/ this is the base temporal layer.\ntemporalLayerIdOfFrame = 0;\n}\nint encodingId = RtpLayerDesc.getEidFromIndex(incomingIndex);\nif (frame.isKeyframe())\n{\nlogger.debug(() -> \"Quality filter got keyframe for stream \"\n+ frame.getSsrc());\nreturn acceptKeyframe(encodingId, receivedMs);\n}\nelse if (currentEncodingId > SUSPENDED_ENCODING_ID)\n{\nif (isOutOfSwitchingPhase(receivedMs) && isPossibleToSwitch(encodingId))\n{\n\/\/ XXX(george) i've noticed some \"rogue\" base layer keyframes\n\/\/ that trigger this. what happens is the client sends a base\n\/\/ layer key frame, the bridge switches to that layer because\n\/\/ for all it knows it may be the only keyframe sent by the\n\/\/ client engine. then the bridge notices that packets from the\n\/\/ higher quality streams are flowing and execution ends-up\n\/\/ here. it is a mystery why the engine is \"leaking\" base layer\n\/\/ key frames\nneedsKeyframe = true;\n}\nif (encodingId != currentEncodingId)\n{\n\/\/ for non-keyframes, we can't route anything but the current encoding\nreturn false;\n}\n\/\/ This branch reads the {@link #currentEncodingId} and it\n\/\/ filters packets based on their temporal layer.\nif (currentEncodingId > externalEncodingIdTarget)\n{\n\/\/ pending downscale, decrease the frame rate until we\n\/\/ downscale.\nreturn temporalLayerIdOfFrame < 1;\n}\nelse if (currentEncodingId < externalEncodingIdTarget)\n{\n\/\/ pending upscale, increase the frame rate until we upscale.\nreturn true;\n}\nelse\n{\n\/\/ The currentSpatialLayerId matches exactly the target\n\/\/ currentSpatialLayerId.\nreturn temporalLayerIdOfFrame <= externalTemporalLayerIdTarget;\n}\n}\nelse\n{\n\/\/ In this branch we're not processing a keyframe and the\n\/\/ currentSpatialLayerId is in suspended state, which means we need\n\/\/ a keyframe to start streaming again. Reaching this point also\n\/\/ means that we want to forward something (because both\n\/\/ externalEncodingIdTarget and externalTemporalLayerIdTarget\n\/\/ are greater than 0) so we set the request keyframe flag.\n\/\/ assert needsKeyframe == true;\nreturn false;\n}\n}\n\nint externalTargetIndex, long receivedMs)\n{\n\/\/ We make local copies of the externalTemporalLayerIdTarget and the\n\/\/ externalEncodingTarget (as they may be updated by some other\n\/\/ thread).\nint externalTemporalLayerIdTarget\n= RtpLayerDesc.getTidFromIndex(externalTargetIndex);\n\nif (externalEncodingIdTarget != internalEncodingIdTarget)\n{\n\/\/ The externalEncodingIdTarget has changed since accept last\n\/\/ run; perhaps we should request a keyframe.\ninternalEncodingIdTarget = externalEncodingIdTarget;\nif (externalEncodingIdTarget > SUSPENDED_ENCODING_ID)\n\n|| externalTemporalLayerIdTarget < 0)\n{\n\/\/ We stop forwarding immediately. We will need a keyframe in order\n\/\/ to resume.\ncurrentEncodingId = SUSPENDED_ENCODING_ID;\nreturn false;\n\nif (temporalLayerIdOfFrame < 0)\n{\n\/\/ temporal scalability is not enabled. Pretend that\n\/\/ this is the base temporal layer.\ntemporalLayerIdOfFrame = 0;\n}\n\nif (isOutOfSwitchingPhase(receivedMs) && isPossibleToSwitch(encodingId))\n{\n\/\/ XXX(george) i've noticed some \"rogue\" base layer keyframes\n\/\/ that trigger this. what happens is the client sends a base\n\/\/ layer key frame, the bridge switches to that layer because\n\/\/ for all it knows it may be the only keyframe sent by the\n\/\/ client engine. then the bridge notices that packets from the\n\/\/ higher quality streams are flowing and execution ends-up\n\/\/ here. it is a mystery why the engine is \"leaking\" base layer\n\/\/ key frames\nneedsKeyframe = true;\n}\n\nif (encodingId != currentEncodingId)\n{\n\/\/ for non-keyframes, we can't route anything but the current encoding\nreturn false;\n}\n\nreturn false;\n}\n\/\/ This branch reads the {@link #currentEncodingId} and it\n\/\/ filters packets based on their temporal layer.\nif (currentEncodingId > externalEncodingIdTarget)\n{\n\nif (currentEncodingId > externalEncodingIdTarget)\n{\n\/\/ pending downscale, decrease the frame rate until we\n\/\/ downscale.\nreturn temporalLayerIdOfFrame < 1;\n}\n\nelse if (currentEncodingId < externalEncodingIdTarget)\n{\n\/\/ pending upscale, increase the frame rate until we upscale.\nreturn true;\n}\n\nelse\n{\n\/\/ The currentSpatialLayerId matches exactly the target\n\/\/ currentSpatialLayerId.\nreturn temporalLayerIdOfFrame <= externalTemporalLayerIdTarget;\n}\n\nelse\n{\n\/\/ In this branch we're not processing a keyframe and the\n\/\/ currentSpatialLayerId is in suspended state, which means we need\n\/\/ a keyframe to start streaming again. Reaching this point also\n\/\/ means that we want to forward something (because both\n\/\/ externalEncodingIdTarget and externalTemporalLayerIdTarget\n\/\/ are greater than 0) so we set the request keyframe flag.\n\/\/ assert needsKeyframe == true;\nreturn false;\n}","code_context_10":"synchronized boolean acceptFrame(\n@NotNull VP8Frame frame,\nint incomingIndex,\nint externalTargetIndex, long receivedMs)\n{\n\/\/ We make local copies of the externalTemporalLayerIdTarget and the\n\/\/ externalEncodingTarget (as they may be updated by some other\n\/\/ thread).\nint externalTemporalLayerIdTarget\n= RtpLayerDesc.getTidFromIndex(externalTargetIndex);\nint externalEncodingIdTarget\n= RtpLayerDesc.getEidFromIndex(externalTargetIndex);\nif (externalEncodingIdTarget != internalEncodingIdTarget)\n{\n\/\/ The externalEncodingIdTarget has changed since accept last\n\/\/ run; perhaps we should request a keyframe.\ninternalEncodingIdTarget = externalEncodingIdTarget;\nif (externalEncodingIdTarget > SUSPENDED_ENCODING_ID)\n{\nneedsKeyframe = true;\n}\n}\nif (externalEncodingIdTarget < 0\n|| externalTemporalLayerIdTarget < 0)\n{\n\/\/ We stop forwarding immediately. We will need a keyframe in order\n\/\/ to resume.\ncurrentEncodingId = SUSPENDED_ENCODING_ID;\nreturn false;\n}\nint temporalLayerIdOfFrame = frame.getTemporalLayer();\nif (temporalLayerIdOfFrame < 0)\n{\n\/\/ temporal scalability is not enabled. Pretend that\n\/\/ this is the base temporal layer.\ntemporalLayerIdOfFrame = 0;\n}\nint encodingId = RtpLayerDesc.getEidFromIndex(incomingIndex);\nif (frame.isKeyframe())\n{\nlogger.debug(() -> \"Quality filter got keyframe for stream \"\n+ frame.getSsrc());\nreturn acceptKeyframe(encodingId, receivedMs);\n}\nelse if (currentEncodingId > SUSPENDED_ENCODING_ID)\n{\nif (isOutOfSwitchingPhase(receivedMs) && isPossibleToSwitch(encodingId))\n{\n\/\/ XXX(george) i've noticed some \"rogue\" base layer keyframes\n\/\/ that trigger this. what happens is the client sends a base\n\/\/ layer key frame, the bridge switches to that layer because\n\/\/ for all it knows it may be the only keyframe sent by the\n\/\/ client engine. then the bridge notices that packets from the\n\/\/ higher quality streams are flowing and execution ends-up\n\/\/ here. it is a mystery why the engine is \"leaking\" base layer\n\/\/ key frames\nneedsKeyframe = true;\n}\nif (encodingId != currentEncodingId)\n{\n\/\/ for non-keyframes, we can't route anything but the current encoding\nreturn false;\n}\n\/\/ This branch reads the {@link #currentEncodingId} and it\n\/\/ filters packets based on their temporal layer.\nif (currentEncodingId > externalEncodingIdTarget)\n{\n\/\/ pending downscale, decrease the frame rate until we\n\/\/ downscale.\nreturn temporalLayerIdOfFrame < 1;\n}\nelse if (currentEncodingId < externalEncodingIdTarget)\n{\n\/\/ pending upscale, increase the frame rate until we upscale.\nreturn true;\n}\nelse\n{\n\/\/ The currentSpatialLayerId matches exactly the target\n\/\/ currentSpatialLayerId.\nreturn temporalLayerIdOfFrame <= externalTemporalLayerIdTarget;\n}\n}\nelse\n{\n\/\/ In this branch we're not processing a keyframe and the\n\/\/ currentSpatialLayerId is in suspended state, which means we need\n\/\/ a keyframe to start streaming again. Reaching this point also\n\/\/ means that we want to forward something (because both\n\/\/ externalEncodingIdTarget and externalTemporalLayerIdTarget\n\/\/ are greater than 0) so we set the request keyframe flag.\n\/\/ assert needsKeyframe == true;\nreturn false;\n}\n}\n\nsynchronized boolean acceptFrame(\n@NotNull VP8Frame frame,\nint incomingIndex,\nint externalTargetIndex, long receivedMs)\n{\n\/\/ We make local copies of the externalTemporalLayerIdTarget and the\n\/\/ externalEncodingTarget (as they may be updated by some other\n\/\/ thread).\nint externalTemporalLayerIdTarget\n= RtpLayerDesc.getTidFromIndex(externalTargetIndex);\nint externalEncodingIdTarget\n= RtpLayerDesc.getEidFromIndex(externalTargetIndex);\nif (externalEncodingIdTarget != internalEncodingIdTarget)\n{\n\/\/ The externalEncodingIdTarget has changed since accept last\n\/\/ run; perhaps we should request a keyframe.\ninternalEncodingIdTarget = externalEncodingIdTarget;\nif (externalEncodingIdTarget > SUSPENDED_ENCODING_ID)\n\n{\n\/\/ We make local copies of the externalTemporalLayerIdTarget and the\n\/\/ externalEncodingTarget (as they may be updated by some other\n\/\/ thread).\nint externalTemporalLayerIdTarget\n= RtpLayerDesc.getTidFromIndex(externalTargetIndex);\nint externalEncodingIdTarget\n= RtpLayerDesc.getEidFromIndex(externalTargetIndex);\nif (externalEncodingIdTarget != internalEncodingIdTarget)\n{\n\/\/ The externalEncodingIdTarget has changed since accept last\n\/\/ run; perhaps we should request a keyframe.\ninternalEncodingIdTarget = externalEncodingIdTarget;\nif (externalEncodingIdTarget > SUSPENDED_ENCODING_ID)\n{\nneedsKeyframe = true;\n}\n}\nif (externalEncodingIdTarget < 0\n|| externalTemporalLayerIdTarget < 0)\n{\n\/\/ We stop forwarding immediately. We will need a keyframe in order\n\n\/\/ run; perhaps we should request a keyframe.\ninternalEncodingIdTarget = externalEncodingIdTarget;\nif (externalEncodingIdTarget > SUSPENDED_ENCODING_ID)\n{\nneedsKeyframe = true;\n}\n}\nif (externalEncodingIdTarget < 0\n|| externalTemporalLayerIdTarget < 0)\n{\n\/\/ We stop forwarding immediately. We will need a keyframe in order\n\/\/ to resume.\ncurrentEncodingId = SUSPENDED_ENCODING_ID;\nreturn false;\n}\nint temporalLayerIdOfFrame = frame.getTemporalLayer();\nif (temporalLayerIdOfFrame < 0)\n{\n\/\/ temporal scalability is not enabled. Pretend that\n\/\/ this is the base temporal layer.\ntemporalLayerIdOfFrame = 0;\n}\n\n|| externalTemporalLayerIdTarget < 0)\n{\n\/\/ We stop forwarding immediately. We will need a keyframe in order\n\/\/ to resume.\ncurrentEncodingId = SUSPENDED_ENCODING_ID;\nreturn false;\n}\nint temporalLayerIdOfFrame = frame.getTemporalLayer();\nif (temporalLayerIdOfFrame < 0)\n{\n\/\/ temporal scalability is not enabled. Pretend that\n\/\/ this is the base temporal layer.\ntemporalLayerIdOfFrame = 0;\n}\nint encodingId = RtpLayerDesc.getEidFromIndex(incomingIndex);\nif (frame.isKeyframe())\n{\nlogger.debug(() -> \"Quality filter got keyframe for stream \"\n+ frame.getSsrc());\nreturn acceptKeyframe(encodingId, receivedMs);\n}\nelse if (currentEncodingId > SUSPENDED_ENCODING_ID)\n\nif (frame.isKeyframe())\n{\nlogger.debug(() -> \"Quality filter got keyframe for stream \"\n+ frame.getSsrc());\nreturn acceptKeyframe(encodingId, receivedMs);\n}\nelse if (currentEncodingId > SUSPENDED_ENCODING_ID)\n{\nif (isOutOfSwitchingPhase(receivedMs) && isPossibleToSwitch(encodingId))\n{\n\/\/ XXX(george) i've noticed some \"rogue\" base layer keyframes\n\/\/ that trigger this. what happens is the client sends a base\n\/\/ layer key frame, the bridge switches to that layer because\n\/\/ for all it knows it may be the only keyframe sent by the\n\/\/ client engine. then the bridge notices that packets from the\n\/\/ higher quality streams are flowing and execution ends-up\n\/\/ here. it is a mystery why the engine is \"leaking\" base layer\n\/\/ key frames\nneedsKeyframe = true;\n}\nif (encodingId != currentEncodingId)\n{\n\/\/ for non-keyframes, we can't route anything but the current encoding\nreturn false;\n}\n\/\/ This branch reads the {@link #currentEncodingId} and it\n\/\/ filters packets based on their temporal layer.\nif (currentEncodingId > externalEncodingIdTarget)\n\n\/\/ layer key frame, the bridge switches to that layer because\n\/\/ for all it knows it may be the only keyframe sent by the\n\/\/ client engine. then the bridge notices that packets from the\n\/\/ higher quality streams are flowing and execution ends-up\n\/\/ here. it is a mystery why the engine is \"leaking\" base layer\n\/\/ key frames\nneedsKeyframe = true;\n}\nif (encodingId != currentEncodingId)\n{\n\/\/ for non-keyframes, we can't route anything but the current encoding\nreturn false;\n}\n\/\/ This branch reads the {@link #currentEncodingId} and it\n\/\/ filters packets based on their temporal layer.\nif (currentEncodingId > externalEncodingIdTarget)\n{\n\/\/ pending downscale, decrease the frame rate until we\n\/\/ downscale.\nreturn temporalLayerIdOfFrame < 1;\n}\n\n\/\/ higher quality streams are flowing and execution ends-up\n\/\/ here. it is a mystery why the engine is \"leaking\" base layer\n\/\/ key frames\nneedsKeyframe = true;\n}\nif (encodingId != currentEncodingId)\n{\n\/\/ for non-keyframes, we can't route anything but the current encoding\nreturn false;\n}\n\/\/ This branch reads the {@link #currentEncodingId} and it\n\/\/ filters packets based on their temporal layer.\nif (currentEncodingId > externalEncodingIdTarget)\n{\n\/\/ pending downscale, decrease the frame rate until we\n\/\/ downscale.\nreturn temporalLayerIdOfFrame < 1;\n}\nelse if (currentEncodingId < externalEncodingIdTarget)\n{\n\/\/ pending upscale, increase the frame rate until we upscale.\nreturn true;\n\n}\nif (encodingId != currentEncodingId)\n{\n\/\/ for non-keyframes, we can't route anything but the current encoding\nreturn false;\n}\n\/\/ This branch reads the {@link #currentEncodingId} and it\n\/\/ filters packets based on their temporal layer.\nif (currentEncodingId > externalEncodingIdTarget)\n{\n\/\/ pending downscale, decrease the frame rate until we\n\/\/ downscale.\nreturn temporalLayerIdOfFrame < 1;\n}\nelse if (currentEncodingId < externalEncodingIdTarget)\n{\n\/\/ pending upscale, increase the frame rate until we upscale.\nreturn true;\n}\nelse\n{\n\/\/ The currentSpatialLayerId matches exactly the target\n\n\/\/ This branch reads the {@link #currentEncodingId} and it\n\/\/ filters packets based on their temporal layer.\nif (currentEncodingId > externalEncodingIdTarget)\n{\n\/\/ pending downscale, decrease the frame rate until we\n\/\/ downscale.\nreturn temporalLayerIdOfFrame < 1;\n}\nelse if (currentEncodingId < externalEncodingIdTarget)\n{\n\/\/ pending upscale, increase the frame rate until we upscale.\nreturn true;\n}\nelse\n{\n\/\/ The currentSpatialLayerId matches exactly the target\n\/\/ currentSpatialLayerId.\nreturn temporalLayerIdOfFrame <= externalTemporalLayerIdTarget;\n}\n}\nelse\n\n\/\/ downscale.\nreturn temporalLayerIdOfFrame < 1;\n}\nelse if (currentEncodingId < externalEncodingIdTarget)\n{\n\/\/ pending upscale, increase the frame rate until we upscale.\nreturn true;\n}\nelse\n{\n\/\/ The currentSpatialLayerId matches exactly the target\n\/\/ currentSpatialLayerId.\nreturn temporalLayerIdOfFrame <= externalTemporalLayerIdTarget;\n}\n}\nelse\n{\n\/\/ In this branch we're not processing a keyframe and the\n\/\/ currentSpatialLayerId is in suspended state, which means we need\n\/\/ a keyframe to start streaming again. Reaching this point also\n\/\/ means that we want to forward something (because both\n\/\/ externalEncodingIdTarget and externalTemporalLayerIdTarget\n\n}\nelse\n{\n\/\/ The currentSpatialLayerId matches exactly the target\n\/\/ currentSpatialLayerId.\nreturn temporalLayerIdOfFrame <= externalTemporalLayerIdTarget;\n}\n}\nelse\n{\n\/\/ In this branch we're not processing a keyframe and the\n\/\/ currentSpatialLayerId is in suspended state, which means we need\n\/\/ a keyframe to start streaming again. Reaching this point also\n\/\/ means that we want to forward something (because both\n\/\/ externalEncodingIdTarget and externalTemporalLayerIdTarget\n\/\/ are greater than 0) so we set the request keyframe flag.\n\/\/ assert needsKeyframe == true;\nreturn false;\n}\n}","code_context_20":"synchronized boolean acceptFrame(\n@NotNull VP8Frame frame,\nint incomingIndex,\nint externalTargetIndex, long receivedMs)\n{\n\/\/ We make local copies of the externalTemporalLayerIdTarget and the\n\/\/ externalEncodingTarget (as they may be updated by some other\n\/\/ thread).\nint externalTemporalLayerIdTarget\n= RtpLayerDesc.getTidFromIndex(externalTargetIndex);\nint externalEncodingIdTarget\n= RtpLayerDesc.getEidFromIndex(externalTargetIndex);\nif (externalEncodingIdTarget != internalEncodingIdTarget)\n{\n\/\/ The externalEncodingIdTarget has changed since accept last\n\/\/ run; perhaps we should request a keyframe.\ninternalEncodingIdTarget = externalEncodingIdTarget;\nif (externalEncodingIdTarget > SUSPENDED_ENCODING_ID)\n{\nneedsKeyframe = true;\n}\n}\nif (externalEncodingIdTarget < 0\n|| externalTemporalLayerIdTarget < 0)\n{\n\/\/ We stop forwarding immediately. We will need a keyframe in order\n\/\/ to resume.\ncurrentEncodingId = SUSPENDED_ENCODING_ID;\nreturn false;\n}\nint temporalLayerIdOfFrame = frame.getTemporalLayer();\nif (temporalLayerIdOfFrame < 0)\n{\n\/\/ temporal scalability is not enabled. Pretend that\n\/\/ this is the base temporal layer.\ntemporalLayerIdOfFrame = 0;\n}\nint encodingId = RtpLayerDesc.getEidFromIndex(incomingIndex);\nif (frame.isKeyframe())\n{\nlogger.debug(() -> \"Quality filter got keyframe for stream \"\n+ frame.getSsrc());\nreturn acceptKeyframe(encodingId, receivedMs);\n}\nelse if (currentEncodingId > SUSPENDED_ENCODING_ID)\n{\nif (isOutOfSwitchingPhase(receivedMs) && isPossibleToSwitch(encodingId))\n{\n\/\/ XXX(george) i've noticed some \"rogue\" base layer keyframes\n\/\/ that trigger this. what happens is the client sends a base\n\/\/ layer key frame, the bridge switches to that layer because\n\/\/ for all it knows it may be the only keyframe sent by the\n\/\/ client engine. then the bridge notices that packets from the\n\/\/ higher quality streams are flowing and execution ends-up\n\/\/ here. it is a mystery why the engine is \"leaking\" base layer\n\/\/ key frames\nneedsKeyframe = true;\n}\nif (encodingId != currentEncodingId)\n{\n\/\/ for non-keyframes, we can't route anything but the current encoding\nreturn false;\n}\n\/\/ This branch reads the {@link #currentEncodingId} and it\n\/\/ filters packets based on their temporal layer.\nif (currentEncodingId > externalEncodingIdTarget)\n{\n\/\/ pending downscale, decrease the frame rate until we\n\/\/ downscale.\nreturn temporalLayerIdOfFrame < 1;\n}\nelse if (currentEncodingId < externalEncodingIdTarget)\n{\n\/\/ pending upscale, increase the frame rate until we upscale.\nreturn true;\n}\nelse\n{\n\/\/ The currentSpatialLayerId matches exactly the target\n\/\/ currentSpatialLayerId.\nreturn temporalLayerIdOfFrame <= externalTemporalLayerIdTarget;\n}\n}\nelse\n{\n\/\/ In this branch we're not processing a keyframe and the\n\/\/ currentSpatialLayerId is in suspended state, which means we need\n\/\/ a keyframe to start streaming again. Reaching this point also\n\/\/ means that we want to forward something (because both\n\/\/ externalEncodingIdTarget and externalTemporalLayerIdTarget\n\/\/ are greater than 0) so we set the request keyframe flag.\n\/\/ assert needsKeyframe == true;\nreturn false;\n}\n}\n\nsynchronized boolean acceptFrame(\n@NotNull VP8Frame frame,\nint incomingIndex,\nint externalTargetIndex, long receivedMs)\n{\n\/\/ We make local copies of the externalTemporalLayerIdTarget and the\n\/\/ externalEncodingTarget (as they may be updated by some other\n\/\/ thread).\nint externalTemporalLayerIdTarget\n= RtpLayerDesc.getTidFromIndex(externalTargetIndex);\nint externalEncodingIdTarget\n= RtpLayerDesc.getEidFromIndex(externalTargetIndex);\nif (externalEncodingIdTarget != internalEncodingIdTarget)\n{\n\/\/ The externalEncodingIdTarget has changed since accept last\n\/\/ run; perhaps we should request a keyframe.\ninternalEncodingIdTarget = externalEncodingIdTarget;\nif (externalEncodingIdTarget > SUSPENDED_ENCODING_ID)\n{\nneedsKeyframe = true;\n}\n}\nif (externalEncodingIdTarget < 0\n|| externalTemporalLayerIdTarget < 0)\n{\n\/\/ We stop forwarding immediately. We will need a keyframe in order\n\/\/ to resume.\ncurrentEncodingId = SUSPENDED_ENCODING_ID;\n\nsynchronized boolean acceptFrame(\n@NotNull VP8Frame frame,\nint incomingIndex,\nint externalTargetIndex, long receivedMs)\n{\n\/\/ We make local copies of the externalTemporalLayerIdTarget and the\n\/\/ externalEncodingTarget (as they may be updated by some other\n\/\/ thread).\nint externalTemporalLayerIdTarget\n= RtpLayerDesc.getTidFromIndex(externalTargetIndex);\nint externalEncodingIdTarget\n= RtpLayerDesc.getEidFromIndex(externalTargetIndex);\nif (externalEncodingIdTarget != internalEncodingIdTarget)\n{\n\/\/ The externalEncodingIdTarget has changed since accept last\n\/\/ run; perhaps we should request a keyframe.\ninternalEncodingIdTarget = externalEncodingIdTarget;\nif (externalEncodingIdTarget > SUSPENDED_ENCODING_ID)\n{\nneedsKeyframe = true;\n}\n}\nif (externalEncodingIdTarget < 0\n|| externalTemporalLayerIdTarget < 0)\n{\n\/\/ We stop forwarding immediately. We will need a keyframe in order\n\/\/ to resume.\ncurrentEncodingId = SUSPENDED_ENCODING_ID;\nreturn false;\n}\nint temporalLayerIdOfFrame = frame.getTemporalLayer();\nif (temporalLayerIdOfFrame < 0)\n{\n\/\/ temporal scalability is not enabled. Pretend that\n\/\/ this is the base temporal layer.\ntemporalLayerIdOfFrame = 0;\n\n\/\/ We make local copies of the externalTemporalLayerIdTarget and the\n\/\/ externalEncodingTarget (as they may be updated by some other\n\/\/ thread).\nint externalTemporalLayerIdTarget\n= RtpLayerDesc.getTidFromIndex(externalTargetIndex);\nint externalEncodingIdTarget\n= RtpLayerDesc.getEidFromIndex(externalTargetIndex);\nif (externalEncodingIdTarget != internalEncodingIdTarget)\n{\n\/\/ The externalEncodingIdTarget has changed since accept last\n\/\/ run; perhaps we should request a keyframe.\ninternalEncodingIdTarget = externalEncodingIdTarget;\nif (externalEncodingIdTarget > SUSPENDED_ENCODING_ID)\n{\nneedsKeyframe = true;\n}\n}\nif (externalEncodingIdTarget < 0\n|| externalTemporalLayerIdTarget < 0)\n{\n\/\/ We stop forwarding immediately. We will need a keyframe in order\n\/\/ to resume.\ncurrentEncodingId = SUSPENDED_ENCODING_ID;\nreturn false;\n}\nint temporalLayerIdOfFrame = frame.getTemporalLayer();\nif (temporalLayerIdOfFrame < 0)\n{\n\/\/ temporal scalability is not enabled. Pretend that\n\/\/ this is the base temporal layer.\ntemporalLayerIdOfFrame = 0;\n}\nint encodingId = RtpLayerDesc.getEidFromIndex(incomingIndex);\nif (frame.isKeyframe())\n{\nlogger.debug(() -> \"Quality filter got keyframe for stream \"\n+ frame.getSsrc());\nreturn acceptKeyframe(encodingId, receivedMs);\n}\nelse if (currentEncodingId > SUSPENDED_ENCODING_ID)\n{\nif (isOutOfSwitchingPhase(receivedMs) && isPossibleToSwitch(encodingId))\n\n{\n\/\/ The externalEncodingIdTarget has changed since accept last\n\/\/ run; perhaps we should request a keyframe.\ninternalEncodingIdTarget = externalEncodingIdTarget;\nif (externalEncodingIdTarget > SUSPENDED_ENCODING_ID)\n{\nneedsKeyframe = true;\n}\n}\nif (externalEncodingIdTarget < 0\n|| externalTemporalLayerIdTarget < 0)\n{\n\/\/ We stop forwarding immediately. We will need a keyframe in order\n\/\/ to resume.\ncurrentEncodingId = SUSPENDED_ENCODING_ID;\nreturn false;\n}\nint temporalLayerIdOfFrame = frame.getTemporalLayer();\nif (temporalLayerIdOfFrame < 0)\n{\n\/\/ temporal scalability is not enabled. Pretend that\n\/\/ this is the base temporal layer.\ntemporalLayerIdOfFrame = 0;\n}\nint encodingId = RtpLayerDesc.getEidFromIndex(incomingIndex);\nif (frame.isKeyframe())\n{\nlogger.debug(() -> \"Quality filter got keyframe for stream \"\n+ frame.getSsrc());\nreturn acceptKeyframe(encodingId, receivedMs);\n}\nelse if (currentEncodingId > SUSPENDED_ENCODING_ID)\n{\nif (isOutOfSwitchingPhase(receivedMs) && isPossibleToSwitch(encodingId))\n{\n\/\/ XXX(george) i've noticed some \"rogue\" base layer keyframes\n\/\/ that trigger this. what happens is the client sends a base\n\/\/ layer key frame, the bridge switches to that layer because\n\/\/ for all it knows it may be the only keyframe sent by the\n\/\/ client engine. then the bridge notices that packets from the\n\/\/ higher quality streams are flowing and execution ends-up\n\/\/ here. it is a mystery why the engine is \"leaking\" base layer\n\nreturn false;\n}\nint temporalLayerIdOfFrame = frame.getTemporalLayer();\nif (temporalLayerIdOfFrame < 0)\n{\n\/\/ temporal scalability is not enabled. Pretend that\n\/\/ this is the base temporal layer.\ntemporalLayerIdOfFrame = 0;\n}\nint encodingId = RtpLayerDesc.getEidFromIndex(incomingIndex);\nif (frame.isKeyframe())\n{\nlogger.debug(() -> \"Quality filter got keyframe for stream \"\n+ frame.getSsrc());\nreturn acceptKeyframe(encodingId, receivedMs);\n}\nelse if (currentEncodingId > SUSPENDED_ENCODING_ID)\n{\nif (isOutOfSwitchingPhase(receivedMs) && isPossibleToSwitch(encodingId))\n{\n\/\/ XXX(george) i've noticed some \"rogue\" base layer keyframes\n\/\/ that trigger this. what happens is the client sends a base\n\/\/ layer key frame, the bridge switches to that layer because\n\/\/ for all it knows it may be the only keyframe sent by the\n\/\/ client engine. then the bridge notices that packets from the\n\/\/ higher quality streams are flowing and execution ends-up\n\/\/ here. it is a mystery why the engine is \"leaking\" base layer\n\/\/ key frames\nneedsKeyframe = true;\n}\nif (encodingId != currentEncodingId)\n{\n\/\/ for non-keyframes, we can't route anything but the current encoding\nreturn false;\n}\n\/\/ This branch reads the {@link #currentEncodingId} and it\n\/\/ filters packets based on their temporal layer.\nif (currentEncodingId > externalEncodingIdTarget)\n{\n\/\/ pending downscale, decrease the frame rate until we\n\/\/ downscale.\nreturn temporalLayerIdOfFrame < 1;\n}\nelse if (currentEncodingId < externalEncodingIdTarget)\n{\n\/\/ pending upscale, increase the frame rate until we upscale.\nreturn true;\n}\n\nlogger.debug(() -> \"Quality filter got keyframe for stream \"\n+ frame.getSsrc());\nreturn acceptKeyframe(encodingId, receivedMs);\n}\nelse if (currentEncodingId > SUSPENDED_ENCODING_ID)\n{\nif (isOutOfSwitchingPhase(receivedMs) && isPossibleToSwitch(encodingId))\n{\n\/\/ XXX(george) i've noticed some \"rogue\" base layer keyframes\n\/\/ that trigger this. what happens is the client sends a base\n\/\/ layer key frame, the bridge switches to that layer because\n\/\/ for all it knows it may be the only keyframe sent by the\n\/\/ client engine. then the bridge notices that packets from the\n\/\/ higher quality streams are flowing and execution ends-up\n\/\/ here. it is a mystery why the engine is \"leaking\" base layer\n\/\/ key frames\nneedsKeyframe = true;\n}\nif (encodingId != currentEncodingId)\n{\n\/\/ for non-keyframes, we can't route anything but the current encoding\nreturn false;\n}\n\/\/ This branch reads the {@link #currentEncodingId} and it\n\/\/ filters packets based on their temporal layer.\nif (currentEncodingId > externalEncodingIdTarget)\n{\n\/\/ pending downscale, decrease the frame rate until we\n\/\/ downscale.\nreturn temporalLayerIdOfFrame < 1;\n}\nelse if (currentEncodingId < externalEncodingIdTarget)\n{\n\/\/ pending upscale, increase the frame rate until we upscale.\nreturn true;\n}\nelse\n{\n\/\/ The currentSpatialLayerId matches exactly the target\n\/\/ currentSpatialLayerId.\nreturn temporalLayerIdOfFrame <= externalTemporalLayerIdTarget;\n\n}\nelse if (currentEncodingId > SUSPENDED_ENCODING_ID)\n{\nif (isOutOfSwitchingPhase(receivedMs) && isPossibleToSwitch(encodingId))\n{\n\/\/ XXX(george) i've noticed some \"rogue\" base layer keyframes\n\/\/ that trigger this. what happens is the client sends a base\n\/\/ layer key frame, the bridge switches to that layer because\n\/\/ for all it knows it may be the only keyframe sent by the\n\/\/ client engine. then the bridge notices that packets from the\n\/\/ higher quality streams are flowing and execution ends-up\n\/\/ here. it is a mystery why the engine is \"leaking\" base layer\n\/\/ key frames\nneedsKeyframe = true;\n}\nif (encodingId != currentEncodingId)\n{\n\/\/ for non-keyframes, we can't route anything but the current encoding\nreturn false;\n}\n\/\/ This branch reads the {@link #currentEncodingId} and it\n\/\/ filters packets based on their temporal layer.\nif (currentEncodingId > externalEncodingIdTarget)\n{\n\/\/ pending downscale, decrease the frame rate until we\n\/\/ downscale.\nreturn temporalLayerIdOfFrame < 1;\n}\nelse if (currentEncodingId < externalEncodingIdTarget)\n{\n\/\/ pending upscale, increase the frame rate until we upscale.\nreturn true;\n}\nelse\n{\n\/\/ The currentSpatialLayerId matches exactly the target\n\/\/ currentSpatialLayerId.\nreturn temporalLayerIdOfFrame <= externalTemporalLayerIdTarget;\n}\n}\nelse\n{\n\n{\n\/\/ XXX(george) i've noticed some \"rogue\" base layer keyframes\n\/\/ that trigger this. what happens is the client sends a base\n\/\/ layer key frame, the bridge switches to that layer because\n\/\/ for all it knows it may be the only keyframe sent by the\n\/\/ client engine. then the bridge notices that packets from the\n\/\/ higher quality streams are flowing and execution ends-up\n\/\/ here. it is a mystery why the engine is \"leaking\" base layer\n\/\/ key frames\nneedsKeyframe = true;\n}\nif (encodingId != currentEncodingId)\n{\n\/\/ for non-keyframes, we can't route anything but the current encoding\nreturn false;\n}\n\/\/ This branch reads the {@link #currentEncodingId} and it\n\/\/ filters packets based on their temporal layer.\nif (currentEncodingId > externalEncodingIdTarget)\n{\n\/\/ pending downscale, decrease the frame rate until we\n\/\/ downscale.\nreturn temporalLayerIdOfFrame < 1;\n}\nelse if (currentEncodingId < externalEncodingIdTarget)\n{\n\/\/ pending upscale, increase the frame rate until we upscale.\nreturn true;\n}\nelse\n{\n\/\/ The currentSpatialLayerId matches exactly the target\n\/\/ currentSpatialLayerId.\nreturn temporalLayerIdOfFrame <= externalTemporalLayerIdTarget;\n}\n}\nelse\n{\n\/\/ In this branch we're not processing a keyframe and the\n\/\/ currentSpatialLayerId is in suspended state, which means we need\n\/\/ a keyframe to start streaming again. Reaching this point also\n\/\/ means that we want to forward something (because both\n\n\/\/ higher quality streams are flowing and execution ends-up\n\/\/ here. it is a mystery why the engine is \"leaking\" base layer\n\/\/ key frames\nneedsKeyframe = true;\n}\nif (encodingId != currentEncodingId)\n{\n\/\/ for non-keyframes, we can't route anything but the current encoding\nreturn false;\n}\n\/\/ This branch reads the {@link #currentEncodingId} and it\n\/\/ filters packets based on their temporal layer.\nif (currentEncodingId > externalEncodingIdTarget)\n{\n\/\/ pending downscale, decrease the frame rate until we\n\/\/ downscale.\nreturn temporalLayerIdOfFrame < 1;\n}\nelse if (currentEncodingId < externalEncodingIdTarget)\n{\n\/\/ pending upscale, increase the frame rate until we upscale.\nreturn true;\n}\nelse\n{\n\/\/ The currentSpatialLayerId matches exactly the target\n\/\/ currentSpatialLayerId.\nreturn temporalLayerIdOfFrame <= externalTemporalLayerIdTarget;\n}\n}\nelse\n{\n\/\/ In this branch we're not processing a keyframe and the\n\/\/ currentSpatialLayerId is in suspended state, which means we need\n\/\/ a keyframe to start streaming again. Reaching this point also\n\/\/ means that we want to forward something (because both\n\/\/ externalEncodingIdTarget and externalTemporalLayerIdTarget\n\/\/ are greater than 0) so we set the request keyframe flag.\n\/\/ assert needsKeyframe == true;\nreturn false;\n}\n\nif (encodingId != currentEncodingId)\n{\n\/\/ for non-keyframes, we can't route anything but the current encoding\nreturn false;\n}\n\/\/ This branch reads the {@link #currentEncodingId} and it\n\/\/ filters packets based on their temporal layer.\nif (currentEncodingId > externalEncodingIdTarget)\n{\n\/\/ pending downscale, decrease the frame rate until we\n\/\/ downscale.\nreturn temporalLayerIdOfFrame < 1;\n}\nelse if (currentEncodingId < externalEncodingIdTarget)\n{\n\/\/ pending upscale, increase the frame rate until we upscale.\nreturn true;\n}\nelse\n{\n\/\/ The currentSpatialLayerId matches exactly the target\n\/\/ currentSpatialLayerId.\nreturn temporalLayerIdOfFrame <= externalTemporalLayerIdTarget;\n}\n}\nelse\n{\n\/\/ In this branch we're not processing a keyframe and the\n\/\/ currentSpatialLayerId is in suspended state, which means we need\n\/\/ a keyframe to start streaming again. Reaching this point also\n\/\/ means that we want to forward something (because both\n\/\/ externalEncodingIdTarget and externalTemporalLayerIdTarget\n\/\/ are greater than 0) so we set the request keyframe flag.\n\/\/ assert needsKeyframe == true;\nreturn false;\n}\n}\n\nif (currentEncodingId > externalEncodingIdTarget)\n{\n\/\/ pending downscale, decrease the frame rate until we\n\/\/ downscale.\nreturn temporalLayerIdOfFrame < 1;\n}\nelse if (currentEncodingId < externalEncodingIdTarget)\n{\n\/\/ pending upscale, increase the frame rate until we upscale.\nreturn true;\n}\nelse\n{\n\/\/ The currentSpatialLayerId matches exactly the target\n\/\/ currentSpatialLayerId.\nreturn temporalLayerIdOfFrame <= externalTemporalLayerIdTarget;\n}\n}\nelse\n{\n\/\/ In this branch we're not processing a keyframe and the\n\/\/ currentSpatialLayerId is in suspended state, which means we need\n\/\/ a keyframe to start streaming again. Reaching this point also\n\/\/ means that we want to forward something (because both\n\/\/ externalEncodingIdTarget and externalTemporalLayerIdTarget\n\/\/ are greater than 0) so we set the request keyframe flag.\n\/\/ assert needsKeyframe == true;\nreturn false;\n}\n}","label":[1,0,0,0]}
{"id":19563,"original_code":"public static List getCRLs(X509Extension cert) {\n        \/\/ What follows is a poor man's CRL extractor, for those lacking\n        \/\/ a BouncyCastle \"bcprov.jar\" in their classpath.\n        \/\/ It's a very basic state-machine:  look for a standard URL scheme\n        \/\/ (such as http), and then start looking for a terminator.  After\n        \/\/ running hexdump a few times on these things, it looks to me like\n        \/\/ the UTF-8 value \"65533\" seems to happen near where these things\n        \/\/ terminate.  (Of course this stuff is ASN.1 and not UTF-8, but\n        \/\/ I happen to like some of the functions available to the String\n        \/\/ object).    - juliusdavies@cucbc.com, May 10th, 2006\n        byte[] bytes = cert.getExtensionValue(CRL_EXTENSION);\n        LinkedList httpCRLS = new LinkedList();\n        LinkedList ftpCRLS = new LinkedList();\n        LinkedList otherCRLS = new LinkedList();\n        if (bytes == null) {\n            \/\/ just return empty list\n            return httpCRLS;\n        } else {\n            String s;\n            try {\n                s = new String(bytes, \"UTF-8\");\n            }\n            catch (UnsupportedEncodingException uee) {\n                \/\/ We're screwed if this thing has more than one CRL, because\n                \/\/ the \"indeOf( (char) 65533 )\" below isn't going to work.\n                s = new String(bytes);\n            }\n            int pos = 0;\n            while (pos >= 0) {\n                int x = -1, y;\n                int[] indexes = new int[4];\n                indexes[0] = s.indexOf(\"http\", pos);\n                indexes[1] = s.indexOf(\"ldap\", pos);\n                indexes[2] = s.indexOf(\"file\", pos);\n                indexes[3] = s.indexOf(\"ftp\", pos);\n                Arrays.sort(indexes);\n                for (int i = 0; i < indexes.length; i++) {\n                    if (indexes[i] >= 0) {\n                        x = indexes[i];\n                        break;\n                    }\n                }\n                if (x >= 0) {\n                    y = s.indexOf((char) 65533, x);\n                    String crl = y > x ? s.substring(x, y - 1) : s.substring(x);\n                    if (y > x && crl.endsWith(\"0\")) {\n                        crl = crl.substring(0, crl.length() - 1);\n                    }\n                    String crlTest = crl.trim().toLowerCase();\n                    if (crlTest.startsWith(\"http\")) {\n                        httpCRLS.add(crl);\n                    } else if (crlTest.startsWith(\"ftp\")) {\n                        ftpCRLS.add(crl);\n                    } else {\n                        otherCRLS.add(crl);\n                    }\n                    pos = y;\n                } else {\n                    pos = -1;\n                }\n            }\n        }\n        httpCRLS.addAll(ftpCRLS);\n        httpCRLS.addAll(otherCRLS);\n        return httpCRLS;\n    }","code":"public static List getCRLs(X509Extension cert) {\n       \n       \n       \n       \n       \n       \n       \n       \n       \n        byte[] bytes = cert.getExtensionValue(CRL_EXTENSION);\n        LinkedList httpCRLS = new LinkedList();\n        LinkedList ftpCRLS = new LinkedList();\n        LinkedList otherCRLS = new LinkedList();\n        if (bytes == null) {\n           \n            return httpCRLS;\n        } else {\n            String s;\n            try {\n                s = new String(bytes, \"UTF-8\");\n            }\n            catch (UnsupportedEncodingException uee) {\n               \n               \n                s = new String(bytes);\n            }\n            int pos = 0;\n            while (pos >= 0) {\n                int x = -1, y;\n                int[] indexes = new int[4];\n                indexes[0] = s.indexOf(\"http\", pos);\n                indexes[1] = s.indexOf(\"ldap\", pos);\n                indexes[2] = s.indexOf(\"file\", pos);\n                indexes[3] = s.indexOf(\"ftp\", pos);\n                Arrays.sort(indexes);\n                for (int i = 0; i < indexes.length; i++) {\n                    if (indexes[i] >= 0) {\n                        x = indexes[i];\n                        break;\n                    }\n                }\n                if (x >= 0) {\n                    y = s.indexOf((char) 65533, x);\n                    String crl = y > x ? s.substring(x, y - 1) : s.substring(x);\n                    if (y > x && crl.endsWith(\"0\")) {\n                        crl = crl.substring(0, crl.length() - 1);\n                    }\n                    String crlTest = crl.trim().toLowerCase();\n                    if (crlTest.startsWith(\"http\")) {\n                        httpCRLS.add(crl);\n                    } else if (crlTest.startsWith(\"ftp\")) {\n                        ftpCRLS.add(crl);\n                    } else {\n                        otherCRLS.add(crl);\n                    }\n                    pos = y;\n                } else {\n                    pos = -1;\n                }\n            }\n        }\n        httpCRLS.addAll(ftpCRLS);\n        httpCRLS.addAll(otherCRLS);\n        return httpCRLS;\n    }","cleancode":"public static list getcrls(x509extension cert) { byte[] bytes = cert.getextensionvalue(crl_extension); linkedlist httpcrls = new linkedlist(); linkedlist ftpcrls = new linkedlist(); linkedlist othercrls = new linkedlist(); if (bytes == null) { return httpcrls; } else { string s; try { s = new string(bytes, \"utf-8\"); } catch (unsupportedencodingexception uee) { s = new string(bytes); } int pos = 0; while (pos >= 0) { int x = -1, y; int[] indexes = new int[4]; indexes[0] = s.indexof(\"http\", pos); indexes[1] = s.indexof(\"ldap\", pos); indexes[2] = s.indexof(\"file\", pos); indexes[3] = s.indexof(\"ftp\", pos); arrays.sort(indexes); for (int i = 0; i < indexes.length; i++) { if (indexes[i] >= 0) { x = indexes[i]; break; } } if (x >= 0) { y = s.indexof((char) 65533, x); string crl = y > x ? s.substring(x, y - 1) : s.substring(x); if (y > x && crl.endswith(\"0\")) { crl = crl.substring(0, crl.length() - 1); } string crltest = crl.trim().tolowercase(); if (crltest.startswith(\"http\")) { httpcrls.add(crl); } else if (crltest.startswith(\"ftp\")) { ftpcrls.add(crl); } else { othercrls.add(crl); } pos = y; } else { pos = -1; } } } httpcrls.addall(ftpcrls); httpcrls.addall(othercrls); return httpcrls; }","comment":"\/\/ what follows is a poor man's crl extractor, for those lacking \/\/ a bouncycastle \"bcprov.jar\" in their classpath. \/\/ it's a very basic state-machine: look for a standard url scheme \/\/ (such as http), and then start looking for a terminator. after \/\/ running hexdump a few times on these things, it looks to me like \/\/ the utf-8 value \"65533\" seems to happen near where these things \/\/ terminate. (of course this stuff is asn.1 and not utf-8, but \/\/ i happen to like some of the functions available to the string \/\/ object). - juliusdavies@cucbc.com, may 10th, 2006\n\/\/ just return empty list\n\/\/ we're screwed if this thing has more than one crl, because \/\/ the \"indeof( (char) 65533 )\" below isn't going to work.","repo":"rcbj\/apigee-jwt-aad-timeapi-proxy","code_context_2":"public static List getCRLs(X509Extension cert) {\n\/\/ What follows is a poor man's CRL extractor, for those lacking\n\/\/ a BouncyCastle \"bcprov.jar\" in their classpath.\n\/\/ It's a very basic state-machine: look for a standard URL scheme\n\/\/ (such as http), and then start looking for a terminator. After\n\/\/ running hexdump a few times on these things, it looks to me like\n\/\/ the UTF-8 value \"65533\" seems to happen near where these things\n\/\/ terminate. (Of course this stuff is ASN.1 and not UTF-8, but\n\/\/ I happen to like some of the functions available to the String\n\/\/ object). - juliusdavies@cucbc.com, May 10th, 2006\nbyte[] bytes = cert.getExtensionValue(CRL_EXTENSION);\nLinkedList httpCRLS = new LinkedList();\n\nLinkedList otherCRLS = new LinkedList();\nif (bytes == null) {\n\/\/ just return empty list\nreturn httpCRLS;\n} else {\n\n}\ncatch (UnsupportedEncodingException uee) {\n\/\/ We're screwed if this thing has more than one CRL, because\n\/\/ the \"indeOf( (char) 65533 )\" below isn't going to work.\ns = new String(bytes);\n}","code_context_10":"public static List getCRLs(X509Extension cert) {\n\/\/ What follows is a poor man's CRL extractor, for those lacking\n\/\/ a BouncyCastle \"bcprov.jar\" in their classpath.\n\/\/ It's a very basic state-machine: look for a standard URL scheme\n\/\/ (such as http), and then start looking for a terminator. After\n\/\/ running hexdump a few times on these things, it looks to me like\n\/\/ the UTF-8 value \"65533\" seems to happen near where these things\n\/\/ terminate. (Of course this stuff is ASN.1 and not UTF-8, but\n\/\/ I happen to like some of the functions available to the String\n\/\/ object). - juliusdavies@cucbc.com, May 10th, 2006\nbyte[] bytes = cert.getExtensionValue(CRL_EXTENSION);\nLinkedList httpCRLS = new LinkedList();\nLinkedList ftpCRLS = new LinkedList();\nLinkedList otherCRLS = new LinkedList();\nif (bytes == null) {\n\/\/ just return empty list\nreturn httpCRLS;\n} else {\nString s;\ntry {\n\n\/\/ running hexdump a few times on these things, it looks to me like\n\/\/ the UTF-8 value \"65533\" seems to happen near where these things\n\/\/ terminate. (Of course this stuff is ASN.1 and not UTF-8, but\n\/\/ I happen to like some of the functions available to the String\n\/\/ object). - juliusdavies@cucbc.com, May 10th, 2006\nbyte[] bytes = cert.getExtensionValue(CRL_EXTENSION);\nLinkedList httpCRLS = new LinkedList();\nLinkedList ftpCRLS = new LinkedList();\nLinkedList otherCRLS = new LinkedList();\nif (bytes == null) {\n\/\/ just return empty list\nreturn httpCRLS;\n} else {\nString s;\ntry {\ns = new String(bytes, \"UTF-8\");\n}\ncatch (UnsupportedEncodingException uee) {\n\/\/ We're screwed if this thing has more than one CRL, because\n\/\/ the \"indeOf( (char) 65533 )\" below isn't going to work.\ns = new String(bytes);\n\nLinkedList otherCRLS = new LinkedList();\nif (bytes == null) {\n\/\/ just return empty list\nreturn httpCRLS;\n} else {\nString s;\ntry {\ns = new String(bytes, \"UTF-8\");\n}\ncatch (UnsupportedEncodingException uee) {\n\/\/ We're screwed if this thing has more than one CRL, because\n\/\/ the \"indeOf( (char) 65533 )\" below isn't going to work.\ns = new String(bytes);\n}\nint pos = 0;\nwhile (pos >= 0) {\nint x = -1, y;\nint[] indexes = new int[4];\nindexes[0] = s.indexOf(\"http\", pos);\nindexes[1] = s.indexOf(\"ldap\", pos);\nindexes[2] = s.indexOf(\"file\", pos);\nindexes[3] = s.indexOf(\"ftp\", pos);","code_context_20":"public static List getCRLs(X509Extension cert) {\n\/\/ What follows is a poor man's CRL extractor, for those lacking\n\/\/ a BouncyCastle \"bcprov.jar\" in their classpath.\n\/\/ It's a very basic state-machine: look for a standard URL scheme\n\/\/ (such as http), and then start looking for a terminator. After\n\/\/ running hexdump a few times on these things, it looks to me like\n\/\/ the UTF-8 value \"65533\" seems to happen near where these things\n\/\/ terminate. (Of course this stuff is ASN.1 and not UTF-8, but\n\/\/ I happen to like some of the functions available to the String\n\/\/ object). - juliusdavies@cucbc.com, May 10th, 2006\nbyte[] bytes = cert.getExtensionValue(CRL_EXTENSION);\nLinkedList httpCRLS = new LinkedList();\nLinkedList ftpCRLS = new LinkedList();\nLinkedList otherCRLS = new LinkedList();\nif (bytes == null) {\n\/\/ just return empty list\nreturn httpCRLS;\n} else {\nString s;\ntry {\ns = new String(bytes, \"UTF-8\");\n}\ncatch (UnsupportedEncodingException uee) {\n\/\/ We're screwed if this thing has more than one CRL, because\n\/\/ the \"indeOf( (char) 65533 )\" below isn't going to work.\ns = new String(bytes);\n}\nint pos = 0;\nwhile (pos >= 0) {\nint x = -1, y;\n\npublic static List getCRLs(X509Extension cert) {\n\/\/ What follows is a poor man's CRL extractor, for those lacking\n\/\/ a BouncyCastle \"bcprov.jar\" in their classpath.\n\/\/ It's a very basic state-machine: look for a standard URL scheme\n\/\/ (such as http), and then start looking for a terminator. After\n\/\/ running hexdump a few times on these things, it looks to me like\n\/\/ the UTF-8 value \"65533\" seems to happen near where these things\n\/\/ terminate. (Of course this stuff is ASN.1 and not UTF-8, but\n\/\/ I happen to like some of the functions available to the String\n\/\/ object). - juliusdavies@cucbc.com, May 10th, 2006\nbyte[] bytes = cert.getExtensionValue(CRL_EXTENSION);\nLinkedList httpCRLS = new LinkedList();\nLinkedList ftpCRLS = new LinkedList();\nLinkedList otherCRLS = new LinkedList();\nif (bytes == null) {\n\/\/ just return empty list\nreturn httpCRLS;\n} else {\nString s;\ntry {\ns = new String(bytes, \"UTF-8\");\n}\ncatch (UnsupportedEncodingException uee) {\n\/\/ We're screwed if this thing has more than one CRL, because\n\/\/ the \"indeOf( (char) 65533 )\" below isn't going to work.\ns = new String(bytes);\n}\nint pos = 0;\nwhile (pos >= 0) {\nint x = -1, y;\nint[] indexes = new int[4];\nindexes[0] = s.indexOf(\"http\", pos);\nindexes[1] = s.indexOf(\"ldap\", pos);\nindexes[2] = s.indexOf(\"file\", pos);\nindexes[3] = s.indexOf(\"ftp\", pos);\nArrays.sort(indexes);\n\n\/\/ It's a very basic state-machine: look for a standard URL scheme\n\/\/ (such as http), and then start looking for a terminator. After\n\/\/ running hexdump a few times on these things, it looks to me like\n\/\/ the UTF-8 value \"65533\" seems to happen near where these things\n\/\/ terminate. (Of course this stuff is ASN.1 and not UTF-8, but\n\/\/ I happen to like some of the functions available to the String\n\/\/ object). - juliusdavies@cucbc.com, May 10th, 2006\nbyte[] bytes = cert.getExtensionValue(CRL_EXTENSION);\nLinkedList httpCRLS = new LinkedList();\nLinkedList ftpCRLS = new LinkedList();\nLinkedList otherCRLS = new LinkedList();\nif (bytes == null) {\n\/\/ just return empty list\nreturn httpCRLS;\n} else {\nString s;\ntry {\ns = new String(bytes, \"UTF-8\");\n}\ncatch (UnsupportedEncodingException uee) {\n\/\/ We're screwed if this thing has more than one CRL, because\n\/\/ the \"indeOf( (char) 65533 )\" below isn't going to work.\ns = new String(bytes);\n}\nint pos = 0;\nwhile (pos >= 0) {\nint x = -1, y;\nint[] indexes = new int[4];\nindexes[0] = s.indexOf(\"http\", pos);\nindexes[1] = s.indexOf(\"ldap\", pos);\nindexes[2] = s.indexOf(\"file\", pos);\nindexes[3] = s.indexOf(\"ftp\", pos);\nArrays.sort(indexes);\nfor (int i = 0; i < indexes.length; i++) {\nif (indexes[i] >= 0) {\nx = indexes[i];\nbreak;\n}\n}\nif (x >= 0) {\ny = s.indexOf((char) 65533, x);\nString crl = y > x ? s.substring(x, y - 1) : s.substring(x);","label":[0,0,1,0]}
{"id":11379,"original_code":"public static int XColorByName(String nm) {\n\t\tfor (int i=0; i<data.length; i++) {\n\t\t\tSetting d = data[i];\n\t\t\t\/\/ System.out.println(\"Looking for \" + nm + \"; trying \" + d.name);\n\t\t\tif (nm.equalsIgnoreCase(d.name)) {\n\t\t\t\treturn d.value;\n\t\t\t}\n\t\t}\n\t\t\/\/ How sad... none of the 752 color names matched...\n\t\tthrow new IllegalArgumentException(\"Unknown color \" + nm);\n\t}","code":"public static int XColorByName(String nm) {\n\t\tfor (int i=0; i<data.length; i++) {\n\t\t\tSetting d = data[i];\n\t\t\n\t\t\tif (nm.equalsIgnoreCase(d.name)) {\n\t\t\t\treturn d.value;\n\t\t\t}\n\t\t}\n\t\n\t\tthrow new IllegalArgumentException(\"Unknown color \" + nm);\n\t}","cleancode":"public static int xcolorbyname(string nm) { for (int i=0; i<data.length; i++) { setting d = data[i]; if (nm.equalsignorecase(d.name)) { return d.value; } } throw new illegalargumentexception(\"unknown color \" + nm); }","comment":"\/\/ system.out.println(\"looking for \" + nm + \"; trying \" + d.name);\n\/\/ how sad... none of the 752 color names matched...","repo":"oritelad\/libro-de-actividades","code_context_2":"for (int i=0; i<data.length; i++) {\nSetting d = data[i];\n\/\/ System.out.println(\"Looking for \" + nm + \"; trying \" + d.name);\nif (nm.equalsIgnoreCase(d.name)) {\nreturn d.value;\n\n}\n}\n\/\/ How sad... none of the 752 color names matched...\nthrow new IllegalArgumentException(\"Unknown color \" + nm);\n}","code_context_10":"public static int XColorByName(String nm) {\nfor (int i=0; i<data.length; i++) {\nSetting d = data[i];\n\/\/ System.out.println(\"Looking for \" + nm + \"; trying \" + d.name);\nif (nm.equalsIgnoreCase(d.name)) {\nreturn d.value;\n}\n}\n\/\/ How sad... none of the 752 color names matched...\nthrow new IllegalArgumentException(\"Unknown color \" + nm);\n}\n\npublic static int XColorByName(String nm) {\nfor (int i=0; i<data.length; i++) {\nSetting d = data[i];\n\/\/ System.out.println(\"Looking for \" + nm + \"; trying \" + d.name);\nif (nm.equalsIgnoreCase(d.name)) {\nreturn d.value;\n}\n}\n\/\/ How sad... none of the 752 color names matched...\nthrow new IllegalArgumentException(\"Unknown color \" + nm);\n}","code_context_20":"public static int XColorByName(String nm) {\nfor (int i=0; i<data.length; i++) {\nSetting d = data[i];\n\/\/ System.out.println(\"Looking for \" + nm + \"; trying \" + d.name);\nif (nm.equalsIgnoreCase(d.name)) {\nreturn d.value;\n}\n}\n\/\/ How sad... none of the 752 color names matched...\nthrow new IllegalArgumentException(\"Unknown color \" + nm);\n}\n\npublic static int XColorByName(String nm) {\nfor (int i=0; i<data.length; i++) {\nSetting d = data[i];\n\/\/ System.out.println(\"Looking for \" + nm + \"; trying \" + d.name);\nif (nm.equalsIgnoreCase(d.name)) {\nreturn d.value;\n}\n}\n\/\/ How sad... none of the 752 color names matched...\nthrow new IllegalArgumentException(\"Unknown color \" + nm);\n}","label":[0,0,0,0]}
{"id":11380,"original_code":"public static String XColorByValue(int val) {\n\t\tfor (int i=0; i<data.length; i++) {\n\t\t\tSetting d = data[i];\n\t\t\t\/\/ System.out.println(\"Looking for \" + nm + \"; trying \" + d.name);\n\t\t\tif (val == d.value) {\n\t\t\t\treturn d.name;\n\t\t\t}\n\t\t}\n\t\t\/\/ How sad... none of the 752 color names matched...\n\t\treturn \"XColor(\" + val + \")\";\n\t}","code":"public static String XColorByValue(int val) {\n\t\tfor (int i=0; i<data.length; i++) {\n\t\t\tSetting d = data[i];\n\t\t\n\t\t\tif (val == d.value) {\n\t\t\t\treturn d.name;\n\t\t\t}\n\t\t}\n\t\n\t\treturn \"XColor(\" + val + \")\";\n\t}","cleancode":"public static string xcolorbyvalue(int val) { for (int i=0; i<data.length; i++) { setting d = data[i]; if (val == d.value) { return d.name; } } return \"xcolor(\" + val + \")\"; }","comment":"\/\/ system.out.println(\"looking for \" + nm + \"; trying \" + d.name);\n\/\/ how sad... none of the 752 color names matched...","repo":"oritelad\/libro-de-actividades","code_context_2":"for (int i=0; i<data.length; i++) {\nSetting d = data[i];\n\/\/ System.out.println(\"Looking for \" + nm + \"; trying \" + d.name);\nif (val == d.value) {\nreturn d.name;\n\n}\n}\n\/\/ How sad... none of the 752 color names matched...\nreturn \"XColor(\" + val + \")\";\n}","code_context_10":"public static String XColorByValue(int val) {\nfor (int i=0; i<data.length; i++) {\nSetting d = data[i];\n\/\/ System.out.println(\"Looking for \" + nm + \"; trying \" + d.name);\nif (val == d.value) {\nreturn d.name;\n}\n}\n\/\/ How sad... none of the 752 color names matched...\nreturn \"XColor(\" + val + \")\";\n}\n\npublic static String XColorByValue(int val) {\nfor (int i=0; i<data.length; i++) {\nSetting d = data[i];\n\/\/ System.out.println(\"Looking for \" + nm + \"; trying \" + d.name);\nif (val == d.value) {\nreturn d.name;\n}\n}\n\/\/ How sad... none of the 752 color names matched...\nreturn \"XColor(\" + val + \")\";\n}","code_context_20":"public static String XColorByValue(int val) {\nfor (int i=0; i<data.length; i++) {\nSetting d = data[i];\n\/\/ System.out.println(\"Looking for \" + nm + \"; trying \" + d.name);\nif (val == d.value) {\nreturn d.name;\n}\n}\n\/\/ How sad... none of the 752 color names matched...\nreturn \"XColor(\" + val + \")\";\n}\n\npublic static String XColorByValue(int val) {\nfor (int i=0; i<data.length; i++) {\nSetting d = data[i];\n\/\/ System.out.println(\"Looking for \" + nm + \"; trying \" + d.name);\nif (val == d.value) {\nreturn d.name;\n}\n}\n\/\/ How sad... none of the 752 color names matched...\nreturn \"XColor(\" + val + \")\";\n}","label":[0,0,0,0]}
{"id":11618,"original_code":"private static final boolean isHalfUlp (final double x) {\n    \/\/ TODO: do we need to check for NaN and infinity?\n    return (0.0 != x) && (0L == Doubles.significand(x)); }","code":"private static final boolean isHalfUlp (final double x) {\n   \n    return (0.0 != x) && (0L == Doubles.significand(x)); }","cleancode":"private static final boolean ishalfulp (final double x) { return (0.0 != x) && (0l == doubles.significand(x)); }","comment":"\/\/-------------------------------------------------------------- \/\/ ifastsum \/\/--------------------------------------------------------------\n\/\/ todo: do we need to check for nan and infinity?","repo":"palisades-lakes\/xfp-jmh","code_context_2":"private static final boolean isHalfUlp (final double x) {\n\/\/ TODO: do we need to check for NaN and infinity?\nreturn (0.0 != x) && (0L == Doubles.significand(x)); }\n\nprivate static final boolean isHalfUlp (final double x) {\n\/\/ TODO: do we need to check for NaN and infinity?\nreturn (0.0 != x) && (0L == Doubles.significand(x)); }","code_context_10":"private static final boolean isHalfUlp (final double x) {\n\/\/ TODO: do we need to check for NaN and infinity?\nreturn (0.0 != x) && (0L == Doubles.significand(x)); }\n\nprivate static final boolean isHalfUlp (final double x) {\n\/\/ TODO: do we need to check for NaN and infinity?\nreturn (0.0 != x) && (0L == Doubles.significand(x)); }","code_context_20":"private static final boolean isHalfUlp (final double x) {\n\/\/ TODO: do we need to check for NaN and infinity?\nreturn (0.0 != x) && (0L == Doubles.significand(x)); }\n\nprivate static final boolean isHalfUlp (final double x) {\n\/\/ TODO: do we need to check for NaN and infinity?\nreturn (0.0 != x) && (0L == Doubles.significand(x)); }","label":[1,0,0,0]}
{"id":11619,"original_code":"private static final double halfUlp (final double x) {\n    \/\/ TODO: do we need to check for NaN and infinity?\n    \/\/ TODO: compare to c++ implementation\n    \/\/ TODO: return zero when x is zero?\n    if (0.0 == x) { return 0.0; }\n    return 0.5 * Math.ulp(x); }","code":"private static final double halfUlp (final double x) {\n   \n   \n   \n    if (0.0 == x) { return 0.0; }\n    return 0.5 * Math.ulp(x); }","cleancode":"private static final double halfulp (final double x) { if (0.0 == x) { return 0.0; } return 0.5 * math.ulp(x); }","comment":"\/\/--------------------------------------------------------------\n\/\/ todo: do we need to check for nan and infinity? \/\/ todo: compare to c++ implementation \/\/ todo: return zero when x is zero?","repo":"palisades-lakes\/xfp-jmh","code_context_2":"private static final double halfUlp (final double x) {\n\/\/ TODO: do we need to check for NaN and infinity?\n\/\/ TODO: compare to c++ implementation\n\/\/ TODO: return zero when x is zero?\nif (0.0 == x) { return 0.0; }\nreturn 0.5 * Math.ulp(x); }\n\nprivate static final double halfUlp (final double x) {\n\/\/ TODO: do we need to check for NaN and infinity?\n\/\/ TODO: compare to c++ implementation\n\/\/ TODO: return zero when x is zero?\nif (0.0 == x) { return 0.0; }\nreturn 0.5 * Math.ulp(x); }","code_context_10":"private static final double halfUlp (final double x) {\n\/\/ TODO: do we need to check for NaN and infinity?\n\/\/ TODO: compare to c++ implementation\n\/\/ TODO: return zero when x is zero?\nif (0.0 == x) { return 0.0; }\nreturn 0.5 * Math.ulp(x); }\n\nprivate static final double halfUlp (final double x) {\n\/\/ TODO: do we need to check for NaN and infinity?\n\/\/ TODO: compare to c++ implementation\n\/\/ TODO: return zero when x is zero?\nif (0.0 == x) { return 0.0; }\nreturn 0.5 * Math.ulp(x); }","code_context_20":"private static final double halfUlp (final double x) {\n\/\/ TODO: do we need to check for NaN and infinity?\n\/\/ TODO: compare to c++ implementation\n\/\/ TODO: return zero when x is zero?\nif (0.0 == x) { return 0.0; }\nreturn 0.5 * Math.ulp(x); }\n\nprivate static final double halfUlp (final double x) {\n\/\/ TODO: do we need to check for NaN and infinity?\n\/\/ TODO: compare to c++ implementation\n\/\/ TODO: return zero when x is zero?\nif (0.0 == x) { return 0.0; }\nreturn 0.5 * Math.ulp(x); }","label":[1,0,0,0]}
{"id":11774,"original_code":"@Override\n    protected void parseSynchronusly() throws IOException {\n        final Optional<RDFFormat> formatByMimeType = getContentType().flatMap(Rio::getParserFormatForMIMEType);\n        final String base = getBase().map(IRI::getIRIString).orElse(null);\n        final ParserConfig parserConfig = getParserConfig();\n        \/\/ TODO: Should we need to set anything?\n        final RDFLoader loader = new RDFLoader(parserConfig, rdf4jTermFactory.getValueFactory());\n        final RDFHandler rdfHandler = makeRDFHandler();\n        if (getSourceFile().isPresent()) {\n            \/\/ NOTE: While we could have used\n            \/\/ loader.load(sourcePath.toFile()\n            \/\/ if the path fs provider == FileSystems.getDefault(),\n            \/\/ that RDFLoader method does not use absolute path\n            \/\/ as the base URI, so to be consistent\n            \/\/ we'll always do it with our own input stream\n            \/\/\n            \/\/ That means we may have to guess format by extensions:\n            final Optional<RDFFormat> formatByFilename = getSourceFile().map(Path::getFileName).map(Path::toString)\n                    .flatMap(Rio::getParserFormatForFileName);\n            \/\/ TODO: for the excited.. what about the extension after following\n            \/\/ symlinks?\n            final RDFFormat format = formatByMimeType.orElse(formatByFilename.orElse(null));\n            try (InputStream in = Files.newInputStream(getSourceFile().get())) {\n                loader.load(in, base, format, rdfHandler);\n            }\n        } else if (getSourceIri().isPresent()) {\n            try {\n                \/\/ TODO: Handle international IRIs properly\n                \/\/ (Unicode support for for hostname, path and query)\n                final URL url = new URL(getSourceIri().get().getIRIString());\n                \/\/ TODO: This probably does not support https:\/\/ -> http:\/\/\n                \/\/ redirections\n                loader.load(url, base, formatByMimeType.orElse(null), makeRDFHandler());\n            } catch (final MalformedURLException ex) {\n                throw new IOException(\"Can't handle source URL: \" + getSourceIri().get(), ex);\n            }\n        }\n        \/\/ must be getSourceInputStream then, this is guaranteed by\n        \/\/ super.checkSource();\n        loader.load(getSourceInputStream().get(), base, formatByMimeType.orElse(null), rdfHandler);\n    }","code":"@Override\n    protected void parseSynchronusly() throws IOException {\n        final Optional<RDFFormat> formatByMimeType = getContentType().flatMap(Rio::getParserFormatForMIMEType);\n        final String base = getBase().map(IRI::getIRIString).orElse(null);\n        final ParserConfig parserConfig = getParserConfig();\n       \n        final RDFLoader loader = new RDFLoader(parserConfig, rdf4jTermFactory.getValueFactory());\n        final RDFHandler rdfHandler = makeRDFHandler();\n        if (getSourceFile().isPresent()) {\n           \n           \n           \n           \n           \n           \n           \n           \n            final Optional<RDFFormat> formatByFilename = getSourceFile().map(Path::getFileName).map(Path::toString)\n                    .flatMap(Rio::getParserFormatForFileName);\n           \n           \n            final RDFFormat format = formatByMimeType.orElse(formatByFilename.orElse(null));\n            try (InputStream in = Files.newInputStream(getSourceFile().get())) {\n                loader.load(in, base, format, rdfHandler);\n            }\n        } else if (getSourceIri().isPresent()) {\n            try {\n               \n               \n                final URL url = new URL(getSourceIri().get().getIRIString());\n               \n               \n                loader.load(url, base, formatByMimeType.orElse(null), makeRDFHandler());\n            } catch (final MalformedURLException ex) {\n                throw new IOException(\"Can't handle source URL: \" + getSourceIri().get(), ex);\n            }\n        }\n       \n       \n        loader.load(getSourceInputStream().get(), base, formatByMimeType.orElse(null), rdfHandler);\n    }","cleancode":"@override protected void parsesynchronusly() throws ioexception { final optional<rdfformat> formatbymimetype = getcontenttype().flatmap(rio::getparserformatformimetype); final string base = getbase().map(iri::getiristring).orelse(null); final parserconfig parserconfig = getparserconfig(); final rdfloader loader = new rdfloader(parserconfig, rdf4jtermfactory.getvaluefactory()); final rdfhandler rdfhandler = makerdfhandler(); if (getsourcefile().ispresent()) { final optional<rdfformat> formatbyfilename = getsourcefile().map(path::getfilename).map(path::tostring) .flatmap(rio::getparserformatforfilename); final rdfformat format = formatbymimetype.orelse(formatbyfilename.orelse(null)); try (inputstream in = files.newinputstream(getsourcefile().get())) { loader.load(in, base, format, rdfhandler); } } else if (getsourceiri().ispresent()) { try { final url url = new url(getsourceiri().get().getiristring()); loader.load(url, base, formatbymimetype.orelse(null), makerdfhandler()); } catch (final malformedurlexception ex) { throw new ioexception(\"can't handle source url: \" + getsourceiri().get(), ex); } } loader.load(getsourceinputstream().get(), base, formatbymimetype.orelse(null), rdfhandler); }","comment":"\/\/ todo: should we need to set anything?\n\/\/ note: while we could have used \/\/ loader.load(sourcepath.tofile() \/\/ if the path fs provider == filesystems.getdefault(), \/\/ that rdfloader method does not use absolute path \/\/ as the base uri, so to be consistent \/\/ we'll always do it with our own input stream \/\/ \/\/ that means we may have to guess format by extensions:\n\/\/ todo: for the excited.. what about the extension after following \/\/ symlinks?\n\/\/ todo: handle international iris properly \/\/ (unicode support for for hostname, path and query)\n\/\/ todo: this probably does not support https:\/\/ -> http:\/\/ \/\/ redirections\n\/\/ must be getsourceinputstream then, this is guaranteed by \/\/ super.checksource();","repo":"nikosnikolaidis\/commons-rdf","code_context_2":"final String base = getBase().map(IRI::getIRIString).orElse(null);\nfinal ParserConfig parserConfig = getParserConfig();\n\/\/ TODO: Should we need to set anything?\nfinal RDFLoader loader = new RDFLoader(parserConfig, rdf4jTermFactory.getValueFactory());\nfinal RDFHandler rdfHandler = makeRDFHandler();\n\nfinal RDFHandler rdfHandler = makeRDFHandler();\nif (getSourceFile().isPresent()) {\n\/\/ NOTE: While we could have used\n\/\/ loader.load(sourcePath.toFile()\n\/\/ if the path fs provider == FileSystems.getDefault(),\n\/\/ that RDFLoader method does not use absolute path\n\/\/ as the base URI, so to be consistent\n\/\/ we'll always do it with our own input stream\n\/\/\n\/\/ That means we may have to guess format by extensions:\nfinal Optional<RDFFormat> formatByFilename = getSourceFile().map(Path::getFileName).map(Path::toString)\n.flatMap(Rio::getParserFormatForFileName);\n\nfinal Optional<RDFFormat> formatByFilename = getSourceFile().map(Path::getFileName).map(Path::toString)\n.flatMap(Rio::getParserFormatForFileName);\n\/\/ TODO: for the excited.. what about the extension after following\n\/\/ symlinks?\nfinal RDFFormat format = formatByMimeType.orElse(formatByFilename.orElse(null));\ntry (InputStream in = Files.newInputStream(getSourceFile().get())) {\n\n} else if (getSourceIri().isPresent()) {\ntry {\n\/\/ TODO: Handle international IRIs properly\n\/\/ (Unicode support for for hostname, path and query)\nfinal URL url = new URL(getSourceIri().get().getIRIString());\n\/\/ TODO: This probably does not support https:\/\/ -> http:\/\/\n\n\/\/ (Unicode support for for hostname, path and query)\nfinal URL url = new URL(getSourceIri().get().getIRIString());\n\/\/ TODO: This probably does not support https:\/\/ -> http:\/\/\n\/\/ redirections\nloader.load(url, base, formatByMimeType.orElse(null), makeRDFHandler());\n} catch (final MalformedURLException ex) {\n\n}\n}\n\/\/ must be getSourceInputStream then, this is guaranteed by\n\/\/ super.checkSource();\nloader.load(getSourceInputStream().get(), base, formatByMimeType.orElse(null), rdfHandler);\n}","code_context_10":"@Override\nprotected void parseSynchronusly() throws IOException {\nfinal Optional<RDFFormat> formatByMimeType = getContentType().flatMap(Rio::getParserFormatForMIMEType);\nfinal String base = getBase().map(IRI::getIRIString).orElse(null);\nfinal ParserConfig parserConfig = getParserConfig();\n\/\/ TODO: Should we need to set anything?\nfinal RDFLoader loader = new RDFLoader(parserConfig, rdf4jTermFactory.getValueFactory());\nfinal RDFHandler rdfHandler = makeRDFHandler();\nif (getSourceFile().isPresent()) {\n\/\/ NOTE: While we could have used\n\/\/ loader.load(sourcePath.toFile()\n\/\/ if the path fs provider == FileSystems.getDefault(),\n\/\/ that RDFLoader method does not use absolute path\n\/\/ as the base URI, so to be consistent\n\/\/ we'll always do it with our own input stream\n\/\/\n\n@Override\nprotected void parseSynchronusly() throws IOException {\nfinal Optional<RDFFormat> formatByMimeType = getContentType().flatMap(Rio::getParserFormatForMIMEType);\nfinal String base = getBase().map(IRI::getIRIString).orElse(null);\nfinal ParserConfig parserConfig = getParserConfig();\n\/\/ TODO: Should we need to set anything?\nfinal RDFLoader loader = new RDFLoader(parserConfig, rdf4jTermFactory.getValueFactory());\nfinal RDFHandler rdfHandler = makeRDFHandler();\nif (getSourceFile().isPresent()) {\n\/\/ NOTE: While we could have used\n\/\/ loader.load(sourcePath.toFile()\n\/\/ if the path fs provider == FileSystems.getDefault(),\n\/\/ that RDFLoader method does not use absolute path\n\/\/ as the base URI, so to be consistent\n\/\/ we'll always do it with our own input stream\n\/\/\n\/\/ That means we may have to guess format by extensions:\nfinal Optional<RDFFormat> formatByFilename = getSourceFile().map(Path::getFileName).map(Path::toString)\n.flatMap(Rio::getParserFormatForFileName);\n\/\/ TODO: for the excited.. what about the extension after following\n\/\/ symlinks?\nfinal RDFFormat format = formatByMimeType.orElse(formatByFilename.orElse(null));\ntry (InputStream in = Files.newInputStream(getSourceFile().get())) {\nloader.load(in, base, format, rdfHandler);\n}\n} else if (getSourceIri().isPresent()) {\ntry {\n\n\/\/ NOTE: While we could have used\n\/\/ loader.load(sourcePath.toFile()\n\/\/ if the path fs provider == FileSystems.getDefault(),\n\/\/ that RDFLoader method does not use absolute path\n\/\/ as the base URI, so to be consistent\n\/\/ we'll always do it with our own input stream\n\/\/\n\/\/ That means we may have to guess format by extensions:\nfinal Optional<RDFFormat> formatByFilename = getSourceFile().map(Path::getFileName).map(Path::toString)\n.flatMap(Rio::getParserFormatForFileName);\n\/\/ TODO: for the excited.. what about the extension after following\n\/\/ symlinks?\nfinal RDFFormat format = formatByMimeType.orElse(formatByFilename.orElse(null));\ntry (InputStream in = Files.newInputStream(getSourceFile().get())) {\nloader.load(in, base, format, rdfHandler);\n}\n} else if (getSourceIri().isPresent()) {\ntry {\n\/\/ TODO: Handle international IRIs properly\n\/\/ (Unicode support for for hostname, path and query)\nfinal URL url = new URL(getSourceIri().get().getIRIString());\n\/\/ TODO: This probably does not support https:\/\/ -> http:\/\/\n\nfinal Optional<RDFFormat> formatByFilename = getSourceFile().map(Path::getFileName).map(Path::toString)\n.flatMap(Rio::getParserFormatForFileName);\n\/\/ TODO: for the excited.. what about the extension after following\n\/\/ symlinks?\nfinal RDFFormat format = formatByMimeType.orElse(formatByFilename.orElse(null));\ntry (InputStream in = Files.newInputStream(getSourceFile().get())) {\nloader.load(in, base, format, rdfHandler);\n}\n} else if (getSourceIri().isPresent()) {\ntry {\n\/\/ TODO: Handle international IRIs properly\n\/\/ (Unicode support for for hostname, path and query)\nfinal URL url = new URL(getSourceIri().get().getIRIString());\n\/\/ TODO: This probably does not support https:\/\/ -> http:\/\/\n\/\/ redirections\nloader.load(url, base, formatByMimeType.orElse(null), makeRDFHandler());\n} catch (final MalformedURLException ex) {\nthrow new IOException(\"Can't handle source URL: \" + getSourceIri().get(), ex);\n}\n}\n\/\/ must be getSourceInputStream then, this is guaranteed by\n\/\/ super.checkSource();\n\n\/\/ symlinks?\nfinal RDFFormat format = formatByMimeType.orElse(formatByFilename.orElse(null));\ntry (InputStream in = Files.newInputStream(getSourceFile().get())) {\nloader.load(in, base, format, rdfHandler);\n}\n} else if (getSourceIri().isPresent()) {\ntry {\n\/\/ TODO: Handle international IRIs properly\n\/\/ (Unicode support for for hostname, path and query)\nfinal URL url = new URL(getSourceIri().get().getIRIString());\n\/\/ TODO: This probably does not support https:\/\/ -> http:\/\/\n\/\/ redirections\nloader.load(url, base, formatByMimeType.orElse(null), makeRDFHandler());\n} catch (final MalformedURLException ex) {\nthrow new IOException(\"Can't handle source URL: \" + getSourceIri().get(), ex);\n}\n}\n\/\/ must be getSourceInputStream then, this is guaranteed by\n\/\/ super.checkSource();\nloader.load(getSourceInputStream().get(), base, formatByMimeType.orElse(null), rdfHandler);\n}\n\n\/\/ TODO: Handle international IRIs properly\n\/\/ (Unicode support for for hostname, path and query)\nfinal URL url = new URL(getSourceIri().get().getIRIString());\n\/\/ TODO: This probably does not support https:\/\/ -> http:\/\/\n\/\/ redirections\nloader.load(url, base, formatByMimeType.orElse(null), makeRDFHandler());\n} catch (final MalformedURLException ex) {\nthrow new IOException(\"Can't handle source URL: \" + getSourceIri().get(), ex);\n}\n}\n\/\/ must be getSourceInputStream then, this is guaranteed by\n\/\/ super.checkSource();\nloader.load(getSourceInputStream().get(), base, formatByMimeType.orElse(null), rdfHandler);\n}","code_context_20":"@Override\nprotected void parseSynchronusly() throws IOException {\nfinal Optional<RDFFormat> formatByMimeType = getContentType().flatMap(Rio::getParserFormatForMIMEType);\nfinal String base = getBase().map(IRI::getIRIString).orElse(null);\nfinal ParserConfig parserConfig = getParserConfig();\n\/\/ TODO: Should we need to set anything?\nfinal RDFLoader loader = new RDFLoader(parserConfig, rdf4jTermFactory.getValueFactory());\nfinal RDFHandler rdfHandler = makeRDFHandler();\nif (getSourceFile().isPresent()) {\n\/\/ NOTE: While we could have used\n\/\/ loader.load(sourcePath.toFile()\n\/\/ if the path fs provider == FileSystems.getDefault(),\n\/\/ that RDFLoader method does not use absolute path\n\/\/ as the base URI, so to be consistent\n\/\/ we'll always do it with our own input stream\n\/\/\n\/\/ That means we may have to guess format by extensions:\nfinal Optional<RDFFormat> formatByFilename = getSourceFile().map(Path::getFileName).map(Path::toString)\n.flatMap(Rio::getParserFormatForFileName);\n\/\/ TODO: for the excited.. what about the extension after following\n\/\/ symlinks?\nfinal RDFFormat format = formatByMimeType.orElse(formatByFilename.orElse(null));\ntry (InputStream in = Files.newInputStream(getSourceFile().get())) {\nloader.load(in, base, format, rdfHandler);\n}\n} else if (getSourceIri().isPresent()) {\n\n@Override\nprotected void parseSynchronusly() throws IOException {\nfinal Optional<RDFFormat> formatByMimeType = getContentType().flatMap(Rio::getParserFormatForMIMEType);\nfinal String base = getBase().map(IRI::getIRIString).orElse(null);\nfinal ParserConfig parserConfig = getParserConfig();\n\/\/ TODO: Should we need to set anything?\nfinal RDFLoader loader = new RDFLoader(parserConfig, rdf4jTermFactory.getValueFactory());\nfinal RDFHandler rdfHandler = makeRDFHandler();\nif (getSourceFile().isPresent()) {\n\/\/ NOTE: While we could have used\n\/\/ loader.load(sourcePath.toFile()\n\/\/ if the path fs provider == FileSystems.getDefault(),\n\/\/ that RDFLoader method does not use absolute path\n\/\/ as the base URI, so to be consistent\n\/\/ we'll always do it with our own input stream\n\/\/\n\/\/ That means we may have to guess format by extensions:\nfinal Optional<RDFFormat> formatByFilename = getSourceFile().map(Path::getFileName).map(Path::toString)\n.flatMap(Rio::getParserFormatForFileName);\n\/\/ TODO: for the excited.. what about the extension after following\n\/\/ symlinks?\nfinal RDFFormat format = formatByMimeType.orElse(formatByFilename.orElse(null));\ntry (InputStream in = Files.newInputStream(getSourceFile().get())) {\nloader.load(in, base, format, rdfHandler);\n}\n} else if (getSourceIri().isPresent()) {\ntry {\n\/\/ TODO: Handle international IRIs properly\n\/\/ (Unicode support for for hostname, path and query)\nfinal URL url = new URL(getSourceIri().get().getIRIString());\n\/\/ TODO: This probably does not support https:\/\/ -> http:\/\/\n\/\/ redirections\nloader.load(url, base, formatByMimeType.orElse(null), makeRDFHandler());\n} catch (final MalformedURLException ex) {\nthrow new IOException(\"Can't handle source URL: \" + getSourceIri().get(), ex);\n}\n}\n\n@Override\nprotected void parseSynchronusly() throws IOException {\nfinal Optional<RDFFormat> formatByMimeType = getContentType().flatMap(Rio::getParserFormatForMIMEType);\nfinal String base = getBase().map(IRI::getIRIString).orElse(null);\nfinal ParserConfig parserConfig = getParserConfig();\n\/\/ TODO: Should we need to set anything?\nfinal RDFLoader loader = new RDFLoader(parserConfig, rdf4jTermFactory.getValueFactory());\nfinal RDFHandler rdfHandler = makeRDFHandler();\nif (getSourceFile().isPresent()) {\n\/\/ NOTE: While we could have used\n\/\/ loader.load(sourcePath.toFile()\n\/\/ if the path fs provider == FileSystems.getDefault(),\n\/\/ that RDFLoader method does not use absolute path\n\/\/ as the base URI, so to be consistent\n\/\/ we'll always do it with our own input stream\n\/\/\n\/\/ That means we may have to guess format by extensions:\nfinal Optional<RDFFormat> formatByFilename = getSourceFile().map(Path::getFileName).map(Path::toString)\n.flatMap(Rio::getParserFormatForFileName);\n\/\/ TODO: for the excited.. what about the extension after following\n\/\/ symlinks?\nfinal RDFFormat format = formatByMimeType.orElse(formatByFilename.orElse(null));\ntry (InputStream in = Files.newInputStream(getSourceFile().get())) {\nloader.load(in, base, format, rdfHandler);\n}\n} else if (getSourceIri().isPresent()) {\ntry {\n\/\/ TODO: Handle international IRIs properly\n\/\/ (Unicode support for for hostname, path and query)\nfinal URL url = new URL(getSourceIri().get().getIRIString());\n\/\/ TODO: This probably does not support https:\/\/ -> http:\/\/\n\/\/ redirections\nloader.load(url, base, formatByMimeType.orElse(null), makeRDFHandler());\n} catch (final MalformedURLException ex) {\nthrow new IOException(\"Can't handle source URL: \" + getSourceIri().get(), ex);\n}\n}\n\/\/ must be getSourceInputStream then, this is guaranteed by\n\/\/ super.checkSource();\nloader.load(getSourceInputStream().get(), base, formatByMimeType.orElse(null), rdfHandler);\n}\n\nfinal RDFHandler rdfHandler = makeRDFHandler();\nif (getSourceFile().isPresent()) {\n\/\/ NOTE: While we could have used\n\/\/ loader.load(sourcePath.toFile()\n\/\/ if the path fs provider == FileSystems.getDefault(),\n\/\/ that RDFLoader method does not use absolute path\n\/\/ as the base URI, so to be consistent\n\/\/ we'll always do it with our own input stream\n\/\/\n\/\/ That means we may have to guess format by extensions:\nfinal Optional<RDFFormat> formatByFilename = getSourceFile().map(Path::getFileName).map(Path::toString)\n.flatMap(Rio::getParserFormatForFileName);\n\/\/ TODO: for the excited.. what about the extension after following\n\/\/ symlinks?\nfinal RDFFormat format = formatByMimeType.orElse(formatByFilename.orElse(null));\ntry (InputStream in = Files.newInputStream(getSourceFile().get())) {\nloader.load(in, base, format, rdfHandler);\n}\n} else if (getSourceIri().isPresent()) {\ntry {\n\/\/ TODO: Handle international IRIs properly\n\/\/ (Unicode support for for hostname, path and query)\nfinal URL url = new URL(getSourceIri().get().getIRIString());\n\/\/ TODO: This probably does not support https:\/\/ -> http:\/\/\n\/\/ redirections\nloader.load(url, base, formatByMimeType.orElse(null), makeRDFHandler());\n} catch (final MalformedURLException ex) {\nthrow new IOException(\"Can't handle source URL: \" + getSourceIri().get(), ex);\n}\n}\n\/\/ must be getSourceInputStream then, this is guaranteed by\n\/\/ super.checkSource();\nloader.load(getSourceInputStream().get(), base, formatByMimeType.orElse(null), rdfHandler);\n}\n\n\/\/ loader.load(sourcePath.toFile()\n\/\/ if the path fs provider == FileSystems.getDefault(),\n\/\/ that RDFLoader method does not use absolute path\n\/\/ as the base URI, so to be consistent\n\/\/ we'll always do it with our own input stream\n\/\/\n\/\/ That means we may have to guess format by extensions:\nfinal Optional<RDFFormat> formatByFilename = getSourceFile().map(Path::getFileName).map(Path::toString)\n.flatMap(Rio::getParserFormatForFileName);\n\/\/ TODO: for the excited.. what about the extension after following\n\/\/ symlinks?\nfinal RDFFormat format = formatByMimeType.orElse(formatByFilename.orElse(null));\ntry (InputStream in = Files.newInputStream(getSourceFile().get())) {\nloader.load(in, base, format, rdfHandler);\n}\n} else if (getSourceIri().isPresent()) {\ntry {\n\/\/ TODO: Handle international IRIs properly\n\/\/ (Unicode support for for hostname, path and query)\nfinal URL url = new URL(getSourceIri().get().getIRIString());\n\/\/ TODO: This probably does not support https:\/\/ -> http:\/\/\n\/\/ redirections\nloader.load(url, base, formatByMimeType.orElse(null), makeRDFHandler());\n} catch (final MalformedURLException ex) {\nthrow new IOException(\"Can't handle source URL: \" + getSourceIri().get(), ex);\n}\n}\n\/\/ must be getSourceInputStream then, this is guaranteed by\n\/\/ super.checkSource();\nloader.load(getSourceInputStream().get(), base, formatByMimeType.orElse(null), rdfHandler);\n}\n\nfinal Optional<RDFFormat> formatByFilename = getSourceFile().map(Path::getFileName).map(Path::toString)\n.flatMap(Rio::getParserFormatForFileName);\n\/\/ TODO: for the excited.. what about the extension after following\n\/\/ symlinks?\nfinal RDFFormat format = formatByMimeType.orElse(formatByFilename.orElse(null));\ntry (InputStream in = Files.newInputStream(getSourceFile().get())) {\nloader.load(in, base, format, rdfHandler);\n}\n} else if (getSourceIri().isPresent()) {\ntry {\n\/\/ TODO: Handle international IRIs properly\n\/\/ (Unicode support for for hostname, path and query)\nfinal URL url = new URL(getSourceIri().get().getIRIString());\n\/\/ TODO: This probably does not support https:\/\/ -> http:\/\/\n\/\/ redirections\nloader.load(url, base, formatByMimeType.orElse(null), makeRDFHandler());\n} catch (final MalformedURLException ex) {\nthrow new IOException(\"Can't handle source URL: \" + getSourceIri().get(), ex);\n}\n}\n\/\/ must be getSourceInputStream then, this is guaranteed by\n\/\/ super.checkSource();\nloader.load(getSourceInputStream().get(), base, formatByMimeType.orElse(null), rdfHandler);\n}","label":[1,1,0,0]}
{"id":20076,"original_code":"int denybble(byte[] data, int pos)\n        {\n        \/\/ The spec is wrong: it's LSB, then MSB\n        \/\/ int v = (data[pos] << 4) | data[pos+1];\n        int v = (data[pos + 1] << 4) | data[pos];\n        \/\/ Some of the dark star stuff is 8-bit, so we have to make sure we're positive\n        if (v < 0) v += 256;\n        return v;\n        }","code":"int denybble(byte[] data, int pos)\n        {\n       \n       \n        int v = (data[pos + 1] << 4) | data[pos];\n       \n        if (v < 0) v += 256;\n        return v;\n        }","cleancode":"int denybble(byte[] data, int pos) { int v = (data[pos + 1] << 4) | data[pos]; if (v < 0) v += 256; return v; }","comment":"\/\/ the spec is wrong: it's lsb, then msb \/\/ int v = (data[pos] << 4) | data[pos+1];\n\/\/ some of the dark star stuff is 8-bit, so we have to make sure we're positive","repo":"oco27\/edisyn","code_context_2":"int denybble(byte[] data, int pos)\n{\n\/\/ The spec is wrong: it's LSB, then MSB\n\/\/ int v = (data[pos] << 4) | data[pos+1];\nint v = (data[pos + 1] << 4) | data[pos];\n\/\/ Some of the dark star stuff is 8-bit, so we have to make sure we're positive\n\n\/\/ int v = (data[pos] << 4) | data[pos+1];\nint v = (data[pos + 1] << 4) | data[pos];\n\/\/ Some of the dark star stuff is 8-bit, so we have to make sure we're positive\nif (v < 0) v += 256;\nreturn v;","code_context_10":"int denybble(byte[] data, int pos)\n{\n\/\/ The spec is wrong: it's LSB, then MSB\n\/\/ int v = (data[pos] << 4) | data[pos+1];\nint v = (data[pos + 1] << 4) | data[pos];\n\/\/ Some of the dark star stuff is 8-bit, so we have to make sure we're positive\nif (v < 0) v += 256;\nreturn v;\n}\n\nint denybble(byte[] data, int pos)\n{\n\/\/ The spec is wrong: it's LSB, then MSB\n\/\/ int v = (data[pos] << 4) | data[pos+1];\nint v = (data[pos + 1] << 4) | data[pos];\n\/\/ Some of the dark star stuff is 8-bit, so we have to make sure we're positive\nif (v < 0) v += 256;\nreturn v;\n}","code_context_20":"int denybble(byte[] data, int pos)\n{\n\/\/ The spec is wrong: it's LSB, then MSB\n\/\/ int v = (data[pos] << 4) | data[pos+1];\nint v = (data[pos + 1] << 4) | data[pos];\n\/\/ Some of the dark star stuff is 8-bit, so we have to make sure we're positive\nif (v < 0) v += 256;\nreturn v;\n}\n\nint denybble(byte[] data, int pos)\n{\n\/\/ The spec is wrong: it's LSB, then MSB\n\/\/ int v = (data[pos] << 4) | data[pos+1];\nint v = (data[pos + 1] << 4) | data[pos];\n\/\/ Some of the dark star stuff is 8-bit, so we have to make sure we're positive\nif (v < 0) v += 256;\nreturn v;\n}","label":[0,0,1,0]}
{"id":20077,"original_code":"void addData(byte[] data, int pos, int val)\n        {\n        \/\/ The spec is wrong: it's LSB, then MSB\n        data[pos] = (byte)((val >> 0) & 0x0F);\n        data[pos + 1] = (byte)((val >> 4) & 0x0F);\n        \/\/data[pos + 1] = (byte)((val >> 0) & 0x0F);\n        \/\/data[pos] = (byte)((val >> 4) & 0x0F);\n        }","code":"void addData(byte[] data, int pos, int val)\n        {\n       \n        data[pos] = (byte)((val >> 0) & 0x0F);\n        data[pos + 1] = (byte)((val >> 4) & 0x0F);\n       \n       \n        }","cleancode":"void adddata(byte[] data, int pos, int val) { data[pos] = (byte)((val >> 0) & 0x0f); data[pos + 1] = (byte)((val >> 4) & 0x0f); }","comment":"\/\/ the spec is wrong: it's lsb, then msb\n\/\/data[pos + 1] = (byte)((val >> 0) & 0x0f); \/\/data[pos] = (byte)((val >> 4) & 0x0f);","repo":"oco27\/edisyn","code_context_2":"void addData(byte[] data, int pos, int val)\n{\n\/\/ The spec is wrong: it's LSB, then MSB\ndata[pos] = (byte)((val >> 0) & 0x0F);\ndata[pos + 1] = (byte)((val >> 4) & 0x0F);\n\ndata[pos] = (byte)((val >> 0) & 0x0F);\ndata[pos + 1] = (byte)((val >> 4) & 0x0F);\n\/\/data[pos + 1] = (byte)((val >> 0) & 0x0F);\n\/\/data[pos] = (byte)((val >> 4) & 0x0F);\n}","code_context_10":"void addData(byte[] data, int pos, int val)\n{\n\/\/ The spec is wrong: it's LSB, then MSB\ndata[pos] = (byte)((val >> 0) & 0x0F);\ndata[pos + 1] = (byte)((val >> 4) & 0x0F);\n\/\/data[pos + 1] = (byte)((val >> 0) & 0x0F);\n\/\/data[pos] = (byte)((val >> 4) & 0x0F);\n}\n\nvoid addData(byte[] data, int pos, int val)\n{\n\/\/ The spec is wrong: it's LSB, then MSB\ndata[pos] = (byte)((val >> 0) & 0x0F);\ndata[pos + 1] = (byte)((val >> 4) & 0x0F);\n\/\/data[pos + 1] = (byte)((val >> 0) & 0x0F);\n\/\/data[pos] = (byte)((val >> 4) & 0x0F);\n}","code_context_20":"void addData(byte[] data, int pos, int val)\n{\n\/\/ The spec is wrong: it's LSB, then MSB\ndata[pos] = (byte)((val >> 0) & 0x0F);\ndata[pos + 1] = (byte)((val >> 4) & 0x0F);\n\/\/data[pos + 1] = (byte)((val >> 0) & 0x0F);\n\/\/data[pos] = (byte)((val >> 4) & 0x0F);\n}\n\nvoid addData(byte[] data, int pos, int val)\n{\n\/\/ The spec is wrong: it's LSB, then MSB\ndata[pos] = (byte)((val >> 0) & 0x0F);\ndata[pos + 1] = (byte)((val >> 4) & 0x0F);\n\/\/data[pos + 1] = (byte)((val >> 0) & 0x0F);\n\/\/data[pos] = (byte)((val >> 4) & 0x0F);\n}","label":[0,0,1,0]}
{"id":11963,"original_code":"protected void paint(GraphicsContext gc) {\n        \/\/ Get a sorted copy of the series data.  Once we have this we can release locks.\n        Rectangle2D rectViewport = viewport;\n        HashMap<Series, LinkedList<T>> data = new HashMap<>();\n        for(Series<T> series : this.series) {\n            LinkedList<T> seriesData = new LinkedList<>(series.getData());\n            seriesData.sort((o1, o2) -> fnXValue.apply(o1).compareTo(fnXValue.apply(o2)));\n            data.put(series, seriesData);\n        }\n        \/\/Make sure we have data before continuing.\n        if(data.size() == 0) {\n            return;\n        }\n        if(data.values().stream().flatMap(LinkedList::stream).count() == 0) {\n            return;\n        }\n        \/\/ Calculate the range on each axis.\n        Range<TX> axisX;\n        Range<TY> axisY;\n        \/\/TODO: Since we just sorted by X, we can optimize this a bit.\n        if(rangeX != null) {\n            axisX = new Range<>(\n                    rangeX.min == null ? data.values().stream().flatMap(LinkedList::stream).map(fnXValue).min(TX::compareTo).get() : rangeX.min,\n                    rangeX.max == null ? data.values().stream().flatMap(LinkedList::stream).map(fnXValue).max(TX::compareTo).get() : rangeX.max\n            );\n        } else {\n            axisX = new Range<>(\n                    data.values().stream().flatMap(LinkedList::stream).map(fnXValue).min(TX::compareTo).get(),\n                    data.values().stream().flatMap(LinkedList::stream).map(fnXValue).max(TX::compareTo).get()\n            );\n        }\n        if(rangeY != null) {\n            axisY = new Range<>(\n                    rangeY.min == null ? data.values().stream().flatMap(LinkedList::stream).map(fnYValue).min(TY::compareTo).get() : rangeY.min,\n                    rangeY.max == null ? data.values().stream().flatMap(LinkedList::stream).map(fnYValue).max(TY::compareTo).get() : rangeY.max\n            );\n        } else {\n            axisY = new Range<>(\n                    data.values().stream().flatMap(LinkedList::stream).map(fnYValue).min(TY::compareTo).get(),\n                    data.values().stream().flatMap(LinkedList::stream).map(fnYValue).max(TY::compareTo).get()\n            );\n        }\n        final List<TX> ticksX = fnTicksX.generateTicks(axisX, viewport.getMinX(), viewport.getMaxX());\n        \/\/axisX = new Range<>(ticksX.get(0), ticksX.get(ticksX.size() - 1));\n        \/\/rangeXRendered = axisX;\n        final List<TY> ticksY = fnTicksY.generateTicks(axisY, viewport.getMinY(), viewport.getMaxY());\n        \/\/axisY = new Range<>(ticksY.get(0), ticksY.get(ticksY.size() - 1));\n        \/\/ Calculate the width of the widest Y-axis label and the height of the tallest X-axis label.\n        double maxWidth = 0.0;\n        double pxMinSpacingBetweenTicks = 0.0;\n        for(TY tickY : ticksY) {\n            textForMeasuring.setText(fnFormatY.apply(tickY));\n            maxWidth = Math.max(maxWidth, textForMeasuring.getLayoutBounds().getWidth());\n            pxMinSpacingBetweenTicks = Math.max(pxMinSpacingBetweenTicks, 2.0 * textForMeasuring.getLayoutBounds().getHeight());\n        }\n        double maxHeight = 0.0;\n        for(TX tickX : ticksX) {\n            \/\/X-labels are displayed at a 30-degree incline.\n            \/\/The approximate width of the rotated text is 0.87*{width}\n            \/\/The distance from the top of the bounding to the origin from which text should be drawn is 0.5*{length} + 0.87*{height}\n            textForMeasuring.setText(fnFormatX.apply(tickX));\n            final Bounds boundsText = textForMeasuring.getLayoutBounds();\n            maxHeight = Math.max(maxHeight, 0.5 * boundsText.getWidth() + 0.87 * boundsText.getHeight());\n            \/\/TODO: Also check maxWidth against the amount by which this would underflow the X=0 line\n        }\n        final Rectangle2D sizeAxisLabel = new Rectangle2D(0.0, 0.0, maxWidth, maxHeight);\n        if(getWidth() <= sizeAxisLabel.getWidth() || getHeight() <= sizeAxisLabel.getHeight()) {\n            return;\n        }\n        rectChart = new Rectangle2D(sizeAxisLabel.getWidth() + pxTickLength, 0.0, getWidth() - sizeAxisLabel.getWidth() - pxTickLength, getHeight() - sizeAxisLabel.getHeight() - pxTickLength);\n        \/\/ Render series data, build tooltip cache\n        renderedPoints.clear();\n        for(Map.Entry<Series, LinkedList<T>> entry : data.entrySet()) {\n            Point2D ptPrev = null;\n            gc.setStroke(entry.getKey().getColor());\n            \/\/TODO: Make this customizable\n            gc.setLineWidth(2.0);\n            for(T value : entry.getValue()) {\n                TX x = fnXValue.apply(value);\n                TY y = fnYValue.apply(value);\n                \/\/ Add rectViewport.getMinY() instead of subtracting because we're mirroring the Y coordinate around the X-axis.\n                Point2D ptNew = new Point2D(\n                        chartXFromDataX(axisX, x),\n                        chartYFromDataY(axisY, y));\n                Point<T, TX, TY> pt = new Point<>(\n                        value,\n                        x,\n                        y,\n                        ptNew,\n                        entry.getKey().getColor()\n                );\n                renderedPoints.add(pt);\n                if(ptPrev != null) {\n                    gc.strokeLine(ptPrev.getX(), ptPrev.getY(), ptNew.getX(), ptNew.getY());\n                }\n                gc.strokeOval(ptNew.getX() - pointRadius, ptNew.getY() - pointRadius, pointRadius * 2, pointRadius * 2);\n                ptPrev = ptNew;\n            }\n        }\n        \/\/ Render axes (last so it overwrites any values near an axis)\n        \/\/Clear the axis area\n        gc.clearRect(0.0, 0.0, sizeAxisLabel.getWidth() + pxTickLength, getHeight());\n        gc.clearRect(0.0, getHeight() - sizeAxisLabel.getHeight() - pxTickLength, getWidth(), sizeAxisLabel.getHeight());\n        \/\/Draw the axes\n        gc.setStroke(Color.BLACK);\n        gc.setLineWidth(0.5);\n        gc.strokeLine(rectChart.getMinX(), 0.0, rectChart.getMinX(), rectChart.getMaxY());\n        gc.strokeLine(rectChart.getMinX(), rectChart.getMaxY(), rectChart.getMaxX(), rectChart.getMaxY());\n        Font font = Font.font(\"MONOSPACE\", 12.0);\n        gc.setFont(font);\n        \/\/ticksX and ticksY are lists of the corresponding values; they need to be handed of to the corresponding fnNormalize and then scaled for display.\n        double pxLast = -pxMinSpacingBetweenTicks;\n        for(TX tickX : ticksX) {\n            final double pxX = chartXFromDataX(axisX, tickX);\n            if(pxLast + pxMinSpacingBetweenTicks > pxX) {\n                continue;\n            }\n            pxLast = pxX;\n            gc.strokeLine(pxX, rectChart.getMaxY(), pxX, rectChart.getMaxY() + pxTickLength);\n            final String textLabel = fnFormatX.apply(tickX);\n            textForMeasuring.setText(textLabel);\n            final Bounds boundsText = textForMeasuring.getLayoutBounds();\n            double offsetY = 0.5 * boundsText.getWidth() + 0.87 * boundsText.getHeight();\n            double offsetX = -0.87 * boundsText.getWidth();\n            gc.save();\n            \/\/ Translate then rotate to rotate text around local origin rather than rotating around the canvas origin.\n            \/\/ Rotating and drawing at an offset results in a rotation around the origin.\n            gc.translate(pxX + offsetX, rectChart.getMaxY() + offsetY);\n            gc.rotate(-30.0);\n            gc.strokeText(textLabel, 0.0, 0.0);\n            gc.restore();\n        }\n        for(TY tickY : ticksY) {\n            final double pxY = chartYFromDataY(axisY, tickY);\n            gc.strokeLine(rectChart.getMinX() - pxTickLength, pxY, rectChart.getMinX(), pxY);\n            final String textLabel = fnFormatY.apply(tickY);\n            textForMeasuring.setText(textLabel);\n            gc.strokeText(fnFormatY.apply(tickY), 0.0, pxY + textForMeasuring.getLayoutBounds().getHeight());\n        }\n    }","code":"protected void paint(GraphicsContext gc) {\n       \n        Rectangle2D rectViewport = viewport;\n        HashMap<Series, LinkedList<T>> data = new HashMap<>();\n        for(Series<T> series : this.series) {\n            LinkedList<T> seriesData = new LinkedList<>(series.getData());\n            seriesData.sort((o1, o2) -> fnXValue.apply(o1).compareTo(fnXValue.apply(o2)));\n            data.put(series, seriesData);\n        }\n       \n        if(data.size() == 0) {\n            return;\n        }\n        if(data.values().stream().flatMap(LinkedList::stream).count() == 0) {\n            return;\n        }\n       \n        Range<TX> axisX;\n        Range<TY> axisY;\n       \n        if(rangeX != null) {\n            axisX = new Range<>(\n                    rangeX.min == null ? data.values().stream().flatMap(LinkedList::stream).map(fnXValue).min(TX::compareTo).get() : rangeX.min,\n                    rangeX.max == null ? data.values().stream().flatMap(LinkedList::stream).map(fnXValue).max(TX::compareTo).get() : rangeX.max\n            );\n        } else {\n            axisX = new Range<>(\n                    data.values().stream().flatMap(LinkedList::stream).map(fnXValue).min(TX::compareTo).get(),\n                    data.values().stream().flatMap(LinkedList::stream).map(fnXValue).max(TX::compareTo).get()\n            );\n        }\n        if(rangeY != null) {\n            axisY = new Range<>(\n                    rangeY.min == null ? data.values().stream().flatMap(LinkedList::stream).map(fnYValue).min(TY::compareTo).get() : rangeY.min,\n                    rangeY.max == null ? data.values().stream().flatMap(LinkedList::stream).map(fnYValue).max(TY::compareTo).get() : rangeY.max\n            );\n        } else {\n            axisY = new Range<>(\n                    data.values().stream().flatMap(LinkedList::stream).map(fnYValue).min(TY::compareTo).get(),\n                    data.values().stream().flatMap(LinkedList::stream).map(fnYValue).max(TY::compareTo).get()\n            );\n        }\n        final List<TX> ticksX = fnTicksX.generateTicks(axisX, viewport.getMinX(), viewport.getMaxX());\n       \n       \n        final List<TY> ticksY = fnTicksY.generateTicks(axisY, viewport.getMinY(), viewport.getMaxY());\n       \n       \n        double maxWidth = 0.0;\n        double pxMinSpacingBetweenTicks = 0.0;\n        for(TY tickY : ticksY) {\n            textForMeasuring.setText(fnFormatY.apply(tickY));\n            maxWidth = Math.max(maxWidth, textForMeasuring.getLayoutBounds().getWidth());\n            pxMinSpacingBetweenTicks = Math.max(pxMinSpacingBetweenTicks, 2.0 * textForMeasuring.getLayoutBounds().getHeight());\n        }\n        double maxHeight = 0.0;\n        for(TX tickX : ticksX) {\n           \n           \n           \n            textForMeasuring.setText(fnFormatX.apply(tickX));\n            final Bounds boundsText = textForMeasuring.getLayoutBounds();\n            maxHeight = Math.max(maxHeight, 0.5 * boundsText.getWidth() + 0.87 * boundsText.getHeight());\n           \n        }\n        final Rectangle2D sizeAxisLabel = new Rectangle2D(0.0, 0.0, maxWidth, maxHeight);\n        if(getWidth() <= sizeAxisLabel.getWidth() || getHeight() <= sizeAxisLabel.getHeight()) {\n            return;\n        }\n        rectChart = new Rectangle2D(sizeAxisLabel.getWidth() + pxTickLength, 0.0, getWidth() - sizeAxisLabel.getWidth() - pxTickLength, getHeight() - sizeAxisLabel.getHeight() - pxTickLength);\n       \n        renderedPoints.clear();\n        for(Map.Entry<Series, LinkedList<T>> entry : data.entrySet()) {\n            Point2D ptPrev = null;\n            gc.setStroke(entry.getKey().getColor());\n           \n            gc.setLineWidth(2.0);\n            for(T value : entry.getValue()) {\n                TX x = fnXValue.apply(value);\n                TY y = fnYValue.apply(value);\n               \n                Point2D ptNew = new Point2D(\n                        chartXFromDataX(axisX, x),\n                        chartYFromDataY(axisY, y));\n                Point<T, TX, TY> pt = new Point<>(\n                        value,\n                        x,\n                        y,\n                        ptNew,\n                        entry.getKey().getColor()\n                );\n                renderedPoints.add(pt);\n                if(ptPrev != null) {\n                    gc.strokeLine(ptPrev.getX(), ptPrev.getY(), ptNew.getX(), ptNew.getY());\n                }\n                gc.strokeOval(ptNew.getX() - pointRadius, ptNew.getY() - pointRadius, pointRadius * 2, pointRadius * 2);\n                ptPrev = ptNew;\n            }\n        }\n       \n       \n        gc.clearRect(0.0, 0.0, sizeAxisLabel.getWidth() + pxTickLength, getHeight());\n        gc.clearRect(0.0, getHeight() - sizeAxisLabel.getHeight() - pxTickLength, getWidth(), sizeAxisLabel.getHeight());\n       \n        gc.setStroke(Color.BLACK);\n        gc.setLineWidth(0.5);\n        gc.strokeLine(rectChart.getMinX(), 0.0, rectChart.getMinX(), rectChart.getMaxY());\n        gc.strokeLine(rectChart.getMinX(), rectChart.getMaxY(), rectChart.getMaxX(), rectChart.getMaxY());\n        Font font = Font.font(\"MONOSPACE\", 12.0);\n        gc.setFont(font);\n       \n        double pxLast = -pxMinSpacingBetweenTicks;\n        for(TX tickX : ticksX) {\n            final double pxX = chartXFromDataX(axisX, tickX);\n            if(pxLast + pxMinSpacingBetweenTicks > pxX) {\n                continue;\n            }\n            pxLast = pxX;\n            gc.strokeLine(pxX, rectChart.getMaxY(), pxX, rectChart.getMaxY() + pxTickLength);\n            final String textLabel = fnFormatX.apply(tickX);\n            textForMeasuring.setText(textLabel);\n            final Bounds boundsText = textForMeasuring.getLayoutBounds();\n            double offsetY = 0.5 * boundsText.getWidth() + 0.87 * boundsText.getHeight();\n            double offsetX = -0.87 * boundsText.getWidth();\n            gc.save();\n           \n           \n            gc.translate(pxX + offsetX, rectChart.getMaxY() + offsetY);\n            gc.rotate(-30.0);\n            gc.strokeText(textLabel, 0.0, 0.0);\n            gc.restore();\n        }\n        for(TY tickY : ticksY) {\n            final double pxY = chartYFromDataY(axisY, tickY);\n            gc.strokeLine(rectChart.getMinX() - pxTickLength, pxY, rectChart.getMinX(), pxY);\n            final String textLabel = fnFormatY.apply(tickY);\n            textForMeasuring.setText(textLabel);\n            gc.strokeText(fnFormatY.apply(tickY), 0.0, pxY + textForMeasuring.getLayoutBounds().getHeight());\n        }\n    }","cleancode":"protected void paint(graphicscontext gc) { rectangle2d rectviewport = viewport; hashmap<series, linkedlist<t>> data = new hashmap<>(); for(series<t> series : this.series) { linkedlist<t> seriesdata = new linkedlist<>(series.getdata()); seriesdata.sort((o1, o2) -> fnxvalue.apply(o1).compareto(fnxvalue.apply(o2))); data.put(series, seriesdata); } if(data.size() == 0) { return; } if(data.values().stream().flatmap(linkedlist::stream).count() == 0) { return; } range<tx> axisx; range<ty> axisy; if(rangex != null) { axisx = new range<>( rangex.min == null ? data.values().stream().flatmap(linkedlist::stream).map(fnxvalue).min(tx::compareto).get() : rangex.min, rangex.max == null ? data.values().stream().flatmap(linkedlist::stream).map(fnxvalue).max(tx::compareto).get() : rangex.max ); } else { axisx = new range<>( data.values().stream().flatmap(linkedlist::stream).map(fnxvalue).min(tx::compareto).get(), data.values().stream().flatmap(linkedlist::stream).map(fnxvalue).max(tx::compareto).get() ); } if(rangey != null) { axisy = new range<>( rangey.min == null ? data.values().stream().flatmap(linkedlist::stream).map(fnyvalue).min(ty::compareto).get() : rangey.min, rangey.max == null ? data.values().stream().flatmap(linkedlist::stream).map(fnyvalue).max(ty::compareto).get() : rangey.max ); } else { axisy = new range<>( data.values().stream().flatmap(linkedlist::stream).map(fnyvalue).min(ty::compareto).get(), data.values().stream().flatmap(linkedlist::stream).map(fnyvalue).max(ty::compareto).get() ); } final list<tx> ticksx = fnticksx.generateticks(axisx, viewport.getminx(), viewport.getmaxx()); final list<ty> ticksy = fnticksy.generateticks(axisy, viewport.getminy(), viewport.getmaxy()); double maxwidth = 0.0; double pxminspacingbetweenticks = 0.0; for(ty ticky : ticksy) { textformeasuring.settext(fnformaty.apply(ticky)); maxwidth = math.max(maxwidth, textformeasuring.getlayoutbounds().getwidth()); pxminspacingbetweenticks = math.max(pxminspacingbetweenticks, 2.0 * textformeasuring.getlayoutbounds().getheight()); } double maxheight = 0.0; for(tx tickx : ticksx) { textformeasuring.settext(fnformatx.apply(tickx)); final bounds boundstext = textformeasuring.getlayoutbounds(); maxheight = math.max(maxheight, 0.5 * boundstext.getwidth() + 0.87 * boundstext.getheight()); } final rectangle2d sizeaxislabel = new rectangle2d(0.0, 0.0, maxwidth, maxheight); if(getwidth() <= sizeaxislabel.getwidth() || getheight() <= sizeaxislabel.getheight()) { return; } rectchart = new rectangle2d(sizeaxislabel.getwidth() + pxticklength, 0.0, getwidth() - sizeaxislabel.getwidth() - pxticklength, getheight() - sizeaxislabel.getheight() - pxticklength); renderedpoints.clear(); for(map.entry<series, linkedlist<t>> entry : data.entryset()) { point2d ptprev = null; gc.setstroke(entry.getkey().getcolor()); gc.setlinewidth(2.0); for(t value : entry.getvalue()) { tx x = fnxvalue.apply(value); ty y = fnyvalue.apply(value); point2d ptnew = new point2d( chartxfromdatax(axisx, x), chartyfromdatay(axisy, y)); point<t, tx, ty> pt = new point<>( value, x, y, ptnew, entry.getkey().getcolor() ); renderedpoints.add(pt); if(ptprev != null) { gc.strokeline(ptprev.getx(), ptprev.gety(), ptnew.getx(), ptnew.gety()); } gc.strokeoval(ptnew.getx() - pointradius, ptnew.gety() - pointradius, pointradius * 2, pointradius * 2); ptprev = ptnew; } } gc.clearrect(0.0, 0.0, sizeaxislabel.getwidth() + pxticklength, getheight()); gc.clearrect(0.0, getheight() - sizeaxislabel.getheight() - pxticklength, getwidth(), sizeaxislabel.getheight()); gc.setstroke(color.black); gc.setlinewidth(0.5); gc.strokeline(rectchart.getminx(), 0.0, rectchart.getminx(), rectchart.getmaxy()); gc.strokeline(rectchart.getminx(), rectchart.getmaxy(), rectchart.getmaxx(), rectchart.getmaxy()); font font = font.font(\"monospace\", 12.0); gc.setfont(font); double pxlast = -pxminspacingbetweenticks; for(tx tickx : ticksx) { final double pxx = chartxfromdatax(axisx, tickx); if(pxlast + pxminspacingbetweenticks > pxx) { continue; } pxlast = pxx; gc.strokeline(pxx, rectchart.getmaxy(), pxx, rectchart.getmaxy() + pxticklength); final string textlabel = fnformatx.apply(tickx); textformeasuring.settext(textlabel); final bounds boundstext = textformeasuring.getlayoutbounds(); double offsety = 0.5 * boundstext.getwidth() + 0.87 * boundstext.getheight(); double offsetx = -0.87 * boundstext.getwidth(); gc.save(); gc.translate(pxx + offsetx, rectchart.getmaxy() + offsety); gc.rotate(-30.0); gc.stroketext(textlabel, 0.0, 0.0); gc.restore(); } for(ty ticky : ticksy) { final double pxy = chartyfromdatay(axisy, ticky); gc.strokeline(rectchart.getminx() - pxticklength, pxy, rectchart.getminx(), pxy); final string textlabel = fnformaty.apply(ticky); textformeasuring.settext(textlabel); gc.stroketext(fnformaty.apply(ticky), 0.0, pxy + textformeasuring.getlayoutbounds().getheight()); } }","comment":"\/\/ get a sorted copy of the series data. once we have this we can release locks.\n\/\/make sure we have data before continuing.\n\/\/ calculate the range on each axis.\n\/\/todo: since we just sorted by x, we can optimize this a bit.\n\/\/axisx = new range<>(ticksx.get(0), ticksx.get(ticksx.size() - 1)); \/\/rangexrendered = axisx;\n\/\/axisy = new range<>(ticksy.get(0), ticksy.get(ticksy.size() - 1)); \/\/ calculate the width of the widest y-axis label and the height of the tallest x-axis label.\n\/\/x-labels are displayed at a 30-degree incline. \/\/the approximate width of the rotated text is 0.87*{width} \/\/the distance from the top of the bounding to the origin from which text should be drawn is 0.5*{length} + 0.87*{height}\n\/\/todo: also check maxwidth against the amount by which this would underflow the x=0 line\n\/\/ render series data, build tooltip cache\n\/\/todo: make this customizable\n\/\/ add rectviewport.getminy() instead of subtracting because we're mirroring the y coordinate around the x-axis.\n\/\/ render axes (last so it overwrites any values near an axis) \/\/clear the axis area\n\/\/draw the axes\n\/\/ticksx and ticksy are lists of the corresponding values; they need to be handed of to the corresponding fnnormalize and then scaled for display.\n\/\/ translate then rotate to rotate text around local origin rather than rotating around the canvas origin. \/\/ rotating and drawing at an offset results in a rotation around the origin.","repo":"nathanawmk\/ICS-Security-Tools","code_context_2":"protected void paint(GraphicsContext gc) {\n\/\/ Get a sorted copy of the series data. Once we have this we can release locks.\nRectangle2D rectViewport = viewport;\nHashMap<Series, LinkedList<T>> data = new HashMap<>();\n\ndata.put(series, seriesData);\n}\n\/\/Make sure we have data before continuing.\nif(data.size() == 0) {\nreturn;\n\nreturn;\n}\n\/\/ Calculate the range on each axis.\nRange<TX> axisX;\nRange<TY> axisY;\n\nRange<TX> axisX;\nRange<TY> axisY;\n\/\/TODO: Since we just sorted by X, we can optimize this a bit.\nif(rangeX != null) {\naxisX = new Range<>(\n\n}\nfinal List<TX> ticksX = fnTicksX.generateTicks(axisX, viewport.getMinX(), viewport.getMaxX());\n\/\/axisX = new Range<>(ticksX.get(0), ticksX.get(ticksX.size() - 1));\n\/\/rangeXRendered = axisX;\nfinal List<TY> ticksY = fnTicksY.generateTicks(axisY, viewport.getMinY(), viewport.getMaxY());\n\/\/axisY = new Range<>(ticksY.get(0), ticksY.get(ticksY.size() - 1));\n\n\/\/rangeXRendered = axisX;\nfinal List<TY> ticksY = fnTicksY.generateTicks(axisY, viewport.getMinY(), viewport.getMaxY());\n\/\/axisY = new Range<>(ticksY.get(0), ticksY.get(ticksY.size() - 1));\n\/\/ Calculate the width of the widest Y-axis label and the height of the tallest X-axis label.\ndouble maxWidth = 0.0;\ndouble pxMinSpacingBetweenTicks = 0.0;\n\ndouble maxHeight = 0.0;\nfor(TX tickX : ticksX) {\n\/\/X-labels are displayed at a 30-degree incline.\n\/\/The approximate width of the rotated text is 0.87*{width}\n\/\/The distance from the top of the bounding to the origin from which text should be drawn is 0.5*{length} + 0.87*{height}\ntextForMeasuring.setText(fnFormatX.apply(tickX));\nfinal Bounds boundsText = textForMeasuring.getLayoutBounds();\n\nfinal Bounds boundsText = textForMeasuring.getLayoutBounds();\nmaxHeight = Math.max(maxHeight, 0.5 * boundsText.getWidth() + 0.87 * boundsText.getHeight());\n\/\/TODO: Also check maxWidth against the amount by which this would underflow the X=0 line\n}\nfinal Rectangle2D sizeAxisLabel = new Rectangle2D(0.0, 0.0, maxWidth, maxHeight);\n\n}\nrectChart = new Rectangle2D(sizeAxisLabel.getWidth() + pxTickLength, 0.0, getWidth() - sizeAxisLabel.getWidth() - pxTickLength, getHeight() - sizeAxisLabel.getHeight() - pxTickLength);\n\/\/ Render series data, build tooltip cache\nrenderedPoints.clear();\nfor(Map.Entry<Series, LinkedList<T>> entry : data.entrySet()) {\n\nPoint2D ptPrev = null;\ngc.setStroke(entry.getKey().getColor());\n\/\/TODO: Make this customizable\ngc.setLineWidth(2.0);\nfor(T value : entry.getValue()) {\n\nTX x = fnXValue.apply(value);\nTY y = fnYValue.apply(value);\n\/\/ Add rectViewport.getMinY() instead of subtracting because we're mirroring the Y coordinate around the X-axis.\nPoint2D ptNew = new Point2D(\nchartXFromDataX(axisX, x),\n\n}\n}\n\/\/ Render axes (last so it overwrites any values near an axis)\n\/\/Clear the axis area\ngc.clearRect(0.0, 0.0, sizeAxisLabel.getWidth() + pxTickLength, getHeight());\ngc.clearRect(0.0, getHeight() - sizeAxisLabel.getHeight() - pxTickLength, getWidth(), sizeAxisLabel.getHeight());\n\ngc.clearRect(0.0, 0.0, sizeAxisLabel.getWidth() + pxTickLength, getHeight());\ngc.clearRect(0.0, getHeight() - sizeAxisLabel.getHeight() - pxTickLength, getWidth(), sizeAxisLabel.getHeight());\n\/\/Draw the axes\ngc.setStroke(Color.BLACK);\ngc.setLineWidth(0.5);\n\nFont font = Font.font(\"MONOSPACE\", 12.0);\ngc.setFont(font);\n\/\/ticksX and ticksY are lists of the corresponding values; they need to be handed of to the corresponding fnNormalize and then scaled for display.\ndouble pxLast = -pxMinSpacingBetweenTicks;\nfor(TX tickX : ticksX) {\n\ndouble offsetX = -0.87 * boundsText.getWidth();\ngc.save();\n\/\/ Translate then rotate to rotate text around local origin rather than rotating around the canvas origin.\n\/\/ Rotating and drawing at an offset results in a rotation around the origin.\ngc.translate(pxX + offsetX, rectChart.getMaxY() + offsetY);\ngc.rotate(-30.0);","code_context_10":"protected void paint(GraphicsContext gc) {\n\/\/ Get a sorted copy of the series data. Once we have this we can release locks.\nRectangle2D rectViewport = viewport;\nHashMap<Series, LinkedList<T>> data = new HashMap<>();\nfor(Series<T> series : this.series) {\nLinkedList<T> seriesData = new LinkedList<>(series.getData());\nseriesData.sort((o1, o2) -> fnXValue.apply(o1).compareTo(fnXValue.apply(o2)));\ndata.put(series, seriesData);\n}\n\/\/Make sure we have data before continuing.\nif(data.size() == 0) {\nreturn;\n\nprotected void paint(GraphicsContext gc) {\n\/\/ Get a sorted copy of the series data. Once we have this we can release locks.\nRectangle2D rectViewport = viewport;\nHashMap<Series, LinkedList<T>> data = new HashMap<>();\nfor(Series<T> series : this.series) {\nLinkedList<T> seriesData = new LinkedList<>(series.getData());\nseriesData.sort((o1, o2) -> fnXValue.apply(o1).compareTo(fnXValue.apply(o2)));\ndata.put(series, seriesData);\n}\n\/\/Make sure we have data before continuing.\nif(data.size() == 0) {\nreturn;\n}\nif(data.values().stream().flatMap(LinkedList::stream).count() == 0) {\nreturn;\n}\n\/\/ Calculate the range on each axis.\nRange<TX> axisX;\nRange<TY> axisY;\n\/\/TODO: Since we just sorted by X, we can optimize this a bit.\n\nseriesData.sort((o1, o2) -> fnXValue.apply(o1).compareTo(fnXValue.apply(o2)));\ndata.put(series, seriesData);\n}\n\/\/Make sure we have data before continuing.\nif(data.size() == 0) {\nreturn;\n}\nif(data.values().stream().flatMap(LinkedList::stream).count() == 0) {\nreturn;\n}\n\/\/ Calculate the range on each axis.\nRange<TX> axisX;\nRange<TY> axisY;\n\/\/TODO: Since we just sorted by X, we can optimize this a bit.\nif(rangeX != null) {\naxisX = new Range<>(\nrangeX.min == null ? data.values().stream().flatMap(LinkedList::stream).map(fnXValue).min(TX::compareTo).get() : rangeX.min,\nrangeX.max == null ? data.values().stream().flatMap(LinkedList::stream).map(fnXValue).max(TX::compareTo).get() : rangeX.max\n);\n} else {\naxisX = new Range<>(\n\n\/\/Make sure we have data before continuing.\nif(data.size() == 0) {\nreturn;\n}\nif(data.values().stream().flatMap(LinkedList::stream).count() == 0) {\nreturn;\n}\n\/\/ Calculate the range on each axis.\nRange<TX> axisX;\nRange<TY> axisY;\n\/\/TODO: Since we just sorted by X, we can optimize this a bit.\nif(rangeX != null) {\naxisX = new Range<>(\nrangeX.min == null ? data.values().stream().flatMap(LinkedList::stream).map(fnXValue).min(TX::compareTo).get() : rangeX.min,\nrangeX.max == null ? data.values().stream().flatMap(LinkedList::stream).map(fnXValue).max(TX::compareTo).get() : rangeX.max\n);\n} else {\naxisX = new Range<>(\ndata.values().stream().flatMap(LinkedList::stream).map(fnXValue).min(TX::compareTo).get(),\ndata.values().stream().flatMap(LinkedList::stream).map(fnXValue).max(TX::compareTo).get()\n);\n\nrangeY.min == null ? data.values().stream().flatMap(LinkedList::stream).map(fnYValue).min(TY::compareTo).get() : rangeY.min,\nrangeY.max == null ? data.values().stream().flatMap(LinkedList::stream).map(fnYValue).max(TY::compareTo).get() : rangeY.max\n);\n} else {\naxisY = new Range<>(\ndata.values().stream().flatMap(LinkedList::stream).map(fnYValue).min(TY::compareTo).get(),\ndata.values().stream().flatMap(LinkedList::stream).map(fnYValue).max(TY::compareTo).get()\n);\n}\nfinal List<TX> ticksX = fnTicksX.generateTicks(axisX, viewport.getMinX(), viewport.getMaxX());\n\/\/axisX = new Range<>(ticksX.get(0), ticksX.get(ticksX.size() - 1));\n\/\/rangeXRendered = axisX;\nfinal List<TY> ticksY = fnTicksY.generateTicks(axisY, viewport.getMinY(), viewport.getMaxY());\n\/\/axisY = new Range<>(ticksY.get(0), ticksY.get(ticksY.size() - 1));\n\/\/ Calculate the width of the widest Y-axis label and the height of the tallest X-axis label.\ndouble maxWidth = 0.0;\ndouble pxMinSpacingBetweenTicks = 0.0;\nfor(TY tickY : ticksY) {\ntextForMeasuring.setText(fnFormatY.apply(tickY));\nmaxWidth = Math.max(maxWidth, textForMeasuring.getLayoutBounds().getWidth());\npxMinSpacingBetweenTicks = Math.max(pxMinSpacingBetweenTicks, 2.0 * textForMeasuring.getLayoutBounds().getHeight());\n}\n\n} else {\naxisY = new Range<>(\ndata.values().stream().flatMap(LinkedList::stream).map(fnYValue).min(TY::compareTo).get(),\ndata.values().stream().flatMap(LinkedList::stream).map(fnYValue).max(TY::compareTo).get()\n);\n}\nfinal List<TX> ticksX = fnTicksX.generateTicks(axisX, viewport.getMinX(), viewport.getMaxX());\n\/\/axisX = new Range<>(ticksX.get(0), ticksX.get(ticksX.size() - 1));\n\/\/rangeXRendered = axisX;\nfinal List<TY> ticksY = fnTicksY.generateTicks(axisY, viewport.getMinY(), viewport.getMaxY());\n\/\/axisY = new Range<>(ticksY.get(0), ticksY.get(ticksY.size() - 1));\n\/\/ Calculate the width of the widest Y-axis label and the height of the tallest X-axis label.\ndouble maxWidth = 0.0;\ndouble pxMinSpacingBetweenTicks = 0.0;\nfor(TY tickY : ticksY) {\ntextForMeasuring.setText(fnFormatY.apply(tickY));\nmaxWidth = Math.max(maxWidth, textForMeasuring.getLayoutBounds().getWidth());\npxMinSpacingBetweenTicks = Math.max(pxMinSpacingBetweenTicks, 2.0 * textForMeasuring.getLayoutBounds().getHeight());\n}\ndouble maxHeight = 0.0;\nfor(TX tickX : ticksX) {\n\/\/X-labels are displayed at a 30-degree incline.\n\n\/\/ Calculate the width of the widest Y-axis label and the height of the tallest X-axis label.\ndouble maxWidth = 0.0;\ndouble pxMinSpacingBetweenTicks = 0.0;\nfor(TY tickY : ticksY) {\ntextForMeasuring.setText(fnFormatY.apply(tickY));\nmaxWidth = Math.max(maxWidth, textForMeasuring.getLayoutBounds().getWidth());\npxMinSpacingBetweenTicks = Math.max(pxMinSpacingBetweenTicks, 2.0 * textForMeasuring.getLayoutBounds().getHeight());\n}\ndouble maxHeight = 0.0;\nfor(TX tickX : ticksX) {\n\/\/X-labels are displayed at a 30-degree incline.\n\/\/The approximate width of the rotated text is 0.87*{width}\n\/\/The distance from the top of the bounding to the origin from which text should be drawn is 0.5*{length} + 0.87*{height}\ntextForMeasuring.setText(fnFormatX.apply(tickX));\nfinal Bounds boundsText = textForMeasuring.getLayoutBounds();\nmaxHeight = Math.max(maxHeight, 0.5 * boundsText.getWidth() + 0.87 * boundsText.getHeight());\n\/\/TODO: Also check maxWidth against the amount by which this would underflow the X=0 line\n}\nfinal Rectangle2D sizeAxisLabel = new Rectangle2D(0.0, 0.0, maxWidth, maxHeight);\nif(getWidth() <= sizeAxisLabel.getWidth() || getHeight() <= sizeAxisLabel.getHeight()) {\nreturn;\n}\nrectChart = new Rectangle2D(sizeAxisLabel.getWidth() + pxTickLength, 0.0, getWidth() - sizeAxisLabel.getWidth() - pxTickLength, getHeight() - sizeAxisLabel.getHeight() - pxTickLength);\n\npxMinSpacingBetweenTicks = Math.max(pxMinSpacingBetweenTicks, 2.0 * textForMeasuring.getLayoutBounds().getHeight());\n}\ndouble maxHeight = 0.0;\nfor(TX tickX : ticksX) {\n\/\/X-labels are displayed at a 30-degree incline.\n\/\/The approximate width of the rotated text is 0.87*{width}\n\/\/The distance from the top of the bounding to the origin from which text should be drawn is 0.5*{length} + 0.87*{height}\ntextForMeasuring.setText(fnFormatX.apply(tickX));\nfinal Bounds boundsText = textForMeasuring.getLayoutBounds();\nmaxHeight = Math.max(maxHeight, 0.5 * boundsText.getWidth() + 0.87 * boundsText.getHeight());\n\/\/TODO: Also check maxWidth against the amount by which this would underflow the X=0 line\n}\nfinal Rectangle2D sizeAxisLabel = new Rectangle2D(0.0, 0.0, maxWidth, maxHeight);\nif(getWidth() <= sizeAxisLabel.getWidth() || getHeight() <= sizeAxisLabel.getHeight()) {\nreturn;\n}\nrectChart = new Rectangle2D(sizeAxisLabel.getWidth() + pxTickLength, 0.0, getWidth() - sizeAxisLabel.getWidth() - pxTickLength, getHeight() - sizeAxisLabel.getHeight() - pxTickLength);\n\/\/ Render series data, build tooltip cache\nrenderedPoints.clear();\nfor(Map.Entry<Series, LinkedList<T>> entry : data.entrySet()) {\nPoint2D ptPrev = null;\n\ntextForMeasuring.setText(fnFormatX.apply(tickX));\nfinal Bounds boundsText = textForMeasuring.getLayoutBounds();\nmaxHeight = Math.max(maxHeight, 0.5 * boundsText.getWidth() + 0.87 * boundsText.getHeight());\n\/\/TODO: Also check maxWidth against the amount by which this would underflow the X=0 line\n}\nfinal Rectangle2D sizeAxisLabel = new Rectangle2D(0.0, 0.0, maxWidth, maxHeight);\nif(getWidth() <= sizeAxisLabel.getWidth() || getHeight() <= sizeAxisLabel.getHeight()) {\nreturn;\n}\nrectChart = new Rectangle2D(sizeAxisLabel.getWidth() + pxTickLength, 0.0, getWidth() - sizeAxisLabel.getWidth() - pxTickLength, getHeight() - sizeAxisLabel.getHeight() - pxTickLength);\n\/\/ Render series data, build tooltip cache\nrenderedPoints.clear();\nfor(Map.Entry<Series, LinkedList<T>> entry : data.entrySet()) {\nPoint2D ptPrev = null;\ngc.setStroke(entry.getKey().getColor());\n\/\/TODO: Make this customizable\ngc.setLineWidth(2.0);\nfor(T value : entry.getValue()) {\nTX x = fnXValue.apply(value);\nTY y = fnYValue.apply(value);\n\/\/ Add rectViewport.getMinY() instead of subtracting because we're mirroring the Y coordinate around the X-axis.\n\nfinal Rectangle2D sizeAxisLabel = new Rectangle2D(0.0, 0.0, maxWidth, maxHeight);\nif(getWidth() <= sizeAxisLabel.getWidth() || getHeight() <= sizeAxisLabel.getHeight()) {\nreturn;\n}\nrectChart = new Rectangle2D(sizeAxisLabel.getWidth() + pxTickLength, 0.0, getWidth() - sizeAxisLabel.getWidth() - pxTickLength, getHeight() - sizeAxisLabel.getHeight() - pxTickLength);\n\/\/ Render series data, build tooltip cache\nrenderedPoints.clear();\nfor(Map.Entry<Series, LinkedList<T>> entry : data.entrySet()) {\nPoint2D ptPrev = null;\ngc.setStroke(entry.getKey().getColor());\n\/\/TODO: Make this customizable\ngc.setLineWidth(2.0);\nfor(T value : entry.getValue()) {\nTX x = fnXValue.apply(value);\nTY y = fnYValue.apply(value);\n\/\/ Add rectViewport.getMinY() instead of subtracting because we're mirroring the Y coordinate around the X-axis.\nPoint2D ptNew = new Point2D(\nchartXFromDataX(axisX, x),\nchartYFromDataY(axisY, y));\nPoint<T, TX, TY> pt = new Point<>(\nvalue,\n\n\/\/ Render series data, build tooltip cache\nrenderedPoints.clear();\nfor(Map.Entry<Series, LinkedList<T>> entry : data.entrySet()) {\nPoint2D ptPrev = null;\ngc.setStroke(entry.getKey().getColor());\n\/\/TODO: Make this customizable\ngc.setLineWidth(2.0);\nfor(T value : entry.getValue()) {\nTX x = fnXValue.apply(value);\nTY y = fnYValue.apply(value);\n\/\/ Add rectViewport.getMinY() instead of subtracting because we're mirroring the Y coordinate around the X-axis.\nPoint2D ptNew = new Point2D(\nchartXFromDataX(axisX, x),\nchartYFromDataY(axisY, y));\nPoint<T, TX, TY> pt = new Point<>(\nvalue,\nx,\ny,\nptNew,\nentry.getKey().getColor()\n);\n\nentry.getKey().getColor()\n);\nrenderedPoints.add(pt);\nif(ptPrev != null) {\ngc.strokeLine(ptPrev.getX(), ptPrev.getY(), ptNew.getX(), ptNew.getY());\n}\ngc.strokeOval(ptNew.getX() - pointRadius, ptNew.getY() - pointRadius, pointRadius * 2, pointRadius * 2);\nptPrev = ptNew;\n}\n}\n\/\/ Render axes (last so it overwrites any values near an axis)\n\/\/Clear the axis area\ngc.clearRect(0.0, 0.0, sizeAxisLabel.getWidth() + pxTickLength, getHeight());\ngc.clearRect(0.0, getHeight() - sizeAxisLabel.getHeight() - pxTickLength, getWidth(), sizeAxisLabel.getHeight());\n\/\/Draw the axes\ngc.setStroke(Color.BLACK);\ngc.setLineWidth(0.5);\ngc.strokeLine(rectChart.getMinX(), 0.0, rectChart.getMinX(), rectChart.getMaxY());\ngc.strokeLine(rectChart.getMinX(), rectChart.getMaxY(), rectChart.getMaxX(), rectChart.getMaxY());\nFont font = Font.font(\"MONOSPACE\", 12.0);\ngc.setFont(font);\n\/\/ticksX and ticksY are lists of the corresponding values; they need to be handed of to the corresponding fnNormalize and then scaled for display.\n\ngc.strokeLine(ptPrev.getX(), ptPrev.getY(), ptNew.getX(), ptNew.getY());\n}\ngc.strokeOval(ptNew.getX() - pointRadius, ptNew.getY() - pointRadius, pointRadius * 2, pointRadius * 2);\nptPrev = ptNew;\n}\n}\n\/\/ Render axes (last so it overwrites any values near an axis)\n\/\/Clear the axis area\ngc.clearRect(0.0, 0.0, sizeAxisLabel.getWidth() + pxTickLength, getHeight());\ngc.clearRect(0.0, getHeight() - sizeAxisLabel.getHeight() - pxTickLength, getWidth(), sizeAxisLabel.getHeight());\n\/\/Draw the axes\ngc.setStroke(Color.BLACK);\ngc.setLineWidth(0.5);\ngc.strokeLine(rectChart.getMinX(), 0.0, rectChart.getMinX(), rectChart.getMaxY());\ngc.strokeLine(rectChart.getMinX(), rectChart.getMaxY(), rectChart.getMaxX(), rectChart.getMaxY());\nFont font = Font.font(\"MONOSPACE\", 12.0);\ngc.setFont(font);\n\/\/ticksX and ticksY are lists of the corresponding values; they need to be handed of to the corresponding fnNormalize and then scaled for display.\ndouble pxLast = -pxMinSpacingBetweenTicks;\nfor(TX tickX : ticksX) {\nfinal double pxX = chartXFromDataX(axisX, tickX);\n\n\/\/Clear the axis area\ngc.clearRect(0.0, 0.0, sizeAxisLabel.getWidth() + pxTickLength, getHeight());\ngc.clearRect(0.0, getHeight() - sizeAxisLabel.getHeight() - pxTickLength, getWidth(), sizeAxisLabel.getHeight());\n\/\/Draw the axes\ngc.setStroke(Color.BLACK);\ngc.setLineWidth(0.5);\ngc.strokeLine(rectChart.getMinX(), 0.0, rectChart.getMinX(), rectChart.getMaxY());\ngc.strokeLine(rectChart.getMinX(), rectChart.getMaxY(), rectChart.getMaxX(), rectChart.getMaxY());\nFont font = Font.font(\"MONOSPACE\", 12.0);\ngc.setFont(font);\n\/\/ticksX and ticksY are lists of the corresponding values; they need to be handed of to the corresponding fnNormalize and then scaled for display.\ndouble pxLast = -pxMinSpacingBetweenTicks;\nfor(TX tickX : ticksX) {\nfinal double pxX = chartXFromDataX(axisX, tickX);\nif(pxLast + pxMinSpacingBetweenTicks > pxX) {\ncontinue;\n}\npxLast = pxX;\ngc.strokeLine(pxX, rectChart.getMaxY(), pxX, rectChart.getMaxY() + pxTickLength);\nfinal String textLabel = fnFormatX.apply(tickX);\ntextForMeasuring.setText(textLabel);\n\ncontinue;\n}\npxLast = pxX;\ngc.strokeLine(pxX, rectChart.getMaxY(), pxX, rectChart.getMaxY() + pxTickLength);\nfinal String textLabel = fnFormatX.apply(tickX);\ntextForMeasuring.setText(textLabel);\nfinal Bounds boundsText = textForMeasuring.getLayoutBounds();\ndouble offsetY = 0.5 * boundsText.getWidth() + 0.87 * boundsText.getHeight();\ndouble offsetX = -0.87 * boundsText.getWidth();\ngc.save();\n\/\/ Translate then rotate to rotate text around local origin rather than rotating around the canvas origin.\n\/\/ Rotating and drawing at an offset results in a rotation around the origin.\ngc.translate(pxX + offsetX, rectChart.getMaxY() + offsetY);\ngc.rotate(-30.0);\ngc.strokeText(textLabel, 0.0, 0.0);\ngc.restore();\n}\nfor(TY tickY : ticksY) {\nfinal double pxY = chartYFromDataY(axisY, tickY);\ngc.strokeLine(rectChart.getMinX() - pxTickLength, pxY, rectChart.getMinX(), pxY);\nfinal String textLabel = fnFormatY.apply(tickY);\ntextForMeasuring.setText(textLabel);","code_context_20":"protected void paint(GraphicsContext gc) {\n\/\/ Get a sorted copy of the series data. Once we have this we can release locks.\nRectangle2D rectViewport = viewport;\nHashMap<Series, LinkedList<T>> data = new HashMap<>();\nfor(Series<T> series : this.series) {\nLinkedList<T> seriesData = new LinkedList<>(series.getData());\nseriesData.sort((o1, o2) -> fnXValue.apply(o1).compareTo(fnXValue.apply(o2)));\ndata.put(series, seriesData);\n}\n\/\/Make sure we have data before continuing.\nif(data.size() == 0) {\nreturn;\n}\nif(data.values().stream().flatMap(LinkedList::stream).count() == 0) {\nreturn;\n}\n\/\/ Calculate the range on each axis.\nRange<TX> axisX;\nRange<TY> axisY;\n\/\/TODO: Since we just sorted by X, we can optimize this a bit.\nif(rangeX != null) {\naxisX = new Range<>(\n\nprotected void paint(GraphicsContext gc) {\n\/\/ Get a sorted copy of the series data. Once we have this we can release locks.\nRectangle2D rectViewport = viewport;\nHashMap<Series, LinkedList<T>> data = new HashMap<>();\nfor(Series<T> series : this.series) {\nLinkedList<T> seriesData = new LinkedList<>(series.getData());\nseriesData.sort((o1, o2) -> fnXValue.apply(o1).compareTo(fnXValue.apply(o2)));\ndata.put(series, seriesData);\n}\n\/\/Make sure we have data before continuing.\nif(data.size() == 0) {\nreturn;\n}\nif(data.values().stream().flatMap(LinkedList::stream).count() == 0) {\nreturn;\n}\n\/\/ Calculate the range on each axis.\nRange<TX> axisX;\nRange<TY> axisY;\n\/\/TODO: Since we just sorted by X, we can optimize this a bit.\nif(rangeX != null) {\naxisX = new Range<>(\nrangeX.min == null ? data.values().stream().flatMap(LinkedList::stream).map(fnXValue).min(TX::compareTo).get() : rangeX.min,\nrangeX.max == null ? data.values().stream().flatMap(LinkedList::stream).map(fnXValue).max(TX::compareTo).get() : rangeX.max\n);\n} else {\naxisX = new Range<>(\ndata.values().stream().flatMap(LinkedList::stream).map(fnXValue).min(TX::compareTo).get(),\ndata.values().stream().flatMap(LinkedList::stream).map(fnXValue).max(TX::compareTo).get()\n);\n\nprotected void paint(GraphicsContext gc) {\n\/\/ Get a sorted copy of the series data. Once we have this we can release locks.\nRectangle2D rectViewport = viewport;\nHashMap<Series, LinkedList<T>> data = new HashMap<>();\nfor(Series<T> series : this.series) {\nLinkedList<T> seriesData = new LinkedList<>(series.getData());\nseriesData.sort((o1, o2) -> fnXValue.apply(o1).compareTo(fnXValue.apply(o2)));\ndata.put(series, seriesData);\n}\n\/\/Make sure we have data before continuing.\nif(data.size() == 0) {\nreturn;\n}\nif(data.values().stream().flatMap(LinkedList::stream).count() == 0) {\nreturn;\n}\n\/\/ Calculate the range on each axis.\nRange<TX> axisX;\nRange<TY> axisY;\n\/\/TODO: Since we just sorted by X, we can optimize this a bit.\nif(rangeX != null) {\naxisX = new Range<>(\nrangeX.min == null ? data.values().stream().flatMap(LinkedList::stream).map(fnXValue).min(TX::compareTo).get() : rangeX.min,\nrangeX.max == null ? data.values().stream().flatMap(LinkedList::stream).map(fnXValue).max(TX::compareTo).get() : rangeX.max\n);\n} else {\naxisX = new Range<>(\ndata.values().stream().flatMap(LinkedList::stream).map(fnXValue).min(TX::compareTo).get(),\ndata.values().stream().flatMap(LinkedList::stream).map(fnXValue).max(TX::compareTo).get()\n);\n}\nif(rangeY != null) {\naxisY = new Range<>(\nrangeY.min == null ? data.values().stream().flatMap(LinkedList::stream).map(fnYValue).min(TY::compareTo).get() : rangeY.min,\nrangeY.max == null ? data.values().stream().flatMap(LinkedList::stream).map(fnYValue).max(TY::compareTo).get() : rangeY.max\n);\n} else {\n\nprotected void paint(GraphicsContext gc) {\n\/\/ Get a sorted copy of the series data. Once we have this we can release locks.\nRectangle2D rectViewport = viewport;\nHashMap<Series, LinkedList<T>> data = new HashMap<>();\nfor(Series<T> series : this.series) {\nLinkedList<T> seriesData = new LinkedList<>(series.getData());\nseriesData.sort((o1, o2) -> fnXValue.apply(o1).compareTo(fnXValue.apply(o2)));\ndata.put(series, seriesData);\n}\n\/\/Make sure we have data before continuing.\nif(data.size() == 0) {\nreturn;\n}\nif(data.values().stream().flatMap(LinkedList::stream).count() == 0) {\nreturn;\n}\n\/\/ Calculate the range on each axis.\nRange<TX> axisX;\nRange<TY> axisY;\n\/\/TODO: Since we just sorted by X, we can optimize this a bit.\nif(rangeX != null) {\naxisX = new Range<>(\nrangeX.min == null ? data.values().stream().flatMap(LinkedList::stream).map(fnXValue).min(TX::compareTo).get() : rangeX.min,\nrangeX.max == null ? data.values().stream().flatMap(LinkedList::stream).map(fnXValue).max(TX::compareTo).get() : rangeX.max\n);\n} else {\naxisX = new Range<>(\ndata.values().stream().flatMap(LinkedList::stream).map(fnXValue).min(TX::compareTo).get(),\ndata.values().stream().flatMap(LinkedList::stream).map(fnXValue).max(TX::compareTo).get()\n);\n}\nif(rangeY != null) {\naxisY = new Range<>(\nrangeY.min == null ? data.values().stream().flatMap(LinkedList::stream).map(fnYValue).min(TY::compareTo).get() : rangeY.min,\nrangeY.max == null ? data.values().stream().flatMap(LinkedList::stream).map(fnYValue).max(TY::compareTo).get() : rangeY.max\n);\n} else {\naxisY = new Range<>(\ndata.values().stream().flatMap(LinkedList::stream).map(fnYValue).min(TY::compareTo).get(),\ndata.values().stream().flatMap(LinkedList::stream).map(fnYValue).max(TY::compareTo).get()\n\nrangeX.max == null ? data.values().stream().flatMap(LinkedList::stream).map(fnXValue).max(TX::compareTo).get() : rangeX.max\n);\n} else {\naxisX = new Range<>(\ndata.values().stream().flatMap(LinkedList::stream).map(fnXValue).min(TX::compareTo).get(),\ndata.values().stream().flatMap(LinkedList::stream).map(fnXValue).max(TX::compareTo).get()\n);\n}\nif(rangeY != null) {\naxisY = new Range<>(\nrangeY.min == null ? data.values().stream().flatMap(LinkedList::stream).map(fnYValue).min(TY::compareTo).get() : rangeY.min,\nrangeY.max == null ? data.values().stream().flatMap(LinkedList::stream).map(fnYValue).max(TY::compareTo).get() : rangeY.max\n);\n} else {\naxisY = new Range<>(\ndata.values().stream().flatMap(LinkedList::stream).map(fnYValue).min(TY::compareTo).get(),\ndata.values().stream().flatMap(LinkedList::stream).map(fnYValue).max(TY::compareTo).get()\n);\n}\nfinal List<TX> ticksX = fnTicksX.generateTicks(axisX, viewport.getMinX(), viewport.getMaxX());\n\/\/axisX = new Range<>(ticksX.get(0), ticksX.get(ticksX.size() - 1));\n\/\/rangeXRendered = axisX;\nfinal List<TY> ticksY = fnTicksY.generateTicks(axisY, viewport.getMinY(), viewport.getMaxY());\n\/\/axisY = new Range<>(ticksY.get(0), ticksY.get(ticksY.size() - 1));\n\/\/ Calculate the width of the widest Y-axis label and the height of the tallest X-axis label.\ndouble maxWidth = 0.0;\ndouble pxMinSpacingBetweenTicks = 0.0;\nfor(TY tickY : ticksY) {\ntextForMeasuring.setText(fnFormatY.apply(tickY));\nmaxWidth = Math.max(maxWidth, textForMeasuring.getLayoutBounds().getWidth());\npxMinSpacingBetweenTicks = Math.max(pxMinSpacingBetweenTicks, 2.0 * textForMeasuring.getLayoutBounds().getHeight());\n}\ndouble maxHeight = 0.0;\nfor(TX tickX : ticksX) {\n\/\/X-labels are displayed at a 30-degree incline.\n\/\/The approximate width of the rotated text is 0.87*{width}\n\/\/The distance from the top of the bounding to the origin from which text should be drawn is 0.5*{length} + 0.87*{height}\ntextForMeasuring.setText(fnFormatX.apply(tickX));\nfinal Bounds boundsText = textForMeasuring.getLayoutBounds();\nmaxHeight = Math.max(maxHeight, 0.5 * boundsText.getWidth() + 0.87 * boundsText.getHeight());\n\/\/TODO: Also check maxWidth against the amount by which this would underflow the X=0 line\n}\n\naxisX = new Range<>(\ndata.values().stream().flatMap(LinkedList::stream).map(fnXValue).min(TX::compareTo).get(),\ndata.values().stream().flatMap(LinkedList::stream).map(fnXValue).max(TX::compareTo).get()\n);\n}\nif(rangeY != null) {\naxisY = new Range<>(\nrangeY.min == null ? data.values().stream().flatMap(LinkedList::stream).map(fnYValue).min(TY::compareTo).get() : rangeY.min,\nrangeY.max == null ? data.values().stream().flatMap(LinkedList::stream).map(fnYValue).max(TY::compareTo).get() : rangeY.max\n);\n} else {\naxisY = new Range<>(\ndata.values().stream().flatMap(LinkedList::stream).map(fnYValue).min(TY::compareTo).get(),\ndata.values().stream().flatMap(LinkedList::stream).map(fnYValue).max(TY::compareTo).get()\n);\n}\nfinal List<TX> ticksX = fnTicksX.generateTicks(axisX, viewport.getMinX(), viewport.getMaxX());\n\/\/axisX = new Range<>(ticksX.get(0), ticksX.get(ticksX.size() - 1));\n\/\/rangeXRendered = axisX;\nfinal List<TY> ticksY = fnTicksY.generateTicks(axisY, viewport.getMinY(), viewport.getMaxY());\n\/\/axisY = new Range<>(ticksY.get(0), ticksY.get(ticksY.size() - 1));\n\/\/ Calculate the width of the widest Y-axis label and the height of the tallest X-axis label.\ndouble maxWidth = 0.0;\ndouble pxMinSpacingBetweenTicks = 0.0;\nfor(TY tickY : ticksY) {\ntextForMeasuring.setText(fnFormatY.apply(tickY));\nmaxWidth = Math.max(maxWidth, textForMeasuring.getLayoutBounds().getWidth());\npxMinSpacingBetweenTicks = Math.max(pxMinSpacingBetweenTicks, 2.0 * textForMeasuring.getLayoutBounds().getHeight());\n}\ndouble maxHeight = 0.0;\nfor(TX tickX : ticksX) {\n\/\/X-labels are displayed at a 30-degree incline.\n\/\/The approximate width of the rotated text is 0.87*{width}\n\/\/The distance from the top of the bounding to the origin from which text should be drawn is 0.5*{length} + 0.87*{height}\ntextForMeasuring.setText(fnFormatX.apply(tickX));\nfinal Bounds boundsText = textForMeasuring.getLayoutBounds();\nmaxHeight = Math.max(maxHeight, 0.5 * boundsText.getWidth() + 0.87 * boundsText.getHeight());\n\/\/TODO: Also check maxWidth against the amount by which this would underflow the X=0 line\n}\nfinal Rectangle2D sizeAxisLabel = new Rectangle2D(0.0, 0.0, maxWidth, maxHeight);\nif(getWidth() <= sizeAxisLabel.getWidth() || getHeight() <= sizeAxisLabel.getHeight()) {\nreturn;\n\naxisY = new Range<>(\ndata.values().stream().flatMap(LinkedList::stream).map(fnYValue).min(TY::compareTo).get(),\ndata.values().stream().flatMap(LinkedList::stream).map(fnYValue).max(TY::compareTo).get()\n);\n}\nfinal List<TX> ticksX = fnTicksX.generateTicks(axisX, viewport.getMinX(), viewport.getMaxX());\n\/\/axisX = new Range<>(ticksX.get(0), ticksX.get(ticksX.size() - 1));\n\/\/rangeXRendered = axisX;\nfinal List<TY> ticksY = fnTicksY.generateTicks(axisY, viewport.getMinY(), viewport.getMaxY());\n\/\/axisY = new Range<>(ticksY.get(0), ticksY.get(ticksY.size() - 1));\n\/\/ Calculate the width of the widest Y-axis label and the height of the tallest X-axis label.\ndouble maxWidth = 0.0;\ndouble pxMinSpacingBetweenTicks = 0.0;\nfor(TY tickY : ticksY) {\ntextForMeasuring.setText(fnFormatY.apply(tickY));\nmaxWidth = Math.max(maxWidth, textForMeasuring.getLayoutBounds().getWidth());\npxMinSpacingBetweenTicks = Math.max(pxMinSpacingBetweenTicks, 2.0 * textForMeasuring.getLayoutBounds().getHeight());\n}\ndouble maxHeight = 0.0;\nfor(TX tickX : ticksX) {\n\/\/X-labels are displayed at a 30-degree incline.\n\/\/The approximate width of the rotated text is 0.87*{width}\n\/\/The distance from the top of the bounding to the origin from which text should be drawn is 0.5*{length} + 0.87*{height}\ntextForMeasuring.setText(fnFormatX.apply(tickX));\nfinal Bounds boundsText = textForMeasuring.getLayoutBounds();\nmaxHeight = Math.max(maxHeight, 0.5 * boundsText.getWidth() + 0.87 * boundsText.getHeight());\n\/\/TODO: Also check maxWidth against the amount by which this would underflow the X=0 line\n}\nfinal Rectangle2D sizeAxisLabel = new Rectangle2D(0.0, 0.0, maxWidth, maxHeight);\nif(getWidth() <= sizeAxisLabel.getWidth() || getHeight() <= sizeAxisLabel.getHeight()) {\nreturn;\n}\nrectChart = new Rectangle2D(sizeAxisLabel.getWidth() + pxTickLength, 0.0, getWidth() - sizeAxisLabel.getWidth() - pxTickLength, getHeight() - sizeAxisLabel.getHeight() - pxTickLength);\n\/\/ Render series data, build tooltip cache\nrenderedPoints.clear();\nfor(Map.Entry<Series, LinkedList<T>> entry : data.entrySet()) {\nPoint2D ptPrev = null;\ngc.setStroke(entry.getKey().getColor());\n\/\/TODO: Make this customizable\ngc.setLineWidth(2.0);\nfor(T value : entry.getValue()) {\nTX x = fnXValue.apply(value);\nTY y = fnYValue.apply(value);\n\n\/\/axisX = new Range<>(ticksX.get(0), ticksX.get(ticksX.size() - 1));\n\/\/rangeXRendered = axisX;\nfinal List<TY> ticksY = fnTicksY.generateTicks(axisY, viewport.getMinY(), viewport.getMaxY());\n\/\/axisY = new Range<>(ticksY.get(0), ticksY.get(ticksY.size() - 1));\n\/\/ Calculate the width of the widest Y-axis label and the height of the tallest X-axis label.\ndouble maxWidth = 0.0;\ndouble pxMinSpacingBetweenTicks = 0.0;\nfor(TY tickY : ticksY) {\ntextForMeasuring.setText(fnFormatY.apply(tickY));\nmaxWidth = Math.max(maxWidth, textForMeasuring.getLayoutBounds().getWidth());\npxMinSpacingBetweenTicks = Math.max(pxMinSpacingBetweenTicks, 2.0 * textForMeasuring.getLayoutBounds().getHeight());\n}\ndouble maxHeight = 0.0;\nfor(TX tickX : ticksX) {\n\/\/X-labels are displayed at a 30-degree incline.\n\/\/The approximate width of the rotated text is 0.87*{width}\n\/\/The distance from the top of the bounding to the origin from which text should be drawn is 0.5*{length} + 0.87*{height}\ntextForMeasuring.setText(fnFormatX.apply(tickX));\nfinal Bounds boundsText = textForMeasuring.getLayoutBounds();\nmaxHeight = Math.max(maxHeight, 0.5 * boundsText.getWidth() + 0.87 * boundsText.getHeight());\n\/\/TODO: Also check maxWidth against the amount by which this would underflow the X=0 line\n}\nfinal Rectangle2D sizeAxisLabel = new Rectangle2D(0.0, 0.0, maxWidth, maxHeight);\nif(getWidth() <= sizeAxisLabel.getWidth() || getHeight() <= sizeAxisLabel.getHeight()) {\nreturn;\n}\nrectChart = new Rectangle2D(sizeAxisLabel.getWidth() + pxTickLength, 0.0, getWidth() - sizeAxisLabel.getWidth() - pxTickLength, getHeight() - sizeAxisLabel.getHeight() - pxTickLength);\n\/\/ Render series data, build tooltip cache\nrenderedPoints.clear();\nfor(Map.Entry<Series, LinkedList<T>> entry : data.entrySet()) {\nPoint2D ptPrev = null;\ngc.setStroke(entry.getKey().getColor());\n\/\/TODO: Make this customizable\ngc.setLineWidth(2.0);\nfor(T value : entry.getValue()) {\nTX x = fnXValue.apply(value);\nTY y = fnYValue.apply(value);\n\/\/ Add rectViewport.getMinY() instead of subtracting because we're mirroring the Y coordinate around the X-axis.\nPoint2D ptNew = new Point2D(\nchartXFromDataX(axisX, x),\nchartYFromDataY(axisY, y));\n\nfor(TY tickY : ticksY) {\ntextForMeasuring.setText(fnFormatY.apply(tickY));\nmaxWidth = Math.max(maxWidth, textForMeasuring.getLayoutBounds().getWidth());\npxMinSpacingBetweenTicks = Math.max(pxMinSpacingBetweenTicks, 2.0 * textForMeasuring.getLayoutBounds().getHeight());\n}\ndouble maxHeight = 0.0;\nfor(TX tickX : ticksX) {\n\/\/X-labels are displayed at a 30-degree incline.\n\/\/The approximate width of the rotated text is 0.87*{width}\n\/\/The distance from the top of the bounding to the origin from which text should be drawn is 0.5*{length} + 0.87*{height}\ntextForMeasuring.setText(fnFormatX.apply(tickX));\nfinal Bounds boundsText = textForMeasuring.getLayoutBounds();\nmaxHeight = Math.max(maxHeight, 0.5 * boundsText.getWidth() + 0.87 * boundsText.getHeight());\n\/\/TODO: Also check maxWidth against the amount by which this would underflow the X=0 line\n}\nfinal Rectangle2D sizeAxisLabel = new Rectangle2D(0.0, 0.0, maxWidth, maxHeight);\nif(getWidth() <= sizeAxisLabel.getWidth() || getHeight() <= sizeAxisLabel.getHeight()) {\nreturn;\n}\nrectChart = new Rectangle2D(sizeAxisLabel.getWidth() + pxTickLength, 0.0, getWidth() - sizeAxisLabel.getWidth() - pxTickLength, getHeight() - sizeAxisLabel.getHeight() - pxTickLength);\n\/\/ Render series data, build tooltip cache\nrenderedPoints.clear();\nfor(Map.Entry<Series, LinkedList<T>> entry : data.entrySet()) {\nPoint2D ptPrev = null;\ngc.setStroke(entry.getKey().getColor());\n\/\/TODO: Make this customizable\ngc.setLineWidth(2.0);\nfor(T value : entry.getValue()) {\nTX x = fnXValue.apply(value);\nTY y = fnYValue.apply(value);\n\/\/ Add rectViewport.getMinY() instead of subtracting because we're mirroring the Y coordinate around the X-axis.\nPoint2D ptNew = new Point2D(\nchartXFromDataX(axisX, x),\nchartYFromDataY(axisY, y));\nPoint<T, TX, TY> pt = new Point<>(\nvalue,\nx,\ny,\nptNew,\nentry.getKey().getColor()\n);\n\ndouble maxHeight = 0.0;\nfor(TX tickX : ticksX) {\n\/\/X-labels are displayed at a 30-degree incline.\n\/\/The approximate width of the rotated text is 0.87*{width}\n\/\/The distance from the top of the bounding to the origin from which text should be drawn is 0.5*{length} + 0.87*{height}\ntextForMeasuring.setText(fnFormatX.apply(tickX));\nfinal Bounds boundsText = textForMeasuring.getLayoutBounds();\nmaxHeight = Math.max(maxHeight, 0.5 * boundsText.getWidth() + 0.87 * boundsText.getHeight());\n\/\/TODO: Also check maxWidth against the amount by which this would underflow the X=0 line\n}\nfinal Rectangle2D sizeAxisLabel = new Rectangle2D(0.0, 0.0, maxWidth, maxHeight);\nif(getWidth() <= sizeAxisLabel.getWidth() || getHeight() <= sizeAxisLabel.getHeight()) {\nreturn;\n}\nrectChart = new Rectangle2D(sizeAxisLabel.getWidth() + pxTickLength, 0.0, getWidth() - sizeAxisLabel.getWidth() - pxTickLength, getHeight() - sizeAxisLabel.getHeight() - pxTickLength);\n\/\/ Render series data, build tooltip cache\nrenderedPoints.clear();\nfor(Map.Entry<Series, LinkedList<T>> entry : data.entrySet()) {\nPoint2D ptPrev = null;\ngc.setStroke(entry.getKey().getColor());\n\/\/TODO: Make this customizable\ngc.setLineWidth(2.0);\nfor(T value : entry.getValue()) {\nTX x = fnXValue.apply(value);\nTY y = fnYValue.apply(value);\n\/\/ Add rectViewport.getMinY() instead of subtracting because we're mirroring the Y coordinate around the X-axis.\nPoint2D ptNew = new Point2D(\nchartXFromDataX(axisX, x),\nchartYFromDataY(axisY, y));\nPoint<T, TX, TY> pt = new Point<>(\nvalue,\nx,\ny,\nptNew,\nentry.getKey().getColor()\n);\nrenderedPoints.add(pt);\nif(ptPrev != null) {\ngc.strokeLine(ptPrev.getX(), ptPrev.getY(), ptNew.getX(), ptNew.getY());\n}\ngc.strokeOval(ptNew.getX() - pointRadius, ptNew.getY() - pointRadius, pointRadius * 2, pointRadius * 2);\n\ntextForMeasuring.setText(fnFormatX.apply(tickX));\nfinal Bounds boundsText = textForMeasuring.getLayoutBounds();\nmaxHeight = Math.max(maxHeight, 0.5 * boundsText.getWidth() + 0.87 * boundsText.getHeight());\n\/\/TODO: Also check maxWidth against the amount by which this would underflow the X=0 line\n}\nfinal Rectangle2D sizeAxisLabel = new Rectangle2D(0.0, 0.0, maxWidth, maxHeight);\nif(getWidth() <= sizeAxisLabel.getWidth() || getHeight() <= sizeAxisLabel.getHeight()) {\nreturn;\n}\nrectChart = new Rectangle2D(sizeAxisLabel.getWidth() + pxTickLength, 0.0, getWidth() - sizeAxisLabel.getWidth() - pxTickLength, getHeight() - sizeAxisLabel.getHeight() - pxTickLength);\n\/\/ Render series data, build tooltip cache\nrenderedPoints.clear();\nfor(Map.Entry<Series, LinkedList<T>> entry : data.entrySet()) {\nPoint2D ptPrev = null;\ngc.setStroke(entry.getKey().getColor());\n\/\/TODO: Make this customizable\ngc.setLineWidth(2.0);\nfor(T value : entry.getValue()) {\nTX x = fnXValue.apply(value);\nTY y = fnYValue.apply(value);\n\/\/ Add rectViewport.getMinY() instead of subtracting because we're mirroring the Y coordinate around the X-axis.\nPoint2D ptNew = new Point2D(\nchartXFromDataX(axisX, x),\nchartYFromDataY(axisY, y));\nPoint<T, TX, TY> pt = new Point<>(\nvalue,\nx,\ny,\nptNew,\nentry.getKey().getColor()\n);\nrenderedPoints.add(pt);\nif(ptPrev != null) {\ngc.strokeLine(ptPrev.getX(), ptPrev.getY(), ptNew.getX(), ptNew.getY());\n}\ngc.strokeOval(ptNew.getX() - pointRadius, ptNew.getY() - pointRadius, pointRadius * 2, pointRadius * 2);\nptPrev = ptNew;\n}\n}\n\/\/ Render axes (last so it overwrites any values near an axis)\n\/\/Clear the axis area\n\nTY y = fnYValue.apply(value);\n\/\/ Add rectViewport.getMinY() instead of subtracting because we're mirroring the Y coordinate around the X-axis.\nPoint2D ptNew = new Point2D(\nchartXFromDataX(axisX, x),\nchartYFromDataY(axisY, y));\nPoint<T, TX, TY> pt = new Point<>(\nvalue,\nx,\ny,\nptNew,\nentry.getKey().getColor()\n);\nrenderedPoints.add(pt);\nif(ptPrev != null) {\ngc.strokeLine(ptPrev.getX(), ptPrev.getY(), ptNew.getX(), ptNew.getY());\n}\ngc.strokeOval(ptNew.getX() - pointRadius, ptNew.getY() - pointRadius, pointRadius * 2, pointRadius * 2);\nptPrev = ptNew;\n}\n}\n\/\/ Render axes (last so it overwrites any values near an axis)\n\/\/Clear the axis area\ngc.clearRect(0.0, 0.0, sizeAxisLabel.getWidth() + pxTickLength, getHeight());\ngc.clearRect(0.0, getHeight() - sizeAxisLabel.getHeight() - pxTickLength, getWidth(), sizeAxisLabel.getHeight());\n\/\/Draw the axes\ngc.setStroke(Color.BLACK);\ngc.setLineWidth(0.5);\ngc.strokeLine(rectChart.getMinX(), 0.0, rectChart.getMinX(), rectChart.getMaxY());\ngc.strokeLine(rectChart.getMinX(), rectChart.getMaxY(), rectChart.getMaxX(), rectChart.getMaxY());\nFont font = Font.font(\"MONOSPACE\", 12.0);\ngc.setFont(font);\n\/\/ticksX and ticksY are lists of the corresponding values; they need to be handed of to the corresponding fnNormalize and then scaled for display.\ndouble pxLast = -pxMinSpacingBetweenTicks;\nfor(TX tickX : ticksX) {\nfinal double pxX = chartXFromDataX(axisX, tickX);\nif(pxLast + pxMinSpacingBetweenTicks > pxX) {\ncontinue;\n}\npxLast = pxX;\ngc.strokeLine(pxX, rectChart.getMaxY(), pxX, rectChart.getMaxY() + pxTickLength);\nfinal String textLabel = fnFormatX.apply(tickX);\ntextForMeasuring.setText(textLabel);\n\nchartYFromDataY(axisY, y));\nPoint<T, TX, TY> pt = new Point<>(\nvalue,\nx,\ny,\nptNew,\nentry.getKey().getColor()\n);\nrenderedPoints.add(pt);\nif(ptPrev != null) {\ngc.strokeLine(ptPrev.getX(), ptPrev.getY(), ptNew.getX(), ptNew.getY());\n}\ngc.strokeOval(ptNew.getX() - pointRadius, ptNew.getY() - pointRadius, pointRadius * 2, pointRadius * 2);\nptPrev = ptNew;\n}\n}\n\/\/ Render axes (last so it overwrites any values near an axis)\n\/\/Clear the axis area\ngc.clearRect(0.0, 0.0, sizeAxisLabel.getWidth() + pxTickLength, getHeight());\ngc.clearRect(0.0, getHeight() - sizeAxisLabel.getHeight() - pxTickLength, getWidth(), sizeAxisLabel.getHeight());\n\/\/Draw the axes\ngc.setStroke(Color.BLACK);\ngc.setLineWidth(0.5);\ngc.strokeLine(rectChart.getMinX(), 0.0, rectChart.getMinX(), rectChart.getMaxY());\ngc.strokeLine(rectChart.getMinX(), rectChart.getMaxY(), rectChart.getMaxX(), rectChart.getMaxY());\nFont font = Font.font(\"MONOSPACE\", 12.0);\ngc.setFont(font);\n\/\/ticksX and ticksY are lists of the corresponding values; they need to be handed of to the corresponding fnNormalize and then scaled for display.\ndouble pxLast = -pxMinSpacingBetweenTicks;\nfor(TX tickX : ticksX) {\nfinal double pxX = chartXFromDataX(axisX, tickX);\nif(pxLast + pxMinSpacingBetweenTicks > pxX) {\ncontinue;\n}\npxLast = pxX;\ngc.strokeLine(pxX, rectChart.getMaxY(), pxX, rectChart.getMaxY() + pxTickLength);\nfinal String textLabel = fnFormatX.apply(tickX);\ntextForMeasuring.setText(textLabel);\nfinal Bounds boundsText = textForMeasuring.getLayoutBounds();\ndouble offsetY = 0.5 * boundsText.getWidth() + 0.87 * boundsText.getHeight();\ndouble offsetX = -0.87 * boundsText.getWidth();\n\n);\nrenderedPoints.add(pt);\nif(ptPrev != null) {\ngc.strokeLine(ptPrev.getX(), ptPrev.getY(), ptNew.getX(), ptNew.getY());\n}\ngc.strokeOval(ptNew.getX() - pointRadius, ptNew.getY() - pointRadius, pointRadius * 2, pointRadius * 2);\nptPrev = ptNew;\n}\n}\n\/\/ Render axes (last so it overwrites any values near an axis)\n\/\/Clear the axis area\ngc.clearRect(0.0, 0.0, sizeAxisLabel.getWidth() + pxTickLength, getHeight());\ngc.clearRect(0.0, getHeight() - sizeAxisLabel.getHeight() - pxTickLength, getWidth(), sizeAxisLabel.getHeight());\n\/\/Draw the axes\ngc.setStroke(Color.BLACK);\ngc.setLineWidth(0.5);\ngc.strokeLine(rectChart.getMinX(), 0.0, rectChart.getMinX(), rectChart.getMaxY());\ngc.strokeLine(rectChart.getMinX(), rectChart.getMaxY(), rectChart.getMaxX(), rectChart.getMaxY());\nFont font = Font.font(\"MONOSPACE\", 12.0);\ngc.setFont(font);\n\/\/ticksX and ticksY are lists of the corresponding values; they need to be handed of to the corresponding fnNormalize and then scaled for display.\ndouble pxLast = -pxMinSpacingBetweenTicks;\nfor(TX tickX : ticksX) {\nfinal double pxX = chartXFromDataX(axisX, tickX);\nif(pxLast + pxMinSpacingBetweenTicks > pxX) {\ncontinue;\n}\npxLast = pxX;\ngc.strokeLine(pxX, rectChart.getMaxY(), pxX, rectChart.getMaxY() + pxTickLength);\nfinal String textLabel = fnFormatX.apply(tickX);\ntextForMeasuring.setText(textLabel);\nfinal Bounds boundsText = textForMeasuring.getLayoutBounds();\ndouble offsetY = 0.5 * boundsText.getWidth() + 0.87 * boundsText.getHeight();\ndouble offsetX = -0.87 * boundsText.getWidth();\ngc.save();\n\/\/ Translate then rotate to rotate text around local origin rather than rotating around the canvas origin.\n\/\/ Rotating and drawing at an offset results in a rotation around the origin.\ngc.translate(pxX + offsetX, rectChart.getMaxY() + offsetY);\ngc.rotate(-30.0);\ngc.strokeText(textLabel, 0.0, 0.0);\ngc.restore();\n\ngc.setLineWidth(0.5);\ngc.strokeLine(rectChart.getMinX(), 0.0, rectChart.getMinX(), rectChart.getMaxY());\ngc.strokeLine(rectChart.getMinX(), rectChart.getMaxY(), rectChart.getMaxX(), rectChart.getMaxY());\nFont font = Font.font(\"MONOSPACE\", 12.0);\ngc.setFont(font);\n\/\/ticksX and ticksY are lists of the corresponding values; they need to be handed of to the corresponding fnNormalize and then scaled for display.\ndouble pxLast = -pxMinSpacingBetweenTicks;\nfor(TX tickX : ticksX) {\nfinal double pxX = chartXFromDataX(axisX, tickX);\nif(pxLast + pxMinSpacingBetweenTicks > pxX) {\ncontinue;\n}\npxLast = pxX;\ngc.strokeLine(pxX, rectChart.getMaxY(), pxX, rectChart.getMaxY() + pxTickLength);\nfinal String textLabel = fnFormatX.apply(tickX);\ntextForMeasuring.setText(textLabel);\nfinal Bounds boundsText = textForMeasuring.getLayoutBounds();\ndouble offsetY = 0.5 * boundsText.getWidth() + 0.87 * boundsText.getHeight();\ndouble offsetX = -0.87 * boundsText.getWidth();\ngc.save();\n\/\/ Translate then rotate to rotate text around local origin rather than rotating around the canvas origin.\n\/\/ Rotating and drawing at an offset results in a rotation around the origin.\ngc.translate(pxX + offsetX, rectChart.getMaxY() + offsetY);\ngc.rotate(-30.0);\ngc.strokeText(textLabel, 0.0, 0.0);\ngc.restore();\n}\nfor(TY tickY : ticksY) {\nfinal double pxY = chartYFromDataY(axisY, tickY);\ngc.strokeLine(rectChart.getMinX() - pxTickLength, pxY, rectChart.getMinX(), pxY);\nfinal String textLabel = fnFormatY.apply(tickY);\ntextForMeasuring.setText(textLabel);\ngc.strokeText(fnFormatY.apply(tickY), 0.0, pxY + textForMeasuring.getLayoutBounds().getHeight());\n}\n}","label":[1,1,0,0]}
{"id":12044,"original_code":"private void createView() {\n        FontIcon closeBtn = Controls.fontIcon(Material2AL.CLOSE, \"close-icon\");\n        closeBtn.setCursor(Cursor.HAND);\n        closeBtn.setOnMouseClicked(e -> close());\n        GridPane.setValignment(closeBtn, VPos.TOP);\n        GridPane.setHalignment(closeBtn, HPos.RIGHT);\n        TextFlow textFlow = Containers.create(TextFlow::new, \"text\");\n        \/\/ sadly setMaxHeight() isn't working with TextFlow\n        \/\/ so, we have to clip notification text manually\n        Text text = new Text(notification.getClippedText(Toast.MAX_MESSAGE_LEN));\n        textFlow.getChildren().addAll(text);\n        Hyperlink expandBtn = new Hyperlink(t(ACTION_MORE));\n        expandBtn.setOnAction(e -> expand());\n        if (expandHandler == null) { expandBtn.setManaged(false); }\n        add(textFlow, 0, 0);\n        add(closeBtn, 1, 0);\n        add(expandBtn, 0, 2, REMAINING, 1);\n        getColumnConstraints().addAll(HGROW_ALWAYS, HGROW_NEVER);\n        getRowConstraints().addAll(VGROW_ALWAYS, VGROW_NEVER);\n        VBox.setVgrow(this, Priority.NEVER);\n        getStyleClass().addAll(\"toast\", notification.getType().name().toLowerCase());\n    }","code":"private void createView() {\n        FontIcon closeBtn = Controls.fontIcon(Material2AL.CLOSE, \"close-icon\");\n        closeBtn.setCursor(Cursor.HAND);\n        closeBtn.setOnMouseClicked(e -> close());\n        GridPane.setValignment(closeBtn, VPos.TOP);\n        GridPane.setHalignment(closeBtn, HPos.RIGHT);\n        TextFlow textFlow = Containers.create(TextFlow::new, \"text\");\n       \n       \n        Text text = new Text(notification.getClippedText(Toast.MAX_MESSAGE_LEN));\n        textFlow.getChildren().addAll(text);\n        Hyperlink expandBtn = new Hyperlink(t(ACTION_MORE));\n        expandBtn.setOnAction(e -> expand());\n        if (expandHandler == null) { expandBtn.setManaged(false); }\n        add(textFlow, 0, 0);\n        add(closeBtn, 1, 0);\n        add(expandBtn, 0, 2, REMAINING, 1);\n        getColumnConstraints().addAll(HGROW_ALWAYS, HGROW_NEVER);\n        getRowConstraints().addAll(VGROW_ALWAYS, VGROW_NEVER);\n        VBox.setVgrow(this, Priority.NEVER);\n        getStyleClass().addAll(\"toast\", notification.getType().name().toLowerCase());\n    }","cleancode":"private void createview() { fonticon closebtn = controls.fonticon(material2al.close, \"close-icon\"); closebtn.setcursor(cursor.hand); closebtn.setonmouseclicked(e -> close()); gridpane.setvalignment(closebtn, vpos.top); gridpane.sethalignment(closebtn, hpos.right); textflow textflow = containers.create(textflow::new, \"text\"); text text = new text(notification.getclippedtext(toast.max_message_len)); textflow.getchildren().addall(text); hyperlink expandbtn = new hyperlink(t(action_more)); expandbtn.setonaction(e -> expand()); if (expandhandler == null) { expandbtn.setmanaged(false); } add(textflow, 0, 0); add(closebtn, 1, 0); add(expandbtn, 0, 2, remaining, 1); getcolumnconstraints().addall(hgrow_always, hgrow_never); getrowconstraints().addall(vgrow_always, vgrow_never); vbox.setvgrow(this, priority.never); getstyleclass().addall(\"toast\", notification.gettype().name().tolowercase()); }","comment":"\/\/ sadly setmaxheight() isn't working with textflow \/\/ so, we have to clip notification text manually","repo":"mkpaz\/telek","code_context_2":"GridPane.setHalignment(closeBtn, HPos.RIGHT);\nTextFlow textFlow = Containers.create(TextFlow::new, \"text\");\n\/\/ sadly setMaxHeight() isn't working with TextFlow\n\/\/ so, we have to clip notification text manually\nText text = new Text(notification.getClippedText(Toast.MAX_MESSAGE_LEN));\ntextFlow.getChildren().addAll(text);","code_context_10":"private void createView() {\nFontIcon closeBtn = Controls.fontIcon(Material2AL.CLOSE, \"close-icon\");\ncloseBtn.setCursor(Cursor.HAND);\ncloseBtn.setOnMouseClicked(e -> close());\nGridPane.setValignment(closeBtn, VPos.TOP);\nGridPane.setHalignment(closeBtn, HPos.RIGHT);\nTextFlow textFlow = Containers.create(TextFlow::new, \"text\");\n\/\/ sadly setMaxHeight() isn't working with TextFlow\n\/\/ so, we have to clip notification text manually\nText text = new Text(notification.getClippedText(Toast.MAX_MESSAGE_LEN));\ntextFlow.getChildren().addAll(text);\nHyperlink expandBtn = new Hyperlink(t(ACTION_MORE));\nexpandBtn.setOnAction(e -> expand());\nif (expandHandler == null) { expandBtn.setManaged(false); }\nadd(textFlow, 0, 0);\nadd(closeBtn, 1, 0);\nadd(expandBtn, 0, 2, REMAINING, 1);\ngetColumnConstraints().addAll(HGROW_ALWAYS, HGROW_NEVER);\ngetRowConstraints().addAll(VGROW_ALWAYS, VGROW_NEVER);","code_context_20":"private void createView() {\nFontIcon closeBtn = Controls.fontIcon(Material2AL.CLOSE, \"close-icon\");\ncloseBtn.setCursor(Cursor.HAND);\ncloseBtn.setOnMouseClicked(e -> close());\nGridPane.setValignment(closeBtn, VPos.TOP);\nGridPane.setHalignment(closeBtn, HPos.RIGHT);\nTextFlow textFlow = Containers.create(TextFlow::new, \"text\");\n\/\/ sadly setMaxHeight() isn't working with TextFlow\n\/\/ so, we have to clip notification text manually\nText text = new Text(notification.getClippedText(Toast.MAX_MESSAGE_LEN));\ntextFlow.getChildren().addAll(text);\nHyperlink expandBtn = new Hyperlink(t(ACTION_MORE));\nexpandBtn.setOnAction(e -> expand());\nif (expandHandler == null) { expandBtn.setManaged(false); }\nadd(textFlow, 0, 0);\nadd(closeBtn, 1, 0);\nadd(expandBtn, 0, 2, REMAINING, 1);\ngetColumnConstraints().addAll(HGROW_ALWAYS, HGROW_NEVER);\ngetRowConstraints().addAll(VGROW_ALWAYS, VGROW_NEVER);\nVBox.setVgrow(this, Priority.NEVER);\ngetStyleClass().addAll(\"toast\", notification.getType().name().toLowerCase());\n}","label":[0,0,0,0]}
{"id":12086,"original_code":"public static void main(String[] args) {\n        \/\/ TODO code application logic here\n        \/\/ cria o objeto Scanner\n        Scanner input = new Scanner(System.in);\n        \/\/ entrada de dados\n        System.out.print(\"Digite tr\u00eas n\u00fameros de ponto-flutuante: \");\n        double numero1 = input.nextDouble(); \/\/ primeiro n\u00famero\n        double numero2 = input.nextDouble(); \/\/ segundo n\u00famero\n        double numero3 = input.nextDouble(); \/\/ terceiro n\u00famero\n        \/\/ detremina o maior valor\n        double resultado = maiorValor( numero1, numero2, numero3 );\n        \/\/ imprime resultado\n        System.out.printf(\"O maior valor \u00e9 %.2f%n\", resultado );\n    }","code":"public static void main(String[] args) {\n       \n       \n        Scanner input = new Scanner(System.in);\n       \n        System.out.print(\"Digite tr\u00eas n\u00fameros de ponto-flutuante: \");\n        double numero1 = input.nextDouble();        double numero2 = input.nextDouble();        double numero3 = input.nextDouble();       \n        double resultado = maiorValor( numero1, numero2, numero3 );\n       \n        System.out.printf(\"O maior valor \u00e9 %.2f%n\", resultado );\n    }","cleancode":"public static void main(string[] args) { scanner input = new scanner(system.in); system.out.print(\"digite tr\u00eas n\u00fameros de ponto-flutuante: \"); double numero1 = input.nextdouble(); double numero2 = input.nextdouble(); double numero3 = input.nextdouble(); double resultado = maiorvalor( numero1, numero2, numero3 ); system.out.printf(\"o maior valor \u00e9 %.2f%n\", resultado ); }","comment":"\/\/ todo code application logic here \/\/ cria o objeto scanner\n\/\/ entrada de dados\n\/\/ primeiro n\u00famero\n\/\/ segundo n\u00famero\n\/\/ terceiro n\u00famero\n\/\/ detremina o maior valor\n\/\/ imprime resultado","repo":"pedro-filho-81\/LivrosDeJava","code_context_2":"public static void main(String[] args) {\n\/\/ TODO code application logic here\n\/\/ cria o objeto Scanner\nScanner input = new Scanner(System.in);\n\/\/ entrada de dados\n\n\/\/ cria o objeto Scanner\nScanner input = new Scanner(System.in);\n\/\/ entrada de dados\nSystem.out.print(\"Digite tr\u00eas n\u00fameros de ponto-flutuante: \");\ndouble numero1 = input.nextDouble(); \/\/ primeiro n\u00famero\n\n\/\/ entrada de dados\nSystem.out.print(\"Digite tr\u00eas n\u00fameros de ponto-flutuante: \");\ndouble numero1 = input.nextDouble(); \/\/ primeiro n\u00famero\ndouble numero2 = input.nextDouble(); \/\/ segundo n\u00famero\ndouble numero3 = input.nextDouble(); \/\/ terceiro n\u00famero\n\nSystem.out.print(\"Digite tr\u00eas n\u00fameros de ponto-flutuante: \");\ndouble numero1 = input.nextDouble(); \/\/ primeiro n\u00famero\ndouble numero2 = input.nextDouble(); \/\/ segundo n\u00famero\ndouble numero3 = input.nextDouble(); \/\/ terceiro n\u00famero\n\/\/ detremina o maior valor\n\ndouble numero1 = input.nextDouble(); \/\/ primeiro n\u00famero\ndouble numero2 = input.nextDouble(); \/\/ segundo n\u00famero\ndouble numero3 = input.nextDouble(); \/\/ terceiro n\u00famero\n\/\/ detremina o maior valor\ndouble resultado = maiorValor( numero1, numero2, numero3 );\n\ndouble numero2 = input.nextDouble(); \/\/ segundo n\u00famero\ndouble numero3 = input.nextDouble(); \/\/ terceiro n\u00famero\n\/\/ detremina o maior valor\ndouble resultado = maiorValor( numero1, numero2, numero3 );\n\/\/ imprime resultado\n\n\/\/ detremina o maior valor\ndouble resultado = maiorValor( numero1, numero2, numero3 );\n\/\/ imprime resultado\nSystem.out.printf(\"O maior valor \u00e9 %.2f%n\", resultado );\n}","code_context_10":"public static void main(String[] args) {\n\/\/ TODO code application logic here\n\/\/ cria o objeto Scanner\nScanner input = new Scanner(System.in);\n\/\/ entrada de dados\nSystem.out.print(\"Digite tr\u00eas n\u00fameros de ponto-flutuante: \");\ndouble numero1 = input.nextDouble(); \/\/ primeiro n\u00famero\ndouble numero2 = input.nextDouble(); \/\/ segundo n\u00famero\ndouble numero3 = input.nextDouble(); \/\/ terceiro n\u00famero\n\/\/ detremina o maior valor\ndouble resultado = maiorValor( numero1, numero2, numero3 );\n\/\/ imprime resultado\nSystem.out.printf(\"O maior valor \u00e9 %.2f%n\", resultado );\n\npublic static void main(String[] args) {\n\/\/ TODO code application logic here\n\/\/ cria o objeto Scanner\nScanner input = new Scanner(System.in);\n\/\/ entrada de dados\nSystem.out.print(\"Digite tr\u00eas n\u00fameros de ponto-flutuante: \");\ndouble numero1 = input.nextDouble(); \/\/ primeiro n\u00famero\ndouble numero2 = input.nextDouble(); \/\/ segundo n\u00famero\ndouble numero3 = input.nextDouble(); \/\/ terceiro n\u00famero\n\/\/ detremina o maior valor\ndouble resultado = maiorValor( numero1, numero2, numero3 );\n\/\/ imprime resultado\nSystem.out.printf(\"O maior valor \u00e9 %.2f%n\", resultado );\n}\n\npublic static void main(String[] args) {\n\/\/ TODO code application logic here\n\/\/ cria o objeto Scanner\nScanner input = new Scanner(System.in);\n\/\/ entrada de dados\nSystem.out.print(\"Digite tr\u00eas n\u00fameros de ponto-flutuante: \");\ndouble numero1 = input.nextDouble(); \/\/ primeiro n\u00famero\ndouble numero2 = input.nextDouble(); \/\/ segundo n\u00famero\ndouble numero3 = input.nextDouble(); \/\/ terceiro n\u00famero\n\/\/ detremina o maior valor\ndouble resultado = maiorValor( numero1, numero2, numero3 );\n\/\/ imprime resultado\nSystem.out.printf(\"O maior valor \u00e9 %.2f%n\", resultado );\n}\n\npublic static void main(String[] args) {\n\/\/ TODO code application logic here\n\/\/ cria o objeto Scanner\nScanner input = new Scanner(System.in);\n\/\/ entrada de dados\nSystem.out.print(\"Digite tr\u00eas n\u00fameros de ponto-flutuante: \");\ndouble numero1 = input.nextDouble(); \/\/ primeiro n\u00famero\ndouble numero2 = input.nextDouble(); \/\/ segundo n\u00famero\ndouble numero3 = input.nextDouble(); \/\/ terceiro n\u00famero\n\/\/ detremina o maior valor\ndouble resultado = maiorValor( numero1, numero2, numero3 );\n\/\/ imprime resultado\nSystem.out.printf(\"O maior valor \u00e9 %.2f%n\", resultado );\n}\n\npublic static void main(String[] args) {\n\/\/ TODO code application logic here\n\/\/ cria o objeto Scanner\nScanner input = new Scanner(System.in);\n\/\/ entrada de dados\nSystem.out.print(\"Digite tr\u00eas n\u00fameros de ponto-flutuante: \");\ndouble numero1 = input.nextDouble(); \/\/ primeiro n\u00famero\ndouble numero2 = input.nextDouble(); \/\/ segundo n\u00famero\ndouble numero3 = input.nextDouble(); \/\/ terceiro n\u00famero\n\/\/ detremina o maior valor\ndouble resultado = maiorValor( numero1, numero2, numero3 );\n\/\/ imprime resultado\nSystem.out.printf(\"O maior valor \u00e9 %.2f%n\", resultado );\n}\n\npublic static void main(String[] args) {\n\/\/ TODO code application logic here\n\/\/ cria o objeto Scanner\nScanner input = new Scanner(System.in);\n\/\/ entrada de dados\nSystem.out.print(\"Digite tr\u00eas n\u00fameros de ponto-flutuante: \");\ndouble numero1 = input.nextDouble(); \/\/ primeiro n\u00famero\ndouble numero2 = input.nextDouble(); \/\/ segundo n\u00famero\ndouble numero3 = input.nextDouble(); \/\/ terceiro n\u00famero\n\/\/ detremina o maior valor\ndouble resultado = maiorValor( numero1, numero2, numero3 );\n\/\/ imprime resultado\nSystem.out.printf(\"O maior valor \u00e9 %.2f%n\", resultado );\n}\n\n\/\/ TODO code application logic here\n\/\/ cria o objeto Scanner\nScanner input = new Scanner(System.in);\n\/\/ entrada de dados\nSystem.out.print(\"Digite tr\u00eas n\u00fameros de ponto-flutuante: \");\ndouble numero1 = input.nextDouble(); \/\/ primeiro n\u00famero\ndouble numero2 = input.nextDouble(); \/\/ segundo n\u00famero\ndouble numero3 = input.nextDouble(); \/\/ terceiro n\u00famero\n\/\/ detremina o maior valor\ndouble resultado = maiorValor( numero1, numero2, numero3 );\n\/\/ imprime resultado\nSystem.out.printf(\"O maior valor \u00e9 %.2f%n\", resultado );\n}","code_context_20":"public static void main(String[] args) {\n\/\/ TODO code application logic here\n\/\/ cria o objeto Scanner\nScanner input = new Scanner(System.in);\n\/\/ entrada de dados\nSystem.out.print(\"Digite tr\u00eas n\u00fameros de ponto-flutuante: \");\ndouble numero1 = input.nextDouble(); \/\/ primeiro n\u00famero\ndouble numero2 = input.nextDouble(); \/\/ segundo n\u00famero\ndouble numero3 = input.nextDouble(); \/\/ terceiro n\u00famero\n\/\/ detremina o maior valor\ndouble resultado = maiorValor( numero1, numero2, numero3 );\n\/\/ imprime resultado\nSystem.out.printf(\"O maior valor \u00e9 %.2f%n\", resultado );\n}\n\npublic static void main(String[] args) {\n\/\/ TODO code application logic here\n\/\/ cria o objeto Scanner\nScanner input = new Scanner(System.in);\n\/\/ entrada de dados\nSystem.out.print(\"Digite tr\u00eas n\u00fameros de ponto-flutuante: \");\ndouble numero1 = input.nextDouble(); \/\/ primeiro n\u00famero\ndouble numero2 = input.nextDouble(); \/\/ segundo n\u00famero\ndouble numero3 = input.nextDouble(); \/\/ terceiro n\u00famero\n\/\/ detremina o maior valor\ndouble resultado = maiorValor( numero1, numero2, numero3 );\n\/\/ imprime resultado\nSystem.out.printf(\"O maior valor \u00e9 %.2f%n\", resultado );\n}\n\npublic static void main(String[] args) {\n\/\/ TODO code application logic here\n\/\/ cria o objeto Scanner\nScanner input = new Scanner(System.in);\n\/\/ entrada de dados\nSystem.out.print(\"Digite tr\u00eas n\u00fameros de ponto-flutuante: \");\ndouble numero1 = input.nextDouble(); \/\/ primeiro n\u00famero\ndouble numero2 = input.nextDouble(); \/\/ segundo n\u00famero\ndouble numero3 = input.nextDouble(); \/\/ terceiro n\u00famero\n\/\/ detremina o maior valor\ndouble resultado = maiorValor( numero1, numero2, numero3 );\n\/\/ imprime resultado\nSystem.out.printf(\"O maior valor \u00e9 %.2f%n\", resultado );\n}\n\npublic static void main(String[] args) {\n\/\/ TODO code application logic here\n\/\/ cria o objeto Scanner\nScanner input = new Scanner(System.in);\n\/\/ entrada de dados\nSystem.out.print(\"Digite tr\u00eas n\u00fameros de ponto-flutuante: \");\ndouble numero1 = input.nextDouble(); \/\/ primeiro n\u00famero\ndouble numero2 = input.nextDouble(); \/\/ segundo n\u00famero\ndouble numero3 = input.nextDouble(); \/\/ terceiro n\u00famero\n\/\/ detremina o maior valor\ndouble resultado = maiorValor( numero1, numero2, numero3 );\n\/\/ imprime resultado\nSystem.out.printf(\"O maior valor \u00e9 %.2f%n\", resultado );\n}\n\npublic static void main(String[] args) {\n\/\/ TODO code application logic here\n\/\/ cria o objeto Scanner\nScanner input = new Scanner(System.in);\n\/\/ entrada de dados\nSystem.out.print(\"Digite tr\u00eas n\u00fameros de ponto-flutuante: \");\ndouble numero1 = input.nextDouble(); \/\/ primeiro n\u00famero\ndouble numero2 = input.nextDouble(); \/\/ segundo n\u00famero\ndouble numero3 = input.nextDouble(); \/\/ terceiro n\u00famero\n\/\/ detremina o maior valor\ndouble resultado = maiorValor( numero1, numero2, numero3 );\n\/\/ imprime resultado\nSystem.out.printf(\"O maior valor \u00e9 %.2f%n\", resultado );\n}\n\npublic static void main(String[] args) {\n\/\/ TODO code application logic here\n\/\/ cria o objeto Scanner\nScanner input = new Scanner(System.in);\n\/\/ entrada de dados\nSystem.out.print(\"Digite tr\u00eas n\u00fameros de ponto-flutuante: \");\ndouble numero1 = input.nextDouble(); \/\/ primeiro n\u00famero\ndouble numero2 = input.nextDouble(); \/\/ segundo n\u00famero\ndouble numero3 = input.nextDouble(); \/\/ terceiro n\u00famero\n\/\/ detremina o maior valor\ndouble resultado = maiorValor( numero1, numero2, numero3 );\n\/\/ imprime resultado\nSystem.out.printf(\"O maior valor \u00e9 %.2f%n\", resultado );\n}\n\npublic static void main(String[] args) {\n\/\/ TODO code application logic here\n\/\/ cria o objeto Scanner\nScanner input = new Scanner(System.in);\n\/\/ entrada de dados\nSystem.out.print(\"Digite tr\u00eas n\u00fameros de ponto-flutuante: \");\ndouble numero1 = input.nextDouble(); \/\/ primeiro n\u00famero\ndouble numero2 = input.nextDouble(); \/\/ segundo n\u00famero\ndouble numero3 = input.nextDouble(); \/\/ terceiro n\u00famero\n\/\/ detremina o maior valor\ndouble resultado = maiorValor( numero1, numero2, numero3 );\n\/\/ imprime resultado\nSystem.out.printf(\"O maior valor \u00e9 %.2f%n\", resultado );\n}","label":[0,1,0,0]}
{"id":20687,"original_code":"@Test\n    public void fetchExistingAggregateById_populatesValues()\n    {\n        try(PhotonTransaction transaction = photon.beginTransaction())\n        {\n            PhotonTestTable photonTestTable = transaction.query(PhotonTestTable.class).fetchById(1);\n            \/\/ The database does not store a time zone, so we assume the date is in the system's time zone. But to make these tests\n            \/\/ compare epoch times but still work with any system time zone, we have to offset the epoch to the system's time zone.\n            int currentUtcOffset = TimeZone.getDefault().getOffset(new Date().getTime());\n            assertNotNull(photonTestTable);\n            assertEquals(1, photonTestTable.getId());\n            assertEquals(UUID.fromString(\"8ED1E1BD-253E-4469-B4CB-71E1217825B7\"), photonTestTable.getUuidColumn());\n            assertEquals(ZonedDateTime.ofInstant(Instant.ofEpochMilli(1489915698000L - currentUtcOffset), ZoneId.systemDefault()), photonTestTable.getDateColumn());\n            assertEquals(\"Test String\", photonTestTable.getVarcharColumn());\n        }\n    }","code":"@Test\n    public void fetchExistingAggregateById_populatesValues()\n    {\n        try(PhotonTransaction transaction = photon.beginTransaction())\n        {\n            PhotonTestTable photonTestTable = transaction.query(PhotonTestTable.class).fetchById(1);\n           \n           \n            int currentUtcOffset = TimeZone.getDefault().getOffset(new Date().getTime());\n            assertNotNull(photonTestTable);\n            assertEquals(1, photonTestTable.getId());\n            assertEquals(UUID.fromString(\"8ED1E1BD-253E-4469-B4CB-71E1217825B7\"), photonTestTable.getUuidColumn());\n            assertEquals(ZonedDateTime.ofInstant(Instant.ofEpochMilli(1489915698000L - currentUtcOffset), ZoneId.systemDefault()), photonTestTable.getDateColumn());\n            assertEquals(\"Test String\", photonTestTable.getVarcharColumn());\n        }\n    }","cleancode":"@test public void fetchexistingaggregatebyid_populatesvalues() { try(photontransaction transaction = photon.begintransaction()) { photontesttable photontesttable = transaction.query(photontesttable.class).fetchbyid(1); int currentutcoffset = timezone.getdefault().getoffset(new date().gettime()); assertnotnull(photontesttable); assertequals(1, photontesttable.getid()); assertequals(uuid.fromstring(\"8ed1e1bd-253e-4469-b4cb-71e1217825b7\"), photontesttable.getuuidcolumn()); assertequals(zoneddatetime.ofinstant(instant.ofepochmilli(1489915698000l - currentutcoffset), zoneid.systemdefault()), photontesttable.getdatecolumn()); assertequals(\"test string\", photontesttable.getvarcharcolumn()); } }","comment":"\/\/ todo: this test fails if run during standard time instead of dst. the time is off by one hour.\n\/\/ the database does not store a time zone, so we assume the date is in the system's time zone. but to make these tests \/\/ compare epoch times but still work with any system time zone, we have to offset the epoch to the system's time zone.","repo":"molcikas\/photon","code_context_2":"@Test\npublic void fetchExistingAggregateById_populatesValues()\n{\ntry(PhotonTransaction transaction = photon.beginTransaction())\n{\nPhotonTestTable photonTestTable = transaction.query(PhotonTestTable.class).fetchById(1);\n\/\/ The database does not store a time zone, so we assume the date is in the system's time zone. But to make these tests\n\/\/ compare epoch times but still work with any system time zone, we have to offset the epoch to the system's time zone.\nint currentUtcOffset = TimeZone.getDefault().getOffset(new Date().getTime());\nassertNotNull(photonTestTable);\nassertEquals(1, photonTestTable.getId());\nassertEquals(UUID.fromString(\"8ED1E1BD-253E-4469-B4CB-71E1217825B7\"), photonTestTable.getUuidColumn());\nassertEquals(ZonedDateTime.ofInstant(Instant.ofEpochMilli(1489915698000L - currentUtcOffset), ZoneId.systemDefault()), photonTestTable.getDateColumn());\nassertEquals(\"Test String\", photonTestTable.getVarcharColumn());\n}\n}\n\n{\nPhotonTestTable photonTestTable = transaction.query(PhotonTestTable.class).fetchById(1);\n\/\/ The database does not store a time zone, so we assume the date is in the system's time zone. But to make these tests\n\/\/ compare epoch times but still work with any system time zone, we have to offset the epoch to the system's time zone.\nint currentUtcOffset = TimeZone.getDefault().getOffset(new Date().getTime());\nassertNotNull(photonTestTable);","code_context_10":"@Test\npublic void fetchExistingAggregateById_populatesValues()\n{\ntry(PhotonTransaction transaction = photon.beginTransaction())\n{\nPhotonTestTable photonTestTable = transaction.query(PhotonTestTable.class).fetchById(1);\n\/\/ The database does not store a time zone, so we assume the date is in the system's time zone. But to make these tests\n\/\/ compare epoch times but still work with any system time zone, we have to offset the epoch to the system's time zone.\nint currentUtcOffset = TimeZone.getDefault().getOffset(new Date().getTime());\nassertNotNull(photonTestTable);\nassertEquals(1, photonTestTable.getId());\nassertEquals(UUID.fromString(\"8ED1E1BD-253E-4469-B4CB-71E1217825B7\"), photonTestTable.getUuidColumn());\nassertEquals(ZonedDateTime.ofInstant(Instant.ofEpochMilli(1489915698000L - currentUtcOffset), ZoneId.systemDefault()), photonTestTable.getDateColumn());\nassertEquals(\"Test String\", photonTestTable.getVarcharColumn());\n}\n}\n\n@Test\npublic void fetchExistingAggregateById_populatesValues()\n{\ntry(PhotonTransaction transaction = photon.beginTransaction())\n{\nPhotonTestTable photonTestTable = transaction.query(PhotonTestTable.class).fetchById(1);\n\/\/ The database does not store a time zone, so we assume the date is in the system's time zone. But to make these tests\n\/\/ compare epoch times but still work with any system time zone, we have to offset the epoch to the system's time zone.\nint currentUtcOffset = TimeZone.getDefault().getOffset(new Date().getTime());\nassertNotNull(photonTestTable);\nassertEquals(1, photonTestTable.getId());\nassertEquals(UUID.fromString(\"8ED1E1BD-253E-4469-B4CB-71E1217825B7\"), photonTestTable.getUuidColumn());\nassertEquals(ZonedDateTime.ofInstant(Instant.ofEpochMilli(1489915698000L - currentUtcOffset), ZoneId.systemDefault()), photonTestTable.getDateColumn());\nassertEquals(\"Test String\", photonTestTable.getVarcharColumn());\n}\n}","code_context_20":"@Test\npublic void fetchExistingAggregateById_populatesValues()\n{\ntry(PhotonTransaction transaction = photon.beginTransaction())\n{\nPhotonTestTable photonTestTable = transaction.query(PhotonTestTable.class).fetchById(1);\n\/\/ The database does not store a time zone, so we assume the date is in the system's time zone. But to make these tests\n\/\/ compare epoch times but still work with any system time zone, we have to offset the epoch to the system's time zone.\nint currentUtcOffset = TimeZone.getDefault().getOffset(new Date().getTime());\nassertNotNull(photonTestTable);\nassertEquals(1, photonTestTable.getId());\nassertEquals(UUID.fromString(\"8ED1E1BD-253E-4469-B4CB-71E1217825B7\"), photonTestTable.getUuidColumn());\nassertEquals(ZonedDateTime.ofInstant(Instant.ofEpochMilli(1489915698000L - currentUtcOffset), ZoneId.systemDefault()), photonTestTable.getDateColumn());\nassertEquals(\"Test String\", photonTestTable.getVarcharColumn());\n}\n}\n\n@Test\npublic void fetchExistingAggregateById_populatesValues()\n{\ntry(PhotonTransaction transaction = photon.beginTransaction())\n{\nPhotonTestTable photonTestTable = transaction.query(PhotonTestTable.class).fetchById(1);\n\/\/ The database does not store a time zone, so we assume the date is in the system's time zone. But to make these tests\n\/\/ compare epoch times but still work with any system time zone, we have to offset the epoch to the system's time zone.\nint currentUtcOffset = TimeZone.getDefault().getOffset(new Date().getTime());\nassertNotNull(photonTestTable);\nassertEquals(1, photonTestTable.getId());\nassertEquals(UUID.fromString(\"8ED1E1BD-253E-4469-B4CB-71E1217825B7\"), photonTestTable.getUuidColumn());\nassertEquals(ZonedDateTime.ofInstant(Instant.ofEpochMilli(1489915698000L - currentUtcOffset), ZoneId.systemDefault()), photonTestTable.getDateColumn());\nassertEquals(\"Test String\", photonTestTable.getVarcharColumn());\n}\n}","label":[0,0,1,0]}
{"id":12596,"original_code":"public static BufferedImage boofCVBinarization(BufferedImage image, int threshold) {\n\t\tGrayU8 input8 = ConvertBufferedImage.convertFrom(image,(GrayU8)null);\n\t\tGrayF32 input32 = ConvertBufferedImage.convertFromSingle(image, null, GrayF32.class);\n\t\tGrayU8 binary8 = new GrayU8(input8.getWidth(), input8.getHeight());\n\/\/\t\tGrayF32 binary32 = new GrayF32(input8.getWidth(), input8.getHeight());\n\t\tboolean down = false;\n\t\tThresholdImageOps.threshold(input8, binary8, threshold, down);\n\/\/\t\tGThresholdImageOps.threshold(input32, binary8, threshold, down);\n\t\tBufferedImage outputImage = null;\n\/\/\t\toutputImage =\tConvertBufferedImage.convertTo(binary8, null);\n\t\tboolean invert = false;\n\t\toutputImage = VisualizeBinaryData.renderBinary(binary8, invert, null);\n\t\t\/\/ \n\/\/\t\toutputImage = ImageUtil.removeAlpha(outputImage);\n\/\/\t\toutputImage = ImageUtil.convertRGB(outputImage, \n\/\/\t\t\t\tnew int[] {0x0d0d0d}, new int[] {0xffffff});\n\t\treturn outputImage;\n\t}","code":"public static BufferedImage boofCVBinarization(BufferedImage image, int threshold) {\n\t\tGrayU8 input8 = ConvertBufferedImage.convertFrom(image,(GrayU8)null);\n\t\tGrayF32 input32 = ConvertBufferedImage.convertFromSingle(image, null, GrayF32.class);\n\t\tGrayU8 binary8 = new GrayU8(input8.getWidth(), input8.getHeight());\n\t\tboolean down = false;\n\t\tThresholdImageOps.threshold(input8, binary8, threshold, down);\n\t\tBufferedImage outputImage = null;\n\t\tboolean invert = false;\n\t\toutputImage = VisualizeBinaryData.renderBinary(binary8, invert, null);\n\t\n\t\treturn outputImage;\n\t}","cleancode":"public static bufferedimage boofcvbinarization(bufferedimage image, int threshold) { grayu8 input8 = convertbufferedimage.convertfrom(image,(grayu8)null); grayf32 input32 = convertbufferedimage.convertfromsingle(image, null, grayf32.class); grayu8 binary8 = new grayu8(input8.getwidth(), input8.getheight()); boolean down = false; thresholdimageops.threshold(input8, binary8, threshold, down); bufferedimage outputimage = null; boolean invert = false; outputimage = visualizebinarydata.renderbinary(binary8, invert, null); return outputimage; }","comment":"\/** this does not get the correct result and rerquires a kludge which could fail anytime * * @param image * @param threshold * @return *\/\n\/\/ grayf32 binary32 = new grayf32(input8.getwidth(), input8.getheight());\n\/\/ gthresholdimageops.threshold(input32, binary8, threshold, down);\n\/\/ outputimage = convertbufferedimage.convertto(binary8, null);\n\/\/ \/\/ outputimage = imageutil.removealpha(outputimage); \/\/ outputimage = imageutil.convertrgb(outputimage, \/\/ new int[] {0x0d0d0d}, new int[] {0xffffff});","repo":"nuest\/ami3","code_context_2":"public static BufferedImage boofCVBinarization(BufferedImage image, int threshold) {\nGrayU8 input8 = ConvertBufferedImage.convertFrom(image,(GrayU8)null);\nGrayF32 input32 = ConvertBufferedImage.convertFromSingle(image, null, GrayF32.class);\nGrayU8 binary8 = new GrayU8(input8.getWidth(), input8.getHeight());\n\/\/ GrayF32 binary32 = new GrayF32(input8.getWidth(), input8.getHeight());\nboolean down = false;\nThresholdImageOps.threshold(input8, binary8, threshold, down);\n\/\/ GThresholdImageOps.threshold(input32, binary8, threshold, down);\nBufferedImage outputImage = null;\n\/\/ outputImage = ConvertBufferedImage.convertTo(binary8, null);\nboolean invert = false;\noutputImage = VisualizeBinaryData.renderBinary(binary8, invert, null);\n\/\/\n\/\/ outputImage = ImageUtil.removeAlpha(outputImage);\n\/\/ outputImage = ImageUtil.convertRGB(outputImage,\n\/\/ new int[] {0x0d0d0d}, new int[] {0xffffff});\nreturn outputImage;\n}\n\nGrayF32 input32 = ConvertBufferedImage.convertFromSingle(image, null, GrayF32.class);\nGrayU8 binary8 = new GrayU8(input8.getWidth(), input8.getHeight());\n\/\/ GrayF32 binary32 = new GrayF32(input8.getWidth(), input8.getHeight());\nboolean down = false;\nThresholdImageOps.threshold(input8, binary8, threshold, down);\n\nboolean down = false;\nThresholdImageOps.threshold(input8, binary8, threshold, down);\n\/\/ GThresholdImageOps.threshold(input32, binary8, threshold, down);\nBufferedImage outputImage = null;\n\/\/ outputImage = ConvertBufferedImage.convertTo(binary8, null);\n\n\/\/ GThresholdImageOps.threshold(input32, binary8, threshold, down);\nBufferedImage outputImage = null;\n\/\/ outputImage = ConvertBufferedImage.convertTo(binary8, null);\nboolean invert = false;\noutputImage = VisualizeBinaryData.renderBinary(binary8, invert, null);\n\nGrayF32 input32 = ConvertBufferedImage.convertFromSingle(image, null, GrayF32.class);\nGrayU8 binary8 = new GrayU8(input8.getWidth(), input8.getHeight());\n\/\/ GrayF32 binary32 = new GrayF32(input8.getWidth(), input8.getHeight());\nboolean down = false;\nThresholdImageOps.threshold(input8, binary8, threshold, down);\n\/\/ GThresholdImageOps.threshold(input32, binary8, threshold, down);\nBufferedImage outputImage = null;\n\/\/ outputImage = ConvertBufferedImage.convertTo(binary8, null);","code_context_10":"public static BufferedImage boofCVBinarization(BufferedImage image, int threshold) {\nGrayU8 input8 = ConvertBufferedImage.convertFrom(image,(GrayU8)null);\nGrayF32 input32 = ConvertBufferedImage.convertFromSingle(image, null, GrayF32.class);\nGrayU8 binary8 = new GrayU8(input8.getWidth(), input8.getHeight());\n\/\/ GrayF32 binary32 = new GrayF32(input8.getWidth(), input8.getHeight());\nboolean down = false;\nThresholdImageOps.threshold(input8, binary8, threshold, down);\n\/\/ GThresholdImageOps.threshold(input32, binary8, threshold, down);\nBufferedImage outputImage = null;\n\/\/ outputImage = ConvertBufferedImage.convertTo(binary8, null);\nboolean invert = false;\noutputImage = VisualizeBinaryData.renderBinary(binary8, invert, null);\n\/\/\n\/\/ outputImage = ImageUtil.removeAlpha(outputImage);\n\/\/ outputImage = ImageUtil.convertRGB(outputImage,\n\/\/ new int[] {0x0d0d0d}, new int[] {0xffffff});\nreturn outputImage;\n}\n\npublic static BufferedImage boofCVBinarization(BufferedImage image, int threshold) {\nGrayU8 input8 = ConvertBufferedImage.convertFrom(image,(GrayU8)null);\nGrayF32 input32 = ConvertBufferedImage.convertFromSingle(image, null, GrayF32.class);\nGrayU8 binary8 = new GrayU8(input8.getWidth(), input8.getHeight());\n\/\/ GrayF32 binary32 = new GrayF32(input8.getWidth(), input8.getHeight());\nboolean down = false;\nThresholdImageOps.threshold(input8, binary8, threshold, down);\n\/\/ GThresholdImageOps.threshold(input32, binary8, threshold, down);\nBufferedImage outputImage = null;\n\/\/ outputImage = ConvertBufferedImage.convertTo(binary8, null);\nboolean invert = false;\noutputImage = VisualizeBinaryData.renderBinary(binary8, invert, null);\n\/\/\n\/\/ outputImage = ImageUtil.removeAlpha(outputImage);\n\/\/ outputImage = ImageUtil.convertRGB(outputImage,\n\npublic static BufferedImage boofCVBinarization(BufferedImage image, int threshold) {\nGrayU8 input8 = ConvertBufferedImage.convertFrom(image,(GrayU8)null);\nGrayF32 input32 = ConvertBufferedImage.convertFromSingle(image, null, GrayF32.class);\nGrayU8 binary8 = new GrayU8(input8.getWidth(), input8.getHeight());\n\/\/ GrayF32 binary32 = new GrayF32(input8.getWidth(), input8.getHeight());\nboolean down = false;\nThresholdImageOps.threshold(input8, binary8, threshold, down);\n\/\/ GThresholdImageOps.threshold(input32, binary8, threshold, down);\nBufferedImage outputImage = null;\n\/\/ outputImage = ConvertBufferedImage.convertTo(binary8, null);\nboolean invert = false;\noutputImage = VisualizeBinaryData.renderBinary(binary8, invert, null);\n\/\/\n\/\/ outputImage = ImageUtil.removeAlpha(outputImage);\n\/\/ outputImage = ImageUtil.convertRGB(outputImage,\n\/\/ new int[] {0x0d0d0d}, new int[] {0xffffff});\nreturn outputImage;\n}\n\npublic static BufferedImage boofCVBinarization(BufferedImage image, int threshold) {\nGrayU8 input8 = ConvertBufferedImage.convertFrom(image,(GrayU8)null);\nGrayF32 input32 = ConvertBufferedImage.convertFromSingle(image, null, GrayF32.class);\nGrayU8 binary8 = new GrayU8(input8.getWidth(), input8.getHeight());\n\/\/ GrayF32 binary32 = new GrayF32(input8.getWidth(), input8.getHeight());\nboolean down = false;\nThresholdImageOps.threshold(input8, binary8, threshold, down);\n\/\/ GThresholdImageOps.threshold(input32, binary8, threshold, down);\nBufferedImage outputImage = null;\n\/\/ outputImage = ConvertBufferedImage.convertTo(binary8, null);\nboolean invert = false;\noutputImage = VisualizeBinaryData.renderBinary(binary8, invert, null);\n\/\/\n\/\/ outputImage = ImageUtil.removeAlpha(outputImage);\n\/\/ outputImage = ImageUtil.convertRGB(outputImage,\n\/\/ new int[] {0x0d0d0d}, new int[] {0xffffff});\nreturn outputImage;\n}\n\npublic static BufferedImage boofCVBinarization(BufferedImage image, int threshold) {\nGrayU8 input8 = ConvertBufferedImage.convertFrom(image,(GrayU8)null);\nGrayF32 input32 = ConvertBufferedImage.convertFromSingle(image, null, GrayF32.class);\nGrayU8 binary8 = new GrayU8(input8.getWidth(), input8.getHeight());\n\/\/ GrayF32 binary32 = new GrayF32(input8.getWidth(), input8.getHeight());\nboolean down = false;\nThresholdImageOps.threshold(input8, binary8, threshold, down);\n\/\/ GThresholdImageOps.threshold(input32, binary8, threshold, down);\nBufferedImage outputImage = null;\n\/\/ outputImage = ConvertBufferedImage.convertTo(binary8, null);\nboolean invert = false;\noutputImage = VisualizeBinaryData.renderBinary(binary8, invert, null);\n\/\/\n\/\/ outputImage = ImageUtil.removeAlpha(outputImage);\n\/\/ outputImage = ImageUtil.convertRGB(outputImage,\n\/\/ new int[] {0x0d0d0d}, new int[] {0xffffff});\nreturn outputImage;\n}","code_context_20":"public static BufferedImage boofCVBinarization(BufferedImage image, int threshold) {\nGrayU8 input8 = ConvertBufferedImage.convertFrom(image,(GrayU8)null);\nGrayF32 input32 = ConvertBufferedImage.convertFromSingle(image, null, GrayF32.class);\nGrayU8 binary8 = new GrayU8(input8.getWidth(), input8.getHeight());\n\/\/ GrayF32 binary32 = new GrayF32(input8.getWidth(), input8.getHeight());\nboolean down = false;\nThresholdImageOps.threshold(input8, binary8, threshold, down);\n\/\/ GThresholdImageOps.threshold(input32, binary8, threshold, down);\nBufferedImage outputImage = null;\n\/\/ outputImage = ConvertBufferedImage.convertTo(binary8, null);\nboolean invert = false;\noutputImage = VisualizeBinaryData.renderBinary(binary8, invert, null);\n\/\/\n\/\/ outputImage = ImageUtil.removeAlpha(outputImage);\n\/\/ outputImage = ImageUtil.convertRGB(outputImage,\n\/\/ new int[] {0x0d0d0d}, new int[] {0xffffff});\nreturn outputImage;\n}\n\npublic static BufferedImage boofCVBinarization(BufferedImage image, int threshold) {\nGrayU8 input8 = ConvertBufferedImage.convertFrom(image,(GrayU8)null);\nGrayF32 input32 = ConvertBufferedImage.convertFromSingle(image, null, GrayF32.class);\nGrayU8 binary8 = new GrayU8(input8.getWidth(), input8.getHeight());\n\/\/ GrayF32 binary32 = new GrayF32(input8.getWidth(), input8.getHeight());\nboolean down = false;\nThresholdImageOps.threshold(input8, binary8, threshold, down);\n\/\/ GThresholdImageOps.threshold(input32, binary8, threshold, down);\nBufferedImage outputImage = null;\n\/\/ outputImage = ConvertBufferedImage.convertTo(binary8, null);\nboolean invert = false;\noutputImage = VisualizeBinaryData.renderBinary(binary8, invert, null);\n\/\/\n\/\/ outputImage = ImageUtil.removeAlpha(outputImage);\n\/\/ outputImage = ImageUtil.convertRGB(outputImage,\n\/\/ new int[] {0x0d0d0d}, new int[] {0xffffff});\nreturn outputImage;\n}\n\npublic static BufferedImage boofCVBinarization(BufferedImage image, int threshold) {\nGrayU8 input8 = ConvertBufferedImage.convertFrom(image,(GrayU8)null);\nGrayF32 input32 = ConvertBufferedImage.convertFromSingle(image, null, GrayF32.class);\nGrayU8 binary8 = new GrayU8(input8.getWidth(), input8.getHeight());\n\/\/ GrayF32 binary32 = new GrayF32(input8.getWidth(), input8.getHeight());\nboolean down = false;\nThresholdImageOps.threshold(input8, binary8, threshold, down);\n\/\/ GThresholdImageOps.threshold(input32, binary8, threshold, down);\nBufferedImage outputImage = null;\n\/\/ outputImage = ConvertBufferedImage.convertTo(binary8, null);\nboolean invert = false;\noutputImage = VisualizeBinaryData.renderBinary(binary8, invert, null);\n\/\/\n\/\/ outputImage = ImageUtil.removeAlpha(outputImage);\n\/\/ outputImage = ImageUtil.convertRGB(outputImage,\n\/\/ new int[] {0x0d0d0d}, new int[] {0xffffff});\nreturn outputImage;\n}\n\npublic static BufferedImage boofCVBinarization(BufferedImage image, int threshold) {\nGrayU8 input8 = ConvertBufferedImage.convertFrom(image,(GrayU8)null);\nGrayF32 input32 = ConvertBufferedImage.convertFromSingle(image, null, GrayF32.class);\nGrayU8 binary8 = new GrayU8(input8.getWidth(), input8.getHeight());\n\/\/ GrayF32 binary32 = new GrayF32(input8.getWidth(), input8.getHeight());\nboolean down = false;\nThresholdImageOps.threshold(input8, binary8, threshold, down);\n\/\/ GThresholdImageOps.threshold(input32, binary8, threshold, down);\nBufferedImage outputImage = null;\n\/\/ outputImage = ConvertBufferedImage.convertTo(binary8, null);\nboolean invert = false;\noutputImage = VisualizeBinaryData.renderBinary(binary8, invert, null);\n\/\/\n\/\/ outputImage = ImageUtil.removeAlpha(outputImage);\n\/\/ outputImage = ImageUtil.convertRGB(outputImage,\n\/\/ new int[] {0x0d0d0d}, new int[] {0xffffff});\nreturn outputImage;\n}\n\npublic static BufferedImage boofCVBinarization(BufferedImage image, int threshold) {\nGrayU8 input8 = ConvertBufferedImage.convertFrom(image,(GrayU8)null);\nGrayF32 input32 = ConvertBufferedImage.convertFromSingle(image, null, GrayF32.class);\nGrayU8 binary8 = new GrayU8(input8.getWidth(), input8.getHeight());\n\/\/ GrayF32 binary32 = new GrayF32(input8.getWidth(), input8.getHeight());\nboolean down = false;\nThresholdImageOps.threshold(input8, binary8, threshold, down);\n\/\/ GThresholdImageOps.threshold(input32, binary8, threshold, down);\nBufferedImage outputImage = null;\n\/\/ outputImage = ConvertBufferedImage.convertTo(binary8, null);\nboolean invert = false;\noutputImage = VisualizeBinaryData.renderBinary(binary8, invert, null);\n\/\/\n\/\/ outputImage = ImageUtil.removeAlpha(outputImage);\n\/\/ outputImage = ImageUtil.convertRGB(outputImage,\n\/\/ new int[] {0x0d0d0d}, new int[] {0xffffff});\nreturn outputImage;\n}","label":[0,0,1,0]}
{"id":20812,"original_code":"static int examineVar(final int var, final ArrayList<Read> list, final IntList collection, final int[] rvector, LinkedHashMap<Integer, ArrayList<Read>> map){\n\t\tcollection.clear();\n\t\tfor(Read r : list){\n\t\t\tfinal ReadKey rk=(ReadKey) r.obj;\n\t\t\tfinal IntList vars=rk.vars;\n\t\t\tfor(int i=0; i<vars.size; i++){\n\t\t\t\tfinal int v2=vars.get(i);\n\t\t\t\tif(v2!=var){\n\t\t\t\t\tcollection.add(v2);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcollection.sort();\n\t\tfinal int varCount=list.size();\n\t\tint lastVar2=-1, bestVar2=-1;\n\t\tint sharedCount=0, bestSharedCount=0, bestDifferent=999;\n\t\tfor(int i=0; i<collection.size; i++){\/\/TODO: Note that not all reads actually cover a given var\n\t\t\tint currentVar2=collection.get(i);\n\t\t\tif(currentVar2==lastVar2){sharedCount++;}\n\t\t\telse{\n\t\t\t\tif(sharedCount>bestSharedCount){\n\t\t\t\t\tfinal int different1=(sharedCount==varCount ? 0 : countDifferentAlleles(lastVar2, list));\n\t\t\t\t\tif(different1*8<varCount){\n\t\t\t\t\t\tArrayList<Read> list2=map.get(lastVar2);\n\t\t\t\t\t\tfinal int varCount2=(list2==null ? 0 : list2.size());\n\t\t\t\t\t\tfinal int different2=(sharedCount==varCount2 ? 0 : countDifferentAlleles(var, list2));\n\t\t\t\t\t\tif(different2*8<varCount2){\n\t\t\t\t\t\t\tbestVar2=lastVar2;\n\t\t\t\t\t\t\tbestSharedCount=sharedCount;\n\t\t\t\t\t\t\tbestDifferent=Tools.max(different1, different2);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tsharedCount=1;\n\t\t\t}\n\t\t\tlastVar2=currentVar2;\n\t\t}\n\t\tif(sharedCount>bestSharedCount){\n\t\t\tfinal int different1=(sharedCount==varCount ? 0 : countDifferentAlleles(lastVar2, list));\n\t\t\tif(different1*8<varCount){\n\t\t\t\tArrayList<Read> list2=map.get(lastVar2);\n\t\t\t\tfinal int varCount2=(list2==null ? 0 : list2.size());\n\t\t\t\tfinal int different2=(sharedCount==varCount2 ? 0 : countDifferentAlleles(var, list2));\n\t\t\t\tif(different2*8<varCount2){\n\t\t\t\t\tbestVar2=lastVar2;\n\t\t\t\t\tbestSharedCount=sharedCount;\n\t\t\t\t\tbestDifferent=Tools.max(different1, different2);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\trvector[0]=var;\n\t\trvector[1]=list.size();\n\t\trvector[2]=bestVar2;\n\t\trvector[3]=sharedCount;\n\t\trvector[4]=bestDifferent;\n\t\treturn bestVar2;\n\t}","code":"static int examineVar(final int var, final ArrayList<Read> list, final IntList collection, final int[] rvector, LinkedHashMap<Integer, ArrayList<Read>> map){\n\t\tcollection.clear();\n\t\tfor(Read r : list){\n\t\t\tfinal ReadKey rk=(ReadKey) r.obj;\n\t\t\tfinal IntList vars=rk.vars;\n\t\t\tfor(int i=0; i<vars.size; i++){\n\t\t\t\tfinal int v2=vars.get(i);\n\t\t\t\tif(v2!=var){\n\t\t\t\t\tcollection.add(v2);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcollection.sort();\n\t\tfinal int varCount=list.size();\n\t\tint lastVar2=-1, bestVar2=-1;\n\t\tint sharedCount=0, bestSharedCount=0, bestDifferent=999;\n\t\tfor(int i=0; i<collection.size; i++)\n\t\t\tint currentVar2=collection.get(i);\n\t\t\tif(currentVar2==lastVar2){sharedCount++;}\n\t\t\telse{\n\t\t\t\tif(sharedCount>bestSharedCount){\n\t\t\t\t\tfinal int different1=(sharedCount==varCount ? 0 : countDifferentAlleles(lastVar2, list));\n\t\t\t\t\tif(different1*8<varCount){\n\t\t\t\t\t\tArrayList<Read> list2=map.get(lastVar2);\n\t\t\t\t\t\tfinal int varCount2=(list2==null ? 0 : list2.size());\n\t\t\t\t\t\tfinal int different2=(sharedCount==varCount2 ? 0 : countDifferentAlleles(var, list2));\n\t\t\t\t\t\tif(different2*8<varCount2){\n\t\t\t\t\t\t\tbestVar2=lastVar2;\n\t\t\t\t\t\t\tbestSharedCount=sharedCount;\n\t\t\t\t\t\t\tbestDifferent=Tools.max(different1, different2);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tsharedCount=1;\n\t\t\t}\n\t\t\tlastVar2=currentVar2;\n\t\t}\n\t\tif(sharedCount>bestSharedCount){\n\t\t\tfinal int different1=(sharedCount==varCount ? 0 : countDifferentAlleles(lastVar2, list));\n\t\t\tif(different1*8<varCount){\n\t\t\t\tArrayList<Read> list2=map.get(lastVar2);\n\t\t\t\tfinal int varCount2=(list2==null ? 0 : list2.size());\n\t\t\t\tfinal int different2=(sharedCount==varCount2 ? 0 : countDifferentAlleles(var, list2));\n\t\t\t\tif(different2*8<varCount2){\n\t\t\t\t\tbestVar2=lastVar2;\n\t\t\t\t\tbestSharedCount=sharedCount;\n\t\t\t\t\tbestDifferent=Tools.max(different1, different2);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\trvector[0]=var;\n\t\trvector[1]=list.size();\n\t\trvector[2]=bestVar2;\n\t\trvector[3]=sharedCount;\n\t\trvector[4]=bestDifferent;\n\t\treturn bestVar2;\n\t}","cleancode":"static int examinevar(final int var, final arraylist<read> list, final intlist collection, final int[] rvector, linkedhashmap<integer, arraylist<read>> map){ collection.clear(); for(read r : list){ final readkey rk=(readkey) r.obj; final intlist vars=rk.vars; for(int i=0; i<vars.size; i++){ final int v2=vars.get(i); if(v2!=var){ collection.add(v2); } } } collection.sort(); final int varcount=list.size(); int lastvar2=-1, bestvar2=-1; int sharedcount=0, bestsharedcount=0, bestdifferent=999; for(int i=0; i<collection.size; i++) int currentvar2=collection.get(i); if(currentvar2==lastvar2){sharedcount++;} else{ if(sharedcount>bestsharedcount){ final int different1=(sharedcount==varcount ? 0 : countdifferentalleles(lastvar2, list)); if(different1*8<varcount){ arraylist<read> list2=map.get(lastvar2); final int varcount2=(list2==null ? 0 : list2.size()); final int different2=(sharedcount==varcount2 ? 0 : countdifferentalleles(var, list2)); if(different2*8<varcount2){ bestvar2=lastvar2; bestsharedcount=sharedcount; bestdifferent=tools.max(different1, different2); } } } sharedcount=1; } lastvar2=currentvar2; } if(sharedcount>bestsharedcount){ final int different1=(sharedcount==varcount ? 0 : countdifferentalleles(lastvar2, list)); if(different1*8<varcount){ arraylist<read> list2=map.get(lastvar2); final int varcount2=(list2==null ? 0 : list2.size()); final int different2=(sharedcount==varcount2 ? 0 : countdifferentalleles(var, list2)); if(different2*8<varcount2){ bestvar2=lastvar2; bestsharedcount=sharedcount; bestdifferent=tools.max(different1, different2); } } } rvector[0]=var; rvector[1]=list.size(); rvector[2]=bestvar2; rvector[3]=sharedcount; rvector[4]=bestdifferent; return bestvar2; }","comment":"\/\/todo: note that not all reads actually cover a given var","repo":"nedru004\/LibraryAnalysis2","code_context_2":"int lastVar2=-1, bestVar2=-1;\nint sharedCount=0, bestSharedCount=0, bestDifferent=999;\nfor(int i=0; i<collection.size; i++){\/\/TODO: Note that not all reads actually cover a given var\nint currentVar2=collection.get(i);\nif(currentVar2==lastVar2){sharedCount++;}","code_context_10":"final int v2=vars.get(i);\nif(v2!=var){\ncollection.add(v2);\n}\n}\n}\ncollection.sort();\nfinal int varCount=list.size();\nint lastVar2=-1, bestVar2=-1;\nint sharedCount=0, bestSharedCount=0, bestDifferent=999;\nfor(int i=0; i<collection.size; i++){\/\/TODO: Note that not all reads actually cover a given var\nint currentVar2=collection.get(i);\nif(currentVar2==lastVar2){sharedCount++;}\nelse{\nif(sharedCount>bestSharedCount){\nfinal int different1=(sharedCount==varCount ? 0 : countDifferentAlleles(lastVar2, list));\nif(different1*8<varCount){\nArrayList<Read> list2=map.get(lastVar2);\nfinal int varCount2=(list2==null ? 0 : list2.size());\nfinal int different2=(sharedCount==varCount2 ? 0 : countDifferentAlleles(var, list2));\nif(different2*8<varCount2){","code_context_20":"static int examineVar(final int var, final ArrayList<Read> list, final IntList collection, final int[] rvector, LinkedHashMap<Integer, ArrayList<Read>> map){\ncollection.clear();\nfor(Read r : list){\nfinal ReadKey rk=(ReadKey) r.obj;\nfinal IntList vars=rk.vars;\nfor(int i=0; i<vars.size; i++){\nfinal int v2=vars.get(i);\nif(v2!=var){\ncollection.add(v2);\n}\n}\n}\ncollection.sort();\nfinal int varCount=list.size();\nint lastVar2=-1, bestVar2=-1;\nint sharedCount=0, bestSharedCount=0, bestDifferent=999;\nfor(int i=0; i<collection.size; i++){\/\/TODO: Note that not all reads actually cover a given var\nint currentVar2=collection.get(i);\nif(currentVar2==lastVar2){sharedCount++;}\nelse{\nif(sharedCount>bestSharedCount){\nfinal int different1=(sharedCount==varCount ? 0 : countDifferentAlleles(lastVar2, list));\nif(different1*8<varCount){\nArrayList<Read> list2=map.get(lastVar2);\nfinal int varCount2=(list2==null ? 0 : list2.size());\nfinal int different2=(sharedCount==varCount2 ? 0 : countDifferentAlleles(var, list2));\nif(different2*8<varCount2){\nbestVar2=lastVar2;\nbestSharedCount=sharedCount;\nbestDifferent=Tools.max(different1, different2);\n}\n}\n}\nsharedCount=1;\n}\nlastVar2=currentVar2;\n}","label":[1,0,0,0]}
{"id":12626,"original_code":"@RequestMapping(path = \"\/0\/admin\/applications\/{appId}\/block\", method = RequestMethod.POST)\n\tpublic ResponseEntity<Boolean> updateDeveloperApplication(\n\t\t\t@PathVariable String appId\n\t) {\n\t\t\/\/ Let's get the user from principal and validate the userId against it.\n\t\tUser user = userService.findAuthenticatedUser();\n\t\tif (user == null)\n\t\t\treturn new ResponseEntity<>(HttpStatus.FORBIDDEN);\n\t\t\/\/ TODO check and ensure user is Moderator role\n\t\tApplication application = applicationService.findApplication(appId);\n\t\tif (application == null){\n\t\t\tlogger.debug(\"Application not found pre condition failed\");\n\t\t\treturn new ResponseEntity<>(HttpStatus.PRECONDITION_FAILED);\n\t\t}\t\n\t\t\/\/ TODO what if Application was already blocked?\n\t\tBoolean result = applicationService.blockApplication(application);\n\t\treturn new ResponseEntity<>(result, HttpStatus.OK);\n\t}","code":"@RequestMapping(path = \"\/0\/admin\/applications\/{appId}\/block\", method = RequestMethod.POST)\n\tpublic ResponseEntity<Boolean> updateDeveloperApplication(\n\t\t\t@PathVariable String appId\n\t) {\n\t\n\t\tUser user = userService.findAuthenticatedUser();\n\t\tif (user == null)\n\t\t\treturn new ResponseEntity<>(HttpStatus.FORBIDDEN);\n\t\n\t\tApplication application = applicationService.findApplication(appId);\n\t\tif (application == null){\n\t\t\tlogger.debug(\"Application not found pre condition failed\");\n\t\t\treturn new ResponseEntity<>(HttpStatus.PRECONDITION_FAILED);\n\t\t}\t\n\t\n\t\tBoolean result = applicationService.blockApplication(application);\n\t\treturn new ResponseEntity<>(result, HttpStatus.OK);\n\t}","cleancode":"@requestmapping(path = \"\/0\/admin\/applications\/{appid}\/block\", method = requestmethod.post) public responseentity<boolean> updatedeveloperapplication( @pathvariable string appid ) { user user = userservice.findauthenticateduser(); if (user == null) return new responseentity<>(httpstatus.forbidden); application application = applicationservice.findapplication(appid); if (application == null){ logger.debug(\"application not found pre condition failed\"); return new responseentity<>(httpstatus.precondition_failed); } boolean result = applicationservice.blockapplication(application); return new responseentity<>(result, httpstatus.ok); }","comment":"\/** * block developer application * @param appid the id of the application to be blocked * @return a boolean value that indicates whether the update is successful *\/\n\/\/ let's get the user from principal and validate the userid against it.\n\/\/ todo check and ensure user is moderator role\n\/\/ todo what if application was already blocked?","repo":"niuyiming\/alpha-umi","code_context_2":"@RequestMapping(path = \"\/0\/admin\/applications\/{appId}\/block\", method = RequestMethod.POST)\npublic ResponseEntity<Boolean> updateDeveloperApplication(\n@PathVariable String appId\n) {\n\/\/ Let's get the user from principal and validate the userId against it.\nUser user = userService.findAuthenticatedUser();\nif (user == null)\nreturn new ResponseEntity<>(HttpStatus.FORBIDDEN);\n\/\/ TODO check and ensure user is Moderator role\nApplication application = applicationService.findApplication(appId);\nif (application == null){\nlogger.debug(\"Application not found pre condition failed\");\nreturn new ResponseEntity<>(HttpStatus.PRECONDITION_FAILED);\n}\n\/\/ TODO what if Application was already blocked?\nBoolean result = applicationService.blockApplication(application);\nreturn new ResponseEntity<>(result, HttpStatus.OK);\n}\n\n@PathVariable String appId\n) {\n\/\/ Let's get the user from principal and validate the userId against it.\nUser user = userService.findAuthenticatedUser();\nif (user == null)\n\nif (user == null)\nreturn new ResponseEntity<>(HttpStatus.FORBIDDEN);\n\/\/ TODO check and ensure user is Moderator role\nApplication application = applicationService.findApplication(appId);\nif (application == null){\n\nreturn new ResponseEntity<>(HttpStatus.PRECONDITION_FAILED);\n}\n\/\/ TODO what if Application was already blocked?\nBoolean result = applicationService.blockApplication(application);\nreturn new ResponseEntity<>(result, HttpStatus.OK);","code_context_10":"@RequestMapping(path = \"\/0\/admin\/applications\/{appId}\/block\", method = RequestMethod.POST)\npublic ResponseEntity<Boolean> updateDeveloperApplication(\n@PathVariable String appId\n) {\n\/\/ Let's get the user from principal and validate the userId against it.\nUser user = userService.findAuthenticatedUser();\nif (user == null)\nreturn new ResponseEntity<>(HttpStatus.FORBIDDEN);\n\/\/ TODO check and ensure user is Moderator role\nApplication application = applicationService.findApplication(appId);\nif (application == null){\nlogger.debug(\"Application not found pre condition failed\");\nreturn new ResponseEntity<>(HttpStatus.PRECONDITION_FAILED);\n}\n\/\/ TODO what if Application was already blocked?\nBoolean result = applicationService.blockApplication(application);\nreturn new ResponseEntity<>(result, HttpStatus.OK);\n}\n\n@RequestMapping(path = \"\/0\/admin\/applications\/{appId}\/block\", method = RequestMethod.POST)\npublic ResponseEntity<Boolean> updateDeveloperApplication(\n@PathVariable String appId\n) {\n\/\/ Let's get the user from principal and validate the userId against it.\nUser user = userService.findAuthenticatedUser();\nif (user == null)\nreturn new ResponseEntity<>(HttpStatus.FORBIDDEN);\n\/\/ TODO check and ensure user is Moderator role\nApplication application = applicationService.findApplication(appId);\nif (application == null){\nlogger.debug(\"Application not found pre condition failed\");\nreturn new ResponseEntity<>(HttpStatus.PRECONDITION_FAILED);\n}\n\/\/ TODO what if Application was already blocked?\n\n@RequestMapping(path = \"\/0\/admin\/applications\/{appId}\/block\", method = RequestMethod.POST)\npublic ResponseEntity<Boolean> updateDeveloperApplication(\n@PathVariable String appId\n) {\n\/\/ Let's get the user from principal and validate the userId against it.\nUser user = userService.findAuthenticatedUser();\nif (user == null)\nreturn new ResponseEntity<>(HttpStatus.FORBIDDEN);\n\/\/ TODO check and ensure user is Moderator role\nApplication application = applicationService.findApplication(appId);\nif (application == null){\nlogger.debug(\"Application not found pre condition failed\");\nreturn new ResponseEntity<>(HttpStatus.PRECONDITION_FAILED);\n}\n\/\/ TODO what if Application was already blocked?\nBoolean result = applicationService.blockApplication(application);\nreturn new ResponseEntity<>(result, HttpStatus.OK);\n}\n\n\/\/ Let's get the user from principal and validate the userId against it.\nUser user = userService.findAuthenticatedUser();\nif (user == null)\nreturn new ResponseEntity<>(HttpStatus.FORBIDDEN);\n\/\/ TODO check and ensure user is Moderator role\nApplication application = applicationService.findApplication(appId);\nif (application == null){\nlogger.debug(\"Application not found pre condition failed\");\nreturn new ResponseEntity<>(HttpStatus.PRECONDITION_FAILED);\n}\n\/\/ TODO what if Application was already blocked?\nBoolean result = applicationService.blockApplication(application);\nreturn new ResponseEntity<>(result, HttpStatus.OK);\n}","code_context_20":"@RequestMapping(path = \"\/0\/admin\/applications\/{appId}\/block\", method = RequestMethod.POST)\npublic ResponseEntity<Boolean> updateDeveloperApplication(\n@PathVariable String appId\n) {\n\/\/ Let's get the user from principal and validate the userId against it.\nUser user = userService.findAuthenticatedUser();\nif (user == null)\nreturn new ResponseEntity<>(HttpStatus.FORBIDDEN);\n\/\/ TODO check and ensure user is Moderator role\nApplication application = applicationService.findApplication(appId);\nif (application == null){\nlogger.debug(\"Application not found pre condition failed\");\nreturn new ResponseEntity<>(HttpStatus.PRECONDITION_FAILED);\n}\n\/\/ TODO what if Application was already blocked?\nBoolean result = applicationService.blockApplication(application);\nreturn new ResponseEntity<>(result, HttpStatus.OK);\n}\n\n@RequestMapping(path = \"\/0\/admin\/applications\/{appId}\/block\", method = RequestMethod.POST)\npublic ResponseEntity<Boolean> updateDeveloperApplication(\n@PathVariable String appId\n) {\n\/\/ Let's get the user from principal and validate the userId against it.\nUser user = userService.findAuthenticatedUser();\nif (user == null)\nreturn new ResponseEntity<>(HttpStatus.FORBIDDEN);\n\/\/ TODO check and ensure user is Moderator role\nApplication application = applicationService.findApplication(appId);\nif (application == null){\nlogger.debug(\"Application not found pre condition failed\");\nreturn new ResponseEntity<>(HttpStatus.PRECONDITION_FAILED);\n}\n\/\/ TODO what if Application was already blocked?\nBoolean result = applicationService.blockApplication(application);\nreturn new ResponseEntity<>(result, HttpStatus.OK);\n}\n\n@RequestMapping(path = \"\/0\/admin\/applications\/{appId}\/block\", method = RequestMethod.POST)\npublic ResponseEntity<Boolean> updateDeveloperApplication(\n@PathVariable String appId\n) {\n\/\/ Let's get the user from principal and validate the userId against it.\nUser user = userService.findAuthenticatedUser();\nif (user == null)\nreturn new ResponseEntity<>(HttpStatus.FORBIDDEN);\n\/\/ TODO check and ensure user is Moderator role\nApplication application = applicationService.findApplication(appId);\nif (application == null){\nlogger.debug(\"Application not found pre condition failed\");\nreturn new ResponseEntity<>(HttpStatus.PRECONDITION_FAILED);\n}\n\/\/ TODO what if Application was already blocked?\nBoolean result = applicationService.blockApplication(application);\nreturn new ResponseEntity<>(result, HttpStatus.OK);\n}\n\n@RequestMapping(path = \"\/0\/admin\/applications\/{appId}\/block\", method = RequestMethod.POST)\npublic ResponseEntity<Boolean> updateDeveloperApplication(\n@PathVariable String appId\n) {\n\/\/ Let's get the user from principal and validate the userId against it.\nUser user = userService.findAuthenticatedUser();\nif (user == null)\nreturn new ResponseEntity<>(HttpStatus.FORBIDDEN);\n\/\/ TODO check and ensure user is Moderator role\nApplication application = applicationService.findApplication(appId);\nif (application == null){\nlogger.debug(\"Application not found pre condition failed\");\nreturn new ResponseEntity<>(HttpStatus.PRECONDITION_FAILED);\n}\n\/\/ TODO what if Application was already blocked?\nBoolean result = applicationService.blockApplication(application);\nreturn new ResponseEntity<>(result, HttpStatus.OK);\n}","label":[1,1,0,0]}
{"id":13141,"original_code":"private boolean useSwitchingProvider() {\n    if (!isFastInit) {\n      return false;\n    }\n    switch (binding.kind()) {\n      case BOUND_INSTANCE:\n      case COMPONENT:\n      case COMPONENT_DEPENDENCY:\n      case DELEGATE:\n      case MEMBERS_INJECTOR: \/\/ TODO(b\/199889259): Consider optimizing this for fastInit mode.\n        \/\/ These binding kinds avoid SwitchingProvider when the backing instance already exists,\n        \/\/ e.g. a component provider can use FactoryInstance.create(this).\n        return false;\n      case MULTIBOUND_SET:\n      case MULTIBOUND_MAP:\n      case OPTIONAL:\n        \/\/ These binding kinds avoid SwitchingProvider when their are no dependencies,\n        \/\/ e.g. a multibound set with no dependency can use a singleton, SetFactory.empty().\n        return !binding.dependencies().isEmpty();\n      case INJECTION:\n      case PROVISION:\n      case ASSISTED_INJECTION:\n      case ASSISTED_FACTORY:\n      case COMPONENT_PROVISION:\n      case SUBCOMPONENT_CREATOR:\n      case PRODUCTION:\n      case COMPONENT_PRODUCTION:\n      case MEMBERS_INJECTION:\n        return true;\n    }\n    throw new AssertionError(String.format(\"No such binding kind: %s\", binding.kind()));\n  }","code":"private boolean useSwitchingProvider() {\n    if (!isFastInit) {\n      return false;\n    }\n    switch (binding.kind()) {\n      case BOUND_INSTANCE:\n      case COMPONENT:\n      case COMPONENT_DEPENDENCY:\n      case DELEGATE:\n      case MEMBERS_INJECTOR:\n       \n       \n        return false;\n      case MULTIBOUND_SET:\n      case MULTIBOUND_MAP:\n      case OPTIONAL:\n       \n       \n        return !binding.dependencies().isEmpty();\n      case INJECTION:\n      case PROVISION:\n      case ASSISTED_INJECTION:\n      case ASSISTED_FACTORY:\n      case COMPONENT_PROVISION:\n      case SUBCOMPONENT_CREATOR:\n      case PRODUCTION:\n      case COMPONENT_PRODUCTION:\n      case MEMBERS_INJECTION:\n        return true;\n    }\n    throw new AssertionError(String.format(\"No such binding kind: %s\", binding.kind()));\n  }","cleancode":"private boolean useswitchingprovider() { if (!isfastinit) { return false; } switch (binding.kind()) { case bound_instance: case component: case component_dependency: case delegate: case members_injector: return false; case multibound_set: case multibound_map: case optional: return !binding.dependencies().isempty(); case injection: case provision: case assisted_injection: case assisted_factory: case component_provision: case subcomponent_creator: case production: case component_production: case members_injection: return true; } throw new assertionerror(string.format(\"no such binding kind: %s\", binding.kind())); }","comment":"\/\/ todo(b\/199889259): consider optimizing this for fastinit mode.\n\/\/ these binding kinds avoid switchingprovider when the backing instance already exists, \/\/ e.g. a component provider can use factoryinstance.create(this).\n\/\/ these binding kinds avoid switchingprovider when their are no dependencies, \/\/ e.g. a multibound set with no dependency can use a singleton, setfactory.empty().","repo":"priamm\/dagger","code_context_2":"case COMPONENT_DEPENDENCY:\ncase DELEGATE:\ncase MEMBERS_INJECTOR: \/\/ TODO(b\/199889259): Consider optimizing this for fastInit mode.\n\/\/ These binding kinds avoid SwitchingProvider when the backing instance already exists,\n\/\/ e.g. a component provider can use FactoryInstance.create(this).\n\ncase DELEGATE:\ncase MEMBERS_INJECTOR: \/\/ TODO(b\/199889259): Consider optimizing this for fastInit mode.\n\/\/ These binding kinds avoid SwitchingProvider when the backing instance already exists,\n\/\/ e.g. a component provider can use FactoryInstance.create(this).\nreturn false;\ncase MULTIBOUND_SET:\n\ncase MULTIBOUND_MAP:\ncase OPTIONAL:\n\/\/ These binding kinds avoid SwitchingProvider when their are no dependencies,\n\/\/ e.g. a multibound set with no dependency can use a singleton, SetFactory.empty().\nreturn !binding.dependencies().isEmpty();\ncase INJECTION:","code_context_10":"private boolean useSwitchingProvider() {\nif (!isFastInit) {\nreturn false;\n}\nswitch (binding.kind()) {\ncase BOUND_INSTANCE:\ncase COMPONENT:\ncase COMPONENT_DEPENDENCY:\ncase DELEGATE:\ncase MEMBERS_INJECTOR: \/\/ TODO(b\/199889259): Consider optimizing this for fastInit mode.\n\/\/ These binding kinds avoid SwitchingProvider when the backing instance already exists,\n\/\/ e.g. a component provider can use FactoryInstance.create(this).\nreturn false;\ncase MULTIBOUND_SET:\ncase MULTIBOUND_MAP:\ncase OPTIONAL:\n\/\/ These binding kinds avoid SwitchingProvider when their are no dependencies,\n\/\/ e.g. a multibound set with no dependency can use a singleton, SetFactory.empty().\nreturn !binding.dependencies().isEmpty();\ncase INJECTION:\n\nprivate boolean useSwitchingProvider() {\nif (!isFastInit) {\nreturn false;\n}\nswitch (binding.kind()) {\ncase BOUND_INSTANCE:\ncase COMPONENT:\ncase COMPONENT_DEPENDENCY:\ncase DELEGATE:\ncase MEMBERS_INJECTOR: \/\/ TODO(b\/199889259): Consider optimizing this for fastInit mode.\n\/\/ These binding kinds avoid SwitchingProvider when the backing instance already exists,\n\/\/ e.g. a component provider can use FactoryInstance.create(this).\nreturn false;\ncase MULTIBOUND_SET:\ncase MULTIBOUND_MAP:\ncase OPTIONAL:\n\/\/ These binding kinds avoid SwitchingProvider when their are no dependencies,\n\/\/ e.g. a multibound set with no dependency can use a singleton, SetFactory.empty().\nreturn !binding.dependencies().isEmpty();\ncase INJECTION:\ncase PROVISION:\ncase ASSISTED_INJECTION:\n\ncase COMPONENT:\ncase COMPONENT_DEPENDENCY:\ncase DELEGATE:\ncase MEMBERS_INJECTOR: \/\/ TODO(b\/199889259): Consider optimizing this for fastInit mode.\n\/\/ These binding kinds avoid SwitchingProvider when the backing instance already exists,\n\/\/ e.g. a component provider can use FactoryInstance.create(this).\nreturn false;\ncase MULTIBOUND_SET:\ncase MULTIBOUND_MAP:\ncase OPTIONAL:\n\/\/ These binding kinds avoid SwitchingProvider when their are no dependencies,\n\/\/ e.g. a multibound set with no dependency can use a singleton, SetFactory.empty().\nreturn !binding.dependencies().isEmpty();\ncase INJECTION:\ncase PROVISION:\ncase ASSISTED_INJECTION:\ncase ASSISTED_FACTORY:\ncase COMPONENT_PROVISION:\ncase SUBCOMPONENT_CREATOR:\ncase PRODUCTION:\ncase COMPONENT_PRODUCTION:\ncase MEMBERS_INJECTION:","code_context_20":"private boolean useSwitchingProvider() {\nif (!isFastInit) {\nreturn false;\n}\nswitch (binding.kind()) {\ncase BOUND_INSTANCE:\ncase COMPONENT:\ncase COMPONENT_DEPENDENCY:\ncase DELEGATE:\ncase MEMBERS_INJECTOR: \/\/ TODO(b\/199889259): Consider optimizing this for fastInit mode.\n\/\/ These binding kinds avoid SwitchingProvider when the backing instance already exists,\n\/\/ e.g. a component provider can use FactoryInstance.create(this).\nreturn false;\ncase MULTIBOUND_SET:\ncase MULTIBOUND_MAP:\ncase OPTIONAL:\n\/\/ These binding kinds avoid SwitchingProvider when their are no dependencies,\n\/\/ e.g. a multibound set with no dependency can use a singleton, SetFactory.empty().\nreturn !binding.dependencies().isEmpty();\ncase INJECTION:\ncase PROVISION:\ncase ASSISTED_INJECTION:\ncase ASSISTED_FACTORY:\ncase COMPONENT_PROVISION:\ncase SUBCOMPONENT_CREATOR:\ncase PRODUCTION:\ncase COMPONENT_PRODUCTION:\ncase MEMBERS_INJECTION:\nreturn true;\n}\n\nprivate boolean useSwitchingProvider() {\nif (!isFastInit) {\nreturn false;\n}\nswitch (binding.kind()) {\ncase BOUND_INSTANCE:\ncase COMPONENT:\ncase COMPONENT_DEPENDENCY:\ncase DELEGATE:\ncase MEMBERS_INJECTOR: \/\/ TODO(b\/199889259): Consider optimizing this for fastInit mode.\n\/\/ These binding kinds avoid SwitchingProvider when the backing instance already exists,\n\/\/ e.g. a component provider can use FactoryInstance.create(this).\nreturn false;\ncase MULTIBOUND_SET:\ncase MULTIBOUND_MAP:\ncase OPTIONAL:\n\/\/ These binding kinds avoid SwitchingProvider when their are no dependencies,\n\/\/ e.g. a multibound set with no dependency can use a singleton, SetFactory.empty().\nreturn !binding.dependencies().isEmpty();\ncase INJECTION:\ncase PROVISION:\ncase ASSISTED_INJECTION:\ncase ASSISTED_FACTORY:\ncase COMPONENT_PROVISION:\ncase SUBCOMPONENT_CREATOR:\ncase PRODUCTION:\ncase COMPONENT_PRODUCTION:\ncase MEMBERS_INJECTION:\nreturn true;\n}\nthrow new AssertionError(String.format(\"No such binding kind: %s\", binding.kind()));\n}\n\nprivate boolean useSwitchingProvider() {\nif (!isFastInit) {\nreturn false;\n}\nswitch (binding.kind()) {\ncase BOUND_INSTANCE:\ncase COMPONENT:\ncase COMPONENT_DEPENDENCY:\ncase DELEGATE:\ncase MEMBERS_INJECTOR: \/\/ TODO(b\/199889259): Consider optimizing this for fastInit mode.\n\/\/ These binding kinds avoid SwitchingProvider when the backing instance already exists,\n\/\/ e.g. a component provider can use FactoryInstance.create(this).\nreturn false;\ncase MULTIBOUND_SET:\ncase MULTIBOUND_MAP:\ncase OPTIONAL:\n\/\/ These binding kinds avoid SwitchingProvider when their are no dependencies,\n\/\/ e.g. a multibound set with no dependency can use a singleton, SetFactory.empty().\nreturn !binding.dependencies().isEmpty();\ncase INJECTION:\ncase PROVISION:\ncase ASSISTED_INJECTION:\ncase ASSISTED_FACTORY:\ncase COMPONENT_PROVISION:\ncase SUBCOMPONENT_CREATOR:\ncase PRODUCTION:\ncase COMPONENT_PRODUCTION:\ncase MEMBERS_INJECTION:\nreturn true;\n}\nthrow new AssertionError(String.format(\"No such binding kind: %s\", binding.kind()));\n}","label":[1,0,0,0]}
{"id":13305,"original_code":"@Test\n\tpublic void openPrivateRepository() {\n\t\t\/\/TODO : need to implement. first need to figure out a way to hide the credentials dialog.\n\t}","code":"@Test\n\tpublic void openPrivateRepository() {\n\t\n\t}","cleancode":"@test public void openprivaterepository() { }","comment":"\/\/todo : need to implement. first need to figure out a way to hide the credentials dialog.","repo":"mvm-sap\/ADT_Frontend","code_context_2":"@Test\npublic void openPrivateRepository() {\n\/\/TODO : need to implement. first need to figure out a way to hide the credentials dialog.\n}","code_context_10":"@Test\npublic void openPrivateRepository() {\n\/\/TODO : need to implement. first need to figure out a way to hide the credentials dialog.\n}","code_context_20":"@Test\npublic void openPrivateRepository() {\n\/\/TODO : need to implement. first need to figure out a way to hide the credentials dialog.\n}","label":[0,1,0,0]}
{"id":13339,"original_code":"@Override\n    public void validateDataOnEntry()\n            throws DataModelException {\n        \/\/ TODO auto-generated method stub, to be implemented by parser\n    }","code":"@Override\n    public void validateDataOnEntry()\n            throws DataModelException {\n       \n    }","cleancode":"@override public void validatedataonentry() throws datamodelexception { }","comment":"\/** * validates the data on entering the corresponding parse tree node. * * @throws datamodelexception a violation of data model rules *\/\n\/\/ todo auto-generated method stub, to be implemented by parser","repo":"onekeynet\/OConf","code_context_2":"@Override\npublic void validateDataOnEntry()\nthrows DataModelException {\n\/\/ TODO auto-generated method stub, to be implemented by parser\n}\n\npublic void validateDataOnEntry()\nthrows DataModelException {\n\/\/ TODO auto-generated method stub, to be implemented by parser\n}","code_context_10":"@Override\npublic void validateDataOnEntry()\nthrows DataModelException {\n\/\/ TODO auto-generated method stub, to be implemented by parser\n}\n\n@Override\npublic void validateDataOnEntry()\nthrows DataModelException {\n\/\/ TODO auto-generated method stub, to be implemented by parser\n}","code_context_20":"@Override\npublic void validateDataOnEntry()\nthrows DataModelException {\n\/\/ TODO auto-generated method stub, to be implemented by parser\n}\n\n@Override\npublic void validateDataOnEntry()\nthrows DataModelException {\n\/\/ TODO auto-generated method stub, to be implemented by parser\n}","label":[0,1,0,0]}
{"id":13382,"original_code":"private boolean writeResponseBodyToDisk(ResponseBody body) {\n        try {\n            \/\/ todo change the file location\/name according to your needs\n            File futureStudioIconFile = new File(mOtaSaveFilePath);\n            InputStream inputStream = null;\n            OutputStream outputStream = null;\n            try {\n                byte[] fileReader = new byte[1024];\n                long fileSize = body.contentLength();\n                long fileSizeDownloaded = 0;\n                inputStream = body.byteStream();\n                outputStream = new FileOutputStream(futureStudioIconFile);\n                while (true) {\n                    int read = inputStream.read(fileReader);\n                    if (read == -1) {\n                        break;\n                    }\n                    outputStream.write(fileReader, 0, read);\n                    fileSizeDownloaded += read;\n                }\n                outputStream.flush();\n                return true;\n            } catch (IOException e) {\n                return false;\n            } finally {\n                if (inputStream != null) {\n                    inputStream.close();\n                }\n                if (outputStream != null) {\n                    outputStream.close();\n                }\n            }\n        } catch (IOException e) {\n            return false;\n        }\n    }","code":"private boolean writeResponseBodyToDisk(ResponseBody body) {\n        try {\n           \n            File futureStudioIconFile = new File(mOtaSaveFilePath);\n            InputStream inputStream = null;\n            OutputStream outputStream = null;\n            try {\n                byte[] fileReader = new byte[1024];\n                long fileSize = body.contentLength();\n                long fileSizeDownloaded = 0;\n                inputStream = body.byteStream();\n                outputStream = new FileOutputStream(futureStudioIconFile);\n                while (true) {\n                    int read = inputStream.read(fileReader);\n                    if (read == -1) {\n                        break;\n                    }\n                    outputStream.write(fileReader, 0, read);\n                    fileSizeDownloaded += read;\n                }\n                outputStream.flush();\n                return true;\n            } catch (IOException e) {\n                return false;\n            } finally {\n                if (inputStream != null) {\n                    inputStream.close();\n                }\n                if (outputStream != null) {\n                    outputStream.close();\n                }\n            }\n        } catch (IOException e) {\n            return false;\n        }\n    }","cleancode":"private boolean writeresponsebodytodisk(responsebody body) { try { file futurestudioiconfile = new file(motasavefilepath); inputstream inputstream = null; outputstream outputstream = null; try { byte[] filereader = new byte[1024]; long filesize = body.contentlength(); long filesizedownloaded = 0; inputstream = body.bytestream(); outputstream = new fileoutputstream(futurestudioiconfile); while (true) { int read = inputstream.read(filereader); if (read == -1) { break; } outputstream.write(filereader, 0, read); filesizedownloaded += read; } outputstream.flush(); return true; } catch (ioexception e) { return false; } finally { if (inputstream != null) { inputstream.close(); } if (outputstream != null) { outputstream.close(); } } } catch (ioexception e) { return false; } }","comment":"\/\/ todo change the file location\/name according to your needs","repo":"qiaolw\/AndroidTest","code_context_2":"private boolean writeResponseBodyToDisk(ResponseBody body) {\ntry {\n\/\/ todo change the file location\/name according to your needs\nFile futureStudioIconFile = new File(mOtaSaveFilePath);\nInputStream inputStream = null;","code_context_10":"private boolean writeResponseBodyToDisk(ResponseBody body) {\ntry {\n\/\/ todo change the file location\/name according to your needs\nFile futureStudioIconFile = new File(mOtaSaveFilePath);\nInputStream inputStream = null;\nOutputStream outputStream = null;\ntry {\nbyte[] fileReader = new byte[1024];\nlong fileSize = body.contentLength();\nlong fileSizeDownloaded = 0;\ninputStream = body.byteStream();\noutputStream = new FileOutputStream(futureStudioIconFile);\nwhile (true) {","code_context_20":"private boolean writeResponseBodyToDisk(ResponseBody body) {\ntry {\n\/\/ todo change the file location\/name according to your needs\nFile futureStudioIconFile = new File(mOtaSaveFilePath);\nInputStream inputStream = null;\nOutputStream outputStream = null;\ntry {\nbyte[] fileReader = new byte[1024];\nlong fileSize = body.contentLength();\nlong fileSizeDownloaded = 0;\ninputStream = body.byteStream();\noutputStream = new FileOutputStream(futureStudioIconFile);\nwhile (true) {\nint read = inputStream.read(fileReader);\nif (read == -1) {\nbreak;\n}\noutputStream.write(fileReader, 0, read);\nfileSizeDownloaded += read;\n}\noutputStream.flush();\nreturn true;\n} catch (IOException e) {","label":[1,0,0,0]}
{"id":21838,"original_code":"@Override\n\tpublic void operate(OpContext context) throws ProcessingException {\n\t\tfinal TableDataSource table = (TableDataSource)context.get(tableInput);\n\t\tint ipaTidx = super.getColumnIndex(table, SystemTierType.IPATarget.getName());\n\t\tif(ipaTidx < 0) {\n\t\t\tthrow new ProcessingException(null, \"Table has no \" + SystemTierType.IPATarget.getName() + \" column.\");\n\t\t}\n\t\tint ipaAidx = super.getColumnIndex(table, SystemTierType.IPAActual.getName());\n\t\tif(ipaAidx < 0) {\n\t\t\tthrow new ProcessingException(null, \"Table has no \" + SystemTierType.IPAActual.getName() + \" column.\");\n\t\t}\n\t\t\/\/ group by session if info is available\n\t\t\/\/ TODO make this an option\n\t\tint sessionIdx = super.getColumnIndex(table, \"Session\");\n\t\tboolean ignoreDiacritics = isIgnoreDiacritics();\n\t\tif(context.containsKey(\"ignoreDiacritics\")) {\n\t\t\tignoreDiacritics = (boolean)context.get(\"ignoreDiacritics\");\n\t\t}\n\t\tfinal Map<GroupKey, IpaTernaryTree<List<IPATranscript>>> tokenCounts =\n\t\t\t\tnew LinkedHashMap<>();\n\t\tfor(int row = 0; row < table.getRowCount(); row++) {\n\t\t\tcheckCanceled();\n\t\t\tfinal Object groupVal =\n\t\t\t\t\t(sessionIdx >= 0 ? table.getValueAt(row, sessionIdx) : \"*\");\n\t\t\tfinal GroupKey groupKey = new GroupKey(groupVal, ignoreDiacritics);\n\t\t\tIpaTernaryTree<List<IPATranscript>> tokenCount =\n\t\t\t\t\ttokenCounts.get(groupKey);\n\t\t\tif(tokenCount == null) {\n\t\t\t\ttokenCount = new IpaTernaryTree<>();\n\t\t\t\ttokenCounts.put(groupKey, tokenCount);\n\t\t\t}\n\t\t\tIPATranscript ipaT =\n\t\t\t\t\tIPATranscript.class.cast(table.getValueAt(row, ipaTidx));\n\t\t\tIPATranscript ipaA =\n\t\t\t\t\tIPATranscript.class.cast(table.getValueAt(row, ipaAidx));\n\t\t\tif(ignoreDiacritics) {\n\t\t\t\tipaT = ipaT.removePunctuation().stripDiacritics();\n\t\t\t\tipaA = ipaA.removePunctuation().stripDiacritics();\n\t\t\t}\n\t\t\tList<IPATranscript> productions = tokenCount.get(ipaT);\n\t\t\tif(productions == null) {\n\t\t\t\tproductions = new ArrayList<>();\n\t\t\t\ttokenCount.put(ipaT, productions);\n\t\t\t}\n\t\t\tproductions.add(ipaA);\n\t\t}\n\t\tfinal DefaultTableDataSource outputTable = new DefaultTableDataSource();\n\t\tfor(GroupKey groupKey:tokenCounts.keySet()) {\n\t\t\tfinal Object[] rowData = new Object[7];\n\t\t\t\/\/ produce table\n\t\t\tint numRepatedWords = 0;\n\t\t\tint numAllCorrect = 0;\n\t\t\tint numOneOrMoreCorrect = 0;\n\t\t\tint numSameError = 0;\n\t\t\tint numDifferentErrors = 0;\n\t\t\tfloat sumOfAvgDistances = 0;\n\t\t\tfinal IpaTernaryTree<List<IPATranscript>> tokenCount = tokenCounts.get(groupKey);\n\t\t\tfinal List<IPATranscript> repeatedTokens =\n\t\t\t\t\ttokenCount.keySet().stream()\n\t\t\t\t\t\t.filter( (ipa) -> tokenCount.get(ipa).size() > 1 )\n\t\t\t\t\t\t.collect(Collectors.toList());\n\t\t\tnumRepatedWords = repeatedTokens.size();\n\t\t\tfor(IPATranscript ipa:repeatedTokens) {\n\t\t\t\tcheckCanceled();\n\t\t\t\tint numCorrect = 0;\n\t\t\t\tfinal List<IPATranscript> productions = tokenCount.get(ipa);\n\t\t\t\tfinal Set<IPATranscript> distinctProductions = new LinkedHashSet<>(productions);\n\t\t\t\tfor(IPATranscript production:tokenCount.get(ipa)) {\n\t\t\t\t\tif(TableUtils.checkEquals(ipa, production, false, ignoreDiacritics)) {\n\t\t\t\t\t\t++numCorrect;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif(numCorrect == productions.size()) {\n\t\t\t\t\t++numAllCorrect;\n\t\t\t\t} else {\n\t\t\t\t\tif(numCorrect > 0 && numCorrect < productions.size()) {\n\t\t\t\t\t\t++numOneOrMoreCorrect;\n\t\t\t\t\t}\n\t\t\t\t\tdistinctProductions.remove(ipa);\n\t\t\t\t\tif(distinctProductions.size() == 1) {\n\t\t\t\t\t\t++numSameError;\n\t\t\t\t\t} else {\n\t\t\t\t\t\t++numDifferentErrors;\n\t\t\t\t\t}\n\t\t\t\t\tint totalDistance = 0;\n\t\t\t\t\tfor(IPATranscript production:productions) {\n\t\t\t\t\t\ttotalDistance += LevenshteinDistance.distance(ipa, production);\n\t\t\t\t\t}\n\t\t\t\t\tfloat avg = ((float)totalDistance)\/((float)productions.size());\n\t\t\t\t\tsumOfAvgDistances += avg;\n\t\t\t\t}\n\t\t\t}\n\t\t\t\/\/ append row to table\n\t\t\trowData[0] = groupKey.key;\n\t\t\trowData[1] = numRepatedWords;\n\t\t\trowData[2] = numAllCorrect;\n\t\t\trowData[3] = numOneOrMoreCorrect;\n\t\t\trowData[4] = numSameError;\n\t\t\trowData[5] = numDifferentErrors;\n\t\t\trowData[6] = sumOfAvgDistances \/ numRepatedWords;\n\t\t\toutputTable.addRow(rowData);\n\t\t}\n\t\toutputTable.setColumnTitle(0, \"Session\");\n\t\toutputTable.setColumnTitle(1, \"# Repeated IPA Target\");\n\t\toutputTable.setColumnTitle(2, \"# All Correct\");\n\t\toutputTable.setColumnTitle(3, \"# One or More Correct\");\n\t\toutputTable.setColumnTitle(4, \"# Same Error\");\n\t\toutputTable.setColumnTitle(5, \"# Different Errors\");\n\t\toutputTable.setColumnTitle(6, \"Avg Distance\");\n\t\tcontext.put(tableOutput, outputTable);\n\t}","code":"@Override\n\tpublic void operate(OpContext context) throws ProcessingException {\n\t\tfinal TableDataSource table = (TableDataSource)context.get(tableInput);\n\t\tint ipaTidx = super.getColumnIndex(table, SystemTierType.IPATarget.getName());\n\t\tif(ipaTidx < 0) {\n\t\t\tthrow new ProcessingException(null, \"Table has no \" + SystemTierType.IPATarget.getName() + \" column.\");\n\t\t}\n\t\tint ipaAidx = super.getColumnIndex(table, SystemTierType.IPAActual.getName());\n\t\tif(ipaAidx < 0) {\n\t\t\tthrow new ProcessingException(null, \"Table has no \" + SystemTierType.IPAActual.getName() + \" column.\");\n\t\t}\n\t\n\t\n\t\tint sessionIdx = super.getColumnIndex(table, \"Session\");\n\t\tboolean ignoreDiacritics = isIgnoreDiacritics();\n\t\tif(context.containsKey(\"ignoreDiacritics\")) {\n\t\t\tignoreDiacritics = (boolean)context.get(\"ignoreDiacritics\");\n\t\t}\n\t\tfinal Map<GroupKey, IpaTernaryTree<List<IPATranscript>>> tokenCounts =\n\t\t\t\tnew LinkedHashMap<>();\n\t\tfor(int row = 0; row < table.getRowCount(); row++) {\n\t\t\tcheckCanceled();\n\t\t\tfinal Object groupVal =\n\t\t\t\t\t(sessionIdx >= 0 ? table.getValueAt(row, sessionIdx) : \"*\");\n\t\t\tfinal GroupKey groupKey = new GroupKey(groupVal, ignoreDiacritics);\n\t\t\tIpaTernaryTree<List<IPATranscript>> tokenCount =\n\t\t\t\t\ttokenCounts.get(groupKey);\n\t\t\tif(tokenCount == null) {\n\t\t\t\ttokenCount = new IpaTernaryTree<>();\n\t\t\t\ttokenCounts.put(groupKey, tokenCount);\n\t\t\t}\n\t\t\tIPATranscript ipaT =\n\t\t\t\t\tIPATranscript.class.cast(table.getValueAt(row, ipaTidx));\n\t\t\tIPATranscript ipaA =\n\t\t\t\t\tIPATranscript.class.cast(table.getValueAt(row, ipaAidx));\n\t\t\tif(ignoreDiacritics) {\n\t\t\t\tipaT = ipaT.removePunctuation().stripDiacritics();\n\t\t\t\tipaA = ipaA.removePunctuation().stripDiacritics();\n\t\t\t}\n\t\t\tList<IPATranscript> productions = tokenCount.get(ipaT);\n\t\t\tif(productions == null) {\n\t\t\t\tproductions = new ArrayList<>();\n\t\t\t\ttokenCount.put(ipaT, productions);\n\t\t\t}\n\t\t\tproductions.add(ipaA);\n\t\t}\n\t\tfinal DefaultTableDataSource outputTable = new DefaultTableDataSource();\n\t\tfor(GroupKey groupKey:tokenCounts.keySet()) {\n\t\t\tfinal Object[] rowData = new Object[7];\n\t\t\n\t\t\tint numRepatedWords = 0;\n\t\t\tint numAllCorrect = 0;\n\t\t\tint numOneOrMoreCorrect = 0;\n\t\t\tint numSameError = 0;\n\t\t\tint numDifferentErrors = 0;\n\t\t\tfloat sumOfAvgDistances = 0;\n\t\t\tfinal IpaTernaryTree<List<IPATranscript>> tokenCount = tokenCounts.get(groupKey);\n\t\t\tfinal List<IPATranscript> repeatedTokens =\n\t\t\t\t\ttokenCount.keySet().stream()\n\t\t\t\t\t\t.filter( (ipa) -> tokenCount.get(ipa).size() > 1 )\n\t\t\t\t\t\t.collect(Collectors.toList());\n\t\t\tnumRepatedWords = repeatedTokens.size();\n\t\t\tfor(IPATranscript ipa:repeatedTokens) {\n\t\t\t\tcheckCanceled();\n\t\t\t\tint numCorrect = 0;\n\t\t\t\tfinal List<IPATranscript> productions = tokenCount.get(ipa);\n\t\t\t\tfinal Set<IPATranscript> distinctProductions = new LinkedHashSet<>(productions);\n\t\t\t\tfor(IPATranscript production:tokenCount.get(ipa)) {\n\t\t\t\t\tif(TableUtils.checkEquals(ipa, production, false, ignoreDiacritics)) {\n\t\t\t\t\t\t++numCorrect;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif(numCorrect == productions.size()) {\n\t\t\t\t\t++numAllCorrect;\n\t\t\t\t} else {\n\t\t\t\t\tif(numCorrect > 0 && numCorrect < productions.size()) {\n\t\t\t\t\t\t++numOneOrMoreCorrect;\n\t\t\t\t\t}\n\t\t\t\t\tdistinctProductions.remove(ipa);\n\t\t\t\t\tif(distinctProductions.size() == 1) {\n\t\t\t\t\t\t++numSameError;\n\t\t\t\t\t} else {\n\t\t\t\t\t\t++numDifferentErrors;\n\t\t\t\t\t}\n\t\t\t\t\tint totalDistance = 0;\n\t\t\t\t\tfor(IPATranscript production:productions) {\n\t\t\t\t\t\ttotalDistance += LevenshteinDistance.distance(ipa, production);\n\t\t\t\t\t}\n\t\t\t\t\tfloat avg = ((float)totalDistance)\/((float)productions.size());\n\t\t\t\t\tsumOfAvgDistances += avg;\n\t\t\t\t}\n\t\t\t}\n\t\t\n\t\t\trowData[0] = groupKey.key;\n\t\t\trowData[1] = numRepatedWords;\n\t\t\trowData[2] = numAllCorrect;\n\t\t\trowData[3] = numOneOrMoreCorrect;\n\t\t\trowData[4] = numSameError;\n\t\t\trowData[5] = numDifferentErrors;\n\t\t\trowData[6] = sumOfAvgDistances \/ numRepatedWords;\n\t\t\toutputTable.addRow(rowData);\n\t\t}\n\t\toutputTable.setColumnTitle(0, \"Session\");\n\t\toutputTable.setColumnTitle(1, \"# Repeated IPA Target\");\n\t\toutputTable.setColumnTitle(2, \"# All Correct\");\n\t\toutputTable.setColumnTitle(3, \"# One or More Correct\");\n\t\toutputTable.setColumnTitle(4, \"# Same Error\");\n\t\toutputTable.setColumnTitle(5, \"# Different Errors\");\n\t\toutputTable.setColumnTitle(6, \"Avg Distance\");\n\t\tcontext.put(tableOutput, outputTable);\n\t}","cleancode":"@override public void operate(opcontext context) throws processingexception { final tabledatasource table = (tabledatasource)context.get(tableinput); int ipatidx = super.getcolumnindex(table, systemtiertype.ipatarget.getname()); if(ipatidx < 0) { throw new processingexception(null, \"table has no \" + systemtiertype.ipatarget.getname() + \" column.\"); } int ipaaidx = super.getcolumnindex(table, systemtiertype.ipaactual.getname()); if(ipaaidx < 0) { throw new processingexception(null, \"table has no \" + systemtiertype.ipaactual.getname() + \" column.\"); } int sessionidx = super.getcolumnindex(table, \"session\"); boolean ignorediacritics = isignorediacritics(); if(context.containskey(\"ignorediacritics\")) { ignorediacritics = (boolean)context.get(\"ignorediacritics\"); } final map<groupkey, ipaternarytree<list<ipatranscript>>> tokencounts = new linkedhashmap<>(); for(int row = 0; row < table.getrowcount(); row++) { checkcanceled(); final object groupval = (sessionidx >= 0 ? table.getvalueat(row, sessionidx) : \"*\"); final groupkey groupkey = new groupkey(groupval, ignorediacritics); ipaternarytree<list<ipatranscript>> tokencount = tokencounts.get(groupkey); if(tokencount == null) { tokencount = new ipaternarytree<>(); tokencounts.put(groupkey, tokencount); } ipatranscript ipat = ipatranscript.class.cast(table.getvalueat(row, ipatidx)); ipatranscript ipaa = ipatranscript.class.cast(table.getvalueat(row, ipaaidx)); if(ignorediacritics) { ipat = ipat.removepunctuation().stripdiacritics(); ipaa = ipaa.removepunctuation().stripdiacritics(); } list<ipatranscript> productions = tokencount.get(ipat); if(productions == null) { productions = new arraylist<>(); tokencount.put(ipat, productions); } productions.add(ipaa); } final defaulttabledatasource outputtable = new defaulttabledatasource(); for(groupkey groupkey:tokencounts.keyset()) { final object[] rowdata = new object[7]; int numrepatedwords = 0; int numallcorrect = 0; int numoneormorecorrect = 0; int numsameerror = 0; int numdifferenterrors = 0; float sumofavgdistances = 0; final ipaternarytree<list<ipatranscript>> tokencount = tokencounts.get(groupkey); final list<ipatranscript> repeatedtokens = tokencount.keyset().stream() .filter( (ipa) -> tokencount.get(ipa).size() > 1 ) .collect(collectors.tolist()); numrepatedwords = repeatedtokens.size(); for(ipatranscript ipa:repeatedtokens) { checkcanceled(); int numcorrect = 0; final list<ipatranscript> productions = tokencount.get(ipa); final set<ipatranscript> distinctproductions = new linkedhashset<>(productions); for(ipatranscript production:tokencount.get(ipa)) { if(tableutils.checkequals(ipa, production, false, ignorediacritics)) { ++numcorrect; } } if(numcorrect == productions.size()) { ++numallcorrect; } else { if(numcorrect > 0 && numcorrect < productions.size()) { ++numoneormorecorrect; } distinctproductions.remove(ipa); if(distinctproductions.size() == 1) { ++numsameerror; } else { ++numdifferenterrors; } int totaldistance = 0; for(ipatranscript production:productions) { totaldistance += levenshteindistance.distance(ipa, production); } float avg = ((float)totaldistance)\/((float)productions.size()); sumofavgdistances += avg; } } rowdata[0] = groupkey.key; rowdata[1] = numrepatedwords; rowdata[2] = numallcorrect; rowdata[3] = numoneormorecorrect; rowdata[4] = numsameerror; rowdata[5] = numdifferenterrors; rowdata[6] = sumofavgdistances \/ numrepatedwords; outputtable.addrow(rowdata); } outputtable.setcolumntitle(0, \"session\"); outputtable.setcolumntitle(1, \"# repeated ipa target\"); outputtable.setcolumntitle(2, \"# all correct\"); outputtable.setcolumntitle(3, \"# one or more correct\"); outputtable.setcolumntitle(4, \"# same error\"); outputtable.setcolumntitle(5, \"# different errors\"); outputtable.setcolumntitle(6, \"avg distance\"); context.put(tableoutput, outputtable); }","comment":"\/\/ group by session if info is available \/\/ todo make this an option\n\/\/ produce table\n\/\/ append row to table","repo":"phon-ca\/phon","code_context_2":"throw new ProcessingException(null, \"Table has no \" + SystemTierType.IPAActual.getName() + \" column.\");\n}\n\/\/ group by session if info is available\n\/\/ TODO make this an option\nint sessionIdx = super.getColumnIndex(table, \"Session\");\nboolean ignoreDiacritics = isIgnoreDiacritics();\n\nfor(GroupKey groupKey:tokenCounts.keySet()) {\nfinal Object[] rowData = new Object[7];\n\/\/ produce table\nint numRepatedWords = 0;\nint numAllCorrect = 0;\n\n}\n}\n\/\/ append row to table\nrowData[0] = groupKey.key;\nrowData[1] = numRepatedWords;","code_context_10":"public void operate(OpContext context) throws ProcessingException {\nfinal TableDataSource table = (TableDataSource)context.get(tableInput);\nint ipaTidx = super.getColumnIndex(table, SystemTierType.IPATarget.getName());\nif(ipaTidx < 0) {\nthrow new ProcessingException(null, \"Table has no \" + SystemTierType.IPATarget.getName() + \" column.\");\n}\nint ipaAidx = super.getColumnIndex(table, SystemTierType.IPAActual.getName());\nif(ipaAidx < 0) {\nthrow new ProcessingException(null, \"Table has no \" + SystemTierType.IPAActual.getName() + \" column.\");\n}\n\/\/ group by session if info is available\n\/\/ TODO make this an option\nint sessionIdx = super.getColumnIndex(table, \"Session\");\nboolean ignoreDiacritics = isIgnoreDiacritics();\nif(context.containsKey(\"ignoreDiacritics\")) {\nignoreDiacritics = (boolean)context.get(\"ignoreDiacritics\");\n}\nfinal Map<GroupKey, IpaTernaryTree<List<IPATranscript>>> tokenCounts =\nnew LinkedHashMap<>();\nfor(int row = 0; row < table.getRowCount(); row++) {\ncheckCanceled();\nfinal Object groupVal =\n\nList<IPATranscript> productions = tokenCount.get(ipaT);\nif(productions == null) {\nproductions = new ArrayList<>();\ntokenCount.put(ipaT, productions);\n}\nproductions.add(ipaA);\n}\nfinal DefaultTableDataSource outputTable = new DefaultTableDataSource();\nfor(GroupKey groupKey:tokenCounts.keySet()) {\nfinal Object[] rowData = new Object[7];\n\/\/ produce table\nint numRepatedWords = 0;\nint numAllCorrect = 0;\nint numOneOrMoreCorrect = 0;\nint numSameError = 0;\nint numDifferentErrors = 0;\nfloat sumOfAvgDistances = 0;\nfinal IpaTernaryTree<List<IPATranscript>> tokenCount = tokenCounts.get(groupKey);\nfinal List<IPATranscript> repeatedTokens =\ntokenCount.keySet().stream()\n.filter( (ipa) -> tokenCount.get(ipa).size() > 1 )\n\n++numDifferentErrors;\n}\nint totalDistance = 0;\nfor(IPATranscript production:productions) {\ntotalDistance += LevenshteinDistance.distance(ipa, production);\n}\nfloat avg = ((float)totalDistance)\/((float)productions.size());\nsumOfAvgDistances += avg;\n}\n}\n\/\/ append row to table\nrowData[0] = groupKey.key;\nrowData[1] = numRepatedWords;\nrowData[2] = numAllCorrect;\nrowData[3] = numOneOrMoreCorrect;\nrowData[4] = numSameError;\nrowData[5] = numDifferentErrors;\nrowData[6] = sumOfAvgDistances \/ numRepatedWords;\noutputTable.addRow(rowData);\n}\noutputTable.setColumnTitle(0, \"Session\");","code_context_20":"@Override\npublic void operate(OpContext context) throws ProcessingException {\nfinal TableDataSource table = (TableDataSource)context.get(tableInput);\nint ipaTidx = super.getColumnIndex(table, SystemTierType.IPATarget.getName());\nif(ipaTidx < 0) {\nthrow new ProcessingException(null, \"Table has no \" + SystemTierType.IPATarget.getName() + \" column.\");\n}\nint ipaAidx = super.getColumnIndex(table, SystemTierType.IPAActual.getName());\nif(ipaAidx < 0) {\nthrow new ProcessingException(null, \"Table has no \" + SystemTierType.IPAActual.getName() + \" column.\");\n}\n\/\/ group by session if info is available\n\/\/ TODO make this an option\nint sessionIdx = super.getColumnIndex(table, \"Session\");\nboolean ignoreDiacritics = isIgnoreDiacritics();\nif(context.containsKey(\"ignoreDiacritics\")) {\nignoreDiacritics = (boolean)context.get(\"ignoreDiacritics\");\n}\nfinal Map<GroupKey, IpaTernaryTree<List<IPATranscript>>> tokenCounts =\nnew LinkedHashMap<>();\nfor(int row = 0; row < table.getRowCount(); row++) {\ncheckCanceled();\nfinal Object groupVal =\n(sessionIdx >= 0 ? table.getValueAt(row, sessionIdx) : \"*\");\nfinal GroupKey groupKey = new GroupKey(groupVal, ignoreDiacritics);\nIpaTernaryTree<List<IPATranscript>> tokenCount =\ntokenCounts.get(groupKey);\nif(tokenCount == null) {\ntokenCount = new IpaTernaryTree<>();\ntokenCounts.put(groupKey, tokenCount);\n}\nIPATranscript ipaT =\nIPATranscript.class.cast(table.getValueAt(row, ipaTidx));\n\ntokenCounts.put(groupKey, tokenCount);\n}\nIPATranscript ipaT =\nIPATranscript.class.cast(table.getValueAt(row, ipaTidx));\nIPATranscript ipaA =\nIPATranscript.class.cast(table.getValueAt(row, ipaAidx));\nif(ignoreDiacritics) {\nipaT = ipaT.removePunctuation().stripDiacritics();\nipaA = ipaA.removePunctuation().stripDiacritics();\n}\nList<IPATranscript> productions = tokenCount.get(ipaT);\nif(productions == null) {\nproductions = new ArrayList<>();\ntokenCount.put(ipaT, productions);\n}\nproductions.add(ipaA);\n}\nfinal DefaultTableDataSource outputTable = new DefaultTableDataSource();\nfor(GroupKey groupKey:tokenCounts.keySet()) {\nfinal Object[] rowData = new Object[7];\n\/\/ produce table\nint numRepatedWords = 0;\nint numAllCorrect = 0;\nint numOneOrMoreCorrect = 0;\nint numSameError = 0;\nint numDifferentErrors = 0;\nfloat sumOfAvgDistances = 0;\nfinal IpaTernaryTree<List<IPATranscript>> tokenCount = tokenCounts.get(groupKey);\nfinal List<IPATranscript> repeatedTokens =\ntokenCount.keySet().stream()\n.filter( (ipa) -> tokenCount.get(ipa).size() > 1 )\n.collect(Collectors.toList());\nnumRepatedWords = repeatedTokens.size();\nfor(IPATranscript ipa:repeatedTokens) {\ncheckCanceled();\nint numCorrect = 0;\nfinal List<IPATranscript> productions = tokenCount.get(ipa);\nfinal Set<IPATranscript> distinctProductions = new LinkedHashSet<>(productions);\nfor(IPATranscript production:tokenCount.get(ipa)) {\nif(TableUtils.checkEquals(ipa, production, false, ignoreDiacritics)) {\n++numCorrect;\n\nif(numCorrect == productions.size()) {\n++numAllCorrect;\n} else {\nif(numCorrect > 0 && numCorrect < productions.size()) {\n++numOneOrMoreCorrect;\n}\ndistinctProductions.remove(ipa);\nif(distinctProductions.size() == 1) {\n++numSameError;\n} else {\n++numDifferentErrors;\n}\nint totalDistance = 0;\nfor(IPATranscript production:productions) {\ntotalDistance += LevenshteinDistance.distance(ipa, production);\n}\nfloat avg = ((float)totalDistance)\/((float)productions.size());\nsumOfAvgDistances += avg;\n}\n}\n\/\/ append row to table\nrowData[0] = groupKey.key;\nrowData[1] = numRepatedWords;\nrowData[2] = numAllCorrect;\nrowData[3] = numOneOrMoreCorrect;\nrowData[4] = numSameError;\nrowData[5] = numDifferentErrors;\nrowData[6] = sumOfAvgDistances \/ numRepatedWords;\noutputTable.addRow(rowData);\n}\noutputTable.setColumnTitle(0, \"Session\");\noutputTable.setColumnTitle(1, \"# Repeated IPA Target\");\noutputTable.setColumnTitle(2, \"# All Correct\");\noutputTable.setColumnTitle(3, \"# One or More Correct\");\noutputTable.setColumnTitle(4, \"# Same Error\");\noutputTable.setColumnTitle(5, \"# Different Errors\");\noutputTable.setColumnTitle(6, \"Avg Distance\");\ncontext.put(tableOutput, outputTable);\n}","label":[1,0,0,0]}
{"id":30178,"original_code":"public static String[] split( String value, Font font, int firstLineWidth, int lineWidth ) {\n\t\treturn wrap(value, font, firstLineWidth, lineWidth);\n\t}","code":"public static String[] split( String value, Font font, int firstLineWidth, int lineWidth ) {\n\t\treturn wrap(value, font, firstLineWidth, lineWidth);\n\t}","cleancode":"public static string[] split( string value, font font, int firstlinewidth, int linewidth ) { return wrap(value, font, firstlinewidth, linewidth); }","comment":"\/\/#if polish.midp || polish.usepolishgui \/** * wraps the given string so it fits on the specified lines. * first of al it is splitted at the line-breaks ('\\n'), subsequently the substrings * are splitted when they do not fit on a single line. * * @param value the string which should be splitted * @param font the font which is used to display the font * @param firstlinewidth the allowed width for the first line * @param linewidth the allowed width for all other lines, linewidth >= firstlinewidth * @return the array containing the substrings * @deprecated please use wrap instead * @see #wrap(string, font, int, int) *\/","repo":"mobabel\/MoMeGo","code_context_2":"public static String[] split( String value, Font font, int firstLineWidth, int lineWidth ) {\nreturn wrap(value, font, firstLineWidth, lineWidth);\n}","code_context_10":"public static String[] split( String value, Font font, int firstLineWidth, int lineWidth ) {\nreturn wrap(value, font, firstLineWidth, lineWidth);\n}","code_context_20":"public static String[] split( String value, Font font, int firstLineWidth, int lineWidth ) {\nreturn wrap(value, font, firstLineWidth, lineWidth);\n}","label":[0,0,0,0]}
{"id":13831,"original_code":"private void removeDanglingTransitions(AbstractWorkflow workflow) {\n    if (workflow.getTransitions() == null || workflow.getTransitions().isEmpty()) {\n      return;\n    }\n    Set<String> activityIds = new HashSet<>();\n    for (Activity activity : workflow.getActivities()) {\n      activityIds.add(activity.getId());\n      \/\/ Transitions from Boundary event timers should be included as well\n      \/\/ todo: make generic\n      List<Timer> activityTimers = activity.getTimers();\n      if (activityTimers != null) {\n        for (Timer timer : activityTimers) {\n          if (timer instanceof BoundaryEventTimer) {\n            BoundaryEvent boundaryEvent = ((BoundaryEventTimer) timer).boundaryEvent;\n            activityIds.add(boundaryEvent.getBoundaryId());\n            activityIds.addAll(boundaryEvent.getToTransitionIds());\n          }\n        }\n      }\n    }\n    ListIterator<Transition> transitionIterator = workflow.getTransitions().listIterator();\n    while(transitionIterator.hasNext()){\n      Transition transition = transitionIterator.next();\n      if (!activityIds.contains(transition.getFromId()) || !activityIds.contains(transition.getToId())) {\n        transitionIterator.remove();\n      }\n    }\n  }","code":"private void removeDanglingTransitions(AbstractWorkflow workflow) {\n    if (workflow.getTransitions() == null || workflow.getTransitions().isEmpty()) {\n      return;\n    }\n    Set<String> activityIds = new HashSet<>();\n    for (Activity activity : workflow.getActivities()) {\n      activityIds.add(activity.getId());\n     \n     \n      List<Timer> activityTimers = activity.getTimers();\n      if (activityTimers != null) {\n        for (Timer timer : activityTimers) {\n          if (timer instanceof BoundaryEventTimer) {\n            BoundaryEvent boundaryEvent = ((BoundaryEventTimer) timer).boundaryEvent;\n            activityIds.add(boundaryEvent.getBoundaryId());\n            activityIds.addAll(boundaryEvent.getToTransitionIds());\n          }\n        }\n      }\n    }\n    ListIterator<Transition> transitionIterator = workflow.getTransitions().listIterator();\n    while(transitionIterator.hasNext()){\n      Transition transition = transitionIterator.next();\n      if (!activityIds.contains(transition.getFromId()) || !activityIds.contains(transition.getToId())) {\n        transitionIterator.remove();\n      }\n    }\n  }","cleancode":"private void removedanglingtransitions(abstractworkflow workflow) { if (workflow.gettransitions() == null || workflow.gettransitions().isempty()) { return; } set<string> activityids = new hashset<>(); for (activity activity : workflow.getactivities()) { activityids.add(activity.getid()); list<timer> activitytimers = activity.gettimers(); if (activitytimers != null) { for (timer timer : activitytimers) { if (timer instanceof boundaryeventtimer) { boundaryevent boundaryevent = ((boundaryeventtimer) timer).boundaryevent; activityids.add(boundaryevent.getboundaryid()); activityids.addall(boundaryevent.gettotransitionids()); } } } } listiterator<transition> transitioniterator = workflow.gettransitions().listiterator(); while(transitioniterator.hasnext()){ transition transition = transitioniterator.next(); if (!activityids.contains(transition.getfromid()) || !activityids.contains(transition.gettoid())) { transitioniterator.remove(); } } }","comment":"\/** * removes transitions to or from a missing activity, probably due to the activity not being imported. *\/\n\/\/ transitions from boundary event timers should be included as well \/\/ todo: make generic","repo":"pharod\/effektif","code_context_2":"private void removeDanglingTransitions(AbstractWorkflow workflow) {\nif (workflow.getTransitions() == null || workflow.getTransitions().isEmpty()) {\nreturn;\n}\nSet<String> activityIds = new HashSet<>();\nfor (Activity activity : workflow.getActivities()) {\nactivityIds.add(activity.getId());\n\/\/ Transitions from Boundary event timers should be included as well\n\/\/ todo: make generic\nList<Timer> activityTimers = activity.getTimers();\nif (activityTimers != null) {\nfor (Timer timer : activityTimers) {\nif (timer instanceof BoundaryEventTimer) {\nBoundaryEvent boundaryEvent = ((BoundaryEventTimer) timer).boundaryEvent;\nactivityIds.add(boundaryEvent.getBoundaryId());\nactivityIds.addAll(boundaryEvent.getToTransitionIds());\n}\n}\n}\n}\nListIterator<Transition> transitionIterator = workflow.getTransitions().listIterator();\nwhile(transitionIterator.hasNext()){\nTransition transition = transitionIterator.next();\nif (!activityIds.contains(transition.getFromId()) || !activityIds.contains(transition.getToId())) {\ntransitionIterator.remove();\n}\n}\n}\n\nfor (Activity activity : workflow.getActivities()) {\nactivityIds.add(activity.getId());\n\/\/ Transitions from Boundary event timers should be included as well\n\/\/ todo: make generic\nList<Timer> activityTimers = activity.getTimers();\nif (activityTimers != null) {","code_context_10":"private void removeDanglingTransitions(AbstractWorkflow workflow) {\nif (workflow.getTransitions() == null || workflow.getTransitions().isEmpty()) {\nreturn;\n}\nSet<String> activityIds = new HashSet<>();\nfor (Activity activity : workflow.getActivities()) {\nactivityIds.add(activity.getId());\n\/\/ Transitions from Boundary event timers should be included as well\n\/\/ todo: make generic\nList<Timer> activityTimers = activity.getTimers();\nif (activityTimers != null) {\nfor (Timer timer : activityTimers) {\nif (timer instanceof BoundaryEventTimer) {\nBoundaryEvent boundaryEvent = ((BoundaryEventTimer) timer).boundaryEvent;\nactivityIds.add(boundaryEvent.getBoundaryId());\nactivityIds.addAll(boundaryEvent.getToTransitionIds());\n}\n}\n}\n}\nListIterator<Transition> transitionIterator = workflow.getTransitions().listIterator();\nwhile(transitionIterator.hasNext()){\nTransition transition = transitionIterator.next();\nif (!activityIds.contains(transition.getFromId()) || !activityIds.contains(transition.getToId())) {\ntransitionIterator.remove();\n}\n}\n}\n\nprivate void removeDanglingTransitions(AbstractWorkflow workflow) {\nif (workflow.getTransitions() == null || workflow.getTransitions().isEmpty()) {\nreturn;\n}\nSet<String> activityIds = new HashSet<>();\nfor (Activity activity : workflow.getActivities()) {\nactivityIds.add(activity.getId());\n\/\/ Transitions from Boundary event timers should be included as well\n\/\/ todo: make generic\nList<Timer> activityTimers = activity.getTimers();\nif (activityTimers != null) {\nfor (Timer timer : activityTimers) {\nif (timer instanceof BoundaryEventTimer) {\nBoundaryEvent boundaryEvent = ((BoundaryEventTimer) timer).boundaryEvent;\nactivityIds.add(boundaryEvent.getBoundaryId());\nactivityIds.addAll(boundaryEvent.getToTransitionIds());\n}\n}\n}","code_context_20":"private void removeDanglingTransitions(AbstractWorkflow workflow) {\nif (workflow.getTransitions() == null || workflow.getTransitions().isEmpty()) {\nreturn;\n}\nSet<String> activityIds = new HashSet<>();\nfor (Activity activity : workflow.getActivities()) {\nactivityIds.add(activity.getId());\n\/\/ Transitions from Boundary event timers should be included as well\n\/\/ todo: make generic\nList<Timer> activityTimers = activity.getTimers();\nif (activityTimers != null) {\nfor (Timer timer : activityTimers) {\nif (timer instanceof BoundaryEventTimer) {\nBoundaryEvent boundaryEvent = ((BoundaryEventTimer) timer).boundaryEvent;\nactivityIds.add(boundaryEvent.getBoundaryId());\nactivityIds.addAll(boundaryEvent.getToTransitionIds());\n}\n}\n}\n}\nListIterator<Transition> transitionIterator = workflow.getTransitions().listIterator();\nwhile(transitionIterator.hasNext()){\nTransition transition = transitionIterator.next();\nif (!activityIds.contains(transition.getFromId()) || !activityIds.contains(transition.getToId())) {\ntransitionIterator.remove();\n}\n}\n}\n\nprivate void removeDanglingTransitions(AbstractWorkflow workflow) {\nif (workflow.getTransitions() == null || workflow.getTransitions().isEmpty()) {\nreturn;\n}\nSet<String> activityIds = new HashSet<>();\nfor (Activity activity : workflow.getActivities()) {\nactivityIds.add(activity.getId());\n\/\/ Transitions from Boundary event timers should be included as well\n\/\/ todo: make generic\nList<Timer> activityTimers = activity.getTimers();\nif (activityTimers != null) {\nfor (Timer timer : activityTimers) {\nif (timer instanceof BoundaryEventTimer) {\nBoundaryEvent boundaryEvent = ((BoundaryEventTimer) timer).boundaryEvent;\nactivityIds.add(boundaryEvent.getBoundaryId());\nactivityIds.addAll(boundaryEvent.getToTransitionIds());\n}\n}\n}\n}\nListIterator<Transition> transitionIterator = workflow.getTransitions().listIterator();\nwhile(transitionIterator.hasNext()){\nTransition transition = transitionIterator.next();\nif (!activityIds.contains(transition.getFromId()) || !activityIds.contains(transition.getToId())) {\ntransitionIterator.remove();\n}\n}\n}","label":[1,0,0,0]}
{"id":14220,"original_code":"@Override\n  public void startElement (String uri, String name, String qName, Attributes atts) throws SAXException {\n    try {\n    \/\/log.debug(\"S: '\" + uri + \"' \" + qName);\n    \/\/ ----- <xfml> -----------------------------------------------------------\n    if (EL_XFML.equals(qName)) {\n      String version = atts.getValue(\"version\");\n      if (version == null)\n        log.warn(\"No version attribute on 'xfml' element\");\n      if (!\"1.0\".equals(version))\n        log.warn(\"Unsupported XFML version: \" + version);\n      String mapurl = atts.getValue(\"url\");\n      if (mapurl == null)\n        log.warn(\"No url attribute on 'xfml' element\");\n      else {\n        try {\n          map_uri = new URILocator(mapurl);\n          TopicMapStoreIF store = topicmap.getStore();\n          if (store instanceof AbstractTopicMapStore && store.getBaseAddress() == null)\n            ((AbstractTopicMapStore) store).setBaseAddress(map_uri);\n          doc_address = map_uri;\n          \/\/ Add this document to the list of processed documents.\n          processed_documents_accumulated.add(getBaseAddress());\n        } catch (MalformedURLException e) {\n          log.warn(\"Invalid xfml base URL: \" + mapurl);\n        }\n      }\n      \/\/ FIXME: what to do about language?\n    }\n    \/\/ ----- <facet> ----------------------------------------------------------\n    else if (EL_FACET.equals(qName)) {\n      String id = atts.getValue(\"id\");\n      \/\/ FIXME: complain if no id\n      current_topic = builder.makeTopic();\n      registerSourceLocator(current_topic, id);\n      keep_content = true;\n    }\n    \/\/ ----- <topic> ----------------------------------------------------------\n    else if (EL_TOPIC.equals(qName)) {\n      String id = atts.getValue(\"id\");\n      \/\/ FIXME: complain if no id\n      current_topic = builder.makeTopic();\n      registerSourceLocator(current_topic, id);\n      String parentid = atts.getValue(\"parentTopicid\");\n      if (parentid == null)\n        parentid = atts.getValue(\"facetid\");\n      \/\/ FIXME: complain if no refs\n      TopicIF parent = resolveTopicRef(\"#\" + parentid);\n      parentBuilder.makeAssociation(parent, current_topic);\n    }\n    \/\/ ----- <page> -----------------------------------------------------------\n    else if (EL_PAGE.equals(qName)) {\n      String url = atts.getValue(\"url\");\n      \/\/ FIXME: complain if no url\n      current_topic = builder.makeTopic();\n      current_topic.addSubjectLocator(createLocator(url));\n    }\n    \/\/ ----- <occurrence>------------------------------------------------------\n    else if (EL_OCCURRENCE.equals(qName)) {\n      String topicid = atts.getValue(\"topicid\");\n      \/\/ FIXME: complain if none\n      TopicIF subject = resolveTopicRef(\"#\" + topicid);\n      occursBuilder.makeAssociation(subject, current_topic);\n    }\n    \/\/ ----- <name> -----------------------------------------------------------\n    \/\/ ----- <psi> ------------------------------------------------------------\n    \/\/ ----- <description> ----------------------------------------------------\n    \/\/ ----- <title> ----------------------------------------------------------\n    \/\/ ----- <connect> --------------------------------------------------------\n    else if (EL_NAME.equals(qName) || EL_PSI.equals(qName) || EL_DESCRIPTION.equals(qName) ||\n            EL_TITLE.equals(qName) || EL_CONNECT.equals(qName)) \n      keep_content = true;   \n    } catch (RuntimeException e) {\n      e.printStackTrace();\n      throw e;\n    }\n  }","code":"@Override\n  public void startElement (String uri, String name, String qName, Attributes atts) throws SAXException {\n    try {\n   \n   \n    if (EL_XFML.equals(qName)) {\n      String version = atts.getValue(\"version\");\n      if (version == null)\n        log.warn(\"No version attribute on 'xfml' element\");\n      if (!\"1.0\".equals(version))\n        log.warn(\"Unsupported XFML version: \" + version);\n      String mapurl = atts.getValue(\"url\");\n      if (mapurl == null)\n        log.warn(\"No url attribute on 'xfml' element\");\n      else {\n        try {\n          map_uri = new URILocator(mapurl);\n          TopicMapStoreIF store = topicmap.getStore();\n          if (store instanceof AbstractTopicMapStore && store.getBaseAddress() == null)\n            ((AbstractTopicMapStore) store).setBaseAddress(map_uri);\n          doc_address = map_uri;\n         \n          processed_documents_accumulated.add(getBaseAddress());\n        } catch (MalformedURLException e) {\n          log.warn(\"Invalid xfml base URL: \" + mapurl);\n        }\n      }\n     \n    }\n   \n    else if (EL_FACET.equals(qName)) {\n      String id = atts.getValue(\"id\");\n     \n      current_topic = builder.makeTopic();\n      registerSourceLocator(current_topic, id);\n      keep_content = true;\n    }\n   \n    else if (EL_TOPIC.equals(qName)) {\n      String id = atts.getValue(\"id\");\n     \n      current_topic = builder.makeTopic();\n      registerSourceLocator(current_topic, id);\n      String parentid = atts.getValue(\"parentTopicid\");\n      if (parentid == null)\n        parentid = atts.getValue(\"facetid\");\n     \n      TopicIF parent = resolveTopicRef(\"#\" + parentid);\n      parentBuilder.makeAssociation(parent, current_topic);\n    }\n   \n    else if (EL_PAGE.equals(qName)) {\n      String url = atts.getValue(\"url\");\n     \n      current_topic = builder.makeTopic();\n      current_topic.addSubjectLocator(createLocator(url));\n    }\n   \n    else if (EL_OCCURRENCE.equals(qName)) {\n      String topicid = atts.getValue(\"topicid\");\n     \n      TopicIF subject = resolveTopicRef(\"#\" + topicid);\n      occursBuilder.makeAssociation(subject, current_topic);\n    }\n   \n   \n   \n   \n   \n    else if (EL_NAME.equals(qName) || EL_PSI.equals(qName) || EL_DESCRIPTION.equals(qName) ||\n            EL_TITLE.equals(qName) || EL_CONNECT.equals(qName)) \n      keep_content = true;   \n    } catch (RuntimeException e) {\n      e.printStackTrace();\n      throw e;\n    }\n  }","cleancode":"@override public void startelement (string uri, string name, string qname, attributes atts) throws saxexception { try { if (el_xfml.equals(qname)) { string version = atts.getvalue(\"version\"); if (version == null) log.warn(\"no version attribute on 'xfml' element\"); if (!\"1.0\".equals(version)) log.warn(\"unsupported xfml version: \" + version); string mapurl = atts.getvalue(\"url\"); if (mapurl == null) log.warn(\"no url attribute on 'xfml' element\"); else { try { map_uri = new urilocator(mapurl); topicmapstoreif store = topicmap.getstore(); if (store instanceof abstracttopicmapstore && store.getbaseaddress() == null) ((abstracttopicmapstore) store).setbaseaddress(map_uri); doc_address = map_uri; processed_documents_accumulated.add(getbaseaddress()); } catch (malformedurlexception e) { log.warn(\"invalid xfml base url: \" + mapurl); } } } else if (el_facet.equals(qname)) { string id = atts.getvalue(\"id\"); current_topic = builder.maketopic(); registersourcelocator(current_topic, id); keep_content = true; } else if (el_topic.equals(qname)) { string id = atts.getvalue(\"id\"); current_topic = builder.maketopic(); registersourcelocator(current_topic, id); string parentid = atts.getvalue(\"parenttopicid\"); if (parentid == null) parentid = atts.getvalue(\"facetid\"); topicif parent = resolvetopicref(\"#\" + parentid); parentbuilder.makeassociation(parent, current_topic); } else if (el_page.equals(qname)) { string url = atts.getvalue(\"url\"); current_topic = builder.maketopic(); current_topic.addsubjectlocator(createlocator(url)); } else if (el_occurrence.equals(qname)) { string topicid = atts.getvalue(\"topicid\"); topicif subject = resolvetopicref(\"#\" + topicid); occursbuilder.makeassociation(subject, current_topic); } else if (el_name.equals(qname) || el_psi.equals(qname) || el_description.equals(qname) || el_title.equals(qname) || el_connect.equals(qname)) keep_content = true; } catch (runtimeexception e) { e.printstacktrace(); throw e; } }","comment":"\/\/log.debug(\"s: '\" + uri + \"' \" + qname); \/\/ ----- <xfml> -----------------------------------------------------------\n\/\/ add this document to the list of processed documents.\n\/\/ fixme: what to do about language?\n\/\/ ----- <facet> ----------------------------------------------------------\n\/\/ fixme: complain if no id\n\/\/ ----- <topic> ----------------------------------------------------------\n\/\/ fixme: complain if no id\n\/\/ fixme: complain if no refs\n\/\/ ----- <page> -----------------------------------------------------------\n\/\/ fixme: complain if no url\n\/\/ ----- <occurrence>------------------------------------------------------\n\/\/ fixme: complain if none\n\/\/ ----- <name> ----------------------------------------------------------- \/\/ ----- <psi> ------------------------------------------------------------ \/\/ ----- <description> ---------------------------------------------------- \/\/ ----- <title> ---------------------------------------------------------- \/\/ ----- <connect> --------------------------------------------------------","repo":"ontopia\/ontopia","code_context_2":"public void startElement (String uri, String name, String qName, Attributes atts) throws SAXException {\ntry {\n\/\/log.debug(\"S: '\" + uri + \"' \" + qName);\n\/\/ ----- <xfml> -----------------------------------------------------------\nif (EL_XFML.equals(qName)) {\nString version = atts.getValue(\"version\");\n\n((AbstractTopicMapStore) store).setBaseAddress(map_uri);\ndoc_address = map_uri;\n\/\/ Add this document to the list of processed documents.\nprocessed_documents_accumulated.add(getBaseAddress());\n} catch (MalformedURLException e) {\n\n}\n}\n\/\/ FIXME: what to do about language?\n}\n\/\/ ----- <facet> ----------------------------------------------------------\n\n\/\/ FIXME: what to do about language?\n}\n\/\/ ----- <facet> ----------------------------------------------------------\nelse if (EL_FACET.equals(qName)) {\nString id = atts.getValue(\"id\");\n\nelse if (EL_FACET.equals(qName)) {\nString id = atts.getValue(\"id\");\n\/\/ FIXME: complain if no id\ncurrent_topic = builder.makeTopic();\nregisterSourceLocator(current_topic, id);\n\nkeep_content = true;\n}\n\/\/ ----- <topic> ----------------------------------------------------------\nelse if (EL_TOPIC.equals(qName)) {\nString id = atts.getValue(\"id\");\n\nelse if (EL_FACET.equals(qName)) {\nString id = atts.getValue(\"id\");\n\/\/ FIXME: complain if no id\ncurrent_topic = builder.makeTopic();\nregisterSourceLocator(current_topic, id);\n\nif (parentid == null)\nparentid = atts.getValue(\"facetid\");\n\/\/ FIXME: complain if no refs\nTopicIF parent = resolveTopicRef(\"#\" + parentid);\nparentBuilder.makeAssociation(parent, current_topic);\n\nparentBuilder.makeAssociation(parent, current_topic);\n}\n\/\/ ----- <page> -----------------------------------------------------------\nelse if (EL_PAGE.equals(qName)) {\nString url = atts.getValue(\"url\");\n\nelse if (EL_PAGE.equals(qName)) {\nString url = atts.getValue(\"url\");\n\/\/ FIXME: complain if no url\ncurrent_topic = builder.makeTopic();\ncurrent_topic.addSubjectLocator(createLocator(url));\n\ncurrent_topic.addSubjectLocator(createLocator(url));\n}\n\/\/ ----- <occurrence>------------------------------------------------------\nelse if (EL_OCCURRENCE.equals(qName)) {\nString topicid = atts.getValue(\"topicid\");\n\nelse if (EL_OCCURRENCE.equals(qName)) {\nString topicid = atts.getValue(\"topicid\");\n\/\/ FIXME: complain if none\nTopicIF subject = resolveTopicRef(\"#\" + topicid);\noccursBuilder.makeAssociation(subject, current_topic);\n\noccursBuilder.makeAssociation(subject, current_topic);\n}\n\/\/ ----- <name> -----------------------------------------------------------\n\/\/ ----- <psi> ------------------------------------------------------------\n\/\/ ----- <description> ----------------------------------------------------\n\/\/ ----- <title> ----------------------------------------------------------\n\/\/ ----- <connect> --------------------------------------------------------\nelse if (EL_NAME.equals(qName) || EL_PSI.equals(qName) || EL_DESCRIPTION.equals(qName) ||\nEL_TITLE.equals(qName) || EL_CONNECT.equals(qName))","code_context_10":"@Override\npublic void startElement (String uri, String name, String qName, Attributes atts) throws SAXException {\ntry {\n\/\/log.debug(\"S: '\" + uri + \"' \" + qName);\n\/\/ ----- <xfml> -----------------------------------------------------------\nif (EL_XFML.equals(qName)) {\nString version = atts.getValue(\"version\");\nif (version == null)\nlog.warn(\"No version attribute on 'xfml' element\");\nif (!\"1.0\".equals(version))\nlog.warn(\"Unsupported XFML version: \" + version);\nString mapurl = atts.getValue(\"url\");\nif (mapurl == null)\nlog.warn(\"No url attribute on 'xfml' element\");\nelse {\n\nString mapurl = atts.getValue(\"url\");\nif (mapurl == null)\nlog.warn(\"No url attribute on 'xfml' element\");\nelse {\ntry {\nmap_uri = new URILocator(mapurl);\nTopicMapStoreIF store = topicmap.getStore();\nif (store instanceof AbstractTopicMapStore && store.getBaseAddress() == null)\n((AbstractTopicMapStore) store).setBaseAddress(map_uri);\ndoc_address = map_uri;\n\/\/ Add this document to the list of processed documents.\nprocessed_documents_accumulated.add(getBaseAddress());\n} catch (MalformedURLException e) {\nlog.warn(\"Invalid xfml base URL: \" + mapurl);\n}\n}\n\/\/ FIXME: what to do about language?\n}\n\/\/ ----- <facet> ----------------------------------------------------------\nelse if (EL_FACET.equals(qName)) {\nString id = atts.getValue(\"id\");\n\nTopicMapStoreIF store = topicmap.getStore();\nif (store instanceof AbstractTopicMapStore && store.getBaseAddress() == null)\n((AbstractTopicMapStore) store).setBaseAddress(map_uri);\ndoc_address = map_uri;\n\/\/ Add this document to the list of processed documents.\nprocessed_documents_accumulated.add(getBaseAddress());\n} catch (MalformedURLException e) {\nlog.warn(\"Invalid xfml base URL: \" + mapurl);\n}\n}\n\/\/ FIXME: what to do about language?\n}\n\/\/ ----- <facet> ----------------------------------------------------------\nelse if (EL_FACET.equals(qName)) {\nString id = atts.getValue(\"id\");\n\/\/ FIXME: complain if no id\ncurrent_topic = builder.makeTopic();\nregisterSourceLocator(current_topic, id);\nkeep_content = true;\n}\n\/\/ ----- <topic> ----------------------------------------------------------\n\n((AbstractTopicMapStore) store).setBaseAddress(map_uri);\ndoc_address = map_uri;\n\/\/ Add this document to the list of processed documents.\nprocessed_documents_accumulated.add(getBaseAddress());\n} catch (MalformedURLException e) {\nlog.warn(\"Invalid xfml base URL: \" + mapurl);\n}\n}\n\/\/ FIXME: what to do about language?\n}\n\/\/ ----- <facet> ----------------------------------------------------------\nelse if (EL_FACET.equals(qName)) {\nString id = atts.getValue(\"id\");\n\/\/ FIXME: complain if no id\ncurrent_topic = builder.makeTopic();\nregisterSourceLocator(current_topic, id);\nkeep_content = true;\n}\n\/\/ ----- <topic> ----------------------------------------------------------\nelse if (EL_TOPIC.equals(qName)) {\nString id = atts.getValue(\"id\");\n\nprocessed_documents_accumulated.add(getBaseAddress());\n} catch (MalformedURLException e) {\nlog.warn(\"Invalid xfml base URL: \" + mapurl);\n}\n}\n\/\/ FIXME: what to do about language?\n}\n\/\/ ----- <facet> ----------------------------------------------------------\nelse if (EL_FACET.equals(qName)) {\nString id = atts.getValue(\"id\");\n\/\/ FIXME: complain if no id\ncurrent_topic = builder.makeTopic();\nregisterSourceLocator(current_topic, id);\nkeep_content = true;\n}\n\/\/ ----- <topic> ----------------------------------------------------------\nelse if (EL_TOPIC.equals(qName)) {\nString id = atts.getValue(\"id\");\n\/\/ FIXME: complain if no id\ncurrent_topic = builder.makeTopic();\nregisterSourceLocator(current_topic, id);\n\n\/\/ FIXME: what to do about language?\n}\n\/\/ ----- <facet> ----------------------------------------------------------\nelse if (EL_FACET.equals(qName)) {\nString id = atts.getValue(\"id\");\n\/\/ FIXME: complain if no id\ncurrent_topic = builder.makeTopic();\nregisterSourceLocator(current_topic, id);\nkeep_content = true;\n}\n\/\/ ----- <topic> ----------------------------------------------------------\nelse if (EL_TOPIC.equals(qName)) {\nString id = atts.getValue(\"id\");\n\/\/ FIXME: complain if no id\ncurrent_topic = builder.makeTopic();\nregisterSourceLocator(current_topic, id);\nString parentid = atts.getValue(\"parentTopicid\");\nif (parentid == null)\nparentid = atts.getValue(\"facetid\");\n\/\/ FIXME: complain if no refs\nTopicIF parent = resolveTopicRef(\"#\" + parentid);\n\nprocessed_documents_accumulated.add(getBaseAddress());\n} catch (MalformedURLException e) {\nlog.warn(\"Invalid xfml base URL: \" + mapurl);\n}\n}\n\/\/ FIXME: what to do about language?\n}\n\/\/ ----- <facet> ----------------------------------------------------------\nelse if (EL_FACET.equals(qName)) {\nString id = atts.getValue(\"id\");\n\/\/ FIXME: complain if no id\ncurrent_topic = builder.makeTopic();\nregisterSourceLocator(current_topic, id);\nkeep_content = true;\n}\n\/\/ ----- <topic> ----------------------------------------------------------\nelse if (EL_TOPIC.equals(qName)) {\nString id = atts.getValue(\"id\");\n\/\/ FIXME: complain if no id\ncurrent_topic = builder.makeTopic();\nregisterSourceLocator(current_topic, id);\n\n}\n\/\/ ----- <topic> ----------------------------------------------------------\nelse if (EL_TOPIC.equals(qName)) {\nString id = atts.getValue(\"id\");\n\/\/ FIXME: complain if no id\ncurrent_topic = builder.makeTopic();\nregisterSourceLocator(current_topic, id);\nString parentid = atts.getValue(\"parentTopicid\");\nif (parentid == null)\nparentid = atts.getValue(\"facetid\");\n\/\/ FIXME: complain if no refs\nTopicIF parent = resolveTopicRef(\"#\" + parentid);\nparentBuilder.makeAssociation(parent, current_topic);\n}\n\/\/ ----- <page> -----------------------------------------------------------\nelse if (EL_PAGE.equals(qName)) {\nString url = atts.getValue(\"url\");\n\/\/ FIXME: complain if no url\ncurrent_topic = builder.makeTopic();\ncurrent_topic.addSubjectLocator(createLocator(url));\n}\n\n\/\/ FIXME: complain if no id\ncurrent_topic = builder.makeTopic();\nregisterSourceLocator(current_topic, id);\nString parentid = atts.getValue(\"parentTopicid\");\nif (parentid == null)\nparentid = atts.getValue(\"facetid\");\n\/\/ FIXME: complain if no refs\nTopicIF parent = resolveTopicRef(\"#\" + parentid);\nparentBuilder.makeAssociation(parent, current_topic);\n}\n\/\/ ----- <page> -----------------------------------------------------------\nelse if (EL_PAGE.equals(qName)) {\nString url = atts.getValue(\"url\");\n\/\/ FIXME: complain if no url\ncurrent_topic = builder.makeTopic();\ncurrent_topic.addSubjectLocator(createLocator(url));\n}\n\/\/ ----- <occurrence>------------------------------------------------------\nelse if (EL_OCCURRENCE.equals(qName)) {\nString topicid = atts.getValue(\"topicid\");\n\/\/ FIXME: complain if none\n\nString parentid = atts.getValue(\"parentTopicid\");\nif (parentid == null)\nparentid = atts.getValue(\"facetid\");\n\/\/ FIXME: complain if no refs\nTopicIF parent = resolveTopicRef(\"#\" + parentid);\nparentBuilder.makeAssociation(parent, current_topic);\n}\n\/\/ ----- <page> -----------------------------------------------------------\nelse if (EL_PAGE.equals(qName)) {\nString url = atts.getValue(\"url\");\n\/\/ FIXME: complain if no url\ncurrent_topic = builder.makeTopic();\ncurrent_topic.addSubjectLocator(createLocator(url));\n}\n\/\/ ----- <occurrence>------------------------------------------------------\nelse if (EL_OCCURRENCE.equals(qName)) {\nString topicid = atts.getValue(\"topicid\");\n\/\/ FIXME: complain if none\nTopicIF subject = resolveTopicRef(\"#\" + topicid);\noccursBuilder.makeAssociation(subject, current_topic);\n}\n\nTopicIF parent = resolveTopicRef(\"#\" + parentid);\nparentBuilder.makeAssociation(parent, current_topic);\n}\n\/\/ ----- <page> -----------------------------------------------------------\nelse if (EL_PAGE.equals(qName)) {\nString url = atts.getValue(\"url\");\n\/\/ FIXME: complain if no url\ncurrent_topic = builder.makeTopic();\ncurrent_topic.addSubjectLocator(createLocator(url));\n}\n\/\/ ----- <occurrence>------------------------------------------------------\nelse if (EL_OCCURRENCE.equals(qName)) {\nString topicid = atts.getValue(\"topicid\");\n\/\/ FIXME: complain if none\nTopicIF subject = resolveTopicRef(\"#\" + topicid);\noccursBuilder.makeAssociation(subject, current_topic);\n}\n\/\/ ----- <name> -----------------------------------------------------------\n\/\/ ----- <psi> ------------------------------------------------------------\n\/\/ ----- <description> ----------------------------------------------------\n\/\/ ----- <title> ----------------------------------------------------------\n\n\/\/ ----- <page> -----------------------------------------------------------\nelse if (EL_PAGE.equals(qName)) {\nString url = atts.getValue(\"url\");\n\/\/ FIXME: complain if no url\ncurrent_topic = builder.makeTopic();\ncurrent_topic.addSubjectLocator(createLocator(url));\n}\n\/\/ ----- <occurrence>------------------------------------------------------\nelse if (EL_OCCURRENCE.equals(qName)) {\nString topicid = atts.getValue(\"topicid\");\n\/\/ FIXME: complain if none\nTopicIF subject = resolveTopicRef(\"#\" + topicid);\noccursBuilder.makeAssociation(subject, current_topic);\n}\n\/\/ ----- <name> -----------------------------------------------------------\n\/\/ ----- <psi> ------------------------------------------------------------\n\/\/ ----- <description> ----------------------------------------------------\n\/\/ ----- <title> ----------------------------------------------------------\n\/\/ ----- <connect> --------------------------------------------------------\nelse if (EL_NAME.equals(qName) || EL_PSI.equals(qName) || EL_DESCRIPTION.equals(qName) ||\nEL_TITLE.equals(qName) || EL_CONNECT.equals(qName))\n\ncurrent_topic = builder.makeTopic();\ncurrent_topic.addSubjectLocator(createLocator(url));\n}\n\/\/ ----- <occurrence>------------------------------------------------------\nelse if (EL_OCCURRENCE.equals(qName)) {\nString topicid = atts.getValue(\"topicid\");\n\/\/ FIXME: complain if none\nTopicIF subject = resolveTopicRef(\"#\" + topicid);\noccursBuilder.makeAssociation(subject, current_topic);\n}\n\/\/ ----- <name> -----------------------------------------------------------\n\/\/ ----- <psi> ------------------------------------------------------------\n\/\/ ----- <description> ----------------------------------------------------\n\/\/ ----- <title> ----------------------------------------------------------\n\/\/ ----- <connect> --------------------------------------------------------\nelse if (EL_NAME.equals(qName) || EL_PSI.equals(qName) || EL_DESCRIPTION.equals(qName) ||\nEL_TITLE.equals(qName) || EL_CONNECT.equals(qName))\nkeep_content = true;\n} catch (RuntimeException e) {\ne.printStackTrace();\nthrow e;\n}\n}","code_context_20":"@Override\npublic void startElement (String uri, String name, String qName, Attributes atts) throws SAXException {\ntry {\n\/\/log.debug(\"S: '\" + uri + \"' \" + qName);\n\/\/ ----- <xfml> -----------------------------------------------------------\nif (EL_XFML.equals(qName)) {\nString version = atts.getValue(\"version\");\nif (version == null)\nlog.warn(\"No version attribute on 'xfml' element\");\nif (!\"1.0\".equals(version))\nlog.warn(\"Unsupported XFML version: \" + version);\nString mapurl = atts.getValue(\"url\");\nif (mapurl == null)\nlog.warn(\"No url attribute on 'xfml' element\");\nelse {\ntry {\nmap_uri = new URILocator(mapurl);\nTopicMapStoreIF store = topicmap.getStore();\nif (store instanceof AbstractTopicMapStore && store.getBaseAddress() == null)\n((AbstractTopicMapStore) store).setBaseAddress(map_uri);\ndoc_address = map_uri;\n\/\/ Add this document to the list of processed documents.\nprocessed_documents_accumulated.add(getBaseAddress());\n} catch (MalformedURLException e) {\nlog.warn(\"Invalid xfml base URL: \" + mapurl);\n\npublic void startElement (String uri, String name, String qName, Attributes atts) throws SAXException {\ntry {\n\/\/log.debug(\"S: '\" + uri + \"' \" + qName);\n\/\/ ----- <xfml> -----------------------------------------------------------\nif (EL_XFML.equals(qName)) {\nString version = atts.getValue(\"version\");\nif (version == null)\nlog.warn(\"No version attribute on 'xfml' element\");\nif (!\"1.0\".equals(version))\nlog.warn(\"Unsupported XFML version: \" + version);\nString mapurl = atts.getValue(\"url\");\nif (mapurl == null)\nlog.warn(\"No url attribute on 'xfml' element\");\nelse {\ntry {\nmap_uri = new URILocator(mapurl);\nTopicMapStoreIF store = topicmap.getStore();\nif (store instanceof AbstractTopicMapStore && store.getBaseAddress() == null)\n((AbstractTopicMapStore) store).setBaseAddress(map_uri);\ndoc_address = map_uri;\n\/\/ Add this document to the list of processed documents.\nprocessed_documents_accumulated.add(getBaseAddress());\n} catch (MalformedURLException e) {\nlog.warn(\"Invalid xfml base URL: \" + mapurl);\n}\n}\n\/\/ FIXME: what to do about language?\n}\n\/\/ ----- <facet> ----------------------------------------------------------\nelse if (EL_FACET.equals(qName)) {\nString id = atts.getValue(\"id\");\n\/\/ FIXME: complain if no id\ncurrent_topic = builder.makeTopic();\nregisterSourceLocator(current_topic, id);\nkeep_content = true;\n}\n\/\/ ----- <topic> ----------------------------------------------------------\nelse if (EL_TOPIC.equals(qName)) {\nString id = atts.getValue(\"id\");\n\/\/ FIXME: complain if no id\ncurrent_topic = builder.makeTopic();\n\nif (version == null)\nlog.warn(\"No version attribute on 'xfml' element\");\nif (!\"1.0\".equals(version))\nlog.warn(\"Unsupported XFML version: \" + version);\nString mapurl = atts.getValue(\"url\");\nif (mapurl == null)\nlog.warn(\"No url attribute on 'xfml' element\");\nelse {\ntry {\nmap_uri = new URILocator(mapurl);\nTopicMapStoreIF store = topicmap.getStore();\nif (store instanceof AbstractTopicMapStore && store.getBaseAddress() == null)\n((AbstractTopicMapStore) store).setBaseAddress(map_uri);\ndoc_address = map_uri;\n\/\/ Add this document to the list of processed documents.\nprocessed_documents_accumulated.add(getBaseAddress());\n} catch (MalformedURLException e) {\nlog.warn(\"Invalid xfml base URL: \" + mapurl);\n}\n}\n\/\/ FIXME: what to do about language?\n}\n\/\/ ----- <facet> ----------------------------------------------------------\nelse if (EL_FACET.equals(qName)) {\nString id = atts.getValue(\"id\");\n\/\/ FIXME: complain if no id\ncurrent_topic = builder.makeTopic();\nregisterSourceLocator(current_topic, id);\nkeep_content = true;\n}\n\/\/ ----- <topic> ----------------------------------------------------------\nelse if (EL_TOPIC.equals(qName)) {\nString id = atts.getValue(\"id\");\n\/\/ FIXME: complain if no id\ncurrent_topic = builder.makeTopic();\nregisterSourceLocator(current_topic, id);\nString parentid = atts.getValue(\"parentTopicid\");\nif (parentid == null)\nparentid = atts.getValue(\"facetid\");\n\/\/ FIXME: complain if no refs\nTopicIF parent = resolveTopicRef(\"#\" + parentid);\n\nif (!\"1.0\".equals(version))\nlog.warn(\"Unsupported XFML version: \" + version);\nString mapurl = atts.getValue(\"url\");\nif (mapurl == null)\nlog.warn(\"No url attribute on 'xfml' element\");\nelse {\ntry {\nmap_uri = new URILocator(mapurl);\nTopicMapStoreIF store = topicmap.getStore();\nif (store instanceof AbstractTopicMapStore && store.getBaseAddress() == null)\n((AbstractTopicMapStore) store).setBaseAddress(map_uri);\ndoc_address = map_uri;\n\/\/ Add this document to the list of processed documents.\nprocessed_documents_accumulated.add(getBaseAddress());\n} catch (MalformedURLException e) {\nlog.warn(\"Invalid xfml base URL: \" + mapurl);\n}\n}\n\/\/ FIXME: what to do about language?\n}\n\/\/ ----- <facet> ----------------------------------------------------------\nelse if (EL_FACET.equals(qName)) {\nString id = atts.getValue(\"id\");\n\/\/ FIXME: complain if no id\ncurrent_topic = builder.makeTopic();\nregisterSourceLocator(current_topic, id);\nkeep_content = true;\n}\n\/\/ ----- <topic> ----------------------------------------------------------\nelse if (EL_TOPIC.equals(qName)) {\nString id = atts.getValue(\"id\");\n\/\/ FIXME: complain if no id\ncurrent_topic = builder.makeTopic();\nregisterSourceLocator(current_topic, id);\nString parentid = atts.getValue(\"parentTopicid\");\nif (parentid == null)\nparentid = atts.getValue(\"facetid\");\n\/\/ FIXME: complain if no refs\nTopicIF parent = resolveTopicRef(\"#\" + parentid);\nparentBuilder.makeAssociation(parent, current_topic);\n}\n\nif (mapurl == null)\nlog.warn(\"No url attribute on 'xfml' element\");\nelse {\ntry {\nmap_uri = new URILocator(mapurl);\nTopicMapStoreIF store = topicmap.getStore();\nif (store instanceof AbstractTopicMapStore && store.getBaseAddress() == null)\n((AbstractTopicMapStore) store).setBaseAddress(map_uri);\ndoc_address = map_uri;\n\/\/ Add this document to the list of processed documents.\nprocessed_documents_accumulated.add(getBaseAddress());\n} catch (MalformedURLException e) {\nlog.warn(\"Invalid xfml base URL: \" + mapurl);\n}\n}\n\/\/ FIXME: what to do about language?\n}\n\/\/ ----- <facet> ----------------------------------------------------------\nelse if (EL_FACET.equals(qName)) {\nString id = atts.getValue(\"id\");\n\/\/ FIXME: complain if no id\ncurrent_topic = builder.makeTopic();\nregisterSourceLocator(current_topic, id);\nkeep_content = true;\n}\n\/\/ ----- <topic> ----------------------------------------------------------\nelse if (EL_TOPIC.equals(qName)) {\nString id = atts.getValue(\"id\");\n\/\/ FIXME: complain if no id\ncurrent_topic = builder.makeTopic();\nregisterSourceLocator(current_topic, id);\nString parentid = atts.getValue(\"parentTopicid\");\nif (parentid == null)\nparentid = atts.getValue(\"facetid\");\n\/\/ FIXME: complain if no refs\nTopicIF parent = resolveTopicRef(\"#\" + parentid);\nparentBuilder.makeAssociation(parent, current_topic);\n}\n\/\/ ----- <page> -----------------------------------------------------------\nelse if (EL_PAGE.equals(qName)) {\nString url = atts.getValue(\"url\");\n\nTopicMapStoreIF store = topicmap.getStore();\nif (store instanceof AbstractTopicMapStore && store.getBaseAddress() == null)\n((AbstractTopicMapStore) store).setBaseAddress(map_uri);\ndoc_address = map_uri;\n\/\/ Add this document to the list of processed documents.\nprocessed_documents_accumulated.add(getBaseAddress());\n} catch (MalformedURLException e) {\nlog.warn(\"Invalid xfml base URL: \" + mapurl);\n}\n}\n\/\/ FIXME: what to do about language?\n}\n\/\/ ----- <facet> ----------------------------------------------------------\nelse if (EL_FACET.equals(qName)) {\nString id = atts.getValue(\"id\");\n\/\/ FIXME: complain if no id\ncurrent_topic = builder.makeTopic();\nregisterSourceLocator(current_topic, id);\nkeep_content = true;\n}\n\/\/ ----- <topic> ----------------------------------------------------------\nelse if (EL_TOPIC.equals(qName)) {\nString id = atts.getValue(\"id\");\n\/\/ FIXME: complain if no id\ncurrent_topic = builder.makeTopic();\nregisterSourceLocator(current_topic, id);\nString parentid = atts.getValue(\"parentTopicid\");\nif (parentid == null)\nparentid = atts.getValue(\"facetid\");\n\/\/ FIXME: complain if no refs\nTopicIF parent = resolveTopicRef(\"#\" + parentid);\nparentBuilder.makeAssociation(parent, current_topic);\n}\n\/\/ ----- <page> -----------------------------------------------------------\nelse if (EL_PAGE.equals(qName)) {\nString url = atts.getValue(\"url\");\n\/\/ FIXME: complain if no url\ncurrent_topic = builder.makeTopic();\ncurrent_topic.addSubjectLocator(createLocator(url));\n}\n\/\/ ----- <occurrence>------------------------------------------------------\n\nif (mapurl == null)\nlog.warn(\"No url attribute on 'xfml' element\");\nelse {\ntry {\nmap_uri = new URILocator(mapurl);\nTopicMapStoreIF store = topicmap.getStore();\nif (store instanceof AbstractTopicMapStore && store.getBaseAddress() == null)\n((AbstractTopicMapStore) store).setBaseAddress(map_uri);\ndoc_address = map_uri;\n\/\/ Add this document to the list of processed documents.\nprocessed_documents_accumulated.add(getBaseAddress());\n} catch (MalformedURLException e) {\nlog.warn(\"Invalid xfml base URL: \" + mapurl);\n}\n}\n\/\/ FIXME: what to do about language?\n}\n\/\/ ----- <facet> ----------------------------------------------------------\nelse if (EL_FACET.equals(qName)) {\nString id = atts.getValue(\"id\");\n\/\/ FIXME: complain if no id\ncurrent_topic = builder.makeTopic();\nregisterSourceLocator(current_topic, id);\nkeep_content = true;\n}\n\/\/ ----- <topic> ----------------------------------------------------------\nelse if (EL_TOPIC.equals(qName)) {\nString id = atts.getValue(\"id\");\n\/\/ FIXME: complain if no id\ncurrent_topic = builder.makeTopic();\nregisterSourceLocator(current_topic, id);\nString parentid = atts.getValue(\"parentTopicid\");\nif (parentid == null)\nparentid = atts.getValue(\"facetid\");\n\/\/ FIXME: complain if no refs\nTopicIF parent = resolveTopicRef(\"#\" + parentid);\nparentBuilder.makeAssociation(parent, current_topic);\n}\n\/\/ ----- <page> -----------------------------------------------------------\nelse if (EL_PAGE.equals(qName)) {\nString url = atts.getValue(\"url\");\n\n}\n\/\/ FIXME: what to do about language?\n}\n\/\/ ----- <facet> ----------------------------------------------------------\nelse if (EL_FACET.equals(qName)) {\nString id = atts.getValue(\"id\");\n\/\/ FIXME: complain if no id\ncurrent_topic = builder.makeTopic();\nregisterSourceLocator(current_topic, id);\nkeep_content = true;\n}\n\/\/ ----- <topic> ----------------------------------------------------------\nelse if (EL_TOPIC.equals(qName)) {\nString id = atts.getValue(\"id\");\n\/\/ FIXME: complain if no id\ncurrent_topic = builder.makeTopic();\nregisterSourceLocator(current_topic, id);\nString parentid = atts.getValue(\"parentTopicid\");\nif (parentid == null)\nparentid = atts.getValue(\"facetid\");\n\/\/ FIXME: complain if no refs\nTopicIF parent = resolveTopicRef(\"#\" + parentid);\nparentBuilder.makeAssociation(parent, current_topic);\n}\n\/\/ ----- <page> -----------------------------------------------------------\nelse if (EL_PAGE.equals(qName)) {\nString url = atts.getValue(\"url\");\n\/\/ FIXME: complain if no url\ncurrent_topic = builder.makeTopic();\ncurrent_topic.addSubjectLocator(createLocator(url));\n}\n\/\/ ----- <occurrence>------------------------------------------------------\nelse if (EL_OCCURRENCE.equals(qName)) {\nString topicid = atts.getValue(\"topicid\");\n\/\/ FIXME: complain if none\nTopicIF subject = resolveTopicRef(\"#\" + topicid);\noccursBuilder.makeAssociation(subject, current_topic);\n}\n\/\/ ----- <name> -----------------------------------------------------------\n\/\/ ----- <psi> ------------------------------------------------------------\n\/\/ ----- <description> ----------------------------------------------------\n\nelse if (EL_FACET.equals(qName)) {\nString id = atts.getValue(\"id\");\n\/\/ FIXME: complain if no id\ncurrent_topic = builder.makeTopic();\nregisterSourceLocator(current_topic, id);\nkeep_content = true;\n}\n\/\/ ----- <topic> ----------------------------------------------------------\nelse if (EL_TOPIC.equals(qName)) {\nString id = atts.getValue(\"id\");\n\/\/ FIXME: complain if no id\ncurrent_topic = builder.makeTopic();\nregisterSourceLocator(current_topic, id);\nString parentid = atts.getValue(\"parentTopicid\");\nif (parentid == null)\nparentid = atts.getValue(\"facetid\");\n\/\/ FIXME: complain if no refs\nTopicIF parent = resolveTopicRef(\"#\" + parentid);\nparentBuilder.makeAssociation(parent, current_topic);\n}\n\/\/ ----- <page> -----------------------------------------------------------\nelse if (EL_PAGE.equals(qName)) {\nString url = atts.getValue(\"url\");\n\/\/ FIXME: complain if no url\ncurrent_topic = builder.makeTopic();\ncurrent_topic.addSubjectLocator(createLocator(url));\n}\n\/\/ ----- <occurrence>------------------------------------------------------\nelse if (EL_OCCURRENCE.equals(qName)) {\nString topicid = atts.getValue(\"topicid\");\n\/\/ FIXME: complain if none\nTopicIF subject = resolveTopicRef(\"#\" + topicid);\noccursBuilder.makeAssociation(subject, current_topic);\n}\n\/\/ ----- <name> -----------------------------------------------------------\n\/\/ ----- <psi> ------------------------------------------------------------\n\/\/ ----- <description> ----------------------------------------------------\n\/\/ ----- <title> ----------------------------------------------------------\n\/\/ ----- <connect> --------------------------------------------------------\nelse if (EL_NAME.equals(qName) || EL_PSI.equals(qName) || EL_DESCRIPTION.equals(qName) ||\nEL_TITLE.equals(qName) || EL_CONNECT.equals(qName))\n\ncurrent_topic = builder.makeTopic();\nregisterSourceLocator(current_topic, id);\nkeep_content = true;\n}\n\/\/ ----- <topic> ----------------------------------------------------------\nelse if (EL_TOPIC.equals(qName)) {\nString id = atts.getValue(\"id\");\n\/\/ FIXME: complain if no id\ncurrent_topic = builder.makeTopic();\nregisterSourceLocator(current_topic, id);\nString parentid = atts.getValue(\"parentTopicid\");\nif (parentid == null)\nparentid = atts.getValue(\"facetid\");\n\/\/ FIXME: complain if no refs\nTopicIF parent = resolveTopicRef(\"#\" + parentid);\nparentBuilder.makeAssociation(parent, current_topic);\n}\n\/\/ ----- <page> -----------------------------------------------------------\nelse if (EL_PAGE.equals(qName)) {\nString url = atts.getValue(\"url\");\n\/\/ FIXME: complain if no url\ncurrent_topic = builder.makeTopic();\ncurrent_topic.addSubjectLocator(createLocator(url));\n}\n\/\/ ----- <occurrence>------------------------------------------------------\nelse if (EL_OCCURRENCE.equals(qName)) {\nString topicid = atts.getValue(\"topicid\");\n\/\/ FIXME: complain if none\nTopicIF subject = resolveTopicRef(\"#\" + topicid);\noccursBuilder.makeAssociation(subject, current_topic);\n}\n\/\/ ----- <name> -----------------------------------------------------------\n\/\/ ----- <psi> ------------------------------------------------------------\n\/\/ ----- <description> ----------------------------------------------------\n\/\/ ----- <title> ----------------------------------------------------------\n\/\/ ----- <connect> --------------------------------------------------------\nelse if (EL_NAME.equals(qName) || EL_PSI.equals(qName) || EL_DESCRIPTION.equals(qName) ||\nEL_TITLE.equals(qName) || EL_CONNECT.equals(qName))\nkeep_content = true;\n} catch (RuntimeException e) {\ne.printStackTrace();\n\n\/\/ ----- <topic> ----------------------------------------------------------\nelse if (EL_TOPIC.equals(qName)) {\nString id = atts.getValue(\"id\");\n\/\/ FIXME: complain if no id\ncurrent_topic = builder.makeTopic();\nregisterSourceLocator(current_topic, id);\nString parentid = atts.getValue(\"parentTopicid\");\nif (parentid == null)\nparentid = atts.getValue(\"facetid\");\n\/\/ FIXME: complain if no refs\nTopicIF parent = resolveTopicRef(\"#\" + parentid);\nparentBuilder.makeAssociation(parent, current_topic);\n}\n\/\/ ----- <page> -----------------------------------------------------------\nelse if (EL_PAGE.equals(qName)) {\nString url = atts.getValue(\"url\");\n\/\/ FIXME: complain if no url\ncurrent_topic = builder.makeTopic();\ncurrent_topic.addSubjectLocator(createLocator(url));\n}\n\/\/ ----- <occurrence>------------------------------------------------------\nelse if (EL_OCCURRENCE.equals(qName)) {\nString topicid = atts.getValue(\"topicid\");\n\/\/ FIXME: complain if none\nTopicIF subject = resolveTopicRef(\"#\" + topicid);\noccursBuilder.makeAssociation(subject, current_topic);\n}\n\/\/ ----- <name> -----------------------------------------------------------\n\/\/ ----- <psi> ------------------------------------------------------------\n\/\/ ----- <description> ----------------------------------------------------\n\/\/ ----- <title> ----------------------------------------------------------\n\/\/ ----- <connect> --------------------------------------------------------\nelse if (EL_NAME.equals(qName) || EL_PSI.equals(qName) || EL_DESCRIPTION.equals(qName) ||\nEL_TITLE.equals(qName) || EL_CONNECT.equals(qName))\nkeep_content = true;\n} catch (RuntimeException e) {\ne.printStackTrace();\nthrow e;\n}\n}\n\n\/\/ FIXME: complain if no id\ncurrent_topic = builder.makeTopic();\nregisterSourceLocator(current_topic, id);\nString parentid = atts.getValue(\"parentTopicid\");\nif (parentid == null)\nparentid = atts.getValue(\"facetid\");\n\/\/ FIXME: complain if no refs\nTopicIF parent = resolveTopicRef(\"#\" + parentid);\nparentBuilder.makeAssociation(parent, current_topic);\n}\n\/\/ ----- <page> -----------------------------------------------------------\nelse if (EL_PAGE.equals(qName)) {\nString url = atts.getValue(\"url\");\n\/\/ FIXME: complain if no url\ncurrent_topic = builder.makeTopic();\ncurrent_topic.addSubjectLocator(createLocator(url));\n}\n\/\/ ----- <occurrence>------------------------------------------------------\nelse if (EL_OCCURRENCE.equals(qName)) {\nString topicid = atts.getValue(\"topicid\");\n\/\/ FIXME: complain if none\nTopicIF subject = resolveTopicRef(\"#\" + topicid);\noccursBuilder.makeAssociation(subject, current_topic);\n}\n\/\/ ----- <name> -----------------------------------------------------------\n\/\/ ----- <psi> ------------------------------------------------------------\n\/\/ ----- <description> ----------------------------------------------------\n\/\/ ----- <title> ----------------------------------------------------------\n\/\/ ----- <connect> --------------------------------------------------------\nelse if (EL_NAME.equals(qName) || EL_PSI.equals(qName) || EL_DESCRIPTION.equals(qName) ||\nEL_TITLE.equals(qName) || EL_CONNECT.equals(qName))\nkeep_content = true;\n} catch (RuntimeException e) {\ne.printStackTrace();\nthrow e;\n}\n}\n\nif (parentid == null)\nparentid = atts.getValue(\"facetid\");\n\/\/ FIXME: complain if no refs\nTopicIF parent = resolveTopicRef(\"#\" + parentid);\nparentBuilder.makeAssociation(parent, current_topic);\n}\n\/\/ ----- <page> -----------------------------------------------------------\nelse if (EL_PAGE.equals(qName)) {\nString url = atts.getValue(\"url\");\n\/\/ FIXME: complain if no url\ncurrent_topic = builder.makeTopic();\ncurrent_topic.addSubjectLocator(createLocator(url));\n}\n\/\/ ----- <occurrence>------------------------------------------------------\nelse if (EL_OCCURRENCE.equals(qName)) {\nString topicid = atts.getValue(\"topicid\");\n\/\/ FIXME: complain if none\nTopicIF subject = resolveTopicRef(\"#\" + topicid);\noccursBuilder.makeAssociation(subject, current_topic);\n}\n\/\/ ----- <name> -----------------------------------------------------------\n\/\/ ----- <psi> ------------------------------------------------------------\n\/\/ ----- <description> ----------------------------------------------------\n\/\/ ----- <title> ----------------------------------------------------------\n\/\/ ----- <connect> --------------------------------------------------------\nelse if (EL_NAME.equals(qName) || EL_PSI.equals(qName) || EL_DESCRIPTION.equals(qName) ||\nEL_TITLE.equals(qName) || EL_CONNECT.equals(qName))\nkeep_content = true;\n} catch (RuntimeException e) {\ne.printStackTrace();\nthrow e;\n}\n}","label":[1,0,1,0]}
{"id":22550,"original_code":"public T dequeue(){\n\t\t\/\/TODO resolve queue with single element\n\t\tT result = current.get();\n\t\tcurrent = current.next();\n\t\treturn result;\n\t}","code":"public T dequeue(){\n\t\n\t\tT result = current.get();\n\t\tcurrent = current.next();\n\t\treturn result;\n\t}","cleancode":"public t dequeue(){ t result = current.get(); current = current.next(); return result; }","comment":"\/** * remove element from the queue * @return element *\/\n\/\/todo resolve queue with single element","repo":"pcordemans\/exampleAlgorithms","code_context_2":"public T dequeue(){\n\/\/TODO resolve queue with single element\nT result = current.get();\ncurrent = current.next();\nreturn result;\n}\n\npublic T dequeue(){\n\/\/TODO resolve queue with single element\nT result = current.get();\ncurrent = current.next();","code_context_10":"public T dequeue(){\n\/\/TODO resolve queue with single element\nT result = current.get();\ncurrent = current.next();\nreturn result;\n}\n\npublic T dequeue(){\n\/\/TODO resolve queue with single element\nT result = current.get();\ncurrent = current.next();\nreturn result;\n}","code_context_20":"public T dequeue(){\n\/\/TODO resolve queue with single element\nT result = current.get();\ncurrent = current.next();\nreturn result;\n}\n\npublic T dequeue(){\n\/\/TODO resolve queue with single element\nT result = current.get();\ncurrent = current.next();\nreturn result;\n}","label":[0,1,0,0]}
{"id":22632,"original_code":"public void copyResourcesToCacheIfRequired1(Activity activity){\n        if( ContextCompat.checkSelfPermission(activity, Manifest.permission.WRITE_EXTERNAL_STORAGE)\n                != PackageManager.PERMISSION_GRANTED )\n            return;\n        String sigFilePath = resFolderPath + \"\/sarvamoola\/aitareya.txt\";\n        File sigFile = new File(sigFilePath);\n        if(!sigFile.exists())\n        {\n            for (Pair<String, String> item : mFilesToCopy) {\n                String fileName ;\n                if(item.first.indexOf('\/')!= -1)\n                    fileName = item.first.substring(item.first.lastIndexOf(\"\/\")+1);\n                else\n                    fileName = item.first;\n                String destUrl = resFolderPath;\n                if(!item.second.isEmpty()) {\n\/\/                  if(new File(item.second).isAbsolute()){\n                    if(File.separator.equals(item.second.substring(0,1))){ \/\/ Shortcut to check isAbsolute()\n                        \/\/ Its an absolute url. set the destUrl to empty so that item.second is taken as is\n                        destUrl = \"\";\n                    }\n                    destUrl = destUrl + item.second + '\/';\n                }\n                destUrl = destUrl + fileName;\n                copyFile(item.first, destUrl);\n            }\n        }\n    }","code":"public void copyResourcesToCacheIfRequired1(Activity activity){\n        if( ContextCompat.checkSelfPermission(activity, Manifest.permission.WRITE_EXTERNAL_STORAGE)\n                != PackageManager.PERMISSION_GRANTED )\n            return;\n        String sigFilePath = resFolderPath + \"\/sarvamoola\/aitareya.txt\";\n        File sigFile = new File(sigFilePath);\n        if(!sigFile.exists())\n        {\n            for (Pair<String, String> item : mFilesToCopy) {\n                String fileName ;\n                if(item.first.indexOf('\/')!= -1)\n                    fileName = item.first.substring(item.first.lastIndexOf(\"\/\")+1);\n                else\n                    fileName = item.first;\n                String destUrl = resFolderPath;\n                if(!item.second.isEmpty()) {\n                    if(File.separator.equals(item.second.substring(0,1))){\n                       \n                        destUrl = \"\";\n                    }\n                    destUrl = destUrl + item.second + '\/';\n                }\n                destUrl = destUrl + fileName;\n                copyFile(item.first, destUrl);\n            }\n        }\n    }","cleancode":"public void copyresourcestocacheifrequired1(activity activity){ if( contextcompat.checkselfpermission(activity, manifest.permission.write_external_storage) != packagemanager.permission_granted ) return; string sigfilepath = resfolderpath + \"\/sarvamoola\/aitareya.txt\"; file sigfile = new file(sigfilepath); if(!sigfile.exists()) { for (pair<string, string> item : mfilestocopy) { string filename ; if(item.first.indexof('\/')!= -1) filename = item.first.substring(item.first.lastindexof(\"\/\")+1); else filename = item.first; string desturl = resfolderpath; if(!item.second.isempty()) { if(file.separator.equals(item.second.substring(0,1))){ desturl = \"\"; } desturl = desturl + item.second + '\/'; } desturl = desturl + filename; copyfile(item.first, desturl); } } }","comment":"\/\/ if(new file(item.second).isabsolute()){\n\/\/ shortcut to check isabsolute()\n\/\/ its an absolute url. set the desturl to empty so that item.second is taken as is","repo":"openmuthu\/jaya","code_context_2":"String destUrl = resFolderPath;\nif(!item.second.isEmpty()) {\n\/\/ if(new File(item.second).isAbsolute()){\nif(File.separator.equals(item.second.substring(0,1))){ \/\/ Shortcut to check isAbsolute()\n\/\/ Its an absolute url. set the destUrl to empty so that item.second is taken as is\n\nif(!item.second.isEmpty()) {\n\/\/ if(new File(item.second).isAbsolute()){\nif(File.separator.equals(item.second.substring(0,1))){ \/\/ Shortcut to check isAbsolute()\n\/\/ Its an absolute url. set the destUrl to empty so that item.second is taken as is\ndestUrl = \"\";\n\n\/\/ if(new File(item.second).isAbsolute()){\nif(File.separator.equals(item.second.substring(0,1))){ \/\/ Shortcut to check isAbsolute()\n\/\/ Its an absolute url. set the destUrl to empty so that item.second is taken as is\ndestUrl = \"\";\n}","code_context_10":"if(!sigFile.exists())\n{\nfor (Pair<String, String> item : mFilesToCopy) {\nString fileName ;\nif(item.first.indexOf('\/')!= -1)\nfileName = item.first.substring(item.first.lastIndexOf(\"\/\")+1);\nelse\nfileName = item.first;\nString destUrl = resFolderPath;\nif(!item.second.isEmpty()) {\n\/\/ if(new File(item.second).isAbsolute()){\nif(File.separator.equals(item.second.substring(0,1))){ \/\/ Shortcut to check isAbsolute()\n\/\/ Its an absolute url. set the destUrl to empty so that item.second is taken as is\ndestUrl = \"\";\n}\ndestUrl = destUrl + item.second + '\/';\n}\ndestUrl = destUrl + fileName;\ncopyFile(item.first, destUrl);\n}\n}\n\n{\nfor (Pair<String, String> item : mFilesToCopy) {\nString fileName ;\nif(item.first.indexOf('\/')!= -1)\nfileName = item.first.substring(item.first.lastIndexOf(\"\/\")+1);\nelse\nfileName = item.first;\nString destUrl = resFolderPath;\nif(!item.second.isEmpty()) {\n\/\/ if(new File(item.second).isAbsolute()){\nif(File.separator.equals(item.second.substring(0,1))){ \/\/ Shortcut to check isAbsolute()\n\/\/ Its an absolute url. set the destUrl to empty so that item.second is taken as is\ndestUrl = \"\";\n}\ndestUrl = destUrl + item.second + '\/';\n}\ndestUrl = destUrl + fileName;\ncopyFile(item.first, destUrl);\n}\n}\n}\n\nfor (Pair<String, String> item : mFilesToCopy) {\nString fileName ;\nif(item.first.indexOf('\/')!= -1)\nfileName = item.first.substring(item.first.lastIndexOf(\"\/\")+1);\nelse\nfileName = item.first;\nString destUrl = resFolderPath;\nif(!item.second.isEmpty()) {\n\/\/ if(new File(item.second).isAbsolute()){\nif(File.separator.equals(item.second.substring(0,1))){ \/\/ Shortcut to check isAbsolute()\n\/\/ Its an absolute url. set the destUrl to empty so that item.second is taken as is\ndestUrl = \"\";\n}\ndestUrl = destUrl + item.second + '\/';\n}\ndestUrl = destUrl + fileName;\ncopyFile(item.first, destUrl);\n}\n}\n}","code_context_20":"public void copyResourcesToCacheIfRequired1(Activity activity){\nif( ContextCompat.checkSelfPermission(activity, Manifest.permission.WRITE_EXTERNAL_STORAGE)\n!= PackageManager.PERMISSION_GRANTED )\nreturn;\nString sigFilePath = resFolderPath + \"\/sarvamoola\/aitareya.txt\";\nFile sigFile = new File(sigFilePath);\nif(!sigFile.exists())\n{\nfor (Pair<String, String> item : mFilesToCopy) {\nString fileName ;\nif(item.first.indexOf('\/')!= -1)\nfileName = item.first.substring(item.first.lastIndexOf(\"\/\")+1);\nelse\nfileName = item.first;\nString destUrl = resFolderPath;\nif(!item.second.isEmpty()) {\n\/\/ if(new File(item.second).isAbsolute()){\nif(File.separator.equals(item.second.substring(0,1))){ \/\/ Shortcut to check isAbsolute()\n\/\/ Its an absolute url. set the destUrl to empty so that item.second is taken as is\ndestUrl = \"\";\n}\ndestUrl = destUrl + item.second + '\/';\n}\ndestUrl = destUrl + fileName;\ncopyFile(item.first, destUrl);\n}\n}\n}\n\npublic void copyResourcesToCacheIfRequired1(Activity activity){\nif( ContextCompat.checkSelfPermission(activity, Manifest.permission.WRITE_EXTERNAL_STORAGE)\n!= PackageManager.PERMISSION_GRANTED )\nreturn;\nString sigFilePath = resFolderPath + \"\/sarvamoola\/aitareya.txt\";\nFile sigFile = new File(sigFilePath);\nif(!sigFile.exists())\n{\nfor (Pair<String, String> item : mFilesToCopy) {\nString fileName ;\nif(item.first.indexOf('\/')!= -1)\nfileName = item.first.substring(item.first.lastIndexOf(\"\/\")+1);\nelse\nfileName = item.first;\nString destUrl = resFolderPath;\nif(!item.second.isEmpty()) {\n\/\/ if(new File(item.second).isAbsolute()){\nif(File.separator.equals(item.second.substring(0,1))){ \/\/ Shortcut to check isAbsolute()\n\/\/ Its an absolute url. set the destUrl to empty so that item.second is taken as is\ndestUrl = \"\";\n}\ndestUrl = destUrl + item.second + '\/';\n}\ndestUrl = destUrl + fileName;\ncopyFile(item.first, destUrl);\n}\n}\n}\n\npublic void copyResourcesToCacheIfRequired1(Activity activity){\nif( ContextCompat.checkSelfPermission(activity, Manifest.permission.WRITE_EXTERNAL_STORAGE)\n!= PackageManager.PERMISSION_GRANTED )\nreturn;\nString sigFilePath = resFolderPath + \"\/sarvamoola\/aitareya.txt\";\nFile sigFile = new File(sigFilePath);\nif(!sigFile.exists())\n{\nfor (Pair<String, String> item : mFilesToCopy) {\nString fileName ;\nif(item.first.indexOf('\/')!= -1)\nfileName = item.first.substring(item.first.lastIndexOf(\"\/\")+1);\nelse\nfileName = item.first;\nString destUrl = resFolderPath;\nif(!item.second.isEmpty()) {\n\/\/ if(new File(item.second).isAbsolute()){\nif(File.separator.equals(item.second.substring(0,1))){ \/\/ Shortcut to check isAbsolute()\n\/\/ Its an absolute url. set the destUrl to empty so that item.second is taken as is\ndestUrl = \"\";\n}\ndestUrl = destUrl + item.second + '\/';\n}\ndestUrl = destUrl + fileName;\ncopyFile(item.first, destUrl);\n}\n}\n}","label":[0,1,0,0]}
{"id":14534,"original_code":"public RawMessage handleCborRequest(ChannelId channelId, byte[] payload) {\n\t\tif (payload.length == 0) {\n\t\t\treturn RawMessage.error(channelId, HidError.INVALID_LEN);\n\t\t}\n\t\tCtap2Method method = Ctap2Method.from(payload[0]);\n\t\tbyte[] params = new byte[payload.length - 1];\n\t\tSystem.arraycopy(payload, 1, params, 0, payload.length - 1);\n\t\ttry {\n\t\t\tlog.debug(\"Received CBOR request with method {} and body {}\", method, CborDecoder.decode(params));\n\t\t} catch (CborException e) {\n\t\t\tlog.error(\"Unable to deserialize CBOR parameters\", e);\n\t\t\treturn failure(channelId, Ctap2ResponseCode.INVALID_CBOR);\n\t\t}\n\t\ttry {\n\t\t\tswitch (method) {\n\t\t\tcase GET_ASSERTION:\n\t\t\t\tGetAssertionRequest gar = GetAssertionRequest.fromBytes(params);\n\t\t\t\tbyte[] assertion = authenticator.getAssertion(gar)\n\t\t\t\t\t\t.handleError(err -> asPayload(err, Collections.emptyList()))\n\t\t\t\t\t\t.elseGet(value -> asPayload(Ctap2ResponseCode.OK, value.asCborMap()));\n\t\t\t\treturn ImmutableRawMessage.builder()\n\t\t\t\t\t\t.channelId(channelId)\n\t\t\t\t\t\t.command(HidCommand.CBOR)\n\t\t\t\t\t\t.payload(assertion)\n\t\t\t\t\t\t.build();\n\t\t\tcase GET_INFO:\n\t\t\t\tGetInfoResponse response = authenticator.getInfo();\n\t\t\t\tlog.trace(\"Authenticator supports options {}\", response);\n\t\t\t\tbyte[] info = asPayload(Ctap2ResponseCode.OK, response.asCborMap());\n\t\t\t\treturn ImmutableRawMessage.builder()\n\t\t\t\t\t\t.channelId(channelId)\n\t\t\t\t\t\t.command(HidCommand.CBOR)\n\t\t\t\t\t\t.payload(info)\n\t\t\t\t\t\t.build();\n\t\t\tcase MAKE_CREDENTIAL:\n\t\t\t\tMakeCredentialRequest request = MakeCredentialRequest.fromBytes(params);\n\t\t\t\tResult<MakeCredentialResponse, Ctap2ResponseCode> result = authenticator.makeCredential(request.clientDataHash(),\n\t\t\t\t\t\trequest.relayingPartyId(), request.userId(), request.supportedAlgorithmIds(), request.pinAuth());\n\t\t\t\tbyte[] credential = result\n\t\t\t\t\t\t.handleError(err -> asPayload(err, Collections.emptyList()))\n\t\t\t\t\t\t.elseGet(value -> asPayload(Ctap2ResponseCode.OK, value.asCborMap()));\n\t\t\t\treturn ImmutableRawMessage.builder()\n\t\t\t\t\t\t.channelId(channelId)\n\t\t\t\t\t\t.command(HidCommand.CBOR)\n\t\t\t\t\t\t.payload(credential)\n\t\t\t\t\t\t.build();\n\t\t\tcase CLIENT_PIN:\n\t\t\t\tMap pinParams = (Map) CborDecoder.decode(params).get(0);\n\t\t\t\tUnsignedInteger pinProtocol = (UnsignedInteger) pinParams.get(new UnsignedInteger(0x01));\n\t\t\t\t\/\/ TODO: handle pinProtocol != 1 somehow\n\t\t\t\tUnsignedInteger subCommand = (UnsignedInteger) pinParams.get(new UnsignedInteger(0x02));\n\t\t\t\tswitch(subCommand.getValue().intValue()) {\n\t\t\t\tcase 0x01: \/\/ get retries\n\t\t\t\t\tList<DataItem> retries = pinRequestHandler.getRetries();\n\t\t\t\t\treturn ImmutableRawMessage.builder()\n\t\t\t\t\t\t\t.channelId(channelId)\n\t\t\t\t\t\t\t.command(HidCommand.CBOR)\n\t\t\t\t\t\t\t.payload(asPayload(Ctap2ResponseCode.OK, retries))\n\t\t\t\t\t\t\t.build();\n\t\t\t\tcase 0x02: \/\/ get key\n\t\t\t\t\tList<DataItem> key = pinRequestHandler.getKeyAgreementKey();\n\t\t\t\t\treturn ImmutableRawMessage.builder()\n\t\t\t\t\t\t\t.channelId(channelId)\n\t\t\t\t\t\t\t.command(HidCommand.CBOR)\n\t\t\t\t\t\t\t.payload(asPayload(Ctap2ResponseCode.OK, key))\n\t\t\t\t\t\t\t.build();\n\t\t\t\tcase 0x03: \/\/ set pin\n\t\t\t\t\tMap hostCoseKey = (Map) pinParams.get(new UnsignedInteger(0x03));\n\t\t\t\t\tByteString pinAuth = (ByteString) pinParams.get(new UnsignedInteger(0x04));\n\t\t\t\t\tByteString newPinEnc = (ByteString) pinParams.get(new UnsignedInteger(0x05));\n\t\t\t\t\tCtap2ResponseCode code = pinRequestHandler.setPin(hostCoseKey, newPinEnc.getBytes(), pinAuth.getBytes());\n\t\t\t\t\treturn ImmutableRawMessage.builder()\n\t\t\t\t\t\t\t.channelId(channelId)\n\t\t\t\t\t\t\t.command(HidCommand.CBOR)\n\t\t\t\t\t\t\t.payload(asPayload(code, Collections.emptyList()))\n\t\t\t\t\t\t\t.build();\n\t\t\t\tcase 0x04: \/\/ change pin\n\t\t\t\t\tMap hostCoseKey2 = (Map) pinParams.get(new UnsignedInteger(0x03));\n\t\t\t\t\tByteString pinAuth2 = (ByteString) pinParams.get(new UnsignedInteger(0x04));\n\t\t\t\t\tByteString newPinEnc2 = (ByteString) pinParams.get(new UnsignedInteger(0x05));\n\t\t\t\t\tByteString PinHashEnc = (ByteString) pinParams.get(new UnsignedInteger(0x06));\n\t\t\t\t\tCtap2ResponseCode code2 = pinRequestHandler.changePin(hostCoseKey2, PinHashEnc.getBytes(), newPinEnc2.getBytes(), pinAuth2.getBytes());\n\t\t\t\t\treturn ImmutableRawMessage.builder()\n\t\t\t\t\t\t\t.channelId(channelId)\n\t\t\t\t\t\t\t.command(HidCommand.CBOR)\n\t\t\t\t\t\t\t.payload(asPayload(code2, Collections.emptyList()))\n\t\t\t\t\t\t\t.build();\n\t\t\t\tcase 0x05: \/\/ get pin token\n\t\t\t\t\tMap hostCoseKey3 = (Map) pinParams.get(new UnsignedInteger(0x03));\n\t\t\t\t\tByteString pinHashEnc2 = (ByteString) pinParams.get(new UnsignedInteger(0x06));\n\t\t\t\t\tResult<List<DataItem>, Ctap2ResponseCode> pinToken = pinRequestHandler.getPinToken(hostCoseKey3, pinHashEnc2.getBytes());\n\t\t\t\t\tbyte[] pinTokenPayload = pinToken.handleError(err -> asPayload(err, Collections.emptyList()))\n\t\t\t\t\t\t\t.elseGet(val -> asPayload(Ctap2ResponseCode.OK, val));\n\t\t\t\t\treturn ImmutableRawMessage.builder()\n\t\t\t\t\t\t\t.channelId(channelId)\n\t\t\t\t\t\t\t.command(HidCommand.CBOR)\n\t\t\t\t\t\t\t.payload(pinTokenPayload)\n\t\t\t\t\t\t\t.build();\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase RESET:\n\t\t\tcase GET_NEXT_ASSERTION:\n\t\t\tdefault:\n\t\t\t\treturn RawMessage.error(channelId, HidError.INVALID_CMD);\n\t\t\t}\n\t\t} catch (CborException e) {\n\t\t\tlog.error(\"Unable to deserialize CBOR\", e);\n\t\t}\n\t\treturn failure(channelId, Ctap2ResponseCode.INVALID_CBOR);\n\t}","code":"public RawMessage handleCborRequest(ChannelId channelId, byte[] payload) {\n\t\tif (payload.length == 0) {\n\t\t\treturn RawMessage.error(channelId, HidError.INVALID_LEN);\n\t\t}\n\t\tCtap2Method method = Ctap2Method.from(payload[0]);\n\t\tbyte[] params = new byte[payload.length - 1];\n\t\tSystem.arraycopy(payload, 1, params, 0, payload.length - 1);\n\t\ttry {\n\t\t\tlog.debug(\"Received CBOR request with method {} and body {}\", method, CborDecoder.decode(params));\n\t\t} catch (CborException e) {\n\t\t\tlog.error(\"Unable to deserialize CBOR parameters\", e);\n\t\t\treturn failure(channelId, Ctap2ResponseCode.INVALID_CBOR);\n\t\t}\n\t\ttry {\n\t\t\tswitch (method) {\n\t\t\tcase GET_ASSERTION:\n\t\t\t\tGetAssertionRequest gar = GetAssertionRequest.fromBytes(params);\n\t\t\t\tbyte[] assertion = authenticator.getAssertion(gar)\n\t\t\t\t\t\t.handleError(err -> asPayload(err, Collections.emptyList()))\n\t\t\t\t\t\t.elseGet(value -> asPayload(Ctap2ResponseCode.OK, value.asCborMap()));\n\t\t\t\treturn ImmutableRawMessage.builder()\n\t\t\t\t\t\t.channelId(channelId)\n\t\t\t\t\t\t.command(HidCommand.CBOR)\n\t\t\t\t\t\t.payload(assertion)\n\t\t\t\t\t\t.build();\n\t\t\tcase GET_INFO:\n\t\t\t\tGetInfoResponse response = authenticator.getInfo();\n\t\t\t\tlog.trace(\"Authenticator supports options {}\", response);\n\t\t\t\tbyte[] info = asPayload(Ctap2ResponseCode.OK, response.asCborMap());\n\t\t\t\treturn ImmutableRawMessage.builder()\n\t\t\t\t\t\t.channelId(channelId)\n\t\t\t\t\t\t.command(HidCommand.CBOR)\n\t\t\t\t\t\t.payload(info)\n\t\t\t\t\t\t.build();\n\t\t\tcase MAKE_CREDENTIAL:\n\t\t\t\tMakeCredentialRequest request = MakeCredentialRequest.fromBytes(params);\n\t\t\t\tResult<MakeCredentialResponse, Ctap2ResponseCode> result = authenticator.makeCredential(request.clientDataHash(),\n\t\t\t\t\t\trequest.relayingPartyId(), request.userId(), request.supportedAlgorithmIds(), request.pinAuth());\n\t\t\t\tbyte[] credential = result\n\t\t\t\t\t\t.handleError(err -> asPayload(err, Collections.emptyList()))\n\t\t\t\t\t\t.elseGet(value -> asPayload(Ctap2ResponseCode.OK, value.asCborMap()));\n\t\t\t\treturn ImmutableRawMessage.builder()\n\t\t\t\t\t\t.channelId(channelId)\n\t\t\t\t\t\t.command(HidCommand.CBOR)\n\t\t\t\t\t\t.payload(credential)\n\t\t\t\t\t\t.build();\n\t\t\tcase CLIENT_PIN:\n\t\t\t\tMap pinParams = (Map) CborDecoder.decode(params).get(0);\n\t\t\t\tUnsignedInteger pinProtocol = (UnsignedInteger) pinParams.get(new UnsignedInteger(0x01));\n\t\t\t\n\t\t\t\tUnsignedInteger subCommand = (UnsignedInteger) pinParams.get(new UnsignedInteger(0x02));\n\t\t\t\tswitch(subCommand.getValue().intValue()) {\n\t\t\t\tcase 0x01:\n\t\t\t\t\tList<DataItem> retries = pinRequestHandler.getRetries();\n\t\t\t\t\treturn ImmutableRawMessage.builder()\n\t\t\t\t\t\t\t.channelId(channelId)\n\t\t\t\t\t\t\t.command(HidCommand.CBOR)\n\t\t\t\t\t\t\t.payload(asPayload(Ctap2ResponseCode.OK, retries))\n\t\t\t\t\t\t\t.build();\n\t\t\t\tcase 0x02:\n\t\t\t\t\tList<DataItem> key = pinRequestHandler.getKeyAgreementKey();\n\t\t\t\t\treturn ImmutableRawMessage.builder()\n\t\t\t\t\t\t\t.channelId(channelId)\n\t\t\t\t\t\t\t.command(HidCommand.CBOR)\n\t\t\t\t\t\t\t.payload(asPayload(Ctap2ResponseCode.OK, key))\n\t\t\t\t\t\t\t.build();\n\t\t\t\tcase 0x03:\n\t\t\t\t\tMap hostCoseKey = (Map) pinParams.get(new UnsignedInteger(0x03));\n\t\t\t\t\tByteString pinAuth = (ByteString) pinParams.get(new UnsignedInteger(0x04));\n\t\t\t\t\tByteString newPinEnc = (ByteString) pinParams.get(new UnsignedInteger(0x05));\n\t\t\t\t\tCtap2ResponseCode code = pinRequestHandler.setPin(hostCoseKey, newPinEnc.getBytes(), pinAuth.getBytes());\n\t\t\t\t\treturn ImmutableRawMessage.builder()\n\t\t\t\t\t\t\t.channelId(channelId)\n\t\t\t\t\t\t\t.command(HidCommand.CBOR)\n\t\t\t\t\t\t\t.payload(asPayload(code, Collections.emptyList()))\n\t\t\t\t\t\t\t.build();\n\t\t\t\tcase 0x04:\n\t\t\t\t\tMap hostCoseKey2 = (Map) pinParams.get(new UnsignedInteger(0x03));\n\t\t\t\t\tByteString pinAuth2 = (ByteString) pinParams.get(new UnsignedInteger(0x04));\n\t\t\t\t\tByteString newPinEnc2 = (ByteString) pinParams.get(new UnsignedInteger(0x05));\n\t\t\t\t\tByteString PinHashEnc = (ByteString) pinParams.get(new UnsignedInteger(0x06));\n\t\t\t\t\tCtap2ResponseCode code2 = pinRequestHandler.changePin(hostCoseKey2, PinHashEnc.getBytes(), newPinEnc2.getBytes(), pinAuth2.getBytes());\n\t\t\t\t\treturn ImmutableRawMessage.builder()\n\t\t\t\t\t\t\t.channelId(channelId)\n\t\t\t\t\t\t\t.command(HidCommand.CBOR)\n\t\t\t\t\t\t\t.payload(asPayload(code2, Collections.emptyList()))\n\t\t\t\t\t\t\t.build();\n\t\t\t\tcase 0x05:\n\t\t\t\t\tMap hostCoseKey3 = (Map) pinParams.get(new UnsignedInteger(0x03));\n\t\t\t\t\tByteString pinHashEnc2 = (ByteString) pinParams.get(new UnsignedInteger(0x06));\n\t\t\t\t\tResult<List<DataItem>, Ctap2ResponseCode> pinToken = pinRequestHandler.getPinToken(hostCoseKey3, pinHashEnc2.getBytes());\n\t\t\t\t\tbyte[] pinTokenPayload = pinToken.handleError(err -> asPayload(err, Collections.emptyList()))\n\t\t\t\t\t\t\t.elseGet(val -> asPayload(Ctap2ResponseCode.OK, val));\n\t\t\t\t\treturn ImmutableRawMessage.builder()\n\t\t\t\t\t\t\t.channelId(channelId)\n\t\t\t\t\t\t\t.command(HidCommand.CBOR)\n\t\t\t\t\t\t\t.payload(pinTokenPayload)\n\t\t\t\t\t\t\t.build();\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase RESET:\n\t\t\tcase GET_NEXT_ASSERTION:\n\t\t\tdefault:\n\t\t\t\treturn RawMessage.error(channelId, HidError.INVALID_CMD);\n\t\t\t}\n\t\t} catch (CborException e) {\n\t\t\tlog.error(\"Unable to deserialize CBOR\", e);\n\t\t}\n\t\treturn failure(channelId, Ctap2ResponseCode.INVALID_CBOR);\n\t}","cleancode":"public rawmessage handlecborrequest(channelid channelid, byte[] payload) { if (payload.length == 0) { return rawmessage.error(channelid, hiderror.invalid_len); } ctap2method method = ctap2method.from(payload[0]); byte[] params = new byte[payload.length - 1]; system.arraycopy(payload, 1, params, 0, payload.length - 1); try { log.debug(\"received cbor request with method {} and body {}\", method, cbordecoder.decode(params)); } catch (cborexception e) { log.error(\"unable to deserialize cbor parameters\", e); return failure(channelid, ctap2responsecode.invalid_cbor); } try { switch (method) { case get_assertion: getassertionrequest gar = getassertionrequest.frombytes(params); byte[] assertion = authenticator.getassertion(gar) .handleerror(err -> aspayload(err, collections.emptylist())) .elseget(value -> aspayload(ctap2responsecode.ok, value.ascbormap())); return immutablerawmessage.builder() .channelid(channelid) .command(hidcommand.cbor) .payload(assertion) .build(); case get_info: getinforesponse response = authenticator.getinfo(); log.trace(\"authenticator supports options {}\", response); byte[] info = aspayload(ctap2responsecode.ok, response.ascbormap()); return immutablerawmessage.builder() .channelid(channelid) .command(hidcommand.cbor) .payload(info) .build(); case make_credential: makecredentialrequest request = makecredentialrequest.frombytes(params); result<makecredentialresponse, ctap2responsecode> result = authenticator.makecredential(request.clientdatahash(), request.relayingpartyid(), request.userid(), request.supportedalgorithmids(), request.pinauth()); byte[] credential = result .handleerror(err -> aspayload(err, collections.emptylist())) .elseget(value -> aspayload(ctap2responsecode.ok, value.ascbormap())); return immutablerawmessage.builder() .channelid(channelid) .command(hidcommand.cbor) .payload(credential) .build(); case client_pin: map pinparams = (map) cbordecoder.decode(params).get(0); unsignedinteger pinprotocol = (unsignedinteger) pinparams.get(new unsignedinteger(0x01)); unsignedinteger subcommand = (unsignedinteger) pinparams.get(new unsignedinteger(0x02)); switch(subcommand.getvalue().intvalue()) { case 0x01: list<dataitem> retries = pinrequesthandler.getretries(); return immutablerawmessage.builder() .channelid(channelid) .command(hidcommand.cbor) .payload(aspayload(ctap2responsecode.ok, retries)) .build(); case 0x02: list<dataitem> key = pinrequesthandler.getkeyagreementkey(); return immutablerawmessage.builder() .channelid(channelid) .command(hidcommand.cbor) .payload(aspayload(ctap2responsecode.ok, key)) .build(); case 0x03: map hostcosekey = (map) pinparams.get(new unsignedinteger(0x03)); bytestring pinauth = (bytestring) pinparams.get(new unsignedinteger(0x04)); bytestring newpinenc = (bytestring) pinparams.get(new unsignedinteger(0x05)); ctap2responsecode code = pinrequesthandler.setpin(hostcosekey, newpinenc.getbytes(), pinauth.getbytes()); return immutablerawmessage.builder() .channelid(channelid) .command(hidcommand.cbor) .payload(aspayload(code, collections.emptylist())) .build(); case 0x04: map hostcosekey2 = (map) pinparams.get(new unsignedinteger(0x03)); bytestring pinauth2 = (bytestring) pinparams.get(new unsignedinteger(0x04)); bytestring newpinenc2 = (bytestring) pinparams.get(new unsignedinteger(0x05)); bytestring pinhashenc = (bytestring) pinparams.get(new unsignedinteger(0x06)); ctap2responsecode code2 = pinrequesthandler.changepin(hostcosekey2, pinhashenc.getbytes(), newpinenc2.getbytes(), pinauth2.getbytes()); return immutablerawmessage.builder() .channelid(channelid) .command(hidcommand.cbor) .payload(aspayload(code2, collections.emptylist())) .build(); case 0x05: map hostcosekey3 = (map) pinparams.get(new unsignedinteger(0x03)); bytestring pinhashenc2 = (bytestring) pinparams.get(new unsignedinteger(0x06)); result<list<dataitem>, ctap2responsecode> pintoken = pinrequesthandler.getpintoken(hostcosekey3, pinhashenc2.getbytes()); byte[] pintokenpayload = pintoken.handleerror(err -> aspayload(err, collections.emptylist())) .elseget(val -> aspayload(ctap2responsecode.ok, val)); return immutablerawmessage.builder() .channelid(channelid) .command(hidcommand.cbor) .payload(pintokenpayload) .build(); } break; case reset: case get_next_assertion: default: return rawmessage.error(channelid, hiderror.invalid_cmd); } } catch (cborexception e) { log.error(\"unable to deserialize cbor\", e); } return failure(channelid, ctap2responsecode.invalid_cbor); }","comment":"\/\/ todo: handle pinprotocol != 1 somehow\n\/\/ get retries\n\/\/ get key\n\/\/ set pin\n\/\/ change pin\n\/\/ get pin token","repo":"mphi-rc\/pi-zero-security-key","code_context_2":"Map pinParams = (Map) CborDecoder.decode(params).get(0);\nUnsignedInteger pinProtocol = (UnsignedInteger) pinParams.get(new UnsignedInteger(0x01));\n\/\/ TODO: handle pinProtocol != 1 somehow\nUnsignedInteger subCommand = (UnsignedInteger) pinParams.get(new UnsignedInteger(0x02));\nswitch(subCommand.getValue().intValue()) {\n\nUnsignedInteger subCommand = (UnsignedInteger) pinParams.get(new UnsignedInteger(0x02));\nswitch(subCommand.getValue().intValue()) {\ncase 0x01: \/\/ get retries\nList<DataItem> retries = pinRequestHandler.getRetries();\nreturn ImmutableRawMessage.builder()\n\n.payload(asPayload(Ctap2ResponseCode.OK, retries))\n.build();\ncase 0x02: \/\/ get key\nList<DataItem> key = pinRequestHandler.getKeyAgreementKey();\nreturn ImmutableRawMessage.builder()\n\n.payload(asPayload(Ctap2ResponseCode.OK, key))\n.build();\ncase 0x03: \/\/ set pin\nMap hostCoseKey = (Map) pinParams.get(new UnsignedInteger(0x03));\nByteString pinAuth = (ByteString) pinParams.get(new UnsignedInteger(0x04));\n\n.payload(asPayload(code, Collections.emptyList()))\n.build();\ncase 0x04: \/\/ change pin\nMap hostCoseKey2 = (Map) pinParams.get(new UnsignedInteger(0x03));\nByteString pinAuth2 = (ByteString) pinParams.get(new UnsignedInteger(0x04));\n\n.payload(asPayload(code2, Collections.emptyList()))\n.build();\ncase 0x05: \/\/ get pin token\nMap hostCoseKey3 = (Map) pinParams.get(new UnsignedInteger(0x03));\nByteString pinHashEnc2 = (ByteString) pinParams.get(new UnsignedInteger(0x06));","code_context_10":".handleError(err -> asPayload(err, Collections.emptyList()))\n.elseGet(value -> asPayload(Ctap2ResponseCode.OK, value.asCborMap()));\nreturn ImmutableRawMessage.builder()\n.channelId(channelId)\n.command(HidCommand.CBOR)\n.payload(credential)\n.build();\ncase CLIENT_PIN:\nMap pinParams = (Map) CborDecoder.decode(params).get(0);\nUnsignedInteger pinProtocol = (UnsignedInteger) pinParams.get(new UnsignedInteger(0x01));\n\/\/ TODO: handle pinProtocol != 1 somehow\nUnsignedInteger subCommand = (UnsignedInteger) pinParams.get(new UnsignedInteger(0x02));\nswitch(subCommand.getValue().intValue()) {\ncase 0x01: \/\/ get retries\nList<DataItem> retries = pinRequestHandler.getRetries();\nreturn ImmutableRawMessage.builder()\n.channelId(channelId)\n.command(HidCommand.CBOR)\n.payload(asPayload(Ctap2ResponseCode.OK, retries))\n.build();\ncase 0x02: \/\/ get key\n\n.channelId(channelId)\n.command(HidCommand.CBOR)\n.payload(credential)\n.build();\ncase CLIENT_PIN:\nMap pinParams = (Map) CborDecoder.decode(params).get(0);\nUnsignedInteger pinProtocol = (UnsignedInteger) pinParams.get(new UnsignedInteger(0x01));\n\/\/ TODO: handle pinProtocol != 1 somehow\nUnsignedInteger subCommand = (UnsignedInteger) pinParams.get(new UnsignedInteger(0x02));\nswitch(subCommand.getValue().intValue()) {\ncase 0x01: \/\/ get retries\nList<DataItem> retries = pinRequestHandler.getRetries();\nreturn ImmutableRawMessage.builder()\n.channelId(channelId)\n.command(HidCommand.CBOR)\n.payload(asPayload(Ctap2ResponseCode.OK, retries))\n.build();\ncase 0x02: \/\/ get key\nList<DataItem> key = pinRequestHandler.getKeyAgreementKey();\nreturn ImmutableRawMessage.builder()\n.channelId(channelId)\n\n\/\/ TODO: handle pinProtocol != 1 somehow\nUnsignedInteger subCommand = (UnsignedInteger) pinParams.get(new UnsignedInteger(0x02));\nswitch(subCommand.getValue().intValue()) {\ncase 0x01: \/\/ get retries\nList<DataItem> retries = pinRequestHandler.getRetries();\nreturn ImmutableRawMessage.builder()\n.channelId(channelId)\n.command(HidCommand.CBOR)\n.payload(asPayload(Ctap2ResponseCode.OK, retries))\n.build();\ncase 0x02: \/\/ get key\nList<DataItem> key = pinRequestHandler.getKeyAgreementKey();\nreturn ImmutableRawMessage.builder()\n.channelId(channelId)\n.command(HidCommand.CBOR)\n.payload(asPayload(Ctap2ResponseCode.OK, key))\n.build();\ncase 0x03: \/\/ set pin\nMap hostCoseKey = (Map) pinParams.get(new UnsignedInteger(0x03));\nByteString pinAuth = (ByteString) pinParams.get(new UnsignedInteger(0x04));\nByteString newPinEnc = (ByteString) pinParams.get(new UnsignedInteger(0x05));\n\n.command(HidCommand.CBOR)\n.payload(asPayload(Ctap2ResponseCode.OK, retries))\n.build();\ncase 0x02: \/\/ get key\nList<DataItem> key = pinRequestHandler.getKeyAgreementKey();\nreturn ImmutableRawMessage.builder()\n.channelId(channelId)\n.command(HidCommand.CBOR)\n.payload(asPayload(Ctap2ResponseCode.OK, key))\n.build();\ncase 0x03: \/\/ set pin\nMap hostCoseKey = (Map) pinParams.get(new UnsignedInteger(0x03));\nByteString pinAuth = (ByteString) pinParams.get(new UnsignedInteger(0x04));\nByteString newPinEnc = (ByteString) pinParams.get(new UnsignedInteger(0x05));\nCtap2ResponseCode code = pinRequestHandler.setPin(hostCoseKey, newPinEnc.getBytes(), pinAuth.getBytes());\nreturn ImmutableRawMessage.builder()\n.channelId(channelId)\n.command(HidCommand.CBOR)\n.payload(asPayload(code, Collections.emptyList()))\n.build();\ncase 0x04: \/\/ change pin\n\ncase 0x03: \/\/ set pin\nMap hostCoseKey = (Map) pinParams.get(new UnsignedInteger(0x03));\nByteString pinAuth = (ByteString) pinParams.get(new UnsignedInteger(0x04));\nByteString newPinEnc = (ByteString) pinParams.get(new UnsignedInteger(0x05));\nCtap2ResponseCode code = pinRequestHandler.setPin(hostCoseKey, newPinEnc.getBytes(), pinAuth.getBytes());\nreturn ImmutableRawMessage.builder()\n.channelId(channelId)\n.command(HidCommand.CBOR)\n.payload(asPayload(code, Collections.emptyList()))\n.build();\ncase 0x04: \/\/ change pin\nMap hostCoseKey2 = (Map) pinParams.get(new UnsignedInteger(0x03));\nByteString pinAuth2 = (ByteString) pinParams.get(new UnsignedInteger(0x04));\nByteString newPinEnc2 = (ByteString) pinParams.get(new UnsignedInteger(0x05));\nByteString PinHashEnc = (ByteString) pinParams.get(new UnsignedInteger(0x06));\nCtap2ResponseCode code2 = pinRequestHandler.changePin(hostCoseKey2, PinHashEnc.getBytes(), newPinEnc2.getBytes(), pinAuth2.getBytes());\nreturn ImmutableRawMessage.builder()\n.channelId(channelId)\n.command(HidCommand.CBOR)\n.payload(asPayload(code2, Collections.emptyList()))\n.build();\n\nMap hostCoseKey2 = (Map) pinParams.get(new UnsignedInteger(0x03));\nByteString pinAuth2 = (ByteString) pinParams.get(new UnsignedInteger(0x04));\nByteString newPinEnc2 = (ByteString) pinParams.get(new UnsignedInteger(0x05));\nByteString PinHashEnc = (ByteString) pinParams.get(new UnsignedInteger(0x06));\nCtap2ResponseCode code2 = pinRequestHandler.changePin(hostCoseKey2, PinHashEnc.getBytes(), newPinEnc2.getBytes(), pinAuth2.getBytes());\nreturn ImmutableRawMessage.builder()\n.channelId(channelId)\n.command(HidCommand.CBOR)\n.payload(asPayload(code2, Collections.emptyList()))\n.build();\ncase 0x05: \/\/ get pin token\nMap hostCoseKey3 = (Map) pinParams.get(new UnsignedInteger(0x03));\nByteString pinHashEnc2 = (ByteString) pinParams.get(new UnsignedInteger(0x06));\nResult<List<DataItem>, Ctap2ResponseCode> pinToken = pinRequestHandler.getPinToken(hostCoseKey3, pinHashEnc2.getBytes());\nbyte[] pinTokenPayload = pinToken.handleError(err -> asPayload(err, Collections.emptyList()))\n.elseGet(val -> asPayload(Ctap2ResponseCode.OK, val));\nreturn ImmutableRawMessage.builder()\n.channelId(channelId)\n.command(HidCommand.CBOR)\n.payload(pinTokenPayload)\n.build();","code_context_20":"return ImmutableRawMessage.builder()\n.channelId(channelId)\n.command(HidCommand.CBOR)\n.payload(info)\n.build();\ncase MAKE_CREDENTIAL:\nMakeCredentialRequest request = MakeCredentialRequest.fromBytes(params);\nResult<MakeCredentialResponse, Ctap2ResponseCode> result = authenticator.makeCredential(request.clientDataHash(),\nrequest.relayingPartyId(), request.userId(), request.supportedAlgorithmIds(), request.pinAuth());\nbyte[] credential = result\n.handleError(err -> asPayload(err, Collections.emptyList()))\n.elseGet(value -> asPayload(Ctap2ResponseCode.OK, value.asCborMap()));\nreturn ImmutableRawMessage.builder()\n.channelId(channelId)\n.command(HidCommand.CBOR)\n.payload(credential)\n.build();\ncase CLIENT_PIN:\nMap pinParams = (Map) CborDecoder.decode(params).get(0);\nUnsignedInteger pinProtocol = (UnsignedInteger) pinParams.get(new UnsignedInteger(0x01));\n\/\/ TODO: handle pinProtocol != 1 somehow\nUnsignedInteger subCommand = (UnsignedInteger) pinParams.get(new UnsignedInteger(0x02));\nswitch(subCommand.getValue().intValue()) {\ncase 0x01: \/\/ get retries\nList<DataItem> retries = pinRequestHandler.getRetries();\nreturn ImmutableRawMessage.builder()\n.channelId(channelId)\n.command(HidCommand.CBOR)\n.payload(asPayload(Ctap2ResponseCode.OK, retries))\n.build();\ncase 0x02: \/\/ get key\nList<DataItem> key = pinRequestHandler.getKeyAgreementKey();\nreturn ImmutableRawMessage.builder()\n.channelId(channelId)\n.command(HidCommand.CBOR)\n.payload(asPayload(Ctap2ResponseCode.OK, key))\n.build();\ncase 0x03: \/\/ set pin\nMap hostCoseKey = (Map) pinParams.get(new UnsignedInteger(0x03));\nByteString pinAuth = (ByteString) pinParams.get(new UnsignedInteger(0x04));\nByteString newPinEnc = (ByteString) pinParams.get(new UnsignedInteger(0x05));\n\n.payload(info)\n.build();\ncase MAKE_CREDENTIAL:\nMakeCredentialRequest request = MakeCredentialRequest.fromBytes(params);\nResult<MakeCredentialResponse, Ctap2ResponseCode> result = authenticator.makeCredential(request.clientDataHash(),\nrequest.relayingPartyId(), request.userId(), request.supportedAlgorithmIds(), request.pinAuth());\nbyte[] credential = result\n.handleError(err -> asPayload(err, Collections.emptyList()))\n.elseGet(value -> asPayload(Ctap2ResponseCode.OK, value.asCborMap()));\nreturn ImmutableRawMessage.builder()\n.channelId(channelId)\n.command(HidCommand.CBOR)\n.payload(credential)\n.build();\ncase CLIENT_PIN:\nMap pinParams = (Map) CborDecoder.decode(params).get(0);\nUnsignedInteger pinProtocol = (UnsignedInteger) pinParams.get(new UnsignedInteger(0x01));\n\/\/ TODO: handle pinProtocol != 1 somehow\nUnsignedInteger subCommand = (UnsignedInteger) pinParams.get(new UnsignedInteger(0x02));\nswitch(subCommand.getValue().intValue()) {\ncase 0x01: \/\/ get retries\nList<DataItem> retries = pinRequestHandler.getRetries();\nreturn ImmutableRawMessage.builder()\n.channelId(channelId)\n.command(HidCommand.CBOR)\n.payload(asPayload(Ctap2ResponseCode.OK, retries))\n.build();\ncase 0x02: \/\/ get key\nList<DataItem> key = pinRequestHandler.getKeyAgreementKey();\nreturn ImmutableRawMessage.builder()\n.channelId(channelId)\n.command(HidCommand.CBOR)\n.payload(asPayload(Ctap2ResponseCode.OK, key))\n.build();\ncase 0x03: \/\/ set pin\nMap hostCoseKey = (Map) pinParams.get(new UnsignedInteger(0x03));\nByteString pinAuth = (ByteString) pinParams.get(new UnsignedInteger(0x04));\nByteString newPinEnc = (ByteString) pinParams.get(new UnsignedInteger(0x05));\nCtap2ResponseCode code = pinRequestHandler.setPin(hostCoseKey, newPinEnc.getBytes(), pinAuth.getBytes());\nreturn ImmutableRawMessage.builder()\n.channelId(channelId)\n\n.handleError(err -> asPayload(err, Collections.emptyList()))\n.elseGet(value -> asPayload(Ctap2ResponseCode.OK, value.asCborMap()));\nreturn ImmutableRawMessage.builder()\n.channelId(channelId)\n.command(HidCommand.CBOR)\n.payload(credential)\n.build();\ncase CLIENT_PIN:\nMap pinParams = (Map) CborDecoder.decode(params).get(0);\nUnsignedInteger pinProtocol = (UnsignedInteger) pinParams.get(new UnsignedInteger(0x01));\n\/\/ TODO: handle pinProtocol != 1 somehow\nUnsignedInteger subCommand = (UnsignedInteger) pinParams.get(new UnsignedInteger(0x02));\nswitch(subCommand.getValue().intValue()) {\ncase 0x01: \/\/ get retries\nList<DataItem> retries = pinRequestHandler.getRetries();\nreturn ImmutableRawMessage.builder()\n.channelId(channelId)\n.command(HidCommand.CBOR)\n.payload(asPayload(Ctap2ResponseCode.OK, retries))\n.build();\ncase 0x02: \/\/ get key\nList<DataItem> key = pinRequestHandler.getKeyAgreementKey();\nreturn ImmutableRawMessage.builder()\n.channelId(channelId)\n.command(HidCommand.CBOR)\n.payload(asPayload(Ctap2ResponseCode.OK, key))\n.build();\ncase 0x03: \/\/ set pin\nMap hostCoseKey = (Map) pinParams.get(new UnsignedInteger(0x03));\nByteString pinAuth = (ByteString) pinParams.get(new UnsignedInteger(0x04));\nByteString newPinEnc = (ByteString) pinParams.get(new UnsignedInteger(0x05));\nCtap2ResponseCode code = pinRequestHandler.setPin(hostCoseKey, newPinEnc.getBytes(), pinAuth.getBytes());\nreturn ImmutableRawMessage.builder()\n.channelId(channelId)\n.command(HidCommand.CBOR)\n.payload(asPayload(code, Collections.emptyList()))\n.build();\ncase 0x04: \/\/ change pin\nMap hostCoseKey2 = (Map) pinParams.get(new UnsignedInteger(0x03));\nByteString pinAuth2 = (ByteString) pinParams.get(new UnsignedInteger(0x04));\nByteString newPinEnc2 = (ByteString) pinParams.get(new UnsignedInteger(0x05));\n\ncase CLIENT_PIN:\nMap pinParams = (Map) CborDecoder.decode(params).get(0);\nUnsignedInteger pinProtocol = (UnsignedInteger) pinParams.get(new UnsignedInteger(0x01));\n\/\/ TODO: handle pinProtocol != 1 somehow\nUnsignedInteger subCommand = (UnsignedInteger) pinParams.get(new UnsignedInteger(0x02));\nswitch(subCommand.getValue().intValue()) {\ncase 0x01: \/\/ get retries\nList<DataItem> retries = pinRequestHandler.getRetries();\nreturn ImmutableRawMessage.builder()\n.channelId(channelId)\n.command(HidCommand.CBOR)\n.payload(asPayload(Ctap2ResponseCode.OK, retries))\n.build();\ncase 0x02: \/\/ get key\nList<DataItem> key = pinRequestHandler.getKeyAgreementKey();\nreturn ImmutableRawMessage.builder()\n.channelId(channelId)\n.command(HidCommand.CBOR)\n.payload(asPayload(Ctap2ResponseCode.OK, key))\n.build();\ncase 0x03: \/\/ set pin\nMap hostCoseKey = (Map) pinParams.get(new UnsignedInteger(0x03));\nByteString pinAuth = (ByteString) pinParams.get(new UnsignedInteger(0x04));\nByteString newPinEnc = (ByteString) pinParams.get(new UnsignedInteger(0x05));\nCtap2ResponseCode code = pinRequestHandler.setPin(hostCoseKey, newPinEnc.getBytes(), pinAuth.getBytes());\nreturn ImmutableRawMessage.builder()\n.channelId(channelId)\n.command(HidCommand.CBOR)\n.payload(asPayload(code, Collections.emptyList()))\n.build();\ncase 0x04: \/\/ change pin\nMap hostCoseKey2 = (Map) pinParams.get(new UnsignedInteger(0x03));\nByteString pinAuth2 = (ByteString) pinParams.get(new UnsignedInteger(0x04));\nByteString newPinEnc2 = (ByteString) pinParams.get(new UnsignedInteger(0x05));\nByteString PinHashEnc = (ByteString) pinParams.get(new UnsignedInteger(0x06));\nCtap2ResponseCode code2 = pinRequestHandler.changePin(hostCoseKey2, PinHashEnc.getBytes(), newPinEnc2.getBytes(), pinAuth2.getBytes());\nreturn ImmutableRawMessage.builder()\n.channelId(channelId)\n.command(HidCommand.CBOR)\n.payload(asPayload(code2, Collections.emptyList()))\n.build();\n\n.command(HidCommand.CBOR)\n.payload(asPayload(Ctap2ResponseCode.OK, retries))\n.build();\ncase 0x02: \/\/ get key\nList<DataItem> key = pinRequestHandler.getKeyAgreementKey();\nreturn ImmutableRawMessage.builder()\n.channelId(channelId)\n.command(HidCommand.CBOR)\n.payload(asPayload(Ctap2ResponseCode.OK, key))\n.build();\ncase 0x03: \/\/ set pin\nMap hostCoseKey = (Map) pinParams.get(new UnsignedInteger(0x03));\nByteString pinAuth = (ByteString) pinParams.get(new UnsignedInteger(0x04));\nByteString newPinEnc = (ByteString) pinParams.get(new UnsignedInteger(0x05));\nCtap2ResponseCode code = pinRequestHandler.setPin(hostCoseKey, newPinEnc.getBytes(), pinAuth.getBytes());\nreturn ImmutableRawMessage.builder()\n.channelId(channelId)\n.command(HidCommand.CBOR)\n.payload(asPayload(code, Collections.emptyList()))\n.build();\ncase 0x04: \/\/ change pin\nMap hostCoseKey2 = (Map) pinParams.get(new UnsignedInteger(0x03));\nByteString pinAuth2 = (ByteString) pinParams.get(new UnsignedInteger(0x04));\nByteString newPinEnc2 = (ByteString) pinParams.get(new UnsignedInteger(0x05));\nByteString PinHashEnc = (ByteString) pinParams.get(new UnsignedInteger(0x06));\nCtap2ResponseCode code2 = pinRequestHandler.changePin(hostCoseKey2, PinHashEnc.getBytes(), newPinEnc2.getBytes(), pinAuth2.getBytes());\nreturn ImmutableRawMessage.builder()\n.channelId(channelId)\n.command(HidCommand.CBOR)\n.payload(asPayload(code2, Collections.emptyList()))\n.build();\ncase 0x05: \/\/ get pin token\nMap hostCoseKey3 = (Map) pinParams.get(new UnsignedInteger(0x03));\nByteString pinHashEnc2 = (ByteString) pinParams.get(new UnsignedInteger(0x06));\nResult<List<DataItem>, Ctap2ResponseCode> pinToken = pinRequestHandler.getPinToken(hostCoseKey3, pinHashEnc2.getBytes());\nbyte[] pinTokenPayload = pinToken.handleError(err -> asPayload(err, Collections.emptyList()))\n.elseGet(val -> asPayload(Ctap2ResponseCode.OK, val));\nreturn ImmutableRawMessage.builder()\n.channelId(channelId)\n.command(HidCommand.CBOR)\n.payload(pinTokenPayload)\n\nMap hostCoseKey = (Map) pinParams.get(new UnsignedInteger(0x03));\nByteString pinAuth = (ByteString) pinParams.get(new UnsignedInteger(0x04));\nByteString newPinEnc = (ByteString) pinParams.get(new UnsignedInteger(0x05));\nCtap2ResponseCode code = pinRequestHandler.setPin(hostCoseKey, newPinEnc.getBytes(), pinAuth.getBytes());\nreturn ImmutableRawMessage.builder()\n.channelId(channelId)\n.command(HidCommand.CBOR)\n.payload(asPayload(code, Collections.emptyList()))\n.build();\ncase 0x04: \/\/ change pin\nMap hostCoseKey2 = (Map) pinParams.get(new UnsignedInteger(0x03));\nByteString pinAuth2 = (ByteString) pinParams.get(new UnsignedInteger(0x04));\nByteString newPinEnc2 = (ByteString) pinParams.get(new UnsignedInteger(0x05));\nByteString PinHashEnc = (ByteString) pinParams.get(new UnsignedInteger(0x06));\nCtap2ResponseCode code2 = pinRequestHandler.changePin(hostCoseKey2, PinHashEnc.getBytes(), newPinEnc2.getBytes(), pinAuth2.getBytes());\nreturn ImmutableRawMessage.builder()\n.channelId(channelId)\n.command(HidCommand.CBOR)\n.payload(asPayload(code2, Collections.emptyList()))\n.build();\ncase 0x05: \/\/ get pin token\nMap hostCoseKey3 = (Map) pinParams.get(new UnsignedInteger(0x03));\nByteString pinHashEnc2 = (ByteString) pinParams.get(new UnsignedInteger(0x06));\nResult<List<DataItem>, Ctap2ResponseCode> pinToken = pinRequestHandler.getPinToken(hostCoseKey3, pinHashEnc2.getBytes());\nbyte[] pinTokenPayload = pinToken.handleError(err -> asPayload(err, Collections.emptyList()))\n.elseGet(val -> asPayload(Ctap2ResponseCode.OK, val));\nreturn ImmutableRawMessage.builder()\n.channelId(channelId)\n.command(HidCommand.CBOR)\n.payload(pinTokenPayload)\n.build();\n}\nbreak;\ncase RESET:\ncase GET_NEXT_ASSERTION:\ndefault:\nreturn RawMessage.error(channelId, HidError.INVALID_CMD);\n}\n} catch (CborException e) {\nlog.error(\"Unable to deserialize CBOR\", e);\n}","label":[1,0,0,0]}
{"id":22750,"original_code":"@Test\n\tpublic void acceptedRequestIsFullyApplied() throws EngineException\n\t{\n\t\tRegistrationContext defContext = new RegistrationContext(false, TriggeringMode.manualAtLogin);\n\t\tinitAndCreateForm(false, null);\n\t\tRegistrationRequest request = getRequest();\n\t\tString id3 = registrationsMan.submitRegistrationRequest(request, defContext);\n\t\tregistrationsMan.processRegistrationRequest(id3, null, \n\t\t\t\tRegistrationRequestAction.accept, \"a2\", \"p2\");\n\t\tRegistrationRequestState fromDb = registrationsMan.getRegistrationRequests().get(0);\n\t\tassertEquals(request, fromDb.getRequest());\n\t\tassertEquals(2, fromDb.getAdminComments().size());\n\t\tassertEquals(\"p2\", fromDb.getAdminComments().get(1).getContents());\n\t\tassertEquals(\"a2\", fromDb.getAdminComments().get(0).getContents());\n\t\tassertEquals(RegistrationRequestStatus.accepted, fromDb.getStatus());\n\t\tassertEquals(id3, fromDb.getRequestId());\n\t\tassertNotNull(fromDb.getTimestamp());\n\t\tEntity added = idsMan.getEntity(new EntityParam(new IdentityTaV(X500Identity.ID, \"CN=registration test\")));\n\t\tassertEquals(EntityState.valid, added.getState());\n\t\tassertEquals(EngineInitialization.DEFAULT_CREDENTIAL_REQUIREMENT,\n\t\t\t\tadded.getCredentialInfo().getCredentialRequirementId());\n\t\tassertThat(fromDb.getCreatedEntityId(), is(added.getId()));\n\t\tCredentialPublicInformation cpi = added.getCredentialInfo().getCredentialsState().get(\n\t\t\t\tEngineInitialization.DEFAULT_CREDENTIAL);\n\t\tassertEquals(LocalCredentialState.correct, cpi.getState());\n\t\tEntityParam addedP = new EntityParam(added.getId());\n\t\tCollection<String> groups = idsMan.getGroups(addedP).keySet();\n\t\tassertTrue(groups.contains(\"\/\"));\n\t\tassertTrue(groups.contains(\"\/A\"));\n\t\tassertTrue(groups.contains(\"\/B\"));\n\t\tCollection<AttributesClass> acs = acMan.getEntityAttributeClasses(addedP, \"\/\");\n\t\tassertEquals(1, acs.size());\n\t\tassertEquals(InitializerCommon.NAMING_AC, acs.iterator().next().getName());\n\t\tCollection<AttributeExt> attrs = attrsMan.getAttributes(addedP, \"\/\", \"cn\");\n\t\tassertEquals(1, attrs.size());\n\t\tassertEquals(\"val\", attrs.iterator().next().getValues().get(0));\n\t\tattrs = attrsMan.getAttributes(addedP, \"\/\", \"email\");\n\t\tassertEquals(1, attrs.size());\n\t\tString value = attrs.iterator().next().getValues().get(0);\n\t\tVerifiableEmail ve = new VerifiableEmail(JsonUtil.parse(value)); \/\/FIXME - this is likely wrong\n\t\tassertEquals(\"foo@example.com\", ve.getValue());\n\t\tassertEquals(false, ve.getConfirmationInfo().isConfirmed());\n\t}","code":"@Test\n\tpublic void acceptedRequestIsFullyApplied() throws EngineException\n\t{\n\t\tRegistrationContext defContext = new RegistrationContext(false, TriggeringMode.manualAtLogin);\n\t\tinitAndCreateForm(false, null);\n\t\tRegistrationRequest request = getRequest();\n\t\tString id3 = registrationsMan.submitRegistrationRequest(request, defContext);\n\t\tregistrationsMan.processRegistrationRequest(id3, null, \n\t\t\t\tRegistrationRequestAction.accept, \"a2\", \"p2\");\n\t\tRegistrationRequestState fromDb = registrationsMan.getRegistrationRequests().get(0);\n\t\tassertEquals(request, fromDb.getRequest());\n\t\tassertEquals(2, fromDb.getAdminComments().size());\n\t\tassertEquals(\"p2\", fromDb.getAdminComments().get(1).getContents());\n\t\tassertEquals(\"a2\", fromDb.getAdminComments().get(0).getContents());\n\t\tassertEquals(RegistrationRequestStatus.accepted, fromDb.getStatus());\n\t\tassertEquals(id3, fromDb.getRequestId());\n\t\tassertNotNull(fromDb.getTimestamp());\n\t\tEntity added = idsMan.getEntity(new EntityParam(new IdentityTaV(X500Identity.ID, \"CN=registration test\")));\n\t\tassertEquals(EntityState.valid, added.getState());\n\t\tassertEquals(EngineInitialization.DEFAULT_CREDENTIAL_REQUIREMENT,\n\t\t\t\tadded.getCredentialInfo().getCredentialRequirementId());\n\t\tassertThat(fromDb.getCreatedEntityId(), is(added.getId()));\n\t\tCredentialPublicInformation cpi = added.getCredentialInfo().getCredentialsState().get(\n\t\t\t\tEngineInitialization.DEFAULT_CREDENTIAL);\n\t\tassertEquals(LocalCredentialState.correct, cpi.getState());\n\t\tEntityParam addedP = new EntityParam(added.getId());\n\t\tCollection<String> groups = idsMan.getGroups(addedP).keySet();\n\t\tassertTrue(groups.contains(\"\/\"));\n\t\tassertTrue(groups.contains(\"\/A\"));\n\t\tassertTrue(groups.contains(\"\/B\"));\n\t\tCollection<AttributesClass> acs = acMan.getEntityAttributeClasses(addedP, \"\/\");\n\t\tassertEquals(1, acs.size());\n\t\tassertEquals(InitializerCommon.NAMING_AC, acs.iterator().next().getName());\n\t\tCollection<AttributeExt> attrs = attrsMan.getAttributes(addedP, \"\/\", \"cn\");\n\t\tassertEquals(1, attrs.size());\n\t\tassertEquals(\"val\", attrs.iterator().next().getValues().get(0));\n\t\tattrs = attrsMan.getAttributes(addedP, \"\/\", \"email\");\n\t\tassertEquals(1, attrs.size());\n\t\tString value = attrs.iterator().next().getValues().get(0);\n\t\tVerifiableEmail ve = new VerifiableEmail(JsonUtil.parse(value));\n\t\tassertEquals(\"foo@example.com\", ve.getValue());\n\t\tassertEquals(false, ve.getConfirmationInfo().isConfirmed());\n\t}","cleancode":"@test public void acceptedrequestisfullyapplied() throws engineexception { registrationcontext defcontext = new registrationcontext(false, triggeringmode.manualatlogin); initandcreateform(false, null); registrationrequest request = getrequest(); string id3 = registrationsman.submitregistrationrequest(request, defcontext); registrationsman.processregistrationrequest(id3, null, registrationrequestaction.accept, \"a2\", \"p2\"); registrationrequeststate fromdb = registrationsman.getregistrationrequests().get(0); assertequals(request, fromdb.getrequest()); assertequals(2, fromdb.getadmincomments().size()); assertequals(\"p2\", fromdb.getadmincomments().get(1).getcontents()); assertequals(\"a2\", fromdb.getadmincomments().get(0).getcontents()); assertequals(registrationrequeststatus.accepted, fromdb.getstatus()); assertequals(id3, fromdb.getrequestid()); assertnotnull(fromdb.gettimestamp()); entity added = idsman.getentity(new entityparam(new identitytav(x500identity.id, \"cn=registration test\"))); assertequals(entitystate.valid, added.getstate()); assertequals(engineinitialization.default_credential_requirement, added.getcredentialinfo().getcredentialrequirementid()); assertthat(fromdb.getcreatedentityid(), is(added.getid())); credentialpublicinformation cpi = added.getcredentialinfo().getcredentialsstate().get( engineinitialization.default_credential); assertequals(localcredentialstate.correct, cpi.getstate()); entityparam addedp = new entityparam(added.getid()); collection<string> groups = idsman.getgroups(addedp).keyset(); asserttrue(groups.contains(\"\/\")); asserttrue(groups.contains(\"\/a\")); asserttrue(groups.contains(\"\/b\")); collection<attributesclass> acs = acman.getentityattributeclasses(addedp, \"\/\"); assertequals(1, acs.size()); assertequals(initializercommon.naming_ac, acs.iterator().next().getname()); collection<attributeext> attrs = attrsman.getattributes(addedp, \"\/\", \"cn\"); assertequals(1, attrs.size()); assertequals(\"val\", attrs.iterator().next().getvalues().get(0)); attrs = attrsman.getattributes(addedp, \"\/\", \"email\"); assertequals(1, attrs.size()); string value = attrs.iterator().next().getvalues().get(0); verifiableemail ve = new verifiableemail(jsonutil.parse(value)); assertequals(\"foo@example.com\", ve.getvalue()); assertequals(false, ve.getconfirmationinfo().isconfirmed()); }","comment":"\/\/fixme - this is likely wrong","repo":"olivier-maury\/unity","code_context_2":"assertEquals(1, attrs.size());\nString value = attrs.iterator().next().getValues().get(0);\nVerifiableEmail ve = new VerifiableEmail(JsonUtil.parse(value)); \/\/FIXME - this is likely wrong\nassertEquals(\"foo@example.com\", ve.getValue());\nassertEquals(false, ve.getConfirmationInfo().isConfirmed());","code_context_10":"assertTrue(groups.contains(\"\/B\"));\nCollection<AttributesClass> acs = acMan.getEntityAttributeClasses(addedP, \"\/\");\nassertEquals(1, acs.size());\nassertEquals(InitializerCommon.NAMING_AC, acs.iterator().next().getName());\nCollection<AttributeExt> attrs = attrsMan.getAttributes(addedP, \"\/\", \"cn\");\nassertEquals(1, attrs.size());\nassertEquals(\"val\", attrs.iterator().next().getValues().get(0));\nattrs = attrsMan.getAttributes(addedP, \"\/\", \"email\");\nassertEquals(1, attrs.size());\nString value = attrs.iterator().next().getValues().get(0);\nVerifiableEmail ve = new VerifiableEmail(JsonUtil.parse(value)); \/\/FIXME - this is likely wrong\nassertEquals(\"foo@example.com\", ve.getValue());\nassertEquals(false, ve.getConfirmationInfo().isConfirmed());\n}","code_context_20":"assertEquals(EngineInitialization.DEFAULT_CREDENTIAL_REQUIREMENT,\nadded.getCredentialInfo().getCredentialRequirementId());\nassertThat(fromDb.getCreatedEntityId(), is(added.getId()));\nCredentialPublicInformation cpi = added.getCredentialInfo().getCredentialsState().get(\nEngineInitialization.DEFAULT_CREDENTIAL);\nassertEquals(LocalCredentialState.correct, cpi.getState());\nEntityParam addedP = new EntityParam(added.getId());\nCollection<String> groups = idsMan.getGroups(addedP).keySet();\nassertTrue(groups.contains(\"\/\"));\nassertTrue(groups.contains(\"\/A\"));\nassertTrue(groups.contains(\"\/B\"));\nCollection<AttributesClass> acs = acMan.getEntityAttributeClasses(addedP, \"\/\");\nassertEquals(1, acs.size());\nassertEquals(InitializerCommon.NAMING_AC, acs.iterator().next().getName());\nCollection<AttributeExt> attrs = attrsMan.getAttributes(addedP, \"\/\", \"cn\");\nassertEquals(1, attrs.size());\nassertEquals(\"val\", attrs.iterator().next().getValues().get(0));\nattrs = attrsMan.getAttributes(addedP, \"\/\", \"email\");\nassertEquals(1, attrs.size());\nString value = attrs.iterator().next().getValues().get(0);\nVerifiableEmail ve = new VerifiableEmail(JsonUtil.parse(value)); \/\/FIXME - this is likely wrong\nassertEquals(\"foo@example.com\", ve.getValue());\nassertEquals(false, ve.getConfirmationInfo().isConfirmed());\n}","label":[0,0,1,0]}
{"id":23007,"original_code":"public static boolean isAlreadySubtitled( Downloadable videoDownloadable, Language subtitlesLanguage ) throws IOException, InterruptedException {\n\t\tList<DownloadableFile> allFiles = DownloadableManager.getInstance().getAllFiles( videoDownloadable.getId() );\n\t\tPath mainVideoFilePath;\n\t\tString filename;\n\t\tOptional<Path> optPath = selectMainVideoFile( allFiles );\n\t\tif (optPath.isPresent()) {\n\t\t\tmainVideoFilePath = optPath.get();\n\t\t\tfilename = mainVideoFilePath.getFileName().toString();\n\t\t} else {\n\t\t\tErrorManager.getInstance().reportError(String.format(\"No video file found for %s\", videoDownloadable.toString()));\n\t\t\treturn false;\n\t\t}\n\t\tif (subtitlesLanguage == null) {\n\t\t\treturn true;\n\t\t}\n\t\tif (subtitlesLanguage.getSubTokens() != null) {\n\t\t\t\/\/ Test if the filename contains an indication of the subtitles (VOSTFR, ...)\n\t\t\tfor (String subToken : subtitlesLanguage.getSubTokens()) {\n\t\t\t\tif ( StringUtils.containsIgnoreCase( filename, subToken) ) {\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tVideoMetaData metaData = getInstance().getMetaData(videoDownloadable, mainVideoFilePath);\n\t\tif (metaData.getSubtitleLanguages() != null) {\n\t\t\tfor (Locale locale : metaData.getSubtitleLanguages()) {\n\t\t\t\tif (locale.getLanguage().equals( subtitlesLanguage.getLocale().getLanguage() )) {\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tList<DownloadableFile> subtitleFiles =\n\t\t\t\tallFiles.stream()\n\t\t\t\t.filter( file -> SubtitlesFileFilter.getInstance().accept( file.getFilePath() ) )\n\t\t\t\t.collect( Collectors.toList() );\n\t\tString filenameWithoutExtension = filename; \n\t\tif ( filenameWithoutExtension.lastIndexOf('.') > 0 ) {\n\t\t\tfilenameWithoutExtension = filenameWithoutExtension.substring( 0, filenameWithoutExtension.lastIndexOf('.'));\n\t\t}\n\t\tString targetFileNameRegExp = filenameWithoutExtension + \".\" + subtitlesLanguage.getShortName() + \"\\\\.srt\";\n\t\tfor (DownloadableFile subTitleFile : subtitleFiles) {\n\t\t\tString subtitleFileName = subTitleFile.getFilePath().getFileName().toString();\n\t\t\tif (RegExp.matches(subtitleFileName, targetFileNameRegExp )) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t\t\/\/ FIXME : this last test will accept any subtitle file without checking the language\n\t\tif (!subtitleFiles.isEmpty()) {\n\t\t\treturn true;\n\t\t}\n\t\treturn false;\n\t}","code":"public static boolean isAlreadySubtitled( Downloadable videoDownloadable, Language subtitlesLanguage ) throws IOException, InterruptedException {\n\t\tList<DownloadableFile> allFiles = DownloadableManager.getInstance().getAllFiles( videoDownloadable.getId() );\n\t\tPath mainVideoFilePath;\n\t\tString filename;\n\t\tOptional<Path> optPath = selectMainVideoFile( allFiles );\n\t\tif (optPath.isPresent()) {\n\t\t\tmainVideoFilePath = optPath.get();\n\t\t\tfilename = mainVideoFilePath.getFileName().toString();\n\t\t} else {\n\t\t\tErrorManager.getInstance().reportError(String.format(\"No video file found for %s\", videoDownloadable.toString()));\n\t\t\treturn false;\n\t\t}\n\t\tif (subtitlesLanguage == null) {\n\t\t\treturn true;\n\t\t}\n\t\tif (subtitlesLanguage.getSubTokens() != null) {\n\t\t\n\t\t\tfor (String subToken : subtitlesLanguage.getSubTokens()) {\n\t\t\t\tif ( StringUtils.containsIgnoreCase( filename, subToken) ) {\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tVideoMetaData metaData = getInstance().getMetaData(videoDownloadable, mainVideoFilePath);\n\t\tif (metaData.getSubtitleLanguages() != null) {\n\t\t\tfor (Locale locale : metaData.getSubtitleLanguages()) {\n\t\t\t\tif (locale.getLanguage().equals( subtitlesLanguage.getLocale().getLanguage() )) {\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tList<DownloadableFile> subtitleFiles =\n\t\t\t\tallFiles.stream()\n\t\t\t\t.filter( file -> SubtitlesFileFilter.getInstance().accept( file.getFilePath() ) )\n\t\t\t\t.collect( Collectors.toList() );\n\t\tString filenameWithoutExtension = filename; \n\t\tif ( filenameWithoutExtension.lastIndexOf('.') > 0 ) {\n\t\t\tfilenameWithoutExtension = filenameWithoutExtension.substring( 0, filenameWithoutExtension.lastIndexOf('.'));\n\t\t}\n\t\tString targetFileNameRegExp = filenameWithoutExtension + \".\" + subtitlesLanguage.getShortName() + \"\\\\.srt\";\n\t\tfor (DownloadableFile subTitleFile : subtitleFiles) {\n\t\t\tString subtitleFileName = subTitleFile.getFilePath().getFileName().toString();\n\t\t\tif (RegExp.matches(subtitleFileName, targetFileNameRegExp )) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t\n\t\tif (!subtitleFiles.isEmpty()) {\n\t\t\treturn true;\n\t\t}\n\t\treturn false;\n\t}","cleancode":"public static boolean isalreadysubtitled( downloadable videodownloadable, language subtitleslanguage ) throws ioexception, interruptedexception { list<downloadablefile> allfiles = downloadablemanager.getinstance().getallfiles( videodownloadable.getid() ); path mainvideofilepath; string filename; optional<path> optpath = selectmainvideofile( allfiles ); if (optpath.ispresent()) { mainvideofilepath = optpath.get(); filename = mainvideofilepath.getfilename().tostring(); } else { errormanager.getinstance().reporterror(string.format(\"no video file found for %s\", videodownloadable.tostring())); return false; } if (subtitleslanguage == null) { return true; } if (subtitleslanguage.getsubtokens() != null) { for (string subtoken : subtitleslanguage.getsubtokens()) { if ( stringutils.containsignorecase( filename, subtoken) ) { return true; } } } videometadata metadata = getinstance().getmetadata(videodownloadable, mainvideofilepath); if (metadata.getsubtitlelanguages() != null) { for (locale locale : metadata.getsubtitlelanguages()) { if (locale.getlanguage().equals( subtitleslanguage.getlocale().getlanguage() )) { return true; } } } list<downloadablefile> subtitlefiles = allfiles.stream() .filter( file -> subtitlesfilefilter.getinstance().accept( file.getfilepath() ) ) .collect( collectors.tolist() ); string filenamewithoutextension = filename; if ( filenamewithoutextension.lastindexof('.') > 0 ) { filenamewithoutextension = filenamewithoutextension.substring( 0, filenamewithoutextension.lastindexof('.')); } string targetfilenameregexp = filenamewithoutextension + \".\" + subtitleslanguage.getshortname() + \"\\\\.srt\"; for (downloadablefile subtitlefile : subtitlefiles) { string subtitlefilename = subtitlefile.getfilepath().getfilename().tostring(); if (regexp.matches(subtitlefilename, targetfilenameregexp )) { return true; } } if (!subtitlefiles.isempty()) { return true; } return false; }","comment":"\/\/ test if the filename contains an indication of the subtitles (vostfr, ...)\n\/\/ fixme : this last test will accept any subtitle file without checking the language","repo":"mozvip\/dynamo","code_context_2":"}\nif (subtitlesLanguage.getSubTokens() != null) {\n\/\/ Test if the filename contains an indication of the subtitles (VOSTFR, ...)\nfor (String subToken : subtitlesLanguage.getSubTokens()) {\nif ( StringUtils.containsIgnoreCase( filename, subToken) ) {\n\n}\n}\n\/\/ FIXME : this last test will accept any subtitle file without checking the language\nif (!subtitleFiles.isEmpty()) {\nreturn true;","code_context_10":"mainVideoFilePath = optPath.get();\nfilename = mainVideoFilePath.getFileName().toString();\n} else {\nErrorManager.getInstance().reportError(String.format(\"No video file found for %s\", videoDownloadable.toString()));\nreturn false;\n}\nif (subtitlesLanguage == null) {\nreturn true;\n}\nif (subtitlesLanguage.getSubTokens() != null) {\n\/\/ Test if the filename contains an indication of the subtitles (VOSTFR, ...)\nfor (String subToken : subtitlesLanguage.getSubTokens()) {\nif ( StringUtils.containsIgnoreCase( filename, subToken) ) {\nreturn true;\n}\n}\n}\nVideoMetaData metaData = getInstance().getMetaData(videoDownloadable, mainVideoFilePath);\nif (metaData.getSubtitleLanguages() != null) {\nfor (Locale locale : metaData.getSubtitleLanguages()) {\nif (locale.getLanguage().equals( subtitlesLanguage.getLocale().getLanguage() )) {\n\nif ( filenameWithoutExtension.lastIndexOf('.') > 0 ) {\nfilenameWithoutExtension = filenameWithoutExtension.substring( 0, filenameWithoutExtension.lastIndexOf('.'));\n}\nString targetFileNameRegExp = filenameWithoutExtension + \".\" + subtitlesLanguage.getShortName() + \"\\\\.srt\";\nfor (DownloadableFile subTitleFile : subtitleFiles) {\nString subtitleFileName = subTitleFile.getFilePath().getFileName().toString();\nif (RegExp.matches(subtitleFileName, targetFileNameRegExp )) {\nreturn true;\n}\n}\n\/\/ FIXME : this last test will accept any subtitle file without checking the language\nif (!subtitleFiles.isEmpty()) {\nreturn true;\n}\nreturn false;\n}","code_context_20":"public static boolean isAlreadySubtitled( Downloadable videoDownloadable, Language subtitlesLanguage ) throws IOException, InterruptedException {\nList<DownloadableFile> allFiles = DownloadableManager.getInstance().getAllFiles( videoDownloadable.getId() );\nPath mainVideoFilePath;\nString filename;\nOptional<Path> optPath = selectMainVideoFile( allFiles );\nif (optPath.isPresent()) {\nmainVideoFilePath = optPath.get();\nfilename = mainVideoFilePath.getFileName().toString();\n} else {\nErrorManager.getInstance().reportError(String.format(\"No video file found for %s\", videoDownloadable.toString()));\nreturn false;\n}\nif (subtitlesLanguage == null) {\nreturn true;\n}\nif (subtitlesLanguage.getSubTokens() != null) {\n\/\/ Test if the filename contains an indication of the subtitles (VOSTFR, ...)\nfor (String subToken : subtitlesLanguage.getSubTokens()) {\nif ( StringUtils.containsIgnoreCase( filename, subToken) ) {\nreturn true;\n}\n}\n}\nVideoMetaData metaData = getInstance().getMetaData(videoDownloadable, mainVideoFilePath);\nif (metaData.getSubtitleLanguages() != null) {\nfor (Locale locale : metaData.getSubtitleLanguages()) {\nif (locale.getLanguage().equals( subtitlesLanguage.getLocale().getLanguage() )) {\nreturn true;\n}\n}\n}\nList<DownloadableFile> subtitleFiles =\nallFiles.stream()\n.filter( file -> SubtitlesFileFilter.getInstance().accept( file.getFilePath() ) )\n.collect( Collectors.toList() );\nString filenameWithoutExtension = filename;\nif ( filenameWithoutExtension.lastIndexOf('.') > 0 ) {\n\nif (locale.getLanguage().equals( subtitlesLanguage.getLocale().getLanguage() )) {\nreturn true;\n}\n}\n}\nList<DownloadableFile> subtitleFiles =\nallFiles.stream()\n.filter( file -> SubtitlesFileFilter.getInstance().accept( file.getFilePath() ) )\n.collect( Collectors.toList() );\nString filenameWithoutExtension = filename;\nif ( filenameWithoutExtension.lastIndexOf('.') > 0 ) {\nfilenameWithoutExtension = filenameWithoutExtension.substring( 0, filenameWithoutExtension.lastIndexOf('.'));\n}\nString targetFileNameRegExp = filenameWithoutExtension + \".\" + subtitlesLanguage.getShortName() + \"\\\\.srt\";\nfor (DownloadableFile subTitleFile : subtitleFiles) {\nString subtitleFileName = subTitleFile.getFilePath().getFileName().toString();\nif (RegExp.matches(subtitleFileName, targetFileNameRegExp )) {\nreturn true;\n}\n}\n\/\/ FIXME : this last test will accept any subtitle file without checking the language\nif (!subtitleFiles.isEmpty()) {\nreturn true;\n}\nreturn false;\n}","label":[0,0,1,0]}
{"id":14893,"original_code":"public void addBlock(Set<CFANode> nodes, CFANode blockHead) {\n    Set<ReferencedVariable> referencedVariables = collectReferencedVariables(nodes);\n    Set<CFANode> callNodes = collectCallNodes(nodes);\n    Set<CFANode> returnNodes = collectReturnNodes(nodes);\n    Set<FunctionEntryNode> innerFunctionCalls = collectInnerFunctionCalls(nodes);\n    if (callNodes.isEmpty()) {\n     \/* What shall we do with function, which is not called from anywhere?\n      * There are problems with them at partitioning building stage\n      *\/\n      return;\n    }\n    CFANode registerNode = null;\n    for (CFANode node : callNodes) {\n      registerNode = node;\n      if (node instanceof FunctionEntryNode) {\n        break;\n      }\n    }\n    if (registerNode == null) {\n      \/\/It means, that there is no entry in this block. Don't add it\n      return;\n    }\n    referencedVariablesMap.put(registerNode, referencedVariables);\n    callNodesMap.put(registerNode, callNodes);\n    returnNodesMap.put(registerNode, returnNodes);\n    innerFunctionCallsMap.put(registerNode, innerFunctionCalls);\n    blockNodesMap.put(registerNode, nodes);\n  }","code":"public void addBlock(Set<CFANode> nodes, CFANode blockHead) {\n    Set<ReferencedVariable> referencedVariables = collectReferencedVariables(nodes);\n    Set<CFANode> callNodes = collectCallNodes(nodes);\n    Set<CFANode> returnNodes = collectReturnNodes(nodes);\n    Set<FunctionEntryNode> innerFunctionCalls = collectInnerFunctionCalls(nodes);\n    if (callNodes.isEmpty()) {\n    \n      return;\n    }\n    CFANode registerNode = null;\n    for (CFANode node : callNodes) {\n      registerNode = node;\n      if (node instanceof FunctionEntryNode) {\n        break;\n      }\n    }\n    if (registerNode == null) {\n     \n      return;\n    }\n    referencedVariablesMap.put(registerNode, referencedVariables);\n    callNodesMap.put(registerNode, callNodes);\n    returnNodesMap.put(registerNode, returnNodes);\n    innerFunctionCallsMap.put(registerNode, innerFunctionCalls);\n    blockNodesMap.put(registerNode, nodes);\n  }","cleancode":"public void addblock(set<cfanode> nodes, cfanode blockhead) { set<referencedvariable> referencedvariables = collectreferencedvariables(nodes); set<cfanode> callnodes = collectcallnodes(nodes); set<cfanode> returnnodes = collectreturnnodes(nodes); set<functionentrynode> innerfunctioncalls = collectinnerfunctioncalls(nodes); if (callnodes.isempty()) { return; } cfanode registernode = null; for (cfanode node : callnodes) { registernode = node; if (node instanceof functionentrynode) { break; } } if (registernode == null) { return; } referencedvariablesmap.put(registernode, referencedvariables); callnodesmap.put(registernode, callnodes); returnnodesmap.put(registernode, returnnodes); innerfunctioncallsmap.put(registernode, innerfunctioncalls); blocknodesmap.put(registernode, nodes); }","comment":"\/** * create new block. * * @param nodes nodes from which block should be created; if the set of nodes contains inner * function calls, the called function body should not be included. * @param blockhead entry point for the block. *\/\n\/* what shall we do with function, which is not called from anywhere? * there are problems with them at partitioning building stage *\/\n\/\/it means, that there is no entry in this block. don't add it","repo":"prokopk1n\/cpachecker-1","code_context_2":"public void addBlock(Set<CFANode> nodes, CFANode blockHead) {\nSet<ReferencedVariable> referencedVariables = collectReferencedVariables(nodes);\nSet<CFANode> callNodes = collectCallNodes(nodes);\nSet<CFANode> returnNodes = collectReturnNodes(nodes);\nSet<FunctionEntryNode> innerFunctionCalls = collectInnerFunctionCalls(nodes);\nif (callNodes.isEmpty()) {\n\/* What shall we do with function, which is not called from anywhere?\n* There are problems with them at partitioning building stage\n*\/\nreturn;\n}\nCFANode registerNode = null;\nfor (CFANode node : callNodes) {\nregisterNode = node;\nif (node instanceof FunctionEntryNode) {\nbreak;\n}\n}\nif (registerNode == null) {\n\/\/It means, that there is no entry in this block. Don't add it\nreturn;\n}\nreferencedVariablesMap.put(registerNode, referencedVariables);\ncallNodesMap.put(registerNode, callNodes);\nreturnNodesMap.put(registerNode, returnNodes);\ninnerFunctionCallsMap.put(registerNode, innerFunctionCalls);\nblockNodesMap.put(registerNode, nodes);\n}\n\nSet<FunctionEntryNode> innerFunctionCalls = collectInnerFunctionCalls(nodes);\nif (callNodes.isEmpty()) {\n\/* What shall we do with function, which is not called from anywhere?\n* There are problems with them at partitioning building stage\n*\/\nreturn;\n}\n\n}\nif (registerNode == null) {\n\/\/It means, that there is no entry in this block. Don't add it\nreturn;\n}","code_context_10":"public void addBlock(Set<CFANode> nodes, CFANode blockHead) {\nSet<ReferencedVariable> referencedVariables = collectReferencedVariables(nodes);\nSet<CFANode> callNodes = collectCallNodes(nodes);\nSet<CFANode> returnNodes = collectReturnNodes(nodes);\nSet<FunctionEntryNode> innerFunctionCalls = collectInnerFunctionCalls(nodes);\nif (callNodes.isEmpty()) {\n\/* What shall we do with function, which is not called from anywhere?\n* There are problems with them at partitioning building stage\n*\/\nreturn;\n}\nCFANode registerNode = null;\nfor (CFANode node : callNodes) {\nregisterNode = node;\nif (node instanceof FunctionEntryNode) {\nbreak;\n}\n}\nif (registerNode == null) {\n\/\/It means, that there is no entry in this block. Don't add it\nreturn;\n}\nreferencedVariablesMap.put(registerNode, referencedVariables);\ncallNodesMap.put(registerNode, callNodes);\nreturnNodesMap.put(registerNode, returnNodes);\ninnerFunctionCallsMap.put(registerNode, innerFunctionCalls);\nblockNodesMap.put(registerNode, nodes);\n}\n\npublic void addBlock(Set<CFANode> nodes, CFANode blockHead) {\nSet<ReferencedVariable> referencedVariables = collectReferencedVariables(nodes);\nSet<CFANode> callNodes = collectCallNodes(nodes);\nSet<CFANode> returnNodes = collectReturnNodes(nodes);\nSet<FunctionEntryNode> innerFunctionCalls = collectInnerFunctionCalls(nodes);\nif (callNodes.isEmpty()) {\n\/* What shall we do with function, which is not called from anywhere?\n* There are problems with them at partitioning building stage\n*\/\nreturn;\n}\nCFANode registerNode = null;\nfor (CFANode node : callNodes) {\nregisterNode = node;\nif (node instanceof FunctionEntryNode) {\nbreak;\n}\n}\nif (registerNode == null) {\n\nreturn;\n}\nCFANode registerNode = null;\nfor (CFANode node : callNodes) {\nregisterNode = node;\nif (node instanceof FunctionEntryNode) {\nbreak;\n}\n}\nif (registerNode == null) {\n\/\/It means, that there is no entry in this block. Don't add it\nreturn;\n}\nreferencedVariablesMap.put(registerNode, referencedVariables);\ncallNodesMap.put(registerNode, callNodes);\nreturnNodesMap.put(registerNode, returnNodes);\ninnerFunctionCallsMap.put(registerNode, innerFunctionCalls);\nblockNodesMap.put(registerNode, nodes);\n}","code_context_20":"public void addBlock(Set<CFANode> nodes, CFANode blockHead) {\nSet<ReferencedVariable> referencedVariables = collectReferencedVariables(nodes);\nSet<CFANode> callNodes = collectCallNodes(nodes);\nSet<CFANode> returnNodes = collectReturnNodes(nodes);\nSet<FunctionEntryNode> innerFunctionCalls = collectInnerFunctionCalls(nodes);\nif (callNodes.isEmpty()) {\n\/* What shall we do with function, which is not called from anywhere?\n* There are problems with them at partitioning building stage\n*\/\nreturn;\n}\nCFANode registerNode = null;\nfor (CFANode node : callNodes) {\nregisterNode = node;\nif (node instanceof FunctionEntryNode) {\nbreak;\n}\n}\nif (registerNode == null) {\n\/\/It means, that there is no entry in this block. Don't add it\nreturn;\n}\nreferencedVariablesMap.put(registerNode, referencedVariables);\ncallNodesMap.put(registerNode, callNodes);\nreturnNodesMap.put(registerNode, returnNodes);\ninnerFunctionCallsMap.put(registerNode, innerFunctionCalls);\nblockNodesMap.put(registerNode, nodes);\n}\n\npublic void addBlock(Set<CFANode> nodes, CFANode blockHead) {\nSet<ReferencedVariable> referencedVariables = collectReferencedVariables(nodes);\nSet<CFANode> callNodes = collectCallNodes(nodes);\nSet<CFANode> returnNodes = collectReturnNodes(nodes);\nSet<FunctionEntryNode> innerFunctionCalls = collectInnerFunctionCalls(nodes);\nif (callNodes.isEmpty()) {\n\/* What shall we do with function, which is not called from anywhere?\n* There are problems with them at partitioning building stage\n*\/\nreturn;\n}\nCFANode registerNode = null;\nfor (CFANode node : callNodes) {\nregisterNode = node;\nif (node instanceof FunctionEntryNode) {\nbreak;\n}\n}\nif (registerNode == null) {\n\/\/It means, that there is no entry in this block. Don't add it\nreturn;\n}\nreferencedVariablesMap.put(registerNode, referencedVariables);\ncallNodesMap.put(registerNode, callNodes);\nreturnNodesMap.put(registerNode, returnNodes);\ninnerFunctionCallsMap.put(registerNode, innerFunctionCalls);\nblockNodesMap.put(registerNode, nodes);\n}\n\npublic void addBlock(Set<CFANode> nodes, CFANode blockHead) {\nSet<ReferencedVariable> referencedVariables = collectReferencedVariables(nodes);\nSet<CFANode> callNodes = collectCallNodes(nodes);\nSet<CFANode> returnNodes = collectReturnNodes(nodes);\nSet<FunctionEntryNode> innerFunctionCalls = collectInnerFunctionCalls(nodes);\nif (callNodes.isEmpty()) {\n\/* What shall we do with function, which is not called from anywhere?\n* There are problems with them at partitioning building stage\n*\/\nreturn;\n}\nCFANode registerNode = null;\nfor (CFANode node : callNodes) {\nregisterNode = node;\nif (node instanceof FunctionEntryNode) {\nbreak;\n}\n}\nif (registerNode == null) {\n\/\/It means, that there is no entry in this block. Don't add it\nreturn;\n}\nreferencedVariablesMap.put(registerNode, referencedVariables);\ncallNodesMap.put(registerNode, callNodes);\nreturnNodesMap.put(registerNode, returnNodes);\ninnerFunctionCallsMap.put(registerNode, innerFunctionCalls);\nblockNodesMap.put(registerNode, nodes);\n}","label":[0,1,0,0]}
{"id":23121,"original_code":"@Test\n  public void isJson_shouldReturnTrue_whenStringIsJsonArray() throws JSONException {\n    assertTrue(validateTor.isJSON(\"[]\"));\n    assertTrue(validateTor.isJSON(\"[{\\\"id\\\":1}]\"));\n  }","code":"@Test\n  public void isJson_shouldReturnTrue_whenStringIsJsonArray() throws JSONException {\n    assertTrue(validateTor.isJSON(\"[]\"));\n    assertTrue(validateTor.isJSON(\"[{\\\"id\\\":1}]\"));\n  }","cleancode":"@test public void isjson_shouldreturntrue_whenstringisjsonarray() throws jsonexception { asserttrue(validatetor.isjson(\"[]\")); asserttrue(validatetor.isjson(\"[{\\\"id\\\":1}]\")); }","comment":"\/\/ not work, maybe only in android junit test.","repo":"nisrulz\/validatetor","code_context_2":"@Test\npublic void isJson_shouldReturnTrue_whenStringIsJsonArray() throws JSONException {\nassertTrue(validateTor.isJSON(\"[]\"));\nassertTrue(validateTor.isJSON(\"[{\\\"id\\\":1}]\"));\n}","code_context_10":"@Test\npublic void isJson_shouldReturnTrue_whenStringIsJsonArray() throws JSONException {\nassertTrue(validateTor.isJSON(\"[]\"));\nassertTrue(validateTor.isJSON(\"[{\\\"id\\\":1}]\"));\n}","code_context_20":"@Test\npublic void isJson_shouldReturnTrue_whenStringIsJsonArray() throws JSONException {\nassertTrue(validateTor.isJSON(\"[]\"));\nassertTrue(validateTor.isJSON(\"[{\\\"id\\\":1}]\"));\n}","label":[0,0,1,0]}
{"id":23144,"original_code":"private static FieldImpl makePointObs(FlatField timeStep, DateTime dt)\n            throws VisADException, RemoteException {\n        if (timeStep == null) {\n            return null;\n        }\n        SampledSet domain    = getSpatialDomain(timeStep);\n        int        numPoints = domain.getLength();\n        Integer1DSet points = new Integer1DSet(RealType.getRealType(\"index\"),\n                numPoints);\n        TupleType tt = getParamType(timeStep);\n        TupleType rangeType = new TupleType(new MathType[] {\n                RealTupleType.LatitudeLongitudeAltitude,\n                RealType.Time,\n                tt });\n        FieldImpl ff = new FieldImpl(\n                new FunctionType(\n                        ((SetType) points.getType()).getDomain(),\n                        rangeType), points);\n        float[][] samples  = timeStep.getFloats(false);\n        float[][] geoVals  = getEarthLocationPoints((GriddedSet) domain);\n        boolean   isLatLon = isLatLonOrder(domain);\n        int       latIndex = isLatLon\n                ? 0\n                : 1;\n        int       lonIndex = isLatLon\n                ? 1\n                : 0;\n        boolean   haveAlt  = geoVals.length > 2;\n        for (int i = 0; i < numPoints; i++) {\n            float lat = geoVals[latIndex][i];\n            float lon = geoVals[lonIndex][i];\n            float alt = haveAlt\n                    ? geoVals[2][i]\n                    : 0;\n            if ((lat == lat) && (lon == lon)) {\n                if ( !(alt == alt)) {\n                    alt = 0;\n                }\n                EarthLocation el = new EarthLocationLite(lat, lon, alt);\n                \/\/ TODO:  make this  more efficient\n                PointObTuple pot = new PointObTuple(el, dt,\n                        timeStep.getSample(i), rangeType);\n                ff.setSample(i, pot, false, false);\n            }\n        }\n        return ff;\n    }","code":"private static FieldImpl makePointObs(FlatField timeStep, DateTime dt)\n            throws VisADException, RemoteException {\n        if (timeStep == null) {\n            return null;\n        }\n        SampledSet domain    = getSpatialDomain(timeStep);\n        int        numPoints = domain.getLength();\n        Integer1DSet points = new Integer1DSet(RealType.getRealType(\"index\"),\n                numPoints);\n        TupleType tt = getParamType(timeStep);\n        TupleType rangeType = new TupleType(new MathType[] {\n                RealTupleType.LatitudeLongitudeAltitude,\n                RealType.Time,\n                tt });\n        FieldImpl ff = new FieldImpl(\n                new FunctionType(\n                        ((SetType) points.getType()).getDomain(),\n                        rangeType), points);\n        float[][] samples  = timeStep.getFloats(false);\n        float[][] geoVals  = getEarthLocationPoints((GriddedSet) domain);\n        boolean   isLatLon = isLatLonOrder(domain);\n        int       latIndex = isLatLon\n                ? 0\n                : 1;\n        int       lonIndex = isLatLon\n                ? 1\n                : 0;\n        boolean   haveAlt  = geoVals.length > 2;\n        for (int i = 0; i < numPoints; i++) {\n            float lat = geoVals[latIndex][i];\n            float lon = geoVals[lonIndex][i];\n            float alt = haveAlt\n                    ? geoVals[2][i]\n                    : 0;\n            if ((lat == lat) && (lon == lon)) {\n                if ( !(alt == alt)) {\n                    alt = 0;\n                }\n                EarthLocation el = new EarthLocationLite(lat, lon, alt);\n               \n                PointObTuple pot = new PointObTuple(el, dt,\n                        timeStep.getSample(i), rangeType);\n                ff.setSample(i, pot, false, false);\n            }\n        }\n        return ff;\n    }","cleancode":"private static fieldimpl makepointobs(flatfield timestep, datetime dt) throws visadexception, remoteexception { if (timestep == null) { return null; } sampledset domain = getspatialdomain(timestep); int numpoints = domain.getlength(); integer1dset points = new integer1dset(realtype.getrealtype(\"index\"), numpoints); tupletype tt = getparamtype(timestep); tupletype rangetype = new tupletype(new mathtype[] { realtupletype.latitudelongitudealtitude, realtype.time, tt }); fieldimpl ff = new fieldimpl( new functiontype( ((settype) points.gettype()).getdomain(), rangetype), points); float[][] samples = timestep.getfloats(false); float[][] geovals = getearthlocationpoints((griddedset) domain); boolean islatlon = islatlonorder(domain); int latindex = islatlon ? 0 : 1; int lonindex = islatlon ? 1 : 0; boolean havealt = geovals.length > 2; for (int i = 0; i < numpoints; i++) { float lat = geovals[latindex][i]; float lon = geovals[lonindex][i]; float alt = havealt ? geovals[2][i] : 0; if ((lat == lat) && (lon == lon)) { if ( !(alt == alt)) { alt = 0; } earthlocation el = new earthlocationlite(lat, lon, alt); pointobtuple pot = new pointobtuple(el, dt, timestep.getsample(i), rangetype); ff.setsample(i, pot, false, false); } } return ff; }","comment":"\/** * make point obs from a single timestep of a grid * * @param timestep the grid * @param dt the timestep for the grid * * @return a field of pointobs * * @throws remoteexception java rmi problem * @throws visadexception visad problem *\/\n\/\/ todo: make this more efficient","repo":"oxelson\/IDV","code_context_2":"private static FieldImpl makePointObs(FlatField timeStep, DateTime dt)\nthrows VisADException, RemoteException {\nif (timeStep == null) {\nreturn null;\n}\nSampledSet domain = getSpatialDomain(timeStep);\nint numPoints = domain.getLength();\nInteger1DSet points = new Integer1DSet(RealType.getRealType(\"index\"),\nnumPoints);\nTupleType tt = getParamType(timeStep);\nTupleType rangeType = new TupleType(new MathType[] {\nRealTupleType.LatitudeLongitudeAltitude,\nRealType.Time,\ntt });\nFieldImpl ff = new FieldImpl(\nnew FunctionType(\n((SetType) points.getType()).getDomain(),\nrangeType), points);\nfloat[][] samples = timeStep.getFloats(false);\nfloat[][] geoVals = getEarthLocationPoints((GriddedSet) domain);\nboolean isLatLon = isLatLonOrder(domain);\nint latIndex = isLatLon\n? 0\n: 1;\nint lonIndex = isLatLon\n? 1\n: 0;\nboolean haveAlt = geoVals.length > 2;\nfor (int i = 0; i < numPoints; i++) {\nfloat lat = geoVals[latIndex][i];\nfloat lon = geoVals[lonIndex][i];\nfloat alt = haveAlt\n? geoVals[2][i]\n: 0;\nif ((lat == lat) && (lon == lon)) {\nif ( !(alt == alt)) {\nalt = 0;\n}\nEarthLocation el = new EarthLocationLite(lat, lon, alt);\n\/\/ TODO: make this more efficient\nPointObTuple pot = new PointObTuple(el, dt,\ntimeStep.getSample(i), rangeType);\nff.setSample(i, pot, false, false);\n}\n}\nreturn ff;\n}\n\n}\nEarthLocation el = new EarthLocationLite(lat, lon, alt);\n\/\/ TODO: make this more efficient\nPointObTuple pot = new PointObTuple(el, dt,\ntimeStep.getSample(i), rangeType);","code_context_10":"private static FieldImpl makePointObs(FlatField timeStep, DateTime dt)\nthrows VisADException, RemoteException {\nif (timeStep == null) {\nreturn null;\n}\nSampledSet domain = getSpatialDomain(timeStep);\nint numPoints = domain.getLength();\nInteger1DSet points = new Integer1DSet(RealType.getRealType(\"index\"),\nnumPoints);\nTupleType tt = getParamType(timeStep);\nTupleType rangeType = new TupleType(new MathType[] {\nRealTupleType.LatitudeLongitudeAltitude,\nRealType.Time,\ntt });\nFieldImpl ff = new FieldImpl(\nnew FunctionType(\n((SetType) points.getType()).getDomain(),\nrangeType), points);\nfloat[][] samples = timeStep.getFloats(false);\nfloat[][] geoVals = getEarthLocationPoints((GriddedSet) domain);\nboolean isLatLon = isLatLonOrder(domain);\nint latIndex = isLatLon\n? 0\n: 1;\nint lonIndex = isLatLon\n? 1\n: 0;\nboolean haveAlt = geoVals.length > 2;\nfor (int i = 0; i < numPoints; i++) {\nfloat lat = geoVals[latIndex][i];\nfloat lon = geoVals[lonIndex][i];\nfloat alt = haveAlt\n? geoVals[2][i]\n: 0;\nif ((lat == lat) && (lon == lon)) {\nif ( !(alt == alt)) {\nalt = 0;\n}\nEarthLocation el = new EarthLocationLite(lat, lon, alt);\n\/\/ TODO: make this more efficient\nPointObTuple pot = new PointObTuple(el, dt,\ntimeStep.getSample(i), rangeType);\nff.setSample(i, pot, false, false);\n}\n}\nreturn ff;\n}\n\nfloat lat = geoVals[latIndex][i];\nfloat lon = geoVals[lonIndex][i];\nfloat alt = haveAlt\n? geoVals[2][i]\n: 0;\nif ((lat == lat) && (lon == lon)) {\nif ( !(alt == alt)) {\nalt = 0;\n}\nEarthLocation el = new EarthLocationLite(lat, lon, alt);\n\/\/ TODO: make this more efficient\nPointObTuple pot = new PointObTuple(el, dt,\ntimeStep.getSample(i), rangeType);\nff.setSample(i, pot, false, false);\n}\n}\nreturn ff;\n}","code_context_20":"private static FieldImpl makePointObs(FlatField timeStep, DateTime dt)\nthrows VisADException, RemoteException {\nif (timeStep == null) {\nreturn null;\n}\nSampledSet domain = getSpatialDomain(timeStep);\nint numPoints = domain.getLength();\nInteger1DSet points = new Integer1DSet(RealType.getRealType(\"index\"),\nnumPoints);\nTupleType tt = getParamType(timeStep);\nTupleType rangeType = new TupleType(new MathType[] {\nRealTupleType.LatitudeLongitudeAltitude,\nRealType.Time,\ntt });\nFieldImpl ff = new FieldImpl(\nnew FunctionType(\n((SetType) points.getType()).getDomain(),\nrangeType), points);\nfloat[][] samples = timeStep.getFloats(false);\nfloat[][] geoVals = getEarthLocationPoints((GriddedSet) domain);\nboolean isLatLon = isLatLonOrder(domain);\nint latIndex = isLatLon\n? 0\n: 1;\nint lonIndex = isLatLon\n? 1\n: 0;\nboolean haveAlt = geoVals.length > 2;\nfor (int i = 0; i < numPoints; i++) {\nfloat lat = geoVals[latIndex][i];\nfloat lon = geoVals[lonIndex][i];\nfloat alt = haveAlt\n? geoVals[2][i]\n: 0;\nif ((lat == lat) && (lon == lon)) {\nif ( !(alt == alt)) {\nalt = 0;\n}\nEarthLocation el = new EarthLocationLite(lat, lon, alt);\n\/\/ TODO: make this more efficient\nPointObTuple pot = new PointObTuple(el, dt,\ntimeStep.getSample(i), rangeType);\nff.setSample(i, pot, false, false);\n}\n}\nreturn ff;\n}\n\nfloat[][] geoVals = getEarthLocationPoints((GriddedSet) domain);\nboolean isLatLon = isLatLonOrder(domain);\nint latIndex = isLatLon\n? 0\n: 1;\nint lonIndex = isLatLon\n? 1\n: 0;\nboolean haveAlt = geoVals.length > 2;\nfor (int i = 0; i < numPoints; i++) {\nfloat lat = geoVals[latIndex][i];\nfloat lon = geoVals[lonIndex][i];\nfloat alt = haveAlt\n? geoVals[2][i]\n: 0;\nif ((lat == lat) && (lon == lon)) {\nif ( !(alt == alt)) {\nalt = 0;\n}\nEarthLocation el = new EarthLocationLite(lat, lon, alt);\n\/\/ TODO: make this more efficient\nPointObTuple pot = new PointObTuple(el, dt,\ntimeStep.getSample(i), rangeType);\nff.setSample(i, pot, false, false);\n}\n}\nreturn ff;\n}","label":[1,0,0,0]}
{"id":23145,"original_code":"private static FieldImpl makePointObs(FlatField timeStep, DateTime dt, String function)\n            throws VisADException, RemoteException {\n        final boolean doMax = function.equals(FUNC_MAX);\n        final boolean doMin = function.equals(FUNC_MIN);\n        if (timeStep == null) {\n            return null;\n        }\n        SampledSet domain    = getSpatialDomain(timeStep);\n        int        numPoints = domain.getLength();\n        Integer1DSet points = new Integer1DSet(RealType.getRealType(\"index\"),\n                numPoints);\n        TupleType tt = getParamType(timeStep);\n        TupleType rangeType = new TupleType(new MathType[] {\n                RealTupleType.LatitudeLongitudeAltitude,\n                RealType.Time,\n                tt });\n        FieldImpl ff = new FieldImpl(\n                new FunctionType(\n                        ((SetType) points.getType()).getDomain(),\n                        rangeType), points);\n        float[][] samples  = timeStep.getFloats(false);\n        float[][] geoVals  = getEarthLocationPoints((GriddedSet) domain);\n        boolean   isLatLon = isLatLonOrder(domain);\n        int       latIndex = isLatLon\n                ? 0\n                : 1;\n        int       lonIndex = isLatLon\n                ? 1\n                : 0;\n        boolean   haveAlt  = geoVals.length > 2;\n        float   pMin   = Float.POSITIVE_INFINITY;\n        float   pMax   = Float.NEGATIVE_INFINITY;\n        int index = 0;\n        for (int i = 0; i < numPoints; i++) {\n            float lat = geoVals[latIndex][i];\n            float lon = geoVals[lonIndex][i];\n            float alt = haveAlt\n                    ? geoVals[2][i]\n                    : 0;\n            if ((lat == lat) && (lon == lon)) {\n                if ( !(alt == alt)) {\n                    alt = 0;\n                }\n                if(doMax && (float)timeStep.getValues(i)[0] >= pMax){\n                    pMax = (float)timeStep.getValues(i)[0];\n                    index = i;\n                } else if(doMin && (float)timeStep.getValues(i)[0] < pMin){\n                    pMin = (float)timeStep.getValues(i)[0];\n                    index = i;\n                }\n            }\n        }\n        float alt0  = haveAlt\n                ? geoVals[2][index]\n                : 0;\n        EarthLocation el0 = new EarthLocationLite(geoVals[latIndex][index], geoVals[lonIndex][index], alt0);\n        \/\/ TODO:  make this  more efficient\n        PointObTuple pot = new PointObTuple(el0, dt,\n                timeStep.getSample(index), rangeType);\n        ff.setSample(0, pot, false, false);\n        return ff;\n    }","code":"private static FieldImpl makePointObs(FlatField timeStep, DateTime dt, String function)\n            throws VisADException, RemoteException {\n        final boolean doMax = function.equals(FUNC_MAX);\n        final boolean doMin = function.equals(FUNC_MIN);\n        if (timeStep == null) {\n            return null;\n        }\n        SampledSet domain    = getSpatialDomain(timeStep);\n        int        numPoints = domain.getLength();\n        Integer1DSet points = new Integer1DSet(RealType.getRealType(\"index\"),\n                numPoints);\n        TupleType tt = getParamType(timeStep);\n        TupleType rangeType = new TupleType(new MathType[] {\n                RealTupleType.LatitudeLongitudeAltitude,\n                RealType.Time,\n                tt });\n        FieldImpl ff = new FieldImpl(\n                new FunctionType(\n                        ((SetType) points.getType()).getDomain(),\n                        rangeType), points);\n        float[][] samples  = timeStep.getFloats(false);\n        float[][] geoVals  = getEarthLocationPoints((GriddedSet) domain);\n        boolean   isLatLon = isLatLonOrder(domain);\n        int       latIndex = isLatLon\n                ? 0\n                : 1;\n        int       lonIndex = isLatLon\n                ? 1\n                : 0;\n        boolean   haveAlt  = geoVals.length > 2;\n        float   pMin   = Float.POSITIVE_INFINITY;\n        float   pMax   = Float.NEGATIVE_INFINITY;\n        int index = 0;\n        for (int i = 0; i < numPoints; i++) {\n            float lat = geoVals[latIndex][i];\n            float lon = geoVals[lonIndex][i];\n            float alt = haveAlt\n                    ? geoVals[2][i]\n                    : 0;\n            if ((lat == lat) && (lon == lon)) {\n                if ( !(alt == alt)) {\n                    alt = 0;\n                }\n                if(doMax && (float)timeStep.getValues(i)[0] >= pMax){\n                    pMax = (float)timeStep.getValues(i)[0];\n                    index = i;\n                } else if(doMin && (float)timeStep.getValues(i)[0] < pMin){\n                    pMin = (float)timeStep.getValues(i)[0];\n                    index = i;\n                }\n            }\n        }\n        float alt0  = haveAlt\n                ? geoVals[2][index]\n                : 0;\n        EarthLocation el0 = new EarthLocationLite(geoVals[latIndex][index], geoVals[lonIndex][index], alt0);\n       \n        PointObTuple pot = new PointObTuple(el0, dt,\n                timeStep.getSample(index), rangeType);\n        ff.setSample(0, pot, false, false);\n        return ff;\n    }","cleancode":"private static fieldimpl makepointobs(flatfield timestep, datetime dt, string function) throws visadexception, remoteexception { final boolean domax = function.equals(func_max); final boolean domin = function.equals(func_min); if (timestep == null) { return null; } sampledset domain = getspatialdomain(timestep); int numpoints = domain.getlength(); integer1dset points = new integer1dset(realtype.getrealtype(\"index\"), numpoints); tupletype tt = getparamtype(timestep); tupletype rangetype = new tupletype(new mathtype[] { realtupletype.latitudelongitudealtitude, realtype.time, tt }); fieldimpl ff = new fieldimpl( new functiontype( ((settype) points.gettype()).getdomain(), rangetype), points); float[][] samples = timestep.getfloats(false); float[][] geovals = getearthlocationpoints((griddedset) domain); boolean islatlon = islatlonorder(domain); int latindex = islatlon ? 0 : 1; int lonindex = islatlon ? 1 : 0; boolean havealt = geovals.length > 2; float pmin = float.positive_infinity; float pmax = float.negative_infinity; int index = 0; for (int i = 0; i < numpoints; i++) { float lat = geovals[latindex][i]; float lon = geovals[lonindex][i]; float alt = havealt ? geovals[2][i] : 0; if ((lat == lat) && (lon == lon)) { if ( !(alt == alt)) { alt = 0; } if(domax && (float)timestep.getvalues(i)[0] >= pmax){ pmax = (float)timestep.getvalues(i)[0]; index = i; } else if(domin && (float)timestep.getvalues(i)[0] < pmin){ pmin = (float)timestep.getvalues(i)[0]; index = i; } } } float alt0 = havealt ? geovals[2][index] : 0; earthlocation el0 = new earthlocationlite(geovals[latindex][index], geovals[lonindex][index], alt0); pointobtuple pot = new pointobtuple(el0, dt, timestep.getsample(index), rangetype); ff.setsample(0, pot, false, false); return ff; }","comment":"\/** * make point obs from a single timestep of a grid * * @param timestep the grid * @param dt the timestep for the grid * * @return a field of pointobs * * @throws remoteexception java rmi problem * @throws visadexception visad problem *\/\n\/\/ todo: make this more efficient","repo":"oxelson\/IDV","code_context_2":"private static FieldImpl makePointObs(FlatField timeStep, DateTime dt, String function)\nthrows VisADException, RemoteException {\nfinal boolean doMax = function.equals(FUNC_MAX);\nfinal boolean doMin = function.equals(FUNC_MIN);\nif (timeStep == null) {\nreturn null;\n}\nSampledSet domain = getSpatialDomain(timeStep);\nint numPoints = domain.getLength();\nInteger1DSet points = new Integer1DSet(RealType.getRealType(\"index\"),\nnumPoints);\nTupleType tt = getParamType(timeStep);\nTupleType rangeType = new TupleType(new MathType[] {\nRealTupleType.LatitudeLongitudeAltitude,\nRealType.Time,\ntt });\nFieldImpl ff = new FieldImpl(\nnew FunctionType(\n((SetType) points.getType()).getDomain(),\nrangeType), points);\nfloat[][] samples = timeStep.getFloats(false);\nfloat[][] geoVals = getEarthLocationPoints((GriddedSet) domain);\nboolean isLatLon = isLatLonOrder(domain);\nint latIndex = isLatLon\n? 0\n: 1;\nint lonIndex = isLatLon\n? 1\n: 0;\nboolean haveAlt = geoVals.length > 2;\nfloat pMin = Float.POSITIVE_INFINITY;\nfloat pMax = Float.NEGATIVE_INFINITY;\nint index = 0;\nfor (int i = 0; i < numPoints; i++) {\nfloat lat = geoVals[latIndex][i];\nfloat lon = geoVals[lonIndex][i];\nfloat alt = haveAlt\n? geoVals[2][i]\n: 0;\nif ((lat == lat) && (lon == lon)) {\nif ( !(alt == alt)) {\nalt = 0;\n}\nif(doMax && (float)timeStep.getValues(i)[0] >= pMax){\npMax = (float)timeStep.getValues(i)[0];\nindex = i;\n} else if(doMin && (float)timeStep.getValues(i)[0] < pMin){\npMin = (float)timeStep.getValues(i)[0];\nindex = i;\n}\n}\n}\nfloat alt0 = haveAlt\n? geoVals[2][index]\n: 0;\nEarthLocation el0 = new EarthLocationLite(geoVals[latIndex][index], geoVals[lonIndex][index], alt0);\n\/\/ TODO: make this more efficient\nPointObTuple pot = new PointObTuple(el0, dt,\ntimeStep.getSample(index), rangeType);\nff.setSample(0, pot, false, false);\nreturn ff;\n}\n\n: 0;\nEarthLocation el0 = new EarthLocationLite(geoVals[latIndex][index], geoVals[lonIndex][index], alt0);\n\/\/ TODO: make this more efficient\nPointObTuple pot = new PointObTuple(el0, dt,\ntimeStep.getSample(index), rangeType);","code_context_10":"private static FieldImpl makePointObs(FlatField timeStep, DateTime dt, String function)\nthrows VisADException, RemoteException {\nfinal boolean doMax = function.equals(FUNC_MAX);\nfinal boolean doMin = function.equals(FUNC_MIN);\nif (timeStep == null) {\nreturn null;\n}\nSampledSet domain = getSpatialDomain(timeStep);\nint numPoints = domain.getLength();\nInteger1DSet points = new Integer1DSet(RealType.getRealType(\"index\"),\nnumPoints);\nTupleType tt = getParamType(timeStep);\nTupleType rangeType = new TupleType(new MathType[] {\nRealTupleType.LatitudeLongitudeAltitude,\nRealType.Time,\ntt });\nFieldImpl ff = new FieldImpl(\nnew FunctionType(\n((SetType) points.getType()).getDomain(),\nrangeType), points);\nfloat[][] samples = timeStep.getFloats(false);\nfloat[][] geoVals = getEarthLocationPoints((GriddedSet) domain);\nboolean isLatLon = isLatLonOrder(domain);\nint latIndex = isLatLon\n? 0\n: 1;\nint lonIndex = isLatLon\n? 1\n: 0;\nboolean haveAlt = geoVals.length > 2;\nfloat pMin = Float.POSITIVE_INFINITY;\nfloat pMax = Float.NEGATIVE_INFINITY;\nint index = 0;\nfor (int i = 0; i < numPoints; i++) {\nfloat lat = geoVals[latIndex][i];\nfloat lon = geoVals[lonIndex][i];\nfloat alt = haveAlt\n? geoVals[2][i]\n: 0;\nif ((lat == lat) && (lon == lon)) {\nif ( !(alt == alt)) {\nalt = 0;\n}\nif(doMax && (float)timeStep.getValues(i)[0] >= pMax){\npMax = (float)timeStep.getValues(i)[0];\nindex = i;\n} else if(doMin && (float)timeStep.getValues(i)[0] < pMin){\npMin = (float)timeStep.getValues(i)[0];\nindex = i;\n}\n}\n}\nfloat alt0 = haveAlt\n? geoVals[2][index]\n: 0;\nEarthLocation el0 = new EarthLocationLite(geoVals[latIndex][index], geoVals[lonIndex][index], alt0);\n\/\/ TODO: make this more efficient\nPointObTuple pot = new PointObTuple(el0, dt,\ntimeStep.getSample(index), rangeType);\nff.setSample(0, pot, false, false);\nreturn ff;\n}\n\n} else if(doMin && (float)timeStep.getValues(i)[0] < pMin){\npMin = (float)timeStep.getValues(i)[0];\nindex = i;\n}\n}\n}\nfloat alt0 = haveAlt\n? geoVals[2][index]\n: 0;\nEarthLocation el0 = new EarthLocationLite(geoVals[latIndex][index], geoVals[lonIndex][index], alt0);\n\/\/ TODO: make this more efficient\nPointObTuple pot = new PointObTuple(el0, dt,\ntimeStep.getSample(index), rangeType);\nff.setSample(0, pot, false, false);\nreturn ff;\n}","code_context_20":"private static FieldImpl makePointObs(FlatField timeStep, DateTime dt, String function)\nthrows VisADException, RemoteException {\nfinal boolean doMax = function.equals(FUNC_MAX);\nfinal boolean doMin = function.equals(FUNC_MIN);\nif (timeStep == null) {\nreturn null;\n}\nSampledSet domain = getSpatialDomain(timeStep);\nint numPoints = domain.getLength();\nInteger1DSet points = new Integer1DSet(RealType.getRealType(\"index\"),\nnumPoints);\nTupleType tt = getParamType(timeStep);\nTupleType rangeType = new TupleType(new MathType[] {\nRealTupleType.LatitudeLongitudeAltitude,\nRealType.Time,\ntt });\nFieldImpl ff = new FieldImpl(\nnew FunctionType(\n((SetType) points.getType()).getDomain(),\nrangeType), points);\nfloat[][] samples = timeStep.getFloats(false);\nfloat[][] geoVals = getEarthLocationPoints((GriddedSet) domain);\nboolean isLatLon = isLatLonOrder(domain);\nint latIndex = isLatLon\n? 0\n: 1;\nint lonIndex = isLatLon\n? 1\n: 0;\nboolean haveAlt = geoVals.length > 2;\nfloat pMin = Float.POSITIVE_INFINITY;\nfloat pMax = Float.NEGATIVE_INFINITY;\nint index = 0;\nfor (int i = 0; i < numPoints; i++) {\nfloat lat = geoVals[latIndex][i];\nfloat lon = geoVals[lonIndex][i];\nfloat alt = haveAlt\n? geoVals[2][i]\n: 0;\nif ((lat == lat) && (lon == lon)) {\nif ( !(alt == alt)) {\nalt = 0;\n}\nif(doMax && (float)timeStep.getValues(i)[0] >= pMax){\npMax = (float)timeStep.getValues(i)[0];\nindex = i;\n} else if(doMin && (float)timeStep.getValues(i)[0] < pMin){\npMin = (float)timeStep.getValues(i)[0];\nindex = i;\n}\n}\n}\nfloat alt0 = haveAlt\n? geoVals[2][index]\n: 0;\nEarthLocation el0 = new EarthLocationLite(geoVals[latIndex][index], geoVals[lonIndex][index], alt0);\n\/\/ TODO: make this more efficient\nPointObTuple pot = new PointObTuple(el0, dt,\ntimeStep.getSample(index), rangeType);\nff.setSample(0, pot, false, false);\nreturn ff;\n}\n\nfloat alt = haveAlt\n? geoVals[2][i]\n: 0;\nif ((lat == lat) && (lon == lon)) {\nif ( !(alt == alt)) {\nalt = 0;\n}\nif(doMax && (float)timeStep.getValues(i)[0] >= pMax){\npMax = (float)timeStep.getValues(i)[0];\nindex = i;\n} else if(doMin && (float)timeStep.getValues(i)[0] < pMin){\npMin = (float)timeStep.getValues(i)[0];\nindex = i;\n}\n}\n}\nfloat alt0 = haveAlt\n? geoVals[2][index]\n: 0;\nEarthLocation el0 = new EarthLocationLite(geoVals[latIndex][index], geoVals[lonIndex][index], alt0);\n\/\/ TODO: make this more efficient\nPointObTuple pot = new PointObTuple(el0, dt,\ntimeStep.getSample(index), rangeType);\nff.setSample(0, pot, false, false);\nreturn ff;\n}","label":[1,0,0,0]}
{"id":23146,"original_code":"private static FieldImpl makePointObs(FlatField timeStep, DateTime dt, double min, double max)\n            throws VisADException, RemoteException {\n        if (timeStep == null) {\n            return null;\n        }\n        SampledSet domain    = getSpatialDomain(timeStep);\n        int        numPoints = domain.getLength();\n        Integer1DSet points = new Integer1DSet(RealType.getRealType(\"index\"),\n                numPoints);\n        TupleType tt = getParamType(timeStep);\n        TupleType rangeType = new TupleType(new MathType[] {\n                RealTupleType.LatitudeLongitudeAltitude,\n                RealType.Time,\n                tt });\n        FieldImpl ff = new FieldImpl(\n                new FunctionType(\n                        ((SetType) points.getType()).getDomain(),\n                        rangeType), points);\n        float[][] samples  = timeStep.getFloats(false);\n        float[][] geoVals  = getEarthLocationPoints((GriddedSet) domain);\n        boolean   isLatLon = isLatLonOrder(domain);\n        int       latIndex = isLatLon\n                ? 0\n                : 1;\n        int       lonIndex = isLatLon\n                ? 1\n                : 0;\n        boolean   haveAlt  = geoVals.length > 2;\n        for (int i = 0; i < numPoints; i++) {\n            float lat = geoVals[latIndex][i];\n            float lon = geoVals[lonIndex][i];\n            float alt = haveAlt\n                    ? geoVals[2][i]\n                    : 0;\n            if ((lat == lat) && (lon == lon)) {\n                if ( !(alt == alt)) {\n                    alt = 0;\n                }\n                if(timeStep.getValues(i)[0] >= min && timeStep.getValues(i)[0] < max) {\n                    EarthLocation el = new EarthLocationLite(lat, lon, alt);\n                    \/\/ TODO:  make this  more efficient\n                    PointObTuple pot = new PointObTuple(el, dt,\n                            timeStep.getSample(i), rangeType);\n                    ff.setSample(i, pot, false, false);\n                }\n            }\n        }\n        return ff;\n    }","code":"private static FieldImpl makePointObs(FlatField timeStep, DateTime dt, double min, double max)\n            throws VisADException, RemoteException {\n        if (timeStep == null) {\n            return null;\n        }\n        SampledSet domain    = getSpatialDomain(timeStep);\n        int        numPoints = domain.getLength();\n        Integer1DSet points = new Integer1DSet(RealType.getRealType(\"index\"),\n                numPoints);\n        TupleType tt = getParamType(timeStep);\n        TupleType rangeType = new TupleType(new MathType[] {\n                RealTupleType.LatitudeLongitudeAltitude,\n                RealType.Time,\n                tt });\n        FieldImpl ff = new FieldImpl(\n                new FunctionType(\n                        ((SetType) points.getType()).getDomain(),\n                        rangeType), points);\n        float[][] samples  = timeStep.getFloats(false);\n        float[][] geoVals  = getEarthLocationPoints((GriddedSet) domain);\n        boolean   isLatLon = isLatLonOrder(domain);\n        int       latIndex = isLatLon\n                ? 0\n                : 1;\n        int       lonIndex = isLatLon\n                ? 1\n                : 0;\n        boolean   haveAlt  = geoVals.length > 2;\n        for (int i = 0; i < numPoints; i++) {\n            float lat = geoVals[latIndex][i];\n            float lon = geoVals[lonIndex][i];\n            float alt = haveAlt\n                    ? geoVals[2][i]\n                    : 0;\n            if ((lat == lat) && (lon == lon)) {\n                if ( !(alt == alt)) {\n                    alt = 0;\n                }\n                if(timeStep.getValues(i)[0] >= min && timeStep.getValues(i)[0] < max) {\n                    EarthLocation el = new EarthLocationLite(lat, lon, alt);\n                   \n                    PointObTuple pot = new PointObTuple(el, dt,\n                            timeStep.getSample(i), rangeType);\n                    ff.setSample(i, pot, false, false);\n                }\n            }\n        }\n        return ff;\n    }","cleancode":"private static fieldimpl makepointobs(flatfield timestep, datetime dt, double min, double max) throws visadexception, remoteexception { if (timestep == null) { return null; } sampledset domain = getspatialdomain(timestep); int numpoints = domain.getlength(); integer1dset points = new integer1dset(realtype.getrealtype(\"index\"), numpoints); tupletype tt = getparamtype(timestep); tupletype rangetype = new tupletype(new mathtype[] { realtupletype.latitudelongitudealtitude, realtype.time, tt }); fieldimpl ff = new fieldimpl( new functiontype( ((settype) points.gettype()).getdomain(), rangetype), points); float[][] samples = timestep.getfloats(false); float[][] geovals = getearthlocationpoints((griddedset) domain); boolean islatlon = islatlonorder(domain); int latindex = islatlon ? 0 : 1; int lonindex = islatlon ? 1 : 0; boolean havealt = geovals.length > 2; for (int i = 0; i < numpoints; i++) { float lat = geovals[latindex][i]; float lon = geovals[lonindex][i]; float alt = havealt ? geovals[2][i] : 0; if ((lat == lat) && (lon == lon)) { if ( !(alt == alt)) { alt = 0; } if(timestep.getvalues(i)[0] >= min && timestep.getvalues(i)[0] < max) { earthlocation el = new earthlocationlite(lat, lon, alt); pointobtuple pot = new pointobtuple(el, dt, timestep.getsample(i), rangetype); ff.setsample(i, pot, false, false); } } } return ff; }","comment":"\/** * make point obs from a single timestep of a grid * * @param timestep the grid * @param dt the timestep for the grid * * @return a field of pointobs * * @throws remoteexception java rmi problem * @throws visadexception visad problem *\/\n\/\/ todo: make this more efficient","repo":"oxelson\/IDV","code_context_2":"private static FieldImpl makePointObs(FlatField timeStep, DateTime dt, double min, double max)\nthrows VisADException, RemoteException {\nif (timeStep == null) {\nreturn null;\n}\nSampledSet domain = getSpatialDomain(timeStep);\nint numPoints = domain.getLength();\nInteger1DSet points = new Integer1DSet(RealType.getRealType(\"index\"),\nnumPoints);\nTupleType tt = getParamType(timeStep);\nTupleType rangeType = new TupleType(new MathType[] {\nRealTupleType.LatitudeLongitudeAltitude,\nRealType.Time,\ntt });\nFieldImpl ff = new FieldImpl(\nnew FunctionType(\n((SetType) points.getType()).getDomain(),\nrangeType), points);\nfloat[][] samples = timeStep.getFloats(false);\nfloat[][] geoVals = getEarthLocationPoints((GriddedSet) domain);\nboolean isLatLon = isLatLonOrder(domain);\nint latIndex = isLatLon\n? 0\n: 1;\nint lonIndex = isLatLon\n? 1\n: 0;\nboolean haveAlt = geoVals.length > 2;\nfor (int i = 0; i < numPoints; i++) {\nfloat lat = geoVals[latIndex][i];\nfloat lon = geoVals[lonIndex][i];\nfloat alt = haveAlt\n? geoVals[2][i]\n: 0;\nif ((lat == lat) && (lon == lon)) {\nif ( !(alt == alt)) {\nalt = 0;\n}\nif(timeStep.getValues(i)[0] >= min && timeStep.getValues(i)[0] < max) {\nEarthLocation el = new EarthLocationLite(lat, lon, alt);\n\/\/ TODO: make this more efficient\nPointObTuple pot = new PointObTuple(el, dt,\ntimeStep.getSample(i), rangeType);\nff.setSample(i, pot, false, false);\n}\n}\n}\nreturn ff;\n}\n\nif(timeStep.getValues(i)[0] >= min && timeStep.getValues(i)[0] < max) {\nEarthLocation el = new EarthLocationLite(lat, lon, alt);\n\/\/ TODO: make this more efficient\nPointObTuple pot = new PointObTuple(el, dt,\ntimeStep.getSample(i), rangeType);","code_context_10":"private static FieldImpl makePointObs(FlatField timeStep, DateTime dt, double min, double max)\nthrows VisADException, RemoteException {\nif (timeStep == null) {\nreturn null;\n}\nSampledSet domain = getSpatialDomain(timeStep);\nint numPoints = domain.getLength();\nInteger1DSet points = new Integer1DSet(RealType.getRealType(\"index\"),\nnumPoints);\nTupleType tt = getParamType(timeStep);\nTupleType rangeType = new TupleType(new MathType[] {\nRealTupleType.LatitudeLongitudeAltitude,\nRealType.Time,\ntt });\nFieldImpl ff = new FieldImpl(\nnew FunctionType(\n((SetType) points.getType()).getDomain(),\nrangeType), points);\nfloat[][] samples = timeStep.getFloats(false);\nfloat[][] geoVals = getEarthLocationPoints((GriddedSet) domain);\nboolean isLatLon = isLatLonOrder(domain);\nint latIndex = isLatLon\n? 0\n: 1;\nint lonIndex = isLatLon\n? 1\n: 0;\nboolean haveAlt = geoVals.length > 2;\nfor (int i = 0; i < numPoints; i++) {\nfloat lat = geoVals[latIndex][i];\nfloat lon = geoVals[lonIndex][i];\nfloat alt = haveAlt\n? geoVals[2][i]\n: 0;\nif ((lat == lat) && (lon == lon)) {\nif ( !(alt == alt)) {\nalt = 0;\n}\nif(timeStep.getValues(i)[0] >= min && timeStep.getValues(i)[0] < max) {\nEarthLocation el = new EarthLocationLite(lat, lon, alt);\n\/\/ TODO: make this more efficient\nPointObTuple pot = new PointObTuple(el, dt,\ntimeStep.getSample(i), rangeType);\nff.setSample(i, pot, false, false);\n}\n}\n}\nreturn ff;\n}\n\nfloat lon = geoVals[lonIndex][i];\nfloat alt = haveAlt\n? geoVals[2][i]\n: 0;\nif ((lat == lat) && (lon == lon)) {\nif ( !(alt == alt)) {\nalt = 0;\n}\nif(timeStep.getValues(i)[0] >= min && timeStep.getValues(i)[0] < max) {\nEarthLocation el = new EarthLocationLite(lat, lon, alt);\n\/\/ TODO: make this more efficient\nPointObTuple pot = new PointObTuple(el, dt,\ntimeStep.getSample(i), rangeType);\nff.setSample(i, pot, false, false);\n}\n}\n}\nreturn ff;\n}","code_context_20":"private static FieldImpl makePointObs(FlatField timeStep, DateTime dt, double min, double max)\nthrows VisADException, RemoteException {\nif (timeStep == null) {\nreturn null;\n}\nSampledSet domain = getSpatialDomain(timeStep);\nint numPoints = domain.getLength();\nInteger1DSet points = new Integer1DSet(RealType.getRealType(\"index\"),\nnumPoints);\nTupleType tt = getParamType(timeStep);\nTupleType rangeType = new TupleType(new MathType[] {\nRealTupleType.LatitudeLongitudeAltitude,\nRealType.Time,\ntt });\nFieldImpl ff = new FieldImpl(\nnew FunctionType(\n((SetType) points.getType()).getDomain(),\nrangeType), points);\nfloat[][] samples = timeStep.getFloats(false);\nfloat[][] geoVals = getEarthLocationPoints((GriddedSet) domain);\nboolean isLatLon = isLatLonOrder(domain);\nint latIndex = isLatLon\n? 0\n: 1;\nint lonIndex = isLatLon\n? 1\n: 0;\nboolean haveAlt = geoVals.length > 2;\nfor (int i = 0; i < numPoints; i++) {\nfloat lat = geoVals[latIndex][i];\nfloat lon = geoVals[lonIndex][i];\nfloat alt = haveAlt\n? geoVals[2][i]\n: 0;\nif ((lat == lat) && (lon == lon)) {\nif ( !(alt == alt)) {\nalt = 0;\n}\nif(timeStep.getValues(i)[0] >= min && timeStep.getValues(i)[0] < max) {\nEarthLocation el = new EarthLocationLite(lat, lon, alt);\n\/\/ TODO: make this more efficient\nPointObTuple pot = new PointObTuple(el, dt,\ntimeStep.getSample(i), rangeType);\nff.setSample(i, pot, false, false);\n}\n}\n}\nreturn ff;\n}\n\nboolean isLatLon = isLatLonOrder(domain);\nint latIndex = isLatLon\n? 0\n: 1;\nint lonIndex = isLatLon\n? 1\n: 0;\nboolean haveAlt = geoVals.length > 2;\nfor (int i = 0; i < numPoints; i++) {\nfloat lat = geoVals[latIndex][i];\nfloat lon = geoVals[lonIndex][i];\nfloat alt = haveAlt\n? geoVals[2][i]\n: 0;\nif ((lat == lat) && (lon == lon)) {\nif ( !(alt == alt)) {\nalt = 0;\n}\nif(timeStep.getValues(i)[0] >= min && timeStep.getValues(i)[0] < max) {\nEarthLocation el = new EarthLocationLite(lat, lon, alt);\n\/\/ TODO: make this more efficient\nPointObTuple pot = new PointObTuple(el, dt,\ntimeStep.getSample(i), rangeType);\nff.setSample(i, pot, false, false);\n}\n}\n}\nreturn ff;\n}","label":[1,0,0,0]}
{"id":14974,"original_code":"@Nullable\n    @Deprecated\n    public static Character max(@Nullable CharSequence charSequence) {\n        return maxOrNull(charSequence);\n    }","code":"@Nullable\n    @Deprecated\n    public static Character max(@Nullable CharSequence charSequence) {\n        return maxOrNull(charSequence);\n    }","cleancode":"@nullable @deprecated public static character max(@nullable charsequence charsequence) { return maxornull(charsequence); }","comment":"\/** * returns the largest character or `null` if there are no characters. * * @deprecated please use maxornull instead *\/","repo":"panpf\/tools4j","code_context_2":"@Nullable\n@Deprecated\npublic static Character max(@Nullable CharSequence charSequence) {\nreturn maxOrNull(charSequence);\n}","code_context_10":"@Nullable\n@Deprecated\npublic static Character max(@Nullable CharSequence charSequence) {\nreturn maxOrNull(charSequence);\n}","code_context_20":"@Nullable\n@Deprecated\npublic static Character max(@Nullable CharSequence charSequence) {\nreturn maxOrNull(charSequence);\n}","label":[0,0,0,0]}
{"id":14975,"original_code":"@Nullable\n    @Deprecated\n    public static <R extends Comparable<R>> Character maxBy(@Nullable CharSequence charSequence, @NotNull Transformer<Character, R> selector) {\n        return maxByOrNull(charSequence, selector);\n    }","code":"@Nullable\n    @Deprecated\n    public static <R extends Comparable<R>> Character maxBy(@Nullable CharSequence charSequence, @NotNull Transformer<Character, R> selector) {\n        return maxByOrNull(charSequence, selector);\n    }","cleancode":"@nullable @deprecated public static <r extends comparable<r>> character maxby(@nullable charsequence charsequence, @notnull transformer<character, r> selector) { return maxbyornull(charsequence, selector); }","comment":"\/** * returns the first character yielding the largest value of the given function or `null` if there are no characters. * * @deprecated please use maxbyornull instead *\/","repo":"panpf\/tools4j","code_context_2":"@Nullable\n@Deprecated\npublic static <R extends Comparable<R>> Character maxBy(@Nullable CharSequence charSequence, @NotNull Transformer<Character, R> selector) {\nreturn maxByOrNull(charSequence, selector);\n}","code_context_10":"@Nullable\n@Deprecated\npublic static <R extends Comparable<R>> Character maxBy(@Nullable CharSequence charSequence, @NotNull Transformer<Character, R> selector) {\nreturn maxByOrNull(charSequence, selector);\n}","code_context_20":"@Nullable\n@Deprecated\npublic static <R extends Comparable<R>> Character maxBy(@Nullable CharSequence charSequence, @NotNull Transformer<Character, R> selector) {\nreturn maxByOrNull(charSequence, selector);\n}","label":[0,0,0,0]}
{"id":14976,"original_code":"@Nullable\n    @Deprecated\n    public static Character min(@Nullable CharSequence charSequence) {\n        return minOrNull(charSequence);\n    }","code":"@Nullable\n    @Deprecated\n    public static Character min(@Nullable CharSequence charSequence) {\n        return minOrNull(charSequence);\n    }","cleancode":"@nullable @deprecated public static character min(@nullable charsequence charsequence) { return minornull(charsequence); }","comment":"\/** * returns the smallest character or `null` if there are no characters. * * @deprecated please use minornull instead *\/","repo":"panpf\/tools4j","code_context_2":"@Nullable\n@Deprecated\npublic static Character min(@Nullable CharSequence charSequence) {\nreturn minOrNull(charSequence);\n}","code_context_10":"@Nullable\n@Deprecated\npublic static Character min(@Nullable CharSequence charSequence) {\nreturn minOrNull(charSequence);\n}","code_context_20":"@Nullable\n@Deprecated\npublic static Character min(@Nullable CharSequence charSequence) {\nreturn minOrNull(charSequence);\n}","label":[0,0,0,0]}
{"id":14977,"original_code":"@Nullable\n    @Deprecated\n    public static <R extends Comparable<R>> Character minBy(@Nullable CharSequence charSequence, @NotNull Transformer<Character, R> selector) {\n        return minByOrNull(charSequence, selector);\n    }","code":"@Nullable\n    @Deprecated\n    public static <R extends Comparable<R>> Character minBy(@Nullable CharSequence charSequence, @NotNull Transformer<Character, R> selector) {\n        return minByOrNull(charSequence, selector);\n    }","cleancode":"@nullable @deprecated public static <r extends comparable<r>> character minby(@nullable charsequence charsequence, @notnull transformer<character, r> selector) { return minbyornull(charsequence, selector); }","comment":"\/** * returns the first character yielding the smallest value of the given function or `null` if there are no characters. * * @deprecated please use minbyornull instead *\/","repo":"panpf\/tools4j","code_context_2":"@Nullable\n@Deprecated\npublic static <R extends Comparable<R>> Character minBy(@Nullable CharSequence charSequence, @NotNull Transformer<Character, R> selector) {\nreturn minByOrNull(charSequence, selector);\n}","code_context_10":"@Nullable\n@Deprecated\npublic static <R extends Comparable<R>> Character minBy(@Nullable CharSequence charSequence, @NotNull Transformer<Character, R> selector) {\nreturn minByOrNull(charSequence, selector);\n}","code_context_20":"@Nullable\n@Deprecated\npublic static <R extends Comparable<R>> Character minBy(@Nullable CharSequence charSequence, @NotNull Transformer<Character, R> selector) {\nreturn minByOrNull(charSequence, selector);\n}","label":[0,0,0,0]}
{"id":23182,"original_code":"public static void main(String[] args) {\n        \/\/ TODO code application logic her\n        \/\/ Hola Onasis\n        int num = 0;\n        \/\/ Holaaaaa\n        \/\/ QQUE ONDASS\n        switch(num){\n            case 1:\n            case 2:\n            default:\n        }\n        \/\/\n    }","code":"public static void main(String[] args) {\n       \n       \n        int num = 0;\n       \n       \n        switch(num){\n            case 1:\n            case 2:\n            default:\n        }\n       \n    }","cleancode":"public static void main(string[] args) { int num = 0; switch(num){ case 1: case 2: default: } }","comment":"\/** * @param args the command line arguments *\/\n\/\/ todo code application logic her \/\/ hola onasis\n\/\/ holaaaaa \/\/ qque ondass\n\/\/","repo":"monicastle\/Prueba","code_context_2":"public static void main(String[] args) {\n\/\/ TODO code application logic her\n\/\/ Hola Onasis\nint num = 0;\n\/\/ Holaaaaa\n\/\/ QQUE ONDASS\nswitch(num){\ncase 1:\ncase 2:\ndefault:\n}\n\/\/\n}\n\npublic static void main(String[] args) {\n\/\/ TODO code application logic her\n\/\/ Hola Onasis\nint num = 0;\n\/\/ Holaaaaa\n\n\/\/ Hola Onasis\nint num = 0;\n\/\/ Holaaaaa\n\/\/ QQUE ONDASS\nswitch(num){\ncase 1:\n\npublic static void main(String[] args) {\n\/\/ TODO code application logic her\n\/\/ Hola Onasis\nint num = 0;","code_context_10":"public static void main(String[] args) {\n\/\/ TODO code application logic her\n\/\/ Hola Onasis\nint num = 0;\n\/\/ Holaaaaa\n\/\/ QQUE ONDASS\nswitch(num){\ncase 1:\ncase 2:\ndefault:\n}\n\/\/\n}\n\npublic static void main(String[] args) {\n\/\/ TODO code application logic her\n\/\/ Hola Onasis\nint num = 0;\n\/\/ Holaaaaa\n\/\/ QQUE ONDASS\nswitch(num){\ncase 1:\ncase 2:\ndefault:\n}\n\/\/\n}\n\npublic static void main(String[] args) {\n\/\/ TODO code application logic her\n\/\/ Hola Onasis\nint num = 0;\n\/\/ Holaaaaa\n\/\/ QQUE ONDASS\nswitch(num){\ncase 1:\ncase 2:\ndefault:\n}\n\/\/\n}\n\npublic static void main(String[] args) {\n\/\/ TODO code application logic her\n\/\/ Hola Onasis\nint num = 0;\n\/\/ Holaaaaa\n\/\/ QQUE ONDASS\nswitch(num){\ncase 1:\ncase 2:\ndefault:\n}\n\/\/","code_context_20":"public static void main(String[] args) {\n\/\/ TODO code application logic her\n\/\/ Hola Onasis\nint num = 0;\n\/\/ Holaaaaa\n\/\/ QQUE ONDASS\nswitch(num){\ncase 1:\ncase 2:\ndefault:\n}\n\/\/\n}\n\npublic static void main(String[] args) {\n\/\/ TODO code application logic her\n\/\/ Hola Onasis\nint num = 0;\n\/\/ Holaaaaa\n\/\/ QQUE ONDASS\nswitch(num){\ncase 1:\ncase 2:\ndefault:\n}\n\/\/\n}\n\npublic static void main(String[] args) {\n\/\/ TODO code application logic her\n\/\/ Hola Onasis\nint num = 0;\n\/\/ Holaaaaa\n\/\/ QQUE ONDASS\nswitch(num){\ncase 1:\ncase 2:\ndefault:\n}\n\/\/\n}\n\npublic static void main(String[] args) {\n\/\/ TODO code application logic her\n\/\/ Hola Onasis\nint num = 0;\n\/\/ Holaaaaa\n\/\/ QQUE ONDASS\nswitch(num){\ncase 1:\ncase 2:\ndefault:\n}\n\/\/\n}","label":[0,1,0,0]}
{"id":31571,"original_code":"private Object convertNullValue(RdsTableColumnDetails theColumnDetail) {\n        if (theColumnDetail.isNullable()) {\n            return null;\n        }\n        \/\/ For integral number type things, need to convert \"null\" into 0.\n        if (theColumnDetail.isIntegralType()) {\n            return new Integer(0);\n        }\n        \/\/ For decimal number type things, need to convert \"null\" into 0.0.\n        if (theColumnDetail.isDecimalType()) {\n            return new Double(0.0);\n        }\n        return null; \/\/ What can we do in this case :(\n    }","code":"private Object convertNullValue(RdsTableColumnDetails theColumnDetail) {\n        if (theColumnDetail.isNullable()) {\n            return null;\n        }\n       \n        if (theColumnDetail.isIntegralType()) {\n            return new Integer(0);\n        }\n       \n        if (theColumnDetail.isDecimalType()) {\n            return new Double(0.0);\n        }\n        return null;\n    }","cleancode":"private object convertnullvalue(rdstablecolumndetails thecolumndetail) { if (thecolumndetail.isnullable()) { return null; } if (thecolumndetail.isintegraltype()) { return new integer(0); } if (thecolumndetail.isdecimaltype()) { return new double(0.0); } return null; }","comment":"\/\/ for integral number type things, need to convert \"null\" into 0.\n\/\/ for decimal number type things, need to convert \"null\" into 0.0.\n\/\/ what can we do in this case :(","repo":"ogreflow\/ogre","code_context_2":"return null;\n}\n\/\/ For integral number type things, need to convert \"null\" into 0.\nif (theColumnDetail.isIntegralType()) {\nreturn new Integer(0);\n\nreturn new Integer(0);\n}\n\/\/ For decimal number type things, need to convert \"null\" into 0.0.\nif (theColumnDetail.isDecimalType()) {\nreturn new Double(0.0);\n\nreturn new Double(0.0);\n}\nreturn null; \/\/ What can we do in this case :(\n}","code_context_10":"private Object convertNullValue(RdsTableColumnDetails theColumnDetail) {\nif (theColumnDetail.isNullable()) {\nreturn null;\n}\n\/\/ For integral number type things, need to convert \"null\" into 0.\nif (theColumnDetail.isIntegralType()) {\nreturn new Integer(0);\n}\n\/\/ For decimal number type things, need to convert \"null\" into 0.0.\nif (theColumnDetail.isDecimalType()) {\nreturn new Double(0.0);\n}\nreturn null; \/\/ What can we do in this case :(\n}\n\nprivate Object convertNullValue(RdsTableColumnDetails theColumnDetail) {\nif (theColumnDetail.isNullable()) {\nreturn null;\n}\n\/\/ For integral number type things, need to convert \"null\" into 0.\nif (theColumnDetail.isIntegralType()) {\nreturn new Integer(0);\n}\n\/\/ For decimal number type things, need to convert \"null\" into 0.0.\nif (theColumnDetail.isDecimalType()) {\nreturn new Double(0.0);\n}\nreturn null; \/\/ What can we do in this case :(\n}\n\nreturn null;\n}\n\/\/ For integral number type things, need to convert \"null\" into 0.\nif (theColumnDetail.isIntegralType()) {\nreturn new Integer(0);\n}\n\/\/ For decimal number type things, need to convert \"null\" into 0.0.\nif (theColumnDetail.isDecimalType()) {\nreturn new Double(0.0);\n}\nreturn null; \/\/ What can we do in this case :(\n}","code_context_20":"private Object convertNullValue(RdsTableColumnDetails theColumnDetail) {\nif (theColumnDetail.isNullable()) {\nreturn null;\n}\n\/\/ For integral number type things, need to convert \"null\" into 0.\nif (theColumnDetail.isIntegralType()) {\nreturn new Integer(0);\n}\n\/\/ For decimal number type things, need to convert \"null\" into 0.0.\nif (theColumnDetail.isDecimalType()) {\nreturn new Double(0.0);\n}\nreturn null; \/\/ What can we do in this case :(\n}\n\nprivate Object convertNullValue(RdsTableColumnDetails theColumnDetail) {\nif (theColumnDetail.isNullable()) {\nreturn null;\n}\n\/\/ For integral number type things, need to convert \"null\" into 0.\nif (theColumnDetail.isIntegralType()) {\nreturn new Integer(0);\n}\n\/\/ For decimal number type things, need to convert \"null\" into 0.0.\nif (theColumnDetail.isDecimalType()) {\nreturn new Double(0.0);\n}\nreturn null; \/\/ What can we do in this case :(\n}\n\nprivate Object convertNullValue(RdsTableColumnDetails theColumnDetail) {\nif (theColumnDetail.isNullable()) {\nreturn null;\n}\n\/\/ For integral number type things, need to convert \"null\" into 0.\nif (theColumnDetail.isIntegralType()) {\nreturn new Integer(0);\n}\n\/\/ For decimal number type things, need to convert \"null\" into 0.0.\nif (theColumnDetail.isDecimalType()) {\nreturn new Double(0.0);\n}\nreturn null; \/\/ What can we do in this case :(\n}","label":[1,0,0,0]}
{"id":23738,"original_code":"@Override\n    public void validateStatusOnUpdate(Post post) {\n        \/\/ TODO Implement a method\n    }","code":"@Override\n    public void validateStatusOnUpdate(Post post) {\n       \n    }","cleancode":"@override public void validatestatusonupdate(post post) { }","comment":"\/\/ todo implement a method","repo":"reckue\/note-api","code_context_2":"@Override\npublic void validateStatusOnUpdate(Post post) {\n\/\/ TODO Implement a method\n}","code_context_10":"@Override\npublic void validateStatusOnUpdate(Post post) {\n\/\/ TODO Implement a method\n}","code_context_20":"@Override\npublic void validateStatusOnUpdate(Post post) {\n\/\/ TODO Implement a method\n}","label":[0,1,0,0]}
{"id":32092,"original_code":"private boolean validParameters(List<String> parameters) {\n        \/\/ TODO: throw a parsing error exception on the YAML parser when params size is less than 2.\n        return CollectionUtils.isNotEmpty(parameters) && parameters.size() >= 2;\n    }","code":"private boolean validParameters(List<String> parameters) {\n       \n        return CollectionUtils.isNotEmpty(parameters) && parameters.size() >= 2;\n    }","cleancode":"private boolean validparameters(list<string> parameters) { return collectionutils.isnotempty(parameters) && parameters.size() >= 2; }","comment":"\/* consider doing this in the tosca yaml parser *\/\n\/\/ todo: throw a parsing error exception on the yaml parser when params size is less than 2.","repo":"ngouagna\/alien4cloud-cloudify2-provider","code_context_2":"private boolean validParameters(List<String> parameters) {\n\/\/ TODO: throw a parsing error exception on the YAML parser when params size is less than 2.\nreturn CollectionUtils.isNotEmpty(parameters) && parameters.size() >= 2;\n}\n\nprivate boolean validParameters(List<String> parameters) {\n\/\/ TODO: throw a parsing error exception on the YAML parser when params size is less than 2.\nreturn CollectionUtils.isNotEmpty(parameters) && parameters.size() >= 2;\n}","code_context_10":"private boolean validParameters(List<String> parameters) {\n\/\/ TODO: throw a parsing error exception on the YAML parser when params size is less than 2.\nreturn CollectionUtils.isNotEmpty(parameters) && parameters.size() >= 2;\n}\n\nprivate boolean validParameters(List<String> parameters) {\n\/\/ TODO: throw a parsing error exception on the YAML parser when params size is less than 2.\nreturn CollectionUtils.isNotEmpty(parameters) && parameters.size() >= 2;\n}","code_context_20":"private boolean validParameters(List<String> parameters) {\n\/\/ TODO: throw a parsing error exception on the YAML parser when params size is less than 2.\nreturn CollectionUtils.isNotEmpty(parameters) && parameters.size() >= 2;\n}\n\nprivate boolean validParameters(List<String> parameters) {\n\/\/ TODO: throw a parsing error exception on the YAML parser when params size is less than 2.\nreturn CollectionUtils.isNotEmpty(parameters) && parameters.size() >= 2;\n}","label":[0,1,0,0]}
{"id":15833,"original_code":"private String get_location ()\n    {\n        final StackTraceElement[] stackTrace = new Throwable ().getStackTrace ();\n        for (int i = 2 \/* skip this+serviceChanged *\/; i < stackTrace.length; i++)\n        {\n            StackTraceElement ste = stackTrace [i];\n            String class_name = ste.getClassName ();\n            if (!class_name.startsWith (\"org.apache.felix.framework.\")      \/\/ Skip framework (todo: add more fws)\n                    && !class_name.equals (this.getClass ().getName ()))    \/\/ Skip ourselves\n            {\n                return (ste.toString ());\n            }\n        }\n        return (\"StackTraceElement:Unknown\");\n    }","code":"private String get_location ()\n    {\n        final StackTraceElement[] stackTrace = new Throwable ().getStackTrace ();\n        for (int i = 2; i < stackTrace.length; i++)\n        {\n            StackTraceElement ste = stackTrace [i];\n            String class_name = ste.getClassName ();\n            if (!class_name.startsWith (\"org.apache.felix.framework.\")     \n                    && !class_name.equals (this.getClass ().getName ()))   \n            {\n                return (ste.toString ());\n            }\n        }\n        return (\"StackTraceElement:Unknown\");\n    }","cleancode":"private string get_location () { final stacktraceelement[] stacktrace = new throwable ().getstacktrace (); for (int i = 2; i < stacktrace.length; i++) { stacktraceelement ste = stacktrace [i]; string class_name = ste.getclassname (); if (!class_name.startswith (\"org.apache.felix.framework.\") && !class_name.equals (this.getclass ().getname ())) { return (ste.tostring ()); } } return (\"stacktraceelement:unknown\"); }","comment":"\/* skip this+servicechanged *\/\n\/\/ skip framework (todo: add more fws)\n\/\/ skip ourselves","repo":"neoautus\/lucidj-core","code_context_2":"{\nfinal StackTraceElement[] stackTrace = new Throwable ().getStackTrace ();\nfor (int i = 2 \/* skip this+serviceChanged *\/; i < stackTrace.length; i++)\n{\nStackTraceElement ste = stackTrace [i];\n\nStackTraceElement ste = stackTrace [i];\nString class_name = ste.getClassName ();\nif (!class_name.startsWith (\"org.apache.felix.framework.\") \/\/ Skip framework (todo: add more fws)\n&& !class_name.equals (this.getClass ().getName ())) \/\/ Skip ourselves\n{\n\nString class_name = ste.getClassName ();\nif (!class_name.startsWith (\"org.apache.felix.framework.\") \/\/ Skip framework (todo: add more fws)\n&& !class_name.equals (this.getClass ().getName ())) \/\/ Skip ourselves\n{\nreturn (ste.toString ());","code_context_10":"private String get_location ()\n{\nfinal StackTraceElement[] stackTrace = new Throwable ().getStackTrace ();\nfor (int i = 2 \/* skip this+serviceChanged *\/; i < stackTrace.length; i++)\n{\nStackTraceElement ste = stackTrace [i];\nString class_name = ste.getClassName ();\nif (!class_name.startsWith (\"org.apache.felix.framework.\") \/\/ Skip framework (todo: add more fws)\n&& !class_name.equals (this.getClass ().getName ())) \/\/ Skip ourselves\n{\nreturn (ste.toString ());\n}\n}\nreturn (\"StackTraceElement:Unknown\");\n\nprivate String get_location ()\n{\nfinal StackTraceElement[] stackTrace = new Throwable ().getStackTrace ();\nfor (int i = 2 \/* skip this+serviceChanged *\/; i < stackTrace.length; i++)\n{\nStackTraceElement ste = stackTrace [i];\nString class_name = ste.getClassName ();\nif (!class_name.startsWith (\"org.apache.felix.framework.\") \/\/ Skip framework (todo: add more fws)\n&& !class_name.equals (this.getClass ().getName ())) \/\/ Skip ourselves\n{\nreturn (ste.toString ());\n}\n}\nreturn (\"StackTraceElement:Unknown\");\n}\n\nprivate String get_location ()\n{\nfinal StackTraceElement[] stackTrace = new Throwable ().getStackTrace ();\nfor (int i = 2 \/* skip this+serviceChanged *\/; i < stackTrace.length; i++)\n{\nStackTraceElement ste = stackTrace [i];\nString class_name = ste.getClassName ();\nif (!class_name.startsWith (\"org.apache.felix.framework.\") \/\/ Skip framework (todo: add more fws)\n&& !class_name.equals (this.getClass ().getName ())) \/\/ Skip ourselves\n{\nreturn (ste.toString ());\n}\n}\nreturn (\"StackTraceElement:Unknown\");\n}","code_context_20":"private String get_location ()\n{\nfinal StackTraceElement[] stackTrace = new Throwable ().getStackTrace ();\nfor (int i = 2 \/* skip this+serviceChanged *\/; i < stackTrace.length; i++)\n{\nStackTraceElement ste = stackTrace [i];\nString class_name = ste.getClassName ();\nif (!class_name.startsWith (\"org.apache.felix.framework.\") \/\/ Skip framework (todo: add more fws)\n&& !class_name.equals (this.getClass ().getName ())) \/\/ Skip ourselves\n{\nreturn (ste.toString ());\n}\n}\nreturn (\"StackTraceElement:Unknown\");\n}\n\nprivate String get_location ()\n{\nfinal StackTraceElement[] stackTrace = new Throwable ().getStackTrace ();\nfor (int i = 2 \/* skip this+serviceChanged *\/; i < stackTrace.length; i++)\n{\nStackTraceElement ste = stackTrace [i];\nString class_name = ste.getClassName ();\nif (!class_name.startsWith (\"org.apache.felix.framework.\") \/\/ Skip framework (todo: add more fws)\n&& !class_name.equals (this.getClass ().getName ())) \/\/ Skip ourselves\n{\nreturn (ste.toString ());\n}\n}\nreturn (\"StackTraceElement:Unknown\");\n}\n\nprivate String get_location ()\n{\nfinal StackTraceElement[] stackTrace = new Throwable ().getStackTrace ();\nfor (int i = 2 \/* skip this+serviceChanged *\/; i < stackTrace.length; i++)\n{\nStackTraceElement ste = stackTrace [i];\nString class_name = ste.getClassName ();\nif (!class_name.startsWith (\"org.apache.felix.framework.\") \/\/ Skip framework (todo: add more fws)\n&& !class_name.equals (this.getClass ().getName ())) \/\/ Skip ourselves\n{\nreturn (ste.toString ());\n}\n}\nreturn (\"StackTraceElement:Unknown\");\n}","label":[1,0,0,0]}
{"id":7735,"original_code":"public static void main(String[] args) {\n    \/\/ TODO(pdex): why are we making our own threadpool?\n    final List<ListeningExecutorService> l =\n        Spez.ServicePoolGenerator(THREAD_POOL, \"Spanner Tailer Event Worker\");\n    final SpannerTailer tailer = new SpannerTailer(THREAD_POOL, 200000000);\n    \/\/ final EventPublisher publisher = new EventPublisher(PROJECT_NAME, TOPIC_NAME);\n    final ThreadLocal<EventPublisher> publisher =\n        ThreadLocal.withInitial(\n            () -> {\n              return new EventPublisher(PROJECT_NAME, TOPIC_NAME);\n            });\n    final ExecutorService workStealingPool = Executors.newWorkStealingPool();\n    final ListeningExecutorService forkJoinPool =\n        MoreExecutors.listeningDecorator(workStealingPool);\n    final Map<String, String> metadata = new HashMap<>();\n    final CountDownLatch doneSignal = new CountDownLatch(1);\n    final ScheduledExecutorService scheduler = Executors.newScheduledThreadPool(1);\n    \/\/ Populate CDC Metadata\n    metadata.put(\"SrcDatabase\", DB_NAME);\n    metadata.put(\"SrcTablename\", TABLE_NAME);\n    metadata.put(\"DstTopic\", TOPIC_NAME);\n    final ListenableFuture<SchemaSet> schemaSetFuture =\n        tailer.getSchema(PROJECT_NAME, INSTANCE_NAME, DB_NAME, TABLE_NAME);\n    Futures.addCallback(\n        schemaSetFuture,\n        new FutureCallback<SchemaSet>() {\n          @Override\n          public void onSuccess(SchemaSet schemaSet) {\n            log.info(\"Successfully Processed the Table Schema. Starting the poller now ...\");\n            if (DISRUPTOR) {\n              DisruptorHandler handler =\n                  new DisruptorHandler(schemaSet, publisher, metadata, l.get(0));\n              handler.start();\n              tailer.setRingBuffer(handler.getRingBuffer());\n              ScheduledFuture<?> result =\n                  tailer.start(\n                      2,\n                      500,\n                      PROJECT_NAME,\n                      INSTANCE_NAME,\n                      DB_NAME,\n                      TABLE_NAME,\n                      \"lpts_table\",\n                      schemaSet.tsColName(),\n                      \"2000\");\n              doneSignal.countDown();\n            } else {\n              WorkStealingHandler handler =\n                  new WorkStealingHandler(scheduler, schemaSet, publisher, metadata);\n              tailer.start(\n                  handler,\n                  schemaSet.tsColName(),\n                  l.size(),\n                  THREAD_POOL,\n                  500,\n                  PROJECT_NAME,\n                  INSTANCE_NAME,\n                  DB_NAME,\n                  TABLE_NAME,\n                  \"lpts_table\",\n                  \"2000\",\n                  500,\n                  500);\n              scheduler.scheduleAtFixedRate(\n                  () -> {\n                    handler.logStats();\n                    tailer.logStats();\n                  },\n                  30,\n                  30,\n                  TimeUnit.SECONDS);\n              doneSignal.countDown();\n            }\n          }\n          @Override\n          public void onFailure(Throwable t) {\n            log.error(\"Unable to process schema\", t);\n            System.exit(-1);\n          }\n        },\n        l.get(l.size() % THREAD_POOL));\n    try {\n      log.debug(\"Dumping all known Loggers\");\n      LoggerContext lc = (LoggerContext) LoggerFactory.getILoggerFactory();\n      java.util.Iterator<ch.qos.logback.classic.Logger> it = lc.getLoggerList().iterator();\n      while (it.hasNext()) {\n        ch.qos.logback.classic.Logger thisLog = it.next();\n        log.debug(\"name: {} status: {}\", thisLog.getName(), thisLog.getLevel());\n      }\n      log.info(\"waiting for doneSignal\");\n      doneSignal.await();\n    } catch (InterruptedException e) {\n      e.printStackTrace();\n    }\n  }","code":"public static void main(String[] args) {\n   \n    final List<ListeningExecutorService> l =\n        Spez.ServicePoolGenerator(THREAD_POOL, \"Spanner Tailer Event Worker\");\n    final SpannerTailer tailer = new SpannerTailer(THREAD_POOL, 200000000);\n   \n    final ThreadLocal<EventPublisher> publisher =\n        ThreadLocal.withInitial(\n            () -> {\n              return new EventPublisher(PROJECT_NAME, TOPIC_NAME);\n            });\n    final ExecutorService workStealingPool = Executors.newWorkStealingPool();\n    final ListeningExecutorService forkJoinPool =\n        MoreExecutors.listeningDecorator(workStealingPool);\n    final Map<String, String> metadata = new HashMap<>();\n    final CountDownLatch doneSignal = new CountDownLatch(1);\n    final ScheduledExecutorService scheduler = Executors.newScheduledThreadPool(1);\n   \n    metadata.put(\"SrcDatabase\", DB_NAME);\n    metadata.put(\"SrcTablename\", TABLE_NAME);\n    metadata.put(\"DstTopic\", TOPIC_NAME);\n    final ListenableFuture<SchemaSet> schemaSetFuture =\n        tailer.getSchema(PROJECT_NAME, INSTANCE_NAME, DB_NAME, TABLE_NAME);\n    Futures.addCallback(\n        schemaSetFuture,\n        new FutureCallback<SchemaSet>() {\n          @Override\n          public void onSuccess(SchemaSet schemaSet) {\n            log.info(\"Successfully Processed the Table Schema. Starting the poller now ...\");\n            if (DISRUPTOR) {\n              DisruptorHandler handler =\n                  new DisruptorHandler(schemaSet, publisher, metadata, l.get(0));\n              handler.start();\n              tailer.setRingBuffer(handler.getRingBuffer());\n              ScheduledFuture<?> result =\n                  tailer.start(\n                      2,\n                      500,\n                      PROJECT_NAME,\n                      INSTANCE_NAME,\n                      DB_NAME,\n                      TABLE_NAME,\n                      \"lpts_table\",\n                      schemaSet.tsColName(),\n                      \"2000\");\n              doneSignal.countDown();\n            } else {\n              WorkStealingHandler handler =\n                  new WorkStealingHandler(scheduler, schemaSet, publisher, metadata);\n              tailer.start(\n                  handler,\n                  schemaSet.tsColName(),\n                  l.size(),\n                  THREAD_POOL,\n                  500,\n                  PROJECT_NAME,\n                  INSTANCE_NAME,\n                  DB_NAME,\n                  TABLE_NAME,\n                  \"lpts_table\",\n                  \"2000\",\n                  500,\n                  500);\n              scheduler.scheduleAtFixedRate(\n                  () -> {\n                    handler.logStats();\n                    tailer.logStats();\n                  },\n                  30,\n                  30,\n                  TimeUnit.SECONDS);\n              doneSignal.countDown();\n            }\n          }\n          @Override\n          public void onFailure(Throwable t) {\n            log.error(\"Unable to process schema\", t);\n            System.exit(-1);\n          }\n        },\n        l.get(l.size() % THREAD_POOL));\n    try {\n      log.debug(\"Dumping all known Loggers\");\n      LoggerContext lc = (LoggerContext) LoggerFactory.getILoggerFactory();\n      java.util.Iterator<ch.qos.logback.classic.Logger> it = lc.getLoggerList().iterator();\n      while (it.hasNext()) {\n        ch.qos.logback.classic.Logger thisLog = it.next();\n        log.debug(\"name: {} status: {}\", thisLog.getName(), thisLog.getLevel());\n      }\n      log.info(\"waiting for doneSignal\");\n      doneSignal.await();\n    } catch (InterruptedException e) {\n      e.printStackTrace();\n    }\n  }","cleancode":"public static void main(string[] args) { final list<listeningexecutorservice> l = spez.servicepoolgenerator(thread_pool, \"spanner tailer event worker\"); final spannertailer tailer = new spannertailer(thread_pool, 200000000); final threadlocal<eventpublisher> publisher = threadlocal.withinitial( () -> { return new eventpublisher(project_name, topic_name); }); final executorservice workstealingpool = executors.newworkstealingpool(); final listeningexecutorservice forkjoinpool = moreexecutors.listeningdecorator(workstealingpool); final map<string, string> metadata = new hashmap<>(); final countdownlatch donesignal = new countdownlatch(1); final scheduledexecutorservice scheduler = executors.newscheduledthreadpool(1); metadata.put(\"srcdatabase\", db_name); metadata.put(\"srctablename\", table_name); metadata.put(\"dsttopic\", topic_name); final listenablefuture<schemaset> schemasetfuture = tailer.getschema(project_name, instance_name, db_name, table_name); futures.addcallback( schemasetfuture, new futurecallback<schemaset>() { @override public void onsuccess(schemaset schemaset) { log.info(\"successfully processed the table schema. starting the poller now ...\"); if (disruptor) { disruptorhandler handler = new disruptorhandler(schemaset, publisher, metadata, l.get(0)); handler.start(); tailer.setringbuffer(handler.getringbuffer()); scheduledfuture<?> result = tailer.start( 2, 500, project_name, instance_name, db_name, table_name, \"lpts_table\", schemaset.tscolname(), \"2000\"); donesignal.countdown(); } else { workstealinghandler handler = new workstealinghandler(scheduler, schemaset, publisher, metadata); tailer.start( handler, schemaset.tscolname(), l.size(), thread_pool, 500, project_name, instance_name, db_name, table_name, \"lpts_table\", \"2000\", 500, 500); scheduler.scheduleatfixedrate( () -> { handler.logstats(); tailer.logstats(); }, 30, 30, timeunit.seconds); donesignal.countdown(); } } @override public void onfailure(throwable t) { log.error(\"unable to process schema\", t); system.exit(-1); } }, l.get(l.size() % thread_pool)); try { log.debug(\"dumping all known loggers\"); loggercontext lc = (loggercontext) loggerfactory.getiloggerfactory(); java.util.iterator<ch.qos.logback.classic.logger> it = lc.getloggerlist().iterator(); while (it.hasnext()) { ch.qos.logback.classic.logger thislog = it.next(); log.debug(\"name: {} status: {}\", thislog.getname(), thislog.getlevel()); } log.info(\"waiting for donesignal\"); donesignal.await(); } catch (interruptedexception e) { e.printstacktrace(); } }","comment":"\/\/ todo(pdex): why are we making our own threadpool?\n\/\/ final eventpublisher publisher = new eventpublisher(project_name, topic_name);\n\/\/ populate cdc metadata","repo":"olavloite\/spez2","code_context_2":"public static void main(String[] args) {\n\/\/ TODO(pdex): why are we making our own threadpool?\nfinal List<ListeningExecutorService> l =\nSpez.ServicePoolGenerator(THREAD_POOL, \"Spanner Tailer Event Worker\");\n\nSpez.ServicePoolGenerator(THREAD_POOL, \"Spanner Tailer Event Worker\");\nfinal SpannerTailer tailer = new SpannerTailer(THREAD_POOL, 200000000);\n\/\/ final EventPublisher publisher = new EventPublisher(PROJECT_NAME, TOPIC_NAME);\nfinal ThreadLocal<EventPublisher> publisher =\nThreadLocal.withInitial(\n\nfinal CountDownLatch doneSignal = new CountDownLatch(1);\nfinal ScheduledExecutorService scheduler = Executors.newScheduledThreadPool(1);\n\/\/ Populate CDC Metadata\nmetadata.put(\"SrcDatabase\", DB_NAME);\nmetadata.put(\"SrcTablename\", TABLE_NAME);","code_context_10":"public static void main(String[] args) {\n\/\/ TODO(pdex): why are we making our own threadpool?\nfinal List<ListeningExecutorService> l =\nSpez.ServicePoolGenerator(THREAD_POOL, \"Spanner Tailer Event Worker\");\nfinal SpannerTailer tailer = new SpannerTailer(THREAD_POOL, 200000000);\n\/\/ final EventPublisher publisher = new EventPublisher(PROJECT_NAME, TOPIC_NAME);\nfinal ThreadLocal<EventPublisher> publisher =\nThreadLocal.withInitial(\n() -> {\nreturn new EventPublisher(PROJECT_NAME, TOPIC_NAME);\n});\nfinal ExecutorService workStealingPool = Executors.newWorkStealingPool();\n\npublic static void main(String[] args) {\n\/\/ TODO(pdex): why are we making our own threadpool?\nfinal List<ListeningExecutorService> l =\nSpez.ServicePoolGenerator(THREAD_POOL, \"Spanner Tailer Event Worker\");\nfinal SpannerTailer tailer = new SpannerTailer(THREAD_POOL, 200000000);\n\/\/ final EventPublisher publisher = new EventPublisher(PROJECT_NAME, TOPIC_NAME);\nfinal ThreadLocal<EventPublisher> publisher =\nThreadLocal.withInitial(\n() -> {\nreturn new EventPublisher(PROJECT_NAME, TOPIC_NAME);\n});\nfinal ExecutorService workStealingPool = Executors.newWorkStealingPool();\nfinal ListeningExecutorService forkJoinPool =\nMoreExecutors.listeningDecorator(workStealingPool);\nfinal Map<String, String> metadata = new HashMap<>();\nfinal CountDownLatch doneSignal = new CountDownLatch(1);\n\nThreadLocal.withInitial(\n() -> {\nreturn new EventPublisher(PROJECT_NAME, TOPIC_NAME);\n});\nfinal ExecutorService workStealingPool = Executors.newWorkStealingPool();\nfinal ListeningExecutorService forkJoinPool =\nMoreExecutors.listeningDecorator(workStealingPool);\nfinal Map<String, String> metadata = new HashMap<>();\nfinal CountDownLatch doneSignal = new CountDownLatch(1);\nfinal ScheduledExecutorService scheduler = Executors.newScheduledThreadPool(1);\n\/\/ Populate CDC Metadata\nmetadata.put(\"SrcDatabase\", DB_NAME);\nmetadata.put(\"SrcTablename\", TABLE_NAME);\nmetadata.put(\"DstTopic\", TOPIC_NAME);\nfinal ListenableFuture<SchemaSet> schemaSetFuture =\ntailer.getSchema(PROJECT_NAME, INSTANCE_NAME, DB_NAME, TABLE_NAME);\nFutures.addCallback(\nschemaSetFuture,\nnew FutureCallback<SchemaSet>() {\n@Override\npublic void onSuccess(SchemaSet schemaSet) {","code_context_20":"public static void main(String[] args) {\n\/\/ TODO(pdex): why are we making our own threadpool?\nfinal List<ListeningExecutorService> l =\nSpez.ServicePoolGenerator(THREAD_POOL, \"Spanner Tailer Event Worker\");\nfinal SpannerTailer tailer = new SpannerTailer(THREAD_POOL, 200000000);\n\/\/ final EventPublisher publisher = new EventPublisher(PROJECT_NAME, TOPIC_NAME);\nfinal ThreadLocal<EventPublisher> publisher =\nThreadLocal.withInitial(\n() -> {\nreturn new EventPublisher(PROJECT_NAME, TOPIC_NAME);\n});\nfinal ExecutorService workStealingPool = Executors.newWorkStealingPool();\nfinal ListeningExecutorService forkJoinPool =\nMoreExecutors.listeningDecorator(workStealingPool);\nfinal Map<String, String> metadata = new HashMap<>();\nfinal CountDownLatch doneSignal = new CountDownLatch(1);\nfinal ScheduledExecutorService scheduler = Executors.newScheduledThreadPool(1);\n\/\/ Populate CDC Metadata\nmetadata.put(\"SrcDatabase\", DB_NAME);\nmetadata.put(\"SrcTablename\", TABLE_NAME);\nmetadata.put(\"DstTopic\", TOPIC_NAME);\nfinal ListenableFuture<SchemaSet> schemaSetFuture =\n\npublic static void main(String[] args) {\n\/\/ TODO(pdex): why are we making our own threadpool?\nfinal List<ListeningExecutorService> l =\nSpez.ServicePoolGenerator(THREAD_POOL, \"Spanner Tailer Event Worker\");\nfinal SpannerTailer tailer = new SpannerTailer(THREAD_POOL, 200000000);\n\/\/ final EventPublisher publisher = new EventPublisher(PROJECT_NAME, TOPIC_NAME);\nfinal ThreadLocal<EventPublisher> publisher =\nThreadLocal.withInitial(\n() -> {\nreturn new EventPublisher(PROJECT_NAME, TOPIC_NAME);\n});\nfinal ExecutorService workStealingPool = Executors.newWorkStealingPool();\nfinal ListeningExecutorService forkJoinPool =\nMoreExecutors.listeningDecorator(workStealingPool);\nfinal Map<String, String> metadata = new HashMap<>();\nfinal CountDownLatch doneSignal = new CountDownLatch(1);\nfinal ScheduledExecutorService scheduler = Executors.newScheduledThreadPool(1);\n\/\/ Populate CDC Metadata\nmetadata.put(\"SrcDatabase\", DB_NAME);\nmetadata.put(\"SrcTablename\", TABLE_NAME);\nmetadata.put(\"DstTopic\", TOPIC_NAME);\nfinal ListenableFuture<SchemaSet> schemaSetFuture =\ntailer.getSchema(PROJECT_NAME, INSTANCE_NAME, DB_NAME, TABLE_NAME);\nFutures.addCallback(\nschemaSetFuture,\nnew FutureCallback<SchemaSet>() {\n\npublic static void main(String[] args) {\n\/\/ TODO(pdex): why are we making our own threadpool?\nfinal List<ListeningExecutorService> l =\nSpez.ServicePoolGenerator(THREAD_POOL, \"Spanner Tailer Event Worker\");\nfinal SpannerTailer tailer = new SpannerTailer(THREAD_POOL, 200000000);\n\/\/ final EventPublisher publisher = new EventPublisher(PROJECT_NAME, TOPIC_NAME);\nfinal ThreadLocal<EventPublisher> publisher =\nThreadLocal.withInitial(\n() -> {\nreturn new EventPublisher(PROJECT_NAME, TOPIC_NAME);\n});\nfinal ExecutorService workStealingPool = Executors.newWorkStealingPool();\nfinal ListeningExecutorService forkJoinPool =\nMoreExecutors.listeningDecorator(workStealingPool);\nfinal Map<String, String> metadata = new HashMap<>();\nfinal CountDownLatch doneSignal = new CountDownLatch(1);\nfinal ScheduledExecutorService scheduler = Executors.newScheduledThreadPool(1);\n\/\/ Populate CDC Metadata\nmetadata.put(\"SrcDatabase\", DB_NAME);\nmetadata.put(\"SrcTablename\", TABLE_NAME);\nmetadata.put(\"DstTopic\", TOPIC_NAME);\nfinal ListenableFuture<SchemaSet> schemaSetFuture =\ntailer.getSchema(PROJECT_NAME, INSTANCE_NAME, DB_NAME, TABLE_NAME);\nFutures.addCallback(\nschemaSetFuture,\nnew FutureCallback<SchemaSet>() {\n@Override\npublic void onSuccess(SchemaSet schemaSet) {\nlog.info(\"Successfully Processed the Table Schema. Starting the poller now ...\");\nif (DISRUPTOR) {\nDisruptorHandler handler =\nnew DisruptorHandler(schemaSet, publisher, metadata, l.get(0));\nhandler.start();\ntailer.setRingBuffer(handler.getRingBuffer());\nScheduledFuture<?> result =\ntailer.start(\n2,\n500,","label":[1,0,0,0]}
{"id":24154,"original_code":"@Test\n    public void trouble_maker() {\n        Mono<String> trouble = null; \/\/todo: change this line\n        StepVerifier.create(trouble)\n                    .expectError(IllegalStateException.class)\n                    .verify();\n    }","code":"@Test\n    public void trouble_maker() {\n        Mono<String> trouble = null;\n        StepVerifier.create(trouble)\n                    .expectError(IllegalStateException.class)\n                    .verify();\n    }","cleancode":"@test public void trouble_maker() { mono<string> trouble = null; stepverifier.create(trouble) .expecterror(illegalstateexception.class) .verify(); }","comment":"\/** * create mono that completes exceptionally with exception `illegalstateexception`. *\/\n\/\/todo: change this line","repo":"nicolasbelfis\/practical-reactor","code_context_2":"@Test\npublic void trouble_maker() {\nMono<String> trouble = null; \/\/todo: change this line\nStepVerifier.create(trouble)\n.expectError(IllegalStateException.class)\n.verify();\n}\n\n@Test\npublic void trouble_maker() {\nMono<String> trouble = null; \/\/todo: change this line\nStepVerifier.create(trouble)\n.expectError(IllegalStateException.class)","code_context_10":"@Test\npublic void trouble_maker() {\nMono<String> trouble = null; \/\/todo: change this line\nStepVerifier.create(trouble)\n.expectError(IllegalStateException.class)\n.verify();\n}\n\n@Test\npublic void trouble_maker() {\nMono<String> trouble = null; \/\/todo: change this line\nStepVerifier.create(trouble)\n.expectError(IllegalStateException.class)\n.verify();\n}","code_context_20":"@Test\npublic void trouble_maker() {\nMono<String> trouble = null; \/\/todo: change this line\nStepVerifier.create(trouble)\n.expectError(IllegalStateException.class)\n.verify();\n}\n\n@Test\npublic void trouble_maker() {\nMono<String> trouble = null; \/\/todo: change this line\nStepVerifier.create(trouble)\n.expectError(IllegalStateException.class)\n.verify();\n}","label":[1,0,0,0]}
{"id":24160,"original_code":"@Test\n    public void repeat() {\n        AtomicInteger counter = new AtomicInteger(0);\n        Flux<Integer> repeated = null; \/\/todo: change this line\n        System.out.println(\"Repeat: \");\n        StepVerifier.create(repeated.doOnNext(System.out::println))\n                    .expectNext(1, 2, 3, 4, 5, 6, 7, 8, 9, 10)\n                    .verifyComplete();\n    }","code":"@Test\n    public void repeat() {\n        AtomicInteger counter = new AtomicInteger(0);\n        Flux<Integer> repeated = null;\n        System.out.println(\"Repeat: \");\n        StepVerifier.create(repeated.doOnNext(System.out::println))\n                    .expectNext(1, 2, 3, 4, 5, 6, 7, 8, 9, 10)\n                    .verifyComplete();\n    }","cleancode":"@test public void repeat() { atomicinteger counter = new atomicinteger(0); flux<integer> repeated = null; system.out.println(\"repeat: \"); stepverifier.create(repeated.doonnext(system.out::println)) .expectnext(1, 2, 3, 4, 5, 6, 7, 8, 9, 10) .verifycomplete(); }","comment":"\/** * create callable that increments the counter and returns the counter value, and then use `repeat()` operator to create flux that emits * values from 0 to 10. *\/\n\/\/todo: change this line","repo":"nicolasbelfis\/practical-reactor","code_context_2":"@Test\npublic void repeat() {\nAtomicInteger counter = new AtomicInteger(0);\nFlux<Integer> repeated = null; \/\/todo: change this line\nSystem.out.println(\"Repeat: \");\nStepVerifier.create(repeated.doOnNext(System.out::println))\n.expectNext(1, 2, 3, 4, 5, 6, 7, 8, 9, 10)\n.verifyComplete();\n}\n\npublic void repeat() {\nAtomicInteger counter = new AtomicInteger(0);\nFlux<Integer> repeated = null; \/\/todo: change this line\nSystem.out.println(\"Repeat: \");\nStepVerifier.create(repeated.doOnNext(System.out::println))","code_context_10":"@Test\npublic void repeat() {\nAtomicInteger counter = new AtomicInteger(0);\nFlux<Integer> repeated = null; \/\/todo: change this line\nSystem.out.println(\"Repeat: \");\nStepVerifier.create(repeated.doOnNext(System.out::println))\n.expectNext(1, 2, 3, 4, 5, 6, 7, 8, 9, 10)\n.verifyComplete();\n}\n\n@Test\npublic void repeat() {\nAtomicInteger counter = new AtomicInteger(0);\nFlux<Integer> repeated = null; \/\/todo: change this line\nSystem.out.println(\"Repeat: \");\nStepVerifier.create(repeated.doOnNext(System.out::println))\n.expectNext(1, 2, 3, 4, 5, 6, 7, 8, 9, 10)\n.verifyComplete();\n}","code_context_20":"@Test\npublic void repeat() {\nAtomicInteger counter = new AtomicInteger(0);\nFlux<Integer> repeated = null; \/\/todo: change this line\nSystem.out.println(\"Repeat: \");\nStepVerifier.create(repeated.doOnNext(System.out::println))\n.expectNext(1, 2, 3, 4, 5, 6, 7, 8, 9, 10)\n.verifyComplete();\n}\n\n@Test\npublic void repeat() {\nAtomicInteger counter = new AtomicInteger(0);\nFlux<Integer> repeated = null; \/\/todo: change this line\nSystem.out.println(\"Repeat: \");\nStepVerifier.create(repeated.doOnNext(System.out::println))\n.expectNext(1, 2, 3, 4, 5, 6, 7, 8, 9, 10)\n.verifyComplete();\n}","label":[1,0,0,0]}
{"id":7823,"original_code":"private static double EvalSegmentedFn(final cmsToneCurve g, double R)\n\t{\n\t    int i;\n\t    for (i = g.nSegments-1; i >= 0 ; --i)\n\t    {\n\t        \/\/ Check for domain\n\t        if ((R > g.Segments[i].x0) && (R <= g.Segments[i].x1))\n\t        {\n\t            \/\/ Type == 0 means segment is sampled\n\t            if (g.Segments[i].Type == 0)\n\t            {\n\t                float R1 = (float)(R - g.Segments[i].x0);\n\t                float[] Out = new float[1];\n\t                \/\/ Setup the table (TODO: clean that)\n\t                g.SegInterp[i].Table = g.Segments[i].SampledPoints;\n\t                g.SegInterp[i].Interpolation.getFloat().run(new float[]{R1}, Out, g.SegInterp[i]);\n\t                return Out[0];\n\t            }\n\t            else\n\t            {\n\t            \treturn g.Evals[i].run(g.Segments[i].Type, g.Segments[i].Params, R);\n\t            }\n\t        }\n\t    }\n\t    return MINUS_INF;\n\t}","code":"private static double EvalSegmentedFn(final cmsToneCurve g, double R)\n\t{\n\t    int i;\n\t    for (i = g.nSegments-1; i >= 0 ; --i)\n\t    {\n\t       \n\t        if ((R > g.Segments[i].x0) && (R <= g.Segments[i].x1))\n\t        {\n\t           \n\t            if (g.Segments[i].Type == 0)\n\t            {\n\t                float R1 = (float)(R - g.Segments[i].x0);\n\t                float[] Out = new float[1];\n\t               \n\t                g.SegInterp[i].Table = g.Segments[i].SampledPoints;\n\t                g.SegInterp[i].Interpolation.getFloat().run(new float[]{R1}, Out, g.SegInterp[i]);\n\t                return Out[0];\n\t            }\n\t            else\n\t            {\n\t            \treturn g.Evals[i].run(g.Segments[i].Type, g.Segments[i].Params, R);\n\t            }\n\t        }\n\t    }\n\t    return MINUS_INF;\n\t}","cleancode":"private static double evalsegmentedfn(final cmstonecurve g, double r) { int i; for (i = g.nsegments-1; i >= 0 ; --i) { if ((r > g.segments[i].x0) && (r <= g.segments[i].x1)) { if (g.segments[i].type == 0) { float r1 = (float)(r - g.segments[i].x0); float[] out = new float[1]; g.seginterp[i].table = g.segments[i].sampledpoints; g.seginterp[i].interpolation.getfloat().run(new float[]{r1}, out, g.seginterp[i]); return out[0]; } else { return g.evals[i].run(g.segments[i].type, g.segments[i].params, r); } } } return minus_inf; }","comment":"\/\/ evaluate a segmented funtion for a single value. return -1 if no valid segment found . \/\/ if fn type is 0, perform an interpolation on the table\n\/\/ check for domain\n\/\/ type == 0 means segment is sampled\n\/\/ setup the table (todo: clean that)","repo":"rcmaniac25\/little-cms-for-blackberry","code_context_2":"private static double EvalSegmentedFn(final cmsToneCurve g, double R)\n{\nint i;\nfor (i = g.nSegments-1; i >= 0 ; --i)\n{\n\/\/ Check for domain\nif ((R > g.Segments[i].x0) && (R <= g.Segments[i].x1))\n{\n\/\/ Type == 0 means segment is sampled\nif (g.Segments[i].Type == 0)\n{\nfloat R1 = (float)(R - g.Segments[i].x0);\nfloat[] Out = new float[1];\n\/\/ Setup the table (TODO: clean that)\ng.SegInterp[i].Table = g.Segments[i].SampledPoints;\ng.SegInterp[i].Interpolation.getFloat().run(new float[]{R1}, Out, g.SegInterp[i]);\nreturn Out[0];\n}\nelse\n{\nreturn g.Evals[i].run(g.Segments[i].Type, g.Segments[i].Params, R);\n}\n}\n}\nreturn MINUS_INF;\n}\n\nfor (i = g.nSegments-1; i >= 0 ; --i)\n{\n\/\/ Check for domain\nif ((R > g.Segments[i].x0) && (R <= g.Segments[i].x1))\n{\n\nif ((R > g.Segments[i].x0) && (R <= g.Segments[i].x1))\n{\n\/\/ Type == 0 means segment is sampled\nif (g.Segments[i].Type == 0)\n{\n\nfloat R1 = (float)(R - g.Segments[i].x0);\nfloat[] Out = new float[1];\n\/\/ Setup the table (TODO: clean that)\ng.SegInterp[i].Table = g.Segments[i].SampledPoints;\ng.SegInterp[i].Interpolation.getFloat().run(new float[]{R1}, Out, g.SegInterp[i]);","code_context_10":"private static double EvalSegmentedFn(final cmsToneCurve g, double R)\n{\nint i;\nfor (i = g.nSegments-1; i >= 0 ; --i)\n{\n\/\/ Check for domain\nif ((R > g.Segments[i].x0) && (R <= g.Segments[i].x1))\n{\n\/\/ Type == 0 means segment is sampled\nif (g.Segments[i].Type == 0)\n{\nfloat R1 = (float)(R - g.Segments[i].x0);\nfloat[] Out = new float[1];\n\/\/ Setup the table (TODO: clean that)\ng.SegInterp[i].Table = g.Segments[i].SampledPoints;\ng.SegInterp[i].Interpolation.getFloat().run(new float[]{R1}, Out, g.SegInterp[i]);\nreturn Out[0];\n}\nelse\n{\nreturn g.Evals[i].run(g.Segments[i].Type, g.Segments[i].Params, R);\n}\n}\n}\nreturn MINUS_INF;\n}\n\nprivate static double EvalSegmentedFn(final cmsToneCurve g, double R)\n{\nint i;\nfor (i = g.nSegments-1; i >= 0 ; --i)\n{\n\/\/ Check for domain\nif ((R > g.Segments[i].x0) && (R <= g.Segments[i].x1))\n{\n\/\/ Type == 0 means segment is sampled\nif (g.Segments[i].Type == 0)\n{\nfloat R1 = (float)(R - g.Segments[i].x0);\nfloat[] Out = new float[1];\n\/\/ Setup the table (TODO: clean that)\ng.SegInterp[i].Table = g.Segments[i].SampledPoints;\ng.SegInterp[i].Interpolation.getFloat().run(new float[]{R1}, Out, g.SegInterp[i]);\n\nprivate static double EvalSegmentedFn(final cmsToneCurve g, double R)\n{\nint i;\nfor (i = g.nSegments-1; i >= 0 ; --i)\n{\n\/\/ Check for domain\nif ((R > g.Segments[i].x0) && (R <= g.Segments[i].x1))\n{\n\/\/ Type == 0 means segment is sampled\nif (g.Segments[i].Type == 0)\n{\nfloat R1 = (float)(R - g.Segments[i].x0);\nfloat[] Out = new float[1];\n\/\/ Setup the table (TODO: clean that)\ng.SegInterp[i].Table = g.Segments[i].SampledPoints;\ng.SegInterp[i].Interpolation.getFloat().run(new float[]{R1}, Out, g.SegInterp[i]);\nreturn Out[0];\n}\nelse\n\nfor (i = g.nSegments-1; i >= 0 ; --i)\n{\n\/\/ Check for domain\nif ((R > g.Segments[i].x0) && (R <= g.Segments[i].x1))\n{\n\/\/ Type == 0 means segment is sampled\nif (g.Segments[i].Type == 0)\n{\nfloat R1 = (float)(R - g.Segments[i].x0);\nfloat[] Out = new float[1];\n\/\/ Setup the table (TODO: clean that)\ng.SegInterp[i].Table = g.Segments[i].SampledPoints;\ng.SegInterp[i].Interpolation.getFloat().run(new float[]{R1}, Out, g.SegInterp[i]);\nreturn Out[0];\n}\nelse\n{\nreturn g.Evals[i].run(g.Segments[i].Type, g.Segments[i].Params, R);\n}\n}\n}","code_context_20":"private static double EvalSegmentedFn(final cmsToneCurve g, double R)\n{\nint i;\nfor (i = g.nSegments-1; i >= 0 ; --i)\n{\n\/\/ Check for domain\nif ((R > g.Segments[i].x0) && (R <= g.Segments[i].x1))\n{\n\/\/ Type == 0 means segment is sampled\nif (g.Segments[i].Type == 0)\n{\nfloat R1 = (float)(R - g.Segments[i].x0);\nfloat[] Out = new float[1];\n\/\/ Setup the table (TODO: clean that)\ng.SegInterp[i].Table = g.Segments[i].SampledPoints;\ng.SegInterp[i].Interpolation.getFloat().run(new float[]{R1}, Out, g.SegInterp[i]);\nreturn Out[0];\n}\nelse\n{\nreturn g.Evals[i].run(g.Segments[i].Type, g.Segments[i].Params, R);\n}\n}\n}\nreturn MINUS_INF;\n}\n\nprivate static double EvalSegmentedFn(final cmsToneCurve g, double R)\n{\nint i;\nfor (i = g.nSegments-1; i >= 0 ; --i)\n{\n\/\/ Check for domain\nif ((R > g.Segments[i].x0) && (R <= g.Segments[i].x1))\n{\n\/\/ Type == 0 means segment is sampled\nif (g.Segments[i].Type == 0)\n{\nfloat R1 = (float)(R - g.Segments[i].x0);\nfloat[] Out = new float[1];\n\/\/ Setup the table (TODO: clean that)\ng.SegInterp[i].Table = g.Segments[i].SampledPoints;\ng.SegInterp[i].Interpolation.getFloat().run(new float[]{R1}, Out, g.SegInterp[i]);\nreturn Out[0];\n}\nelse\n{\nreturn g.Evals[i].run(g.Segments[i].Type, g.Segments[i].Params, R);\n}\n}\n}\nreturn MINUS_INF;\n}\n\nprivate static double EvalSegmentedFn(final cmsToneCurve g, double R)\n{\nint i;\nfor (i = g.nSegments-1; i >= 0 ; --i)\n{\n\/\/ Check for domain\nif ((R > g.Segments[i].x0) && (R <= g.Segments[i].x1))\n{\n\/\/ Type == 0 means segment is sampled\nif (g.Segments[i].Type == 0)\n{\nfloat R1 = (float)(R - g.Segments[i].x0);\nfloat[] Out = new float[1];\n\/\/ Setup the table (TODO: clean that)\ng.SegInterp[i].Table = g.Segments[i].SampledPoints;\ng.SegInterp[i].Interpolation.getFloat().run(new float[]{R1}, Out, g.SegInterp[i]);\nreturn Out[0];\n}\nelse\n{\nreturn g.Evals[i].run(g.Segments[i].Type, g.Segments[i].Params, R);\n}\n}\n}\nreturn MINUS_INF;\n}\n\nprivate static double EvalSegmentedFn(final cmsToneCurve g, double R)\n{\nint i;\nfor (i = g.nSegments-1; i >= 0 ; --i)\n{\n\/\/ Check for domain\nif ((R > g.Segments[i].x0) && (R <= g.Segments[i].x1))\n{\n\/\/ Type == 0 means segment is sampled\nif (g.Segments[i].Type == 0)\n{\nfloat R1 = (float)(R - g.Segments[i].x0);\nfloat[] Out = new float[1];\n\/\/ Setup the table (TODO: clean that)\ng.SegInterp[i].Table = g.Segments[i].SampledPoints;\ng.SegInterp[i].Interpolation.getFloat().run(new float[]{R1}, Out, g.SegInterp[i]);\nreturn Out[0];\n}\nelse\n{\nreturn g.Evals[i].run(g.Segments[i].Type, g.Segments[i].Params, R);\n}\n}\n}\nreturn MINUS_INF;\n}","label":[1,0,0,0]}
{"id":16061,"original_code":"@Override\n    protected BufferedDataTable[] execute(final BufferedDataTable[] inData,\n            final ExecutionContext exec) throws Exception {\n    \tDataColumnSpec[] allColSpecs = new DataColumnSpec[1];\n        allColSpecs[0] = \n                new DataColumnSpecCreator(\"url\", StringCell.TYPE).createSpec();\n        DataTableSpec outputSpec = new DataTableSpec(allColSpecs);\n     \/\/   System.out.println(\"calling execute\"+resultUrl.getStringValue());\n        \/\/ the execution context will provide us with storage capacity, in this\n        \/\/ case a data container to which we will add rows sequentially\n        \/\/ Note, this container can also handle arbitrary big data tables, it\n        \/\/ will buffer to disc if necessary.\n        BufferedDataContainer container = exec.createDataContainer(outputSpec);\n        DataCell[] cells = new DataCell[1];\n\tString urlTemplate = resultUrl.getStringValue();\n\tIterator<DataRow> varIt = inData[0].iterator();\n\tDataTableSpec dts = inData[0].getDataTableSpec();\n\tString[] colNames = dts.getColumnNames();\n\tif(varIt.hasNext()){\n\t\/\/while(varIt.hasNext()){\n\t\tDataRow current = varIt.next();\n\t\tIterator<DataCell> cellIt = current.iterator();\n\t\tint colCount = 0;\n\t\twhile(cellIt.hasNext()){\n\t\t\tDataCell currentCell= cellIt.next();\n\t\t\tString curVar =  colNames[colCount];\n\t\t\tString curVal = currentCell.toString();\n\t\t\t\/\/System.out.println(\"curvar:\"+curVar+\", curval:\"+curVal+\", urlTemplate:\"+urlTemplate);\n\t\t\t\tif(urlTemplate.indexOf(curVar)==-1){\n\t\t\t\t\tSystem.out.println(\"1curvar:\"+curVar+\", curval:\"+curVal+\", urlTemplate:\"+urlTemplate);\n\t\t\t\t\turlTemplate = urlTemplate+\"&\"+curVar+\"=\"+URLEncoder.encode(currentCell.toString(),\"UTF-8\");\n\t\t\t\t\tSystem.out.println(\"2curvar:\"+curVar+\", curval:\"+curVal+\", urlTemplate:\"+urlTemplate);\n\t\t\t\t}else{\n\t\t\t\t\tSystem.out.println(\"3curvar:\"+curVar+\", curval:\"+curVal+\", urlTemplate:\"+urlTemplate);\n\t\t\t\t\tString configValue = \"\";\n\t\t\t\t\tif(urlTemplate.indexOf(\"&\"+curVar)!=-1){\n\t\t\t\t\t\tconfigValue = urlTemplate.substring(urlTemplate.indexOf(\"&\"+curVar)+curVar.length()+2,urlTemplate.indexOf(\"]\",urlTemplate.indexOf(curVar)));\n\t\t\t\t\t}else if(urlTemplate.indexOf(\"?\"+curVar)!=-1){\n\t\t\t\t\t\tconfigValue = urlTemplate.substring(urlTemplate.indexOf(\"?\"+curVar)+curVar.length()+2,urlTemplate.indexOf(\"]\",urlTemplate.indexOf(curVar)));\n\t\t\t\t\t}\n\t\t\t\t\tSystem.out.println(\"4curvar:\"+curVar+\", curval:\"+curVal+\", urlTemplate:\"+urlTemplate);\n\t\t\t\t\tif(configValue.endsWith(\"&\")){\n\t\t\t\t\t\tconfigValue = configValue.substring(0,configValue.length()-1); \/\/get rid of the &\n\t\t\t\t\t}\n\t\t\t\t\tif(colCount==0){\n\t\t\t\t\t\turlTemplate +=\"&\";\n\t\t\t\t\t}\n\t\t\t\t\tSystem.out.println(\"5curvar:\"+curVar+\", curval:\"+curVal+\", urlTemplate:\"+urlTemplate);\n\t\t\t\t\tif(!configValue.equals(\"\")){\n\t\t\t\t\t\tSystem.out.println(\"6curvar:\"+curVar+\", curval:\"+curVal+\", urlTemplate:\"+urlTemplate);\n\t\t\t\t\t\tSystem.out.println(\"config var: \"+curVar+\" with configValue:\"+ configValue+ \", is overwritten with value: \"+currentCell.toString()  );\n\t\t\t\t\t\turlTemplate = urlTemplate.replaceAll(Pattern.quote(\"[\"+curVar+\"=\"+configValue+\"&]\"), curVar+\"=\"+URLEncoder.encode(currentCell.toString(),\"UTF-8\")+\"&\");\n\t\t\t\t\t\turlTemplate = urlTemplate.replaceAll(Pattern.quote(\"[\"+curVar+\"=\"+configValue+\"]\"), curVar+\"=\"+URLEncoder.encode(currentCell.toString(),\"UTF-8\"));\n\t\t\t\t\t}else{\n\t\t\t\t\t\t\/\/System.out.println(\"now we are here\");\n\t\t\t\t\t\tSystem.out.println(\"7curvar:\"+curVar+\", curval:\"+curVal+\", urlTemplate:\"+urlTemplate);\n\t\t\t\t\t\tif(urlTemplate.endsWith(\"&\")||urlTemplate.endsWith(\"?\")){\n\t\t\t\t\t\t\t\/\/urlTemplate = urlTemplate.substring(0,urlTemplate.length()-1);\n\t\t\t\t\t\t\turlTemplate = urlTemplate+curVar+\"=\"+URLEncoder.encode(curVal,\"UTF-8\");\n\t\t\t\t\t\t}else{\n\t\t\t\t\t\t\turlTemplate = \"&\"+urlTemplate+curVar+\"=\"+URLEncoder.encode(curVal,\"UTF-8\");\n\t\t\t\t\t\t}\n\t\t\t\t\t\t\/\/urlTemplate = urlTemplate.replaceAll(Pattern.quote(\"[\"+curVar+\"=\"+configValue+\"&]\"), curVar+\"=\"+URLEncoder.encode(currentCell.toString(),\"UTF-8\")+\"&\");\n\t\t\t\t\t\t\/\/urlTemplate = urlTemplate.replaceAll(Pattern.quote(\"[\"+curVar+\"=\"+configValue+\"]\"), curVar+\"=\"+URLEncoder.encode(currentCell.toString(),\"UTF-8\"));\n\t\t\t\t\t\t\/\/System.out.println(\"urlTemplate before:\"+doubleStr+\",  and after:\"+urlTemplate);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\tcolCount++;\n\t\t}\n\t}\n\tSystem.out.println(\"yy:\"+urlTemplate);\n\t\/\/urlTemplate =urlTemplate.replaceAll(\"\\\\[.*?\\\\]\", \"\");\n\turlTemplate =urlTemplate.replaceAll(\"\\\\[\", \"\");\n\turlTemplate =urlTemplate.replaceAll(\"\\\\]\", \"\");\n\turlTemplate =urlTemplate.replaceAll(\"%28\", \"(\");\n\turlTemplate =urlTemplate.replaceAll(\"%29\", \")\");\n\t\/\/urlTemplate =urlTemplate.replaceAll(\"%5B\", \"[\"); \/\/strange that this is needed....API issue?\n\t\/\/urlTemplate =urlTemplate.replaceAll(\"%5D\", \"]\");\n\tSystem.out.println(\"yy:\"+urlTemplate);\n\tif(urlTemplate.endsWith(\"&\")){\n\t\turlTemplate = urlTemplate.substring(0,urlTemplate.length()-1);\n\t}\n\t\/\/urlTemplate = urlTemplate.substring(0, urlTemplate.length()-1);\n\t\/\/System.out.println(\"urlTemplate became \"+urlTemplate);\n\tcells[0] = new StringCell(urlTemplate);\n\t  DataRow row = new DefaultRow(\"aboutCell\", cells);\n        container.addRowToTable(row);\n        container.close();\n        BufferedDataTable out = container.getTable();\n    \/\/ TODO: Return a BufferedDataTable for each output port \n    return new BufferedDataTable[]{out};\n    }","code":"@Override\n    protected BufferedDataTable[] execute(final BufferedDataTable[] inData,\n            final ExecutionContext exec) throws Exception {\n    \tDataColumnSpec[] allColSpecs = new DataColumnSpec[1];\n        allColSpecs[0] = \n                new DataColumnSpecCreator(\"url\", StringCell.TYPE).createSpec();\n        DataTableSpec outputSpec = new DataTableSpec(allColSpecs);\n    \n       \n       \n       \n       \n        BufferedDataContainer container = exec.createDataContainer(outputSpec);\n        DataCell[] cells = new DataCell[1];\n\tString urlTemplate = resultUrl.getStringValue();\n\tIterator<DataRow> varIt = inData[0].iterator();\n\tDataTableSpec dts = inData[0].getDataTableSpec();\n\tString[] colNames = dts.getColumnNames();\n\tif(varIt.hasNext()){\n\n\t\tDataRow current = varIt.next();\n\t\tIterator<DataCell> cellIt = current.iterator();\n\t\tint colCount = 0;\n\t\twhile(cellIt.hasNext()){\n\t\t\tDataCell currentCell= cellIt.next();\n\t\t\tString curVar =  colNames[colCount];\n\t\t\tString curVal = currentCell.toString();\n\t\t\n\t\t\t\tif(urlTemplate.indexOf(curVar)==-1){\n\t\t\t\t\tSystem.out.println(\"1curvar:\"+curVar+\", curval:\"+curVal+\", urlTemplate:\"+urlTemplate);\n\t\t\t\t\turlTemplate = urlTemplate+\"&\"+curVar+\"=\"+URLEncoder.encode(currentCell.toString(),\"UTF-8\");\n\t\t\t\t\tSystem.out.println(\"2curvar:\"+curVar+\", curval:\"+curVal+\", urlTemplate:\"+urlTemplate);\n\t\t\t\t}else{\n\t\t\t\t\tSystem.out.println(\"3curvar:\"+curVar+\", curval:\"+curVal+\", urlTemplate:\"+urlTemplate);\n\t\t\t\t\tString configValue = \"\";\n\t\t\t\t\tif(urlTemplate.indexOf(\"&\"+curVar)!=-1){\n\t\t\t\t\t\tconfigValue = urlTemplate.substring(urlTemplate.indexOf(\"&\"+curVar)+curVar.length()+2,urlTemplate.indexOf(\"]\",urlTemplate.indexOf(curVar)));\n\t\t\t\t\t}else if(urlTemplate.indexOf(\"?\"+curVar)!=-1){\n\t\t\t\t\t\tconfigValue = urlTemplate.substring(urlTemplate.indexOf(\"?\"+curVar)+curVar.length()+2,urlTemplate.indexOf(\"]\",urlTemplate.indexOf(curVar)));\n\t\t\t\t\t}\n\t\t\t\t\tSystem.out.println(\"4curvar:\"+curVar+\", curval:\"+curVal+\", urlTemplate:\"+urlTemplate);\n\t\t\t\t\tif(configValue.endsWith(\"&\")){\n\t\t\t\t\t\tconfigValue = configValue.substring(0,configValue.length()-1);\n\t\t\t\t\t}\n\t\t\t\t\tif(colCount==0){\n\t\t\t\t\t\turlTemplate +=\"&\";\n\t\t\t\t\t}\n\t\t\t\t\tSystem.out.println(\"5curvar:\"+curVar+\", curval:\"+curVal+\", urlTemplate:\"+urlTemplate);\n\t\t\t\t\tif(!configValue.equals(\"\")){\n\t\t\t\t\t\tSystem.out.println(\"6curvar:\"+curVar+\", curval:\"+curVal+\", urlTemplate:\"+urlTemplate);\n\t\t\t\t\t\tSystem.out.println(\"config var: \"+curVar+\" with configValue:\"+ configValue+ \", is overwritten with value: \"+currentCell.toString()  );\n\t\t\t\t\t\turlTemplate = urlTemplate.replaceAll(Pattern.quote(\"[\"+curVar+\"=\"+configValue+\"&]\"), curVar+\"=\"+URLEncoder.encode(currentCell.toString(),\"UTF-8\")+\"&\");\n\t\t\t\t\t\turlTemplate = urlTemplate.replaceAll(Pattern.quote(\"[\"+curVar+\"=\"+configValue+\"]\"), curVar+\"=\"+URLEncoder.encode(currentCell.toString(),\"UTF-8\"));\n\t\t\t\t\t}else{\n\t\t\t\t\t\n\t\t\t\t\t\tSystem.out.println(\"7curvar:\"+curVar+\", curval:\"+curVal+\", urlTemplate:\"+urlTemplate);\n\t\t\t\t\t\tif(urlTemplate.endsWith(\"&\")||urlTemplate.endsWith(\"?\")){\n\t\t\t\t\t\t\n\t\t\t\t\t\t\turlTemplate = urlTemplate+curVar+\"=\"+URLEncoder.encode(curVal,\"UTF-8\");\n\t\t\t\t\t\t}else{\n\t\t\t\t\t\t\turlTemplate = \"&\"+urlTemplate+curVar+\"=\"+URLEncoder.encode(curVal,\"UTF-8\");\n\t\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\t\n\t\t\t\t\t\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\tcolCount++;\n\t\t}\n\t}\n\tSystem.out.println(\"yy:\"+urlTemplate);\n\n\turlTemplate =urlTemplate.replaceAll(\"\\\\[\", \"\");\n\turlTemplate =urlTemplate.replaceAll(\"\\\\]\", \"\");\n\turlTemplate =urlTemplate.replaceAll(\"%28\", \"(\");\n\turlTemplate =urlTemplate.replaceAll(\"%29\", \")\");\n\n\n\tSystem.out.println(\"yy:\"+urlTemplate);\n\tif(urlTemplate.endsWith(\"&\")){\n\t\turlTemplate = urlTemplate.substring(0,urlTemplate.length()-1);\n\t}\n\n\n\tcells[0] = new StringCell(urlTemplate);\n\t  DataRow row = new DefaultRow(\"aboutCell\", cells);\n        container.addRowToTable(row);\n        container.close();\n        BufferedDataTable out = container.getTable();\n   \n    return new BufferedDataTable[]{out};\n    }","cleancode":"@override protected buffereddatatable[] execute(final buffereddatatable[] indata, final executioncontext exec) throws exception { datacolumnspec[] allcolspecs = new datacolumnspec[1]; allcolspecs[0] = new datacolumnspeccreator(\"url\", stringcell.type).createspec(); datatablespec outputspec = new datatablespec(allcolspecs); buffereddatacontainer container = exec.createdatacontainer(outputspec); datacell[] cells = new datacell[1]; string urltemplate = resulturl.getstringvalue(); iterator<datarow> varit = indata[0].iterator(); datatablespec dts = indata[0].getdatatablespec(); string[] colnames = dts.getcolumnnames(); if(varit.hasnext()){ datarow current = varit.next(); iterator<datacell> cellit = current.iterator(); int colcount = 0; while(cellit.hasnext()){ datacell currentcell= cellit.next(); string curvar = colnames[colcount]; string curval = currentcell.tostring(); if(urltemplate.indexof(curvar)==-1){ system.out.println(\"1curvar:\"+curvar+\", curval:\"+curval+\", urltemplate:\"+urltemplate); urltemplate = urltemplate+\"&\"+curvar+\"=\"+urlencoder.encode(currentcell.tostring(),\"utf-8\"); system.out.println(\"2curvar:\"+curvar+\", curval:\"+curval+\", urltemplate:\"+urltemplate); }else{ system.out.println(\"3curvar:\"+curvar+\", curval:\"+curval+\", urltemplate:\"+urltemplate); string configvalue = \"\"; if(urltemplate.indexof(\"&\"+curvar)!=-1){ configvalue = urltemplate.substring(urltemplate.indexof(\"&\"+curvar)+curvar.length()+2,urltemplate.indexof(\"]\",urltemplate.indexof(curvar))); }else if(urltemplate.indexof(\"?\"+curvar)!=-1){ configvalue = urltemplate.substring(urltemplate.indexof(\"?\"+curvar)+curvar.length()+2,urltemplate.indexof(\"]\",urltemplate.indexof(curvar))); } system.out.println(\"4curvar:\"+curvar+\", curval:\"+curval+\", urltemplate:\"+urltemplate); if(configvalue.endswith(\"&\")){ configvalue = configvalue.substring(0,configvalue.length()-1); } if(colcount==0){ urltemplate +=\"&\"; } system.out.println(\"5curvar:\"+curvar+\", curval:\"+curval+\", urltemplate:\"+urltemplate); if(!configvalue.equals(\"\")){ system.out.println(\"6curvar:\"+curvar+\", curval:\"+curval+\", urltemplate:\"+urltemplate); system.out.println(\"config var: \"+curvar+\" with configvalue:\"+ configvalue+ \", is overwritten with value: \"+currentcell.tostring() ); urltemplate = urltemplate.replaceall(pattern.quote(\"[\"+curvar+\"=\"+configvalue+\"&]\"), curvar+\"=\"+urlencoder.encode(currentcell.tostring(),\"utf-8\")+\"&\"); urltemplate = urltemplate.replaceall(pattern.quote(\"[\"+curvar+\"=\"+configvalue+\"]\"), curvar+\"=\"+urlencoder.encode(currentcell.tostring(),\"utf-8\")); }else{ system.out.println(\"7curvar:\"+curvar+\", curval:\"+curval+\", urltemplate:\"+urltemplate); if(urltemplate.endswith(\"&\")||urltemplate.endswith(\"?\")){ urltemplate = urltemplate+curvar+\"=\"+urlencoder.encode(curval,\"utf-8\"); }else{ urltemplate = \"&\"+urltemplate+curvar+\"=\"+urlencoder.encode(curval,\"utf-8\"); } } } colcount++; } } system.out.println(\"yy:\"+urltemplate); urltemplate =urltemplate.replaceall(\"\\\\[\", \"\"); urltemplate =urltemplate.replaceall(\"\\\\]\", \"\"); urltemplate =urltemplate.replaceall(\"%28\", \"(\"); urltemplate =urltemplate.replaceall(\"%29\", \")\"); system.out.println(\"yy:\"+urltemplate); if(urltemplate.endswith(\"&\")){ urltemplate = urltemplate.substring(0,urltemplate.length()-1); } cells[0] = new stringcell(urltemplate); datarow row = new defaultrow(\"aboutcell\", cells); container.addrowtotable(row); container.close(); buffereddatatable out = container.gettable(); return new buffereddatatable[]{out}; }","comment":"\/** * {@inheritdoc} *\/\n\/\/ system.out.println(\"calling execute\"+resulturl.getstringvalue()); \/\/ the execution context will provide us with storage capacity, in this \/\/ case a data container to which we will add rows sequentially \/\/ note, this container can also handle arbitrary big data tables, it \/\/ will buffer to disc if necessary.\n\/\/while(varit.hasnext()){\n\/\/system.out.println(\"curvar:\"+curvar+\", curval:\"+curval+\", urltemplate:\"+urltemplate);\n\/\/get rid of the &\n\/\/system.out.println(\"now we are here\");\n\/\/urltemplate = urltemplate.substring(0,urltemplate.length()-1);\n\/\/urltemplate = urltemplate.replaceall(pattern.quote(\"[\"+curvar+\"=\"+configvalue+\"&]\"), curvar+\"=\"+urlencoder.encode(currentcell.tostring(),\"utf-8\")+\"&\"); \/\/urltemplate = urltemplate.replaceall(pattern.quote(\"[\"+curvar+\"=\"+configvalue+\"]\"), curvar+\"=\"+urlencoder.encode(currentcell.tostring(),\"utf-8\")); \/\/system.out.println(\"urltemplate before:\"+doublestr+\", and after:\"+urltemplate);\n\/\/urltemplate =urltemplate.replaceall(\"\\\\[.*?\\\\]\", \"\");\n\/\/urltemplate =urltemplate.replaceall(\"%5b\", \"[\"); \/\/strange that this is needed....api issue? \/\/urltemplate =urltemplate.replaceall(\"%5d\", \"]\");\n\/\/urltemplate = urltemplate.substring(0, urltemplate.length()-1); \/\/system.out.println(\"urltemplate became \"+urltemplate);\n\/\/ todo: return a buffereddatatable for each output port","repo":"openphacts\/OPS-Knime","code_context_2":"@Override\nprotected BufferedDataTable[] execute(final BufferedDataTable[] inData,\nfinal ExecutionContext exec) throws Exception {\nDataColumnSpec[] allColSpecs = new DataColumnSpec[1];\nallColSpecs[0] =\nnew DataColumnSpecCreator(\"url\", StringCell.TYPE).createSpec();\nDataTableSpec outputSpec = new DataTableSpec(allColSpecs);\n\/\/ System.out.println(\"calling execute\"+resultUrl.getStringValue());\n\/\/ the execution context will provide us with storage capacity, in this\n\/\/ case a data container to which we will add rows sequentially\n\/\/ Note, this container can also handle arbitrary big data tables, it\n\/\/ will buffer to disc if necessary.\nBufferedDataContainer container = exec.createDataContainer(outputSpec);\nDataCell[] cells = new DataCell[1];\nString urlTemplate = resultUrl.getStringValue();\nIterator<DataRow> varIt = inData[0].iterator();\nDataTableSpec dts = inData[0].getDataTableSpec();\nString[] colNames = dts.getColumnNames();\nif(varIt.hasNext()){\n\/\/while(varIt.hasNext()){\nDataRow current = varIt.next();\nIterator<DataCell> cellIt = current.iterator();\nint colCount = 0;\nwhile(cellIt.hasNext()){\nDataCell currentCell= cellIt.next();\nString curVar = colNames[colCount];\nString curVal = currentCell.toString();\n\/\/System.out.println(\"curvar:\"+curVar+\", curval:\"+curVal+\", urlTemplate:\"+urlTemplate);\nif(urlTemplate.indexOf(curVar)==-1){\nSystem.out.println(\"1curvar:\"+curVar+\", curval:\"+curVal+\", urlTemplate:\"+urlTemplate);\nurlTemplate = urlTemplate+\"&\"+curVar+\"=\"+URLEncoder.encode(currentCell.toString(),\"UTF-8\");\nSystem.out.println(\"2curvar:\"+curVar+\", curval:\"+curVal+\", urlTemplate:\"+urlTemplate);\n}else{\nSystem.out.println(\"3curvar:\"+curVar+\", curval:\"+curVal+\", urlTemplate:\"+urlTemplate);\nString configValue = \"\";\nif(urlTemplate.indexOf(\"&\"+curVar)!=-1){\nconfigValue = urlTemplate.substring(urlTemplate.indexOf(\"&\"+curVar)+curVar.length()+2,urlTemplate.indexOf(\"]\",urlTemplate.indexOf(curVar)));\n}else if(urlTemplate.indexOf(\"?\"+curVar)!=-1){\nconfigValue = urlTemplate.substring(urlTemplate.indexOf(\"?\"+curVar)+curVar.length()+2,urlTemplate.indexOf(\"]\",urlTemplate.indexOf(curVar)));\n}\nSystem.out.println(\"4curvar:\"+curVar+\", curval:\"+curVal+\", urlTemplate:\"+urlTemplate);\nif(configValue.endsWith(\"&\")){\nconfigValue = configValue.substring(0,configValue.length()-1); \/\/get rid of the &\n}\nif(colCount==0){\nurlTemplate +=\"&\";\n}\nSystem.out.println(\"5curvar:\"+curVar+\", curval:\"+curVal+\", urlTemplate:\"+urlTemplate);\nif(!configValue.equals(\"\")){\nSystem.out.println(\"6curvar:\"+curVar+\", curval:\"+curVal+\", urlTemplate:\"+urlTemplate);\nSystem.out.println(\"config var: \"+curVar+\" with configValue:\"+ configValue+ \", is overwritten with value: \"+currentCell.toString() );\nurlTemplate = urlTemplate.replaceAll(Pattern.quote(\"[\"+curVar+\"=\"+configValue+\"&]\"), curVar+\"=\"+URLEncoder.encode(currentCell.toString(),\"UTF-8\")+\"&\");\nurlTemplate = urlTemplate.replaceAll(Pattern.quote(\"[\"+curVar+\"=\"+configValue+\"]\"), curVar+\"=\"+URLEncoder.encode(currentCell.toString(),\"UTF-8\"));\n}else{\n\/\/System.out.println(\"now we are here\");\nSystem.out.println(\"7curvar:\"+curVar+\", curval:\"+curVal+\", urlTemplate:\"+urlTemplate);\nif(urlTemplate.endsWith(\"&\")||urlTemplate.endsWith(\"?\")){\n\/\/urlTemplate = urlTemplate.substring(0,urlTemplate.length()-1);\nurlTemplate = urlTemplate+curVar+\"=\"+URLEncoder.encode(curVal,\"UTF-8\");\n}else{\nurlTemplate = \"&\"+urlTemplate+curVar+\"=\"+URLEncoder.encode(curVal,\"UTF-8\");\n}\n\/\/urlTemplate = urlTemplate.replaceAll(Pattern.quote(\"[\"+curVar+\"=\"+configValue+\"&]\"), curVar+\"=\"+URLEncoder.encode(currentCell.toString(),\"UTF-8\")+\"&\");\n\/\/urlTemplate = urlTemplate.replaceAll(Pattern.quote(\"[\"+curVar+\"=\"+configValue+\"]\"), curVar+\"=\"+URLEncoder.encode(currentCell.toString(),\"UTF-8\"));\n\/\/System.out.println(\"urlTemplate before:\"+doubleStr+\", and after:\"+urlTemplate);\n}\n}\ncolCount++;\n}\n}\nSystem.out.println(\"yy:\"+urlTemplate);\n\/\/urlTemplate =urlTemplate.replaceAll(\"\\\\[.*?\\\\]\", \"\");\nurlTemplate =urlTemplate.replaceAll(\"\\\\[\", \"\");\nurlTemplate =urlTemplate.replaceAll(\"\\\\]\", \"\");\nurlTemplate =urlTemplate.replaceAll(\"%28\", \"(\");\nurlTemplate =urlTemplate.replaceAll(\"%29\", \")\");\n\/\/urlTemplate =urlTemplate.replaceAll(\"%5B\", \"[\"); \/\/strange that this is needed....API issue?\n\/\/urlTemplate =urlTemplate.replaceAll(\"%5D\", \"]\");\nSystem.out.println(\"yy:\"+urlTemplate);\nif(urlTemplate.endsWith(\"&\")){\nurlTemplate = urlTemplate.substring(0,urlTemplate.length()-1);\n}\n\/\/urlTemplate = urlTemplate.substring(0, urlTemplate.length()-1);\n\/\/System.out.println(\"urlTemplate became \"+urlTemplate);\ncells[0] = new StringCell(urlTemplate);\nDataRow row = new DefaultRow(\"aboutCell\", cells);\ncontainer.addRowToTable(row);\ncontainer.close();\nBufferedDataTable out = container.getTable();\n\/\/ TODO: Return a BufferedDataTable for each output port\nreturn new BufferedDataTable[]{out};\n}\n\nnew DataColumnSpecCreator(\"url\", StringCell.TYPE).createSpec();\nDataTableSpec outputSpec = new DataTableSpec(allColSpecs);\n\/\/ System.out.println(\"calling execute\"+resultUrl.getStringValue());\n\/\/ the execution context will provide us with storage capacity, in this\n\/\/ case a data container to which we will add rows sequentially\n\/\/ Note, this container can also handle arbitrary big data tables, it\n\/\/ will buffer to disc if necessary.\nBufferedDataContainer container = exec.createDataContainer(outputSpec);\nDataCell[] cells = new DataCell[1];\n\nString[] colNames = dts.getColumnNames();\nif(varIt.hasNext()){\n\/\/while(varIt.hasNext()){\nDataRow current = varIt.next();\nIterator<DataCell> cellIt = current.iterator();\n\nString curVar = colNames[colCount];\nString curVal = currentCell.toString();\n\/\/System.out.println(\"curvar:\"+curVar+\", curval:\"+curVal+\", urlTemplate:\"+urlTemplate);\nif(urlTemplate.indexOf(curVar)==-1){\nSystem.out.println(\"1curvar:\"+curVar+\", curval:\"+curVal+\", urlTemplate:\"+urlTemplate);\n\nSystem.out.println(\"4curvar:\"+curVar+\", curval:\"+curVal+\", urlTemplate:\"+urlTemplate);\nif(configValue.endsWith(\"&\")){\nconfigValue = configValue.substring(0,configValue.length()-1); \/\/get rid of the &\n}\nif(colCount==0){\n\nurlTemplate = urlTemplate.replaceAll(Pattern.quote(\"[\"+curVar+\"=\"+configValue+\"]\"), curVar+\"=\"+URLEncoder.encode(currentCell.toString(),\"UTF-8\"));\n}else{\n\/\/System.out.println(\"now we are here\");\nSystem.out.println(\"7curvar:\"+curVar+\", curval:\"+curVal+\", urlTemplate:\"+urlTemplate);\nif(urlTemplate.endsWith(\"&\")||urlTemplate.endsWith(\"?\")){\n\nSystem.out.println(\"7curvar:\"+curVar+\", curval:\"+curVal+\", urlTemplate:\"+urlTemplate);\nif(urlTemplate.endsWith(\"&\")||urlTemplate.endsWith(\"?\")){\n\/\/urlTemplate = urlTemplate.substring(0,urlTemplate.length()-1);\nurlTemplate = urlTemplate+curVar+\"=\"+URLEncoder.encode(curVal,\"UTF-8\");\n}else{\n\nurlTemplate = \"&\"+urlTemplate+curVar+\"=\"+URLEncoder.encode(curVal,\"UTF-8\");\n}\n\/\/urlTemplate = urlTemplate.replaceAll(Pattern.quote(\"[\"+curVar+\"=\"+configValue+\"&]\"), curVar+\"=\"+URLEncoder.encode(currentCell.toString(),\"UTF-8\")+\"&\");\n\/\/urlTemplate = urlTemplate.replaceAll(Pattern.quote(\"[\"+curVar+\"=\"+configValue+\"]\"), curVar+\"=\"+URLEncoder.encode(currentCell.toString(),\"UTF-8\"));\n\/\/System.out.println(\"urlTemplate before:\"+doubleStr+\", and after:\"+urlTemplate);\n}\n}\n\n}\nSystem.out.println(\"yy:\"+urlTemplate);\n\/\/urlTemplate =urlTemplate.replaceAll(\"\\\\[.*?\\\\]\", \"\");\nurlTemplate =urlTemplate.replaceAll(\"\\\\[\", \"\");\nurlTemplate =urlTemplate.replaceAll(\"\\\\]\", \"\");\n\nurlTemplate =urlTemplate.replaceAll(\"%28\", \"(\");\nurlTemplate =urlTemplate.replaceAll(\"%29\", \")\");\n\/\/urlTemplate =urlTemplate.replaceAll(\"%5B\", \"[\"); \/\/strange that this is needed....API issue?\n\/\/urlTemplate =urlTemplate.replaceAll(\"%5D\", \"]\");\nSystem.out.println(\"yy:\"+urlTemplate);\nif(urlTemplate.endsWith(\"&\")){\n\nurlTemplate = urlTemplate.substring(0,urlTemplate.length()-1);\n}\n\/\/urlTemplate = urlTemplate.substring(0, urlTemplate.length()-1);\n\/\/System.out.println(\"urlTemplate became \"+urlTemplate);\ncells[0] = new StringCell(urlTemplate);\nDataRow row = new DefaultRow(\"aboutCell\", cells);\n\ncontainer.close();\nBufferedDataTable out = container.getTable();\n\/\/ TODO: Return a BufferedDataTable for each output port\nreturn new BufferedDataTable[]{out};\n}","code_context_10":"@Override\nprotected BufferedDataTable[] execute(final BufferedDataTable[] inData,\nfinal ExecutionContext exec) throws Exception {\nDataColumnSpec[] allColSpecs = new DataColumnSpec[1];\nallColSpecs[0] =\nnew DataColumnSpecCreator(\"url\", StringCell.TYPE).createSpec();\nDataTableSpec outputSpec = new DataTableSpec(allColSpecs);\n\/\/ System.out.println(\"calling execute\"+resultUrl.getStringValue());\n\/\/ the execution context will provide us with storage capacity, in this\n\/\/ case a data container to which we will add rows sequentially\n\/\/ Note, this container can also handle arbitrary big data tables, it\n\/\/ will buffer to disc if necessary.\nBufferedDataContainer container = exec.createDataContainer(outputSpec);\nDataCell[] cells = new DataCell[1];\nString urlTemplate = resultUrl.getStringValue();\nIterator<DataRow> varIt = inData[0].iterator();\nDataTableSpec dts = inData[0].getDataTableSpec();\nString[] colNames = dts.getColumnNames();\nif(varIt.hasNext()){\n\/\/while(varIt.hasNext()){\nDataRow current = varIt.next();\nIterator<DataCell> cellIt = current.iterator();\nint colCount = 0;\nwhile(cellIt.hasNext()){\nDataCell currentCell= cellIt.next();\nString curVar = colNames[colCount];\nString curVal = currentCell.toString();\n\/\/System.out.println(\"curvar:\"+curVar+\", curval:\"+curVal+\", urlTemplate:\"+urlTemplate);\nif(urlTemplate.indexOf(curVar)==-1){\nSystem.out.println(\"1curvar:\"+curVar+\", curval:\"+curVal+\", urlTemplate:\"+urlTemplate);\nurlTemplate = urlTemplate+\"&\"+curVar+\"=\"+URLEncoder.encode(currentCell.toString(),\"UTF-8\");\nSystem.out.println(\"2curvar:\"+curVar+\", curval:\"+curVal+\", urlTemplate:\"+urlTemplate);\n}else{\nSystem.out.println(\"3curvar:\"+curVar+\", curval:\"+curVal+\", urlTemplate:\"+urlTemplate);\nString configValue = \"\";\nif(urlTemplate.indexOf(\"&\"+curVar)!=-1){\nconfigValue = urlTemplate.substring(urlTemplate.indexOf(\"&\"+curVar)+curVar.length()+2,urlTemplate.indexOf(\"]\",urlTemplate.indexOf(curVar)));\n}else if(urlTemplate.indexOf(\"?\"+curVar)!=-1){\nconfigValue = urlTemplate.substring(urlTemplate.indexOf(\"?\"+curVar)+curVar.length()+2,urlTemplate.indexOf(\"]\",urlTemplate.indexOf(curVar)));\n}\nSystem.out.println(\"4curvar:\"+curVar+\", curval:\"+curVal+\", urlTemplate:\"+urlTemplate);\nif(configValue.endsWith(\"&\")){\nconfigValue = configValue.substring(0,configValue.length()-1); \/\/get rid of the &\n}\nif(colCount==0){\nurlTemplate +=\"&\";\n}\nSystem.out.println(\"5curvar:\"+curVar+\", curval:\"+curVal+\", urlTemplate:\"+urlTemplate);\nif(!configValue.equals(\"\")){\nSystem.out.println(\"6curvar:\"+curVar+\", curval:\"+curVal+\", urlTemplate:\"+urlTemplate);\nSystem.out.println(\"config var: \"+curVar+\" with configValue:\"+ configValue+ \", is overwritten with value: \"+currentCell.toString() );\nurlTemplate = urlTemplate.replaceAll(Pattern.quote(\"[\"+curVar+\"=\"+configValue+\"&]\"), curVar+\"=\"+URLEncoder.encode(currentCell.toString(),\"UTF-8\")+\"&\");\nurlTemplate = urlTemplate.replaceAll(Pattern.quote(\"[\"+curVar+\"=\"+configValue+\"]\"), curVar+\"=\"+URLEncoder.encode(currentCell.toString(),\"UTF-8\"));\n}else{\n\/\/System.out.println(\"now we are here\");\nSystem.out.println(\"7curvar:\"+curVar+\", curval:\"+curVal+\", urlTemplate:\"+urlTemplate);\nif(urlTemplate.endsWith(\"&\")||urlTemplate.endsWith(\"?\")){\n\/\/urlTemplate = urlTemplate.substring(0,urlTemplate.length()-1);\nurlTemplate = urlTemplate+curVar+\"=\"+URLEncoder.encode(curVal,\"UTF-8\");\n}else{\nurlTemplate = \"&\"+urlTemplate+curVar+\"=\"+URLEncoder.encode(curVal,\"UTF-8\");\n}\n\/\/urlTemplate = urlTemplate.replaceAll(Pattern.quote(\"[\"+curVar+\"=\"+configValue+\"&]\"), curVar+\"=\"+URLEncoder.encode(currentCell.toString(),\"UTF-8\")+\"&\");\n\/\/urlTemplate = urlTemplate.replaceAll(Pattern.quote(\"[\"+curVar+\"=\"+configValue+\"]\"), curVar+\"=\"+URLEncoder.encode(currentCell.toString(),\"UTF-8\"));\n\/\/System.out.println(\"urlTemplate before:\"+doubleStr+\", and after:\"+urlTemplate);\n}\n}\ncolCount++;\n}\n}\nSystem.out.println(\"yy:\"+urlTemplate);\n\/\/urlTemplate =urlTemplate.replaceAll(\"\\\\[.*?\\\\]\", \"\");\nurlTemplate =urlTemplate.replaceAll(\"\\\\[\", \"\");\nurlTemplate =urlTemplate.replaceAll(\"\\\\]\", \"\");\nurlTemplate =urlTemplate.replaceAll(\"%28\", \"(\");\nurlTemplate =urlTemplate.replaceAll(\"%29\", \")\");\n\/\/urlTemplate =urlTemplate.replaceAll(\"%5B\", \"[\"); \/\/strange that this is needed....API issue?\n\/\/urlTemplate =urlTemplate.replaceAll(\"%5D\", \"]\");\nSystem.out.println(\"yy:\"+urlTemplate);\nif(urlTemplate.endsWith(\"&\")){\nurlTemplate = urlTemplate.substring(0,urlTemplate.length()-1);\n}\n\/\/urlTemplate = urlTemplate.substring(0, urlTemplate.length()-1);\n\/\/System.out.println(\"urlTemplate became \"+urlTemplate);\ncells[0] = new StringCell(urlTemplate);\nDataRow row = new DefaultRow(\"aboutCell\", cells);\ncontainer.addRowToTable(row);\ncontainer.close();\nBufferedDataTable out = container.getTable();\n\/\/ TODO: Return a BufferedDataTable for each output port\nreturn new BufferedDataTable[]{out};\n}\n\n@Override\nprotected BufferedDataTable[] execute(final BufferedDataTable[] inData,\nfinal ExecutionContext exec) throws Exception {\nDataColumnSpec[] allColSpecs = new DataColumnSpec[1];\nallColSpecs[0] =\nnew DataColumnSpecCreator(\"url\", StringCell.TYPE).createSpec();\nDataTableSpec outputSpec = new DataTableSpec(allColSpecs);\n\/\/ System.out.println(\"calling execute\"+resultUrl.getStringValue());\n\/\/ the execution context will provide us with storage capacity, in this\n\/\/ case a data container to which we will add rows sequentially\n\/\/ Note, this container can also handle arbitrary big data tables, it\n\/\/ will buffer to disc if necessary.\nBufferedDataContainer container = exec.createDataContainer(outputSpec);\nDataCell[] cells = new DataCell[1];\nString urlTemplate = resultUrl.getStringValue();\nIterator<DataRow> varIt = inData[0].iterator();\nDataTableSpec dts = inData[0].getDataTableSpec();\nString[] colNames = dts.getColumnNames();\nif(varIt.hasNext()){\n\/\/while(varIt.hasNext()){\nDataRow current = varIt.next();\nIterator<DataCell> cellIt = current.iterator();\n\n\/\/ case a data container to which we will add rows sequentially\n\/\/ Note, this container can also handle arbitrary big data tables, it\n\/\/ will buffer to disc if necessary.\nBufferedDataContainer container = exec.createDataContainer(outputSpec);\nDataCell[] cells = new DataCell[1];\nString urlTemplate = resultUrl.getStringValue();\nIterator<DataRow> varIt = inData[0].iterator();\nDataTableSpec dts = inData[0].getDataTableSpec();\nString[] colNames = dts.getColumnNames();\nif(varIt.hasNext()){\n\/\/while(varIt.hasNext()){\nDataRow current = varIt.next();\nIterator<DataCell> cellIt = current.iterator();\nint colCount = 0;\nwhile(cellIt.hasNext()){\nDataCell currentCell= cellIt.next();\nString curVar = colNames[colCount];\nString curVal = currentCell.toString();\n\/\/System.out.println(\"curvar:\"+curVar+\", curval:\"+curVal+\", urlTemplate:\"+urlTemplate);\nif(urlTemplate.indexOf(curVar)==-1){\nSystem.out.println(\"1curvar:\"+curVar+\", curval:\"+curVal+\", urlTemplate:\"+urlTemplate);\n\nString[] colNames = dts.getColumnNames();\nif(varIt.hasNext()){\n\/\/while(varIt.hasNext()){\nDataRow current = varIt.next();\nIterator<DataCell> cellIt = current.iterator();\nint colCount = 0;\nwhile(cellIt.hasNext()){\nDataCell currentCell= cellIt.next();\nString curVar = colNames[colCount];\nString curVal = currentCell.toString();\n\/\/System.out.println(\"curvar:\"+curVar+\", curval:\"+curVal+\", urlTemplate:\"+urlTemplate);\nif(urlTemplate.indexOf(curVar)==-1){\nSystem.out.println(\"1curvar:\"+curVar+\", curval:\"+curVal+\", urlTemplate:\"+urlTemplate);\nurlTemplate = urlTemplate+\"&\"+curVar+\"=\"+URLEncoder.encode(currentCell.toString(),\"UTF-8\");\nSystem.out.println(\"2curvar:\"+curVar+\", curval:\"+curVal+\", urlTemplate:\"+urlTemplate);\n}else{\nSystem.out.println(\"3curvar:\"+curVar+\", curval:\"+curVal+\", urlTemplate:\"+urlTemplate);\nString configValue = \"\";\nif(urlTemplate.indexOf(\"&\"+curVar)!=-1){\nconfigValue = urlTemplate.substring(urlTemplate.indexOf(\"&\"+curVar)+curVar.length()+2,urlTemplate.indexOf(\"]\",urlTemplate.indexOf(curVar)));\n}else if(urlTemplate.indexOf(\"?\"+curVar)!=-1){\n\n}else{\nSystem.out.println(\"3curvar:\"+curVar+\", curval:\"+curVal+\", urlTemplate:\"+urlTemplate);\nString configValue = \"\";\nif(urlTemplate.indexOf(\"&\"+curVar)!=-1){\nconfigValue = urlTemplate.substring(urlTemplate.indexOf(\"&\"+curVar)+curVar.length()+2,urlTemplate.indexOf(\"]\",urlTemplate.indexOf(curVar)));\n}else if(urlTemplate.indexOf(\"?\"+curVar)!=-1){\nconfigValue = urlTemplate.substring(urlTemplate.indexOf(\"?\"+curVar)+curVar.length()+2,urlTemplate.indexOf(\"]\",urlTemplate.indexOf(curVar)));\n}\nSystem.out.println(\"4curvar:\"+curVar+\", curval:\"+curVal+\", urlTemplate:\"+urlTemplate);\nif(configValue.endsWith(\"&\")){\nconfigValue = configValue.substring(0,configValue.length()-1); \/\/get rid of the &\n}\nif(colCount==0){\nurlTemplate +=\"&\";\n}\nSystem.out.println(\"5curvar:\"+curVar+\", curval:\"+curVal+\", urlTemplate:\"+urlTemplate);\nif(!configValue.equals(\"\")){\nSystem.out.println(\"6curvar:\"+curVar+\", curval:\"+curVal+\", urlTemplate:\"+urlTemplate);\nSystem.out.println(\"config var: \"+curVar+\" with configValue:\"+ configValue+ \", is overwritten with value: \"+currentCell.toString() );\nurlTemplate = urlTemplate.replaceAll(Pattern.quote(\"[\"+curVar+\"=\"+configValue+\"&]\"), curVar+\"=\"+URLEncoder.encode(currentCell.toString(),\"UTF-8\")+\"&\");\nurlTemplate = urlTemplate.replaceAll(Pattern.quote(\"[\"+curVar+\"=\"+configValue+\"]\"), curVar+\"=\"+URLEncoder.encode(currentCell.toString(),\"UTF-8\"));\n\nif(colCount==0){\nurlTemplate +=\"&\";\n}\nSystem.out.println(\"5curvar:\"+curVar+\", curval:\"+curVal+\", urlTemplate:\"+urlTemplate);\nif(!configValue.equals(\"\")){\nSystem.out.println(\"6curvar:\"+curVar+\", curval:\"+curVal+\", urlTemplate:\"+urlTemplate);\nSystem.out.println(\"config var: \"+curVar+\" with configValue:\"+ configValue+ \", is overwritten with value: \"+currentCell.toString() );\nurlTemplate = urlTemplate.replaceAll(Pattern.quote(\"[\"+curVar+\"=\"+configValue+\"&]\"), curVar+\"=\"+URLEncoder.encode(currentCell.toString(),\"UTF-8\")+\"&\");\nurlTemplate = urlTemplate.replaceAll(Pattern.quote(\"[\"+curVar+\"=\"+configValue+\"]\"), curVar+\"=\"+URLEncoder.encode(currentCell.toString(),\"UTF-8\"));\n}else{\n\/\/System.out.println(\"now we are here\");\nSystem.out.println(\"7curvar:\"+curVar+\", curval:\"+curVal+\", urlTemplate:\"+urlTemplate);\nif(urlTemplate.endsWith(\"&\")||urlTemplate.endsWith(\"?\")){\n\/\/urlTemplate = urlTemplate.substring(0,urlTemplate.length()-1);\nurlTemplate = urlTemplate+curVar+\"=\"+URLEncoder.encode(curVal,\"UTF-8\");\n}else{\nurlTemplate = \"&\"+urlTemplate+curVar+\"=\"+URLEncoder.encode(curVal,\"UTF-8\");\n}\n\/\/urlTemplate = urlTemplate.replaceAll(Pattern.quote(\"[\"+curVar+\"=\"+configValue+\"&]\"), curVar+\"=\"+URLEncoder.encode(currentCell.toString(),\"UTF-8\")+\"&\");\n\/\/urlTemplate = urlTemplate.replaceAll(Pattern.quote(\"[\"+curVar+\"=\"+configValue+\"]\"), curVar+\"=\"+URLEncoder.encode(currentCell.toString(),\"UTF-8\"));\n\/\/System.out.println(\"urlTemplate before:\"+doubleStr+\", and after:\"+urlTemplate);\n\nSystem.out.println(\"5curvar:\"+curVar+\", curval:\"+curVal+\", urlTemplate:\"+urlTemplate);\nif(!configValue.equals(\"\")){\nSystem.out.println(\"6curvar:\"+curVar+\", curval:\"+curVal+\", urlTemplate:\"+urlTemplate);\nSystem.out.println(\"config var: \"+curVar+\" with configValue:\"+ configValue+ \", is overwritten with value: \"+currentCell.toString() );\nurlTemplate = urlTemplate.replaceAll(Pattern.quote(\"[\"+curVar+\"=\"+configValue+\"&]\"), curVar+\"=\"+URLEncoder.encode(currentCell.toString(),\"UTF-8\")+\"&\");\nurlTemplate = urlTemplate.replaceAll(Pattern.quote(\"[\"+curVar+\"=\"+configValue+\"]\"), curVar+\"=\"+URLEncoder.encode(currentCell.toString(),\"UTF-8\"));\n}else{\n\/\/System.out.println(\"now we are here\");\nSystem.out.println(\"7curvar:\"+curVar+\", curval:\"+curVal+\", urlTemplate:\"+urlTemplate);\nif(urlTemplate.endsWith(\"&\")||urlTemplate.endsWith(\"?\")){\n\/\/urlTemplate = urlTemplate.substring(0,urlTemplate.length()-1);\nurlTemplate = urlTemplate+curVar+\"=\"+URLEncoder.encode(curVal,\"UTF-8\");\n}else{\nurlTemplate = \"&\"+urlTemplate+curVar+\"=\"+URLEncoder.encode(curVal,\"UTF-8\");\n}\n\/\/urlTemplate = urlTemplate.replaceAll(Pattern.quote(\"[\"+curVar+\"=\"+configValue+\"&]\"), curVar+\"=\"+URLEncoder.encode(currentCell.toString(),\"UTF-8\")+\"&\");\n\/\/urlTemplate = urlTemplate.replaceAll(Pattern.quote(\"[\"+curVar+\"=\"+configValue+\"]\"), curVar+\"=\"+URLEncoder.encode(currentCell.toString(),\"UTF-8\"));\n\/\/System.out.println(\"urlTemplate before:\"+doubleStr+\", and after:\"+urlTemplate);\n}\n}\ncolCount++;\n\nurlTemplate = urlTemplate.replaceAll(Pattern.quote(\"[\"+curVar+\"=\"+configValue+\"]\"), curVar+\"=\"+URLEncoder.encode(currentCell.toString(),\"UTF-8\"));\n}else{\n\/\/System.out.println(\"now we are here\");\nSystem.out.println(\"7curvar:\"+curVar+\", curval:\"+curVal+\", urlTemplate:\"+urlTemplate);\nif(urlTemplate.endsWith(\"&\")||urlTemplate.endsWith(\"?\")){\n\/\/urlTemplate = urlTemplate.substring(0,urlTemplate.length()-1);\nurlTemplate = urlTemplate+curVar+\"=\"+URLEncoder.encode(curVal,\"UTF-8\");\n}else{\nurlTemplate = \"&\"+urlTemplate+curVar+\"=\"+URLEncoder.encode(curVal,\"UTF-8\");\n}\n\/\/urlTemplate = urlTemplate.replaceAll(Pattern.quote(\"[\"+curVar+\"=\"+configValue+\"&]\"), curVar+\"=\"+URLEncoder.encode(currentCell.toString(),\"UTF-8\")+\"&\");\n\/\/urlTemplate = urlTemplate.replaceAll(Pattern.quote(\"[\"+curVar+\"=\"+configValue+\"]\"), curVar+\"=\"+URLEncoder.encode(currentCell.toString(),\"UTF-8\"));\n\/\/System.out.println(\"urlTemplate before:\"+doubleStr+\", and after:\"+urlTemplate);\n}\n}\ncolCount++;\n}\n}\nSystem.out.println(\"yy:\"+urlTemplate);\n\/\/urlTemplate =urlTemplate.replaceAll(\"\\\\[.*?\\\\]\", \"\");\nurlTemplate =urlTemplate.replaceAll(\"\\\\[\", \"\");\nurlTemplate =urlTemplate.replaceAll(\"\\\\]\", \"\");\nurlTemplate =urlTemplate.replaceAll(\"%28\", \"(\");\n\n}\n\/\/urlTemplate = urlTemplate.replaceAll(Pattern.quote(\"[\"+curVar+\"=\"+configValue+\"&]\"), curVar+\"=\"+URLEncoder.encode(currentCell.toString(),\"UTF-8\")+\"&\");\n\/\/urlTemplate = urlTemplate.replaceAll(Pattern.quote(\"[\"+curVar+\"=\"+configValue+\"]\"), curVar+\"=\"+URLEncoder.encode(currentCell.toString(),\"UTF-8\"));\n\/\/System.out.println(\"urlTemplate before:\"+doubleStr+\", and after:\"+urlTemplate);\n}\n}\ncolCount++;\n}\n}\nSystem.out.println(\"yy:\"+urlTemplate);\n\/\/urlTemplate =urlTemplate.replaceAll(\"\\\\[.*?\\\\]\", \"\");\nurlTemplate =urlTemplate.replaceAll(\"\\\\[\", \"\");\nurlTemplate =urlTemplate.replaceAll(\"\\\\]\", \"\");\nurlTemplate =urlTemplate.replaceAll(\"%28\", \"(\");\nurlTemplate =urlTemplate.replaceAll(\"%29\", \")\");\n\/\/urlTemplate =urlTemplate.replaceAll(\"%5B\", \"[\"); \/\/strange that this is needed....API issue?\n\/\/urlTemplate =urlTemplate.replaceAll(\"%5D\", \"]\");\nSystem.out.println(\"yy:\"+urlTemplate);\nif(urlTemplate.endsWith(\"&\")){\nurlTemplate = urlTemplate.substring(0,urlTemplate.length()-1);\n}\n\n}\ncolCount++;\n}\n}\nSystem.out.println(\"yy:\"+urlTemplate);\n\/\/urlTemplate =urlTemplate.replaceAll(\"\\\\[.*?\\\\]\", \"\");\nurlTemplate =urlTemplate.replaceAll(\"\\\\[\", \"\");\nurlTemplate =urlTemplate.replaceAll(\"\\\\]\", \"\");\nurlTemplate =urlTemplate.replaceAll(\"%28\", \"(\");\nurlTemplate =urlTemplate.replaceAll(\"%29\", \")\");\n\/\/urlTemplate =urlTemplate.replaceAll(\"%5B\", \"[\"); \/\/strange that this is needed....API issue?\n\/\/urlTemplate =urlTemplate.replaceAll(\"%5D\", \"]\");\nSystem.out.println(\"yy:\"+urlTemplate);\nif(urlTemplate.endsWith(\"&\")){\nurlTemplate = urlTemplate.substring(0,urlTemplate.length()-1);\n}\n\/\/urlTemplate = urlTemplate.substring(0, urlTemplate.length()-1);\n\/\/System.out.println(\"urlTemplate became \"+urlTemplate);\ncells[0] = new StringCell(urlTemplate);\nDataRow row = new DefaultRow(\"aboutCell\", cells);\ncontainer.addRowToTable(row);\ncontainer.close();\n\nurlTemplate =urlTemplate.replaceAll(\"\\\\[\", \"\");\nurlTemplate =urlTemplate.replaceAll(\"\\\\]\", \"\");\nurlTemplate =urlTemplate.replaceAll(\"%28\", \"(\");\nurlTemplate =urlTemplate.replaceAll(\"%29\", \")\");\n\/\/urlTemplate =urlTemplate.replaceAll(\"%5B\", \"[\"); \/\/strange that this is needed....API issue?\n\/\/urlTemplate =urlTemplate.replaceAll(\"%5D\", \"]\");\nSystem.out.println(\"yy:\"+urlTemplate);\nif(urlTemplate.endsWith(\"&\")){\nurlTemplate = urlTemplate.substring(0,urlTemplate.length()-1);\n}\n\/\/urlTemplate = urlTemplate.substring(0, urlTemplate.length()-1);\n\/\/System.out.println(\"urlTemplate became \"+urlTemplate);\ncells[0] = new StringCell(urlTemplate);\nDataRow row = new DefaultRow(\"aboutCell\", cells);\ncontainer.addRowToTable(row);\ncontainer.close();\nBufferedDataTable out = container.getTable();\n\/\/ TODO: Return a BufferedDataTable for each output port\nreturn new BufferedDataTable[]{out};\n}\n\nif(urlTemplate.endsWith(\"&\")){\nurlTemplate = urlTemplate.substring(0,urlTemplate.length()-1);\n}\n\/\/urlTemplate = urlTemplate.substring(0, urlTemplate.length()-1);\n\/\/System.out.println(\"urlTemplate became \"+urlTemplate);\ncells[0] = new StringCell(urlTemplate);\nDataRow row = new DefaultRow(\"aboutCell\", cells);\ncontainer.addRowToTable(row);\ncontainer.close();\nBufferedDataTable out = container.getTable();\n\/\/ TODO: Return a BufferedDataTable for each output port\nreturn new BufferedDataTable[]{out};\n}","code_context_20":"@Override\nprotected BufferedDataTable[] execute(final BufferedDataTable[] inData,\nfinal ExecutionContext exec) throws Exception {\nDataColumnSpec[] allColSpecs = new DataColumnSpec[1];\nallColSpecs[0] =\nnew DataColumnSpecCreator(\"url\", StringCell.TYPE).createSpec();\nDataTableSpec outputSpec = new DataTableSpec(allColSpecs);\n\/\/ System.out.println(\"calling execute\"+resultUrl.getStringValue());\n\/\/ the execution context will provide us with storage capacity, in this\n\/\/ case a data container to which we will add rows sequentially\n\/\/ Note, this container can also handle arbitrary big data tables, it\n\/\/ will buffer to disc if necessary.\nBufferedDataContainer container = exec.createDataContainer(outputSpec);\nDataCell[] cells = new DataCell[1];\nString urlTemplate = resultUrl.getStringValue();\nIterator<DataRow> varIt = inData[0].iterator();\nDataTableSpec dts = inData[0].getDataTableSpec();\nString[] colNames = dts.getColumnNames();\nif(varIt.hasNext()){\n\/\/while(varIt.hasNext()){\nDataRow current = varIt.next();\nIterator<DataCell> cellIt = current.iterator();\nint colCount = 0;\nwhile(cellIt.hasNext()){\nDataCell currentCell= cellIt.next();\nString curVar = colNames[colCount];\nString curVal = currentCell.toString();\n\/\/System.out.println(\"curvar:\"+curVar+\", curval:\"+curVal+\", urlTemplate:\"+urlTemplate);\nif(urlTemplate.indexOf(curVar)==-1){\nSystem.out.println(\"1curvar:\"+curVar+\", curval:\"+curVal+\", urlTemplate:\"+urlTemplate);\nurlTemplate = urlTemplate+\"&\"+curVar+\"=\"+URLEncoder.encode(currentCell.toString(),\"UTF-8\");\nSystem.out.println(\"2curvar:\"+curVar+\", curval:\"+curVal+\", urlTemplate:\"+urlTemplate);\n}else{\nSystem.out.println(\"3curvar:\"+curVar+\", curval:\"+curVal+\", urlTemplate:\"+urlTemplate);\nString configValue = \"\";\nif(urlTemplate.indexOf(\"&\"+curVar)!=-1){\nconfigValue = urlTemplate.substring(urlTemplate.indexOf(\"&\"+curVar)+curVar.length()+2,urlTemplate.indexOf(\"]\",urlTemplate.indexOf(curVar)));\n}else if(urlTemplate.indexOf(\"?\"+curVar)!=-1){\nconfigValue = urlTemplate.substring(urlTemplate.indexOf(\"?\"+curVar)+curVar.length()+2,urlTemplate.indexOf(\"]\",urlTemplate.indexOf(curVar)));\n}\nSystem.out.println(\"4curvar:\"+curVar+\", curval:\"+curVal+\", urlTemplate:\"+urlTemplate);\nif(configValue.endsWith(\"&\")){\nconfigValue = configValue.substring(0,configValue.length()-1); \/\/get rid of the &\n}\nif(colCount==0){\nurlTemplate +=\"&\";\n}\nSystem.out.println(\"5curvar:\"+curVar+\", curval:\"+curVal+\", urlTemplate:\"+urlTemplate);\nif(!configValue.equals(\"\")){\nSystem.out.println(\"6curvar:\"+curVar+\", curval:\"+curVal+\", urlTemplate:\"+urlTemplate);\nSystem.out.println(\"config var: \"+curVar+\" with configValue:\"+ configValue+ \", is overwritten with value: \"+currentCell.toString() );\nurlTemplate = urlTemplate.replaceAll(Pattern.quote(\"[\"+curVar+\"=\"+configValue+\"&]\"), curVar+\"=\"+URLEncoder.encode(currentCell.toString(),\"UTF-8\")+\"&\");\nurlTemplate = urlTemplate.replaceAll(Pattern.quote(\"[\"+curVar+\"=\"+configValue+\"]\"), curVar+\"=\"+URLEncoder.encode(currentCell.toString(),\"UTF-8\"));\n}else{\n\/\/System.out.println(\"now we are here\");\nSystem.out.println(\"7curvar:\"+curVar+\", curval:\"+curVal+\", urlTemplate:\"+urlTemplate);\nif(urlTemplate.endsWith(\"&\")||urlTemplate.endsWith(\"?\")){\n\/\/urlTemplate = urlTemplate.substring(0,urlTemplate.length()-1);\nurlTemplate = urlTemplate+curVar+\"=\"+URLEncoder.encode(curVal,\"UTF-8\");\n}else{\nurlTemplate = \"&\"+urlTemplate+curVar+\"=\"+URLEncoder.encode(curVal,\"UTF-8\");\n}\n\/\/urlTemplate = urlTemplate.replaceAll(Pattern.quote(\"[\"+curVar+\"=\"+configValue+\"&]\"), curVar+\"=\"+URLEncoder.encode(currentCell.toString(),\"UTF-8\")+\"&\");\n\/\/urlTemplate = urlTemplate.replaceAll(Pattern.quote(\"[\"+curVar+\"=\"+configValue+\"]\"), curVar+\"=\"+URLEncoder.encode(currentCell.toString(),\"UTF-8\"));\n\/\/System.out.println(\"urlTemplate before:\"+doubleStr+\", and after:\"+urlTemplate);\n}\n}\ncolCount++;\n}\n}\nSystem.out.println(\"yy:\"+urlTemplate);\n\/\/urlTemplate =urlTemplate.replaceAll(\"\\\\[.*?\\\\]\", \"\");\nurlTemplate =urlTemplate.replaceAll(\"\\\\[\", \"\");\nurlTemplate =urlTemplate.replaceAll(\"\\\\]\", \"\");\nurlTemplate =urlTemplate.replaceAll(\"%28\", \"(\");\nurlTemplate =urlTemplate.replaceAll(\"%29\", \")\");\n\/\/urlTemplate =urlTemplate.replaceAll(\"%5B\", \"[\"); \/\/strange that this is needed....API issue?\n\/\/urlTemplate =urlTemplate.replaceAll(\"%5D\", \"]\");\nSystem.out.println(\"yy:\"+urlTemplate);\nif(urlTemplate.endsWith(\"&\")){\nurlTemplate = urlTemplate.substring(0,urlTemplate.length()-1);\n}\n\/\/urlTemplate = urlTemplate.substring(0, urlTemplate.length()-1);\n\/\/System.out.println(\"urlTemplate became \"+urlTemplate);\ncells[0] = new StringCell(urlTemplate);\nDataRow row = new DefaultRow(\"aboutCell\", cells);\ncontainer.addRowToTable(row);\ncontainer.close();\nBufferedDataTable out = container.getTable();\n\/\/ TODO: Return a BufferedDataTable for each output port\nreturn new BufferedDataTable[]{out};\n}\n\n@Override\nprotected BufferedDataTable[] execute(final BufferedDataTable[] inData,\nfinal ExecutionContext exec) throws Exception {\nDataColumnSpec[] allColSpecs = new DataColumnSpec[1];\nallColSpecs[0] =\nnew DataColumnSpecCreator(\"url\", StringCell.TYPE).createSpec();\nDataTableSpec outputSpec = new DataTableSpec(allColSpecs);\n\/\/ System.out.println(\"calling execute\"+resultUrl.getStringValue());\n\/\/ the execution context will provide us with storage capacity, in this\n\/\/ case a data container to which we will add rows sequentially\n\/\/ Note, this container can also handle arbitrary big data tables, it\n\/\/ will buffer to disc if necessary.\nBufferedDataContainer container = exec.createDataContainer(outputSpec);\nDataCell[] cells = new DataCell[1];\nString urlTemplate = resultUrl.getStringValue();\nIterator<DataRow> varIt = inData[0].iterator();\nDataTableSpec dts = inData[0].getDataTableSpec();\nString[] colNames = dts.getColumnNames();\nif(varIt.hasNext()){\n\/\/while(varIt.hasNext()){\nDataRow current = varIt.next();\nIterator<DataCell> cellIt = current.iterator();\nint colCount = 0;\nwhile(cellIt.hasNext()){\nDataCell currentCell= cellIt.next();\nString curVar = colNames[colCount];\nString curVal = currentCell.toString();\n\/\/System.out.println(\"curvar:\"+curVar+\", curval:\"+curVal+\", urlTemplate:\"+urlTemplate);\nif(urlTemplate.indexOf(curVar)==-1){\nSystem.out.println(\"1curvar:\"+curVar+\", curval:\"+curVal+\", urlTemplate:\"+urlTemplate);\nurlTemplate = urlTemplate+\"&\"+curVar+\"=\"+URLEncoder.encode(currentCell.toString(),\"UTF-8\");\nSystem.out.println(\"2curvar:\"+curVar+\", curval:\"+curVal+\", urlTemplate:\"+urlTemplate);\n\n@Override\nprotected BufferedDataTable[] execute(final BufferedDataTable[] inData,\nfinal ExecutionContext exec) throws Exception {\nDataColumnSpec[] allColSpecs = new DataColumnSpec[1];\nallColSpecs[0] =\nnew DataColumnSpecCreator(\"url\", StringCell.TYPE).createSpec();\nDataTableSpec outputSpec = new DataTableSpec(allColSpecs);\n\/\/ System.out.println(\"calling execute\"+resultUrl.getStringValue());\n\/\/ the execution context will provide us with storage capacity, in this\n\/\/ case a data container to which we will add rows sequentially\n\/\/ Note, this container can also handle arbitrary big data tables, it\n\/\/ will buffer to disc if necessary.\nBufferedDataContainer container = exec.createDataContainer(outputSpec);\nDataCell[] cells = new DataCell[1];\nString urlTemplate = resultUrl.getStringValue();\nIterator<DataRow> varIt = inData[0].iterator();\nDataTableSpec dts = inData[0].getDataTableSpec();\nString[] colNames = dts.getColumnNames();\nif(varIt.hasNext()){\n\/\/while(varIt.hasNext()){\nDataRow current = varIt.next();\nIterator<DataCell> cellIt = current.iterator();\nint colCount = 0;\nwhile(cellIt.hasNext()){\nDataCell currentCell= cellIt.next();\nString curVar = colNames[colCount];\nString curVal = currentCell.toString();\n\/\/System.out.println(\"curvar:\"+curVar+\", curval:\"+curVal+\", urlTemplate:\"+urlTemplate);\nif(urlTemplate.indexOf(curVar)==-1){\nSystem.out.println(\"1curvar:\"+curVar+\", curval:\"+curVal+\", urlTemplate:\"+urlTemplate);\nurlTemplate = urlTemplate+\"&\"+curVar+\"=\"+URLEncoder.encode(currentCell.toString(),\"UTF-8\");\nSystem.out.println(\"2curvar:\"+curVar+\", curval:\"+curVal+\", urlTemplate:\"+urlTemplate);\n}else{\nSystem.out.println(\"3curvar:\"+curVar+\", curval:\"+curVal+\", urlTemplate:\"+urlTemplate);\nString configValue = \"\";\nif(urlTemplate.indexOf(\"&\"+curVar)!=-1){\nconfigValue = urlTemplate.substring(urlTemplate.indexOf(\"&\"+curVar)+curVar.length()+2,urlTemplate.indexOf(\"]\",urlTemplate.indexOf(curVar)));\n}else if(urlTemplate.indexOf(\"?\"+curVar)!=-1){\nconfigValue = urlTemplate.substring(urlTemplate.indexOf(\"?\"+curVar)+curVar.length()+2,urlTemplate.indexOf(\"]\",urlTemplate.indexOf(curVar)));\n}\n\n\/\/ System.out.println(\"calling execute\"+resultUrl.getStringValue());\n\/\/ the execution context will provide us with storage capacity, in this\n\/\/ case a data container to which we will add rows sequentially\n\/\/ Note, this container can also handle arbitrary big data tables, it\n\/\/ will buffer to disc if necessary.\nBufferedDataContainer container = exec.createDataContainer(outputSpec);\nDataCell[] cells = new DataCell[1];\nString urlTemplate = resultUrl.getStringValue();\nIterator<DataRow> varIt = inData[0].iterator();\nDataTableSpec dts = inData[0].getDataTableSpec();\nString[] colNames = dts.getColumnNames();\nif(varIt.hasNext()){\n\/\/while(varIt.hasNext()){\nDataRow current = varIt.next();\nIterator<DataCell> cellIt = current.iterator();\nint colCount = 0;\nwhile(cellIt.hasNext()){\nDataCell currentCell= cellIt.next();\nString curVar = colNames[colCount];\nString curVal = currentCell.toString();\n\/\/System.out.println(\"curvar:\"+curVar+\", curval:\"+curVal+\", urlTemplate:\"+urlTemplate);\nif(urlTemplate.indexOf(curVar)==-1){\nSystem.out.println(\"1curvar:\"+curVar+\", curval:\"+curVal+\", urlTemplate:\"+urlTemplate);\nurlTemplate = urlTemplate+\"&\"+curVar+\"=\"+URLEncoder.encode(currentCell.toString(),\"UTF-8\");\nSystem.out.println(\"2curvar:\"+curVar+\", curval:\"+curVal+\", urlTemplate:\"+urlTemplate);\n}else{\nSystem.out.println(\"3curvar:\"+curVar+\", curval:\"+curVal+\", urlTemplate:\"+urlTemplate);\nString configValue = \"\";\nif(urlTemplate.indexOf(\"&\"+curVar)!=-1){\nconfigValue = urlTemplate.substring(urlTemplate.indexOf(\"&\"+curVar)+curVar.length()+2,urlTemplate.indexOf(\"]\",urlTemplate.indexOf(curVar)));\n}else if(urlTemplate.indexOf(\"?\"+curVar)!=-1){\nconfigValue = urlTemplate.substring(urlTemplate.indexOf(\"?\"+curVar)+curVar.length()+2,urlTemplate.indexOf(\"]\",urlTemplate.indexOf(curVar)));\n}\nSystem.out.println(\"4curvar:\"+curVar+\", curval:\"+curVal+\", urlTemplate:\"+urlTemplate);\nif(configValue.endsWith(\"&\")){\nconfigValue = configValue.substring(0,configValue.length()-1); \/\/get rid of the &\n}\nif(colCount==0){\nurlTemplate +=\"&\";\n}\nSystem.out.println(\"5curvar:\"+curVar+\", curval:\"+curVal+\", urlTemplate:\"+urlTemplate);\n\nint colCount = 0;\nwhile(cellIt.hasNext()){\nDataCell currentCell= cellIt.next();\nString curVar = colNames[colCount];\nString curVal = currentCell.toString();\n\/\/System.out.println(\"curvar:\"+curVar+\", curval:\"+curVal+\", urlTemplate:\"+urlTemplate);\nif(urlTemplate.indexOf(curVar)==-1){\nSystem.out.println(\"1curvar:\"+curVar+\", curval:\"+curVal+\", urlTemplate:\"+urlTemplate);\nurlTemplate = urlTemplate+\"&\"+curVar+\"=\"+URLEncoder.encode(currentCell.toString(),\"UTF-8\");\nSystem.out.println(\"2curvar:\"+curVar+\", curval:\"+curVal+\", urlTemplate:\"+urlTemplate);\n}else{\nSystem.out.println(\"3curvar:\"+curVar+\", curval:\"+curVal+\", urlTemplate:\"+urlTemplate);\nString configValue = \"\";\nif(urlTemplate.indexOf(\"&\"+curVar)!=-1){\nconfigValue = urlTemplate.substring(urlTemplate.indexOf(\"&\"+curVar)+curVar.length()+2,urlTemplate.indexOf(\"]\",urlTemplate.indexOf(curVar)));\n}else if(urlTemplate.indexOf(\"?\"+curVar)!=-1){\nconfigValue = urlTemplate.substring(urlTemplate.indexOf(\"?\"+curVar)+curVar.length()+2,urlTemplate.indexOf(\"]\",urlTemplate.indexOf(curVar)));\n}\nSystem.out.println(\"4curvar:\"+curVar+\", curval:\"+curVal+\", urlTemplate:\"+urlTemplate);\nif(configValue.endsWith(\"&\")){\nconfigValue = configValue.substring(0,configValue.length()-1); \/\/get rid of the &\n}\nif(colCount==0){\nurlTemplate +=\"&\";\n}\nSystem.out.println(\"5curvar:\"+curVar+\", curval:\"+curVal+\", urlTemplate:\"+urlTemplate);\nif(!configValue.equals(\"\")){\nSystem.out.println(\"6curvar:\"+curVar+\", curval:\"+curVal+\", urlTemplate:\"+urlTemplate);\nSystem.out.println(\"config var: \"+curVar+\" with configValue:\"+ configValue+ \", is overwritten with value: \"+currentCell.toString() );\nurlTemplate = urlTemplate.replaceAll(Pattern.quote(\"[\"+curVar+\"=\"+configValue+\"&]\"), curVar+\"=\"+URLEncoder.encode(currentCell.toString(),\"UTF-8\")+\"&\");\nurlTemplate = urlTemplate.replaceAll(Pattern.quote(\"[\"+curVar+\"=\"+configValue+\"]\"), curVar+\"=\"+URLEncoder.encode(currentCell.toString(),\"UTF-8\"));\n}else{\n\/\/System.out.println(\"now we are here\");\nSystem.out.println(\"7curvar:\"+curVar+\", curval:\"+curVal+\", urlTemplate:\"+urlTemplate);\nif(urlTemplate.endsWith(\"&\")||urlTemplate.endsWith(\"?\")){\n\/\/urlTemplate = urlTemplate.substring(0,urlTemplate.length()-1);\nurlTemplate = urlTemplate+curVar+\"=\"+URLEncoder.encode(curVal,\"UTF-8\");\n}else{\nurlTemplate = \"&\"+urlTemplate+curVar+\"=\"+URLEncoder.encode(curVal,\"UTF-8\");\n}\n\/\/urlTemplate = urlTemplate.replaceAll(Pattern.quote(\"[\"+curVar+\"=\"+configValue+\"&]\"), curVar+\"=\"+URLEncoder.encode(currentCell.toString(),\"UTF-8\")+\"&\");\n\nString configValue = \"\";\nif(urlTemplate.indexOf(\"&\"+curVar)!=-1){\nconfigValue = urlTemplate.substring(urlTemplate.indexOf(\"&\"+curVar)+curVar.length()+2,urlTemplate.indexOf(\"]\",urlTemplate.indexOf(curVar)));\n}else if(urlTemplate.indexOf(\"?\"+curVar)!=-1){\nconfigValue = urlTemplate.substring(urlTemplate.indexOf(\"?\"+curVar)+curVar.length()+2,urlTemplate.indexOf(\"]\",urlTemplate.indexOf(curVar)));\n}\nSystem.out.println(\"4curvar:\"+curVar+\", curval:\"+curVal+\", urlTemplate:\"+urlTemplate);\nif(configValue.endsWith(\"&\")){\nconfigValue = configValue.substring(0,configValue.length()-1); \/\/get rid of the &\n}\nif(colCount==0){\nurlTemplate +=\"&\";\n}\nSystem.out.println(\"5curvar:\"+curVar+\", curval:\"+curVal+\", urlTemplate:\"+urlTemplate);\nif(!configValue.equals(\"\")){\nSystem.out.println(\"6curvar:\"+curVar+\", curval:\"+curVal+\", urlTemplate:\"+urlTemplate);\nSystem.out.println(\"config var: \"+curVar+\" with configValue:\"+ configValue+ \", is overwritten with value: \"+currentCell.toString() );\nurlTemplate = urlTemplate.replaceAll(Pattern.quote(\"[\"+curVar+\"=\"+configValue+\"&]\"), curVar+\"=\"+URLEncoder.encode(currentCell.toString(),\"UTF-8\")+\"&\");\nurlTemplate = urlTemplate.replaceAll(Pattern.quote(\"[\"+curVar+\"=\"+configValue+\"]\"), curVar+\"=\"+URLEncoder.encode(currentCell.toString(),\"UTF-8\"));\n}else{\n\/\/System.out.println(\"now we are here\");\nSystem.out.println(\"7curvar:\"+curVar+\", curval:\"+curVal+\", urlTemplate:\"+urlTemplate);\nif(urlTemplate.endsWith(\"&\")||urlTemplate.endsWith(\"?\")){\n\/\/urlTemplate = urlTemplate.substring(0,urlTemplate.length()-1);\nurlTemplate = urlTemplate+curVar+\"=\"+URLEncoder.encode(curVal,\"UTF-8\");\n}else{\nurlTemplate = \"&\"+urlTemplate+curVar+\"=\"+URLEncoder.encode(curVal,\"UTF-8\");\n}\n\/\/urlTemplate = urlTemplate.replaceAll(Pattern.quote(\"[\"+curVar+\"=\"+configValue+\"&]\"), curVar+\"=\"+URLEncoder.encode(currentCell.toString(),\"UTF-8\")+\"&\");\n\/\/urlTemplate = urlTemplate.replaceAll(Pattern.quote(\"[\"+curVar+\"=\"+configValue+\"]\"), curVar+\"=\"+URLEncoder.encode(currentCell.toString(),\"UTF-8\"));\n\/\/System.out.println(\"urlTemplate before:\"+doubleStr+\", and after:\"+urlTemplate);\n}\n}\ncolCount++;\n}\n}\nSystem.out.println(\"yy:\"+urlTemplate);\n\/\/urlTemplate =urlTemplate.replaceAll(\"\\\\[.*?\\\\]\", \"\");\nurlTemplate =urlTemplate.replaceAll(\"\\\\[\", \"\");\nurlTemplate =urlTemplate.replaceAll(\"\\\\]\", \"\");\nurlTemplate =urlTemplate.replaceAll(\"%28\", \"(\");\n\n}else if(urlTemplate.indexOf(\"?\"+curVar)!=-1){\nconfigValue = urlTemplate.substring(urlTemplate.indexOf(\"?\"+curVar)+curVar.length()+2,urlTemplate.indexOf(\"]\",urlTemplate.indexOf(curVar)));\n}\nSystem.out.println(\"4curvar:\"+curVar+\", curval:\"+curVal+\", urlTemplate:\"+urlTemplate);\nif(configValue.endsWith(\"&\")){\nconfigValue = configValue.substring(0,configValue.length()-1); \/\/get rid of the &\n}\nif(colCount==0){\nurlTemplate +=\"&\";\n}\nSystem.out.println(\"5curvar:\"+curVar+\", curval:\"+curVal+\", urlTemplate:\"+urlTemplate);\nif(!configValue.equals(\"\")){\nSystem.out.println(\"6curvar:\"+curVar+\", curval:\"+curVal+\", urlTemplate:\"+urlTemplate);\nSystem.out.println(\"config var: \"+curVar+\" with configValue:\"+ configValue+ \", is overwritten with value: \"+currentCell.toString() );\nurlTemplate = urlTemplate.replaceAll(Pattern.quote(\"[\"+curVar+\"=\"+configValue+\"&]\"), curVar+\"=\"+URLEncoder.encode(currentCell.toString(),\"UTF-8\")+\"&\");\nurlTemplate = urlTemplate.replaceAll(Pattern.quote(\"[\"+curVar+\"=\"+configValue+\"]\"), curVar+\"=\"+URLEncoder.encode(currentCell.toString(),\"UTF-8\"));\n}else{\n\/\/System.out.println(\"now we are here\");\nSystem.out.println(\"7curvar:\"+curVar+\", curval:\"+curVal+\", urlTemplate:\"+urlTemplate);\nif(urlTemplate.endsWith(\"&\")||urlTemplate.endsWith(\"?\")){\n\/\/urlTemplate = urlTemplate.substring(0,urlTemplate.length()-1);\nurlTemplate = urlTemplate+curVar+\"=\"+URLEncoder.encode(curVal,\"UTF-8\");\n}else{\nurlTemplate = \"&\"+urlTemplate+curVar+\"=\"+URLEncoder.encode(curVal,\"UTF-8\");\n}\n\/\/urlTemplate = urlTemplate.replaceAll(Pattern.quote(\"[\"+curVar+\"=\"+configValue+\"&]\"), curVar+\"=\"+URLEncoder.encode(currentCell.toString(),\"UTF-8\")+\"&\");\n\/\/urlTemplate = urlTemplate.replaceAll(Pattern.quote(\"[\"+curVar+\"=\"+configValue+\"]\"), curVar+\"=\"+URLEncoder.encode(currentCell.toString(),\"UTF-8\"));\n\/\/System.out.println(\"urlTemplate before:\"+doubleStr+\", and after:\"+urlTemplate);\n}\n}\ncolCount++;\n}\n}\nSystem.out.println(\"yy:\"+urlTemplate);\n\/\/urlTemplate =urlTemplate.replaceAll(\"\\\\[.*?\\\\]\", \"\");\nurlTemplate =urlTemplate.replaceAll(\"\\\\[\", \"\");\nurlTemplate =urlTemplate.replaceAll(\"\\\\]\", \"\");\nurlTemplate =urlTemplate.replaceAll(\"%28\", \"(\");\nurlTemplate =urlTemplate.replaceAll(\"%29\", \")\");\n\/\/urlTemplate =urlTemplate.replaceAll(\"%5B\", \"[\"); \/\/strange that this is needed....API issue?\n\/\/urlTemplate =urlTemplate.replaceAll(\"%5D\", \"]\");\n\nconfigValue = configValue.substring(0,configValue.length()-1); \/\/get rid of the &\n}\nif(colCount==0){\nurlTemplate +=\"&\";\n}\nSystem.out.println(\"5curvar:\"+curVar+\", curval:\"+curVal+\", urlTemplate:\"+urlTemplate);\nif(!configValue.equals(\"\")){\nSystem.out.println(\"6curvar:\"+curVar+\", curval:\"+curVal+\", urlTemplate:\"+urlTemplate);\nSystem.out.println(\"config var: \"+curVar+\" with configValue:\"+ configValue+ \", is overwritten with value: \"+currentCell.toString() );\nurlTemplate = urlTemplate.replaceAll(Pattern.quote(\"[\"+curVar+\"=\"+configValue+\"&]\"), curVar+\"=\"+URLEncoder.encode(currentCell.toString(),\"UTF-8\")+\"&\");\nurlTemplate = urlTemplate.replaceAll(Pattern.quote(\"[\"+curVar+\"=\"+configValue+\"]\"), curVar+\"=\"+URLEncoder.encode(currentCell.toString(),\"UTF-8\"));\n}else{\n\/\/System.out.println(\"now we are here\");\nSystem.out.println(\"7curvar:\"+curVar+\", curval:\"+curVal+\", urlTemplate:\"+urlTemplate);\nif(urlTemplate.endsWith(\"&\")||urlTemplate.endsWith(\"?\")){\n\/\/urlTemplate = urlTemplate.substring(0,urlTemplate.length()-1);\nurlTemplate = urlTemplate+curVar+\"=\"+URLEncoder.encode(curVal,\"UTF-8\");\n}else{\nurlTemplate = \"&\"+urlTemplate+curVar+\"=\"+URLEncoder.encode(curVal,\"UTF-8\");\n}\n\/\/urlTemplate = urlTemplate.replaceAll(Pattern.quote(\"[\"+curVar+\"=\"+configValue+\"&]\"), curVar+\"=\"+URLEncoder.encode(currentCell.toString(),\"UTF-8\")+\"&\");\n\/\/urlTemplate = urlTemplate.replaceAll(Pattern.quote(\"[\"+curVar+\"=\"+configValue+\"]\"), curVar+\"=\"+URLEncoder.encode(currentCell.toString(),\"UTF-8\"));\n\/\/System.out.println(\"urlTemplate before:\"+doubleStr+\", and after:\"+urlTemplate);\n}\n}\ncolCount++;\n}\n}\nSystem.out.println(\"yy:\"+urlTemplate);\n\/\/urlTemplate =urlTemplate.replaceAll(\"\\\\[.*?\\\\]\", \"\");\nurlTemplate =urlTemplate.replaceAll(\"\\\\[\", \"\");\nurlTemplate =urlTemplate.replaceAll(\"\\\\]\", \"\");\nurlTemplate =urlTemplate.replaceAll(\"%28\", \"(\");\nurlTemplate =urlTemplate.replaceAll(\"%29\", \")\");\n\/\/urlTemplate =urlTemplate.replaceAll(\"%5B\", \"[\"); \/\/strange that this is needed....API issue?\n\/\/urlTemplate =urlTemplate.replaceAll(\"%5D\", \"]\");\nSystem.out.println(\"yy:\"+urlTemplate);\nif(urlTemplate.endsWith(\"&\")){\nurlTemplate = urlTemplate.substring(0,urlTemplate.length()-1);\n}\n\/\/urlTemplate = urlTemplate.substring(0, urlTemplate.length()-1);\n\/\/System.out.println(\"urlTemplate became \"+urlTemplate);\ncells[0] = new StringCell(urlTemplate);\n\nurlTemplate = urlTemplate.replaceAll(Pattern.quote(\"[\"+curVar+\"=\"+configValue+\"&]\"), curVar+\"=\"+URLEncoder.encode(currentCell.toString(),\"UTF-8\")+\"&\");\nurlTemplate = urlTemplate.replaceAll(Pattern.quote(\"[\"+curVar+\"=\"+configValue+\"]\"), curVar+\"=\"+URLEncoder.encode(currentCell.toString(),\"UTF-8\"));\n}else{\n\/\/System.out.println(\"now we are here\");\nSystem.out.println(\"7curvar:\"+curVar+\", curval:\"+curVal+\", urlTemplate:\"+urlTemplate);\nif(urlTemplate.endsWith(\"&\")||urlTemplate.endsWith(\"?\")){\n\/\/urlTemplate = urlTemplate.substring(0,urlTemplate.length()-1);\nurlTemplate = urlTemplate+curVar+\"=\"+URLEncoder.encode(curVal,\"UTF-8\");\n}else{\nurlTemplate = \"&\"+urlTemplate+curVar+\"=\"+URLEncoder.encode(curVal,\"UTF-8\");\n}\n\/\/urlTemplate = urlTemplate.replaceAll(Pattern.quote(\"[\"+curVar+\"=\"+configValue+\"&]\"), curVar+\"=\"+URLEncoder.encode(currentCell.toString(),\"UTF-8\")+\"&\");\n\/\/urlTemplate = urlTemplate.replaceAll(Pattern.quote(\"[\"+curVar+\"=\"+configValue+\"]\"), curVar+\"=\"+URLEncoder.encode(currentCell.toString(),\"UTF-8\"));\n\/\/System.out.println(\"urlTemplate before:\"+doubleStr+\", and after:\"+urlTemplate);\n}\n}\ncolCount++;\n}\n}\nSystem.out.println(\"yy:\"+urlTemplate);\n\/\/urlTemplate =urlTemplate.replaceAll(\"\\\\[.*?\\\\]\", \"\");\nurlTemplate =urlTemplate.replaceAll(\"\\\\[\", \"\");\nurlTemplate =urlTemplate.replaceAll(\"\\\\]\", \"\");\nurlTemplate =urlTemplate.replaceAll(\"%28\", \"(\");\nurlTemplate =urlTemplate.replaceAll(\"%29\", \")\");\n\/\/urlTemplate =urlTemplate.replaceAll(\"%5B\", \"[\"); \/\/strange that this is needed....API issue?\n\/\/urlTemplate =urlTemplate.replaceAll(\"%5D\", \"]\");\nSystem.out.println(\"yy:\"+urlTemplate);\nif(urlTemplate.endsWith(\"&\")){\nurlTemplate = urlTemplate.substring(0,urlTemplate.length()-1);\n}\n\/\/urlTemplate = urlTemplate.substring(0, urlTemplate.length()-1);\n\/\/System.out.println(\"urlTemplate became \"+urlTemplate);\ncells[0] = new StringCell(urlTemplate);\nDataRow row = new DefaultRow(\"aboutCell\", cells);\ncontainer.addRowToTable(row);\ncontainer.close();\nBufferedDataTable out = container.getTable();\n\/\/ TODO: Return a BufferedDataTable for each output port\nreturn new BufferedDataTable[]{out};\n}\n\nif(urlTemplate.endsWith(\"&\")||urlTemplate.endsWith(\"?\")){\n\/\/urlTemplate = urlTemplate.substring(0,urlTemplate.length()-1);\nurlTemplate = urlTemplate+curVar+\"=\"+URLEncoder.encode(curVal,\"UTF-8\");\n}else{\nurlTemplate = \"&\"+urlTemplate+curVar+\"=\"+URLEncoder.encode(curVal,\"UTF-8\");\n}\n\/\/urlTemplate = urlTemplate.replaceAll(Pattern.quote(\"[\"+curVar+\"=\"+configValue+\"&]\"), curVar+\"=\"+URLEncoder.encode(currentCell.toString(),\"UTF-8\")+\"&\");\n\/\/urlTemplate = urlTemplate.replaceAll(Pattern.quote(\"[\"+curVar+\"=\"+configValue+\"]\"), curVar+\"=\"+URLEncoder.encode(currentCell.toString(),\"UTF-8\"));\n\/\/System.out.println(\"urlTemplate before:\"+doubleStr+\", and after:\"+urlTemplate);\n}\n}\ncolCount++;\n}\n}\nSystem.out.println(\"yy:\"+urlTemplate);\n\/\/urlTemplate =urlTemplate.replaceAll(\"\\\\[.*?\\\\]\", \"\");\nurlTemplate =urlTemplate.replaceAll(\"\\\\[\", \"\");\nurlTemplate =urlTemplate.replaceAll(\"\\\\]\", \"\");\nurlTemplate =urlTemplate.replaceAll(\"%28\", \"(\");\nurlTemplate =urlTemplate.replaceAll(\"%29\", \")\");\n\/\/urlTemplate =urlTemplate.replaceAll(\"%5B\", \"[\"); \/\/strange that this is needed....API issue?\n\/\/urlTemplate =urlTemplate.replaceAll(\"%5D\", \"]\");\nSystem.out.println(\"yy:\"+urlTemplate);\nif(urlTemplate.endsWith(\"&\")){\nurlTemplate = urlTemplate.substring(0,urlTemplate.length()-1);\n}\n\/\/urlTemplate = urlTemplate.substring(0, urlTemplate.length()-1);\n\/\/System.out.println(\"urlTemplate became \"+urlTemplate);\ncells[0] = new StringCell(urlTemplate);\nDataRow row = new DefaultRow(\"aboutCell\", cells);\ncontainer.addRowToTable(row);\ncontainer.close();\nBufferedDataTable out = container.getTable();\n\/\/ TODO: Return a BufferedDataTable for each output port\nreturn new BufferedDataTable[]{out};\n}\n\n\/\/urlTemplate = urlTemplate.replaceAll(Pattern.quote(\"[\"+curVar+\"=\"+configValue+\"&]\"), curVar+\"=\"+URLEncoder.encode(currentCell.toString(),\"UTF-8\")+\"&\");\n\/\/urlTemplate = urlTemplate.replaceAll(Pattern.quote(\"[\"+curVar+\"=\"+configValue+\"]\"), curVar+\"=\"+URLEncoder.encode(currentCell.toString(),\"UTF-8\"));\n\/\/System.out.println(\"urlTemplate before:\"+doubleStr+\", and after:\"+urlTemplate);\n}\n}\ncolCount++;\n}\n}\nSystem.out.println(\"yy:\"+urlTemplate);\n\/\/urlTemplate =urlTemplate.replaceAll(\"\\\\[.*?\\\\]\", \"\");\nurlTemplate =urlTemplate.replaceAll(\"\\\\[\", \"\");\nurlTemplate =urlTemplate.replaceAll(\"\\\\]\", \"\");\nurlTemplate =urlTemplate.replaceAll(\"%28\", \"(\");\nurlTemplate =urlTemplate.replaceAll(\"%29\", \")\");\n\/\/urlTemplate =urlTemplate.replaceAll(\"%5B\", \"[\"); \/\/strange that this is needed....API issue?\n\/\/urlTemplate =urlTemplate.replaceAll(\"%5D\", \"]\");\nSystem.out.println(\"yy:\"+urlTemplate);\nif(urlTemplate.endsWith(\"&\")){\nurlTemplate = urlTemplate.substring(0,urlTemplate.length()-1);\n}\n\/\/urlTemplate = urlTemplate.substring(0, urlTemplate.length()-1);\n\/\/System.out.println(\"urlTemplate became \"+urlTemplate);\ncells[0] = new StringCell(urlTemplate);\nDataRow row = new DefaultRow(\"aboutCell\", cells);\ncontainer.addRowToTable(row);\ncontainer.close();\nBufferedDataTable out = container.getTable();\n\/\/ TODO: Return a BufferedDataTable for each output port\nreturn new BufferedDataTable[]{out};\n}\n\n}\nSystem.out.println(\"yy:\"+urlTemplate);\n\/\/urlTemplate =urlTemplate.replaceAll(\"\\\\[.*?\\\\]\", \"\");\nurlTemplate =urlTemplate.replaceAll(\"\\\\[\", \"\");\nurlTemplate =urlTemplate.replaceAll(\"\\\\]\", \"\");\nurlTemplate =urlTemplate.replaceAll(\"%28\", \"(\");\nurlTemplate =urlTemplate.replaceAll(\"%29\", \")\");\n\/\/urlTemplate =urlTemplate.replaceAll(\"%5B\", \"[\"); \/\/strange that this is needed....API issue?\n\/\/urlTemplate =urlTemplate.replaceAll(\"%5D\", \"]\");\nSystem.out.println(\"yy:\"+urlTemplate);\nif(urlTemplate.endsWith(\"&\")){\nurlTemplate = urlTemplate.substring(0,urlTemplate.length()-1);\n}\n\/\/urlTemplate = urlTemplate.substring(0, urlTemplate.length()-1);\n\/\/System.out.println(\"urlTemplate became \"+urlTemplate);\ncells[0] = new StringCell(urlTemplate);\nDataRow row = new DefaultRow(\"aboutCell\", cells);\ncontainer.addRowToTable(row);\ncontainer.close();\nBufferedDataTable out = container.getTable();\n\/\/ TODO: Return a BufferedDataTable for each output port\nreturn new BufferedDataTable[]{out};\n}","label":[0,1,1,0]}
{"id":16088,"original_code":"private void parseNamespaceOrTypes() throws FeatureNotSupportedException {\n        while (!curtok.equals(EOF)) {\n            \/\/ todo: account for assembly attributes\n            parsePossibleAttributes(true);\n            if (curAttributes.size() > 0) {\n                for (AttributeNode an : curAttributes) {\n                    cu.attributes.add(an);\n                }\n                curAttributes.clear();\n            }\n            \/\/ can be usingDirectives, globalAttribs, or NamespaceMembersDecls\n            \/\/ NamespaceMembersDecls include namespaces, class, struct, interface, enum, delegate\n            switch (curtok.id) {\n                case TokenID.Using:\n                    \/\/ using directive\n                    parseUsingDirectives();\n                    break;\n                case TokenID.New:\n                case TokenID.Public:\n                case TokenID.Protected:\n                case TokenID.Partial:\n                case TokenID.Static:\n                case TokenID.Internal:\n                case TokenID.Private:\n                case TokenID.Abstract:\n                case TokenID.Sealed:\n                    \/\/parseTypeModifier();\n                    curmods |= modMap.get(curtok.id);\n                    advance();\n                    break;\n                case TokenID.Namespace:\n                    parseNamespace();\n                    break;\n                case TokenID.Class:\n                    parseClass();\n                    break;\n                case TokenID.Struct:\n                    parseStruct();\n                    break;\n                case TokenID.Interface:\n                    parseInterface();\n                    break;\n                case TokenID.Enum:\n                    parseEnum();\n                    break;\n                case TokenID.Delegate:\n                    parseDelegate();\n                    break;\n                case TokenID.Semi:\n                    advance();\n                    break;\n                default:\n                    return;\n            }\n        }\n    }","code":"private void parseNamespaceOrTypes() throws FeatureNotSupportedException {\n        while (!curtok.equals(EOF)) {\n           \n            parsePossibleAttributes(true);\n            if (curAttributes.size() > 0) {\n                for (AttributeNode an : curAttributes) {\n                    cu.attributes.add(an);\n                }\n                curAttributes.clear();\n            }\n           \n           \n            switch (curtok.id) {\n                case TokenID.Using:\n                   \n                    parseUsingDirectives();\n                    break;\n                case TokenID.New:\n                case TokenID.Public:\n                case TokenID.Protected:\n                case TokenID.Partial:\n                case TokenID.Static:\n                case TokenID.Internal:\n                case TokenID.Private:\n                case TokenID.Abstract:\n                case TokenID.Sealed:\n                   \n                    curmods |= modMap.get(curtok.id);\n                    advance();\n                    break;\n                case TokenID.Namespace:\n                    parseNamespace();\n                    break;\n                case TokenID.Class:\n                    parseClass();\n                    break;\n                case TokenID.Struct:\n                    parseStruct();\n                    break;\n                case TokenID.Interface:\n                    parseInterface();\n                    break;\n                case TokenID.Enum:\n                    parseEnum();\n                    break;\n                case TokenID.Delegate:\n                    parseDelegate();\n                    break;\n                case TokenID.Semi:\n                    advance();\n                    break;\n                default:\n                    return;\n            }\n        }\n    }","cleancode":"private void parsenamespaceortypes() throws featurenotsupportedexception { while (!curtok.equals(eof)) { parsepossibleattributes(true); if (curattributes.size() > 0) { for (attributenode an : curattributes) { cu.attributes.add(an); } curattributes.clear(); } switch (curtok.id) { case tokenid.using: parseusingdirectives(); break; case tokenid.new: case tokenid.public: case tokenid.protected: case tokenid.partial: case tokenid.static: case tokenid.internal: case tokenid.private: case tokenid.abstract: case tokenid.sealed: curmods |= modmap.get(curtok.id); advance(); break; case tokenid.namespace: parsenamespace(); break; case tokenid.class: parseclass(); break; case tokenid.struct: parsestruct(); break; case tokenid.interface: parseinterface(); break; case tokenid.enum: parseenum(); break; case tokenid.delegate: parsedelegate(); break; case tokenid.semi: advance(); break; default: return; } } }","comment":"\/\/ todo: account for assembly attributes\n\/\/ can be usingdirectives, globalattribs, or namespacemembersdecls \/\/ namespacemembersdecls include namespaces, class, struct, interface, enum, delegate\n\/\/ using directive\n\/\/parsetypemodifier();","repo":"osoco\/comprendiendo-software-creando-herramientas","code_context_2":"private void parseNamespaceOrTypes() throws FeatureNotSupportedException {\nwhile (!curtok.equals(EOF)) {\n\/\/ todo: account for assembly attributes\nparsePossibleAttributes(true);\nif (curAttributes.size() > 0) {\n\ncurAttributes.clear();\n}\n\/\/ can be usingDirectives, globalAttribs, or NamespaceMembersDecls\n\/\/ NamespaceMembersDecls include namespaces, class, struct, interface, enum, delegate\nswitch (curtok.id) {\ncase TokenID.Using:\n\nswitch (curtok.id) {\ncase TokenID.Using:\n\/\/ using directive\nparseUsingDirectives();\nbreak;\n\ncase TokenID.Abstract:\ncase TokenID.Sealed:\n\/\/parseTypeModifier();\ncurmods |= modMap.get(curtok.id);\nadvance();","code_context_10":"private void parseNamespaceOrTypes() throws FeatureNotSupportedException {\nwhile (!curtok.equals(EOF)) {\n\/\/ todo: account for assembly attributes\nparsePossibleAttributes(true);\nif (curAttributes.size() > 0) {\nfor (AttributeNode an : curAttributes) {\ncu.attributes.add(an);\n}\ncurAttributes.clear();\n}\n\/\/ can be usingDirectives, globalAttribs, or NamespaceMembersDecls\n\/\/ NamespaceMembersDecls include namespaces, class, struct, interface, enum, delegate\nswitch (curtok.id) {\n\nprivate void parseNamespaceOrTypes() throws FeatureNotSupportedException {\nwhile (!curtok.equals(EOF)) {\n\/\/ todo: account for assembly attributes\nparsePossibleAttributes(true);\nif (curAttributes.size() > 0) {\nfor (AttributeNode an : curAttributes) {\ncu.attributes.add(an);\n}\ncurAttributes.clear();\n}\n\/\/ can be usingDirectives, globalAttribs, or NamespaceMembersDecls\n\/\/ NamespaceMembersDecls include namespaces, class, struct, interface, enum, delegate\nswitch (curtok.id) {\ncase TokenID.Using:\n\/\/ using directive\nparseUsingDirectives();\nbreak;\ncase TokenID.New:\ncase TokenID.Public:\ncase TokenID.Protected:\ncase TokenID.Partial:\ncase TokenID.Static:\n\nif (curAttributes.size() > 0) {\nfor (AttributeNode an : curAttributes) {\ncu.attributes.add(an);\n}\ncurAttributes.clear();\n}\n\/\/ can be usingDirectives, globalAttribs, or NamespaceMembersDecls\n\/\/ NamespaceMembersDecls include namespaces, class, struct, interface, enum, delegate\nswitch (curtok.id) {\ncase TokenID.Using:\n\/\/ using directive\nparseUsingDirectives();\nbreak;\ncase TokenID.New:\ncase TokenID.Public:\ncase TokenID.Protected:\ncase TokenID.Partial:\ncase TokenID.Static:\ncase TokenID.Internal:\ncase TokenID.Private:\ncase TokenID.Abstract:\n\nbreak;\ncase TokenID.New:\ncase TokenID.Public:\ncase TokenID.Protected:\ncase TokenID.Partial:\ncase TokenID.Static:\ncase TokenID.Internal:\ncase TokenID.Private:\ncase TokenID.Abstract:\ncase TokenID.Sealed:\n\/\/parseTypeModifier();\ncurmods |= modMap.get(curtok.id);\nadvance();\nbreak;\ncase TokenID.Namespace:\nparseNamespace();\nbreak;\ncase TokenID.Class:\nparseClass();\nbreak;\ncase TokenID.Struct:","code_context_20":"private void parseNamespaceOrTypes() throws FeatureNotSupportedException {\nwhile (!curtok.equals(EOF)) {\n\/\/ todo: account for assembly attributes\nparsePossibleAttributes(true);\nif (curAttributes.size() > 0) {\nfor (AttributeNode an : curAttributes) {\ncu.attributes.add(an);\n}\ncurAttributes.clear();\n}\n\/\/ can be usingDirectives, globalAttribs, or NamespaceMembersDecls\n\/\/ NamespaceMembersDecls include namespaces, class, struct, interface, enum, delegate\nswitch (curtok.id) {\ncase TokenID.Using:\n\/\/ using directive\nparseUsingDirectives();\nbreak;\ncase TokenID.New:\ncase TokenID.Public:\ncase TokenID.Protected:\ncase TokenID.Partial:\ncase TokenID.Static:\ncase TokenID.Internal:\n\nprivate void parseNamespaceOrTypes() throws FeatureNotSupportedException {\nwhile (!curtok.equals(EOF)) {\n\/\/ todo: account for assembly attributes\nparsePossibleAttributes(true);\nif (curAttributes.size() > 0) {\nfor (AttributeNode an : curAttributes) {\ncu.attributes.add(an);\n}\ncurAttributes.clear();\n}\n\/\/ can be usingDirectives, globalAttribs, or NamespaceMembersDecls\n\/\/ NamespaceMembersDecls include namespaces, class, struct, interface, enum, delegate\nswitch (curtok.id) {\ncase TokenID.Using:\n\/\/ using directive\nparseUsingDirectives();\nbreak;\ncase TokenID.New:\ncase TokenID.Public:\ncase TokenID.Protected:\ncase TokenID.Partial:\ncase TokenID.Static:\ncase TokenID.Internal:\ncase TokenID.Private:\ncase TokenID.Abstract:\ncase TokenID.Sealed:\n\/\/parseTypeModifier();\ncurmods |= modMap.get(curtok.id);\nadvance();\nbreak;\ncase TokenID.Namespace:\nparseNamespace();\n\nprivate void parseNamespaceOrTypes() throws FeatureNotSupportedException {\nwhile (!curtok.equals(EOF)) {\n\/\/ todo: account for assembly attributes\nparsePossibleAttributes(true);\nif (curAttributes.size() > 0) {\nfor (AttributeNode an : curAttributes) {\ncu.attributes.add(an);\n}\ncurAttributes.clear();\n}\n\/\/ can be usingDirectives, globalAttribs, or NamespaceMembersDecls\n\/\/ NamespaceMembersDecls include namespaces, class, struct, interface, enum, delegate\nswitch (curtok.id) {\ncase TokenID.Using:\n\/\/ using directive\nparseUsingDirectives();\nbreak;\ncase TokenID.New:\ncase TokenID.Public:\ncase TokenID.Protected:\ncase TokenID.Partial:\ncase TokenID.Static:\ncase TokenID.Internal:\ncase TokenID.Private:\ncase TokenID.Abstract:\ncase TokenID.Sealed:\n\/\/parseTypeModifier();\ncurmods |= modMap.get(curtok.id);\nadvance();\nbreak;\ncase TokenID.Namespace:\nparseNamespace();\nbreak;\ncase TokenID.Class:\nparseClass();\n\ncu.attributes.add(an);\n}\ncurAttributes.clear();\n}\n\/\/ can be usingDirectives, globalAttribs, or NamespaceMembersDecls\n\/\/ NamespaceMembersDecls include namespaces, class, struct, interface, enum, delegate\nswitch (curtok.id) {\ncase TokenID.Using:\n\/\/ using directive\nparseUsingDirectives();\nbreak;\ncase TokenID.New:\ncase TokenID.Public:\ncase TokenID.Protected:\ncase TokenID.Partial:\ncase TokenID.Static:\ncase TokenID.Internal:\ncase TokenID.Private:\ncase TokenID.Abstract:\ncase TokenID.Sealed:\n\/\/parseTypeModifier();\ncurmods |= modMap.get(curtok.id);\nadvance();\nbreak;\ncase TokenID.Namespace:\nparseNamespace();\nbreak;\ncase TokenID.Class:\nparseClass();\nbreak;\ncase TokenID.Struct:\nparseStruct();\nbreak;\ncase TokenID.Interface:\nparseInterface();\nbreak;\ncase TokenID.Enum:\nparseEnum();\nbreak;\ncase TokenID.Delegate:\nparseDelegate();","label":[0,1,0,0]}
{"id":16089,"original_code":"private PPNode parsePreprocessorDirective() throws FeatureNotSupportedException {\n        PPNode result = null;\n        int startLine = lineCount;\n        inPPDirective = true;\n        advance(); \/\/ over hash\n        IdentifierExpression ie = parseIdentifierOrKeyword();\n        String ppKind = ie.Identifier[0];\n        byte id = PreprocessorID.Empty;\n        if (preprocessor.containsKey(ppKind)) {\n            id = preprocessor.get(ppKind);\n        } else {\n            ReportError(\"Preprocessor directive must be valid identifier, rather than \\\"\" + ppKind + \"\\\".\");\n        }\n        switch (id) {\n            case PreprocessorID.Define:\n                \/\/ conditional-symbol pp-newline\n                IdentifierExpression def = parseIdentifierOrKeyword();\n                if (!ppDefs.containsKey(def.Identifier[0])) {\n                    ppDefs.put(def.Identifier[0], PreprocessorID.Empty);\n                }\n                result = new PPDefineNode(def);\n                break;\n            case PreprocessorID.Undef:\n                \/\/ conditional-symbol pp-newline\n                IdentifierExpression undef = parseIdentifierOrKeyword();\n                if (ppDefs.containsKey(undef.Identifier[0])) {\n                    ppDefs.remove(undef.Identifier[0]);\n                }\n                result = new PPDefineNode(undef);\n                break;\n            case PreprocessorID.If:\n                \/\/ pp-expression pp-newline conditional-section(opt)\n                if (curtok.id == TokenID.LParen) {\n                    advance();\n                }\n                int startCount = lineCount;\n                ppCondition = false;\n                \/\/ todo: account for true, false, ||, &&, ==, !=, !\n                IdentifierExpression ifexpr = parseIdentifierOrKeyword();\n                if (ppDefs.containsKey(ifexpr.Identifier[0])) {\n                    ppCondition = true;\n                }\n                \/\/result = new PPIfNode(ParseExpressionToNewline());\n                if (curtok.id == TokenID.RParen) {\n                    advance();\n                }\n                if (ppCondition == false) {\n                    \/\/ skip this block\n                    SkipToElseOrEndIf();\n                }\n                break;\n            case PreprocessorID.Elif:\n                \/\/ pp-expression pp-newline conditional-section(opt)\n                SkipToEOL(startLine);\n                break;\n            case PreprocessorID.Else:\n                \/\/ pp-newline conditional-section(opt)\n                if (ppCondition == true) {\n                    \/\/ skip this block\n                    SkipToElseOrEndIf();\n                }\n                break;\n            case PreprocessorID.Endif:\n                \/\/ pp-newline\n                result = new PPEndIfNode();\n                ppCondition = false;\n                break;\n            case PreprocessorID.Line:\n                \/\/ line-indicator pp-newline\n                SkipToEOL(startLine);\n                break;\n            case PreprocessorID.Error:\n                \/\/ pp-message\n                SkipToEOL(startLine);\n                break;\n            case PreprocessorID.Warning:\n                \/\/ pp-message\n                SkipToEOL(startLine);\n                break;\n            case PreprocessorID.Region:\n                \/\/ pp-message\n                SkipToEOL(startLine);\n                break;\n            case PreprocessorID.Endregion:\n                \/\/ pp-message\n                SkipToEOL(startLine);\n                break;\n            case PreprocessorID.Pragma:\n                \/\/ pp-message\n                SkipToEOL(startLine);\n                break;\n            default:\n                break;\n        }\n        inPPDirective = false;\n        return result;\n    }","code":"private PPNode parsePreprocessorDirective() throws FeatureNotSupportedException {\n        PPNode result = null;\n        int startLine = lineCount;\n        inPPDirective = true;\n        advance();\n        IdentifierExpression ie = parseIdentifierOrKeyword();\n        String ppKind = ie.Identifier[0];\n        byte id = PreprocessorID.Empty;\n        if (preprocessor.containsKey(ppKind)) {\n            id = preprocessor.get(ppKind);\n        } else {\n            ReportError(\"Preprocessor directive must be valid identifier, rather than \\\"\" + ppKind + \"\\\".\");\n        }\n        switch (id) {\n            case PreprocessorID.Define:\n               \n                IdentifierExpression def = parseIdentifierOrKeyword();\n                if (!ppDefs.containsKey(def.Identifier[0])) {\n                    ppDefs.put(def.Identifier[0], PreprocessorID.Empty);\n                }\n                result = new PPDefineNode(def);\n                break;\n            case PreprocessorID.Undef:\n               \n                IdentifierExpression undef = parseIdentifierOrKeyword();\n                if (ppDefs.containsKey(undef.Identifier[0])) {\n                    ppDefs.remove(undef.Identifier[0]);\n                }\n                result = new PPDefineNode(undef);\n                break;\n            case PreprocessorID.If:\n               \n                if (curtok.id == TokenID.LParen) {\n                    advance();\n                }\n                int startCount = lineCount;\n                ppCondition = false;\n               \n                IdentifierExpression ifexpr = parseIdentifierOrKeyword();\n                if (ppDefs.containsKey(ifexpr.Identifier[0])) {\n                    ppCondition = true;\n                }\n               \n                if (curtok.id == TokenID.RParen) {\n                    advance();\n                }\n                if (ppCondition == false) {\n                   \n                    SkipToElseOrEndIf();\n                }\n                break;\n            case PreprocessorID.Elif:\n               \n                SkipToEOL(startLine);\n                break;\n            case PreprocessorID.Else:\n               \n                if (ppCondition == true) {\n                   \n                    SkipToElseOrEndIf();\n                }\n                break;\n            case PreprocessorID.Endif:\n               \n                result = new PPEndIfNode();\n                ppCondition = false;\n                break;\n            case PreprocessorID.Line:\n               \n                SkipToEOL(startLine);\n                break;\n            case PreprocessorID.Error:\n               \n                SkipToEOL(startLine);\n                break;\n            case PreprocessorID.Warning:\n               \n                SkipToEOL(startLine);\n                break;\n            case PreprocessorID.Region:\n               \n                SkipToEOL(startLine);\n                break;\n            case PreprocessorID.Endregion:\n               \n                SkipToEOL(startLine);\n                break;\n            case PreprocessorID.Pragma:\n               \n                SkipToEOL(startLine);\n                break;\n            default:\n                break;\n        }\n        inPPDirective = false;\n        return result;\n    }","cleancode":"private ppnode parsepreprocessordirective() throws featurenotsupportedexception { ppnode result = null; int startline = linecount; inppdirective = true; advance(); identifierexpression ie = parseidentifierorkeyword(); string ppkind = ie.identifier[0]; byte id = preprocessorid.empty; if (preprocessor.containskey(ppkind)) { id = preprocessor.get(ppkind); } else { reporterror(\"preprocessor directive must be valid identifier, rather than \\\"\" + ppkind + \"\\\".\"); } switch (id) { case preprocessorid.define: identifierexpression def = parseidentifierorkeyword(); if (!ppdefs.containskey(def.identifier[0])) { ppdefs.put(def.identifier[0], preprocessorid.empty); } result = new ppdefinenode(def); break; case preprocessorid.undef: identifierexpression undef = parseidentifierorkeyword(); if (ppdefs.containskey(undef.identifier[0])) { ppdefs.remove(undef.identifier[0]); } result = new ppdefinenode(undef); break; case preprocessorid.if: if (curtok.id == tokenid.lparen) { advance(); } int startcount = linecount; ppcondition = false; identifierexpression ifexpr = parseidentifierorkeyword(); if (ppdefs.containskey(ifexpr.identifier[0])) { ppcondition = true; } if (curtok.id == tokenid.rparen) { advance(); } if (ppcondition == false) { skiptoelseorendif(); } break; case preprocessorid.elif: skiptoeol(startline); break; case preprocessorid.else: if (ppcondition == true) { skiptoelseorendif(); } break; case preprocessorid.endif: result = new ppendifnode(); ppcondition = false; break; case preprocessorid.line: skiptoeol(startline); break; case preprocessorid.error: skiptoeol(startline); break; case preprocessorid.warning: skiptoeol(startline); break; case preprocessorid.region: skiptoeol(startline); break; case preprocessorid.endregion: skiptoeol(startline); break; case preprocessorid.pragma: skiptoeol(startline); break; default: break; } inppdirective = false; return result; }","comment":"\/\/ over hash\n\/\/ conditional-symbol pp-newline\n\/\/ conditional-symbol pp-newline\n\/\/ pp-expression pp-newline conditional-section(opt)\n\/\/ todo: account for true, false, ||, &&, ==, !=, !\n\/\/result = new ppifnode(parseexpressiontonewline());\n\/\/ skip this block\n\/\/ pp-expression pp-newline conditional-section(opt)\n\/\/ pp-newline conditional-section(opt)\n\/\/ skip this block\n\/\/ pp-newline\n\/\/ line-indicator pp-newline\n\/\/ pp-message\n\/\/ pp-message\n\/\/ pp-message\n\/\/ pp-message\n\/\/ pp-message","repo":"osoco\/comprendiendo-software-creando-herramientas","code_context_2":"int startLine = lineCount;\ninPPDirective = true;\nadvance(); \/\/ over hash\nIdentifierExpression ie = parseIdentifierOrKeyword();\nString ppKind = ie.Identifier[0];\n\nswitch (id) {\ncase PreprocessorID.Define:\n\/\/ conditional-symbol pp-newline\nIdentifierExpression def = parseIdentifierOrKeyword();\nif (!ppDefs.containsKey(def.Identifier[0])) {\n\nswitch (id) {\ncase PreprocessorID.Define:\n\/\/ conditional-symbol pp-newline\nIdentifierExpression def = parseIdentifierOrKeyword();\nif (!ppDefs.containsKey(def.Identifier[0])) {\n\nbreak;\ncase PreprocessorID.If:\n\/\/ pp-expression pp-newline conditional-section(opt)\nif (curtok.id == TokenID.LParen) {\nadvance();\n\nint startCount = lineCount;\nppCondition = false;\n\/\/ todo: account for true, false, ||, &&, ==, !=, !\nIdentifierExpression ifexpr = parseIdentifierOrKeyword();\nif (ppDefs.containsKey(ifexpr.Identifier[0])) {\n\nppCondition = true;\n}\n\/\/result = new PPIfNode(ParseExpressionToNewline());\nif (curtok.id == TokenID.RParen) {\nadvance();\n\n}\nif (ppCondition == false) {\n\/\/ skip this block\nSkipToElseOrEndIf();\n}\n\nbreak;\ncase PreprocessorID.If:\n\/\/ pp-expression pp-newline conditional-section(opt)\nif (curtok.id == TokenID.LParen) {\nadvance();\n\nbreak;\ncase PreprocessorID.Else:\n\/\/ pp-newline conditional-section(opt)\nif (ppCondition == true) {\n\/\/ skip this block\n\n}\nif (ppCondition == false) {\n\/\/ skip this block\nSkipToElseOrEndIf();\n}\n\nbreak;\ncase PreprocessorID.Else:\n\/\/ pp-newline conditional-section(opt)\nif (ppCondition == true) {\n\/\/ skip this block\n\nbreak;\ncase PreprocessorID.Line:\n\/\/ line-indicator pp-newline\nSkipToEOL(startLine);\nbreak;\n\nbreak;\ncase PreprocessorID.Error:\n\/\/ pp-message\nSkipToEOL(startLine);\nbreak;\n\nbreak;\ncase PreprocessorID.Error:\n\/\/ pp-message\nSkipToEOL(startLine);\nbreak;\n\nbreak;\ncase PreprocessorID.Error:\n\/\/ pp-message\nSkipToEOL(startLine);\nbreak;\n\nbreak;\ncase PreprocessorID.Error:\n\/\/ pp-message\nSkipToEOL(startLine);\nbreak;\n\nbreak;\ncase PreprocessorID.Error:\n\/\/ pp-message\nSkipToEOL(startLine);\nbreak;","code_context_10":"private PPNode parsePreprocessorDirective() throws FeatureNotSupportedException {\nPPNode result = null;\nint startLine = lineCount;\ninPPDirective = true;\nadvance(); \/\/ over hash\nIdentifierExpression ie = parseIdentifierOrKeyword();\nString ppKind = ie.Identifier[0];\nbyte id = PreprocessorID.Empty;\nif (preprocessor.containsKey(ppKind)) {\nid = preprocessor.get(ppKind);\n} else {\nReportError(\"Preprocessor directive must be valid identifier, rather than \\\"\" + ppKind + \"\\\".\");\n}\nswitch (id) {\ncase PreprocessorID.Define:\n\nIdentifierExpression ie = parseIdentifierOrKeyword();\nString ppKind = ie.Identifier[0];\nbyte id = PreprocessorID.Empty;\nif (preprocessor.containsKey(ppKind)) {\nid = preprocessor.get(ppKind);\n} else {\nReportError(\"Preprocessor directive must be valid identifier, rather than \\\"\" + ppKind + \"\\\".\");\n}\nswitch (id) {\ncase PreprocessorID.Define:\n\/\/ conditional-symbol pp-newline\nIdentifierExpression def = parseIdentifierOrKeyword();\nif (!ppDefs.containsKey(def.Identifier[0])) {\nppDefs.put(def.Identifier[0], PreprocessorID.Empty);\n}\nresult = new PPDefineNode(def);\nbreak;\ncase PreprocessorID.Undef:\n\/\/ conditional-symbol pp-newline\nIdentifierExpression undef = parseIdentifierOrKeyword();\nif (ppDefs.containsKey(undef.Identifier[0])) {\n\nIdentifierExpression ie = parseIdentifierOrKeyword();\nString ppKind = ie.Identifier[0];\nbyte id = PreprocessorID.Empty;\nif (preprocessor.containsKey(ppKind)) {\nid = preprocessor.get(ppKind);\n} else {\nReportError(\"Preprocessor directive must be valid identifier, rather than \\\"\" + ppKind + \"\\\".\");\n}\nswitch (id) {\ncase PreprocessorID.Define:\n\/\/ conditional-symbol pp-newline\nIdentifierExpression def = parseIdentifierOrKeyword();\nif (!ppDefs.containsKey(def.Identifier[0])) {\nppDefs.put(def.Identifier[0], PreprocessorID.Empty);\n}\nresult = new PPDefineNode(def);\nbreak;\ncase PreprocessorID.Undef:\n\/\/ conditional-symbol pp-newline\nIdentifierExpression undef = parseIdentifierOrKeyword();\nif (ppDefs.containsKey(undef.Identifier[0])) {\n\nbreak;\ncase PreprocessorID.Undef:\n\/\/ conditional-symbol pp-newline\nIdentifierExpression undef = parseIdentifierOrKeyword();\nif (ppDefs.containsKey(undef.Identifier[0])) {\nppDefs.remove(undef.Identifier[0]);\n}\nresult = new PPDefineNode(undef);\nbreak;\ncase PreprocessorID.If:\n\/\/ pp-expression pp-newline conditional-section(opt)\nif (curtok.id == TokenID.LParen) {\nadvance();\n}\nint startCount = lineCount;\nppCondition = false;\n\/\/ todo: account for true, false, ||, &&, ==, !=, !\nIdentifierExpression ifexpr = parseIdentifierOrKeyword();\nif (ppDefs.containsKey(ifexpr.Identifier[0])) {\nppCondition = true;\n}\n\n}\nresult = new PPDefineNode(undef);\nbreak;\ncase PreprocessorID.If:\n\/\/ pp-expression pp-newline conditional-section(opt)\nif (curtok.id == TokenID.LParen) {\nadvance();\n}\nint startCount = lineCount;\nppCondition = false;\n\/\/ todo: account for true, false, ||, &&, ==, !=, !\nIdentifierExpression ifexpr = parseIdentifierOrKeyword();\nif (ppDefs.containsKey(ifexpr.Identifier[0])) {\nppCondition = true;\n}\n\/\/result = new PPIfNode(ParseExpressionToNewline());\nif (curtok.id == TokenID.RParen) {\nadvance();\n}\nif (ppCondition == false) {\n\/\/ skip this block\n\nif (curtok.id == TokenID.LParen) {\nadvance();\n}\nint startCount = lineCount;\nppCondition = false;\n\/\/ todo: account for true, false, ||, &&, ==, !=, !\nIdentifierExpression ifexpr = parseIdentifierOrKeyword();\nif (ppDefs.containsKey(ifexpr.Identifier[0])) {\nppCondition = true;\n}\n\/\/result = new PPIfNode(ParseExpressionToNewline());\nif (curtok.id == TokenID.RParen) {\nadvance();\n}\nif (ppCondition == false) {\n\/\/ skip this block\nSkipToElseOrEndIf();\n}\nbreak;\ncase PreprocessorID.Elif:\n\/\/ pp-expression pp-newline conditional-section(opt)\n\n\/\/ todo: account for true, false, ||, &&, ==, !=, !\nIdentifierExpression ifexpr = parseIdentifierOrKeyword();\nif (ppDefs.containsKey(ifexpr.Identifier[0])) {\nppCondition = true;\n}\n\/\/result = new PPIfNode(ParseExpressionToNewline());\nif (curtok.id == TokenID.RParen) {\nadvance();\n}\nif (ppCondition == false) {\n\/\/ skip this block\nSkipToElseOrEndIf();\n}\nbreak;\ncase PreprocessorID.Elif:\n\/\/ pp-expression pp-newline conditional-section(opt)\nSkipToEOL(startLine);\nbreak;\ncase PreprocessorID.Else:\n\/\/ pp-newline conditional-section(opt)\nif (ppCondition == true) {\n\nbreak;\ncase PreprocessorID.Undef:\n\/\/ conditional-symbol pp-newline\nIdentifierExpression undef = parseIdentifierOrKeyword();\nif (ppDefs.containsKey(undef.Identifier[0])) {\nppDefs.remove(undef.Identifier[0]);\n}\nresult = new PPDefineNode(undef);\nbreak;\ncase PreprocessorID.If:\n\/\/ pp-expression pp-newline conditional-section(opt)\nif (curtok.id == TokenID.LParen) {\nadvance();\n}\nint startCount = lineCount;\nppCondition = false;\n\/\/ todo: account for true, false, ||, &&, ==, !=, !\nIdentifierExpression ifexpr = parseIdentifierOrKeyword();\nif (ppDefs.containsKey(ifexpr.Identifier[0])) {\nppCondition = true;\n}\n\nif (ppCondition == false) {\n\/\/ skip this block\nSkipToElseOrEndIf();\n}\nbreak;\ncase PreprocessorID.Elif:\n\/\/ pp-expression pp-newline conditional-section(opt)\nSkipToEOL(startLine);\nbreak;\ncase PreprocessorID.Else:\n\/\/ pp-newline conditional-section(opt)\nif (ppCondition == true) {\n\/\/ skip this block\nSkipToElseOrEndIf();\n}\nbreak;\ncase PreprocessorID.Endif:\n\/\/ pp-newline\nresult = new PPEndIfNode();\nppCondition = false;\nbreak;\n\n\/\/ todo: account for true, false, ||, &&, ==, !=, !\nIdentifierExpression ifexpr = parseIdentifierOrKeyword();\nif (ppDefs.containsKey(ifexpr.Identifier[0])) {\nppCondition = true;\n}\n\/\/result = new PPIfNode(ParseExpressionToNewline());\nif (curtok.id == TokenID.RParen) {\nadvance();\n}\nif (ppCondition == false) {\n\/\/ skip this block\nSkipToElseOrEndIf();\n}\nbreak;\ncase PreprocessorID.Elif:\n\/\/ pp-expression pp-newline conditional-section(opt)\nSkipToEOL(startLine);\nbreak;\ncase PreprocessorID.Else:\n\/\/ pp-newline conditional-section(opt)\nif (ppCondition == true) {\n\nif (ppCondition == false) {\n\/\/ skip this block\nSkipToElseOrEndIf();\n}\nbreak;\ncase PreprocessorID.Elif:\n\/\/ pp-expression pp-newline conditional-section(opt)\nSkipToEOL(startLine);\nbreak;\ncase PreprocessorID.Else:\n\/\/ pp-newline conditional-section(opt)\nif (ppCondition == true) {\n\/\/ skip this block\nSkipToElseOrEndIf();\n}\nbreak;\ncase PreprocessorID.Endif:\n\/\/ pp-newline\nresult = new PPEndIfNode();\nppCondition = false;\nbreak;\n\n\/\/ skip this block\nSkipToElseOrEndIf();\n}\nbreak;\ncase PreprocessorID.Endif:\n\/\/ pp-newline\nresult = new PPEndIfNode();\nppCondition = false;\nbreak;\ncase PreprocessorID.Line:\n\/\/ line-indicator pp-newline\nSkipToEOL(startLine);\nbreak;\ncase PreprocessorID.Error:\n\/\/ pp-message\nSkipToEOL(startLine);\nbreak;\ncase PreprocessorID.Warning:\n\/\/ pp-message\nSkipToEOL(startLine);\nbreak;\n\ncase PreprocessorID.Endif:\n\/\/ pp-newline\nresult = new PPEndIfNode();\nppCondition = false;\nbreak;\ncase PreprocessorID.Line:\n\/\/ line-indicator pp-newline\nSkipToEOL(startLine);\nbreak;\ncase PreprocessorID.Error:\n\/\/ pp-message\nSkipToEOL(startLine);\nbreak;\ncase PreprocessorID.Warning:\n\/\/ pp-message\nSkipToEOL(startLine);\nbreak;\ncase PreprocessorID.Region:\n\/\/ pp-message\nSkipToEOL(startLine);\nbreak;\n\ncase PreprocessorID.Endif:\n\/\/ pp-newline\nresult = new PPEndIfNode();\nppCondition = false;\nbreak;\ncase PreprocessorID.Line:\n\/\/ line-indicator pp-newline\nSkipToEOL(startLine);\nbreak;\ncase PreprocessorID.Error:\n\/\/ pp-message\nSkipToEOL(startLine);\nbreak;\ncase PreprocessorID.Warning:\n\/\/ pp-message\nSkipToEOL(startLine);\nbreak;\ncase PreprocessorID.Region:\n\/\/ pp-message\nSkipToEOL(startLine);\nbreak;\n\ncase PreprocessorID.Endif:\n\/\/ pp-newline\nresult = new PPEndIfNode();\nppCondition = false;\nbreak;\ncase PreprocessorID.Line:\n\/\/ line-indicator pp-newline\nSkipToEOL(startLine);\nbreak;\ncase PreprocessorID.Error:\n\/\/ pp-message\nSkipToEOL(startLine);\nbreak;\ncase PreprocessorID.Warning:\n\/\/ pp-message\nSkipToEOL(startLine);\nbreak;\ncase PreprocessorID.Region:\n\/\/ pp-message\nSkipToEOL(startLine);\nbreak;\n\ncase PreprocessorID.Endif:\n\/\/ pp-newline\nresult = new PPEndIfNode();\nppCondition = false;\nbreak;\ncase PreprocessorID.Line:\n\/\/ line-indicator pp-newline\nSkipToEOL(startLine);\nbreak;\ncase PreprocessorID.Error:\n\/\/ pp-message\nSkipToEOL(startLine);\nbreak;\ncase PreprocessorID.Warning:\n\/\/ pp-message\nSkipToEOL(startLine);\nbreak;\ncase PreprocessorID.Region:\n\/\/ pp-message\nSkipToEOL(startLine);\nbreak;\n\ncase PreprocessorID.Endif:\n\/\/ pp-newline\nresult = new PPEndIfNode();\nppCondition = false;\nbreak;\ncase PreprocessorID.Line:\n\/\/ line-indicator pp-newline\nSkipToEOL(startLine);\nbreak;\ncase PreprocessorID.Error:\n\/\/ pp-message\nSkipToEOL(startLine);\nbreak;\ncase PreprocessorID.Warning:\n\/\/ pp-message\nSkipToEOL(startLine);\nbreak;\ncase PreprocessorID.Region:\n\/\/ pp-message\nSkipToEOL(startLine);\nbreak;","code_context_20":"private PPNode parsePreprocessorDirective() throws FeatureNotSupportedException {\nPPNode result = null;\nint startLine = lineCount;\ninPPDirective = true;\nadvance(); \/\/ over hash\nIdentifierExpression ie = parseIdentifierOrKeyword();\nString ppKind = ie.Identifier[0];\nbyte id = PreprocessorID.Empty;\nif (preprocessor.containsKey(ppKind)) {\nid = preprocessor.get(ppKind);\n} else {\nReportError(\"Preprocessor directive must be valid identifier, rather than \\\"\" + ppKind + \"\\\".\");\n}\nswitch (id) {\ncase PreprocessorID.Define:\n\/\/ conditional-symbol pp-newline\nIdentifierExpression def = parseIdentifierOrKeyword();\nif (!ppDefs.containsKey(def.Identifier[0])) {\nppDefs.put(def.Identifier[0], PreprocessorID.Empty);\n}\nresult = new PPDefineNode(def);\nbreak;\ncase PreprocessorID.Undef:\n\/\/ conditional-symbol pp-newline\nIdentifierExpression undef = parseIdentifierOrKeyword();\n\nprivate PPNode parsePreprocessorDirective() throws FeatureNotSupportedException {\nPPNode result = null;\nint startLine = lineCount;\ninPPDirective = true;\nadvance(); \/\/ over hash\nIdentifierExpression ie = parseIdentifierOrKeyword();\nString ppKind = ie.Identifier[0];\nbyte id = PreprocessorID.Empty;\nif (preprocessor.containsKey(ppKind)) {\nid = preprocessor.get(ppKind);\n} else {\nReportError(\"Preprocessor directive must be valid identifier, rather than \\\"\" + ppKind + \"\\\".\");\n}\nswitch (id) {\ncase PreprocessorID.Define:\n\/\/ conditional-symbol pp-newline\nIdentifierExpression def = parseIdentifierOrKeyword();\nif (!ppDefs.containsKey(def.Identifier[0])) {\nppDefs.put(def.Identifier[0], PreprocessorID.Empty);\n}\nresult = new PPDefineNode(def);\nbreak;\ncase PreprocessorID.Undef:\n\/\/ conditional-symbol pp-newline\nIdentifierExpression undef = parseIdentifierOrKeyword();\nif (ppDefs.containsKey(undef.Identifier[0])) {\nppDefs.remove(undef.Identifier[0]);\n}\nresult = new PPDefineNode(undef);\nbreak;\ncase PreprocessorID.If:\n\/\/ pp-expression pp-newline conditional-section(opt)\nif (curtok.id == TokenID.LParen) {\nadvance();\n}\nint startCount = lineCount;\n\nprivate PPNode parsePreprocessorDirective() throws FeatureNotSupportedException {\nPPNode result = null;\nint startLine = lineCount;\ninPPDirective = true;\nadvance(); \/\/ over hash\nIdentifierExpression ie = parseIdentifierOrKeyword();\nString ppKind = ie.Identifier[0];\nbyte id = PreprocessorID.Empty;\nif (preprocessor.containsKey(ppKind)) {\nid = preprocessor.get(ppKind);\n} else {\nReportError(\"Preprocessor directive must be valid identifier, rather than \\\"\" + ppKind + \"\\\".\");\n}\nswitch (id) {\ncase PreprocessorID.Define:\n\/\/ conditional-symbol pp-newline\nIdentifierExpression def = parseIdentifierOrKeyword();\nif (!ppDefs.containsKey(def.Identifier[0])) {\nppDefs.put(def.Identifier[0], PreprocessorID.Empty);\n}\nresult = new PPDefineNode(def);\nbreak;\ncase PreprocessorID.Undef:\n\/\/ conditional-symbol pp-newline\nIdentifierExpression undef = parseIdentifierOrKeyword();\nif (ppDefs.containsKey(undef.Identifier[0])) {\nppDefs.remove(undef.Identifier[0]);\n}\nresult = new PPDefineNode(undef);\nbreak;\ncase PreprocessorID.If:\n\/\/ pp-expression pp-newline conditional-section(opt)\nif (curtok.id == TokenID.LParen) {\nadvance();\n}\nint startCount = lineCount;\n\nReportError(\"Preprocessor directive must be valid identifier, rather than \\\"\" + ppKind + \"\\\".\");\n}\nswitch (id) {\ncase PreprocessorID.Define:\n\/\/ conditional-symbol pp-newline\nIdentifierExpression def = parseIdentifierOrKeyword();\nif (!ppDefs.containsKey(def.Identifier[0])) {\nppDefs.put(def.Identifier[0], PreprocessorID.Empty);\n}\nresult = new PPDefineNode(def);\nbreak;\ncase PreprocessorID.Undef:\n\/\/ conditional-symbol pp-newline\nIdentifierExpression undef = parseIdentifierOrKeyword();\nif (ppDefs.containsKey(undef.Identifier[0])) {\nppDefs.remove(undef.Identifier[0]);\n}\nresult = new PPDefineNode(undef);\nbreak;\ncase PreprocessorID.If:\n\/\/ pp-expression pp-newline conditional-section(opt)\nif (curtok.id == TokenID.LParen) {\nadvance();\n}\nint startCount = lineCount;\nppCondition = false;\n\/\/ todo: account for true, false, ||, &&, ==, !=, !\nIdentifierExpression ifexpr = parseIdentifierOrKeyword();\nif (ppDefs.containsKey(ifexpr.Identifier[0])) {\nppCondition = true;\n}\n\/\/result = new PPIfNode(ParseExpressionToNewline());\nif (curtok.id == TokenID.RParen) {\nadvance();\n}\nif (ppCondition == false) {\n\/\/ skip this block\nSkipToElseOrEndIf();\n}\nbreak;\ncase PreprocessorID.Elif:\n\nif (!ppDefs.containsKey(def.Identifier[0])) {\nppDefs.put(def.Identifier[0], PreprocessorID.Empty);\n}\nresult = new PPDefineNode(def);\nbreak;\ncase PreprocessorID.Undef:\n\/\/ conditional-symbol pp-newline\nIdentifierExpression undef = parseIdentifierOrKeyword();\nif (ppDefs.containsKey(undef.Identifier[0])) {\nppDefs.remove(undef.Identifier[0]);\n}\nresult = new PPDefineNode(undef);\nbreak;\ncase PreprocessorID.If:\n\/\/ pp-expression pp-newline conditional-section(opt)\nif (curtok.id == TokenID.LParen) {\nadvance();\n}\nint startCount = lineCount;\nppCondition = false;\n\/\/ todo: account for true, false, ||, &&, ==, !=, !\nIdentifierExpression ifexpr = parseIdentifierOrKeyword();\nif (ppDefs.containsKey(ifexpr.Identifier[0])) {\nppCondition = true;\n}\n\/\/result = new PPIfNode(ParseExpressionToNewline());\nif (curtok.id == TokenID.RParen) {\nadvance();\n}\nif (ppCondition == false) {\n\/\/ skip this block\nSkipToElseOrEndIf();\n}\nbreak;\ncase PreprocessorID.Elif:\n\/\/ pp-expression pp-newline conditional-section(opt)\nSkipToEOL(startLine);\nbreak;\ncase PreprocessorID.Else:\n\/\/ pp-newline conditional-section(opt)\nif (ppCondition == true) {\n\ncase PreprocessorID.Undef:\n\/\/ conditional-symbol pp-newline\nIdentifierExpression undef = parseIdentifierOrKeyword();\nif (ppDefs.containsKey(undef.Identifier[0])) {\nppDefs.remove(undef.Identifier[0]);\n}\nresult = new PPDefineNode(undef);\nbreak;\ncase PreprocessorID.If:\n\/\/ pp-expression pp-newline conditional-section(opt)\nif (curtok.id == TokenID.LParen) {\nadvance();\n}\nint startCount = lineCount;\nppCondition = false;\n\/\/ todo: account for true, false, ||, &&, ==, !=, !\nIdentifierExpression ifexpr = parseIdentifierOrKeyword();\nif (ppDefs.containsKey(ifexpr.Identifier[0])) {\nppCondition = true;\n}\n\/\/result = new PPIfNode(ParseExpressionToNewline());\nif (curtok.id == TokenID.RParen) {\nadvance();\n}\nif (ppCondition == false) {\n\/\/ skip this block\nSkipToElseOrEndIf();\n}\nbreak;\ncase PreprocessorID.Elif:\n\/\/ pp-expression pp-newline conditional-section(opt)\nSkipToEOL(startLine);\nbreak;\ncase PreprocessorID.Else:\n\/\/ pp-newline conditional-section(opt)\nif (ppCondition == true) {\n\/\/ skip this block\nSkipToElseOrEndIf();\n}\nbreak;\ncase PreprocessorID.Endif:\n\n}\nresult = new PPDefineNode(undef);\nbreak;\ncase PreprocessorID.If:\n\/\/ pp-expression pp-newline conditional-section(opt)\nif (curtok.id == TokenID.LParen) {\nadvance();\n}\nint startCount = lineCount;\nppCondition = false;\n\/\/ todo: account for true, false, ||, &&, ==, !=, !\nIdentifierExpression ifexpr = parseIdentifierOrKeyword();\nif (ppDefs.containsKey(ifexpr.Identifier[0])) {\nppCondition = true;\n}\n\/\/result = new PPIfNode(ParseExpressionToNewline());\nif (curtok.id == TokenID.RParen) {\nadvance();\n}\nif (ppCondition == false) {\n\/\/ skip this block\nSkipToElseOrEndIf();\n}\nbreak;\ncase PreprocessorID.Elif:\n\/\/ pp-expression pp-newline conditional-section(opt)\nSkipToEOL(startLine);\nbreak;\ncase PreprocessorID.Else:\n\/\/ pp-newline conditional-section(opt)\nif (ppCondition == true) {\n\/\/ skip this block\nSkipToElseOrEndIf();\n}\nbreak;\ncase PreprocessorID.Endif:\n\/\/ pp-newline\nresult = new PPEndIfNode();\nppCondition = false;\nbreak;\ncase PreprocessorID.Line:\n\nReportError(\"Preprocessor directive must be valid identifier, rather than \\\"\" + ppKind + \"\\\".\");\n}\nswitch (id) {\ncase PreprocessorID.Define:\n\/\/ conditional-symbol pp-newline\nIdentifierExpression def = parseIdentifierOrKeyword();\nif (!ppDefs.containsKey(def.Identifier[0])) {\nppDefs.put(def.Identifier[0], PreprocessorID.Empty);\n}\nresult = new PPDefineNode(def);\nbreak;\ncase PreprocessorID.Undef:\n\/\/ conditional-symbol pp-newline\nIdentifierExpression undef = parseIdentifierOrKeyword();\nif (ppDefs.containsKey(undef.Identifier[0])) {\nppDefs.remove(undef.Identifier[0]);\n}\nresult = new PPDefineNode(undef);\nbreak;\ncase PreprocessorID.If:\n\/\/ pp-expression pp-newline conditional-section(opt)\nif (curtok.id == TokenID.LParen) {\nadvance();\n}\nint startCount = lineCount;\nppCondition = false;\n\/\/ todo: account for true, false, ||, &&, ==, !=, !\nIdentifierExpression ifexpr = parseIdentifierOrKeyword();\nif (ppDefs.containsKey(ifexpr.Identifier[0])) {\nppCondition = true;\n}\n\/\/result = new PPIfNode(ParseExpressionToNewline());\nif (curtok.id == TokenID.RParen) {\nadvance();\n}\nif (ppCondition == false) {\n\/\/ skip this block\nSkipToElseOrEndIf();\n}\nbreak;\ncase PreprocessorID.Elif:\n\nppCondition = false;\n\/\/ todo: account for true, false, ||, &&, ==, !=, !\nIdentifierExpression ifexpr = parseIdentifierOrKeyword();\nif (ppDefs.containsKey(ifexpr.Identifier[0])) {\nppCondition = true;\n}\n\/\/result = new PPIfNode(ParseExpressionToNewline());\nif (curtok.id == TokenID.RParen) {\nadvance();\n}\nif (ppCondition == false) {\n\/\/ skip this block\nSkipToElseOrEndIf();\n}\nbreak;\ncase PreprocessorID.Elif:\n\/\/ pp-expression pp-newline conditional-section(opt)\nSkipToEOL(startLine);\nbreak;\ncase PreprocessorID.Else:\n\/\/ pp-newline conditional-section(opt)\nif (ppCondition == true) {\n\/\/ skip this block\nSkipToElseOrEndIf();\n}\nbreak;\ncase PreprocessorID.Endif:\n\/\/ pp-newline\nresult = new PPEndIfNode();\nppCondition = false;\nbreak;\ncase PreprocessorID.Line:\n\/\/ line-indicator pp-newline\nSkipToEOL(startLine);\nbreak;\ncase PreprocessorID.Error:\n\/\/ pp-message\nSkipToEOL(startLine);\nbreak;\ncase PreprocessorID.Warning:\n\/\/ pp-message\n\n}\nresult = new PPDefineNode(undef);\nbreak;\ncase PreprocessorID.If:\n\/\/ pp-expression pp-newline conditional-section(opt)\nif (curtok.id == TokenID.LParen) {\nadvance();\n}\nint startCount = lineCount;\nppCondition = false;\n\/\/ todo: account for true, false, ||, &&, ==, !=, !\nIdentifierExpression ifexpr = parseIdentifierOrKeyword();\nif (ppDefs.containsKey(ifexpr.Identifier[0])) {\nppCondition = true;\n}\n\/\/result = new PPIfNode(ParseExpressionToNewline());\nif (curtok.id == TokenID.RParen) {\nadvance();\n}\nif (ppCondition == false) {\n\/\/ skip this block\nSkipToElseOrEndIf();\n}\nbreak;\ncase PreprocessorID.Elif:\n\/\/ pp-expression pp-newline conditional-section(opt)\nSkipToEOL(startLine);\nbreak;\ncase PreprocessorID.Else:\n\/\/ pp-newline conditional-section(opt)\nif (ppCondition == true) {\n\/\/ skip this block\nSkipToElseOrEndIf();\n}\nbreak;\ncase PreprocessorID.Endif:\n\/\/ pp-newline\nresult = new PPEndIfNode();\nppCondition = false;\nbreak;\ncase PreprocessorID.Line:\n\nppCondition = false;\n\/\/ todo: account for true, false, ||, &&, ==, !=, !\nIdentifierExpression ifexpr = parseIdentifierOrKeyword();\nif (ppDefs.containsKey(ifexpr.Identifier[0])) {\nppCondition = true;\n}\n\/\/result = new PPIfNode(ParseExpressionToNewline());\nif (curtok.id == TokenID.RParen) {\nadvance();\n}\nif (ppCondition == false) {\n\/\/ skip this block\nSkipToElseOrEndIf();\n}\nbreak;\ncase PreprocessorID.Elif:\n\/\/ pp-expression pp-newline conditional-section(opt)\nSkipToEOL(startLine);\nbreak;\ncase PreprocessorID.Else:\n\/\/ pp-newline conditional-section(opt)\nif (ppCondition == true) {\n\/\/ skip this block\nSkipToElseOrEndIf();\n}\nbreak;\ncase PreprocessorID.Endif:\n\/\/ pp-newline\nresult = new PPEndIfNode();\nppCondition = false;\nbreak;\ncase PreprocessorID.Line:\n\/\/ line-indicator pp-newline\nSkipToEOL(startLine);\nbreak;\ncase PreprocessorID.Error:\n\/\/ pp-message\nSkipToEOL(startLine);\nbreak;\ncase PreprocessorID.Warning:\n\/\/ pp-message\n\nSkipToElseOrEndIf();\n}\nbreak;\ncase PreprocessorID.Elif:\n\/\/ pp-expression pp-newline conditional-section(opt)\nSkipToEOL(startLine);\nbreak;\ncase PreprocessorID.Else:\n\/\/ pp-newline conditional-section(opt)\nif (ppCondition == true) {\n\/\/ skip this block\nSkipToElseOrEndIf();\n}\nbreak;\ncase PreprocessorID.Endif:\n\/\/ pp-newline\nresult = new PPEndIfNode();\nppCondition = false;\nbreak;\ncase PreprocessorID.Line:\n\/\/ line-indicator pp-newline\nSkipToEOL(startLine);\nbreak;\ncase PreprocessorID.Error:\n\/\/ pp-message\nSkipToEOL(startLine);\nbreak;\ncase PreprocessorID.Warning:\n\/\/ pp-message\nSkipToEOL(startLine);\nbreak;\ncase PreprocessorID.Region:\n\/\/ pp-message\nSkipToEOL(startLine);\nbreak;\ncase PreprocessorID.Endregion:\n\/\/ pp-message\nSkipToEOL(startLine);\nbreak;\ncase PreprocessorID.Pragma:\n\/\/ pp-message\n\n\/\/ pp-expression pp-newline conditional-section(opt)\nSkipToEOL(startLine);\nbreak;\ncase PreprocessorID.Else:\n\/\/ pp-newline conditional-section(opt)\nif (ppCondition == true) {\n\/\/ skip this block\nSkipToElseOrEndIf();\n}\nbreak;\ncase PreprocessorID.Endif:\n\/\/ pp-newline\nresult = new PPEndIfNode();\nppCondition = false;\nbreak;\ncase PreprocessorID.Line:\n\/\/ line-indicator pp-newline\nSkipToEOL(startLine);\nbreak;\ncase PreprocessorID.Error:\n\/\/ pp-message\nSkipToEOL(startLine);\nbreak;\ncase PreprocessorID.Warning:\n\/\/ pp-message\nSkipToEOL(startLine);\nbreak;\ncase PreprocessorID.Region:\n\/\/ pp-message\nSkipToEOL(startLine);\nbreak;\ncase PreprocessorID.Endregion:\n\/\/ pp-message\nSkipToEOL(startLine);\nbreak;\ncase PreprocessorID.Pragma:\n\/\/ pp-message\nSkipToEOL(startLine);\nbreak;\ndefault:\nbreak;\n\n\/\/ pp-expression pp-newline conditional-section(opt)\nSkipToEOL(startLine);\nbreak;\ncase PreprocessorID.Else:\n\/\/ pp-newline conditional-section(opt)\nif (ppCondition == true) {\n\/\/ skip this block\nSkipToElseOrEndIf();\n}\nbreak;\ncase PreprocessorID.Endif:\n\/\/ pp-newline\nresult = new PPEndIfNode();\nppCondition = false;\nbreak;\ncase PreprocessorID.Line:\n\/\/ line-indicator pp-newline\nSkipToEOL(startLine);\nbreak;\ncase PreprocessorID.Error:\n\/\/ pp-message\nSkipToEOL(startLine);\nbreak;\ncase PreprocessorID.Warning:\n\/\/ pp-message\nSkipToEOL(startLine);\nbreak;\ncase PreprocessorID.Region:\n\/\/ pp-message\nSkipToEOL(startLine);\nbreak;\ncase PreprocessorID.Endregion:\n\/\/ pp-message\nSkipToEOL(startLine);\nbreak;\ncase PreprocessorID.Pragma:\n\/\/ pp-message\nSkipToEOL(startLine);\nbreak;\ndefault:\nbreak;\n\n\/\/ pp-expression pp-newline conditional-section(opt)\nSkipToEOL(startLine);\nbreak;\ncase PreprocessorID.Else:\n\/\/ pp-newline conditional-section(opt)\nif (ppCondition == true) {\n\/\/ skip this block\nSkipToElseOrEndIf();\n}\nbreak;\ncase PreprocessorID.Endif:\n\/\/ pp-newline\nresult = new PPEndIfNode();\nppCondition = false;\nbreak;\ncase PreprocessorID.Line:\n\/\/ line-indicator pp-newline\nSkipToEOL(startLine);\nbreak;\ncase PreprocessorID.Error:\n\/\/ pp-message\nSkipToEOL(startLine);\nbreak;\ncase PreprocessorID.Warning:\n\/\/ pp-message\nSkipToEOL(startLine);\nbreak;\ncase PreprocessorID.Region:\n\/\/ pp-message\nSkipToEOL(startLine);\nbreak;\ncase PreprocessorID.Endregion:\n\/\/ pp-message\nSkipToEOL(startLine);\nbreak;\ncase PreprocessorID.Pragma:\n\/\/ pp-message\nSkipToEOL(startLine);\nbreak;\ndefault:\nbreak;\n\n\/\/ pp-expression pp-newline conditional-section(opt)\nSkipToEOL(startLine);\nbreak;\ncase PreprocessorID.Else:\n\/\/ pp-newline conditional-section(opt)\nif (ppCondition == true) {\n\/\/ skip this block\nSkipToElseOrEndIf();\n}\nbreak;\ncase PreprocessorID.Endif:\n\/\/ pp-newline\nresult = new PPEndIfNode();\nppCondition = false;\nbreak;\ncase PreprocessorID.Line:\n\/\/ line-indicator pp-newline\nSkipToEOL(startLine);\nbreak;\ncase PreprocessorID.Error:\n\/\/ pp-message\nSkipToEOL(startLine);\nbreak;\ncase PreprocessorID.Warning:\n\/\/ pp-message\nSkipToEOL(startLine);\nbreak;\ncase PreprocessorID.Region:\n\/\/ pp-message\nSkipToEOL(startLine);\nbreak;\ncase PreprocessorID.Endregion:\n\/\/ pp-message\nSkipToEOL(startLine);\nbreak;\ncase PreprocessorID.Pragma:\n\/\/ pp-message\nSkipToEOL(startLine);\nbreak;\ndefault:\nbreak;\n\n\/\/ pp-expression pp-newline conditional-section(opt)\nSkipToEOL(startLine);\nbreak;\ncase PreprocessorID.Else:\n\/\/ pp-newline conditional-section(opt)\nif (ppCondition == true) {\n\/\/ skip this block\nSkipToElseOrEndIf();\n}\nbreak;\ncase PreprocessorID.Endif:\n\/\/ pp-newline\nresult = new PPEndIfNode();\nppCondition = false;\nbreak;\ncase PreprocessorID.Line:\n\/\/ line-indicator pp-newline\nSkipToEOL(startLine);\nbreak;\ncase PreprocessorID.Error:\n\/\/ pp-message\nSkipToEOL(startLine);\nbreak;\ncase PreprocessorID.Warning:\n\/\/ pp-message\nSkipToEOL(startLine);\nbreak;\ncase PreprocessorID.Region:\n\/\/ pp-message\nSkipToEOL(startLine);\nbreak;\ncase PreprocessorID.Endregion:\n\/\/ pp-message\nSkipToEOL(startLine);\nbreak;\ncase PreprocessorID.Pragma:\n\/\/ pp-message\nSkipToEOL(startLine);\nbreak;\ndefault:\nbreak;","label":[0,1,0,0]}
{"id":16146,"original_code":"public void create(File dstFolder, List<ExcelTable> tables, ExcelSproutOptions options) {\n        Random rnd = new Random(options.getRandomSeed());\n        \/\/there are many tables\n        \/\/we have to decide: what table to what sheet, and what sheet to what workbook\n        \/\/we should not repeat tables about the same class, so there are possible groups\n        \/\/maybe a workbook should be full to have the best expected.ttl from the original model\n        \/\/here we calculate: what table to what workbook\n        List<List<ExcelTable>> workbookClusters = getWorkbookClusters(tables, rnd);\n        \/\/now we have to decide which table will be in which sheet\n        \/\/the cleanest way is to have a table per sheet\n        \/\/TODO make this variable so more messy version are possible\n        List<List<List<ExcelTable>>> workbookSheetTables = new ArrayList<>();\n        for (List<ExcelTable> workbookTables : workbookClusters) {\n            List<List<ExcelTable>> sheetTables = new ArrayList<>();\n            for (ExcelTable tbl : workbookTables) {\n                List<ExcelTable> sheet = Arrays.asList(tbl);\n                sheetTables.add(sheet);\n            }\n            workbookSheetTables.add(sheetTables);\n        }\n        int maxDigits = String.valueOf(workbookSheetTables.size() - 1).length();\n        Map<List<ExcelTable>, ExcelGeneratorSheetConfig> sheetConfigMap = new HashMap<>();\n        \/\/now we use the ExcelGenerator to generate the workbooks\n        ExcelGenerator excelGenerator = new ExcelGenerator();\n        for (int i = 0; i < workbookSheetTables.size(); i++) {\n            List<List<ExcelTable>> sheets = workbookSheetTables.get(i);\n            \/\/create a config for this workbook\n            ExcelGeneratorWorkbookConfig workbookConf = new ExcelGeneratorWorkbookConfig();\n            \/\/TODO configurable\n            workbookConf.setFileName(\"workbook.xlsx\");\n            for (List<ExcelTable> sheet : sheets) {\n                ExcelGeneratorSheetConfig sheetConf = new ExcelGeneratorSheetConfig();\n                sheetConfigMap.put(sheet, sheetConf);\n                StringBuilder sheetNameSB = new StringBuilder();\n                \/\/TODO a second table in the sheet means we maybe have to move the offset\n                \/\/      so that it will not overlap\n                for (int k = 0; k < sheet.size(); k++) {\n                    ExcelTable excelTable = sheet.get(k);\n                    ExcelGeneratorTableConfig tableConf = new ExcelGeneratorTableConfig();\n                    \/\/TODO maybe make a getSingleOrDefault method\n                    Point offset = (Point) excelTable.getSetup().getOrDefault(\"offset\", new Point(0, 0));\n                    tableConf.setOffset(offset);\n                    \/\/draw the ExcelCell matrix from ExcelTable\n                    tableConf.setStaticCellDrawer(d -> {\n                        \/\/it uses the tableConf offset\n                        d.exceltable(excelTable, options);\n                    });\n                    sheetConf.getTableConfigs().add(tableConf);\n                    \/\/TODO if only one table with one class: add provenance sheetname -> insts a class. (for all insts)\n                    ClassConfig classConfig = excelTable.getSetup().getOrThrow(\"classes\", ClassConfig.class);\n                    if (classConfig.hasLabel()) {\n                        sheetNameSB.append(classConfig.getLabel());\n                    } else {\n                        throw new RuntimeException(\"ClassConfig should give a label to name the sheet\");\n                    }\n                    \/\/in one sheet multiple tables could be existing\n                    if (k != sheet.size() - 1) {\n                        sheetNameSB.append(\" & \");\n                    }\n                }\n                \/\/sheet name comes from table content\n                sheetConf.setSheetName(sheetNameSB.toString());\n                workbookConf.getSheetConfigs().add(sheetConf);\n            }\/\/per sheet\n            ExcelGeneratorResult result = excelGenerator.generate(null, workbookConf);\n            \/\/System.out.println(\"save workbook \" + i);\n            \/\/no extra folder when only one workbook\n            File workbookFolder = workbookSheetTables.size() == 1 ? dstFolder : new File(dstFolder, String.format(\"%0\" + maxDigits + \"d\", i));\n            result.saveExcel(workbookFolder);\n            \/\/write provenance =================================================\n            Model expectedModel = null;\n            Model provenanceModel = null;\n            CSVPrinter provenanceCSV = null;\n            if (options.isWriteExpectedModel()) {\n                expectedModel = ModelFactory.createDefaultModel();\n                expectedModel.setNsPrefixes(options.getPrefixMapping());\n                expectedModel.setNsPrefixes(PrefixMapping.Standard);\n            }\n            if (options.isWriteProvenanceModel()) {\n                provenanceModel = ModelFactory.createDefaultModel();\n                provenanceModel.setNsPrefixes(options.getPrefixMapping());\n                provenanceModel.setNsPrefix(\"prov\", PROV.NS);\n                provenanceModel.setNsPrefix(\"csvw\", CSVW.NS);\n                provenanceModel.setNsPrefix(\"ss\", SS.NS);\n                provenanceModel.setNsPrefixes(PrefixMapping.Standard);\n            }\n            if (options.isWriteProvenanceCSV()) {\n                try {\n                    provenanceCSV = CSVFormat.DEFAULT.print(\n                            new OutputStreamWriter(\n                                    new GZIPOutputStream(\n                                            new FileOutputStream(\n                                                    new File(workbookFolder, \"provenance.csv.gz\")\n                                            ))));\n                    csvProvenanceHeader(provenanceCSV);\n                } catch (IOException ex) {\n                    throw new RuntimeException(ex);\n                }\n            }\n            \/\/used in rdfProvenance for fast lookup reified statements\n            Map<Statement, Resource> stmt2res = new HashMap<>();\n            \/\/need here sheetname for provenance\n            for (List<ExcelTable> sheet : sheets) {\n                ExcelGeneratorSheetConfig sheetConfig = sheetConfigMap.get(sheet);\n                for (ExcelTable table : sheet) {\n                    for (Entry<ExcelCell, Provenance> cell2prov : table.getCellProvMap().entrySet()) {\n                        ExcelCell cell = cell2prov.getKey();\n                        Provenance prov = cell2prov.getValue();\n                        if (cell.getAddress() == null) {\n                            \/\/this was a temporary cell created for a merge \n                            \/\/in TableGenerator putMultipleObjects method\n                            continue;\n                        }\n                        if (prov.getStatements().isEmpty()) {\n                            \/\/no provenance information for this cell\n                            continue;\n                        }\n                        if (options.isWriteExpectedModel()) {\n                            expectedModel.add(prov.getStatements());\n                        }\n                        if (options.isWriteProvenanceModel()) {\n                            rdfProvenance(cell, sheetConfig.getSheetName(), prov, stmt2res, provenanceModel);\n                        }\n                        if (options.isWriteProvenanceCSV()) {\n                            csvProvenance(cell, sheetConfig.getSheetName(), prov, provenanceCSV, provenanceModel);\n                        }\n                    }\n                }\n            }\n            \/\/write to files\n            if (options.isWriteExpectedModel()) {\n                File file = new File(workbookFolder, \"expected.ttl.gz\");\n                try (OutputStream os = file.getName().endsWith(\"gz\") ? new GZIPOutputStream(new FileOutputStream(file)) : new FileOutputStream(file)) {\n                    expectedModel.write(os, \"TTL\");\n                } catch (IOException ex) {\n                    throw new RuntimeException(ex);\n                }\n            }\n            if (options.isWriteProvenanceModel()) {\n                File file = new File(workbookFolder, \"provenance.ttl.gz\");\n                try (OutputStream os = file.getName().endsWith(\"gz\") ? new GZIPOutputStream(new FileOutputStream(file)) : new FileOutputStream(file)) {\n                    provenanceModel.write(os, \"TTL\");\n                } catch (IOException ex) {\n                    throw new RuntimeException(ex);\n                }\n            }\n            if (options.isWriteProvenanceCSV()) {\n                try {\n                    provenanceCSV.close();\n                } catch (IOException ex) {\n                    throw new RuntimeException(ex);\n                }\n            }\n            if (options.isWriteGenerationSummaryJson()) {\n                \/\/key is sheet name\n                JSONObject perSheetPatternUsage = new JSONObject();\n                JsonUtility.forceLinkedHashMap(perSheetPatternUsage);\n                for (List<ExcelTable> sheet : sheets) {\n                    ExcelGeneratorSheetConfig sheetConfig = sheetConfigMap.get(sheet);\n                    \/\/count how often\n                    Map<String, Map<Object, Integer>> pattern2value2count = new HashMap<>();\n                    for (ExcelTable tbl : sheet) {\n                        for (Entry<ExcelCell, Provenance> entry : tbl.getCellProvMap().entrySet()) {\n                            \/\/skip the ones with no prov and no address (temp cells)\n                            if (entry.getKey().getAddress() == null || entry.getValue().getStatements().isEmpty()) {\n                                continue;\n                            }\n                            for (Entry<String, Object> e : entry.getValue().getUsedPatterns().entrySet()) {\n                                Object val = e.getValue();\n                                if(val instanceof JSONArray) {\n                                    \/\/because json array hash is always different\n                                    val = val.toString();\n                                }\n                                Map<Object, Integer> value2count = pattern2value2count.computeIfAbsent(e.getKey(), k -> new HashMap<>());\n                                value2count.put(val, value2count.getOrDefault(val, 0) + 1);\n                            }\n                        }\n                    }\n                    JSONObject patternUsage = new JSONObject();\n                    JsonUtility.forceLinkedHashMap(patternUsage);\n                    List<Entry<String, Map<Object, Integer>>> pattern2value2countList = new ArrayList<>(pattern2value2count.entrySet());\n                    pattern2value2countList.sort((a,b) -> a.getKey().compareTo(b.getKey()));\n                    for (Entry<String, Map<Object, Integer>> pattern2value2countEntry : pattern2value2countList) {\n                        JSONArray array = new JSONArray();\n                        for (Entry<Object, Integer> e : pattern2value2countEntry.getValue().entrySet()) {\n                            JSONObject v2c = new JSONObject();\n                            JsonUtility.forceLinkedHashMap(v2c);\n                            v2c.put(\"value\", e.getKey());\n                            v2c.put(\"count\", e.getValue());\n                            array.put(v2c);\n                        }\n                        patternUsage.put(pattern2value2countEntry.getKey(), array);\n                    }\n                    perSheetPatternUsage.put(sheetConfig.getSheetName(), patternUsage);\n                }\n                options.getGenerationSummary().put(\"patternUsagePerSheet\", perSheetPatternUsage);\n                File file = new File(workbookFolder, \"summary.json\");\n                try {\n                    FileUtils.writeStringToFile(file, options.getGenerationSummary().toString(2), StandardCharsets.UTF_8);\n                } catch (IOException ex) {\n                    throw new RuntimeException(ex);\n                }\n            }\n        }\/\/per workbook\n    }","code":"public void create(File dstFolder, List<ExcelTable> tables, ExcelSproutOptions options) {\n        Random rnd = new Random(options.getRandomSeed());\n       \n       \n       \n       \n       \n        List<List<ExcelTable>> workbookClusters = getWorkbookClusters(tables, rnd);\n       \n       \n       \n        List<List<List<ExcelTable>>> workbookSheetTables = new ArrayList<>();\n        for (List<ExcelTable> workbookTables : workbookClusters) {\n            List<List<ExcelTable>> sheetTables = new ArrayList<>();\n            for (ExcelTable tbl : workbookTables) {\n                List<ExcelTable> sheet = Arrays.asList(tbl);\n                sheetTables.add(sheet);\n            }\n            workbookSheetTables.add(sheetTables);\n        }\n        int maxDigits = String.valueOf(workbookSheetTables.size() - 1).length();\n        Map<List<ExcelTable>, ExcelGeneratorSheetConfig> sheetConfigMap = new HashMap<>();\n       \n        ExcelGenerator excelGenerator = new ExcelGenerator();\n        for (int i = 0; i < workbookSheetTables.size(); i++) {\n            List<List<ExcelTable>> sheets = workbookSheetTables.get(i);\n           \n            ExcelGeneratorWorkbookConfig workbookConf = new ExcelGeneratorWorkbookConfig();\n           \n            workbookConf.setFileName(\"workbook.xlsx\");\n            for (List<ExcelTable> sheet : sheets) {\n                ExcelGeneratorSheetConfig sheetConf = new ExcelGeneratorSheetConfig();\n                sheetConfigMap.put(sheet, sheetConf);\n                StringBuilder sheetNameSB = new StringBuilder();\n               \n               \n                for (int k = 0; k < sheet.size(); k++) {\n                    ExcelTable excelTable = sheet.get(k);\n                    ExcelGeneratorTableConfig tableConf = new ExcelGeneratorTableConfig();\n                   \n                    Point offset = (Point) excelTable.getSetup().getOrDefault(\"offset\", new Point(0, 0));\n                    tableConf.setOffset(offset);\n                   \n                    tableConf.setStaticCellDrawer(d -> {\n                       \n                        d.exceltable(excelTable, options);\n                    });\n                    sheetConf.getTableConfigs().add(tableConf);\n                   \n                    ClassConfig classConfig = excelTable.getSetup().getOrThrow(\"classes\", ClassConfig.class);\n                    if (classConfig.hasLabel()) {\n                        sheetNameSB.append(classConfig.getLabel());\n                    } else {\n                        throw new RuntimeException(\"ClassConfig should give a label to name the sheet\");\n                    }\n                   \n                    if (k != sheet.size() - 1) {\n                        sheetNameSB.append(\" & \");\n                    }\n                }\n               \n                sheetConf.setSheetName(sheetNameSB.toString());\n                workbookConf.getSheetConfigs().add(sheetConf);\n            \n            ExcelGeneratorResult result = excelGenerator.generate(null, workbookConf);\n           \n           \n            File workbookFolder = workbookSheetTables.size() == 1 ? dstFolder : new File(dstFolder, String.format(\"%0\" + maxDigits + \"d\", i));\n            result.saveExcel(workbookFolder);\n           \n            Model expectedModel = null;\n            Model provenanceModel = null;\n            CSVPrinter provenanceCSV = null;\n            if (options.isWriteExpectedModel()) {\n                expectedModel = ModelFactory.createDefaultModel();\n                expectedModel.setNsPrefixes(options.getPrefixMapping());\n                expectedModel.setNsPrefixes(PrefixMapping.Standard);\n            }\n            if (options.isWriteProvenanceModel()) {\n                provenanceModel = ModelFactory.createDefaultModel();\n                provenanceModel.setNsPrefixes(options.getPrefixMapping());\n                provenanceModel.setNsPrefix(\"prov\", PROV.NS);\n                provenanceModel.setNsPrefix(\"csvw\", CSVW.NS);\n                provenanceModel.setNsPrefix(\"ss\", SS.NS);\n                provenanceModel.setNsPrefixes(PrefixMapping.Standard);\n            }\n            if (options.isWriteProvenanceCSV()) {\n                try {\n                    provenanceCSV = CSVFormat.DEFAULT.print(\n                            new OutputStreamWriter(\n                                    new GZIPOutputStream(\n                                            new FileOutputStream(\n                                                    new File(workbookFolder, \"provenance.csv.gz\")\n                                            ))));\n                    csvProvenanceHeader(provenanceCSV);\n                } catch (IOException ex) {\n                    throw new RuntimeException(ex);\n                }\n            }\n           \n            Map<Statement, Resource> stmt2res = new HashMap<>();\n           \n            for (List<ExcelTable> sheet : sheets) {\n                ExcelGeneratorSheetConfig sheetConfig = sheetConfigMap.get(sheet);\n                for (ExcelTable table : sheet) {\n                    for (Entry<ExcelCell, Provenance> cell2prov : table.getCellProvMap().entrySet()) {\n                        ExcelCell cell = cell2prov.getKey();\n                        Provenance prov = cell2prov.getValue();\n                        if (cell.getAddress() == null) {\n                           \n                           \n                            continue;\n                        }\n                        if (prov.getStatements().isEmpty()) {\n                           \n                            continue;\n                        }\n                        if (options.isWriteExpectedModel()) {\n                            expectedModel.add(prov.getStatements());\n                        }\n                        if (options.isWriteProvenanceModel()) {\n                            rdfProvenance(cell, sheetConfig.getSheetName(), prov, stmt2res, provenanceModel);\n                        }\n                        if (options.isWriteProvenanceCSV()) {\n                            csvProvenance(cell, sheetConfig.getSheetName(), prov, provenanceCSV, provenanceModel);\n                        }\n                    }\n                }\n            }\n           \n            if (options.isWriteExpectedModel()) {\n                File file = new File(workbookFolder, \"expected.ttl.gz\");\n                try (OutputStream os = file.getName().endsWith(\"gz\") ? new GZIPOutputStream(new FileOutputStream(file)) : new FileOutputStream(file)) {\n                    expectedModel.write(os, \"TTL\");\n                } catch (IOException ex) {\n                    throw new RuntimeException(ex);\n                }\n            }\n            if (options.isWriteProvenanceModel()) {\n                File file = new File(workbookFolder, \"provenance.ttl.gz\");\n                try (OutputStream os = file.getName().endsWith(\"gz\") ? new GZIPOutputStream(new FileOutputStream(file)) : new FileOutputStream(file)) {\n                    provenanceModel.write(os, \"TTL\");\n                } catch (IOException ex) {\n                    throw new RuntimeException(ex);\n                }\n            }\n            if (options.isWriteProvenanceCSV()) {\n                try {\n                    provenanceCSV.close();\n                } catch (IOException ex) {\n                    throw new RuntimeException(ex);\n                }\n            }\n            if (options.isWriteGenerationSummaryJson()) {\n               \n                JSONObject perSheetPatternUsage = new JSONObject();\n                JsonUtility.forceLinkedHashMap(perSheetPatternUsage);\n                for (List<ExcelTable> sheet : sheets) {\n                    ExcelGeneratorSheetConfig sheetConfig = sheetConfigMap.get(sheet);\n                   \n                    Map<String, Map<Object, Integer>> pattern2value2count = new HashMap<>();\n                    for (ExcelTable tbl : sheet) {\n                        for (Entry<ExcelCell, Provenance> entry : tbl.getCellProvMap().entrySet()) {\n                           \n                            if (entry.getKey().getAddress() == null || entry.getValue().getStatements().isEmpty()) {\n                                continue;\n                            }\n                            for (Entry<String, Object> e : entry.getValue().getUsedPatterns().entrySet()) {\n                                Object val = e.getValue();\n                                if(val instanceof JSONArray) {\n                                   \n                                    val = val.toString();\n                                }\n                                Map<Object, Integer> value2count = pattern2value2count.computeIfAbsent(e.getKey(), k -> new HashMap<>());\n                                value2count.put(val, value2count.getOrDefault(val, 0) + 1);\n                            }\n                        }\n                    }\n                    JSONObject patternUsage = new JSONObject();\n                    JsonUtility.forceLinkedHashMap(patternUsage);\n                    List<Entry<String, Map<Object, Integer>>> pattern2value2countList = new ArrayList<>(pattern2value2count.entrySet());\n                    pattern2value2countList.sort((a,b) -> a.getKey().compareTo(b.getKey()));\n                    for (Entry<String, Map<Object, Integer>> pattern2value2countEntry : pattern2value2countList) {\n                        JSONArray array = new JSONArray();\n                        for (Entry<Object, Integer> e : pattern2value2countEntry.getValue().entrySet()) {\n                            JSONObject v2c = new JSONObject();\n                            JsonUtility.forceLinkedHashMap(v2c);\n                            v2c.put(\"value\", e.getKey());\n                            v2c.put(\"count\", e.getValue());\n                            array.put(v2c);\n                        }\n                        patternUsage.put(pattern2value2countEntry.getKey(), array);\n                    }\n                    perSheetPatternUsage.put(sheetConfig.getSheetName(), patternUsage);\n                }\n                options.getGenerationSummary().put(\"patternUsagePerSheet\", perSheetPatternUsage);\n                File file = new File(workbookFolder, \"summary.json\");\n                try {\n                    FileUtils.writeStringToFile(file, options.getGenerationSummary().toString(2), StandardCharsets.UTF_8);\n                } catch (IOException ex) {\n                    throw new RuntimeException(ex);\n                }\n            }\n        \n    }","cleancode":"public void create(file dstfolder, list<exceltable> tables, excelsproutoptions options) { random rnd = new random(options.getrandomseed()); list<list<exceltable>> workbookclusters = getworkbookclusters(tables, rnd); list<list<list<exceltable>>> workbooksheettables = new arraylist<>(); for (list<exceltable> workbooktables : workbookclusters) { list<list<exceltable>> sheettables = new arraylist<>(); for (exceltable tbl : workbooktables) { list<exceltable> sheet = arrays.aslist(tbl); sheettables.add(sheet); } workbooksheettables.add(sheettables); } int maxdigits = string.valueof(workbooksheettables.size() - 1).length(); map<list<exceltable>, excelgeneratorsheetconfig> sheetconfigmap = new hashmap<>(); excelgenerator excelgenerator = new excelgenerator(); for (int i = 0; i < workbooksheettables.size(); i++) { list<list<exceltable>> sheets = workbooksheettables.get(i); excelgeneratorworkbookconfig workbookconf = new excelgeneratorworkbookconfig(); workbookconf.setfilename(\"workbook.xlsx\"); for (list<exceltable> sheet : sheets) { excelgeneratorsheetconfig sheetconf = new excelgeneratorsheetconfig(); sheetconfigmap.put(sheet, sheetconf); stringbuilder sheetnamesb = new stringbuilder(); for (int k = 0; k < sheet.size(); k++) { exceltable exceltable = sheet.get(k); excelgeneratortableconfig tableconf = new excelgeneratortableconfig(); point offset = (point) exceltable.getsetup().getordefault(\"offset\", new point(0, 0)); tableconf.setoffset(offset); tableconf.setstaticcelldrawer(d -> { d.exceltable(exceltable, options); }); sheetconf.gettableconfigs().add(tableconf); classconfig classconfig = exceltable.getsetup().getorthrow(\"classes\", classconfig.class); if (classconfig.haslabel()) { sheetnamesb.append(classconfig.getlabel()); } else { throw new runtimeexception(\"classconfig should give a label to name the sheet\"); } if (k != sheet.size() - 1) { sheetnamesb.append(\" & \"); } } sheetconf.setsheetname(sheetnamesb.tostring()); workbookconf.getsheetconfigs().add(sheetconf); excelgeneratorresult result = excelgenerator.generate(null, workbookconf); file workbookfolder = workbooksheettables.size() == 1 ? dstfolder : new file(dstfolder, string.format(\"%0\" + maxdigits + \"d\", i)); result.saveexcel(workbookfolder); model expectedmodel = null; model provenancemodel = null; csvprinter provenancecsv = null; if (options.iswriteexpectedmodel()) { expectedmodel = modelfactory.createdefaultmodel(); expectedmodel.setnsprefixes(options.getprefixmapping()); expectedmodel.setnsprefixes(prefixmapping.standard); } if (options.iswriteprovenancemodel()) { provenancemodel = modelfactory.createdefaultmodel(); provenancemodel.setnsprefixes(options.getprefixmapping()); provenancemodel.setnsprefix(\"prov\", prov.ns); provenancemodel.setnsprefix(\"csvw\", csvw.ns); provenancemodel.setnsprefix(\"ss\", ss.ns); provenancemodel.setnsprefixes(prefixmapping.standard); } if (options.iswriteprovenancecsv()) { try { provenancecsv = csvformat.default.print( new outputstreamwriter( new gzipoutputstream( new fileoutputstream( new file(workbookfolder, \"provenance.csv.gz\") )))); csvprovenanceheader(provenancecsv); } catch (ioexception ex) { throw new runtimeexception(ex); } } map<statement, resource> stmt2res = new hashmap<>(); for (list<exceltable> sheet : sheets) { excelgeneratorsheetconfig sheetconfig = sheetconfigmap.get(sheet); for (exceltable table : sheet) { for (entry<excelcell, provenance> cell2prov : table.getcellprovmap().entryset()) { excelcell cell = cell2prov.getkey(); provenance prov = cell2prov.getvalue(); if (cell.getaddress() == null) { continue; } if (prov.getstatements().isempty()) { continue; } if (options.iswriteexpectedmodel()) { expectedmodel.add(prov.getstatements()); } if (options.iswriteprovenancemodel()) { rdfprovenance(cell, sheetconfig.getsheetname(), prov, stmt2res, provenancemodel); } if (options.iswriteprovenancecsv()) { csvprovenance(cell, sheetconfig.getsheetname(), prov, provenancecsv, provenancemodel); } } } } if (options.iswriteexpectedmodel()) { file file = new file(workbookfolder, \"expected.ttl.gz\"); try (outputstream os = file.getname().endswith(\"gz\") ? new gzipoutputstream(new fileoutputstream(file)) : new fileoutputstream(file)) { expectedmodel.write(os, \"ttl\"); } catch (ioexception ex) { throw new runtimeexception(ex); } } if (options.iswriteprovenancemodel()) { file file = new file(workbookfolder, \"provenance.ttl.gz\"); try (outputstream os = file.getname().endswith(\"gz\") ? new gzipoutputstream(new fileoutputstream(file)) : new fileoutputstream(file)) { provenancemodel.write(os, \"ttl\"); } catch (ioexception ex) { throw new runtimeexception(ex); } } if (options.iswriteprovenancecsv()) { try { provenancecsv.close(); } catch (ioexception ex) { throw new runtimeexception(ex); } } if (options.iswritegenerationsummaryjson()) { jsonobject persheetpatternusage = new jsonobject(); jsonutility.forcelinkedhashmap(persheetpatternusage); for (list<exceltable> sheet : sheets) { excelgeneratorsheetconfig sheetconfig = sheetconfigmap.get(sheet); map<string, map<object, integer>> pattern2value2count = new hashmap<>(); for (exceltable tbl : sheet) { for (entry<excelcell, provenance> entry : tbl.getcellprovmap().entryset()) { if (entry.getkey().getaddress() == null || entry.getvalue().getstatements().isempty()) { continue; } for (entry<string, object> e : entry.getvalue().getusedpatterns().entryset()) { object val = e.getvalue(); if(val instanceof jsonarray) { val = val.tostring(); } map<object, integer> value2count = pattern2value2count.computeifabsent(e.getkey(), k -> new hashmap<>()); value2count.put(val, value2count.getordefault(val, 0) + 1); } } } jsonobject patternusage = new jsonobject(); jsonutility.forcelinkedhashmap(patternusage); list<entry<string, map<object, integer>>> pattern2value2countlist = new arraylist<>(pattern2value2count.entryset()); pattern2value2countlist.sort((a,b) -> a.getkey().compareto(b.getkey())); for (entry<string, map<object, integer>> pattern2value2countentry : pattern2value2countlist) { jsonarray array = new jsonarray(); for (entry<object, integer> e : pattern2value2countentry.getvalue().entryset()) { jsonobject v2c = new jsonobject(); jsonutility.forcelinkedhashmap(v2c); v2c.put(\"value\", e.getkey()); v2c.put(\"count\", e.getvalue()); array.put(v2c); } patternusage.put(pattern2value2countentry.getkey(), array); } persheetpatternusage.put(sheetconfig.getsheetname(), patternusage); } options.getgenerationsummary().put(\"patternusagepersheet\", persheetpatternusage); file file = new file(workbookfolder, \"summary.json\"); try { fileutils.writestringtofile(file, options.getgenerationsummary().tostring(2), standardcharsets.utf_8); } catch (ioexception ex) { throw new runtimeexception(ex); } } }","comment":"\/\/there are many tables \/\/we have to decide: what table to what sheet, and what sheet to what workbook \/\/we should not repeat tables about the same class, so there are possible groups \/\/maybe a workbook should be full to have the best expected.ttl from the original model \/\/here we calculate: what table to what workbook\n\/\/now we have to decide which table will be in which sheet \/\/the cleanest way is to have a table per sheet \/\/todo make this variable so more messy version are possible\n\/\/now we use the excelgenerator to generate the workbooks\n\/\/create a config for this workbook\n\/\/todo configurable\n\/\/todo a second table in the sheet means we maybe have to move the offset \/\/ so that it will not overlap\n\/\/todo maybe make a getsingleordefault method\n\/\/draw the excelcell matrix from exceltable\n\/\/it uses the tableconf offset\n\/\/todo if only one table with one class: add provenance sheetname -> insts a class. (for all insts)\n\/\/in one sheet multiple tables could be existing\n\/\/sheet name comes from table content\n\/\/per sheet\n\/\/system.out.println(\"save workbook \" + i); \/\/no extra folder when only one workbook\n\/\/write provenance =================================================\n\/\/used in rdfprovenance for fast lookup reified statements\n\/\/need here sheetname for provenance\n\/\/this was a temporary cell created for a merge \/\/in tablegenerator putmultipleobjects method\n\/\/no provenance information for this cell\n\/\/write to files\n\/\/key is sheet name\n\/\/count how often\n\/\/skip the ones with no prov and no address (temp cells)\n\/\/because json array hash is always different\n\/\/per workbook","repo":"mschroeder-github\/datasprout","code_context_2":"public void create(File dstFolder, List<ExcelTable> tables, ExcelSproutOptions options) {\nRandom rnd = new Random(options.getRandomSeed());\n\/\/there are many tables\n\/\/we have to decide: what table to what sheet, and what sheet to what workbook\n\/\/we should not repeat tables about the same class, so there are possible groups\n\/\/maybe a workbook should be full to have the best expected.ttl from the original model\n\/\/here we calculate: what table to what workbook\nList<List<ExcelTable>> workbookClusters = getWorkbookClusters(tables, rnd);\n\/\/now we have to decide which table will be in which sheet\n\n\/\/here we calculate: what table to what workbook\nList<List<ExcelTable>> workbookClusters = getWorkbookClusters(tables, rnd);\n\/\/now we have to decide which table will be in which sheet\n\/\/the cleanest way is to have a table per sheet\n\/\/TODO make this variable so more messy version are possible\nList<List<List<ExcelTable>>> workbookSheetTables = new ArrayList<>();\nfor (List<ExcelTable> workbookTables : workbookClusters) {\n\nint maxDigits = String.valueOf(workbookSheetTables.size() - 1).length();\nMap<List<ExcelTable>, ExcelGeneratorSheetConfig> sheetConfigMap = new HashMap<>();\n\/\/now we use the ExcelGenerator to generate the workbooks\nExcelGenerator excelGenerator = new ExcelGenerator();\nfor (int i = 0; i < workbookSheetTables.size(); i++) {\n\nfor (int i = 0; i < workbookSheetTables.size(); i++) {\nList<List<ExcelTable>> sheets = workbookSheetTables.get(i);\n\/\/create a config for this workbook\nExcelGeneratorWorkbookConfig workbookConf = new ExcelGeneratorWorkbookConfig();\n\/\/TODO configurable\n\n\/\/create a config for this workbook\nExcelGeneratorWorkbookConfig workbookConf = new ExcelGeneratorWorkbookConfig();\n\/\/TODO configurable\nworkbookConf.setFileName(\"workbook.xlsx\");\nfor (List<ExcelTable> sheet : sheets) {\n\nsheetConfigMap.put(sheet, sheetConf);\nStringBuilder sheetNameSB = new StringBuilder();\n\/\/TODO a second table in the sheet means we maybe have to move the offset\n\/\/ so that it will not overlap\nfor (int k = 0; k < sheet.size(); k++) {\nExcelTable excelTable = sheet.get(k);\n\nExcelTable excelTable = sheet.get(k);\nExcelGeneratorTableConfig tableConf = new ExcelGeneratorTableConfig();\n\/\/TODO maybe make a getSingleOrDefault method\nPoint offset = (Point) excelTable.getSetup().getOrDefault(\"offset\", new Point(0, 0));\ntableConf.setOffset(offset);\n\nPoint offset = (Point) excelTable.getSetup().getOrDefault(\"offset\", new Point(0, 0));\ntableConf.setOffset(offset);\n\/\/draw the ExcelCell matrix from ExcelTable\ntableConf.setStaticCellDrawer(d -> {\n\/\/it uses the tableConf offset\n\n\/\/draw the ExcelCell matrix from ExcelTable\ntableConf.setStaticCellDrawer(d -> {\n\/\/it uses the tableConf offset\nd.exceltable(excelTable, options);\n});\n\n});\nsheetConf.getTableConfigs().add(tableConf);\n\/\/TODO if only one table with one class: add provenance sheetname -> insts a class. (for all insts)\nClassConfig classConfig = excelTable.getSetup().getOrThrow(\"classes\", ClassConfig.class);\nif (classConfig.hasLabel()) {\n\nthrow new RuntimeException(\"ClassConfig should give a label to name the sheet\");\n}\n\/\/in one sheet multiple tables could be existing\nif (k != sheet.size() - 1) {\nsheetNameSB.append(\" & \");\n\n}\n}\n\/\/sheet name comes from table content\nsheetConf.setSheetName(sheetNameSB.toString());\nworkbookConf.getSheetConfigs().add(sheetConf);\n\nsheetConf.setSheetName(sheetNameSB.toString());\nworkbookConf.getSheetConfigs().add(sheetConf);\n}\/\/per sheet\nExcelGeneratorResult result = excelGenerator.generate(null, workbookConf);\n\/\/System.out.println(\"save workbook \" + i);\n\n}\/\/per sheet\nExcelGeneratorResult result = excelGenerator.generate(null, workbookConf);\n\/\/System.out.println(\"save workbook \" + i);\n\/\/no extra folder when only one workbook\nFile workbookFolder = workbookSheetTables.size() == 1 ? dstFolder : new File(dstFolder, String.format(\"%0\" + maxDigits + \"d\", i));\nresult.saveExcel(workbookFolder);\n\nFile workbookFolder = workbookSheetTables.size() == 1 ? dstFolder : new File(dstFolder, String.format(\"%0\" + maxDigits + \"d\", i));\nresult.saveExcel(workbookFolder);\n\/\/write provenance =================================================\nModel expectedModel = null;\nModel provenanceModel = null;\n\n}\n}\n\/\/used in rdfProvenance for fast lookup reified statements\nMap<Statement, Resource> stmt2res = new HashMap<>();\n\/\/need here sheetname for provenance\n\n\/\/used in rdfProvenance for fast lookup reified statements\nMap<Statement, Resource> stmt2res = new HashMap<>();\n\/\/need here sheetname for provenance\nfor (List<ExcelTable> sheet : sheets) {\nExcelGeneratorSheetConfig sheetConfig = sheetConfigMap.get(sheet);\n\nProvenance prov = cell2prov.getValue();\nif (cell.getAddress() == null) {\n\/\/this was a temporary cell created for a merge\n\/\/in TableGenerator putMultipleObjects method\ncontinue;\n}\n\n}\nif (prov.getStatements().isEmpty()) {\n\/\/no provenance information for this cell\ncontinue;\n}\n\n}\n}\n\/\/write to files\nif (options.isWriteExpectedModel()) {\nFile file = new File(workbookFolder, \"expected.ttl.gz\");\n\n}\nif (options.isWriteGenerationSummaryJson()) {\n\/\/key is sheet name\nJSONObject perSheetPatternUsage = new JSONObject();\nJsonUtility.forceLinkedHashMap(perSheetPatternUsage);\n\nfor (List<ExcelTable> sheet : sheets) {\nExcelGeneratorSheetConfig sheetConfig = sheetConfigMap.get(sheet);\n\/\/count how often\nMap<String, Map<Object, Integer>> pattern2value2count = new HashMap<>();\nfor (ExcelTable tbl : sheet) {\n\nfor (ExcelTable tbl : sheet) {\nfor (Entry<ExcelCell, Provenance> entry : tbl.getCellProvMap().entrySet()) {\n\/\/skip the ones with no prov and no address (temp cells)\nif (entry.getKey().getAddress() == null || entry.getValue().getStatements().isEmpty()) {\ncontinue;\n\nObject val = e.getValue();\nif(val instanceof JSONArray) {\n\/\/because json array hash is always different\nval = val.toString();\n}\n\n}\n}\n}\/\/per workbook\n}","code_context_10":"public void create(File dstFolder, List<ExcelTable> tables, ExcelSproutOptions options) {\nRandom rnd = new Random(options.getRandomSeed());\n\/\/there are many tables\n\/\/we have to decide: what table to what sheet, and what sheet to what workbook\n\/\/we should not repeat tables about the same class, so there are possible groups\n\/\/maybe a workbook should be full to have the best expected.ttl from the original model\n\/\/here we calculate: what table to what workbook\nList<List<ExcelTable>> workbookClusters = getWorkbookClusters(tables, rnd);\n\/\/now we have to decide which table will be in which sheet\n\/\/the cleanest way is to have a table per sheet\n\/\/TODO make this variable so more messy version are possible\nList<List<List<ExcelTable>>> workbookSheetTables = new ArrayList<>();\nfor (List<ExcelTable> workbookTables : workbookClusters) {\nList<List<ExcelTable>> sheetTables = new ArrayList<>();\nfor (ExcelTable tbl : workbookTables) {\nList<ExcelTable> sheet = Arrays.asList(tbl);\nsheetTables.add(sheet);\n\npublic void create(File dstFolder, List<ExcelTable> tables, ExcelSproutOptions options) {\nRandom rnd = new Random(options.getRandomSeed());\n\/\/there are many tables\n\/\/we have to decide: what table to what sheet, and what sheet to what workbook\n\/\/we should not repeat tables about the same class, so there are possible groups\n\/\/maybe a workbook should be full to have the best expected.ttl from the original model\n\/\/here we calculate: what table to what workbook\nList<List<ExcelTable>> workbookClusters = getWorkbookClusters(tables, rnd);\n\/\/now we have to decide which table will be in which sheet\n\/\/the cleanest way is to have a table per sheet\n\/\/TODO make this variable so more messy version are possible\nList<List<List<ExcelTable>>> workbookSheetTables = new ArrayList<>();\nfor (List<ExcelTable> workbookTables : workbookClusters) {\nList<List<ExcelTable>> sheetTables = new ArrayList<>();\nfor (ExcelTable tbl : workbookTables) {\nList<ExcelTable> sheet = Arrays.asList(tbl);\nsheetTables.add(sheet);\n}\nworkbookSheetTables.add(sheetTables);\n}\nint maxDigits = String.valueOf(workbookSheetTables.size() - 1).length();\n\nfor (List<ExcelTable> workbookTables : workbookClusters) {\nList<List<ExcelTable>> sheetTables = new ArrayList<>();\nfor (ExcelTable tbl : workbookTables) {\nList<ExcelTable> sheet = Arrays.asList(tbl);\nsheetTables.add(sheet);\n}\nworkbookSheetTables.add(sheetTables);\n}\nint maxDigits = String.valueOf(workbookSheetTables.size() - 1).length();\nMap<List<ExcelTable>, ExcelGeneratorSheetConfig> sheetConfigMap = new HashMap<>();\n\/\/now we use the ExcelGenerator to generate the workbooks\nExcelGenerator excelGenerator = new ExcelGenerator();\nfor (int i = 0; i < workbookSheetTables.size(); i++) {\nList<List<ExcelTable>> sheets = workbookSheetTables.get(i);\n\/\/create a config for this workbook\nExcelGeneratorWorkbookConfig workbookConf = new ExcelGeneratorWorkbookConfig();\n\/\/TODO configurable\nworkbookConf.setFileName(\"workbook.xlsx\");\nfor (List<ExcelTable> sheet : sheets) {\nExcelGeneratorSheetConfig sheetConf = new ExcelGeneratorSheetConfig();\nsheetConfigMap.put(sheet, sheetConf);\n\nsheetTables.add(sheet);\n}\nworkbookSheetTables.add(sheetTables);\n}\nint maxDigits = String.valueOf(workbookSheetTables.size() - 1).length();\nMap<List<ExcelTable>, ExcelGeneratorSheetConfig> sheetConfigMap = new HashMap<>();\n\/\/now we use the ExcelGenerator to generate the workbooks\nExcelGenerator excelGenerator = new ExcelGenerator();\nfor (int i = 0; i < workbookSheetTables.size(); i++) {\nList<List<ExcelTable>> sheets = workbookSheetTables.get(i);\n\/\/create a config for this workbook\nExcelGeneratorWorkbookConfig workbookConf = new ExcelGeneratorWorkbookConfig();\n\/\/TODO configurable\nworkbookConf.setFileName(\"workbook.xlsx\");\nfor (List<ExcelTable> sheet : sheets) {\nExcelGeneratorSheetConfig sheetConf = new ExcelGeneratorSheetConfig();\nsheetConfigMap.put(sheet, sheetConf);\nStringBuilder sheetNameSB = new StringBuilder();\n\/\/TODO a second table in the sheet means we maybe have to move the offset\n\/\/ so that it will not overlap\nfor (int k = 0; k < sheet.size(); k++) {\n\nworkbookSheetTables.add(sheetTables);\n}\nint maxDigits = String.valueOf(workbookSheetTables.size() - 1).length();\nMap<List<ExcelTable>, ExcelGeneratorSheetConfig> sheetConfigMap = new HashMap<>();\n\/\/now we use the ExcelGenerator to generate the workbooks\nExcelGenerator excelGenerator = new ExcelGenerator();\nfor (int i = 0; i < workbookSheetTables.size(); i++) {\nList<List<ExcelTable>> sheets = workbookSheetTables.get(i);\n\/\/create a config for this workbook\nExcelGeneratorWorkbookConfig workbookConf = new ExcelGeneratorWorkbookConfig();\n\/\/TODO configurable\nworkbookConf.setFileName(\"workbook.xlsx\");\nfor (List<ExcelTable> sheet : sheets) {\nExcelGeneratorSheetConfig sheetConf = new ExcelGeneratorSheetConfig();\nsheetConfigMap.put(sheet, sheetConf);\nStringBuilder sheetNameSB = new StringBuilder();\n\/\/TODO a second table in the sheet means we maybe have to move the offset\n\/\/ so that it will not overlap\nfor (int k = 0; k < sheet.size(); k++) {\nExcelTable excelTable = sheet.get(k);\nExcelGeneratorTableConfig tableConf = new ExcelGeneratorTableConfig();\n\nfor (int i = 0; i < workbookSheetTables.size(); i++) {\nList<List<ExcelTable>> sheets = workbookSheetTables.get(i);\n\/\/create a config for this workbook\nExcelGeneratorWorkbookConfig workbookConf = new ExcelGeneratorWorkbookConfig();\n\/\/TODO configurable\nworkbookConf.setFileName(\"workbook.xlsx\");\nfor (List<ExcelTable> sheet : sheets) {\nExcelGeneratorSheetConfig sheetConf = new ExcelGeneratorSheetConfig();\nsheetConfigMap.put(sheet, sheetConf);\nStringBuilder sheetNameSB = new StringBuilder();\n\/\/TODO a second table in the sheet means we maybe have to move the offset\n\/\/ so that it will not overlap\nfor (int k = 0; k < sheet.size(); k++) {\nExcelTable excelTable = sheet.get(k);\nExcelGeneratorTableConfig tableConf = new ExcelGeneratorTableConfig();\n\/\/TODO maybe make a getSingleOrDefault method\nPoint offset = (Point) excelTable.getSetup().getOrDefault(\"offset\", new Point(0, 0));\ntableConf.setOffset(offset);\n\/\/draw the ExcelCell matrix from ExcelTable\ntableConf.setStaticCellDrawer(d -> {\n\/\/it uses the tableConf offset\nd.exceltable(excelTable, options);\n\nworkbookConf.setFileName(\"workbook.xlsx\");\nfor (List<ExcelTable> sheet : sheets) {\nExcelGeneratorSheetConfig sheetConf = new ExcelGeneratorSheetConfig();\nsheetConfigMap.put(sheet, sheetConf);\nStringBuilder sheetNameSB = new StringBuilder();\n\/\/TODO a second table in the sheet means we maybe have to move the offset\n\/\/ so that it will not overlap\nfor (int k = 0; k < sheet.size(); k++) {\nExcelTable excelTable = sheet.get(k);\nExcelGeneratorTableConfig tableConf = new ExcelGeneratorTableConfig();\n\/\/TODO maybe make a getSingleOrDefault method\nPoint offset = (Point) excelTable.getSetup().getOrDefault(\"offset\", new Point(0, 0));\ntableConf.setOffset(offset);\n\/\/draw the ExcelCell matrix from ExcelTable\ntableConf.setStaticCellDrawer(d -> {\n\/\/it uses the tableConf offset\nd.exceltable(excelTable, options);\n});\nsheetConf.getTableConfigs().add(tableConf);\n\/\/TODO if only one table with one class: add provenance sheetname -> insts a class. (for all insts)\nClassConfig classConfig = excelTable.getSetup().getOrThrow(\"classes\", ClassConfig.class);\n\nsheetConfigMap.put(sheet, sheetConf);\nStringBuilder sheetNameSB = new StringBuilder();\n\/\/TODO a second table in the sheet means we maybe have to move the offset\n\/\/ so that it will not overlap\nfor (int k = 0; k < sheet.size(); k++) {\nExcelTable excelTable = sheet.get(k);\nExcelGeneratorTableConfig tableConf = new ExcelGeneratorTableConfig();\n\/\/TODO maybe make a getSingleOrDefault method\nPoint offset = (Point) excelTable.getSetup().getOrDefault(\"offset\", new Point(0, 0));\ntableConf.setOffset(offset);\n\/\/draw the ExcelCell matrix from ExcelTable\ntableConf.setStaticCellDrawer(d -> {\n\/\/it uses the tableConf offset\nd.exceltable(excelTable, options);\n});\nsheetConf.getTableConfigs().add(tableConf);\n\/\/TODO if only one table with one class: add provenance sheetname -> insts a class. (for all insts)\nClassConfig classConfig = excelTable.getSetup().getOrThrow(\"classes\", ClassConfig.class);\nif (classConfig.hasLabel()) {\nsheetNameSB.append(classConfig.getLabel());\n} else {\n\n\/\/TODO a second table in the sheet means we maybe have to move the offset\n\/\/ so that it will not overlap\nfor (int k = 0; k < sheet.size(); k++) {\nExcelTable excelTable = sheet.get(k);\nExcelGeneratorTableConfig tableConf = new ExcelGeneratorTableConfig();\n\/\/TODO maybe make a getSingleOrDefault method\nPoint offset = (Point) excelTable.getSetup().getOrDefault(\"offset\", new Point(0, 0));\ntableConf.setOffset(offset);\n\/\/draw the ExcelCell matrix from ExcelTable\ntableConf.setStaticCellDrawer(d -> {\n\/\/it uses the tableConf offset\nd.exceltable(excelTable, options);\n});\nsheetConf.getTableConfigs().add(tableConf);\n\/\/TODO if only one table with one class: add provenance sheetname -> insts a class. (for all insts)\nClassConfig classConfig = excelTable.getSetup().getOrThrow(\"classes\", ClassConfig.class);\nif (classConfig.hasLabel()) {\nsheetNameSB.append(classConfig.getLabel());\n} else {\nthrow new RuntimeException(\"ClassConfig should give a label to name the sheet\");\n}\n\nExcelGeneratorTableConfig tableConf = new ExcelGeneratorTableConfig();\n\/\/TODO maybe make a getSingleOrDefault method\nPoint offset = (Point) excelTable.getSetup().getOrDefault(\"offset\", new Point(0, 0));\ntableConf.setOffset(offset);\n\/\/draw the ExcelCell matrix from ExcelTable\ntableConf.setStaticCellDrawer(d -> {\n\/\/it uses the tableConf offset\nd.exceltable(excelTable, options);\n});\nsheetConf.getTableConfigs().add(tableConf);\n\/\/TODO if only one table with one class: add provenance sheetname -> insts a class. (for all insts)\nClassConfig classConfig = excelTable.getSetup().getOrThrow(\"classes\", ClassConfig.class);\nif (classConfig.hasLabel()) {\nsheetNameSB.append(classConfig.getLabel());\n} else {\nthrow new RuntimeException(\"ClassConfig should give a label to name the sheet\");\n}\n\/\/in one sheet multiple tables could be existing\nif (k != sheet.size() - 1) {\nsheetNameSB.append(\" & \");\n}\n\nd.exceltable(excelTable, options);\n});\nsheetConf.getTableConfigs().add(tableConf);\n\/\/TODO if only one table with one class: add provenance sheetname -> insts a class. (for all insts)\nClassConfig classConfig = excelTable.getSetup().getOrThrow(\"classes\", ClassConfig.class);\nif (classConfig.hasLabel()) {\nsheetNameSB.append(classConfig.getLabel());\n} else {\nthrow new RuntimeException(\"ClassConfig should give a label to name the sheet\");\n}\n\/\/in one sheet multiple tables could be existing\nif (k != sheet.size() - 1) {\nsheetNameSB.append(\" & \");\n}\n}\n\/\/sheet name comes from table content\nsheetConf.setSheetName(sheetNameSB.toString());\nworkbookConf.getSheetConfigs().add(sheetConf);\n}\/\/per sheet\nExcelGeneratorResult result = excelGenerator.generate(null, workbookConf);\n\/\/System.out.println(\"save workbook \" + i);\n\nif (classConfig.hasLabel()) {\nsheetNameSB.append(classConfig.getLabel());\n} else {\nthrow new RuntimeException(\"ClassConfig should give a label to name the sheet\");\n}\n\/\/in one sheet multiple tables could be existing\nif (k != sheet.size() - 1) {\nsheetNameSB.append(\" & \");\n}\n}\n\/\/sheet name comes from table content\nsheetConf.setSheetName(sheetNameSB.toString());\nworkbookConf.getSheetConfigs().add(sheetConf);\n}\/\/per sheet\nExcelGeneratorResult result = excelGenerator.generate(null, workbookConf);\n\/\/System.out.println(\"save workbook \" + i);\n\/\/no extra folder when only one workbook\nFile workbookFolder = workbookSheetTables.size() == 1 ? dstFolder : new File(dstFolder, String.format(\"%0\" + maxDigits + \"d\", i));\nresult.saveExcel(workbookFolder);\n\/\/write provenance =================================================\nModel expectedModel = null;\n\nthrow new RuntimeException(\"ClassConfig should give a label to name the sheet\");\n}\n\/\/in one sheet multiple tables could be existing\nif (k != sheet.size() - 1) {\nsheetNameSB.append(\" & \");\n}\n}\n\/\/sheet name comes from table content\nsheetConf.setSheetName(sheetNameSB.toString());\nworkbookConf.getSheetConfigs().add(sheetConf);\n}\/\/per sheet\nExcelGeneratorResult result = excelGenerator.generate(null, workbookConf);\n\/\/System.out.println(\"save workbook \" + i);\n\/\/no extra folder when only one workbook\nFile workbookFolder = workbookSheetTables.size() == 1 ? dstFolder : new File(dstFolder, String.format(\"%0\" + maxDigits + \"d\", i));\nresult.saveExcel(workbookFolder);\n\/\/write provenance =================================================\nModel expectedModel = null;\nModel provenanceModel = null;\nCSVPrinter provenanceCSV = null;\nif (options.isWriteExpectedModel()) {\n\n\/\/in one sheet multiple tables could be existing\nif (k != sheet.size() - 1) {\nsheetNameSB.append(\" & \");\n}\n}\n\/\/sheet name comes from table content\nsheetConf.setSheetName(sheetNameSB.toString());\nworkbookConf.getSheetConfigs().add(sheetConf);\n}\/\/per sheet\nExcelGeneratorResult result = excelGenerator.generate(null, workbookConf);\n\/\/System.out.println(\"save workbook \" + i);\n\/\/no extra folder when only one workbook\nFile workbookFolder = workbookSheetTables.size() == 1 ? dstFolder : new File(dstFolder, String.format(\"%0\" + maxDigits + \"d\", i));\nresult.saveExcel(workbookFolder);\n\/\/write provenance =================================================\nModel expectedModel = null;\nModel provenanceModel = null;\nCSVPrinter provenanceCSV = null;\nif (options.isWriteExpectedModel()) {\nexpectedModel = ModelFactory.createDefaultModel();\nexpectedModel.setNsPrefixes(options.getPrefixMapping());\nexpectedModel.setNsPrefixes(PrefixMapping.Standard);\n\n}\n\/\/sheet name comes from table content\nsheetConf.setSheetName(sheetNameSB.toString());\nworkbookConf.getSheetConfigs().add(sheetConf);\n}\/\/per sheet\nExcelGeneratorResult result = excelGenerator.generate(null, workbookConf);\n\/\/System.out.println(\"save workbook \" + i);\n\/\/no extra folder when only one workbook\nFile workbookFolder = workbookSheetTables.size() == 1 ? dstFolder : new File(dstFolder, String.format(\"%0\" + maxDigits + \"d\", i));\nresult.saveExcel(workbookFolder);\n\/\/write provenance =================================================\nModel expectedModel = null;\nModel provenanceModel = null;\nCSVPrinter provenanceCSV = null;\nif (options.isWriteExpectedModel()) {\nexpectedModel = ModelFactory.createDefaultModel();\nexpectedModel.setNsPrefixes(options.getPrefixMapping());\nexpectedModel.setNsPrefixes(PrefixMapping.Standard);\n}\nif (options.isWriteProvenanceModel()) {\nprovenanceModel = ModelFactory.createDefaultModel();\n\nnew OutputStreamWriter(\nnew GZIPOutputStream(\nnew FileOutputStream(\nnew File(workbookFolder, \"provenance.csv.gz\")\n))));\ncsvProvenanceHeader(provenanceCSV);\n} catch (IOException ex) {\nthrow new RuntimeException(ex);\n}\n}\n\/\/used in rdfProvenance for fast lookup reified statements\nMap<Statement, Resource> stmt2res = new HashMap<>();\n\/\/need here sheetname for provenance\nfor (List<ExcelTable> sheet : sheets) {\nExcelGeneratorSheetConfig sheetConfig = sheetConfigMap.get(sheet);\nfor (ExcelTable table : sheet) {\nfor (Entry<ExcelCell, Provenance> cell2prov : table.getCellProvMap().entrySet()) {\nExcelCell cell = cell2prov.getKey();\nProvenance prov = cell2prov.getValue();\nif (cell.getAddress() == null) {\n\/\/this was a temporary cell created for a merge\n\nnew FileOutputStream(\nnew File(workbookFolder, \"provenance.csv.gz\")\n))));\ncsvProvenanceHeader(provenanceCSV);\n} catch (IOException ex) {\nthrow new RuntimeException(ex);\n}\n}\n\/\/used in rdfProvenance for fast lookup reified statements\nMap<Statement, Resource> stmt2res = new HashMap<>();\n\/\/need here sheetname for provenance\nfor (List<ExcelTable> sheet : sheets) {\nExcelGeneratorSheetConfig sheetConfig = sheetConfigMap.get(sheet);\nfor (ExcelTable table : sheet) {\nfor (Entry<ExcelCell, Provenance> cell2prov : table.getCellProvMap().entrySet()) {\nExcelCell cell = cell2prov.getKey();\nProvenance prov = cell2prov.getValue();\nif (cell.getAddress() == null) {\n\/\/this was a temporary cell created for a merge\n\/\/in TableGenerator putMultipleObjects method\ncontinue;\n\n\/\/used in rdfProvenance for fast lookup reified statements\nMap<Statement, Resource> stmt2res = new HashMap<>();\n\/\/need here sheetname for provenance\nfor (List<ExcelTable> sheet : sheets) {\nExcelGeneratorSheetConfig sheetConfig = sheetConfigMap.get(sheet);\nfor (ExcelTable table : sheet) {\nfor (Entry<ExcelCell, Provenance> cell2prov : table.getCellProvMap().entrySet()) {\nExcelCell cell = cell2prov.getKey();\nProvenance prov = cell2prov.getValue();\nif (cell.getAddress() == null) {\n\/\/this was a temporary cell created for a merge\n\/\/in TableGenerator putMultipleObjects method\ncontinue;\n}\nif (prov.getStatements().isEmpty()) {\n\/\/no provenance information for this cell\ncontinue;\n}\nif (options.isWriteExpectedModel()) {\nexpectedModel.add(prov.getStatements());\n}\nif (options.isWriteProvenanceModel()) {\n\nfor (ExcelTable table : sheet) {\nfor (Entry<ExcelCell, Provenance> cell2prov : table.getCellProvMap().entrySet()) {\nExcelCell cell = cell2prov.getKey();\nProvenance prov = cell2prov.getValue();\nif (cell.getAddress() == null) {\n\/\/this was a temporary cell created for a merge\n\/\/in TableGenerator putMultipleObjects method\ncontinue;\n}\nif (prov.getStatements().isEmpty()) {\n\/\/no provenance information for this cell\ncontinue;\n}\nif (options.isWriteExpectedModel()) {\nexpectedModel.add(prov.getStatements());\n}\nif (options.isWriteProvenanceModel()) {\nrdfProvenance(cell, sheetConfig.getSheetName(), prov, stmt2res, provenanceModel);\n}\nif (options.isWriteProvenanceCSV()) {\ncsvProvenance(cell, sheetConfig.getSheetName(), prov, provenanceCSV, provenanceModel);\n\n}\nif (options.isWriteProvenanceModel()) {\nrdfProvenance(cell, sheetConfig.getSheetName(), prov, stmt2res, provenanceModel);\n}\nif (options.isWriteProvenanceCSV()) {\ncsvProvenance(cell, sheetConfig.getSheetName(), prov, provenanceCSV, provenanceModel);\n}\n}\n}\n}\n\/\/write to files\nif (options.isWriteExpectedModel()) {\nFile file = new File(workbookFolder, \"expected.ttl.gz\");\ntry (OutputStream os = file.getName().endsWith(\"gz\") ? new GZIPOutputStream(new FileOutputStream(file)) : new FileOutputStream(file)) {\nexpectedModel.write(os, \"TTL\");\n} catch (IOException ex) {\nthrow new RuntimeException(ex);\n}\n}\nif (options.isWriteProvenanceModel()) {\nFile file = new File(workbookFolder, \"provenance.ttl.gz\");\n\n}\n}\nif (options.isWriteProvenanceCSV()) {\ntry {\nprovenanceCSV.close();\n} catch (IOException ex) {\nthrow new RuntimeException(ex);\n}\n}\nif (options.isWriteGenerationSummaryJson()) {\n\/\/key is sheet name\nJSONObject perSheetPatternUsage = new JSONObject();\nJsonUtility.forceLinkedHashMap(perSheetPatternUsage);\nfor (List<ExcelTable> sheet : sheets) {\nExcelGeneratorSheetConfig sheetConfig = sheetConfigMap.get(sheet);\n\/\/count how often\nMap<String, Map<Object, Integer>> pattern2value2count = new HashMap<>();\nfor (ExcelTable tbl : sheet) {\nfor (Entry<ExcelCell, Provenance> entry : tbl.getCellProvMap().entrySet()) {\n\/\/skip the ones with no prov and no address (temp cells)\nif (entry.getKey().getAddress() == null || entry.getValue().getStatements().isEmpty()) {\n\n} catch (IOException ex) {\nthrow new RuntimeException(ex);\n}\n}\nif (options.isWriteGenerationSummaryJson()) {\n\/\/key is sheet name\nJSONObject perSheetPatternUsage = new JSONObject();\nJsonUtility.forceLinkedHashMap(perSheetPatternUsage);\nfor (List<ExcelTable> sheet : sheets) {\nExcelGeneratorSheetConfig sheetConfig = sheetConfigMap.get(sheet);\n\/\/count how often\nMap<String, Map<Object, Integer>> pattern2value2count = new HashMap<>();\nfor (ExcelTable tbl : sheet) {\nfor (Entry<ExcelCell, Provenance> entry : tbl.getCellProvMap().entrySet()) {\n\/\/skip the ones with no prov and no address (temp cells)\nif (entry.getKey().getAddress() == null || entry.getValue().getStatements().isEmpty()) {\ncontinue;\n}\nfor (Entry<String, Object> e : entry.getValue().getUsedPatterns().entrySet()) {\nObject val = e.getValue();\nif(val instanceof JSONArray) {\n\nif (options.isWriteGenerationSummaryJson()) {\n\/\/key is sheet name\nJSONObject perSheetPatternUsage = new JSONObject();\nJsonUtility.forceLinkedHashMap(perSheetPatternUsage);\nfor (List<ExcelTable> sheet : sheets) {\nExcelGeneratorSheetConfig sheetConfig = sheetConfigMap.get(sheet);\n\/\/count how often\nMap<String, Map<Object, Integer>> pattern2value2count = new HashMap<>();\nfor (ExcelTable tbl : sheet) {\nfor (Entry<ExcelCell, Provenance> entry : tbl.getCellProvMap().entrySet()) {\n\/\/skip the ones with no prov and no address (temp cells)\nif (entry.getKey().getAddress() == null || entry.getValue().getStatements().isEmpty()) {\ncontinue;\n}\nfor (Entry<String, Object> e : entry.getValue().getUsedPatterns().entrySet()) {\nObject val = e.getValue();\nif(val instanceof JSONArray) {\n\/\/because json array hash is always different\nval = val.toString();\n}\nMap<Object, Integer> value2count = pattern2value2count.computeIfAbsent(e.getKey(), k -> new HashMap<>());\n\nMap<String, Map<Object, Integer>> pattern2value2count = new HashMap<>();\nfor (ExcelTable tbl : sheet) {\nfor (Entry<ExcelCell, Provenance> entry : tbl.getCellProvMap().entrySet()) {\n\/\/skip the ones with no prov and no address (temp cells)\nif (entry.getKey().getAddress() == null || entry.getValue().getStatements().isEmpty()) {\ncontinue;\n}\nfor (Entry<String, Object> e : entry.getValue().getUsedPatterns().entrySet()) {\nObject val = e.getValue();\nif(val instanceof JSONArray) {\n\/\/because json array hash is always different\nval = val.toString();\n}\nMap<Object, Integer> value2count = pattern2value2count.computeIfAbsent(e.getKey(), k -> new HashMap<>());\nvalue2count.put(val, value2count.getOrDefault(val, 0) + 1);\n}\n}\n}\nJSONObject patternUsage = new JSONObject();\nJsonUtility.forceLinkedHashMap(patternUsage);\nList<Entry<String, Map<Object, Integer>>> pattern2value2countList = new ArrayList<>(pattern2value2count.entrySet());\n\nperSheetPatternUsage.put(sheetConfig.getSheetName(), patternUsage);\n}\noptions.getGenerationSummary().put(\"patternUsagePerSheet\", perSheetPatternUsage);\nFile file = new File(workbookFolder, \"summary.json\");\ntry {\nFileUtils.writeStringToFile(file, options.getGenerationSummary().toString(2), StandardCharsets.UTF_8);\n} catch (IOException ex) {\nthrow new RuntimeException(ex);\n}\n}\n}\/\/per workbook\n}","code_context_20":"public void create(File dstFolder, List<ExcelTable> tables, ExcelSproutOptions options) {\nRandom rnd = new Random(options.getRandomSeed());\n\/\/there are many tables\n\/\/we have to decide: what table to what sheet, and what sheet to what workbook\n\/\/we should not repeat tables about the same class, so there are possible groups\n\/\/maybe a workbook should be full to have the best expected.ttl from the original model\n\/\/here we calculate: what table to what workbook\nList<List<ExcelTable>> workbookClusters = getWorkbookClusters(tables, rnd);\n\/\/now we have to decide which table will be in which sheet\n\/\/the cleanest way is to have a table per sheet\n\/\/TODO make this variable so more messy version are possible\nList<List<List<ExcelTable>>> workbookSheetTables = new ArrayList<>();\nfor (List<ExcelTable> workbookTables : workbookClusters) {\nList<List<ExcelTable>> sheetTables = new ArrayList<>();\nfor (ExcelTable tbl : workbookTables) {\nList<ExcelTable> sheet = Arrays.asList(tbl);\nsheetTables.add(sheet);\n}\nworkbookSheetTables.add(sheetTables);\n}\nint maxDigits = String.valueOf(workbookSheetTables.size() - 1).length();\nMap<List<ExcelTable>, ExcelGeneratorSheetConfig> sheetConfigMap = new HashMap<>();\n\/\/now we use the ExcelGenerator to generate the workbooks\nExcelGenerator excelGenerator = new ExcelGenerator();\nfor (int i = 0; i < workbookSheetTables.size(); i++) {\nList<List<ExcelTable>> sheets = workbookSheetTables.get(i);\n\/\/create a config for this workbook\n\npublic void create(File dstFolder, List<ExcelTable> tables, ExcelSproutOptions options) {\nRandom rnd = new Random(options.getRandomSeed());\n\/\/there are many tables\n\/\/we have to decide: what table to what sheet, and what sheet to what workbook\n\/\/we should not repeat tables about the same class, so there are possible groups\n\/\/maybe a workbook should be full to have the best expected.ttl from the original model\n\/\/here we calculate: what table to what workbook\nList<List<ExcelTable>> workbookClusters = getWorkbookClusters(tables, rnd);\n\/\/now we have to decide which table will be in which sheet\n\/\/the cleanest way is to have a table per sheet\n\/\/TODO make this variable so more messy version are possible\nList<List<List<ExcelTable>>> workbookSheetTables = new ArrayList<>();\nfor (List<ExcelTable> workbookTables : workbookClusters) {\nList<List<ExcelTable>> sheetTables = new ArrayList<>();\nfor (ExcelTable tbl : workbookTables) {\nList<ExcelTable> sheet = Arrays.asList(tbl);\nsheetTables.add(sheet);\n}\nworkbookSheetTables.add(sheetTables);\n}\nint maxDigits = String.valueOf(workbookSheetTables.size() - 1).length();\nMap<List<ExcelTable>, ExcelGeneratorSheetConfig> sheetConfigMap = new HashMap<>();\n\/\/now we use the ExcelGenerator to generate the workbooks\nExcelGenerator excelGenerator = new ExcelGenerator();\nfor (int i = 0; i < workbookSheetTables.size(); i++) {\nList<List<ExcelTable>> sheets = workbookSheetTables.get(i);\n\/\/create a config for this workbook\nExcelGeneratorWorkbookConfig workbookConf = new ExcelGeneratorWorkbookConfig();\n\/\/TODO configurable\nworkbookConf.setFileName(\"workbook.xlsx\");\nfor (List<ExcelTable> sheet : sheets) {\n\n\/\/there are many tables\n\/\/we have to decide: what table to what sheet, and what sheet to what workbook\n\/\/we should not repeat tables about the same class, so there are possible groups\n\/\/maybe a workbook should be full to have the best expected.ttl from the original model\n\/\/here we calculate: what table to what workbook\nList<List<ExcelTable>> workbookClusters = getWorkbookClusters(tables, rnd);\n\/\/now we have to decide which table will be in which sheet\n\/\/the cleanest way is to have a table per sheet\n\/\/TODO make this variable so more messy version are possible\nList<List<List<ExcelTable>>> workbookSheetTables = new ArrayList<>();\nfor (List<ExcelTable> workbookTables : workbookClusters) {\nList<List<ExcelTable>> sheetTables = new ArrayList<>();\nfor (ExcelTable tbl : workbookTables) {\nList<ExcelTable> sheet = Arrays.asList(tbl);\nsheetTables.add(sheet);\n}\nworkbookSheetTables.add(sheetTables);\n}\nint maxDigits = String.valueOf(workbookSheetTables.size() - 1).length();\nMap<List<ExcelTable>, ExcelGeneratorSheetConfig> sheetConfigMap = new HashMap<>();\n\/\/now we use the ExcelGenerator to generate the workbooks\nExcelGenerator excelGenerator = new ExcelGenerator();\nfor (int i = 0; i < workbookSheetTables.size(); i++) {\nList<List<ExcelTable>> sheets = workbookSheetTables.get(i);\n\/\/create a config for this workbook\nExcelGeneratorWorkbookConfig workbookConf = new ExcelGeneratorWorkbookConfig();\n\/\/TODO configurable\nworkbookConf.setFileName(\"workbook.xlsx\");\nfor (List<ExcelTable> sheet : sheets) {\nExcelGeneratorSheetConfig sheetConf = new ExcelGeneratorSheetConfig();\nsheetConfigMap.put(sheet, sheetConf);\nStringBuilder sheetNameSB = new StringBuilder();\n\/\/TODO a second table in the sheet means we maybe have to move the offset\n\/\/ so that it will not overlap\nfor (int k = 0; k < sheet.size(); k++) {\nExcelTable excelTable = sheet.get(k);\nExcelGeneratorTableConfig tableConf = new ExcelGeneratorTableConfig();\n\/\/TODO maybe make a getSingleOrDefault method\nPoint offset = (Point) excelTable.getSetup().getOrDefault(\"offset\", new Point(0, 0));\ntableConf.setOffset(offset);\n\/\/draw the ExcelCell matrix from ExcelTable\n\n\/\/here we calculate: what table to what workbook\nList<List<ExcelTable>> workbookClusters = getWorkbookClusters(tables, rnd);\n\/\/now we have to decide which table will be in which sheet\n\/\/the cleanest way is to have a table per sheet\n\/\/TODO make this variable so more messy version are possible\nList<List<List<ExcelTable>>> workbookSheetTables = new ArrayList<>();\nfor (List<ExcelTable> workbookTables : workbookClusters) {\nList<List<ExcelTable>> sheetTables = new ArrayList<>();\nfor (ExcelTable tbl : workbookTables) {\nList<ExcelTable> sheet = Arrays.asList(tbl);\nsheetTables.add(sheet);\n}\nworkbookSheetTables.add(sheetTables);\n}\nint maxDigits = String.valueOf(workbookSheetTables.size() - 1).length();\nMap<List<ExcelTable>, ExcelGeneratorSheetConfig> sheetConfigMap = new HashMap<>();\n\/\/now we use the ExcelGenerator to generate the workbooks\nExcelGenerator excelGenerator = new ExcelGenerator();\nfor (int i = 0; i < workbookSheetTables.size(); i++) {\nList<List<ExcelTable>> sheets = workbookSheetTables.get(i);\n\/\/create a config for this workbook\nExcelGeneratorWorkbookConfig workbookConf = new ExcelGeneratorWorkbookConfig();\n\/\/TODO configurable\nworkbookConf.setFileName(\"workbook.xlsx\");\nfor (List<ExcelTable> sheet : sheets) {\nExcelGeneratorSheetConfig sheetConf = new ExcelGeneratorSheetConfig();\nsheetConfigMap.put(sheet, sheetConf);\nStringBuilder sheetNameSB = new StringBuilder();\n\/\/TODO a second table in the sheet means we maybe have to move the offset\n\/\/ so that it will not overlap\nfor (int k = 0; k < sheet.size(); k++) {\nExcelTable excelTable = sheet.get(k);\nExcelGeneratorTableConfig tableConf = new ExcelGeneratorTableConfig();\n\/\/TODO maybe make a getSingleOrDefault method\nPoint offset = (Point) excelTable.getSetup().getOrDefault(\"offset\", new Point(0, 0));\ntableConf.setOffset(offset);\n\/\/draw the ExcelCell matrix from ExcelTable\ntableConf.setStaticCellDrawer(d -> {\n\/\/it uses the tableConf offset\nd.exceltable(excelTable, options);\n});\n\n\/\/now we have to decide which table will be in which sheet\n\/\/the cleanest way is to have a table per sheet\n\/\/TODO make this variable so more messy version are possible\nList<List<List<ExcelTable>>> workbookSheetTables = new ArrayList<>();\nfor (List<ExcelTable> workbookTables : workbookClusters) {\nList<List<ExcelTable>> sheetTables = new ArrayList<>();\nfor (ExcelTable tbl : workbookTables) {\nList<ExcelTable> sheet = Arrays.asList(tbl);\nsheetTables.add(sheet);\n}\nworkbookSheetTables.add(sheetTables);\n}\nint maxDigits = String.valueOf(workbookSheetTables.size() - 1).length();\nMap<List<ExcelTable>, ExcelGeneratorSheetConfig> sheetConfigMap = new HashMap<>();\n\/\/now we use the ExcelGenerator to generate the workbooks\nExcelGenerator excelGenerator = new ExcelGenerator();\nfor (int i = 0; i < workbookSheetTables.size(); i++) {\nList<List<ExcelTable>> sheets = workbookSheetTables.get(i);\n\/\/create a config for this workbook\nExcelGeneratorWorkbookConfig workbookConf = new ExcelGeneratorWorkbookConfig();\n\/\/TODO configurable\nworkbookConf.setFileName(\"workbook.xlsx\");\nfor (List<ExcelTable> sheet : sheets) {\nExcelGeneratorSheetConfig sheetConf = new ExcelGeneratorSheetConfig();\nsheetConfigMap.put(sheet, sheetConf);\nStringBuilder sheetNameSB = new StringBuilder();\n\/\/TODO a second table in the sheet means we maybe have to move the offset\n\/\/ so that it will not overlap\nfor (int k = 0; k < sheet.size(); k++) {\nExcelTable excelTable = sheet.get(k);\nExcelGeneratorTableConfig tableConf = new ExcelGeneratorTableConfig();\n\/\/TODO maybe make a getSingleOrDefault method\nPoint offset = (Point) excelTable.getSetup().getOrDefault(\"offset\", new Point(0, 0));\ntableConf.setOffset(offset);\n\/\/draw the ExcelCell matrix from ExcelTable\ntableConf.setStaticCellDrawer(d -> {\n\/\/it uses the tableConf offset\nd.exceltable(excelTable, options);\n});\nsheetConf.getTableConfigs().add(tableConf);\n\/\/TODO if only one table with one class: add provenance sheetname -> insts a class. (for all insts)\n\nfor (ExcelTable tbl : workbookTables) {\nList<ExcelTable> sheet = Arrays.asList(tbl);\nsheetTables.add(sheet);\n}\nworkbookSheetTables.add(sheetTables);\n}\nint maxDigits = String.valueOf(workbookSheetTables.size() - 1).length();\nMap<List<ExcelTable>, ExcelGeneratorSheetConfig> sheetConfigMap = new HashMap<>();\n\/\/now we use the ExcelGenerator to generate the workbooks\nExcelGenerator excelGenerator = new ExcelGenerator();\nfor (int i = 0; i < workbookSheetTables.size(); i++) {\nList<List<ExcelTable>> sheets = workbookSheetTables.get(i);\n\/\/create a config for this workbook\nExcelGeneratorWorkbookConfig workbookConf = new ExcelGeneratorWorkbookConfig();\n\/\/TODO configurable\nworkbookConf.setFileName(\"workbook.xlsx\");\nfor (List<ExcelTable> sheet : sheets) {\nExcelGeneratorSheetConfig sheetConf = new ExcelGeneratorSheetConfig();\nsheetConfigMap.put(sheet, sheetConf);\nStringBuilder sheetNameSB = new StringBuilder();\n\/\/TODO a second table in the sheet means we maybe have to move the offset\n\/\/ so that it will not overlap\nfor (int k = 0; k < sheet.size(); k++) {\nExcelTable excelTable = sheet.get(k);\nExcelGeneratorTableConfig tableConf = new ExcelGeneratorTableConfig();\n\/\/TODO maybe make a getSingleOrDefault method\nPoint offset = (Point) excelTable.getSetup().getOrDefault(\"offset\", new Point(0, 0));\ntableConf.setOffset(offset);\n\/\/draw the ExcelCell matrix from ExcelTable\ntableConf.setStaticCellDrawer(d -> {\n\/\/it uses the tableConf offset\nd.exceltable(excelTable, options);\n});\nsheetConf.getTableConfigs().add(tableConf);\n\/\/TODO if only one table with one class: add provenance sheetname -> insts a class. (for all insts)\nClassConfig classConfig = excelTable.getSetup().getOrThrow(\"classes\", ClassConfig.class);\nif (classConfig.hasLabel()) {\nsheetNameSB.append(classConfig.getLabel());\n} else {\nthrow new RuntimeException(\"ClassConfig should give a label to name the sheet\");\n}\n\/\/in one sheet multiple tables could be existing\n\n}\nint maxDigits = String.valueOf(workbookSheetTables.size() - 1).length();\nMap<List<ExcelTable>, ExcelGeneratorSheetConfig> sheetConfigMap = new HashMap<>();\n\/\/now we use the ExcelGenerator to generate the workbooks\nExcelGenerator excelGenerator = new ExcelGenerator();\nfor (int i = 0; i < workbookSheetTables.size(); i++) {\nList<List<ExcelTable>> sheets = workbookSheetTables.get(i);\n\/\/create a config for this workbook\nExcelGeneratorWorkbookConfig workbookConf = new ExcelGeneratorWorkbookConfig();\n\/\/TODO configurable\nworkbookConf.setFileName(\"workbook.xlsx\");\nfor (List<ExcelTable> sheet : sheets) {\nExcelGeneratorSheetConfig sheetConf = new ExcelGeneratorSheetConfig();\nsheetConfigMap.put(sheet, sheetConf);\nStringBuilder sheetNameSB = new StringBuilder();\n\/\/TODO a second table in the sheet means we maybe have to move the offset\n\/\/ so that it will not overlap\nfor (int k = 0; k < sheet.size(); k++) {\nExcelTable excelTable = sheet.get(k);\nExcelGeneratorTableConfig tableConf = new ExcelGeneratorTableConfig();\n\/\/TODO maybe make a getSingleOrDefault method\nPoint offset = (Point) excelTable.getSetup().getOrDefault(\"offset\", new Point(0, 0));\ntableConf.setOffset(offset);\n\/\/draw the ExcelCell matrix from ExcelTable\ntableConf.setStaticCellDrawer(d -> {\n\/\/it uses the tableConf offset\nd.exceltable(excelTable, options);\n});\nsheetConf.getTableConfigs().add(tableConf);\n\/\/TODO if only one table with one class: add provenance sheetname -> insts a class. (for all insts)\nClassConfig classConfig = excelTable.getSetup().getOrThrow(\"classes\", ClassConfig.class);\nif (classConfig.hasLabel()) {\nsheetNameSB.append(classConfig.getLabel());\n} else {\nthrow new RuntimeException(\"ClassConfig should give a label to name the sheet\");\n}\n\/\/in one sheet multiple tables could be existing\nif (k != sheet.size() - 1) {\nsheetNameSB.append(\" & \");\n}\n}\n\n\/\/now we use the ExcelGenerator to generate the workbooks\nExcelGenerator excelGenerator = new ExcelGenerator();\nfor (int i = 0; i < workbookSheetTables.size(); i++) {\nList<List<ExcelTable>> sheets = workbookSheetTables.get(i);\n\/\/create a config for this workbook\nExcelGeneratorWorkbookConfig workbookConf = new ExcelGeneratorWorkbookConfig();\n\/\/TODO configurable\nworkbookConf.setFileName(\"workbook.xlsx\");\nfor (List<ExcelTable> sheet : sheets) {\nExcelGeneratorSheetConfig sheetConf = new ExcelGeneratorSheetConfig();\nsheetConfigMap.put(sheet, sheetConf);\nStringBuilder sheetNameSB = new StringBuilder();\n\/\/TODO a second table in the sheet means we maybe have to move the offset\n\/\/ so that it will not overlap\nfor (int k = 0; k < sheet.size(); k++) {\nExcelTable excelTable = sheet.get(k);\nExcelGeneratorTableConfig tableConf = new ExcelGeneratorTableConfig();\n\/\/TODO maybe make a getSingleOrDefault method\nPoint offset = (Point) excelTable.getSetup().getOrDefault(\"offset\", new Point(0, 0));\ntableConf.setOffset(offset);\n\/\/draw the ExcelCell matrix from ExcelTable\ntableConf.setStaticCellDrawer(d -> {\n\/\/it uses the tableConf offset\nd.exceltable(excelTable, options);\n});\nsheetConf.getTableConfigs().add(tableConf);\n\/\/TODO if only one table with one class: add provenance sheetname -> insts a class. (for all insts)\nClassConfig classConfig = excelTable.getSetup().getOrThrow(\"classes\", ClassConfig.class);\nif (classConfig.hasLabel()) {\nsheetNameSB.append(classConfig.getLabel());\n} else {\nthrow new RuntimeException(\"ClassConfig should give a label to name the sheet\");\n}\n\/\/in one sheet multiple tables could be existing\nif (k != sheet.size() - 1) {\nsheetNameSB.append(\" & \");\n}\n}\n\/\/sheet name comes from table content\nsheetConf.setSheetName(sheetNameSB.toString());\nworkbookConf.getSheetConfigs().add(sheetConf);\n\nfor (int i = 0; i < workbookSheetTables.size(); i++) {\nList<List<ExcelTable>> sheets = workbookSheetTables.get(i);\n\/\/create a config for this workbook\nExcelGeneratorWorkbookConfig workbookConf = new ExcelGeneratorWorkbookConfig();\n\/\/TODO configurable\nworkbookConf.setFileName(\"workbook.xlsx\");\nfor (List<ExcelTable> sheet : sheets) {\nExcelGeneratorSheetConfig sheetConf = new ExcelGeneratorSheetConfig();\nsheetConfigMap.put(sheet, sheetConf);\nStringBuilder sheetNameSB = new StringBuilder();\n\/\/TODO a second table in the sheet means we maybe have to move the offset\n\/\/ so that it will not overlap\nfor (int k = 0; k < sheet.size(); k++) {\nExcelTable excelTable = sheet.get(k);\nExcelGeneratorTableConfig tableConf = new ExcelGeneratorTableConfig();\n\/\/TODO maybe make a getSingleOrDefault method\nPoint offset = (Point) excelTable.getSetup().getOrDefault(\"offset\", new Point(0, 0));\ntableConf.setOffset(offset);\n\/\/draw the ExcelCell matrix from ExcelTable\ntableConf.setStaticCellDrawer(d -> {\n\/\/it uses the tableConf offset\nd.exceltable(excelTable, options);\n});\nsheetConf.getTableConfigs().add(tableConf);\n\/\/TODO if only one table with one class: add provenance sheetname -> insts a class. (for all insts)\nClassConfig classConfig = excelTable.getSetup().getOrThrow(\"classes\", ClassConfig.class);\nif (classConfig.hasLabel()) {\nsheetNameSB.append(classConfig.getLabel());\n} else {\nthrow new RuntimeException(\"ClassConfig should give a label to name the sheet\");\n}\n\/\/in one sheet multiple tables could be existing\nif (k != sheet.size() - 1) {\nsheetNameSB.append(\" & \");\n}\n}\n\/\/sheet name comes from table content\nsheetConf.setSheetName(sheetNameSB.toString());\nworkbookConf.getSheetConfigs().add(sheetConf);\n}\/\/per sheet\nExcelGeneratorResult result = excelGenerator.generate(null, workbookConf);\n\n\/\/TODO configurable\nworkbookConf.setFileName(\"workbook.xlsx\");\nfor (List<ExcelTable> sheet : sheets) {\nExcelGeneratorSheetConfig sheetConf = new ExcelGeneratorSheetConfig();\nsheetConfigMap.put(sheet, sheetConf);\nStringBuilder sheetNameSB = new StringBuilder();\n\/\/TODO a second table in the sheet means we maybe have to move the offset\n\/\/ so that it will not overlap\nfor (int k = 0; k < sheet.size(); k++) {\nExcelTable excelTable = sheet.get(k);\nExcelGeneratorTableConfig tableConf = new ExcelGeneratorTableConfig();\n\/\/TODO maybe make a getSingleOrDefault method\nPoint offset = (Point) excelTable.getSetup().getOrDefault(\"offset\", new Point(0, 0));\ntableConf.setOffset(offset);\n\/\/draw the ExcelCell matrix from ExcelTable\ntableConf.setStaticCellDrawer(d -> {\n\/\/it uses the tableConf offset\nd.exceltable(excelTable, options);\n});\nsheetConf.getTableConfigs().add(tableConf);\n\/\/TODO if only one table with one class: add provenance sheetname -> insts a class. (for all insts)\nClassConfig classConfig = excelTable.getSetup().getOrThrow(\"classes\", ClassConfig.class);\nif (classConfig.hasLabel()) {\nsheetNameSB.append(classConfig.getLabel());\n} else {\nthrow new RuntimeException(\"ClassConfig should give a label to name the sheet\");\n}\n\/\/in one sheet multiple tables could be existing\nif (k != sheet.size() - 1) {\nsheetNameSB.append(\" & \");\n}\n}\n\/\/sheet name comes from table content\nsheetConf.setSheetName(sheetNameSB.toString());\nworkbookConf.getSheetConfigs().add(sheetConf);\n}\/\/per sheet\nExcelGeneratorResult result = excelGenerator.generate(null, workbookConf);\n\/\/System.out.println(\"save workbook \" + i);\n\/\/no extra folder when only one workbook\nFile workbookFolder = workbookSheetTables.size() == 1 ? dstFolder : new File(dstFolder, String.format(\"%0\" + maxDigits + \"d\", i));\nresult.saveExcel(workbookFolder);\n\n\/\/ so that it will not overlap\nfor (int k = 0; k < sheet.size(); k++) {\nExcelTable excelTable = sheet.get(k);\nExcelGeneratorTableConfig tableConf = new ExcelGeneratorTableConfig();\n\/\/TODO maybe make a getSingleOrDefault method\nPoint offset = (Point) excelTable.getSetup().getOrDefault(\"offset\", new Point(0, 0));\ntableConf.setOffset(offset);\n\/\/draw the ExcelCell matrix from ExcelTable\ntableConf.setStaticCellDrawer(d -> {\n\/\/it uses the tableConf offset\nd.exceltable(excelTable, options);\n});\nsheetConf.getTableConfigs().add(tableConf);\n\/\/TODO if only one table with one class: add provenance sheetname -> insts a class. (for all insts)\nClassConfig classConfig = excelTable.getSetup().getOrThrow(\"classes\", ClassConfig.class);\nif (classConfig.hasLabel()) {\nsheetNameSB.append(classConfig.getLabel());\n} else {\nthrow new RuntimeException(\"ClassConfig should give a label to name the sheet\");\n}\n\/\/in one sheet multiple tables could be existing\nif (k != sheet.size() - 1) {\nsheetNameSB.append(\" & \");\n}\n}\n\/\/sheet name comes from table content\nsheetConf.setSheetName(sheetNameSB.toString());\nworkbookConf.getSheetConfigs().add(sheetConf);\n}\/\/per sheet\nExcelGeneratorResult result = excelGenerator.generate(null, workbookConf);\n\/\/System.out.println(\"save workbook \" + i);\n\/\/no extra folder when only one workbook\nFile workbookFolder = workbookSheetTables.size() == 1 ? dstFolder : new File(dstFolder, String.format(\"%0\" + maxDigits + \"d\", i));\nresult.saveExcel(workbookFolder);\n\/\/write provenance =================================================\nModel expectedModel = null;\nModel provenanceModel = null;\nCSVPrinter provenanceCSV = null;\nif (options.isWriteExpectedModel()) {\nexpectedModel = ModelFactory.createDefaultModel();\nexpectedModel.setNsPrefixes(options.getPrefixMapping());\n\nPoint offset = (Point) excelTable.getSetup().getOrDefault(\"offset\", new Point(0, 0));\ntableConf.setOffset(offset);\n\/\/draw the ExcelCell matrix from ExcelTable\ntableConf.setStaticCellDrawer(d -> {\n\/\/it uses the tableConf offset\nd.exceltable(excelTable, options);\n});\nsheetConf.getTableConfigs().add(tableConf);\n\/\/TODO if only one table with one class: add provenance sheetname -> insts a class. (for all insts)\nClassConfig classConfig = excelTable.getSetup().getOrThrow(\"classes\", ClassConfig.class);\nif (classConfig.hasLabel()) {\nsheetNameSB.append(classConfig.getLabel());\n} else {\nthrow new RuntimeException(\"ClassConfig should give a label to name the sheet\");\n}\n\/\/in one sheet multiple tables could be existing\nif (k != sheet.size() - 1) {\nsheetNameSB.append(\" & \");\n}\n}\n\/\/sheet name comes from table content\nsheetConf.setSheetName(sheetNameSB.toString());\nworkbookConf.getSheetConfigs().add(sheetConf);\n}\/\/per sheet\nExcelGeneratorResult result = excelGenerator.generate(null, workbookConf);\n\/\/System.out.println(\"save workbook \" + i);\n\/\/no extra folder when only one workbook\nFile workbookFolder = workbookSheetTables.size() == 1 ? dstFolder : new File(dstFolder, String.format(\"%0\" + maxDigits + \"d\", i));\nresult.saveExcel(workbookFolder);\n\/\/write provenance =================================================\nModel expectedModel = null;\nModel provenanceModel = null;\nCSVPrinter provenanceCSV = null;\nif (options.isWriteExpectedModel()) {\nexpectedModel = ModelFactory.createDefaultModel();\nexpectedModel.setNsPrefixes(options.getPrefixMapping());\nexpectedModel.setNsPrefixes(PrefixMapping.Standard);\n}\nif (options.isWriteProvenanceModel()) {\nprovenanceModel = ModelFactory.createDefaultModel();\nprovenanceModel.setNsPrefixes(options.getPrefixMapping());\n\ntableConf.setStaticCellDrawer(d -> {\n\/\/it uses the tableConf offset\nd.exceltable(excelTable, options);\n});\nsheetConf.getTableConfigs().add(tableConf);\n\/\/TODO if only one table with one class: add provenance sheetname -> insts a class. (for all insts)\nClassConfig classConfig = excelTable.getSetup().getOrThrow(\"classes\", ClassConfig.class);\nif (classConfig.hasLabel()) {\nsheetNameSB.append(classConfig.getLabel());\n} else {\nthrow new RuntimeException(\"ClassConfig should give a label to name the sheet\");\n}\n\/\/in one sheet multiple tables could be existing\nif (k != sheet.size() - 1) {\nsheetNameSB.append(\" & \");\n}\n}\n\/\/sheet name comes from table content\nsheetConf.setSheetName(sheetNameSB.toString());\nworkbookConf.getSheetConfigs().add(sheetConf);\n}\/\/per sheet\nExcelGeneratorResult result = excelGenerator.generate(null, workbookConf);\n\/\/System.out.println(\"save workbook \" + i);\n\/\/no extra folder when only one workbook\nFile workbookFolder = workbookSheetTables.size() == 1 ? dstFolder : new File(dstFolder, String.format(\"%0\" + maxDigits + \"d\", i));\nresult.saveExcel(workbookFolder);\n\/\/write provenance =================================================\nModel expectedModel = null;\nModel provenanceModel = null;\nCSVPrinter provenanceCSV = null;\nif (options.isWriteExpectedModel()) {\nexpectedModel = ModelFactory.createDefaultModel();\nexpectedModel.setNsPrefixes(options.getPrefixMapping());\nexpectedModel.setNsPrefixes(PrefixMapping.Standard);\n}\nif (options.isWriteProvenanceModel()) {\nprovenanceModel = ModelFactory.createDefaultModel();\nprovenanceModel.setNsPrefixes(options.getPrefixMapping());\nprovenanceModel.setNsPrefix(\"prov\", PROV.NS);\nprovenanceModel.setNsPrefix(\"csvw\", CSVW.NS);\nprovenanceModel.setNsPrefix(\"ss\", SS.NS);\n\nd.exceltable(excelTable, options);\n});\nsheetConf.getTableConfigs().add(tableConf);\n\/\/TODO if only one table with one class: add provenance sheetname -> insts a class. (for all insts)\nClassConfig classConfig = excelTable.getSetup().getOrThrow(\"classes\", ClassConfig.class);\nif (classConfig.hasLabel()) {\nsheetNameSB.append(classConfig.getLabel());\n} else {\nthrow new RuntimeException(\"ClassConfig should give a label to name the sheet\");\n}\n\/\/in one sheet multiple tables could be existing\nif (k != sheet.size() - 1) {\nsheetNameSB.append(\" & \");\n}\n}\n\/\/sheet name comes from table content\nsheetConf.setSheetName(sheetNameSB.toString());\nworkbookConf.getSheetConfigs().add(sheetConf);\n}\/\/per sheet\nExcelGeneratorResult result = excelGenerator.generate(null, workbookConf);\n\/\/System.out.println(\"save workbook \" + i);\n\/\/no extra folder when only one workbook\nFile workbookFolder = workbookSheetTables.size() == 1 ? dstFolder : new File(dstFolder, String.format(\"%0\" + maxDigits + \"d\", i));\nresult.saveExcel(workbookFolder);\n\/\/write provenance =================================================\nModel expectedModel = null;\nModel provenanceModel = null;\nCSVPrinter provenanceCSV = null;\nif (options.isWriteExpectedModel()) {\nexpectedModel = ModelFactory.createDefaultModel();\nexpectedModel.setNsPrefixes(options.getPrefixMapping());\nexpectedModel.setNsPrefixes(PrefixMapping.Standard);\n}\nif (options.isWriteProvenanceModel()) {\nprovenanceModel = ModelFactory.createDefaultModel();\nprovenanceModel.setNsPrefixes(options.getPrefixMapping());\nprovenanceModel.setNsPrefix(\"prov\", PROV.NS);\nprovenanceModel.setNsPrefix(\"csvw\", CSVW.NS);\nprovenanceModel.setNsPrefix(\"ss\", SS.NS);\nprovenanceModel.setNsPrefixes(PrefixMapping.Standard);\n}\nif (options.isWriteProvenanceCSV()) {\n\nClassConfig classConfig = excelTable.getSetup().getOrThrow(\"classes\", ClassConfig.class);\nif (classConfig.hasLabel()) {\nsheetNameSB.append(classConfig.getLabel());\n} else {\nthrow new RuntimeException(\"ClassConfig should give a label to name the sheet\");\n}\n\/\/in one sheet multiple tables could be existing\nif (k != sheet.size() - 1) {\nsheetNameSB.append(\" & \");\n}\n}\n\/\/sheet name comes from table content\nsheetConf.setSheetName(sheetNameSB.toString());\nworkbookConf.getSheetConfigs().add(sheetConf);\n}\/\/per sheet\nExcelGeneratorResult result = excelGenerator.generate(null, workbookConf);\n\/\/System.out.println(\"save workbook \" + i);\n\/\/no extra folder when only one workbook\nFile workbookFolder = workbookSheetTables.size() == 1 ? dstFolder : new File(dstFolder, String.format(\"%0\" + maxDigits + \"d\", i));\nresult.saveExcel(workbookFolder);\n\/\/write provenance =================================================\nModel expectedModel = null;\nModel provenanceModel = null;\nCSVPrinter provenanceCSV = null;\nif (options.isWriteExpectedModel()) {\nexpectedModel = ModelFactory.createDefaultModel();\nexpectedModel.setNsPrefixes(options.getPrefixMapping());\nexpectedModel.setNsPrefixes(PrefixMapping.Standard);\n}\nif (options.isWriteProvenanceModel()) {\nprovenanceModel = ModelFactory.createDefaultModel();\nprovenanceModel.setNsPrefixes(options.getPrefixMapping());\nprovenanceModel.setNsPrefix(\"prov\", PROV.NS);\nprovenanceModel.setNsPrefix(\"csvw\", CSVW.NS);\nprovenanceModel.setNsPrefix(\"ss\", SS.NS);\nprovenanceModel.setNsPrefixes(PrefixMapping.Standard);\n}\nif (options.isWriteProvenanceCSV()) {\ntry {\nprovenanceCSV = CSVFormat.DEFAULT.print(\nnew OutputStreamWriter(\n\nprovenanceModel = ModelFactory.createDefaultModel();\nprovenanceModel.setNsPrefixes(options.getPrefixMapping());\nprovenanceModel.setNsPrefix(\"prov\", PROV.NS);\nprovenanceModel.setNsPrefix(\"csvw\", CSVW.NS);\nprovenanceModel.setNsPrefix(\"ss\", SS.NS);\nprovenanceModel.setNsPrefixes(PrefixMapping.Standard);\n}\nif (options.isWriteProvenanceCSV()) {\ntry {\nprovenanceCSV = CSVFormat.DEFAULT.print(\nnew OutputStreamWriter(\nnew GZIPOutputStream(\nnew FileOutputStream(\nnew File(workbookFolder, \"provenance.csv.gz\")\n))));\ncsvProvenanceHeader(provenanceCSV);\n} catch (IOException ex) {\nthrow new RuntimeException(ex);\n}\n}\n\/\/used in rdfProvenance for fast lookup reified statements\nMap<Statement, Resource> stmt2res = new HashMap<>();\n\/\/need here sheetname for provenance\nfor (List<ExcelTable> sheet : sheets) {\nExcelGeneratorSheetConfig sheetConfig = sheetConfigMap.get(sheet);\nfor (ExcelTable table : sheet) {\nfor (Entry<ExcelCell, Provenance> cell2prov : table.getCellProvMap().entrySet()) {\nExcelCell cell = cell2prov.getKey();\nProvenance prov = cell2prov.getValue();\nif (cell.getAddress() == null) {\n\/\/this was a temporary cell created for a merge\n\/\/in TableGenerator putMultipleObjects method\ncontinue;\n}\nif (prov.getStatements().isEmpty()) {\n\/\/no provenance information for this cell\ncontinue;\n}\nif (options.isWriteExpectedModel()) {\nexpectedModel.add(prov.getStatements());\n}\n\nprovenanceModel.setNsPrefix(\"prov\", PROV.NS);\nprovenanceModel.setNsPrefix(\"csvw\", CSVW.NS);\nprovenanceModel.setNsPrefix(\"ss\", SS.NS);\nprovenanceModel.setNsPrefixes(PrefixMapping.Standard);\n}\nif (options.isWriteProvenanceCSV()) {\ntry {\nprovenanceCSV = CSVFormat.DEFAULT.print(\nnew OutputStreamWriter(\nnew GZIPOutputStream(\nnew FileOutputStream(\nnew File(workbookFolder, \"provenance.csv.gz\")\n))));\ncsvProvenanceHeader(provenanceCSV);\n} catch (IOException ex) {\nthrow new RuntimeException(ex);\n}\n}\n\/\/used in rdfProvenance for fast lookup reified statements\nMap<Statement, Resource> stmt2res = new HashMap<>();\n\/\/need here sheetname for provenance\nfor (List<ExcelTable> sheet : sheets) {\nExcelGeneratorSheetConfig sheetConfig = sheetConfigMap.get(sheet);\nfor (ExcelTable table : sheet) {\nfor (Entry<ExcelCell, Provenance> cell2prov : table.getCellProvMap().entrySet()) {\nExcelCell cell = cell2prov.getKey();\nProvenance prov = cell2prov.getValue();\nif (cell.getAddress() == null) {\n\/\/this was a temporary cell created for a merge\n\/\/in TableGenerator putMultipleObjects method\ncontinue;\n}\nif (prov.getStatements().isEmpty()) {\n\/\/no provenance information for this cell\ncontinue;\n}\nif (options.isWriteExpectedModel()) {\nexpectedModel.add(prov.getStatements());\n}\nif (options.isWriteProvenanceModel()) {\nrdfProvenance(cell, sheetConfig.getSheetName(), prov, stmt2res, provenanceModel);\n\nnew OutputStreamWriter(\nnew GZIPOutputStream(\nnew FileOutputStream(\nnew File(workbookFolder, \"provenance.csv.gz\")\n))));\ncsvProvenanceHeader(provenanceCSV);\n} catch (IOException ex) {\nthrow new RuntimeException(ex);\n}\n}\n\/\/used in rdfProvenance for fast lookup reified statements\nMap<Statement, Resource> stmt2res = new HashMap<>();\n\/\/need here sheetname for provenance\nfor (List<ExcelTable> sheet : sheets) {\nExcelGeneratorSheetConfig sheetConfig = sheetConfigMap.get(sheet);\nfor (ExcelTable table : sheet) {\nfor (Entry<ExcelCell, Provenance> cell2prov : table.getCellProvMap().entrySet()) {\nExcelCell cell = cell2prov.getKey();\nProvenance prov = cell2prov.getValue();\nif (cell.getAddress() == null) {\n\/\/this was a temporary cell created for a merge\n\/\/in TableGenerator putMultipleObjects method\ncontinue;\n}\nif (prov.getStatements().isEmpty()) {\n\/\/no provenance information for this cell\ncontinue;\n}\nif (options.isWriteExpectedModel()) {\nexpectedModel.add(prov.getStatements());\n}\nif (options.isWriteProvenanceModel()) {\nrdfProvenance(cell, sheetConfig.getSheetName(), prov, stmt2res, provenanceModel);\n}\nif (options.isWriteProvenanceCSV()) {\ncsvProvenance(cell, sheetConfig.getSheetName(), prov, provenanceCSV, provenanceModel);\n}\n}\n}\n}\n\/\/write to files\nif (options.isWriteExpectedModel()) {\n\ncsvProvenanceHeader(provenanceCSV);\n} catch (IOException ex) {\nthrow new RuntimeException(ex);\n}\n}\n\/\/used in rdfProvenance for fast lookup reified statements\nMap<Statement, Resource> stmt2res = new HashMap<>();\n\/\/need here sheetname for provenance\nfor (List<ExcelTable> sheet : sheets) {\nExcelGeneratorSheetConfig sheetConfig = sheetConfigMap.get(sheet);\nfor (ExcelTable table : sheet) {\nfor (Entry<ExcelCell, Provenance> cell2prov : table.getCellProvMap().entrySet()) {\nExcelCell cell = cell2prov.getKey();\nProvenance prov = cell2prov.getValue();\nif (cell.getAddress() == null) {\n\/\/this was a temporary cell created for a merge\n\/\/in TableGenerator putMultipleObjects method\ncontinue;\n}\nif (prov.getStatements().isEmpty()) {\n\/\/no provenance information for this cell\ncontinue;\n}\nif (options.isWriteExpectedModel()) {\nexpectedModel.add(prov.getStatements());\n}\nif (options.isWriteProvenanceModel()) {\nrdfProvenance(cell, sheetConfig.getSheetName(), prov, stmt2res, provenanceModel);\n}\nif (options.isWriteProvenanceCSV()) {\ncsvProvenance(cell, sheetConfig.getSheetName(), prov, provenanceCSV, provenanceModel);\n}\n}\n}\n}\n\/\/write to files\nif (options.isWriteExpectedModel()) {\nFile file = new File(workbookFolder, \"expected.ttl.gz\");\ntry (OutputStream os = file.getName().endsWith(\"gz\") ? new GZIPOutputStream(new FileOutputStream(file)) : new FileOutputStream(file)) {\nexpectedModel.write(os, \"TTL\");\n} catch (IOException ex) {\n\n\/\/this was a temporary cell created for a merge\n\/\/in TableGenerator putMultipleObjects method\ncontinue;\n}\nif (prov.getStatements().isEmpty()) {\n\/\/no provenance information for this cell\ncontinue;\n}\nif (options.isWriteExpectedModel()) {\nexpectedModel.add(prov.getStatements());\n}\nif (options.isWriteProvenanceModel()) {\nrdfProvenance(cell, sheetConfig.getSheetName(), prov, stmt2res, provenanceModel);\n}\nif (options.isWriteProvenanceCSV()) {\ncsvProvenance(cell, sheetConfig.getSheetName(), prov, provenanceCSV, provenanceModel);\n}\n}\n}\n}\n\/\/write to files\nif (options.isWriteExpectedModel()) {\nFile file = new File(workbookFolder, \"expected.ttl.gz\");\ntry (OutputStream os = file.getName().endsWith(\"gz\") ? new GZIPOutputStream(new FileOutputStream(file)) : new FileOutputStream(file)) {\nexpectedModel.write(os, \"TTL\");\n} catch (IOException ex) {\nthrow new RuntimeException(ex);\n}\n}\nif (options.isWriteProvenanceModel()) {\nFile file = new File(workbookFolder, \"provenance.ttl.gz\");\ntry (OutputStream os = file.getName().endsWith(\"gz\") ? new GZIPOutputStream(new FileOutputStream(file)) : new FileOutputStream(file)) {\nprovenanceModel.write(os, \"TTL\");\n} catch (IOException ex) {\nthrow new RuntimeException(ex);\n}\n}\nif (options.isWriteProvenanceCSV()) {\ntry {\nprovenanceCSV.close();\n} catch (IOException ex) {\n\n} catch (IOException ex) {\nthrow new RuntimeException(ex);\n}\n}\nif (options.isWriteProvenanceModel()) {\nFile file = new File(workbookFolder, \"provenance.ttl.gz\");\ntry (OutputStream os = file.getName().endsWith(\"gz\") ? new GZIPOutputStream(new FileOutputStream(file)) : new FileOutputStream(file)) {\nprovenanceModel.write(os, \"TTL\");\n} catch (IOException ex) {\nthrow new RuntimeException(ex);\n}\n}\nif (options.isWriteProvenanceCSV()) {\ntry {\nprovenanceCSV.close();\n} catch (IOException ex) {\nthrow new RuntimeException(ex);\n}\n}\nif (options.isWriteGenerationSummaryJson()) {\n\/\/key is sheet name\nJSONObject perSheetPatternUsage = new JSONObject();\nJsonUtility.forceLinkedHashMap(perSheetPatternUsage);\nfor (List<ExcelTable> sheet : sheets) {\nExcelGeneratorSheetConfig sheetConfig = sheetConfigMap.get(sheet);\n\/\/count how often\nMap<String, Map<Object, Integer>> pattern2value2count = new HashMap<>();\nfor (ExcelTable tbl : sheet) {\nfor (Entry<ExcelCell, Provenance> entry : tbl.getCellProvMap().entrySet()) {\n\/\/skip the ones with no prov and no address (temp cells)\nif (entry.getKey().getAddress() == null || entry.getValue().getStatements().isEmpty()) {\ncontinue;\n}\nfor (Entry<String, Object> e : entry.getValue().getUsedPatterns().entrySet()) {\nObject val = e.getValue();\nif(val instanceof JSONArray) {\n\/\/because json array hash is always different\nval = val.toString();\n}\nMap<Object, Integer> value2count = pattern2value2count.computeIfAbsent(e.getKey(), k -> new HashMap<>());\nvalue2count.put(val, value2count.getOrDefault(val, 0) + 1);\n\nFile file = new File(workbookFolder, \"provenance.ttl.gz\");\ntry (OutputStream os = file.getName().endsWith(\"gz\") ? new GZIPOutputStream(new FileOutputStream(file)) : new FileOutputStream(file)) {\nprovenanceModel.write(os, \"TTL\");\n} catch (IOException ex) {\nthrow new RuntimeException(ex);\n}\n}\nif (options.isWriteProvenanceCSV()) {\ntry {\nprovenanceCSV.close();\n} catch (IOException ex) {\nthrow new RuntimeException(ex);\n}\n}\nif (options.isWriteGenerationSummaryJson()) {\n\/\/key is sheet name\nJSONObject perSheetPatternUsage = new JSONObject();\nJsonUtility.forceLinkedHashMap(perSheetPatternUsage);\nfor (List<ExcelTable> sheet : sheets) {\nExcelGeneratorSheetConfig sheetConfig = sheetConfigMap.get(sheet);\n\/\/count how often\nMap<String, Map<Object, Integer>> pattern2value2count = new HashMap<>();\nfor (ExcelTable tbl : sheet) {\nfor (Entry<ExcelCell, Provenance> entry : tbl.getCellProvMap().entrySet()) {\n\/\/skip the ones with no prov and no address (temp cells)\nif (entry.getKey().getAddress() == null || entry.getValue().getStatements().isEmpty()) {\ncontinue;\n}\nfor (Entry<String, Object> e : entry.getValue().getUsedPatterns().entrySet()) {\nObject val = e.getValue();\nif(val instanceof JSONArray) {\n\/\/because json array hash is always different\nval = val.toString();\n}\nMap<Object, Integer> value2count = pattern2value2count.computeIfAbsent(e.getKey(), k -> new HashMap<>());\nvalue2count.put(val, value2count.getOrDefault(val, 0) + 1);\n}\n}\n}\nJSONObject patternUsage = new JSONObject();\nJsonUtility.forceLinkedHashMap(patternUsage);\n\nthrow new RuntimeException(ex);\n}\n}\nif (options.isWriteProvenanceCSV()) {\ntry {\nprovenanceCSV.close();\n} catch (IOException ex) {\nthrow new RuntimeException(ex);\n}\n}\nif (options.isWriteGenerationSummaryJson()) {\n\/\/key is sheet name\nJSONObject perSheetPatternUsage = new JSONObject();\nJsonUtility.forceLinkedHashMap(perSheetPatternUsage);\nfor (List<ExcelTable> sheet : sheets) {\nExcelGeneratorSheetConfig sheetConfig = sheetConfigMap.get(sheet);\n\/\/count how often\nMap<String, Map<Object, Integer>> pattern2value2count = new HashMap<>();\nfor (ExcelTable tbl : sheet) {\nfor (Entry<ExcelCell, Provenance> entry : tbl.getCellProvMap().entrySet()) {\n\/\/skip the ones with no prov and no address (temp cells)\nif (entry.getKey().getAddress() == null || entry.getValue().getStatements().isEmpty()) {\ncontinue;\n}\nfor (Entry<String, Object> e : entry.getValue().getUsedPatterns().entrySet()) {\nObject val = e.getValue();\nif(val instanceof JSONArray) {\n\/\/because json array hash is always different\nval = val.toString();\n}\nMap<Object, Integer> value2count = pattern2value2count.computeIfAbsent(e.getKey(), k -> new HashMap<>());\nvalue2count.put(val, value2count.getOrDefault(val, 0) + 1);\n}\n}\n}\nJSONObject patternUsage = new JSONObject();\nJsonUtility.forceLinkedHashMap(patternUsage);\nList<Entry<String, Map<Object, Integer>>> pattern2value2countList = new ArrayList<>(pattern2value2count.entrySet());\npattern2value2countList.sort((a,b) -> a.getKey().compareTo(b.getKey()));\nfor (Entry<String, Map<Object, Integer>> pattern2value2countEntry : pattern2value2countList) {\nJSONArray array = new JSONArray();\n\nthrow new RuntimeException(ex);\n}\n}\nif (options.isWriteGenerationSummaryJson()) {\n\/\/key is sheet name\nJSONObject perSheetPatternUsage = new JSONObject();\nJsonUtility.forceLinkedHashMap(perSheetPatternUsage);\nfor (List<ExcelTable> sheet : sheets) {\nExcelGeneratorSheetConfig sheetConfig = sheetConfigMap.get(sheet);\n\/\/count how often\nMap<String, Map<Object, Integer>> pattern2value2count = new HashMap<>();\nfor (ExcelTable tbl : sheet) {\nfor (Entry<ExcelCell, Provenance> entry : tbl.getCellProvMap().entrySet()) {\n\/\/skip the ones with no prov and no address (temp cells)\nif (entry.getKey().getAddress() == null || entry.getValue().getStatements().isEmpty()) {\ncontinue;\n}\nfor (Entry<String, Object> e : entry.getValue().getUsedPatterns().entrySet()) {\nObject val = e.getValue();\nif(val instanceof JSONArray) {\n\/\/because json array hash is always different\nval = val.toString();\n}\nMap<Object, Integer> value2count = pattern2value2count.computeIfAbsent(e.getKey(), k -> new HashMap<>());\nvalue2count.put(val, value2count.getOrDefault(val, 0) + 1);\n}\n}\n}\nJSONObject patternUsage = new JSONObject();\nJsonUtility.forceLinkedHashMap(patternUsage);\nList<Entry<String, Map<Object, Integer>>> pattern2value2countList = new ArrayList<>(pattern2value2count.entrySet());\npattern2value2countList.sort((a,b) -> a.getKey().compareTo(b.getKey()));\nfor (Entry<String, Map<Object, Integer>> pattern2value2countEntry : pattern2value2countList) {\nJSONArray array = new JSONArray();\nfor (Entry<Object, Integer> e : pattern2value2countEntry.getValue().entrySet()) {\nJSONObject v2c = new JSONObject();\nJsonUtility.forceLinkedHashMap(v2c);\nv2c.put(\"value\", e.getKey());\nv2c.put(\"count\", e.getValue());\narray.put(v2c);\n}\n\nJSONArray array = new JSONArray();\nfor (Entry<Object, Integer> e : pattern2value2countEntry.getValue().entrySet()) {\nJSONObject v2c = new JSONObject();\nJsonUtility.forceLinkedHashMap(v2c);\nv2c.put(\"value\", e.getKey());\nv2c.put(\"count\", e.getValue());\narray.put(v2c);\n}\npatternUsage.put(pattern2value2countEntry.getKey(), array);\n}\nperSheetPatternUsage.put(sheetConfig.getSheetName(), patternUsage);\n}\noptions.getGenerationSummary().put(\"patternUsagePerSheet\", perSheetPatternUsage);\nFile file = new File(workbookFolder, \"summary.json\");\ntry {\nFileUtils.writeStringToFile(file, options.getGenerationSummary().toString(2), StandardCharsets.UTF_8);\n} catch (IOException ex) {\nthrow new RuntimeException(ex);\n}\n}\n}\/\/per workbook\n}","label":[1,1,0,0]}
{"id":16159,"original_code":"@Override\n    public boolean equals(Object o) {\n        if (this == o) return true;\n        if (o == null || getClass() != o.getClass()) return false;\n        ParameterizedTypeImpl that = (ParameterizedTypeImpl) o;\n        \/\/ Probably incorrect - comparing Object[] arrays with Arrays.equals\n        if (!Arrays.equals(actualTypeArguments, that.actualTypeArguments)) return false;\n        if (ownerType != null ? !ownerType.equals(that.ownerType) : that.ownerType != null) return false;\n        return rawType != null ? rawType.equals(that.rawType) : that.rawType == null;\n    }","code":"@Override\n    public boolean equals(Object o) {\n        if (this == o) return true;\n        if (o == null || getClass() != o.getClass()) return false;\n        ParameterizedTypeImpl that = (ParameterizedTypeImpl) o;\n       \n        if (!Arrays.equals(actualTypeArguments, that.actualTypeArguments)) return false;\n        if (ownerType != null ? !ownerType.equals(that.ownerType) : that.ownerType != null) return false;\n        return rawType != null ? rawType.equals(that.rawType) : that.rawType == null;\n    }","cleancode":"@override public boolean equals(object o) { if (this == o) return true; if (o == null || getclass() != o.getclass()) return false; parameterizedtypeimpl that = (parameterizedtypeimpl) o; if (!arrays.equals(actualtypearguments, that.actualtypearguments)) return false; if (ownertype != null ? !ownertype.equals(that.ownertype) : that.ownertype != null) return false; return rawtype != null ? rawtype.equals(that.rawtype) : that.rawtype == null; }","comment":"\/\/ probably incorrect - comparing object[] arrays with arrays.equals","repo":"osglworks\/java-di","code_context_2":"if (o == null || getClass() != o.getClass()) return false;\nParameterizedTypeImpl that = (ParameterizedTypeImpl) o;\n\/\/ Probably incorrect - comparing Object[] arrays with Arrays.equals\nif (!Arrays.equals(actualTypeArguments, that.actualTypeArguments)) return false;\nif (ownerType != null ? !ownerType.equals(that.ownerType) : that.ownerType != null) return false;","code_context_10":"@Override\npublic boolean equals(Object o) {\nif (this == o) return true;\nif (o == null || getClass() != o.getClass()) return false;\nParameterizedTypeImpl that = (ParameterizedTypeImpl) o;\n\/\/ Probably incorrect - comparing Object[] arrays with Arrays.equals\nif (!Arrays.equals(actualTypeArguments, that.actualTypeArguments)) return false;\nif (ownerType != null ? !ownerType.equals(that.ownerType) : that.ownerType != null) return false;\nreturn rawType != null ? rawType.equals(that.rawType) : that.rawType == null;\n}","code_context_20":"@Override\npublic boolean equals(Object o) {\nif (this == o) return true;\nif (o == null || getClass() != o.getClass()) return false;\nParameterizedTypeImpl that = (ParameterizedTypeImpl) o;\n\/\/ Probably incorrect - comparing Object[] arrays with Arrays.equals\nif (!Arrays.equals(actualTypeArguments, that.actualTypeArguments)) return false;\nif (ownerType != null ? !ownerType.equals(that.ownerType) : that.ownerType != null) return false;\nreturn rawType != null ? rawType.equals(that.rawType) : that.rawType == null;\n}","label":[0,0,1,0]}
{"id":8062,"original_code":"@Override \/\/ ObjectEventListener\n    public Object addingObject (Object obj, int index)\n    {\n        ObjectRenderer renderer = rendererFactory.newRenderer (obj);\n        \/\/ TODO: VAADIN SESSION HANDLING\n        layout.addComponent (renderer, index);\n        active_renderers.put (get_object_hash (obj), renderer);\n        log.info (\"<<RENDERER>> addingObject() layout height = {} {}\", layout.getHeight (), layout.getHeightUnits ().toString ());\n        log.info (\"Add new renderer {}: obj={} or={} \/\/\/ active_renderers={}\", this, get_object_hash (obj), renderer, active_renderers);\n        return (obj);\n    }","code":"@Override     public Object addingObject (Object obj, int index)\n    {\n        ObjectRenderer renderer = rendererFactory.newRenderer (obj);\n       \n        layout.addComponent (renderer, index);\n        active_renderers.put (get_object_hash (obj), renderer);\n        log.info (\"<<RENDERER>> addingObject() layout height = {} {}\", layout.getHeight (), layout.getHeightUnits ().toString ());\n        log.info (\"Add new renderer {}: obj={} or={} \/\/\/ active_renderers={}\", this, get_object_hash (obj), renderer, active_renderers);\n        return (obj);\n    }","cleancode":"@override public object addingobject (object obj, int index) { objectrenderer renderer = rendererfactory.newrenderer (obj); layout.addcomponent (renderer, index); active_renderers.put (get_object_hash (obj), renderer); log.info (\"<<renderer>> addingobject() layout height = {} {}\", layout.getheight (), layout.getheightunits ().tostring ()); log.info (\"add new renderer {}: obj={} or={} \/\/\/ active_renderers={}\", this, get_object_hash (obj), renderer, active_renderers); return (obj); }","comment":"\/\/ objecteventlistener\n\/\/ todo: vaadin session handling","repo":"neoautus\/lucidj","code_context_2":"@Override \/\/ ObjectEventListener\npublic Object addingObject (Object obj, int index)\n{\n\n{\nObjectRenderer renderer = rendererFactory.newRenderer (obj);\n\/\/ TODO: VAADIN SESSION HANDLING\nlayout.addComponent (renderer, index);\nactive_renderers.put (get_object_hash (obj), renderer);","code_context_10":"@Override \/\/ ObjectEventListener\npublic Object addingObject (Object obj, int index)\n{\nObjectRenderer renderer = rendererFactory.newRenderer (obj);\n\/\/ TODO: VAADIN SESSION HANDLING\nlayout.addComponent (renderer, index);\nactive_renderers.put (get_object_hash (obj), renderer);\nlog.info (\"<<RENDERER>> addingObject() layout height = {} {}\", layout.getHeight (), layout.getHeightUnits ().toString ());\nlog.info (\"Add new renderer {}: obj={} or={} \/\/\/ active_renderers={}\", this, get_object_hash (obj), renderer, active_renderers);\nreturn (obj);\n}\n\n@Override \/\/ ObjectEventListener\npublic Object addingObject (Object obj, int index)\n{\nObjectRenderer renderer = rendererFactory.newRenderer (obj);\n\/\/ TODO: VAADIN SESSION HANDLING\nlayout.addComponent (renderer, index);\nactive_renderers.put (get_object_hash (obj), renderer);\nlog.info (\"<<RENDERER>> addingObject() layout height = {} {}\", layout.getHeight (), layout.getHeightUnits ().toString ());\nlog.info (\"Add new renderer {}: obj={} or={} \/\/\/ active_renderers={}\", this, get_object_hash (obj), renderer, active_renderers);\nreturn (obj);\n}","code_context_20":"@Override \/\/ ObjectEventListener\npublic Object addingObject (Object obj, int index)\n{\nObjectRenderer renderer = rendererFactory.newRenderer (obj);\n\/\/ TODO: VAADIN SESSION HANDLING\nlayout.addComponent (renderer, index);\nactive_renderers.put (get_object_hash (obj), renderer);\nlog.info (\"<<RENDERER>> addingObject() layout height = {} {}\", layout.getHeight (), layout.getHeightUnits ().toString ());\nlog.info (\"Add new renderer {}: obj={} or={} \/\/\/ active_renderers={}\", this, get_object_hash (obj), renderer, active_renderers);\nreturn (obj);\n}\n\n@Override \/\/ ObjectEventListener\npublic Object addingObject (Object obj, int index)\n{\nObjectRenderer renderer = rendererFactory.newRenderer (obj);\n\/\/ TODO: VAADIN SESSION HANDLING\nlayout.addComponent (renderer, index);\nactive_renderers.put (get_object_hash (obj), renderer);\nlog.info (\"<<RENDERER>> addingObject() layout height = {} {}\", layout.getHeight (), layout.getHeightUnits ().toString ());\nlog.info (\"Add new renderer {}: obj={} or={} \/\/\/ active_renderers={}\", this, get_object_hash (obj), renderer, active_renderers);\nreturn (obj);\n}","label":[0,1,0,0]}
{"id":8063,"original_code":"@Override \/\/ ObjectEventListener\n    public void removingObject (Object obj, int index)\n    {\n        String hash = get_object_hash (obj);\n        ObjectRenderer renderer = active_renderers.get (hash);\n        log.info (\"removingObject: obj={} or={} layout={} \/\/\/ active_renderers={}\", hash, renderer, layout, active_renderers);\n        \/\/ Only deal with valid renderers\n        if (renderer != null)\n        {\n            \/\/ TODO: VAADIN SESSION HANDLING\n            layout.removeComponent (renderer);\n            log.info (\"<<RENDERER>> removingObject() layout height = {} {}\", layout.getHeight (), layout.getHeightUnits ().toString ());\n        }\n        active_renderers.remove (hash);\n    }","code":"@Override     public void removingObject (Object obj, int index)\n    {\n        String hash = get_object_hash (obj);\n        ObjectRenderer renderer = active_renderers.get (hash);\n        log.info (\"removingObject: obj={} or={} layout={} \/\/\/ active_renderers={}\", hash, renderer, layout, active_renderers);\n       \n        if (renderer != null)\n        {\n           \n            layout.removeComponent (renderer);\n            log.info (\"<<RENDERER>> removingObject() layout height = {} {}\", layout.getHeight (), layout.getHeightUnits ().toString ());\n        }\n        active_renderers.remove (hash);\n    }","cleancode":"@override public void removingobject (object obj, int index) { string hash = get_object_hash (obj); objectrenderer renderer = active_renderers.get (hash); log.info (\"removingobject: obj={} or={} layout={} \/\/\/ active_renderers={}\", hash, renderer, layout, active_renderers); if (renderer != null) { layout.removecomponent (renderer); log.info (\"<<renderer>> removingobject() layout height = {} {}\", layout.getheight (), layout.getheightunits ().tostring ()); } active_renderers.remove (hash); }","comment":"\/\/ objecteventlistener\n\/\/ only deal with valid renderers\n\/\/ todo: vaadin session handling","repo":"neoautus\/lucidj","code_context_2":"@Override \/\/ ObjectEventListener\npublic void removingObject (Object obj, int index)\n{\n\nObjectRenderer renderer = active_renderers.get (hash);\nlog.info (\"removingObject: obj={} or={} layout={} \/\/\/ active_renderers={}\", hash, renderer, layout, active_renderers);\n\/\/ Only deal with valid renderers\nif (renderer != null)\n{\n\nif (renderer != null)\n{\n\/\/ TODO: VAADIN SESSION HANDLING\nlayout.removeComponent (renderer);\nlog.info (\"<<RENDERER>> removingObject() layout height = {} {}\", layout.getHeight (), layout.getHeightUnits ().toString ());","code_context_10":"@Override \/\/ ObjectEventListener\npublic void removingObject (Object obj, int index)\n{\nString hash = get_object_hash (obj);\nObjectRenderer renderer = active_renderers.get (hash);\nlog.info (\"removingObject: obj={} or={} layout={} \/\/\/ active_renderers={}\", hash, renderer, layout, active_renderers);\n\/\/ Only deal with valid renderers\nif (renderer != null)\n{\n\/\/ TODO: VAADIN SESSION HANDLING\nlayout.removeComponent (renderer);\n\n@Override \/\/ ObjectEventListener\npublic void removingObject (Object obj, int index)\n{\nString hash = get_object_hash (obj);\nObjectRenderer renderer = active_renderers.get (hash);\nlog.info (\"removingObject: obj={} or={} layout={} \/\/\/ active_renderers={}\", hash, renderer, layout, active_renderers);\n\/\/ Only deal with valid renderers\nif (renderer != null)\n{\n\/\/ TODO: VAADIN SESSION HANDLING\nlayout.removeComponent (renderer);\nlog.info (\"<<RENDERER>> removingObject() layout height = {} {}\", layout.getHeight (), layout.getHeightUnits ().toString ());\n}\nactive_renderers.remove (hash);\n}\n\n@Override \/\/ ObjectEventListener\npublic void removingObject (Object obj, int index)\n{\nString hash = get_object_hash (obj);\nObjectRenderer renderer = active_renderers.get (hash);\nlog.info (\"removingObject: obj={} or={} layout={} \/\/\/ active_renderers={}\", hash, renderer, layout, active_renderers);\n\/\/ Only deal with valid renderers\nif (renderer != null)\n{\n\/\/ TODO: VAADIN SESSION HANDLING\nlayout.removeComponent (renderer);\nlog.info (\"<<RENDERER>> removingObject() layout height = {} {}\", layout.getHeight (), layout.getHeightUnits ().toString ());\n}\nactive_renderers.remove (hash);\n}","code_context_20":"@Override \/\/ ObjectEventListener\npublic void removingObject (Object obj, int index)\n{\nString hash = get_object_hash (obj);\nObjectRenderer renderer = active_renderers.get (hash);\nlog.info (\"removingObject: obj={} or={} layout={} \/\/\/ active_renderers={}\", hash, renderer, layout, active_renderers);\n\/\/ Only deal with valid renderers\nif (renderer != null)\n{\n\/\/ TODO: VAADIN SESSION HANDLING\nlayout.removeComponent (renderer);\nlog.info (\"<<RENDERER>> removingObject() layout height = {} {}\", layout.getHeight (), layout.getHeightUnits ().toString ());\n}\nactive_renderers.remove (hash);\n}\n\n@Override \/\/ ObjectEventListener\npublic void removingObject (Object obj, int index)\n{\nString hash = get_object_hash (obj);\nObjectRenderer renderer = active_renderers.get (hash);\nlog.info (\"removingObject: obj={} or={} layout={} \/\/\/ active_renderers={}\", hash, renderer, layout, active_renderers);\n\/\/ Only deal with valid renderers\nif (renderer != null)\n{\n\/\/ TODO: VAADIN SESSION HANDLING\nlayout.removeComponent (renderer);\nlog.info (\"<<RENDERER>> removingObject() layout height = {} {}\", layout.getHeight (), layout.getHeightUnits ().toString ());\n}\nactive_renderers.remove (hash);\n}\n\n@Override \/\/ ObjectEventListener\npublic void removingObject (Object obj, int index)\n{\nString hash = get_object_hash (obj);\nObjectRenderer renderer = active_renderers.get (hash);\nlog.info (\"removingObject: obj={} or={} layout={} \/\/\/ active_renderers={}\", hash, renderer, layout, active_renderers);\n\/\/ Only deal with valid renderers\nif (renderer != null)\n{\n\/\/ TODO: VAADIN SESSION HANDLING\nlayout.removeComponent (renderer);\nlog.info (\"<<RENDERER>> removingObject() layout height = {} {}\", layout.getHeight (), layout.getHeightUnits ().toString ());\n}\nactive_renderers.remove (hash);\n}","label":[0,1,0,0]}

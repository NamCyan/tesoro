{"id":24673,"original_code":"private void validateZoneAvailable(String tenantId, String zone) throws IllegalArgumentException {\n    List<ZoneDTO> zones;\n    try {\n      zones = zoneApi.getAvailableZones(tenantId);\n    } catch (ResourceAccessException e) {\n      \/\/ need to do something here to handle things more gracefully.\n      throw new RuntimeException(\"Unable to validate zones.\", e);\n    }\n    boolean found = zones.stream().anyMatch(z -> z.getName().equals(zone));\n    log.debug(\"Found {} zones for tenant\", zoneApi.getAvailableZones(tenantId).size());\n    if (!found) throw new IllegalArgumentException(\"Provided zone does not exist: \" + zone);\n  }","code_wo_comment":"private void validateZoneAvailable(String tenantId, String zone) throws IllegalArgumentException {\n    List<ZoneDTO> zones;\n    try {\n      zones = zoneApi.getAvailableZones(tenantId);\n    } catch (ResourceAccessException e) {\n     \n      throw new RuntimeException(\"Unable to validate zones.\", e);\n    }\n    boolean found = zones.stream().anyMatch(z -> z.getName().equals(zone));\n    log.debug(\"Found {} zones for tenant\", zoneApi.getAvailableZones(tenantId).size());\n    if (!found) throw new IllegalArgumentException(\"Provided zone does not exist: \" + zone);\n  }","cleancode":"private void validatezoneavailable(string tenantid, string zone) throws illegalargumentexception { list<zonedto> zones; try { zones = zoneapi.getavailablezones(tenantid); } catch (resourceaccessexception e) { throw new runtimeexception(\"unable to validate zones.\", e); } boolean found = zones.stream().anymatch(z -> z.getname().equals(zone)); log.debug(\"found {} zones for tenant\", zoneapi.getavailablezones(tenantid).size()); if (!found) throw new illegalargumentexception(\"provided zone does not exist: \" + zone); }","repo":"racker\/salus-telemetry-ambassador","label":[1,0,0,0]}
{"id":16532,"original_code":"public String getBlockId() {\n            final BlockEntity be = serverWorld.getBlockEntity(this.blockPos); \/\/ FIXME do we need to check at y+1?\n            return String.valueOf(Registry.BLOCK_ENTITY_TYPE.getId(be.getType()));\n        }","code_wo_comment":"public String getBlockId() {\n            final BlockEntity be = serverWorld.getBlockEntity(this.blockPos);\n            return String.valueOf(Registry.BLOCK_ENTITY_TYPE.getId(be.getType()));\n        }","cleancode":"public string getblockid() { final blockentity be = serverworld.getblockentity(this.blockpos); return string.valueof(registry.block_entity_type.getid(be.gettype())); }","repo":"pcal43\/mob-filter","label":[0,0,1,0]}
{"id":24727,"original_code":"@Override\n    public List<DeviceStorageRoot> getSecondaryDeviceStorageRoots() {\n        ArrayList<DeviceStorageRoot> secondaryStorageRoot = new ArrayList<>(1);\n        if (secondaryStoragePath != null) {\n            secondaryStorageRoot.add(new DeviceStorageRoot(secondaryStoragePath, secondaryStoragePath, DeviceStorageRoot.Type.SECONDARY));\n        }\n        return secondaryStorageRoot;\n    }","code_wo_comment":"@Override\n    public List<DeviceStorageRoot> getSecondaryDeviceStorageRoots() {\n        ArrayList<DeviceStorageRoot> secondaryStorageRoot = new ArrayList<>(1);\n        if (secondaryStoragePath != null) {\n            secondaryStorageRoot.add(new DeviceStorageRoot(secondaryStoragePath, secondaryStoragePath, DeviceStorageRoot.Type.SECONDARY));\n        }\n        return secondaryStorageRoot;\n    }","cleancode":"@override public list<devicestorageroot> getsecondarydevicestorageroots() { arraylist<devicestorageroot> secondarystorageroot = new arraylist<>(1); if (secondarystoragepath != null) { secondarystorageroot.add(new devicestorageroot(secondarystoragepath, secondarystoragepath, devicestorageroot.type.secondary)); } return secondarystorageroot; }","repo":"novoda\/storage-path-finder","label":[1,0,0,0]}
{"id":8431,"original_code":"@JsonGetter(\"amount\")\n    public int getAmount ( ) { \n        return this.amount;\n    }","code_wo_comment":"@JsonGetter(\"amount\")\n    public int getAmount ( ) { \n        return this.amount;\n    }","cleancode":"@jsongetter(\"amount\") public int getamount ( ) { return this.amount; }","repo":"pagarme\/pagarme-core-api-java","label":[0,0,0,0]}
{"id":8432,"original_code":"@JsonSetter(\"amount\")\n    public void setAmount (int value) { \n        this.amount = value;\n    }","code_wo_comment":"@JsonSetter(\"amount\")\n    public void setAmount (int value) { \n        this.amount = value;\n    }","cleancode":"@jsonsetter(\"amount\") public void setamount (int value) { this.amount = value; }","repo":"pagarme\/pagarme-core-api-java","label":[0,0,0,0]}
{"id":8433,"original_code":"@JsonGetter(\"description\")\n    public String getDescription ( ) { \n        return this.description;\n    }","code_wo_comment":"@JsonGetter(\"description\")\n    public String getDescription ( ) { \n        return this.description;\n    }","cleancode":"@jsongetter(\"description\") public string getdescription ( ) { return this.description; }","repo":"pagarme\/pagarme-core-api-java","label":[0,0,0,0]}
{"id":8434,"original_code":"@JsonSetter(\"description\")\n    public void setDescription (String value) { \n        this.description = value;\n    }","code_wo_comment":"@JsonSetter(\"description\")\n    public void setDescription (String value) { \n        this.description = value;\n    }","cleancode":"@jsonsetter(\"description\") public void setdescription (string value) { this.description = value; }","repo":"pagarme\/pagarme-core-api-java","label":[0,0,0,0]}
{"id":8435,"original_code":"@JsonGetter(\"quantity\")\n    public int getQuantity ( ) { \n        return this.quantity;\n    }","code_wo_comment":"@JsonGetter(\"quantity\")\n    public int getQuantity ( ) { \n        return this.quantity;\n    }","cleancode":"@jsongetter(\"quantity\") public int getquantity ( ) { return this.quantity; }","repo":"pagarme\/pagarme-core-api-java","label":[0,0,0,0]}
{"id":8436,"original_code":"@JsonSetter(\"quantity\")\n    public void setQuantity (int value) { \n        this.quantity = value;\n    }","code_wo_comment":"@JsonSetter(\"quantity\")\n    public void setQuantity (int value) { \n        this.quantity = value;\n    }","cleancode":"@jsonsetter(\"quantity\") public void setquantity (int value) { this.quantity = value; }","repo":"pagarme\/pagarme-core-api-java","label":[0,0,0,0]}
{"id":8437,"original_code":"@JsonGetter(\"category\")\n    public String getCategory ( ) { \n        return this.category;\n    }","code_wo_comment":"@JsonGetter(\"category\")\n    public String getCategory ( ) { \n        return this.category;\n    }","cleancode":"@jsongetter(\"category\") public string getcategory ( ) { return this.category; }","repo":"pagarme\/pagarme-core-api-java","label":[0,0,0,0]}
{"id":8438,"original_code":"@JsonSetter(\"category\")\n    public void setCategory (String value) { \n        this.category = value;\n    }","code_wo_comment":"@JsonSetter(\"category\")\n    public void setCategory (String value) { \n        this.category = value;\n    }","cleancode":"@jsonsetter(\"category\") public void setcategory (string value) { this.category = value; }","repo":"pagarme\/pagarme-core-api-java","label":[0,0,0,0]}
{"id":8485,"original_code":"private void updateCartCount(int count){\n        if (txtItemCount != null) {\n            txtItemCount.setText(String.valueOf(count));\n        }\n    }","code_wo_comment":"private void updateCartCount(int count){\n        if (txtItemCount != null) {\n            txtItemCount.setText(String.valueOf(count));\n        }\n    }","cleancode":"private void updatecartcount(int count){ if (txtitemcount != null) { txtitemcount.settext(string.valueof(count)); } }","repo":"nilesh14\/FMC","label":[1,0,0,0]}
{"id":16767,"original_code":"@Override\n      public Runnable getConsumer(final KafkaSynchronizedConsumerPool pool, final KafkaStream<byte[], byte[]> stream) {\n        return new Runnable() {          \n          @Override\n          public void run() {\n            ConsumerIterator<byte[],byte[]> iter = stream.iterator();\n            byte[] sipHashKey = frontend.keystore.getKey(KeyStore.SIPHASH_KAFKA_PLASMA_FRONTEND_IN);\n            byte[] aesKey = frontend.keystore.getKey(KeyStore.AES_KAFKA_PLASMA_FRONTEND_IN);\n            \/\/ Iterate on the messages\n            TDeserializer deserializer = new TDeserializer(new TCompactProtocol.Factory());\n            KafkaOffsetCounters counters = pool.getCounters();\n            \/\/ TODO(hbs): allow setting of writeBufferSize\n            try {\n            while (iter.hasNext()) {\n              \/\/\n              \/\/ Since the cal to 'next' may block, we need to first\n              \/\/ check that there is a message available\n              \/\/\n              boolean nonEmpty = iter.nonEmpty();\n              if (nonEmpty) {\n                MessageAndMetadata<byte[], byte[]> msg = iter.next();\n                counters.count(msg.partition(), msg.offset());\n                byte[] data = msg.message();\n                Sensision.update(SensisionConstants.SENSISION_CLASS_PLASMA_FRONTEND_KAFKA_MESSAGES, Sensision.EMPTY_LABELS, 1);\n                Sensision.update(SensisionConstants.SENSISION_CLASS_PLASMA_FRONTEND_KAFKA_BYTES, Sensision.EMPTY_LABELS, data.length);\n                if (null != sipHashKey) {\n                  data = CryptoUtils.removeMAC(sipHashKey, data);\n                }\n                \/\/ Skip data whose MAC was not verified successfully\n                if (null == data) {\n                  Sensision.update(SensisionConstants.SENSISION_CLASS_PLASMA_FRONTEND_KAFKA_INVALIDMACS, Sensision.EMPTY_LABELS, 1);\n                  continue;\n                }\n                \/\/ Unwrap data if need be\n                if (null != aesKey) {\n                  data = CryptoUtils.unwrap(aesKey, data);\n                }\n                \/\/ Skip data that was not unwrapped successfuly\n                if (null == data) {\n                  Sensision.update(SensisionConstants.SENSISION_CLASS_PLASMA_FRONTEND_KAFKA_INVALIDCIPHERS, Sensision.EMPTY_LABELS, 1);\n                  continue;\n                }\n                \/\/\n                \/\/ Extract KafkaDataMessage\n                \/\/\n                KafkaDataMessage tmsg = new KafkaDataMessage();\n                deserializer.deserialize(tmsg, data);\n                switch(tmsg.getType()) {\n                  case STORE:\n                    GTSEncoder encoder = new GTSEncoder(0L, null, tmsg.getData());\n                    encoder.setClassId(tmsg.getClassId());\n                    encoder.setLabelsId(tmsg.getLabelsId());\n                    frontend.dispatch(encoder);\n                    break;\n                  case DELETE:\n                  case ARCHIVE:\n                    break;\n                  default:\n                    throw new RuntimeException(\"Invalid message type.\");\n                }            \n              } else {\n                \/\/ Sleep a tiny while\n                try {\n                  Thread.sleep(1L);\n                } catch (InterruptedException ie) {             \n                }\n              }          \n            }        \n          } catch (Throwable t) {\n            t.printStackTrace(System.err);\n          } finally {\n            \/\/ Set abort to true in case we exit the 'run' method\n            pool.getAbort().set(true);\n          }\n          }\n        };\n      }","code_wo_comment":"@Override\n      public Runnable getConsumer(final KafkaSynchronizedConsumerPool pool, final KafkaStream<byte[], byte[]> stream) {\n        return new Runnable() {          \n          @Override\n          public void run() {\n            ConsumerIterator<byte[],byte[]> iter = stream.iterator();\n            byte[] sipHashKey = frontend.keystore.getKey(KeyStore.SIPHASH_KAFKA_PLASMA_FRONTEND_IN);\n            byte[] aesKey = frontend.keystore.getKey(KeyStore.AES_KAFKA_PLASMA_FRONTEND_IN);\n           \n            TDeserializer deserializer = new TDeserializer(new TCompactProtocol.Factory());\n            KafkaOffsetCounters counters = pool.getCounters();\n           \n            try {\n            while (iter.hasNext()) {\n             \n             \n             \n             \n              boolean nonEmpty = iter.nonEmpty();\n              if (nonEmpty) {\n                MessageAndMetadata<byte[], byte[]> msg = iter.next();\n                counters.count(msg.partition(), msg.offset());\n                byte[] data = msg.message();\n                Sensision.update(SensisionConstants.SENSISION_CLASS_PLASMA_FRONTEND_KAFKA_MESSAGES, Sensision.EMPTY_LABELS, 1);\n                Sensision.update(SensisionConstants.SENSISION_CLASS_PLASMA_FRONTEND_KAFKA_BYTES, Sensision.EMPTY_LABELS, data.length);\n                if (null != sipHashKey) {\n                  data = CryptoUtils.removeMAC(sipHashKey, data);\n                }\n               \n                if (null == data) {\n                  Sensision.update(SensisionConstants.SENSISION_CLASS_PLASMA_FRONTEND_KAFKA_INVALIDMACS, Sensision.EMPTY_LABELS, 1);\n                  continue;\n                }\n               \n                if (null != aesKey) {\n                  data = CryptoUtils.unwrap(aesKey, data);\n                }\n               \n                if (null == data) {\n                  Sensision.update(SensisionConstants.SENSISION_CLASS_PLASMA_FRONTEND_KAFKA_INVALIDCIPHERS, Sensision.EMPTY_LABELS, 1);\n                  continue;\n                }\n               \n               \n               \n                KafkaDataMessage tmsg = new KafkaDataMessage();\n                deserializer.deserialize(tmsg, data);\n                switch(tmsg.getType()) {\n                  case STORE:\n                    GTSEncoder encoder = new GTSEncoder(0L, null, tmsg.getData());\n                    encoder.setClassId(tmsg.getClassId());\n                    encoder.setLabelsId(tmsg.getLabelsId());\n                    frontend.dispatch(encoder);\n                    break;\n                  case DELETE:\n                  case ARCHIVE:\n                    break;\n                  default:\n                    throw new RuntimeException(\"Invalid message type.\");\n                }            \n              } else {\n               \n                try {\n                  Thread.sleep(1L);\n                } catch (InterruptedException ie) {             \n                }\n              }          \n            }        \n          } catch (Throwable t) {\n            t.printStackTrace(System.err);\n          } finally {\n           \n            pool.getAbort().set(true);\n          }\n          }\n        };\n      }","cleancode":"@override public runnable getconsumer(final kafkasynchronizedconsumerpool pool, final kafkastream<byte[], byte[]> stream) { return new runnable() { @override public void run() { consumeriterator<byte[],byte[]> iter = stream.iterator(); byte[] siphashkey = frontend.keystore.getkey(keystore.siphash_kafka_plasma_frontend_in); byte[] aeskey = frontend.keystore.getkey(keystore.aes_kafka_plasma_frontend_in); tdeserializer deserializer = new tdeserializer(new tcompactprotocol.factory()); kafkaoffsetcounters counters = pool.getcounters(); try { while (iter.hasnext()) { boolean nonempty = iter.nonempty(); if (nonempty) { messageandmetadata<byte[], byte[]> msg = iter.next(); counters.count(msg.partition(), msg.offset()); byte[] data = msg.message(); sensision.update(sensisionconstants.sensision_class_plasma_frontend_kafka_messages, sensision.empty_labels, 1); sensision.update(sensisionconstants.sensision_class_plasma_frontend_kafka_bytes, sensision.empty_labels, data.length); if (null != siphashkey) { data = cryptoutils.removemac(siphashkey, data); } if (null == data) { sensision.update(sensisionconstants.sensision_class_plasma_frontend_kafka_invalidmacs, sensision.empty_labels, 1); continue; } if (null != aeskey) { data = cryptoutils.unwrap(aeskey, data); } if (null == data) { sensision.update(sensisionconstants.sensision_class_plasma_frontend_kafka_invalidciphers, sensision.empty_labels, 1); continue; } kafkadatamessage tmsg = new kafkadatamessage(); deserializer.deserialize(tmsg, data); switch(tmsg.gettype()) { case store: gtsencoder encoder = new gtsencoder(0l, null, tmsg.getdata()); encoder.setclassid(tmsg.getclassid()); encoder.setlabelsid(tmsg.getlabelsid()); frontend.dispatch(encoder); break; case delete: case archive: break; default: throw new runtimeexception(\"invalid message type.\"); } } else { try { thread.sleep(1l); } catch (interruptedexception ie) { } } } } catch (throwable t) { t.printstacktrace(system.err); } finally { pool.getabort().set(true); } } }; }","repo":"randomboolean\/warp10-platform","label":[0,1,0,0]}
{"id":432,"original_code":"protected void addSubtable(GlyphSubtable subtable) {\n        if (subtable instanceof GlyphClassSubtable) {\n            this.gct = (GlyphClassSubtable) subtable;\n        } else if (subtable instanceof AttachmentPointSubtable) {\n            \/\/ TODO - not yet used\n            \/\/ this.apt = (AttachmentPointSubtable) subtable;\n        } else if (subtable instanceof LigatureCaretSubtable) {\n            \/\/ TODO - not yet used\n            \/\/ this.lct = (LigatureCaretSubtable) subtable;\n        } else if (subtable instanceof MarkAttachmentSubtable) {\n            this.mat = (MarkAttachmentSubtable) subtable;\n        } else {\n            throw new UnsupportedOperationException(\"unsupported glyph definition subtable type: \" + subtable);\n        }\n    }","code_wo_comment":"protected void addSubtable(GlyphSubtable subtable) {\n        if (subtable instanceof GlyphClassSubtable) {\n            this.gct = (GlyphClassSubtable) subtable;\n        } else if (subtable instanceof AttachmentPointSubtable) {\n           \n           \n        } else if (subtable instanceof LigatureCaretSubtable) {\n           \n           \n        } else if (subtable instanceof MarkAttachmentSubtable) {\n            this.mat = (MarkAttachmentSubtable) subtable;\n        } else {\n            throw new UnsupportedOperationException(\"unsupported glyph definition subtable type: \" + subtable);\n        }\n    }","cleancode":"protected void addsubtable(glyphsubtable subtable) { if (subtable instanceof glyphclasssubtable) { this.gct = (glyphclasssubtable) subtable; } else if (subtable instanceof attachmentpointsubtable) { } else if (subtable instanceof ligaturecaretsubtable) { } else if (subtable instanceof markattachmentsubtable) { this.mat = (markattachmentsubtable) subtable; } else { throw new unsupportedoperationexception(\"unsupported glyph definition subtable type: \" + subtable); } }","repo":"not2sirius\/fop","label":[1,0,0,0]}
{"id":8645,"original_code":"@Override\n    public void exitOperator_expr(OperonModuleParser.Operator_exprContext ctx) {\n        \/\/:OFF:log.debug(\"EXIT Operator_expr :: Stack size :: \" + this.stack.size());\n        List<ParseTree> subNodes = getContextChildNodes(ctx);\n        int subNodesSize = subNodes.size();\n        \/\/ Get the FunctionRef\n        FunctionRef funcRef = (FunctionRef) this.stack.pop();\n        boolean isCascade = false;\n        if (subNodes.get(subNodes.size() - 2) instanceof TerminalNode && \n            subNodes.get(subNodes.size() - 2).getText().toLowerCase().equals(\"cascade\")) {\n            \/\/:OFF:log.debug(\"  >> Operator :: set cascade true :: \" + subNodes.get(subNodes.size() - 2).getText());\n            isCascade = true;\n        }\n        \/\/ Get the overloaded operator:\n        for (int i = 0; i < subNodesSize; i ++) {\n            \/\/:OFF:log.debug(subNodes.get(i).getClass().getName());\n            if (subNodes.get(i) instanceof TerminalNode) {\n                \/\/:OFF:log.debug(\"  >> Operator :: terminal-node found.\");\n            }\n        }\n        String operator = subNodes.get(2).getText();\n        \/\/:OFF:log.debug(\" >> OPERATOR :: \" + operator);\n        Operator op = new Operator(this.currentStatement); \/\/ TODO: might not to inherit Node, therefore giving statement not required.\n        op.setOperator(operator);\n        op.setFunctionRef(funcRef);\n        op.setCascade(isCascade);\n        this.stack.push(op);\n    }","code_wo_comment":"@Override\n    public void exitOperator_expr(OperonModuleParser.Operator_exprContext ctx) {\n       \n        List<ParseTree> subNodes = getContextChildNodes(ctx);\n        int subNodesSize = subNodes.size();\n       \n        FunctionRef funcRef = (FunctionRef) this.stack.pop();\n        boolean isCascade = false;\n        if (subNodes.get(subNodes.size() - 2) instanceof TerminalNode && \n            subNodes.get(subNodes.size() - 2).getText().toLowerCase().equals(\"cascade\")) {\n           \n            isCascade = true;\n        }\n       \n        for (int i = 0; i < subNodesSize; i ++) {\n           \n            if (subNodes.get(i) instanceof TerminalNode) {\n               \n            }\n        }\n        String operator = subNodes.get(2).getText();\n       \n        Operator op = new Operator(this.currentStatement);\n        op.setOperator(operator);\n        op.setFunctionRef(funcRef);\n        op.setCascade(isCascade);\n        this.stack.push(op);\n    }","cleancode":"@override public void exitoperator_expr(operonmoduleparser.operator_exprcontext ctx) { list<parsetree> subnodes = getcontextchildnodes(ctx); int subnodessize = subnodes.size(); functionref funcref = (functionref) this.stack.pop(); boolean iscascade = false; if (subnodes.get(subnodes.size() - 2) instanceof terminalnode && subnodes.get(subnodes.size() - 2).gettext().tolowercase().equals(\"cascade\")) { iscascade = true; } for (int i = 0; i < subnodessize; i ++) { if (subnodes.get(i) instanceof terminalnode) { } } string operator = subnodes.get(2).gettext(); operator op = new operator(this.currentstatement); op.setoperator(operator); op.setfunctionref(funcref); op.setcascade(iscascade); this.stack.push(op); }","repo":"operon-io\/operon-lang","label":[1,0,0,0]}
{"id":33243,"original_code":"private void testClassify(String testID, String testExpectedID) {\n        log.info(\"Testing the CLASSIFY task\");\n        OWLOntologyManager manager = TestData.manager;\n        \/\/ We prepare the input ontology\n        try {\n            OWLOntology testOntology = manager.createOntology();\n            OWLOntologyID testOntologyID = testOntology.getOntologyID();\n            log.debug(\"Created test ontology with ID: {}\", testOntologyID);\n            manager.applyChange(new AddImport(testOntology, TestData.factory.getOWLImportsDeclaration(IRI\n                    .create(testID))));\n            \/\/ Maybe we want to see what is in before\n            if (log.isDebugEnabled()) TestUtils.debug(manager.getOntology(testOntologyID), log);\n            \/\/ Now we test the method\n            log.debug(\"Running HermiT\");\n            Set<OWLAxiom> inferred = this.theinstance.runTask(ReasoningService.Tasks.CLASSIFY,\n                manager.getOntology(testOntologyID));\n            \/\/ Maybe we want to see the inferred axiom list\n            if (log.isDebugEnabled()) {\n                TestUtils.debug(inferred, log);\n            }\n            Set<OWLLogicalAxiom> expectedAxioms = manager.getOntology(IRI.create(testExpectedID))\n                    .getLogicalAxioms();\n            Set<OWLAxiom> missing = new HashSet<OWLAxiom>();\n            for (OWLAxiom expected : expectedAxioms) {\n                if (!inferred.contains(expected)) {\n                    log.error(\"missing expected axiom: {}\", expected);\n                    missing.add(expected);\n                }\n            }\n            assertTrue(missing.isEmpty());\n            \/\/ We want only Class related axioms in the result set\n            for (OWLAxiom a : inferred) {\n                assertTrue(a instanceof OWLClassAssertionAxiom || a instanceof OWLSubClassOfAxiom\n                           || a instanceof OWLEquivalentClassesAxiom || a instanceof OWLDisjointClassesAxiom);\n            }\n            \/\/ We want to remove the ontology from the manager\n            manager.removeOntology(testOntology);\n        } catch (OWLOntologyCreationException e) {\n            log.error(\"An {} have been thrown while creating the input ontology for test\", e.getClass());\n            assertTrue(false);\n        } catch (ReasoningServiceException e) {\n            log.error(\"An {} have been thrown while executing the reasoning\", e.getClass());\n            assertTrue(false);\n        } catch (InconsistentInputException e) {\n            log.error(\"An {} have been thrown while executing the reasoning\", e.getClass());\n            assertTrue(false);\n        } catch (UnsupportedTaskException e) {\n            log.error(\"An {} have been thrown while executing the reasoning\", e.getClass());\n            assertTrue(false);\n        }\n    }","code_wo_comment":"private void testClassify(String testID, String testExpectedID) {\n        log.info(\"Testing the CLASSIFY task\");\n        OWLOntologyManager manager = TestData.manager;\n       \n        try {\n            OWLOntology testOntology = manager.createOntology();\n            OWLOntologyID testOntologyID = testOntology.getOntologyID();\n            log.debug(\"Created test ontology with ID: {}\", testOntologyID);\n            manager.applyChange(new AddImport(testOntology, TestData.factory.getOWLImportsDeclaration(IRI\n                    .create(testID))));\n           \n            if (log.isDebugEnabled()) TestUtils.debug(manager.getOntology(testOntologyID), log);\n           \n            log.debug(\"Running HermiT\");\n            Set<OWLAxiom> inferred = this.theinstance.runTask(ReasoningService.Tasks.CLASSIFY,\n                manager.getOntology(testOntologyID));\n           \n            if (log.isDebugEnabled()) {\n                TestUtils.debug(inferred, log);\n            }\n            Set<OWLLogicalAxiom> expectedAxioms = manager.getOntology(IRI.create(testExpectedID))\n                    .getLogicalAxioms();\n            Set<OWLAxiom> missing = new HashSet<OWLAxiom>();\n            for (OWLAxiom expected : expectedAxioms) {\n                if (!inferred.contains(expected)) {\n                    log.error(\"missing expected axiom: {}\", expected);\n                    missing.add(expected);\n                }\n            }\n            assertTrue(missing.isEmpty());\n           \n            for (OWLAxiom a : inferred) {\n                assertTrue(a instanceof OWLClassAssertionAxiom || a instanceof OWLSubClassOfAxiom\n                           || a instanceof OWLEquivalentClassesAxiom || a instanceof OWLDisjointClassesAxiom);\n            }\n           \n            manager.removeOntology(testOntology);\n        } catch (OWLOntologyCreationException e) {\n            log.error(\"An {} have been thrown while creating the input ontology for test\", e.getClass());\n            assertTrue(false);\n        } catch (ReasoningServiceException e) {\n            log.error(\"An {} have been thrown while executing the reasoning\", e.getClass());\n            assertTrue(false);\n        } catch (InconsistentInputException e) {\n            log.error(\"An {} have been thrown while executing the reasoning\", e.getClass());\n            assertTrue(false);\n        } catch (UnsupportedTaskException e) {\n            log.error(\"An {} have been thrown while executing the reasoning\", e.getClass());\n            assertTrue(false);\n        }\n    }","cleancode":"private void testclassify(string testid, string testexpectedid) { log.info(\"testing the classify task\"); owlontologymanager manager = testdata.manager; try { owlontology testontology = manager.createontology(); owlontologyid testontologyid = testontology.getontologyid(); log.debug(\"created test ontology with id: {}\", testontologyid); manager.applychange(new addimport(testontology, testdata.factory.getowlimportsdeclaration(iri .create(testid)))); if (log.isdebugenabled()) testutils.debug(manager.getontology(testontologyid), log); log.debug(\"running hermit\"); set<owlaxiom> inferred = this.theinstance.runtask(reasoningservice.tasks.classify, manager.getontology(testontologyid)); if (log.isdebugenabled()) { testutils.debug(inferred, log); } set<owllogicalaxiom> expectedaxioms = manager.getontology(iri.create(testexpectedid)) .getlogicalaxioms(); set<owlaxiom> missing = new hashset<owlaxiom>(); for (owlaxiom expected : expectedaxioms) { if (!inferred.contains(expected)) { log.error(\"missing expected axiom: {}\", expected); missing.add(expected); } } asserttrue(missing.isempty()); for (owlaxiom a : inferred) { asserttrue(a instanceof owlclassassertionaxiom || a instanceof owlsubclassofaxiom || a instanceof owlequivalentclassesaxiom || a instanceof owldisjointclassesaxiom); } manager.removeontology(testontology); } catch (owlontologycreationexception e) { log.error(\"an {} have been thrown while creating the input ontology for test\", e.getclass()); asserttrue(false); } catch (reasoningserviceexception e) { log.error(\"an {} have been thrown while executing the reasoning\", e.getclass()); asserttrue(false); } catch (inconsistentinputexception e) { log.error(\"an {} have been thrown while executing the reasoning\", e.getclass()); asserttrue(false); } catch (unsupportedtaskexception e) { log.error(\"an {} have been thrown while executing the reasoning\", e.getclass()); asserttrue(false); } }","repo":"nikosnikolaidis\/stanbol","label":[0,0,0,1]}
{"id":8668,"original_code":"@Test\n  public void testAclExtraction() {\n    CiscoXrConfiguration c = parseVendorConfig(\"acl\");\n    assertThat(c.getIpv4Acls(), hasKeys(\"acl\"));\n    Ipv4AccessList acl = c.getIpv4Acls().get(\"acl\");\n    \/\/ TODO: get the remark line in there too.\n    assertThat(acl.getLines(), hasSize(7));\n    assertThat(c.getIpv6Acls(), hasKeys(\"aclv6\"));\n    Ipv6AccessList aclv6 = c.getIpv6Acls().get(\"aclv6\");\n    \/\/ TODO: get the remark line in there too.\n    assertThat(aclv6.getLines(), hasSize(4));\n  }","code_wo_comment":"@Test\n  public void testAclExtraction() {\n    CiscoXrConfiguration c = parseVendorConfig(\"acl\");\n    assertThat(c.getIpv4Acls(), hasKeys(\"acl\"));\n    Ipv4AccessList acl = c.getIpv4Acls().get(\"acl\");\n   \n    assertThat(acl.getLines(), hasSize(7));\n    assertThat(c.getIpv6Acls(), hasKeys(\"aclv6\"));\n    Ipv6AccessList aclv6 = c.getIpv6Acls().get(\"aclv6\");\n   \n    assertThat(aclv6.getLines(), hasSize(4));\n  }","cleancode":"@test public void testaclextraction() { ciscoxrconfiguration c = parsevendorconfig(\"acl\"); assertthat(c.getipv4acls(), haskeys(\"acl\")); ipv4accesslist acl = c.getipv4acls().get(\"acl\"); assertthat(acl.getlines(), hassize(7)); assertthat(c.getipv6acls(), haskeys(\"aclv6\")); ipv6accesslist aclv6 = c.getipv6acls().get(\"aclv6\"); assertthat(aclv6.getlines(), hassize(4)); }","repo":"pranavbj-amzn\/batfish","label":[1,0,0,0]}
{"id":8669,"original_code":"@Test\n  public void testAclConversion() {\n    Configuration c = parseConfig(\"acl\");\n    assertThat(c.getIpAccessLists(), hasKeys(\"acl\"));\n    IpAccessList acl = c.getIpAccessLists().get(\"acl\");\n    \/\/ TODO: get the remark line in there too.\n    assertThat(acl.getLines(), hasSize(7));\n    assertThat(c.getIp6AccessLists(), hasKeys(\"aclv6\"));\n    Ip6AccessList aclv6 = c.getIp6AccessLists().get(\"aclv6\");\n    \/\/ TODO: get the remark line in there too.\n    assertThat(aclv6.getLines(), hasSize(4));\n  }","code_wo_comment":"@Test\n  public void testAclConversion() {\n    Configuration c = parseConfig(\"acl\");\n    assertThat(c.getIpAccessLists(), hasKeys(\"acl\"));\n    IpAccessList acl = c.getIpAccessLists().get(\"acl\");\n   \n    assertThat(acl.getLines(), hasSize(7));\n    assertThat(c.getIp6AccessLists(), hasKeys(\"aclv6\"));\n    Ip6AccessList aclv6 = c.getIp6AccessLists().get(\"aclv6\");\n   \n    assertThat(aclv6.getLines(), hasSize(4));\n  }","cleancode":"@test public void testaclconversion() { configuration c = parseconfig(\"acl\"); assertthat(c.getipaccesslists(), haskeys(\"acl\")); ipaccesslist acl = c.getipaccesslists().get(\"acl\"); assertthat(acl.getlines(), hassize(7)); assertthat(c.getip6accesslists(), haskeys(\"aclv6\")); ip6accesslist aclv6 = c.getip6accesslists().get(\"aclv6\"); assertthat(aclv6.getlines(), hassize(4)); }","repo":"pranavbj-amzn\/batfish","label":[1,0,0,0]}
{"id":33288,"original_code":"@Override\n\t\tpublic boolean onTouch(View v, MotionEvent event) {\n\t\t\tswitch(event.getAction()){\n\t\t\t\tcase MotionEvent.ACTION_CANCEL:\n\t\t\t\t\t_downTime.set(0);\n\t\t\t\t\tbreak;\n\t\t\t\tcase MotionEvent.ACTION_DOWN:\n\t\t\t\t\t_downTime.set(System.currentTimeMillis());\n\t\t\t\t\t_downX = event.getX();\n\t\t\t\t\t_downY = event.getY();\n\t\t\t\t\tif(_longClickTimer == null){\t\/\/ if there is no pre-existing task, create a new one\n\t\t\t\t\t\t_longClickTimer = new AsyncTask<Void, Void, Boolean>(){\n\t\t\t\t\t\t\t@Override\n\t\t\t\t\t\t\tprotected Boolean doInBackground(Void... params) {\n\t\t\t\t\t\t\t\ttry{\n\t\t\t\t\t\t\t\t\tfor(long i=0;i<Definitions.THRESHOLD_LONG_CLICK_MAX_DURATION;i+=INTERVAL_LONG_CLICK_CHECK){\n\t\t\t\t\t\t\t\t\t\tThread.sleep(INTERVAL_LONG_CLICK_CHECK);\n\t\t\t\t\t\t\t\t\t\tlong downTime = _downTime.get();\n\t\t\t\t\t\t\t\t\t\tif(downTime > 0 && System.currentTimeMillis()-downTime > Definitions.THRESHOLD_LONG_CLICK_MIN_DURATION){\n\t\t\t\t\t\t\t\t\t\t\treturn true;\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}catch(InterruptedException ex){\n\t\t\t\t\t\t\t\t\tLogUtils.warn(CLASS_NAME, \"doInBackground\", ex.toString());\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\treturn false;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t@Override\n\t\t\t\t\t\t\tprotected void onPostExecute(Boolean result) {\n\t\t\t\t\t\t\t\tif(result){\n\t\t\t\t\t\t\t\t\tcenterChart();\n\t\t\t\t\t\t\t\t\t_downTime.set(0);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t_longClickTimer = null;\n\t\t\t\t\t\t\t}\t\t\t\t\t\n\t\t\t\t\t\t};\t\/\/ new asyncTask\n\t\t\t\t\t\t_longClickTimer.execute();\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\tcase MotionEvent.ACTION_MOVE:\n\t\t\t\t\tcheckForMovement(event);\n\t\t\t\t\tbreak;\n\t\t\t\tcase MotionEvent.ACTION_UP:\n\t\t\t\t\tlong downTime = _downTime.getAndSet(0);\n\t\t\t\t\tif(downTime != 0 && (System.currentTimeMillis()-downTime) < Definitions.THRESHOLD_CLICK_MAX_DURATION && !checkForMovement(event)){\n\t\t\t\t\t\tSeriesSelection selection = _viewChart.getCurrentSeriesAndPoint();\n\t\t\t\t\t\tif(selection == null || selection.getSeriesIndex() != 0){\t\/\/ if there was no selection or this is not the first series (point values)\n\t\t\t\t\t\t\tLogUtils.debug(CLASS_NAME, \"onTouch\", \"No usable selection.\");\n\t\t\t\t\t\t}else{\n\t\t\t\t\t\t\tList<GaugeValue> values = _currentGauge.getValues();\n\t\t\t\t\t\t\tint valueCount = values.size();\n\t\t\t\t\t\t\tint index = 0;\n\t\t\t\t\t\t\t\/\/TODO: this will break if the chart shows something else than the last getMaxGraphPoints() of values\n\t\t\t\t\t\t\tif(valueCount - _settings.getMaxGraphPoints() > 0){\n\t\t\t\t\t\t\t\tindex = valueCount - _settings.getMaxGraphPoints() + selection.getPointIndex();\n\t\t\t\t\t\t\t}else{\n\t\t\t\t\t\t\t\tindex = selection.getPointIndex();\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t_currentValue = _currentGauge.getValues().get(index);\n\t\t\t\t\t\t\t(new GaugeValueDialog()).show(GraphActivity.this.getSupportFragmentManager(), GaugeValueDialog.TAG);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t\t\tbreak;\t\/\/ ignore everything else\n\t\t\t}\n\t\t\treturn false;\t\/\/ always return false so that we do not interfere with the graph pan\/zoom controls\n\t\t}","code_wo_comment":"@Override\n\t\tpublic boolean onTouch(View v, MotionEvent event) {\n\t\t\tswitch(event.getAction()){\n\t\t\t\tcase MotionEvent.ACTION_CANCEL:\n\t\t\t\t\t_downTime.set(0);\n\t\t\t\t\tbreak;\n\t\t\t\tcase MotionEvent.ACTION_DOWN:\n\t\t\t\t\t_downTime.set(System.currentTimeMillis());\n\t\t\t\t\t_downX = event.getX();\n\t\t\t\t\t_downY = event.getY();\n\t\t\t\t\tif(_longClickTimer == null){\n\t\t\t\t\t\t_longClickTimer = new AsyncTask<Void, Void, Boolean>(){\n\t\t\t\t\t\t\t@Override\n\t\t\t\t\t\t\tprotected Boolean doInBackground(Void... params) {\n\t\t\t\t\t\t\t\ttry{\n\t\t\t\t\t\t\t\t\tfor(long i=0;i<Definitions.THRESHOLD_LONG_CLICK_MAX_DURATION;i+=INTERVAL_LONG_CLICK_CHECK){\n\t\t\t\t\t\t\t\t\t\tThread.sleep(INTERVAL_LONG_CLICK_CHECK);\n\t\t\t\t\t\t\t\t\t\tlong downTime = _downTime.get();\n\t\t\t\t\t\t\t\t\t\tif(downTime > 0 && System.currentTimeMillis()-downTime > Definitions.THRESHOLD_LONG_CLICK_MIN_DURATION){\n\t\t\t\t\t\t\t\t\t\t\treturn true;\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}catch(InterruptedException ex){\n\t\t\t\t\t\t\t\t\tLogUtils.warn(CLASS_NAME, \"doInBackground\", ex.toString());\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\treturn false;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t@Override\n\t\t\t\t\t\t\tprotected void onPostExecute(Boolean result) {\n\t\t\t\t\t\t\t\tif(result){\n\t\t\t\t\t\t\t\t\tcenterChart();\n\t\t\t\t\t\t\t\t\t_downTime.set(0);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t_longClickTimer = null;\n\t\t\t\t\t\t\t}\t\t\t\t\t\n\t\t\t\t\t\t};\n\t\t\t\t\t\t_longClickTimer.execute();\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\tcase MotionEvent.ACTION_MOVE:\n\t\t\t\t\tcheckForMovement(event);\n\t\t\t\t\tbreak;\n\t\t\t\tcase MotionEvent.ACTION_UP:\n\t\t\t\t\tlong downTime = _downTime.getAndSet(0);\n\t\t\t\t\tif(downTime != 0 && (System.currentTimeMillis()-downTime) < Definitions.THRESHOLD_CLICK_MAX_DURATION && !checkForMovement(event)){\n\t\t\t\t\t\tSeriesSelection selection = _viewChart.getCurrentSeriesAndPoint();\n\t\t\t\t\t\tif(selection == null || selection.getSeriesIndex() != 0){\n\t\t\t\t\t\t\tLogUtils.debug(CLASS_NAME, \"onTouch\", \"No usable selection.\");\n\t\t\t\t\t\t}else{\n\t\t\t\t\t\t\tList<GaugeValue> values = _currentGauge.getValues();\n\t\t\t\t\t\t\tint valueCount = values.size();\n\t\t\t\t\t\t\tint index = 0;\n\t\t\t\t\t\t\n\t\t\t\t\t\t\tif(valueCount - _settings.getMaxGraphPoints() > 0){\n\t\t\t\t\t\t\t\tindex = valueCount - _settings.getMaxGraphPoints() + selection.getPointIndex();\n\t\t\t\t\t\t\t}else{\n\t\t\t\t\t\t\t\tindex = selection.getPointIndex();\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t_currentValue = _currentGauge.getValues().get(index);\n\t\t\t\t\t\t\t(new GaugeValueDialog()).show(GraphActivity.this.getSupportFragmentManager(), GaugeValueDialog.TAG);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t\treturn false;\n\t\t}","cleancode":"@override public boolean ontouch(view v, motionevent event) { switch(event.getaction()){ case motionevent.action_cancel: _downtime.set(0); break; case motionevent.action_down: _downtime.set(system.currenttimemillis()); _downx = event.getx(); _downy = event.gety(); if(_longclicktimer == null){ _longclicktimer = new asynctask<void, void, boolean>(){ @override protected boolean doinbackground(void... params) { try{ for(long i=0;i<definitions.threshold_long_click_max_duration;i+=interval_long_click_check){ thread.sleep(interval_long_click_check); long downtime = _downtime.get(); if(downtime > 0 && system.currenttimemillis()-downtime > definitions.threshold_long_click_min_duration){ return true; } } }catch(interruptedexception ex){ logutils.warn(class_name, \"doinbackground\", ex.tostring()); } return false; } @override protected void onpostexecute(boolean result) { if(result){ centerchart(); _downtime.set(0); } _longclicktimer = null; } }; _longclicktimer.execute(); } break; case motionevent.action_move: checkformovement(event); break; case motionevent.action_up: long downtime = _downtime.getandset(0); if(downtime != 0 && (system.currenttimemillis()-downtime) < definitions.threshold_click_max_duration && !checkformovement(event)){ seriesselection selection = _viewchart.getcurrentseriesandpoint(); if(selection == null || selection.getseriesindex() != 0){ logutils.debug(class_name, \"ontouch\", \"no usable selection.\"); }else{ list<gaugevalue> values = _currentgauge.getvalues(); int valuecount = values.size(); int index = 0; if(valuecount - _settings.getmaxgraphpoints() > 0){ index = valuecount - _settings.getmaxgraphpoints() + selection.getpointindex(); }else{ index = selection.getpointindex(); } _currentvalue = _currentgauge.getvalues().get(index); (new gaugevaluedialog()).show(graphactivity.this.getsupportfragmentmanager(), gaugevaluedialog.tag); } } break; default: break; } return false; }","repo":"otula\/kiiaudata","label":[0,0,1,0]}
{"id":675,"original_code":"@Override\n    public int describeContents() {\n        return 0;\/\/TODO figure out how to act with this stuff\n    }","code_wo_comment":"@Override\n    public int describeContents() {\n        return 0\n    }","cleancode":"@override public int describecontents() { return 0 }","repo":"programmerr47\/breverkruntkin-test-task","label":[1,0,0,0]}
{"id":8907,"original_code":"public void setWs(boolean b) {\n    \/\/ TODO: document me\n    this.tr.setSkipws(b);\n  }","code_wo_comment":"public void setWs(boolean b) {\n   \n    this.tr.setSkipws(b);\n  }","cleancode":"public void setws(boolean b) { this.tr.setskipws(b); }","repo":"rebse\/flaka","label":[0,0,0,0]}
{"id":8908,"original_code":"public void setCl(boolean b) {\n    \/\/ TODO: document me\n    this.tr.setResolveContLines(b);\n  }","code_wo_comment":"public void setCl(boolean b) {\n   \n    this.tr.setResolveContLines(b);\n  }","cleancode":"public void setcl(boolean b) { this.tr.setresolvecontlines(b); }","repo":"rebse\/flaka","label":[0,0,0,0]}
{"id":781,"original_code":"private Map<String, T> getChoiceMap() {\n        if (choiceMap == null || alwaysReload()) {\n            Collection<T> choices = loadChoices();\n            choiceMap = new HashMap<>();\n            for (T choice: choices) {\n                \/\/ TODO: smarter initialization of the map\n                choiceMap.put(choice.getLocalPart(), choice);\n            }\n        }\n        return choiceMap;\n    }","code_wo_comment":"private Map<String, T> getChoiceMap() {\n        if (choiceMap == null || alwaysReload()) {\n            Collection<T> choices = loadChoices();\n            choiceMap = new HashMap<>();\n            for (T choice: choices) {\n               \n                choiceMap.put(choice.getLocalPart(), choice);\n            }\n        }\n        return choiceMap;\n    }","cleancode":"private map<string, t> getchoicemap() { if (choicemap == null || alwaysreload()) { collection<t> choices = loadchoices(); choicemap = new hashmap<>(); for (t choice: choices) { choicemap.put(choice.getlocalpart(), choice); } } return choicemap; }","repo":"mythoss\/midpoint","label":[1,0,0,0]}
{"id":9010,"original_code":"public static void main(String[] args) {\n        \/\/ The connection string value can be obtained by:\n        \/\/ 1. Going to your Event Hubs namespace in Azure Portal.\n        \/\/ 2. Creating an Event Hub instance.\n        \/\/ 3. Creating a \"Shared access policy\" for your Event Hub instance.\n        \/\/ 4. Copying the connection string from the policy's properties.\n        String connectionString = \"Endpoint={endpoint};SharedAccessKeyName={sharedAccessKeyName};SharedAccessKey={sharedAccessKey};EntityPath={eventHubName}\";\n        EventHubProducerAsyncClient producer = new EventHubClientBuilder()\n            .connectionString(connectionString)\n            .buildAsyncProducer();\n        \/\/ Create an event to send.\n        EventData data = new EventData(\"Hello world!\".getBytes(UTF_8));\n        \/\/ Send that event. This call returns a Mono<Void>, which we subscribe to. It completes successfully when the\n        \/\/ event has been delivered to the Event Hub. It completes with an error if an exception occurred while sending\n        \/\/ the event.\n        \/\/ SendOptions are not specified, so events sent are load balanced between all available partitions in the\n        \/\/ Event Hub instance.\n        producer.send(data).subscribe(\n            (ignored) -> System.out.println(\"Event sent.\"),\n            error -> {\n                System.err.println(\"There was an error sending the event: \" + error.toString());\n                if (error instanceof AmqpException) {\n                    AmqpException amqpException = (AmqpException) error;\n                    System.err.println(String.format(\"Is send operation retriable? %s. Error condition: %s\",\n                        amqpException.isTransient(), amqpException.getErrorCondition()));\n                }\n            }, () -> {\n                \/\/ Disposing of our producer and client.\n                producer.close();\n            });\n    }","code_wo_comment":"public static void main(String[] args) {\n       \n       \n       \n       \n       \n        String connectionString = \"Endpoint={endpoint};SharedAccessKeyName={sharedAccessKeyName};SharedAccessKey={sharedAccessKey};EntityPath={eventHubName}\";\n        EventHubProducerAsyncClient producer = new EventHubClientBuilder()\n            .connectionString(connectionString)\n            .buildAsyncProducer();\n       \n        EventData data = new EventData(\"Hello world!\".getBytes(UTF_8));\n       \n       \n       \n       \n       \n        producer.send(data).subscribe(\n            (ignored) -> System.out.println(\"Event sent.\"),\n            error -> {\n                System.err.println(\"There was an error sending the event: \" + error.toString());\n                if (error instanceof AmqpException) {\n                    AmqpException amqpException = (AmqpException) error;\n                    System.err.println(String.format(\"Is send operation retriable? %s. Error condition: %s\",\n                        amqpException.isTransient(), amqpException.getErrorCondition()));\n                }\n            }, () -> {\n               \n                producer.close();\n            });\n    }","cleancode":"public static void main(string[] args) { string connectionstring = \"endpoint={endpoint};sharedaccesskeyname={sharedaccesskeyname};sharedaccesskey={sharedaccesskey};entitypath={eventhubname}\"; eventhubproducerasyncclient producer = new eventhubclientbuilder() .connectionstring(connectionstring) .buildasyncproducer(); eventdata data = new eventdata(\"hello world!\".getbytes(utf_8)); producer.send(data).subscribe( (ignored) -> system.out.println(\"event sent.\"), error -> { system.err.println(\"there was an error sending the event: \" + error.tostring()); if (error instanceof amqpexception) { amqpexception amqpexception = (amqpexception) error; system.err.println(string.format(\"is send operation retriable? %s. error condition: %s\", amqpexception.istransient(), amqpexception.geterrorcondition())); } }, () -> { producer.close(); }); }","repo":"ppsim\/azure-sdk-for-java","label":[0,0,0,0]}
{"id":822,"original_code":"private BasePrinter escapeCharacter(char c) {\n      if (c == '\"') {\n        return backslashChar(c);\n      }\n      switch (c) {\n        case '\\\\':\n          return backslashChar('\\\\');\n        case '\\r':\n          return backslashChar('r');\n        case '\\n':\n          return backslashChar('n');\n        case '\\t':\n          return backslashChar('t');\n        default:\n          if (c < 32) {\n            \/\/TODO(bazel-team): support \\x escapes\n            return this.append(String.format(\"\\\\x%02x\", (int) c));\n          }\n          return this.append(c); \/\/ no need to support UTF-8\n      } \/\/ endswitch\n    }","code_wo_comment":"private BasePrinter escapeCharacter(char c) {\n      if (c == '\"') {\n        return backslashChar(c);\n      }\n      switch (c) {\n        case '\\\\':\n          return backslashChar('\\\\');\n        case '\\r':\n          return backslashChar('r');\n        case '\\n':\n          return backslashChar('n');\n        case '\\t':\n          return backslashChar('t');\n        default:\n          if (c < 32) {\n           \n            return this.append(String.format(\"\\\\x%02x\", (int) c));\n          }\n          return this.append(c);\n      }\n    }","cleancode":"private baseprinter escapecharacter(char c) { if (c == '\"') { return backslashchar(c); } switch (c) { case '\\\\': return backslashchar('\\\\'); case '\\r': return backslashchar('r'); case '\\n': return backslashchar('n'); case '\\t': return backslashchar('t'); default: if (c < 32) { return this.append(string.format(\"\\\\x%02x\", (int) c)); } return this.append(c); } }","repo":"moroten\/bazel","label":[0,1,0,0]}
{"id":831,"original_code":"private Pair<ImageView, String> loadImageWithCaption(int fileId, String caption, Map <String,\n            Integer> weaponMap, Integer id) {\n        try {\n            \/\/TODO: USE BELOW WHEN INFO IS CHANGED\n            System.out.println(fileId);\n            var image = new ImageView(myLogic.getImage(fileId));\n            System.out.println(\"**********\");\n            System.out.println(image);\n            weaponMap.put(image.toString(), id);\n            image.setFitWidth(100);\n            image.setFitHeight(100);\n            Pair pair = new Pair<>(image, caption);\n            return pair;\n\/\/            return new Pair<>(image, caption);\n        }\n        catch(Exception e){\n            System.out.println(e);\n            \/\/This shouldn't ever happen\n        }\n        return null;\n    }","code_wo_comment":"private Pair<ImageView, String> loadImageWithCaption(int fileId, String caption, Map <String,\n            Integer> weaponMap, Integer id) {\n        try {\n           \n            System.out.println(fileId);\n            var image = new ImageView(myLogic.getImage(fileId));\n            System.out.println(\"**********\");\n            System.out.println(image);\n            weaponMap.put(image.toString(), id);\n            image.setFitWidth(100);\n            image.setFitHeight(100);\n            Pair pair = new Pair<>(image, caption);\n            return pair;\n        }\n        catch(Exception e){\n            System.out.println(e);\n           \n        }\n        return null;\n    }","cleancode":"private pair<imageview, string> loadimagewithcaption(int fileid, string caption, map <string, integer> weaponmap, integer id) { try { system.out.println(fileid); var image = new imageview(mylogic.getimage(fileid)); system.out.println(\"**********\"); system.out.println(image); weaponmap.put(image.tostring(), id); image.setfitwidth(100); image.setfitheight(100); pair pair = new pair<>(image, caption); return pair; } catch(exception e){ system.out.println(e); } return null; }","repo":"pandawithcat\/VoogaSalad","label":[1,0,0,0]}
{"id":25437,"original_code":"@Override\n  public void channelRead0(final ChannelHandlerContext ctx, final RPCMessage msg)\n      throws IOException {\n    switch (msg.getType()) {\n      case RPC_BLOCK_READ_REQUEST:\n        assert msg instanceof RPCBlockReadRequest;\n        mBlockHandler.handleBlockReadRequest(ctx, (RPCBlockReadRequest) msg);\n        break;\n      case RPC_BLOCK_WRITE_REQUEST:\n        assert msg instanceof RPCBlockWriteRequest;\n        mBlockHandler.handleBlockWriteRequest(ctx, (RPCBlockWriteRequest) msg);\n        break;\n      case RPC_FILE_READ_REQUEST:\n        assert msg instanceof RPCFileReadRequest;\n        mUnderFileSystemHandler.handleFileReadRequest(ctx, (RPCFileReadRequest) msg);\n        break;\n      case RPC_FILE_WRITE_REQUEST:\n        assert msg instanceof RPCFileWriteRequest;\n        mUnderFileSystemHandler.handleFileWriteRequest(ctx, (RPCFileWriteRequest) msg);\n        break;\n      case RPC_ERROR_RESPONSE:\n        \/\/ TODO(peis): Fix this, we should not assert here.\n        assert msg instanceof RPCErrorResponse;\n        LOG.error(\"Received an error response from the client: \" + msg.toString());\n        break;\n      default:\n        RPCErrorResponse resp = new RPCErrorResponse(RPCResponse.Status.UNKNOWN_MESSAGE_ERROR);\n        ctx.writeAndFlush(resp);\n        \/\/ TODO(peis): Fix this. We should not throw an exception here.\n        throw new IllegalArgumentException(\n            \"No handler implementation for rpc msg type: \" + msg.getType());\n    }\n  }","code_wo_comment":"@Override\n  public void channelRead0(final ChannelHandlerContext ctx, final RPCMessage msg)\n      throws IOException {\n    switch (msg.getType()) {\n      case RPC_BLOCK_READ_REQUEST:\n        assert msg instanceof RPCBlockReadRequest;\n        mBlockHandler.handleBlockReadRequest(ctx, (RPCBlockReadRequest) msg);\n        break;\n      case RPC_BLOCK_WRITE_REQUEST:\n        assert msg instanceof RPCBlockWriteRequest;\n        mBlockHandler.handleBlockWriteRequest(ctx, (RPCBlockWriteRequest) msg);\n        break;\n      case RPC_FILE_READ_REQUEST:\n        assert msg instanceof RPCFileReadRequest;\n        mUnderFileSystemHandler.handleFileReadRequest(ctx, (RPCFileReadRequest) msg);\n        break;\n      case RPC_FILE_WRITE_REQUEST:\n        assert msg instanceof RPCFileWriteRequest;\n        mUnderFileSystemHandler.handleFileWriteRequest(ctx, (RPCFileWriteRequest) msg);\n        break;\n      case RPC_ERROR_RESPONSE:\n       \n        assert msg instanceof RPCErrorResponse;\n        LOG.error(\"Received an error response from the client: \" + msg.toString());\n        break;\n      default:\n        RPCErrorResponse resp = new RPCErrorResponse(RPCResponse.Status.UNKNOWN_MESSAGE_ERROR);\n        ctx.writeAndFlush(resp);\n       \n        throw new IllegalArgumentException(\n            \"No handler implementation for rpc msg type: \" + msg.getType());\n    }\n  }","cleancode":"@override public void channelread0(final channelhandlercontext ctx, final rpcmessage msg) throws ioexception { switch (msg.gettype()) { case rpc_block_read_request: assert msg instanceof rpcblockreadrequest; mblockhandler.handleblockreadrequest(ctx, (rpcblockreadrequest) msg); break; case rpc_block_write_request: assert msg instanceof rpcblockwriterequest; mblockhandler.handleblockwriterequest(ctx, (rpcblockwriterequest) msg); break; case rpc_file_read_request: assert msg instanceof rpcfilereadrequest; munderfilesystemhandler.handlefilereadrequest(ctx, (rpcfilereadrequest) msg); break; case rpc_file_write_request: assert msg instanceof rpcfilewriterequest; munderfilesystemhandler.handlefilewriterequest(ctx, (rpcfilewriterequest) msg); break; case rpc_error_response: assert msg instanceof rpcerrorresponse; log.error(\"received an error response from the client: \" + msg.tostring()); break; default: rpcerrorresponse resp = new rpcerrorresponse(rpcresponse.status.unknown_message_error); ctx.writeandflush(resp); throw new illegalargumentexception( \"no handler implementation for rpc msg type: \" + msg.gettype()); } }","repo":"ramiyer\/alluxio","label":[1,0,1,0]}
{"id":25438,"original_code":"@Override\n  public void exceptionCaught(ChannelHandlerContext ctx, Throwable cause) throws Exception {\n    LOG.warn(\"Exception thrown while processing request\", cause);\n    \/\/ TODO(peis): This doesn't have to be decode error, it can also be any network errors such as\n    \/\/ connection reset. Fix this ALLUXIO-2235.\n    RPCErrorResponse resp = new RPCErrorResponse(RPCResponse.Status.DECODE_ERROR);\n    ChannelFuture channelFuture = ctx.writeAndFlush(resp);\n    \/\/ Close the channel because it is likely a network error.\n    channelFuture.addListener(ChannelFutureListener.CLOSE);\n  }","code_wo_comment":"@Override\n  public void exceptionCaught(ChannelHandlerContext ctx, Throwable cause) throws Exception {\n    LOG.warn(\"Exception thrown while processing request\", cause);\n   \n   \n    RPCErrorResponse resp = new RPCErrorResponse(RPCResponse.Status.DECODE_ERROR);\n    ChannelFuture channelFuture = ctx.writeAndFlush(resp);\n   \n    channelFuture.addListener(ChannelFutureListener.CLOSE);\n  }","cleancode":"@override public void exceptioncaught(channelhandlercontext ctx, throwable cause) throws exception { log.warn(\"exception thrown while processing request\", cause); rpcerrorresponse resp = new rpcerrorresponse(rpcresponse.status.decode_error); channelfuture channelfuture = ctx.writeandflush(resp); channelfuture.addlistener(channelfuturelistener.close); }","repo":"ramiyer\/alluxio","label":[0,0,1,0]}
{"id":17264,"original_code":"public static NavigableMap<String, Object> readAttrs(Buffer buffer, int version) {\n        NavigableMap<String, Object> attrs = new TreeMap<>(String.CASE_INSENSITIVE_ORDER);\n        int flags = buffer.getInt();\n        if (version >= SftpConstants.SFTP_V4) {\n            int type = buffer.getUByte();\n            switch (type) {\n                case SftpConstants.SSH_FILEXFER_TYPE_REGULAR:\n                    attrs.put(\"isRegular\", Boolean.TRUE);\n                    break;\n                case SftpConstants.SSH_FILEXFER_TYPE_DIRECTORY:\n                    attrs.put(\"isDirectory\", Boolean.TRUE);\n                    break;\n                case SftpConstants.SSH_FILEXFER_TYPE_SYMLINK:\n                    attrs.put(\"isSymbolicLink\", Boolean.TRUE);\n                    break;\n                case SftpConstants.SSH_FILEXFER_TYPE_SOCKET:\n                case SftpConstants.SSH_FILEXFER_TYPE_CHAR_DEVICE:\n                case SftpConstants.SSH_FILEXFER_TYPE_BLOCK_DEVICE:\n                case SftpConstants.SSH_FILEXFER_TYPE_FIFO:\n                    attrs.put(\"isOther\", Boolean.TRUE);\n                    break;\n                default:    \/\/ ignored\n            }\n        }\n        if ((flags & SftpConstants.SSH_FILEXFER_ATTR_SIZE) != 0) {\n            attrs.put(\"size\", buffer.getLong());\n        }\n        if (version == SftpConstants.SFTP_V3) {\n            if ((flags & SftpConstants.SSH_FILEXFER_ATTR_UIDGID) != 0) {\n                attrs.put(\"uid\", buffer.getInt());\n                attrs.put(\"gid\", buffer.getInt());\n            }\n        } else {\n            if ((version >= SftpConstants.SFTP_V6) && ((flags & SftpConstants.SSH_FILEXFER_ATTR_ALLOCATION_SIZE) != 0)) {\n                @SuppressWarnings(\"unused\")\n                long allocSize = buffer.getLong();    \/\/ TODO handle allocation size\n            }\n            if ((flags & SftpConstants.SSH_FILEXFER_ATTR_OWNERGROUP) != 0) {\n                attrs.put(\"owner\", new DefaultGroupPrincipal(buffer.getString()));\n                attrs.put(\"group\", new DefaultGroupPrincipal(buffer.getString()));\n            }\n        }\n        if ((flags & SftpConstants.SSH_FILEXFER_ATTR_PERMISSIONS) != 0) {\n            attrs.put(\"permissions\", permissionsToAttributes(buffer.getInt()));\n        }\n        if (version == SftpConstants.SFTP_V3) {\n            if ((flags & SftpConstants.SSH_FILEXFER_ATTR_ACMODTIME) != 0) {\n                attrs.put(\"lastAccessTime\", readTime(buffer, version, flags));\n                attrs.put(\"lastModifiedTime\", readTime(buffer, version, flags));\n            }\n        } else if (version >= SftpConstants.SFTP_V4) {\n            if ((flags & SftpConstants.SSH_FILEXFER_ATTR_ACCESSTIME) != 0) {\n                attrs.put(\"lastAccessTime\", readTime(buffer, version, flags));\n            }\n            if ((flags & SftpConstants.SSH_FILEXFER_ATTR_CREATETIME) != 0) {\n                attrs.put(\"creationTime\", readTime(buffer, version, flags));\n            }\n            if ((flags & SftpConstants.SSH_FILEXFER_ATTR_MODIFYTIME) != 0) {\n                attrs.put(\"lastModifiedTime\", readTime(buffer, version, flags));\n            }\n            if ((version >= SftpConstants.SFTP_V6) && (flags & SftpConstants.SSH_FILEXFER_ATTR_CTIME) != 0) {\n                attrs.put(\"ctime\", readTime(buffer, version, flags));\n            }\n            if ((flags & SftpConstants.SSH_FILEXFER_ATTR_ACL) != 0) {\n                attrs.put(\"acl\", readACLs(buffer, version));\n            }\n            if ((flags & SftpConstants.SSH_FILEXFER_ATTR_BITS) != 0) {\n                @SuppressWarnings(\"unused\")\n                int bits = buffer.getInt();\n                @SuppressWarnings(\"unused\")\n                int valid = 0xffffffff;\n                if (version >= SftpConstants.SFTP_V6) {\n                    valid = buffer.getInt();\n                }\n                \/\/ TODO: handle attrib bits\n            }\n            if (version >= SftpConstants.SFTP_V6) {\n                if ((flags & SftpConstants.SSH_FILEXFER_ATTR_TEXT_HINT) != 0) {\n                    @SuppressWarnings(\"unused\")\n                    boolean text = buffer.getBoolean(); \/\/ TODO: handle text\n                }\n                if ((flags & SftpConstants.SSH_FILEXFER_ATTR_MIME_TYPE) != 0) {\n                    @SuppressWarnings(\"unused\")\n                    String mimeType = buffer.getString(); \/\/ TODO: handle mime-type\n                }\n                if ((flags & SftpConstants.SSH_FILEXFER_ATTR_LINK_COUNT) != 0) {\n                    @SuppressWarnings(\"unused\")\n                    int nlink = buffer.getInt(); \/\/ TODO: handle link-count\n                }\n                if ((flags & SftpConstants.SSH_FILEXFER_ATTR_UNTRANSLATED_NAME) != 0) {\n                    @SuppressWarnings(\"unused\")\n                    String untranslated = buffer.getString(); \/\/ TODO: handle untranslated-name\n                }\n            }\n        }\n        if ((flags & SftpConstants.SSH_FILEXFER_ATTR_EXTENDED) != 0) {\n            attrs.put(\"extended\", readExtensions(buffer));\n        }\n        return attrs;\n    }","code_wo_comment":"public static NavigableMap<String, Object> readAttrs(Buffer buffer, int version) {\n        NavigableMap<String, Object> attrs = new TreeMap<>(String.CASE_INSENSITIVE_ORDER);\n        int flags = buffer.getInt();\n        if (version >= SftpConstants.SFTP_V4) {\n            int type = buffer.getUByte();\n            switch (type) {\n                case SftpConstants.SSH_FILEXFER_TYPE_REGULAR:\n                    attrs.put(\"isRegular\", Boolean.TRUE);\n                    break;\n                case SftpConstants.SSH_FILEXFER_TYPE_DIRECTORY:\n                    attrs.put(\"isDirectory\", Boolean.TRUE);\n                    break;\n                case SftpConstants.SSH_FILEXFER_TYPE_SYMLINK:\n                    attrs.put(\"isSymbolicLink\", Boolean.TRUE);\n                    break;\n                case SftpConstants.SSH_FILEXFER_TYPE_SOCKET:\n                case SftpConstants.SSH_FILEXFER_TYPE_CHAR_DEVICE:\n                case SftpConstants.SSH_FILEXFER_TYPE_BLOCK_DEVICE:\n                case SftpConstants.SSH_FILEXFER_TYPE_FIFO:\n                    attrs.put(\"isOther\", Boolean.TRUE);\n                    break;\n                default:   \n            }\n        }\n        if ((flags & SftpConstants.SSH_FILEXFER_ATTR_SIZE) != 0) {\n            attrs.put(\"size\", buffer.getLong());\n        }\n        if (version == SftpConstants.SFTP_V3) {\n            if ((flags & SftpConstants.SSH_FILEXFER_ATTR_UIDGID) != 0) {\n                attrs.put(\"uid\", buffer.getInt());\n                attrs.put(\"gid\", buffer.getInt());\n            }\n        } else {\n            if ((version >= SftpConstants.SFTP_V6) && ((flags & SftpConstants.SSH_FILEXFER_ATTR_ALLOCATION_SIZE) != 0)) {\n                @SuppressWarnings(\"unused\")\n                long allocSize = buffer.getLong();   \n            }\n            if ((flags & SftpConstants.SSH_FILEXFER_ATTR_OWNERGROUP) != 0) {\n                attrs.put(\"owner\", new DefaultGroupPrincipal(buffer.getString()));\n                attrs.put(\"group\", new DefaultGroupPrincipal(buffer.getString()));\n            }\n        }\n        if ((flags & SftpConstants.SSH_FILEXFER_ATTR_PERMISSIONS) != 0) {\n            attrs.put(\"permissions\", permissionsToAttributes(buffer.getInt()));\n        }\n        if (version == SftpConstants.SFTP_V3) {\n            if ((flags & SftpConstants.SSH_FILEXFER_ATTR_ACMODTIME) != 0) {\n                attrs.put(\"lastAccessTime\", readTime(buffer, version, flags));\n                attrs.put(\"lastModifiedTime\", readTime(buffer, version, flags));\n            }\n        } else if (version >= SftpConstants.SFTP_V4) {\n            if ((flags & SftpConstants.SSH_FILEXFER_ATTR_ACCESSTIME) != 0) {\n                attrs.put(\"lastAccessTime\", readTime(buffer, version, flags));\n            }\n            if ((flags & SftpConstants.SSH_FILEXFER_ATTR_CREATETIME) != 0) {\n                attrs.put(\"creationTime\", readTime(buffer, version, flags));\n            }\n            if ((flags & SftpConstants.SSH_FILEXFER_ATTR_MODIFYTIME) != 0) {\n                attrs.put(\"lastModifiedTime\", readTime(buffer, version, flags));\n            }\n            if ((version >= SftpConstants.SFTP_V6) && (flags & SftpConstants.SSH_FILEXFER_ATTR_CTIME) != 0) {\n                attrs.put(\"ctime\", readTime(buffer, version, flags));\n            }\n            if ((flags & SftpConstants.SSH_FILEXFER_ATTR_ACL) != 0) {\n                attrs.put(\"acl\", readACLs(buffer, version));\n            }\n            if ((flags & SftpConstants.SSH_FILEXFER_ATTR_BITS) != 0) {\n                @SuppressWarnings(\"unused\")\n                int bits = buffer.getInt();\n                @SuppressWarnings(\"unused\")\n                int valid = 0xffffffff;\n                if (version >= SftpConstants.SFTP_V6) {\n                    valid = buffer.getInt();\n                }\n               \n            }\n            if (version >= SftpConstants.SFTP_V6) {\n                if ((flags & SftpConstants.SSH_FILEXFER_ATTR_TEXT_HINT) != 0) {\n                    @SuppressWarnings(\"unused\")\n                    boolean text = buffer.getBoolean();\n                }\n                if ((flags & SftpConstants.SSH_FILEXFER_ATTR_MIME_TYPE) != 0) {\n                    @SuppressWarnings(\"unused\")\n                    String mimeType = buffer.getString();\n                }\n                if ((flags & SftpConstants.SSH_FILEXFER_ATTR_LINK_COUNT) != 0) {\n                    @SuppressWarnings(\"unused\")\n                    int nlink = buffer.getInt();\n                }\n                if ((flags & SftpConstants.SSH_FILEXFER_ATTR_UNTRANSLATED_NAME) != 0) {\n                    @SuppressWarnings(\"unused\")\n                    String untranslated = buffer.getString();\n                }\n            }\n        }\n        if ((flags & SftpConstants.SSH_FILEXFER_ATTR_EXTENDED) != 0) {\n            attrs.put(\"extended\", readExtensions(buffer));\n        }\n        return attrs;\n    }","cleancode":"public static navigablemap<string, object> readattrs(buffer buffer, int version) { navigablemap<string, object> attrs = new treemap<>(string.case_insensitive_order); int flags = buffer.getint(); if (version >= sftpconstants.sftp_v4) { int type = buffer.getubyte(); switch (type) { case sftpconstants.ssh_filexfer_type_regular: attrs.put(\"isregular\", boolean.true); break; case sftpconstants.ssh_filexfer_type_directory: attrs.put(\"isdirectory\", boolean.true); break; case sftpconstants.ssh_filexfer_type_symlink: attrs.put(\"issymboliclink\", boolean.true); break; case sftpconstants.ssh_filexfer_type_socket: case sftpconstants.ssh_filexfer_type_char_device: case sftpconstants.ssh_filexfer_type_block_device: case sftpconstants.ssh_filexfer_type_fifo: attrs.put(\"isother\", boolean.true); break; default: } } if ((flags & sftpconstants.ssh_filexfer_attr_size) != 0) { attrs.put(\"size\", buffer.getlong()); } if (version == sftpconstants.sftp_v3) { if ((flags & sftpconstants.ssh_filexfer_attr_uidgid) != 0) { attrs.put(\"uid\", buffer.getint()); attrs.put(\"gid\", buffer.getint()); } } else { if ((version >= sftpconstants.sftp_v6) && ((flags & sftpconstants.ssh_filexfer_attr_allocation_size) != 0)) { @suppresswarnings(\"unused\") long allocsize = buffer.getlong(); } if ((flags & sftpconstants.ssh_filexfer_attr_ownergroup) != 0) { attrs.put(\"owner\", new defaultgroupprincipal(buffer.getstring())); attrs.put(\"group\", new defaultgroupprincipal(buffer.getstring())); } } if ((flags & sftpconstants.ssh_filexfer_attr_permissions) != 0) { attrs.put(\"permissions\", permissionstoattributes(buffer.getint())); } if (version == sftpconstants.sftp_v3) { if ((flags & sftpconstants.ssh_filexfer_attr_acmodtime) != 0) { attrs.put(\"lastaccesstime\", readtime(buffer, version, flags)); attrs.put(\"lastmodifiedtime\", readtime(buffer, version, flags)); } } else if (version >= sftpconstants.sftp_v4) { if ((flags & sftpconstants.ssh_filexfer_attr_accesstime) != 0) { attrs.put(\"lastaccesstime\", readtime(buffer, version, flags)); } if ((flags & sftpconstants.ssh_filexfer_attr_createtime) != 0) { attrs.put(\"creationtime\", readtime(buffer, version, flags)); } if ((flags & sftpconstants.ssh_filexfer_attr_modifytime) != 0) { attrs.put(\"lastmodifiedtime\", readtime(buffer, version, flags)); } if ((version >= sftpconstants.sftp_v6) && (flags & sftpconstants.ssh_filexfer_attr_ctime) != 0) { attrs.put(\"ctime\", readtime(buffer, version, flags)); } if ((flags & sftpconstants.ssh_filexfer_attr_acl) != 0) { attrs.put(\"acl\", readacls(buffer, version)); } if ((flags & sftpconstants.ssh_filexfer_attr_bits) != 0) { @suppresswarnings(\"unused\") int bits = buffer.getint(); @suppresswarnings(\"unused\") int valid = 0xffffffff; if (version >= sftpconstants.sftp_v6) { valid = buffer.getint(); } } if (version >= sftpconstants.sftp_v6) { if ((flags & sftpconstants.ssh_filexfer_attr_text_hint) != 0) { @suppresswarnings(\"unused\") boolean text = buffer.getboolean(); } if ((flags & sftpconstants.ssh_filexfer_attr_mime_type) != 0) { @suppresswarnings(\"unused\") string mimetype = buffer.getstring(); } if ((flags & sftpconstants.ssh_filexfer_attr_link_count) != 0) { @suppresswarnings(\"unused\") int nlink = buffer.getint(); } if ((flags & sftpconstants.ssh_filexfer_attr_untranslated_name) != 0) { @suppresswarnings(\"unused\") string untranslated = buffer.getstring(); } } } if ((flags & sftpconstants.ssh_filexfer_attr_extended) != 0) { attrs.put(\"extended\", readextensions(buffer)); } return attrs; }","repo":"msohn\/mina-sshd","label":[0,1,0,0]}
{"id":17318,"original_code":"@Override\n    void storeProperties() throws IOException {\n        super.storeProperties();\n        \/\/ Store chnages in manifest\n        storeManifestChanges();\n        \/\/ store localized info\n        if (bundleInfo != null && bundleInfo.isModified()) {\n            bundleInfo.store();\n        } \/\/ XXX else ignore for now but we could save into some default location\n        ProjectXMLManager pxm = getProjectXMLManager();\n        \/\/ Store project.xml changes\n        \/\/ store module dependencies\n        DependencyListModel dependencyModel = getDependenciesListModel();\n        if (dependencyModel.isChanged()) {\n            Set<ModuleDependency> depsToSave = new TreeSet<ModuleDependency>(dependencyModel.getDependencies());\n            logNetBeansAPIUsage(\"DEPENDENCIES\", dependencyModel.getDependencies()); \/\/ NOI18N\n            try {\n                pxm.replaceDependencies(depsToSave);\n            } catch (CyclicDependencyException ex) {\n                throw new IOException(ex);\n            }\n        }\n        Set<String> friends = getFriendListModel().getFriends();\n        Set<String> publicPkgs = getPublicPackagesModel().getSelectedPackages();\n        boolean refreshModuleList = false;\n        if (getPublicPackagesModel().isChanged() || getFriendListModel().isChanged()) {\n            if (friends.size() > 0) { \/\/ store friends packages\n                pxm.replaceFriends(friends, publicPkgs);\n            } else { \/\/ store public packages\n                pxm.replacePublicPackages(publicPkgs);\n            }\n            refreshModuleList = true;\n        }\n        \/\/ store class-path-extensions + its src & javadoc\n        if (cps != null && wrappedJarsListModel != null && wrappedJarsChanged) {\n            final List<Item> cpExtList = ClassPathUiSupport.getList(wrappedJarsListModel);\n            Map<String, String> newCpExt = new HashMap<String, String>();\n            for (Item item : cpExtList) {\n                String binPath = item.getFilePath();\n                if (binPath != null) {\n                    FileObject fo = FileUtil.toFileObject(PropertyUtils.resolveFile(getProjectDirectoryFile(), binPath));\n                    if(fo != null)\n                    {\n                        String runtimePath = ApisupportAntUtils.CPEXT_RUNTIME_RELATIVE_PATH + fo.getNameExt();\n                        newCpExt.put(runtimePath, binPath);\n                    }\n                }\n            }\n            \/\/ delete removed JARs, remove any remaining exported packages and src&javadoc refs left\n            Iterator<Item> it = getCPExtIterator();\n            HashSet<String> jarsSet = new HashSet<String>(newCpExt.values());\n            while (it.hasNext()) {\n                Item item = it.next();\n                if (!jarsSet.contains(item.getFilePath())) {\n                    \/\/ XXX deleting here doesn't work on Windows: \n\/\/                    File f = PropertyUtils.resolveFile(getProjectDirectoryFile(), item.getFilePath());\n\/\/                    FileObject toDel = FileUtil.toFileObject(f);\n\/\/                    if (toDel != null) {\n\/\/                        toDel.delete();\n\/\/                    }\n                    assert item.getReference() != null : \"getCPExtIterator() initializes references to wrapped JARs\";\n                    item.removeSourceAndJavadoc(getUpdateHelper());\n                    getRefHelper().destroyReference(item.getReference());\n                }\n            }\n            cps.encodeToStrings(cpExtList, CPEXT);\n            pxm.replaceClassPathExtensions(newCpExt);\n            wrappedJarsChanged = false;\n        }\n        if (isStandalone()) {\n            ModuleProperties.storePlatform(getHelper(), getActivePlatform());\n            if (javaPlatformChanged) {\n                ModuleProperties.storeJavaPlatform(getHelper(), getEvaluator(), getActiveJavaPlatform(), false);\n            }\n            if (refreshModuleList) {\n                ModuleList.refreshModuleListForRoot(getProjectDirectoryFile());\n            }\n        } else if (isSuiteComponent() && refreshModuleList) {\n            ModuleList.refreshModuleListForRoot(getSuiteDirectory());\n        } else if (isNetBeansOrg()) {\n            if (javaPlatformChanged) {\n                ModuleProperties.storeJavaPlatform(getHelper(), getEvaluator(), getActiveJavaPlatform(), true);\n            }\n            if (refreshModuleList) {\n                ModuleList.refreshModuleListForRoot(ModuleList.findNetBeansOrg(getProjectDirectoryFile()));\n            }\n        }\n    }","code_wo_comment":"@Override\n    void storeProperties() throws IOException {\n        super.storeProperties();\n       \n        storeManifestChanges();\n       \n        if (bundleInfo != null && bundleInfo.isModified()) {\n            bundleInfo.store();\n        }\n        ProjectXMLManager pxm = getProjectXMLManager();\n       \n       \n        DependencyListModel dependencyModel = getDependenciesListModel();\n        if (dependencyModel.isChanged()) {\n            Set<ModuleDependency> depsToSave = new TreeSet<ModuleDependency>(dependencyModel.getDependencies());\n            logNetBeansAPIUsage(\"DEPENDENCIES\", dependencyModel.getDependencies());\n            try {\n                pxm.replaceDependencies(depsToSave);\n            } catch (CyclicDependencyException ex) {\n                throw new IOException(ex);\n            }\n        }\n        Set<String> friends = getFriendListModel().getFriends();\n        Set<String> publicPkgs = getPublicPackagesModel().getSelectedPackages();\n        boolean refreshModuleList = false;\n        if (getPublicPackagesModel().isChanged() || getFriendListModel().isChanged()) {\n            if (friends.size() > 0) {\n                pxm.replaceFriends(friends, publicPkgs);\n            } else {\n                pxm.replacePublicPackages(publicPkgs);\n            }\n            refreshModuleList = true;\n        }\n       \n        if (cps != null && wrappedJarsListModel != null && wrappedJarsChanged) {\n            final List<Item> cpExtList = ClassPathUiSupport.getList(wrappedJarsListModel);\n            Map<String, String> newCpExt = new HashMap<String, String>();\n            for (Item item : cpExtList) {\n                String binPath = item.getFilePath();\n                if (binPath != null) {\n                    FileObject fo = FileUtil.toFileObject(PropertyUtils.resolveFile(getProjectDirectoryFile(), binPath));\n                    if(fo != null)\n                    {\n                        String runtimePath = ApisupportAntUtils.CPEXT_RUNTIME_RELATIVE_PATH + fo.getNameExt();\n                        newCpExt.put(runtimePath, binPath);\n                    }\n                }\n            }\n           \n            Iterator<Item> it = getCPExtIterator();\n            HashSet<String> jarsSet = new HashSet<String>(newCpExt.values());\n            while (it.hasNext()) {\n                Item item = it.next();\n                if (!jarsSet.contains(item.getFilePath())) {\n                   \n                    assert item.getReference() != null : \"getCPExtIterator() initializes references to wrapped JARs\";\n                    item.removeSourceAndJavadoc(getUpdateHelper());\n                    getRefHelper().destroyReference(item.getReference());\n                }\n            }\n            cps.encodeToStrings(cpExtList, CPEXT);\n            pxm.replaceClassPathExtensions(newCpExt);\n            wrappedJarsChanged = false;\n        }\n        if (isStandalone()) {\n            ModuleProperties.storePlatform(getHelper(), getActivePlatform());\n            if (javaPlatformChanged) {\n                ModuleProperties.storeJavaPlatform(getHelper(), getEvaluator(), getActiveJavaPlatform(), false);\n            }\n            if (refreshModuleList) {\n                ModuleList.refreshModuleListForRoot(getProjectDirectoryFile());\n            }\n        } else if (isSuiteComponent() && refreshModuleList) {\n            ModuleList.refreshModuleListForRoot(getSuiteDirectory());\n        } else if (isNetBeansOrg()) {\n            if (javaPlatformChanged) {\n                ModuleProperties.storeJavaPlatform(getHelper(), getEvaluator(), getActiveJavaPlatform(), true);\n            }\n            if (refreshModuleList) {\n                ModuleList.refreshModuleListForRoot(ModuleList.findNetBeansOrg(getProjectDirectoryFile()));\n            }\n        }\n    }","cleancode":"@override void storeproperties() throws ioexception { super.storeproperties(); storemanifestchanges(); if (bundleinfo != null && bundleinfo.ismodified()) { bundleinfo.store(); } projectxmlmanager pxm = getprojectxmlmanager(); dependencylistmodel dependencymodel = getdependencieslistmodel(); if (dependencymodel.ischanged()) { set<moduledependency> depstosave = new treeset<moduledependency>(dependencymodel.getdependencies()); lognetbeansapiusage(\"dependencies\", dependencymodel.getdependencies()); try { pxm.replacedependencies(depstosave); } catch (cyclicdependencyexception ex) { throw new ioexception(ex); } } set<string> friends = getfriendlistmodel().getfriends(); set<string> publicpkgs = getpublicpackagesmodel().getselectedpackages(); boolean refreshmodulelist = false; if (getpublicpackagesmodel().ischanged() || getfriendlistmodel().ischanged()) { if (friends.size() > 0) { pxm.replacefriends(friends, publicpkgs); } else { pxm.replacepublicpackages(publicpkgs); } refreshmodulelist = true; } if (cps != null && wrappedjarslistmodel != null && wrappedjarschanged) { final list<item> cpextlist = classpathuisupport.getlist(wrappedjarslistmodel); map<string, string> newcpext = new hashmap<string, string>(); for (item item : cpextlist) { string binpath = item.getfilepath(); if (binpath != null) { fileobject fo = fileutil.tofileobject(propertyutils.resolvefile(getprojectdirectoryfile(), binpath)); if(fo != null) { string runtimepath = apisupportantutils.cpext_runtime_relative_path + fo.getnameext(); newcpext.put(runtimepath, binpath); } } } iterator<item> it = getcpextiterator(); hashset<string> jarsset = new hashset<string>(newcpext.values()); while (it.hasnext()) { item item = it.next(); if (!jarsset.contains(item.getfilepath())) { assert item.getreference() != null : \"getcpextiterator() initializes references to wrapped jars\"; item.removesourceandjavadoc(getupdatehelper()); getrefhelper().destroyreference(item.getreference()); } } cps.encodetostrings(cpextlist, cpext); pxm.replaceclasspathextensions(newcpext); wrappedjarschanged = false; } if (isstandalone()) { moduleproperties.storeplatform(gethelper(), getactiveplatform()); if (javaplatformchanged) { moduleproperties.storejavaplatform(gethelper(), getevaluator(), getactivejavaplatform(), false); } if (refreshmodulelist) { modulelist.refreshmodulelistforroot(getprojectdirectoryfile()); } } else if (issuitecomponent() && refreshmodulelist) { modulelist.refreshmodulelistforroot(getsuitedirectory()); } else if (isnetbeansorg()) { if (javaplatformchanged) { moduleproperties.storejavaplatform(gethelper(), getevaluator(), getactivejavaplatform(), true); } if (refreshmodulelist) { modulelist.refreshmodulelistforroot(modulelist.findnetbeansorg(getprojectdirectoryfile())); } } }","repo":"pokebadgerswithspoon\/incubator-netbeans","label":[1,0,1,0]}
{"id":17373,"original_code":"public void deleteByUserId(int userId) {\n        try {\n            DeleteBuilder<UserRequest, Long> deleteBuilder = dao.deleteBuilder();\n            deleteBuilder.where().eq(QMUserColumns.ID, userId);\n            if (deleteBuilder.delete() > 0) {\n                \/\/TODO VT need to think how to send ID to observers\n                notifyObserversDeletedById(userId);\n            }\n        } catch (SQLException e) {\n            ErrorUtils.logError(e);\n        }\n    }","code_wo_comment":"public void deleteByUserId(int userId) {\n        try {\n            DeleteBuilder<UserRequest, Long> deleteBuilder = dao.deleteBuilder();\n            deleteBuilder.where().eq(QMUserColumns.ID, userId);\n            if (deleteBuilder.delete() > 0) {\n               \n                notifyObserversDeletedById(userId);\n            }\n        } catch (SQLException e) {\n            ErrorUtils.logError(e);\n        }\n    }","cleancode":"public void deletebyuserid(int userid) { try { deletebuilder<userrequest, long> deletebuilder = dao.deletebuilder(); deletebuilder.where().eq(qmusercolumns.id, userid); if (deletebuilder.delete() > 0) { notifyobserversdeletedbyid(userid); } } catch (sqlexception e) { errorutils.logerror(e); } }","repo":"philz127\/CAPSTONE","label":[1,0,0,0]}
{"id":25568,"original_code":"@Deprecated\n  public boolean isValidShortNumberForRegion(String shortNumber, String regionDialingFrom) {\n    PhoneMetadata phoneMetadata =\n        MetadataManager.getShortNumberMetadataForRegion(regionDialingFrom);\n    if (phoneMetadata == null) {\n      return false;\n    }\n    PhoneNumberDesc generalDesc = phoneMetadata.getGeneralDesc();\n    if (!matchesPossibleNumberAndNationalNumber(shortNumber, generalDesc)) {\n      return false;\n    }\n    PhoneNumberDesc shortNumberDesc = phoneMetadata.getShortCode();\n    return matchesPossibleNumberAndNationalNumber(shortNumber, shortNumberDesc);\n  }","code_wo_comment":"@Deprecated\n  public boolean isValidShortNumberForRegion(String shortNumber, String regionDialingFrom) {\n    PhoneMetadata phoneMetadata =\n        MetadataManager.getShortNumberMetadataForRegion(regionDialingFrom);\n    if (phoneMetadata == null) {\n      return false;\n    }\n    PhoneNumberDesc generalDesc = phoneMetadata.getGeneralDesc();\n    if (!matchesPossibleNumberAndNationalNumber(shortNumber, generalDesc)) {\n      return false;\n    }\n    PhoneNumberDesc shortNumberDesc = phoneMetadata.getShortCode();\n    return matchesPossibleNumberAndNationalNumber(shortNumber, shortNumberDesc);\n  }","cleancode":"@deprecated public boolean isvalidshortnumberforregion(string shortnumber, string regiondialingfrom) { phonemetadata phonemetadata = metadatamanager.getshortnumbermetadataforregion(regiondialingfrom); if (phonemetadata == null) { return false; } phonenumberdesc generaldesc = phonemetadata.getgeneraldesc(); if (!matchespossiblenumberandnationalnumber(shortnumber, generaldesc)) { return false; } phonenumberdesc shortnumberdesc = phonemetadata.getshortcode(); return matchespossiblenumberandnationalnumber(shortnumber, shortnumberdesc); }","repo":"nickbarban\/libphonenumber","label":[0,0,0,0]}
{"id":33777,"original_code":"private List<AnnotatedAttributeValuePair> getAttributeValuePairs(JsonOutcome outcome, JsonReference reference) {\n        Optional<String> docNameTrue = getFirstDocname(reference);\n        String docName = docNameTrue.orElse(outcome.getShortTitle());\n        \/\/ we use the highlighted text to put the table caption\n        String highlightedText = outcome.getOutcomeDescription();\n        Arm arm1 = getAssignedArm(outcome.getItemArmIdGrp1(), outcome.getGrp1ArmName());\n        Arm arm2 = getAssignedArm(outcome.getItemArmIdGrp2(), outcome.getGrp2ArmName());\n        \/\/ outcome values\n        Attribute ovAttribute = attributes.getFromName(\"Outcome value\");\n        AnnotatedAttributeValuePair ov1 = new AnnotatedAttributeValuePair(ovAttribute, outcome.getData3(),\n                docName, arm1, \"\", highlightedText, \"\", 0);\n        AnnotatedAttributeValuePair ov2 = new AnnotatedAttributeValuePair(ovAttribute, outcome.getData4(),\n                docName, arm2, \"\", highlightedText, \"\", 0);\n        \/\/ timepoints\n        Attribute timepointAttribute = attributes.getFromName(\"Longest follow up\");\n        AnnotatedAttributeValuePair tp1 = new AnnotatedAttributeValuePair(timepointAttribute, outcome.getTimepointString(),\n                docName, arm1, \"\", highlightedText, \"\", 0);\n        AnnotatedAttributeValuePair tp2 = new AnnotatedAttributeValuePair(timepointAttribute, outcome.getTimepointString(),\n                docName, arm2, \"\", highlightedText, \"\", 0);\n        \/\/ timepoint units\n        Attribute timepointUnitAttribute = attributes.getFromName(\"Longest follow up (metric)\");\n        AnnotatedAttributeValuePair tpUnit1 = new AnnotatedAttributeValuePair(timepointUnitAttribute, outcome.getItemTimepointMetric(),\n                docName, arm1, \"\", highlightedText, \"\", 0);\n        AnnotatedAttributeValuePair tpUnit2 = new AnnotatedAttributeValuePair(timepointUnitAttribute, outcome.getItemTimepointMetric(),\n                docName, arm2, \"\", highlightedText, \"\", 0);\n        \/\/ sample size\n        Attribute samplesizeAttribute = attributes.getFromName(\"Individual-level analysed\");\n        AnnotatedAttributeValuePair ss1 = new AnnotatedAttributeValuePair(samplesizeAttribute, outcome.getData1(),\n                docName, arm1, \"\", highlightedText, \"\", 0);\n        AnnotatedAttributeValuePair ss2 = new AnnotatedAttributeValuePair(samplesizeAttribute, outcome.getData2(),\n                docName, arm2, \"\", highlightedText, \"\", 0);\n        \/\/ TODO: anything else?\n        return Lists.newArrayList(ov1, ov2, tp1, tp2, tpUnit1, tpUnit2, ss1, ss2);\n    }","code_wo_comment":"private List<AnnotatedAttributeValuePair> getAttributeValuePairs(JsonOutcome outcome, JsonReference reference) {\n        Optional<String> docNameTrue = getFirstDocname(reference);\n        String docName = docNameTrue.orElse(outcome.getShortTitle());\n       \n        String highlightedText = outcome.getOutcomeDescription();\n        Arm arm1 = getAssignedArm(outcome.getItemArmIdGrp1(), outcome.getGrp1ArmName());\n        Arm arm2 = getAssignedArm(outcome.getItemArmIdGrp2(), outcome.getGrp2ArmName());\n       \n        Attribute ovAttribute = attributes.getFromName(\"Outcome value\");\n        AnnotatedAttributeValuePair ov1 = new AnnotatedAttributeValuePair(ovAttribute, outcome.getData3(),\n                docName, arm1, \"\", highlightedText, \"\", 0);\n        AnnotatedAttributeValuePair ov2 = new AnnotatedAttributeValuePair(ovAttribute, outcome.getData4(),\n                docName, arm2, \"\", highlightedText, \"\", 0);\n       \n        Attribute timepointAttribute = attributes.getFromName(\"Longest follow up\");\n        AnnotatedAttributeValuePair tp1 = new AnnotatedAttributeValuePair(timepointAttribute, outcome.getTimepointString(),\n                docName, arm1, \"\", highlightedText, \"\", 0);\n        AnnotatedAttributeValuePair tp2 = new AnnotatedAttributeValuePair(timepointAttribute, outcome.getTimepointString(),\n                docName, arm2, \"\", highlightedText, \"\", 0);\n       \n        Attribute timepointUnitAttribute = attributes.getFromName(\"Longest follow up (metric)\");\n        AnnotatedAttributeValuePair tpUnit1 = new AnnotatedAttributeValuePair(timepointUnitAttribute, outcome.getItemTimepointMetric(),\n                docName, arm1, \"\", highlightedText, \"\", 0);\n        AnnotatedAttributeValuePair tpUnit2 = new AnnotatedAttributeValuePair(timepointUnitAttribute, outcome.getItemTimepointMetric(),\n                docName, arm2, \"\", highlightedText, \"\", 0);\n       \n        Attribute samplesizeAttribute = attributes.getFromName(\"Individual-level analysed\");\n        AnnotatedAttributeValuePair ss1 = new AnnotatedAttributeValuePair(samplesizeAttribute, outcome.getData1(),\n                docName, arm1, \"\", highlightedText, \"\", 0);\n        AnnotatedAttributeValuePair ss2 = new AnnotatedAttributeValuePair(samplesizeAttribute, outcome.getData2(),\n                docName, arm2, \"\", highlightedText, \"\", 0);\n       \n        return Lists.newArrayList(ov1, ov2, tp1, tp2, tpUnit1, tpUnit2, ss1, ss2);\n    }","cleancode":"private list<annotatedattributevaluepair> getattributevaluepairs(jsonoutcome outcome, jsonreference reference) { optional<string> docnametrue = getfirstdocname(reference); string docname = docnametrue.orelse(outcome.getshorttitle()); string highlightedtext = outcome.getoutcomedescription(); arm arm1 = getassignedarm(outcome.getitemarmidgrp1(), outcome.getgrp1armname()); arm arm2 = getassignedarm(outcome.getitemarmidgrp2(), outcome.getgrp2armname()); attribute ovattribute = attributes.getfromname(\"outcome value\"); annotatedattributevaluepair ov1 = new annotatedattributevaluepair(ovattribute, outcome.getdata3(), docname, arm1, \"\", highlightedtext, \"\", 0); annotatedattributevaluepair ov2 = new annotatedattributevaluepair(ovattribute, outcome.getdata4(), docname, arm2, \"\", highlightedtext, \"\", 0); attribute timepointattribute = attributes.getfromname(\"longest follow up\"); annotatedattributevaluepair tp1 = new annotatedattributevaluepair(timepointattribute, outcome.gettimepointstring(), docname, arm1, \"\", highlightedtext, \"\", 0); annotatedattributevaluepair tp2 = new annotatedattributevaluepair(timepointattribute, outcome.gettimepointstring(), docname, arm2, \"\", highlightedtext, \"\", 0); attribute timepointunitattribute = attributes.getfromname(\"longest follow up (metric)\"); annotatedattributevaluepair tpunit1 = new annotatedattributevaluepair(timepointunitattribute, outcome.getitemtimepointmetric(), docname, arm1, \"\", highlightedtext, \"\", 0); annotatedattributevaluepair tpunit2 = new annotatedattributevaluepair(timepointunitattribute, outcome.getitemtimepointmetric(), docname, arm2, \"\", highlightedtext, \"\", 0); attribute samplesizeattribute = attributes.getfromname(\"individual-level analysed\"); annotatedattributevaluepair ss1 = new annotatedattributevaluepair(samplesizeattribute, outcome.getdata1(), docname, arm1, \"\", highlightedtext, \"\", 0); annotatedattributevaluepair ss2 = new annotatedattributevaluepair(samplesizeattribute, outcome.getdata2(), docname, arm2, \"\", highlightedtext, \"\", 0); return lists.newarraylist(ov1, ov2, tp1, tp2, tpunit1, tpunit2, ss1, ss2); }","repo":"ouyangzhiping\/Info-extract","label":[1,0,0,0]}
{"id":33859,"original_code":"public void sortRows(AlignmentTrack.SortOption option, double location) {\n        if (alignmentRows == null) {\n            return;\n        }\n        for (AlignmentInterval.Row row : alignmentRows) {\n            if (option == AlignmentTrack.SortOption.NUCELOTIDE) {\n                \/\/ TODO -- why is this here?\n            }\n            row.updateScore(option, location, this);\n        }\n        Collections.sort(alignmentRows, new Comparator<Row>() {\n            public int compare(AlignmentInterval.Row arg0, AlignmentInterval.Row arg1) {\n                if (arg0.getScore() > arg1.getScore()) {\n                    return 1;\n                } else if (arg0.getScore() > arg1.getScore()) {\n                    return -1;\n                }\n                return 0;\n            }\n        });\n    }","code_wo_comment":"public void sortRows(AlignmentTrack.SortOption option, double location) {\n        if (alignmentRows == null) {\n            return;\n        }\n        for (AlignmentInterval.Row row : alignmentRows) {\n            if (option == AlignmentTrack.SortOption.NUCELOTIDE) {\n               \n            }\n            row.updateScore(option, location, this);\n        }\n        Collections.sort(alignmentRows, new Comparator<Row>() {\n            public int compare(AlignmentInterval.Row arg0, AlignmentInterval.Row arg1) {\n                if (arg0.getScore() > arg1.getScore()) {\n                    return 1;\n                } else if (arg0.getScore() > arg1.getScore()) {\n                    return -1;\n                }\n                return 0;\n            }\n        });\n    }","cleancode":"public void sortrows(alignmenttrack.sortoption option, double location) { if (alignmentrows == null) { return; } for (alignmentinterval.row row : alignmentrows) { if (option == alignmenttrack.sortoption.nucelotide) { } row.updatescore(option, location, this); } collections.sort(alignmentrows, new comparator<row>() { public int compare(alignmentinterval.row arg0, alignmentinterval.row arg1) { if (arg0.getscore() > arg1.getscore()) { return 1; } else if (arg0.getscore() > arg1.getscore()) { return -1; } return 0; } }); }","repo":"nrgene\/NRGene-IGV","label":[1,0,0,0]}
{"id":17516,"original_code":"public native byte [] getClientIp();","code_wo_comment":"public native byte [] getClientIp();","cleancode":"public native byte [] getclientip();","repo":"recolic\/hbase-2.1.0","label":[0,0,1,0]}
{"id":25782,"original_code":"public static List<JSONObject> constructRokuNativeElements(JSONObject elementObj) {\n\t\tList<JSONObject> elements = new ArrayList<>();\n\t\tJSONArray valueArr = (JSONArray) elementObj.get(\"value\");\n\t\tif (valueArr == null) {\n\t\t\treturn elements;\n\t\t}\n\t\tfor (int i = 0; i < valueArr.size(); i++) {\n\t\t\tString[] boundsComponents = { \"0\", \"0\", \"0\", \"0\" };\n\t\t\tString text = \"\";\n\t\t\tJSONObject valueObj = (JSONObject) valueArr.get(i);\n\t\t\tJSONArray attrArr = (JSONArray) valueObj.get(\"Attrs\");\n\t\t\tfor (int i2 = 0; i2 < attrArr.size(); i2++) {\n\t\t\t\tJSONObject attrObj = (JSONObject) attrArr.get(i2);\n\t\t\t\tJSONObject nameObj = (JSONObject) attrObj.get(\"Name\");\n\t\t\t\tif (nameObj.containsValue(\"bounds\")) {\n\t\t\t\t\tString boundsStr = (String) attrObj.get(\"Value\");\n\t\t\t\t\tboundsStr = boundsStr.replace(\"{\", \"\").replace(\"}\", \"\");\n\t\t\t\t\tboundsComponents = boundsStr.split(\", \");\n\t\t\t\t}\n\t\t\t\tif (nameObj.containsValue(\"text\")) {\n\t\t\t\t\ttext = (String) attrObj.get(\"Value\");\n\t\t\t\t}\n\t\t\t}\n\t\t\telements.add(constructRokuNativeElementJSON(elementObj, text, boundsComponents));\n\t\t}\n\t\treturn elements;\n\t}","code_wo_comment":"public static List<JSONObject> constructRokuNativeElements(JSONObject elementObj) {\n\t\tList<JSONObject> elements = new ArrayList<>();\n\t\tJSONArray valueArr = (JSONArray) elementObj.get(\"value\");\n\t\tif (valueArr == null) {\n\t\t\treturn elements;\n\t\t}\n\t\tfor (int i = 0; i < valueArr.size(); i++) {\n\t\t\tString[] boundsComponents = { \"0\", \"0\", \"0\", \"0\" };\n\t\t\tString text = \"\";\n\t\t\tJSONObject valueObj = (JSONObject) valueArr.get(i);\n\t\t\tJSONArray attrArr = (JSONArray) valueObj.get(\"Attrs\");\n\t\t\tfor (int i2 = 0; i2 < attrArr.size(); i2++) {\n\t\t\t\tJSONObject attrObj = (JSONObject) attrArr.get(i2);\n\t\t\t\tJSONObject nameObj = (JSONObject) attrObj.get(\"Name\");\n\t\t\t\tif (nameObj.containsValue(\"bounds\")) {\n\t\t\t\t\tString boundsStr = (String) attrObj.get(\"Value\");\n\t\t\t\t\tboundsStr = boundsStr.replace(\"{\", \"\").replace(\"}\", \"\");\n\t\t\t\t\tboundsComponents = boundsStr.split(\", \");\n\t\t\t\t}\n\t\t\t\tif (nameObj.containsValue(\"text\")) {\n\t\t\t\t\ttext = (String) attrObj.get(\"Value\");\n\t\t\t\t}\n\t\t\t}\n\t\t\telements.add(constructRokuNativeElementJSON(elementObj, text, boundsComponents));\n\t\t}\n\t\treturn elements;\n\t}","cleancode":"public static list<jsonobject> constructrokunativeelements(jsonobject elementobj) { list<jsonobject> elements = new arraylist<>(); jsonarray valuearr = (jsonarray) elementobj.get(\"value\"); if (valuearr == null) { return elements; } for (int i = 0; i < valuearr.size(); i++) { string[] boundscomponents = { \"0\", \"0\", \"0\", \"0\" }; string text = \"\"; jsonobject valueobj = (jsonobject) valuearr.get(i); jsonarray attrarr = (jsonarray) valueobj.get(\"attrs\"); for (int i2 = 0; i2 < attrarr.size(); i2++) { jsonobject attrobj = (jsonobject) attrarr.get(i2); jsonobject nameobj = (jsonobject) attrobj.get(\"name\"); if (nameobj.containsvalue(\"bounds\")) { string boundsstr = (string) attrobj.get(\"value\"); boundsstr = boundsstr.replace(\"{\", \"\").replace(\"}\", \"\"); boundscomponents = boundsstr.split(\", \"); } if (nameobj.containsvalue(\"text\")) { text = (string) attrobj.get(\"value\"); } } elements.add(constructrokunativeelementjson(elementobj, text, boundscomponents)); } return elements; }","repo":"mohanakrishna12\/rokuality-server","label":[0,1,0,0]}
{"id":1229,"original_code":"@Test\n  public void testReadFailure() throws IOException {\n    \/\/ TODO (lwhite): These tests don't fail. What was their intent?\n    Table table1 =\n        Table.read()\n            .csv(CsvReadOptions.builder(\"..\/data\/read_failure_test.csv\").minimizeColumnSizes());\n    table1.structure(); \/\/ just make sure the import completed\n    ShortColumn test = table1.shortColumn(\"Test\");\n    \/\/ TODO(lwhite): Better tests\n    assertNotNull(test.summary());\n  }","code_wo_comment":"@Test\n  public void testReadFailure() throws IOException {\n   \n    Table table1 =\n        Table.read()\n            .csv(CsvReadOptions.builder(\"..\/data\/read_failure_test.csv\").minimizeColumnSizes());\n    table1.structure();\n    ShortColumn test = table1.shortColumn(\"Test\");\n   \n    assertNotNull(test.summary());\n  }","cleancode":"@test public void testreadfailure() throws ioexception { table table1 = table.read() .csv(csvreadoptions.builder(\"..\/data\/read_failure_test.csv\").minimizecolumnsizes()); table1.structure(); shortcolumn test = table1.shortcolumn(\"test\"); assertnotnull(test.summary()); }","repo":"rayeaster\/tablesaw","label":[0,0,0,1]}
{"id":34107,"original_code":"public void copyFrom(OutputProperties opsrc)\n    throws TransformerException\n  {\n   \/\/ Bugzilla 6157: recover from xsl:output statements\n    \/\/ checkDuplicates(opsrc);\n    copyFrom(opsrc.getProperties());\n  }","code_wo_comment":"public void copyFrom(OutputProperties opsrc)\n    throws TransformerException\n  {\n  \n   \n    copyFrom(opsrc.getProperties());\n  }","cleancode":"public void copyfrom(outputproperties opsrc) throws transformerexception { copyfrom(opsrc.getproperties()); }","repo":"oradian\/xalan-j","label":[0,0,1,0]}
{"id":25919,"original_code":"private void buildDependencyTree( Queue<DependencyNode> nodeQueue, boolean full, boolean online, Session session, Map<String, Profile> profiles, PomFileLoader loader, Log log )\n\t\t{\n\t\t\tint neededLevels = full ? -1 : 1;\n\t\t\twhile( !nodeQueue.isEmpty() )\n\t\t\t{\n\t\t\t\tDependencyNode node = nodeQueue.poll();\n\t\t\t\tif( neededLevels >= 0 && node.getLevel() >= neededLevels )\n\t\t\t\t\tcontinue;\n\t\t\t\tnode.collectDependencyManagement( profiles, session.projects(), log );\n\t\t\t\tMap<DependencyKey, RawDependency> localDependencies = getHierarchicalDependencies( session, node.getProject(), null, online, profiles, log );\n\t\t\t\tif( localDependencies == null )\n\t\t\t\t\tcontinue;\n\t\t\t\tfor( Entry<DependencyKey, RawDependency> e : localDependencies.entrySet() )\n\t\t\t\t{\n\t\t\t\t\tDependencyKey dependencyKey = e.getKey();\n\t\t\t\t\tRawDependency dependency = e.getValue();\n\t\t\t\t\tif( dependency.isOptional() && !node.isRoot() )\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\tGroupArtifact ga = new GroupArtifact( dependencyKey.getGroupId(), dependencyKey.getArtifactId() );\n\t\t\t\t\tif( isGroupArtifactExcluded( node, ga ) )\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\tDependencyNode existingNode = node.searchNodeForGroupArtifact( ga );\n\t\t\t\t\tif( existingNode != null )\n\t\t\t\t\t{\n\t\t\t\t\t\tif( existingNode.getLevel() <= node.getLevel() + 1 )\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\telse\n\t\t\t\t\t\t\texistingNode.removeFromParent();\n\t\t\t\t\t}\n\t\t\t\t\tfinal Optional<VersionScope> optionalVs = getVersionScopeFromDependencyManagement( node, dependencyKey, dependency );\n\t\t\t\t\tfinal VersionScope vs;\n\t\t\t\t\tif(optionalVs.isPresent() )\n\t\t\t\t\t{\n\t\t\t\t\t\tvs = optionalVs.get();\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\tvs = dependency.getVs();\n\t\t\t\t\t\tif( node.isRoot() )\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tif(vs.getScope() == null) {\n\t\t\t\t\t\t\t\tvs.setScope( Scope.COMPILE );\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tScope scope = Scope.getScopeTransformation( node.getVs().getScope(), dependency.getVs().getScope() );\n\t\t\t\t\t\t\tif(scope == null )\n\t\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t\tvs.setScope( scope );\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tScope scope = vs.getScope();\n\t\t\t\t\tassert scope != null;\n\t\t\t\t\tassert vs.getVersion() != null : \"null version of dependency \" + dependencyKey + \" -> \" + dependency + \" (for project \" + project + \")\";\n\t\t\t\t\tif( scope == Scope.IMPORT || scope == Scope.SYSTEM )\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\/\/ get remote repositories\n\t\t\t\t\tList<Repository> additionalRepos = getProjectRepositories( session, node.getProject(), log );\n\t\t\t\t\tGav dependencyGav = new Gav( dependencyKey.getGroupId(), dependencyKey.getArtifactId(), vs.getVersion() );\n\t\t\t\t\tProject childProject = null;\n\t\t\t\t\tif( neededLevels < 0 || node.getLevel() >= neededLevels )\n\t\t\t\t\t{\n\t\t\t\t\t\tchildProject = session.projects().forGav( dependencyGav );\n\t\t\t\t\t\tif( childProject == null )\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tFile pomFile = loader.loadPomFileForGav( dependencyGav, additionalRepos, log );\n\t\t\t\t\t\t\tif( pomFile == null )\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tlog.html( Tools.errorMessage( \"cannot fetch project \" + dependencyGav + \" referenced in \" + node.getProject() ) );\n\t\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tPomAnalysis analysis = new PomAnalysis( session, loader, null, false, log );\n\t\t\t\t\t\t\tanalysis.addFile( pomFile );\n\t\t\t\t\t\t\tSet<Project> loadedProjects = analysis.loadProjects();\n\t\t\t\t\t\t\tif( loadedProjects.size() != 1 )\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tlog.html( Tools.errorMessage( \"cannot fetch project \" + dependencyGav + \" referenced in \" + node.getProject() ) );\n\t\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tchildProject = loadedProjects.iterator().next();\n\t\t\t\t\t\t\tanalysis.completeLoadedProjects();\n\t\t\t\t\t\t\tanalysis.addCompletedProjectsToSession();\n\t\t\t\t\t\t\tSet<Project> addedToGraph = analysis.addCompletedProjectsToGraph();\n\t\t\t\t\t\t\tif( !addedToGraph.contains( childProject ) )\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tlog.html( Tools.errorMessage( \"cannot fetch project \" + dependencyGav + \" referenced in \" + node.getProject() ) );\n\t\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif( childProject == null )\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\/\/ TODO : use specified repositories if needed !\n\t\t\t\t\t\t\tlog.html( Tools.warningMessage( \"cannot fetch project \" + dependencyGav + \" referenced in \" + node.getProject() + (dependency.isOptional() ? \" (this is an optional dependency)\" : \"\") ) );\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tDependencyNode child = new DependencyNode( childProject, dependencyKey, vs );\n\t\t\t\t\tchild.addExclusions( dependency.getExclusions() );\n\t\t\t\t\tnode.addChild( child );\n\t\t\t\t\tDependencyManagement dm = node.getLocalManagement( dependencyKey );\n\t\t\t\t\tif( dm != null )\n\t\t\t\t\t\tchild.addExclusions( dm.getExclusions() );\n\t\t\t\t\t\/\/FIXME is always false\n\t\t\t\t\tif( scope == Scope.SYSTEM )\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\/\/ TODO it seems to me that transitive dependency policy only\n\t\t\t\t\t\/\/ applies to jar artifacts, is that true ??\n\t\t\t\t\t\/\/ if( \"jar\".equals( dependencyKey.getType() ) )\n\t\t\t\t\tnodeQueue.add( child );\n\t\t\t\t}\n\t\t\t}\n\t\t}","code_wo_comment":"private void buildDependencyTree( Queue<DependencyNode> nodeQueue, boolean full, boolean online, Session session, Map<String, Profile> profiles, PomFileLoader loader, Log log )\n\t\t{\n\t\t\tint neededLevels = full ? -1 : 1;\n\t\t\twhile( !nodeQueue.isEmpty() )\n\t\t\t{\n\t\t\t\tDependencyNode node = nodeQueue.poll();\n\t\t\t\tif( neededLevels >= 0 && node.getLevel() >= neededLevels )\n\t\t\t\t\tcontinue;\n\t\t\t\tnode.collectDependencyManagement( profiles, session.projects(), log );\n\t\t\t\tMap<DependencyKey, RawDependency> localDependencies = getHierarchicalDependencies( session, node.getProject(), null, online, profiles, log );\n\t\t\t\tif( localDependencies == null )\n\t\t\t\t\tcontinue;\n\t\t\t\tfor( Entry<DependencyKey, RawDependency> e : localDependencies.entrySet() )\n\t\t\t\t{\n\t\t\t\t\tDependencyKey dependencyKey = e.getKey();\n\t\t\t\t\tRawDependency dependency = e.getValue();\n\t\t\t\t\tif( dependency.isOptional() && !node.isRoot() )\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\tGroupArtifact ga = new GroupArtifact( dependencyKey.getGroupId(), dependencyKey.getArtifactId() );\n\t\t\t\t\tif( isGroupArtifactExcluded( node, ga ) )\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\tDependencyNode existingNode = node.searchNodeForGroupArtifact( ga );\n\t\t\t\t\tif( existingNode != null )\n\t\t\t\t\t{\n\t\t\t\t\t\tif( existingNode.getLevel() <= node.getLevel() + 1 )\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\telse\n\t\t\t\t\t\t\texistingNode.removeFromParent();\n\t\t\t\t\t}\n\t\t\t\t\tfinal Optional<VersionScope> optionalVs = getVersionScopeFromDependencyManagement( node, dependencyKey, dependency );\n\t\t\t\t\tfinal VersionScope vs;\n\t\t\t\t\tif(optionalVs.isPresent() )\n\t\t\t\t\t{\n\t\t\t\t\t\tvs = optionalVs.get();\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\tvs = dependency.getVs();\n\t\t\t\t\t\tif( node.isRoot() )\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tif(vs.getScope() == null) {\n\t\t\t\t\t\t\t\tvs.setScope( Scope.COMPILE );\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tScope scope = Scope.getScopeTransformation( node.getVs().getScope(), dependency.getVs().getScope() );\n\t\t\t\t\t\t\tif(scope == null )\n\t\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t\tvs.setScope( scope );\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tScope scope = vs.getScope();\n\t\t\t\t\tassert scope != null;\n\t\t\t\t\tassert vs.getVersion() != null : \"null version of dependency \" + dependencyKey + \" -> \" + dependency + \" (for project \" + project + \")\";\n\t\t\t\t\tif( scope == Scope.IMPORT || scope == Scope.SYSTEM )\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\n\t\t\t\t\tList<Repository> additionalRepos = getProjectRepositories( session, node.getProject(), log );\n\t\t\t\t\tGav dependencyGav = new Gav( dependencyKey.getGroupId(), dependencyKey.getArtifactId(), vs.getVersion() );\n\t\t\t\t\tProject childProject = null;\n\t\t\t\t\tif( neededLevels < 0 || node.getLevel() >= neededLevels )\n\t\t\t\t\t{\n\t\t\t\t\t\tchildProject = session.projects().forGav( dependencyGav );\n\t\t\t\t\t\tif( childProject == null )\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tFile pomFile = loader.loadPomFileForGav( dependencyGav, additionalRepos, log );\n\t\t\t\t\t\t\tif( pomFile == null )\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tlog.html( Tools.errorMessage( \"cannot fetch project \" + dependencyGav + \" referenced in \" + node.getProject() ) );\n\t\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tPomAnalysis analysis = new PomAnalysis( session, loader, null, false, log );\n\t\t\t\t\t\t\tanalysis.addFile( pomFile );\n\t\t\t\t\t\t\tSet<Project> loadedProjects = analysis.loadProjects();\n\t\t\t\t\t\t\tif( loadedProjects.size() != 1 )\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tlog.html( Tools.errorMessage( \"cannot fetch project \" + dependencyGav + \" referenced in \" + node.getProject() ) );\n\t\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tchildProject = loadedProjects.iterator().next();\n\t\t\t\t\t\t\tanalysis.completeLoadedProjects();\n\t\t\t\t\t\t\tanalysis.addCompletedProjectsToSession();\n\t\t\t\t\t\t\tSet<Project> addedToGraph = analysis.addCompletedProjectsToGraph();\n\t\t\t\t\t\t\tif( !addedToGraph.contains( childProject ) )\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tlog.html( Tools.errorMessage( \"cannot fetch project \" + dependencyGav + \" referenced in \" + node.getProject() ) );\n\t\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif( childProject == null )\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\n\t\t\t\t\t\t\tlog.html( Tools.warningMessage( \"cannot fetch project \" + dependencyGav + \" referenced in \" + node.getProject() + (dependency.isOptional() ? \" (this is an optional dependency)\" : \"\") ) );\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tDependencyNode child = new DependencyNode( childProject, dependencyKey, vs );\n\t\t\t\t\tchild.addExclusions( dependency.getExclusions() );\n\t\t\t\t\tnode.addChild( child );\n\t\t\t\t\tDependencyManagement dm = node.getLocalManagement( dependencyKey );\n\t\t\t\t\tif( dm != null )\n\t\t\t\t\t\tchild.addExclusions( dm.getExclusions() );\n\t\t\t\t\n\t\t\t\t\tif( scope == Scope.SYSTEM )\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\n\t\t\t\t\n\t\t\t\t\n\t\t\t\t\tnodeQueue.add( child );\n\t\t\t\t}\n\t\t\t}\n\t\t}","cleancode":"private void builddependencytree( queue<dependencynode> nodequeue, boolean full, boolean online, session session, map<string, profile> profiles, pomfileloader loader, log log ) { int neededlevels = full ? -1 : 1; while( !nodequeue.isempty() ) { dependencynode node = nodequeue.poll(); if( neededlevels >= 0 && node.getlevel() >= neededlevels ) continue; node.collectdependencymanagement( profiles, session.projects(), log ); map<dependencykey, rawdependency> localdependencies = gethierarchicaldependencies( session, node.getproject(), null, online, profiles, log ); if( localdependencies == null ) continue; for( entry<dependencykey, rawdependency> e : localdependencies.entryset() ) { dependencykey dependencykey = e.getkey(); rawdependency dependency = e.getvalue(); if( dependency.isoptional() && !node.isroot() ) continue; groupartifact ga = new groupartifact( dependencykey.getgroupid(), dependencykey.getartifactid() ); if( isgroupartifactexcluded( node, ga ) ) continue; dependencynode existingnode = node.searchnodeforgroupartifact( ga ); if( existingnode != null ) { if( existingnode.getlevel() <= node.getlevel() + 1 ) continue; else existingnode.removefromparent(); } final optional<versionscope> optionalvs = getversionscopefromdependencymanagement( node, dependencykey, dependency ); final versionscope vs; if(optionalvs.ispresent() ) { vs = optionalvs.get(); } else { vs = dependency.getvs(); if( node.isroot() ) { if(vs.getscope() == null) { vs.setscope( scope.compile ); } } else { scope scope = scope.getscopetransformation( node.getvs().getscope(), dependency.getvs().getscope() ); if(scope == null ) continue; vs.setscope( scope ); } } scope scope = vs.getscope(); assert scope != null; assert vs.getversion() != null : \"null version of dependency \" + dependencykey + \" -> \" + dependency + \" (for project \" + project + \")\"; if( scope == scope.import || scope == scope.system ) continue; list<repository> additionalrepos = getprojectrepositories( session, node.getproject(), log ); gav dependencygav = new gav( dependencykey.getgroupid(), dependencykey.getartifactid(), vs.getversion() ); project childproject = null; if( neededlevels < 0 || node.getlevel() >= neededlevels ) { childproject = session.projects().forgav( dependencygav ); if( childproject == null ) { file pomfile = loader.loadpomfileforgav( dependencygav, additionalrepos, log ); if( pomfile == null ) { log.html( tools.errormessage( \"cannot fetch project \" + dependencygav + \" referenced in \" + node.getproject() ) ); continue; } pomanalysis analysis = new pomanalysis( session, loader, null, false, log ); analysis.addfile( pomfile ); set<project> loadedprojects = analysis.loadprojects(); if( loadedprojects.size() != 1 ) { log.html( tools.errormessage( \"cannot fetch project \" + dependencygav + \" referenced in \" + node.getproject() ) ); continue; } childproject = loadedprojects.iterator().next(); analysis.completeloadedprojects(); analysis.addcompletedprojectstosession(); set<project> addedtograph = analysis.addcompletedprojectstograph(); if( !addedtograph.contains( childproject ) ) { log.html( tools.errormessage( \"cannot fetch project \" + dependencygav + \" referenced in \" + node.getproject() ) ); continue; } } if( childproject == null ) { log.html( tools.warningmessage( \"cannot fetch project \" + dependencygav + \" referenced in \" + node.getproject() + (dependency.isoptional() ? \" (this is an optional dependency)\" : \"\") ) ); continue; } } dependencynode child = new dependencynode( childproject, dependencykey, vs ); child.addexclusions( dependency.getexclusions() ); node.addchild( child ); dependencymanagement dm = node.getlocalmanagement( dependencykey ); if( dm != null ) child.addexclusions( dm.getexclusions() ); if( scope == scope.system ) continue; nodequeue.add( child ); } } }","repo":"mpicque\/pom-explorer","label":[1,1,1,0]}
{"id":34120,"original_code":"private void setupViewPager(ViewPager viewPager) {\n        \/\/ TODO: see if we can replace the words with icons in the future\n        mSectionsPageAdapter.addFragment(new HomeFragment(), \"Home\");\n        mSectionsPageAdapter.addFragment(new SettingsFragment(), \"Settings\");\n        viewPager.setAdapter(mSectionsPageAdapter);\n    }","code_wo_comment":"private void setupViewPager(ViewPager viewPager) {\n       \n        mSectionsPageAdapter.addFragment(new HomeFragment(), \"Home\");\n        mSectionsPageAdapter.addFragment(new SettingsFragment(), \"Settings\");\n        viewPager.setAdapter(mSectionsPageAdapter);\n    }","cleancode":"private void setupviewpager(viewpager viewpager) { msectionspageadapter.addfragment(new homefragment(), \"home\"); msectionspageadapter.addfragment(new settingsfragment(), \"settings\"); viewpager.setadapter(msectionspageadapter); }","repo":"mo-morgan\/Food-Radar","label":[1,0,0,0]}
{"id":1432,"original_code":"@Override\n\tpublic void onDestroy() {\n\t    super.onDestroy();  \/\/ Always call the superclass\n\t    \/\/ probably not needed, onStop closes the socket, which should make the thread stop (?)\n\t    if (recvAsyncTask != null)\n\t    \trecvAsyncTask.cancel(true);\n\t    recvAsyncTask = null;\n\t}","code_wo_comment":"@Override\n\tpublic void onDestroy() {\n\t    super.onDestroy(); \n\t   \n\t    if (recvAsyncTask != null)\n\t    \trecvAsyncTask.cancel(true);\n\t    recvAsyncTask = null;\n\t}","cleancode":"@override public void ondestroy() { super.ondestroy(); if (recvasynctask != null) recvasynctask.cancel(true); recvasynctask = null; }","repo":"phques\/androidpush","label":[1,0,0,0]}
{"id":1435,"original_code":"public static CashierTransaction fromJson(\n    \t\tfinal Cashier cashier,\n    \t\tfinal JsonCommand command) {\n        final Integer txnType = command.integerValueOfParameterNamed(\"txnType\");\n        final BigDecimal txnAmount = command.bigDecimalValueOfParameterNamed(\"txnAmount\");\n        final LocalDate txnDate = command.localDateValueOfParameterNamed(\"txnDate\");\n        final String entityType = command.stringValueOfParameterNamed(\"entityType\");\n        final String txnNote = command.stringValueOfParameterNamed(\"txnNote\");\n        final Long entityId = command.longValueOfParameterNamed(\"entityId\");\n        final String currencyCode = command.stringValueOfParameterNamed(\"currencyCode\");\n        \/\/ TODO: get client\/loan\/savings details\n        return new CashierTransaction (cashier, txnType, txnAmount, txnDate, \n        \t\tentityType, entityId, txnNote, currencyCode);\n    }","code_wo_comment":"public static CashierTransaction fromJson(\n    \t\tfinal Cashier cashier,\n    \t\tfinal JsonCommand command) {\n        final Integer txnType = command.integerValueOfParameterNamed(\"txnType\");\n        final BigDecimal txnAmount = command.bigDecimalValueOfParameterNamed(\"txnAmount\");\n        final LocalDate txnDate = command.localDateValueOfParameterNamed(\"txnDate\");\n        final String entityType = command.stringValueOfParameterNamed(\"entityType\");\n        final String txnNote = command.stringValueOfParameterNamed(\"txnNote\");\n        final Long entityId = command.longValueOfParameterNamed(\"entityId\");\n        final String currencyCode = command.stringValueOfParameterNamed(\"currencyCode\");\n       \n        return new CashierTransaction (cashier, txnType, txnAmount, txnDate, \n        \t\tentityType, entityId, txnNote, currencyCode);\n    }","cleancode":"public static cashiertransaction fromjson( final cashier cashier, final jsoncommand command) { final integer txntype = command.integervalueofparameternamed(\"txntype\"); final bigdecimal txnamount = command.bigdecimalvalueofparameternamed(\"txnamount\"); final localdate txndate = command.localdatevalueofparameternamed(\"txndate\"); final string entitytype = command.stringvalueofparameternamed(\"entitytype\"); final string txnnote = command.stringvalueofparameternamed(\"txnnote\"); final long entityid = command.longvalueofparameternamed(\"entityid\"); final string currencycode = command.stringvalueofparameternamed(\"currencycode\"); return new cashiertransaction (cashier, txntype, txnamount, txndate, entitytype, entityid, txnnote, currencycode); }","repo":"raghuvissu\/GST","label":[0,1,0,0]}
{"id":1463,"original_code":"public void parse(InputStream file) throws IOException, TikaException {\n        ByteArrayOutputStream xmpraw = new ByteArrayOutputStream();\n        if (!scanner.parse(file, xmpraw)) {\n            return;\n        }\n        Reader decoded = new InputStreamReader(\n                new ByteArrayInputStream(xmpraw.toByteArray()),\n                DEFAULT_XMP_CHARSET);\n        try {\n            XMPMetadata xmp = XMPMetadata.load(new InputSource(decoded));\n            XMPSchemaDublinCore dc = xmp.getDublinCoreSchema();\n            if (dc != null) {\n                if (dc.getTitle() != null) {\n                    metadata.set(DublinCore.TITLE, dc.getTitle());\n                }\n                if (dc.getDescription() != null) {\n                    metadata.set(DublinCore.DESCRIPTION, dc.getDescription());\n                }\n                if (dc.getCreators() != null && dc.getCreators().size() > 0) {\n                    metadata.set(DublinCore.CREATOR, joinCreators(dc.getCreators()));\n                }\n                if (dc.getSubjects() != null && dc.getSubjects().size() > 0) {\n                    Iterator<String> keywords = dc.getSubjects().iterator();\n                    while (keywords.hasNext()) {\n                        metadata.add(DublinCore.SUBJECT, keywords.next());\n                    }\n                    \/\/ TODO should we set KEYWORDS too?\n                    \/\/ All tested photo managers set the same in Iptc.Application2.Keywords and Xmp.dc.subject\n                }\n            }\n        } catch (IOException e) {\n            \/\/ Could not parse embedded XMP metadata. That's not a serious\n            \/\/ problem, so we'll just ignore the issue for now.\n            \/\/ TODO: Make error handling like this configurable.\n        }\n    }","code_wo_comment":"public void parse(InputStream file) throws IOException, TikaException {\n        ByteArrayOutputStream xmpraw = new ByteArrayOutputStream();\n        if (!scanner.parse(file, xmpraw)) {\n            return;\n        }\n        Reader decoded = new InputStreamReader(\n                new ByteArrayInputStream(xmpraw.toByteArray()),\n                DEFAULT_XMP_CHARSET);\n        try {\n            XMPMetadata xmp = XMPMetadata.load(new InputSource(decoded));\n            XMPSchemaDublinCore dc = xmp.getDublinCoreSchema();\n            if (dc != null) {\n                if (dc.getTitle() != null) {\n                    metadata.set(DublinCore.TITLE, dc.getTitle());\n                }\n                if (dc.getDescription() != null) {\n                    metadata.set(DublinCore.DESCRIPTION, dc.getDescription());\n                }\n                if (dc.getCreators() != null && dc.getCreators().size() > 0) {\n                    metadata.set(DublinCore.CREATOR, joinCreators(dc.getCreators()));\n                }\n                if (dc.getSubjects() != null && dc.getSubjects().size() > 0) {\n                    Iterator<String> keywords = dc.getSubjects().iterator();\n                    while (keywords.hasNext()) {\n                        metadata.add(DublinCore.SUBJECT, keywords.next());\n                    }\n                   \n                   \n                }\n            }\n        } catch (IOException e) {\n           \n           \n           \n        }\n    }","cleancode":"public void parse(inputstream file) throws ioexception, tikaexception { bytearrayoutputstream xmpraw = new bytearrayoutputstream(); if (!scanner.parse(file, xmpraw)) { return; } reader decoded = new inputstreamreader( new bytearrayinputstream(xmpraw.tobytearray()), default_xmp_charset); try { xmpmetadata xmp = xmpmetadata.load(new inputsource(decoded)); xmpschemadublincore dc = xmp.getdublincoreschema(); if (dc != null) { if (dc.gettitle() != null) { metadata.set(dublincore.title, dc.gettitle()); } if (dc.getdescription() != null) { metadata.set(dublincore.description, dc.getdescription()); } if (dc.getcreators() != null && dc.getcreators().size() > 0) { metadata.set(dublincore.creator, joincreators(dc.getcreators())); } if (dc.getsubjects() != null && dc.getsubjects().size() > 0) { iterator<string> keywords = dc.getsubjects().iterator(); while (keywords.hasnext()) { metadata.add(dublincore.subject, keywords.next()); } } } } catch (ioexception e) { } }","repo":"ontometrics\/tika","label":[1,1,0,0]}
{"id":9676,"original_code":"@Override\n    public List<Movie> getMoviesRatedByUser(int userId) {\n        \/\/ TODO: write query to retrieve all movies rated by user with id userId\n        List<Movie> movies = new LinkedList<Movie>();\n        Genre genre0 = new Genre(0, \"genre0\");\n        Genre genre1 = new Genre(1, \"genre1\");\n        Genre genre2 = new Genre(2, \"genre2\");\n        movies.add(new Movie(0, \"Titre 0\", Arrays.asList(new Genre[]{genre0, genre1})));\n        movies.add(new Movie(3, \"Titre 3\", Arrays.asList(new Genre[]{genre0, genre1, genre2})));\n        return movies;\n    }","code_wo_comment":"@Override\n    public List<Movie> getMoviesRatedByUser(int userId) {\n       \n        List<Movie> movies = new LinkedList<Movie>();\n        Genre genre0 = new Genre(0, \"genre0\");\n        Genre genre1 = new Genre(1, \"genre1\");\n        Genre genre2 = new Genre(2, \"genre2\");\n        movies.add(new Movie(0, \"Titre 0\", Arrays.asList(new Genre[]{genre0, genre1})));\n        movies.add(new Movie(3, \"Titre 3\", Arrays.asList(new Genre[]{genre0, genre1, genre2})));\n        return movies;\n    }","cleancode":"@override public list<movie> getmoviesratedbyuser(int userid) { list<movie> movies = new linkedlist<movie>(); genre genre0 = new genre(0, \"genre0\"); genre genre1 = new genre(1, \"genre1\"); genre genre2 = new genre(2, \"genre2\"); movies.add(new movie(0, \"titre 0\", arrays.aslist(new genre[]{genre0, genre1}))); movies.add(new movie(3, \"titre 3\", arrays.aslist(new genre[]{genre0, genre1, genre2}))); return movies; }","repo":"quentinceschin123456\/MovieRecommender","label":[0,1,0,0]}
{"id":1545,"original_code":"public void execute(List<String> statements) throws MetaStoreException {\n    for (String statement : statements) {\n      execute(statement);\n    }\n  }","code_wo_comment":"public void execute(List<String> statements) throws MetaStoreException {\n    for (String statement : statements) {\n      execute(statement);\n    }\n  }","cleancode":"public void execute(list<string> statements) throws metastoreexception { for (string statement : statements) { execute(statement); } }","repo":"plusplusjiajia\/SSM","label":[1,0,0,0]}
{"id":9749,"original_code":"@Test\n  public void testGetFormatted ()\n  {\n    IMutableCurrencyValue aCV = new CurrencyValue (ECurrency.EUR, MathHelper.toBigDecimal (5));\n    if (EJavaVersion.JDK_9.isSupportedVersion ())\n      assertEquals (\"5,00\" + CURRENCY_SPACE + \"\u20ac\", aCV.getCurrencyFormatted ());\n    else\n      assertEquals (\"\u20ac\" + CURRENCY_SPACE + \"5,00\", aCV.getCurrencyFormatted ());\n    aCV = new CurrencyValue (ECurrency.EUR, new BigDecimal (\"5.12\"));\n    if (EJavaVersion.JDK_9.isSupportedVersion ())\n      assertEquals (\"5,12\" + CURRENCY_SPACE + \"\u20ac\", aCV.getCurrencyFormatted ());\n    else\n      assertEquals (\"\u20ac\" + CURRENCY_SPACE + \"5,12\", aCV.getCurrencyFormatted ());\n    aCV = new CurrencyValue (ECurrency.USD, new BigDecimal (\"5.12\"));\n    assertEquals (\"$5.12\", aCV.getCurrencyFormatted ());\n    for (final ECurrency eCurrency : ECurrency.values ())\n    {\n      aCV = new CurrencyValue (eCurrency, new BigDecimal (\"5.12\"));\n      final String sCurrencyFormatted = aCV.getCurrencyFormatted ();\n      assertNotNull (sCurrencyFormatted);\n      final String sValueFormatted = aCV.getValueFormatted ();\n      assertNotNull (sValueFormatted);\n      assertTrue (sValueFormatted, sValueFormatted.indexOf (CurrencyHelper.getCurrencySymbol (eCurrency)) < 0);\n      CommonsTestHelper.testGetClone (aCV);\n      \/\/ There seems to be a bug in the optimizer of 1.6.0_45 so that the output\n      \/\/ values are sometimes reordered - dunno why :(\n      LOGGER.info (\"[\" + sCurrencyFormatted + \"][\" + sValueFormatted + \"]\");\n    }\n  }","code_wo_comment":"@Test\n  public void testGetFormatted ()\n  {\n    IMutableCurrencyValue aCV = new CurrencyValue (ECurrency.EUR, MathHelper.toBigDecimal (5));\n    if (EJavaVersion.JDK_9.isSupportedVersion ())\n      assertEquals (\"5,00\" + CURRENCY_SPACE + \"\u20ac\", aCV.getCurrencyFormatted ());\n    else\n      assertEquals (\"\u20ac\" + CURRENCY_SPACE + \"5,00\", aCV.getCurrencyFormatted ());\n    aCV = new CurrencyValue (ECurrency.EUR, new BigDecimal (\"5.12\"));\n    if (EJavaVersion.JDK_9.isSupportedVersion ())\n      assertEquals (\"5,12\" + CURRENCY_SPACE + \"\u20ac\", aCV.getCurrencyFormatted ());\n    else\n      assertEquals (\"\u20ac\" + CURRENCY_SPACE + \"5,12\", aCV.getCurrencyFormatted ());\n    aCV = new CurrencyValue (ECurrency.USD, new BigDecimal (\"5.12\"));\n    assertEquals (\"$5.12\", aCV.getCurrencyFormatted ());\n    for (final ECurrency eCurrency : ECurrency.values ())\n    {\n      aCV = new CurrencyValue (eCurrency, new BigDecimal (\"5.12\"));\n      final String sCurrencyFormatted = aCV.getCurrencyFormatted ();\n      assertNotNull (sCurrencyFormatted);\n      final String sValueFormatted = aCV.getValueFormatted ();\n      assertNotNull (sValueFormatted);\n      assertTrue (sValueFormatted, sValueFormatted.indexOf (CurrencyHelper.getCurrencySymbol (eCurrency)) < 0);\n      CommonsTestHelper.testGetClone (aCV);\n     \n     \n      LOGGER.info (\"[\" + sCurrencyFormatted + \"][\" + sValueFormatted + \"]\");\n    }\n  }","cleancode":"@test public void testgetformatted () { imutablecurrencyvalue acv = new currencyvalue (ecurrency.eur, mathhelper.tobigdecimal (5)); if (ejavaversion.jdk_9.issupportedversion ()) assertequals (\"5,00\" + currency_space + \"\u20ac\", acv.getcurrencyformatted ()); else assertequals (\"\u20ac\" + currency_space + \"5,00\", acv.getcurrencyformatted ()); acv = new currencyvalue (ecurrency.eur, new bigdecimal (\"5.12\")); if (ejavaversion.jdk_9.issupportedversion ()) assertequals (\"5,12\" + currency_space + \"\u20ac\", acv.getcurrencyformatted ()); else assertequals (\"\u20ac\" + currency_space + \"5,12\", acv.getcurrencyformatted ()); acv = new currencyvalue (ecurrency.usd, new bigdecimal (\"5.12\")); assertequals (\"$5.12\", acv.getcurrencyformatted ()); for (final ecurrency ecurrency : ecurrency.values ()) { acv = new currencyvalue (ecurrency, new bigdecimal (\"5.12\")); final string scurrencyformatted = acv.getcurrencyformatted (); assertnotnull (scurrencyformatted); final string svalueformatted = acv.getvalueformatted (); assertnotnull (svalueformatted); asserttrue (svalueformatted, svalueformatted.indexof (currencyhelper.getcurrencysymbol (ecurrency)) < 0); commonstesthelper.testgetclone (acv); logger.info (\"[\" + scurrencyformatted + \"][\" + svalueformatted + \"]\"); } }","repo":"phax\/ph-masterdata","label":[0,0,1,0]}
{"id":34357,"original_code":"List<CandidateField> findCandidateFieldsForType(@NonNull Object source) {\n        \/\/ At this point source class represents the true polymorphic type of the document\n        Class<?> sourceClass = source.getClass();\n        \/\/ Lock a thread wanting to find information about the same type\n        \/\/ So that this information retrieval is only done once\n        \/\/ Ignore this warning, this class reference will be on the heap\n        List<CandidateField> candidateFields = this.encryptedFieldsMap.get(sourceClass);\n        if (candidateFields != null) {\n            \/\/ The cache is already aware of this type, return candidate fields for it\n            return candidateFields;\n        }\n        \/\/ Don't bother with primitives\n        if (ClassUtils.isPrimitiveOrWrapper(sourceClass)) return Collections.emptyList();\n        \/\/ If it is not known, scan each field for annotation or Appsmith type\n        List<CandidateField> finalCandidateFields = new ArrayList<>();\n        synchronized (sourceClass) {\n            ReflectionUtils.doWithFields(sourceClass, field -> {\n                if (field.getAnnotation(Encrypted.class) != null) {\n                    CandidateField candidateField = new CandidateField(field, CandidateField.Type.ANNOTATED_FIELD);\n                    finalCandidateFields.add(candidateField);\n                } else if (AppsmithDomain.class.isAssignableFrom(field.getType())) {\n                    CandidateField candidateField = null;\n                    field.setAccessible(true);\n                    Object fieldValue = ReflectionUtils.getField(field, source);\n                    if (fieldValue == null) {\n                        if (this.encryptedFieldsMap.containsKey(field.getType())) {\n                            \/\/ If this field is null, but the cache has a non-empty list of candidates already,\n                            \/\/ then this is an appsmith field with known annotations\n                            candidateField = new CandidateField(field, CandidateField.Type.APPSMITH_FIELD_KNOWN);\n                        } else {\n                            \/\/ If it is null and the cache is not aware of the field, this is still a prospect,\n                            \/\/ but with an unknown type (could also be polymorphic)\n                            candidateField = new CandidateField(field, CandidateField.Type.APPSMITH_FIELD_UNKNOWN);\n                        }\n                    } else {\n                        \/\/ If an object exists, check if the object type is the same as the field type\n                        CandidateField.Type appsmithFieldType;\n                        if (field.getType().getCanonicalName().equals(fieldValue.getClass().getCanonicalName())) {\n                            \/\/ If they match, then this is going to be an appsmith known field\n                            appsmithFieldType = CandidateField.Type.APPSMITH_FIELD_KNOWN;\n                        } else {\n                            \/\/ If not, then this field is polymorphic,\n                            \/\/ it will need to be checked for type every time\n                            appsmithFieldType = CandidateField.Type.APPSMITH_FIELD_POLYMORPHIC;\n                        }\n                        \/\/ Now, go into field type and repeat\n                        List<CandidateField> candidateFieldsForType = findCandidateFieldsForType(fieldValue);\n                        if (appsmithFieldType.equals(CandidateField.Type.APPSMITH_FIELD_POLYMORPHIC)\n                                || !candidateFieldsForType.isEmpty()) {\n                            \/\/ This type only qualifies as a candidate if it is polymorphic,\n                            \/\/ or has a list of candidates\n                            candidateField = new CandidateField(field, appsmithFieldType);\n                        }\n                    }\n                    field.setAccessible(false);\n                    if (candidateField != null) {\n                        \/\/ This will only ever be null if the field value is populated,\n                        \/\/ and is known to be a non-encryption related field\n                        finalCandidateFields.add(candidateField);\n                    }\n                } else if (Collection.class.isAssignableFrom(field.getType()) &&\n                        field.getGenericType() instanceof ParameterizedType) {\n                    \/\/ If this is a collection, check if the Type parameter is an AppsmithDomain\n                    Type[] typeArguments;\n                    ParameterizedType parameterizedType = (ParameterizedType) field.getGenericType();\n                    typeArguments = parameterizedType.getActualTypeArguments();\n                    Class<?> subFieldType;\n                    try {\n                        subFieldType = (Class<?>) typeArguments[0];\n                    } catch (ClassCastException|ArrayIndexOutOfBoundsException e) {\n                        subFieldType = null;\n                    }\n                    if(subFieldType != null) {\n                        if (this.encryptedFieldsMap.containsKey(subFieldType)) {\n                            \/\/ This is a known type, it should necessarily be of AppsmithDomain type\n                            assert AppsmithDomain.class.isAssignableFrom(subFieldType);\n                            final List<CandidateField> existingSubTypeCandidates = this.encryptedFieldsMap.get(subFieldType);\n                            if (!existingSubTypeCandidates.isEmpty()) {\n                                finalCandidateFields.add(new CandidateField(field, CandidateField.Type.APPSMITH_COLLECTION_KNOWN));\n                            }\n                        } else if (AppsmithDomain.class.isAssignableFrom(subFieldType)) {\n                            \/\/ If the type is not known, then this is either not parsed yet, or has polymorphic implementations\n                            field.setAccessible(true);\n                            Object fieldValue = ReflectionUtils.getField(field, source);\n                            Collection<?> collection = (Collection<?>) fieldValue;\n                            if (collection == null || collection.isEmpty()) {\n                                finalCandidateFields.add(new CandidateField(field, CandidateField.Type.APPSMITH_COLLECTION_UNKNOWN));\n                            } else {\n                                for (final Object o : collection) {\n                                    if (o == null) {\n                                        continue;\n                                    }\n                                    if (o.getClass().getCanonicalName().equals(subFieldType.getTypeName())) {\n                                        final List<CandidateField> candidateFieldsForListMember = findCandidateFieldsForType(o);\n                                        if (candidateFieldsForListMember != null && !candidateFieldsForListMember.isEmpty()) {\n                                            finalCandidateFields.add(new CandidateField(field, CandidateField.Type.APPSMITH_COLLECTION_KNOWN));\n                                        }\n                                    } else {\n                                        finalCandidateFields.add(new CandidateField(field, CandidateField.Type.APPSMITH_COLLECTION_POLYMORPHIC));\n                                    }\n                                    break;\n                                }\n                            }\n                            field.setAccessible(false);\n                        }\n                    }\n                    \/\/ TODO Add support for nested collections\n                } else if (Map.class.isAssignableFrom(field.getType()) &&\n                        field.getGenericType() instanceof ParameterizedType) {\n                    Type[] typeArguments;\n                    ParameterizedType parameterizedType = (ParameterizedType) field.getGenericType();\n                    typeArguments = parameterizedType.getActualTypeArguments();\n                    Class<?> subFieldType = (Class<?>) typeArguments[1];\n                    if (this.encryptedFieldsMap.containsKey(subFieldType)) {\n                        \/\/ This is a known type, it should necessarily be of AppsmithDomain type\n                        assert AppsmithDomain.class.isAssignableFrom(subFieldType);\n                        final List<CandidateField> existingSubTypeCandidates = this.encryptedFieldsMap.get(subFieldType);\n                        if (!existingSubTypeCandidates.isEmpty()) {\n                            finalCandidateFields.add(new CandidateField(field, CandidateField.Type.APPSMITH_MAP_KNOWN));\n                        }\n                    } else if (AppsmithDomain.class.isAssignableFrom(subFieldType)) {\n                        \/\/ If the type is not known, then this is either not parsed yet, or has polymorphic implementations\n                        field.setAccessible(true);\n                        Object fieldValue = ReflectionUtils.getField(field, source);\n                        Map<?, ?> map = (Map<?, ?>) fieldValue;\n                        if (map == null || map.isEmpty()) {\n                            finalCandidateFields.add(new CandidateField(field, CandidateField.Type.APPSMITH_MAP_UNKNOWN));\n                        } else {\n                            for (Map.Entry<?, ?> entry : map.entrySet()) {\n                                final Object value = entry.getValue();\n                                if (value == null) {\n                                    continue;\n                                }\n                                if (value.getClass().getCanonicalName().equals(subFieldType.getTypeName())) {\n                                    final List<CandidateField> candidateFieldsForListMember = findCandidateFieldsForType(value);\n                                    if (candidateFieldsForListMember != null && !candidateFieldsForListMember.isEmpty()) {\n                                        finalCandidateFields.add(new CandidateField(field, CandidateField.Type.APPSMITH_MAP_KNOWN));\n                                    }\n                                } else {\n                                    finalCandidateFields.add(new CandidateField(field, CandidateField.Type.APPSMITH_MAP_POLYMORPHIC));\n                                }\n                                break;\n                            }\n                        }\n                        field.setAccessible(false);\n                    }\n                }\n            }, field -> field.getAnnotation(Encrypted.class) != null ||\n                    AppsmithDomain.class.isAssignableFrom(field.getType()) ||\n                    Collection.class.isAssignableFrom(field.getType()) ||\n                    Map.class.isAssignableFrom(field.getType()));\n        }\n        \/\/ Update cache for next use\n        encryptedFieldsMap.put(sourceClass, finalCandidateFields);\n        return finalCandidateFields;\n    }","code_wo_comment":"List<CandidateField> findCandidateFieldsForType(@NonNull Object source) {\n       \n        Class<?> sourceClass = source.getClass();\n       \n       \n       \n        List<CandidateField> candidateFields = this.encryptedFieldsMap.get(sourceClass);\n        if (candidateFields != null) {\n           \n            return candidateFields;\n        }\n       \n        if (ClassUtils.isPrimitiveOrWrapper(sourceClass)) return Collections.emptyList();\n       \n        List<CandidateField> finalCandidateFields = new ArrayList<>();\n        synchronized (sourceClass) {\n            ReflectionUtils.doWithFields(sourceClass, field -> {\n                if (field.getAnnotation(Encrypted.class) != null) {\n                    CandidateField candidateField = new CandidateField(field, CandidateField.Type.ANNOTATED_FIELD);\n                    finalCandidateFields.add(candidateField);\n                } else if (AppsmithDomain.class.isAssignableFrom(field.getType())) {\n                    CandidateField candidateField = null;\n                    field.setAccessible(true);\n                    Object fieldValue = ReflectionUtils.getField(field, source);\n                    if (fieldValue == null) {\n                        if (this.encryptedFieldsMap.containsKey(field.getType())) {\n                           \n                           \n                            candidateField = new CandidateField(field, CandidateField.Type.APPSMITH_FIELD_KNOWN);\n                        } else {\n                           \n                           \n                            candidateField = new CandidateField(field, CandidateField.Type.APPSMITH_FIELD_UNKNOWN);\n                        }\n                    } else {\n                       \n                        CandidateField.Type appsmithFieldType;\n                        if (field.getType().getCanonicalName().equals(fieldValue.getClass().getCanonicalName())) {\n                           \n                            appsmithFieldType = CandidateField.Type.APPSMITH_FIELD_KNOWN;\n                        } else {\n                           \n                           \n                            appsmithFieldType = CandidateField.Type.APPSMITH_FIELD_POLYMORPHIC;\n                        }\n                       \n                        List<CandidateField> candidateFieldsForType = findCandidateFieldsForType(fieldValue);\n                        if (appsmithFieldType.equals(CandidateField.Type.APPSMITH_FIELD_POLYMORPHIC)\n                                || !candidateFieldsForType.isEmpty()) {\n                           \n                           \n                            candidateField = new CandidateField(field, appsmithFieldType);\n                        }\n                    }\n                    field.setAccessible(false);\n                    if (candidateField != null) {\n                       \n                       \n                        finalCandidateFields.add(candidateField);\n                    }\n                } else if (Collection.class.isAssignableFrom(field.getType()) &&\n                        field.getGenericType() instanceof ParameterizedType) {\n                   \n                    Type[] typeArguments;\n                    ParameterizedType parameterizedType = (ParameterizedType) field.getGenericType();\n                    typeArguments = parameterizedType.getActualTypeArguments();\n                    Class<?> subFieldType;\n                    try {\n                        subFieldType = (Class<?>) typeArguments[0];\n                    } catch (ClassCastException|ArrayIndexOutOfBoundsException e) {\n                        subFieldType = null;\n                    }\n                    if(subFieldType != null) {\n                        if (this.encryptedFieldsMap.containsKey(subFieldType)) {\n                           \n                            assert AppsmithDomain.class.isAssignableFrom(subFieldType);\n                            final List<CandidateField> existingSubTypeCandidates = this.encryptedFieldsMap.get(subFieldType);\n                            if (!existingSubTypeCandidates.isEmpty()) {\n                                finalCandidateFields.add(new CandidateField(field, CandidateField.Type.APPSMITH_COLLECTION_KNOWN));\n                            }\n                        } else if (AppsmithDomain.class.isAssignableFrom(subFieldType)) {\n                           \n                            field.setAccessible(true);\n                            Object fieldValue = ReflectionUtils.getField(field, source);\n                            Collection<?> collection = (Collection<?>) fieldValue;\n                            if (collection == null || collection.isEmpty()) {\n                                finalCandidateFields.add(new CandidateField(field, CandidateField.Type.APPSMITH_COLLECTION_UNKNOWN));\n                            } else {\n                                for (final Object o : collection) {\n                                    if (o == null) {\n                                        continue;\n                                    }\n                                    if (o.getClass().getCanonicalName().equals(subFieldType.getTypeName())) {\n                                        final List<CandidateField> candidateFieldsForListMember = findCandidateFieldsForType(o);\n                                        if (candidateFieldsForListMember != null && !candidateFieldsForListMember.isEmpty()) {\n                                            finalCandidateFields.add(new CandidateField(field, CandidateField.Type.APPSMITH_COLLECTION_KNOWN));\n                                        }\n                                    } else {\n                                        finalCandidateFields.add(new CandidateField(field, CandidateField.Type.APPSMITH_COLLECTION_POLYMORPHIC));\n                                    }\n                                    break;\n                                }\n                            }\n                            field.setAccessible(false);\n                        }\n                    }\n                   \n                } else if (Map.class.isAssignableFrom(field.getType()) &&\n                        field.getGenericType() instanceof ParameterizedType) {\n                    Type[] typeArguments;\n                    ParameterizedType parameterizedType = (ParameterizedType) field.getGenericType();\n                    typeArguments = parameterizedType.getActualTypeArguments();\n                    Class<?> subFieldType = (Class<?>) typeArguments[1];\n                    if (this.encryptedFieldsMap.containsKey(subFieldType)) {\n                       \n                        assert AppsmithDomain.class.isAssignableFrom(subFieldType);\n                        final List<CandidateField> existingSubTypeCandidates = this.encryptedFieldsMap.get(subFieldType);\n                        if (!existingSubTypeCandidates.isEmpty()) {\n                            finalCandidateFields.add(new CandidateField(field, CandidateField.Type.APPSMITH_MAP_KNOWN));\n                        }\n                    } else if (AppsmithDomain.class.isAssignableFrom(subFieldType)) {\n                       \n                        field.setAccessible(true);\n                        Object fieldValue = ReflectionUtils.getField(field, source);\n                        Map<?, ?> map = (Map<?, ?>) fieldValue;\n                        if (map == null || map.isEmpty()) {\n                            finalCandidateFields.add(new CandidateField(field, CandidateField.Type.APPSMITH_MAP_UNKNOWN));\n                        } else {\n                            for (Map.Entry<?, ?> entry : map.entrySet()) {\n                                final Object value = entry.getValue();\n                                if (value == null) {\n                                    continue;\n                                }\n                                if (value.getClass().getCanonicalName().equals(subFieldType.getTypeName())) {\n                                    final List<CandidateField> candidateFieldsForListMember = findCandidateFieldsForType(value);\n                                    if (candidateFieldsForListMember != null && !candidateFieldsForListMember.isEmpty()) {\n                                        finalCandidateFields.add(new CandidateField(field, CandidateField.Type.APPSMITH_MAP_KNOWN));\n                                    }\n                                } else {\n                                    finalCandidateFields.add(new CandidateField(field, CandidateField.Type.APPSMITH_MAP_POLYMORPHIC));\n                                }\n                                break;\n                            }\n                        }\n                        field.setAccessible(false);\n                    }\n                }\n            }, field -> field.getAnnotation(Encrypted.class) != null ||\n                    AppsmithDomain.class.isAssignableFrom(field.getType()) ||\n                    Collection.class.isAssignableFrom(field.getType()) ||\n                    Map.class.isAssignableFrom(field.getType()));\n        }\n       \n        encryptedFieldsMap.put(sourceClass, finalCandidateFields);\n        return finalCandidateFields;\n    }","cleancode":"list<candidatefield> findcandidatefieldsfortype(@nonnull object source) { class<?> sourceclass = source.getclass(); list<candidatefield> candidatefields = this.encryptedfieldsmap.get(sourceclass); if (candidatefields != null) { return candidatefields; } if (classutils.isprimitiveorwrapper(sourceclass)) return collections.emptylist(); list<candidatefield> finalcandidatefields = new arraylist<>(); synchronized (sourceclass) { reflectionutils.dowithfields(sourceclass, field -> { if (field.getannotation(encrypted.class) != null) { candidatefield candidatefield = new candidatefield(field, candidatefield.type.annotated_field); finalcandidatefields.add(candidatefield); } else if (appsmithdomain.class.isassignablefrom(field.gettype())) { candidatefield candidatefield = null; field.setaccessible(true); object fieldvalue = reflectionutils.getfield(field, source); if (fieldvalue == null) { if (this.encryptedfieldsmap.containskey(field.gettype())) { candidatefield = new candidatefield(field, candidatefield.type.appsmith_field_known); } else { candidatefield = new candidatefield(field, candidatefield.type.appsmith_field_unknown); } } else { candidatefield.type appsmithfieldtype; if (field.gettype().getcanonicalname().equals(fieldvalue.getclass().getcanonicalname())) { appsmithfieldtype = candidatefield.type.appsmith_field_known; } else { appsmithfieldtype = candidatefield.type.appsmith_field_polymorphic; } list<candidatefield> candidatefieldsfortype = findcandidatefieldsfortype(fieldvalue); if (appsmithfieldtype.equals(candidatefield.type.appsmith_field_polymorphic) || !candidatefieldsfortype.isempty()) { candidatefield = new candidatefield(field, appsmithfieldtype); } } field.setaccessible(false); if (candidatefield != null) { finalcandidatefields.add(candidatefield); } } else if (collection.class.isassignablefrom(field.gettype()) && field.getgenerictype() instanceof parameterizedtype) { type[] typearguments; parameterizedtype parameterizedtype = (parameterizedtype) field.getgenerictype(); typearguments = parameterizedtype.getactualtypearguments(); class<?> subfieldtype; try { subfieldtype = (class<?>) typearguments[0]; } catch (classcastexception|arrayindexoutofboundsexception e) { subfieldtype = null; } if(subfieldtype != null) { if (this.encryptedfieldsmap.containskey(subfieldtype)) { assert appsmithdomain.class.isassignablefrom(subfieldtype); final list<candidatefield> existingsubtypecandidates = this.encryptedfieldsmap.get(subfieldtype); if (!existingsubtypecandidates.isempty()) { finalcandidatefields.add(new candidatefield(field, candidatefield.type.appsmith_collection_known)); } } else if (appsmithdomain.class.isassignablefrom(subfieldtype)) { field.setaccessible(true); object fieldvalue = reflectionutils.getfield(field, source); collection<?> collection = (collection<?>) fieldvalue; if (collection == null || collection.isempty()) { finalcandidatefields.add(new candidatefield(field, candidatefield.type.appsmith_collection_unknown)); } else { for (final object o : collection) { if (o == null) { continue; } if (o.getclass().getcanonicalname().equals(subfieldtype.gettypename())) { final list<candidatefield> candidatefieldsforlistmember = findcandidatefieldsfortype(o); if (candidatefieldsforlistmember != null && !candidatefieldsforlistmember.isempty()) { finalcandidatefields.add(new candidatefield(field, candidatefield.type.appsmith_collection_known)); } } else { finalcandidatefields.add(new candidatefield(field, candidatefield.type.appsmith_collection_polymorphic)); } break; } } field.setaccessible(false); } } } else if (map.class.isassignablefrom(field.gettype()) && field.getgenerictype() instanceof parameterizedtype) { type[] typearguments; parameterizedtype parameterizedtype = (parameterizedtype) field.getgenerictype(); typearguments = parameterizedtype.getactualtypearguments(); class<?> subfieldtype = (class<?>) typearguments[1]; if (this.encryptedfieldsmap.containskey(subfieldtype)) { assert appsmithdomain.class.isassignablefrom(subfieldtype); final list<candidatefield> existingsubtypecandidates = this.encryptedfieldsmap.get(subfieldtype); if (!existingsubtypecandidates.isempty()) { finalcandidatefields.add(new candidatefield(field, candidatefield.type.appsmith_map_known)); } } else if (appsmithdomain.class.isassignablefrom(subfieldtype)) { field.setaccessible(true); object fieldvalue = reflectionutils.getfield(field, source); map<?, ?> map = (map<?, ?>) fieldvalue; if (map == null || map.isempty()) { finalcandidatefields.add(new candidatefield(field, candidatefield.type.appsmith_map_unknown)); } else { for (map.entry<?, ?> entry : map.entryset()) { final object value = entry.getvalue(); if (value == null) { continue; } if (value.getclass().getcanonicalname().equals(subfieldtype.gettypename())) { final list<candidatefield> candidatefieldsforlistmember = findcandidatefieldsfortype(value); if (candidatefieldsforlistmember != null && !candidatefieldsforlistmember.isempty()) { finalcandidatefields.add(new candidatefield(field, candidatefield.type.appsmith_map_known)); } } else { finalcandidatefields.add(new candidatefield(field, candidatefield.type.appsmith_map_polymorphic)); } break; } } field.setaccessible(false); } } }, field -> field.getannotation(encrypted.class) != null || appsmithdomain.class.isassignablefrom(field.gettype()) || collection.class.isassignablefrom(field.gettype()) || map.class.isassignablefrom(field.gettype())); } encryptedfieldsmap.put(sourceclass, finalcandidatefields); return finalcandidatefields; }","repo":"profencer\/appsmith","label":[0,1,0,0]}
{"id":1644,"original_code":"public static void setFirstDateAsDCT(SieveDocument doc) {\n    if (doc.getDocstamp() == null) {\n      for (Timex nextTimex : doc.getTimexes()) {\n        if (nextTimex.getType().equals(Timex.Type.DATE)) {\n          nextTimex.setDocumentFunction(DocumentFunction.CREATION_TIME);\n          doc.addCreationTime(nextTimex);\n          break;\n        }\n      }\n    }\n  }","code_wo_comment":"public static void setFirstDateAsDCT(SieveDocument doc) {\n    if (doc.getDocstamp() == null) {\n      for (Timex nextTimex : doc.getTimexes()) {\n        if (nextTimex.getType().equals(Timex.Type.DATE)) {\n          nextTimex.setDocumentFunction(DocumentFunction.CREATION_TIME);\n          doc.addCreationTime(nextTimex);\n          break;\n        }\n      }\n    }\n  }","cleancode":"public static void setfirstdateasdct(sievedocument doc) { if (doc.getdocstamp() == null) { for (timex nexttimex : doc.gettimexes()) { if (nexttimex.gettype().equals(timex.type.date)) { nexttimex.setdocumentfunction(documentfunction.creation_time); doc.addcreationtime(nexttimex); break; } } } }","repo":"nchambers\/caevo","label":[1,0,0,0]}
{"id":26251,"original_code":"public SetterType determineSetterType(String expression) {\n       \/\/ TODO: if (expression.contains(\"setb\")) return SetterType.BUILDER;\n       if(expression.contains(\"setf\"))\n           return SetterType.FIELD;\n       return SetterType.METHOD;\n    }","code_wo_comment":"public SetterType determineSetterType(String expression) {\n      \n       if(expression.contains(\"setf\"))\n           return SetterType.FIELD;\n       return SetterType.METHOD;\n    }","cleancode":"public settertype determinesettertype(string expression) { if(expression.contains(\"setf\")) return settertype.field; return settertype.method; }","repo":"nndi-oss\/intellij-just-sett","label":[0,1,0,0]}
{"id":1701,"original_code":"public static boolean isPasswordValid(String password) {\n        \/\/TODO: Replace this with your own logic\n        return password.length() > 4;\n    }","code_wo_comment":"public static boolean isPasswordValid(String password) {\n       \n        return password.length() > 4;\n    }","cleancode":"public static boolean ispasswordvalid(string password) { return password.length() > 4; }","repo":"neiplz\/Pedometer","label":[1,0,0,0]}
{"id":26305,"original_code":"private void updateRule() {\n        Recur.Builder<LocalDate> rBuilder = new Recur.Builder<>();\n        switch (frequencyBox.getValue()) {\n            case DAILY:\n                rBuilder.frequency(net.fortuna.ical4j.model.Recur.Frequency.DAILY);\n                break;\n            case MONTHLY:\n                rBuilder.frequency(net.fortuna.ical4j.model.Recur.Frequency.MONTHLY);\n                break;\n            case WEEKLY:\n                rBuilder.frequency(net.fortuna.ical4j.model.Recur.Frequency.WEEKLY);\n                break;\n            case YEARLY:\n                rBuilder.frequency(net.fortuna.ical4j.model.Recur.Frequency.YEARLY);\n                break;\n            default:\n                break;\n        }\n        int interval = repeatCountSpinner.getValue();\n        if (interval > 1) {\n            rBuilder.interval(interval);\n        } else {\n            rBuilder.interval(0);\n        }\n        if (endsOnButton.isSelected()) {\n            LocalDate date = endsOnDatePicker.getValue();\n            rBuilder.until(date);\n        }\n        if (endsAfterButton.isSelected()) {\n            rBuilder.count(endsAfterCounterSpinner.getValue());\n        }\n        if (frequencyBox.getValue() == Frequency.MONTHLY) {\n            if (repeatByDayOfTheMonth.isSelected()) {\n                int value = getSkinnable().getStartDate().getDayOfMonth();\n                rBuilder.monthList(new NumberList(value, value, false));\n            } else {\n                LocalDate localDate = getSkinnable().getStartDate();\n                \/\/ TODO: use zone id of context (entry, calendar)\n                ZonedDateTime zonedDateTime = ZonedDateTime.of(localDate,\n                        LocalTime.now(), ZoneId.systemDefault());\n                int hits = 1;\n                ZonedDateTime current = zonedDateTime.withDayOfMonth(1);\n                do {\n                    if (current.getDayOfWeek()\n                            .equals(zonedDateTime.getDayOfWeek())) {\n                        hits++;\n                    }\n                    current = current.plusDays(1);\n                } while (current.toLocalDate().isBefore(localDate));\n                WeekDayList weekdays = new WeekDayList();\n                switch (zonedDateTime.getDayOfWeek()) {\n                    case FRIDAY:\n                        weekdays.add(new WeekDay(WeekDay.FR, hits));\n                        break;\n                    case MONDAY:\n                        weekdays.add(new WeekDay(WeekDay.MO, hits));\n                        break;\n                    case SATURDAY:\n                        weekdays.add(new WeekDay(WeekDay.SA, hits));\n                        break;\n                    case SUNDAY:\n                        weekdays.add(new WeekDay(WeekDay.SU, hits));\n                        break;\n                    case THURSDAY:\n                        weekdays.add(new WeekDay(WeekDay.TH, hits));\n                        break;\n                    case TUESDAY:\n                        weekdays.add(new WeekDay(WeekDay.TU, hits));\n                        break;\n                    case WEDNESDAY:\n                        weekdays.add(new WeekDay(WeekDay.WE, hits));\n                        break;\n                    default:\n                        break;\n                }\n                rBuilder.dayList(weekdays);\n            }\n        }\n        if (frequencyBox.getValue() == Frequency.WEEKLY) {\n            \/*\n             * Weekdays MO, TU, .... SU\n             *\/\n            WeekDayList weekdays = new WeekDayList();\n            maybeAddWeekday(weekdays, WeekDay.MO,\n                    weekDayMondayButton);\n            maybeAddWeekday(weekdays, WeekDay.TU,\n                    weekDayTuesdayButton);\n            maybeAddWeekday(weekdays, WeekDay.WE,\n                    weekDayWednesdayButton);\n            maybeAddWeekday(weekdays, WeekDay.TH,\n                    weekDayThursdayButton);\n            maybeAddWeekday(weekdays, WeekDay.FR,\n                    weekDayFridayButton);\n            maybeAddWeekday(weekdays, WeekDay.SA,\n                    weekDaySaturdayButton);\n            maybeAddWeekday(weekdays, WeekDay.SU,\n                    weekDaySundayButton);\n            rBuilder.dayList(weekdays);\n        }\n        Recur<LocalDate> rule = rBuilder.build();\n        getSkinnable().setRecurrenceRule(rule.toString());\n        if (LoggingDomain.RECURRENCE.isLoggable(Level.FINE)) {\n            LoggingDomain.RECURRENCE.fine(\n                    \"test dumping 10 recurrences starting with today's date\");\n            LocalDate today = LocalDate.of(2015, 8, 18);\n            List<LocalDate> dates = rule.getDates(today, today, LocalDate.MAX, 10);\n            for (LocalDate repeatingDate : dates) {\n                LoggingDomain.RECURRENCE.fine(repeatingDate.toString());\n            }\n        }\n    }","code_wo_comment":"private void updateRule() {\n        Recur.Builder<LocalDate> rBuilder = new Recur.Builder<>();\n        switch (frequencyBox.getValue()) {\n            case DAILY:\n                rBuilder.frequency(net.fortuna.ical4j.model.Recur.Frequency.DAILY);\n                break;\n            case MONTHLY:\n                rBuilder.frequency(net.fortuna.ical4j.model.Recur.Frequency.MONTHLY);\n                break;\n            case WEEKLY:\n                rBuilder.frequency(net.fortuna.ical4j.model.Recur.Frequency.WEEKLY);\n                break;\n            case YEARLY:\n                rBuilder.frequency(net.fortuna.ical4j.model.Recur.Frequency.YEARLY);\n                break;\n            default:\n                break;\n        }\n        int interval = repeatCountSpinner.getValue();\n        if (interval > 1) {\n            rBuilder.interval(interval);\n        } else {\n            rBuilder.interval(0);\n        }\n        if (endsOnButton.isSelected()) {\n            LocalDate date = endsOnDatePicker.getValue();\n            rBuilder.until(date);\n        }\n        if (endsAfterButton.isSelected()) {\n            rBuilder.count(endsAfterCounterSpinner.getValue());\n        }\n        if (frequencyBox.getValue() == Frequency.MONTHLY) {\n            if (repeatByDayOfTheMonth.isSelected()) {\n                int value = getSkinnable().getStartDate().getDayOfMonth();\n                rBuilder.monthList(new NumberList(value, value, false));\n            } else {\n                LocalDate localDate = getSkinnable().getStartDate();\n               \n                ZonedDateTime zonedDateTime = ZonedDateTime.of(localDate,\n                        LocalTime.now(), ZoneId.systemDefault());\n                int hits = 1;\n                ZonedDateTime current = zonedDateTime.withDayOfMonth(1);\n                do {\n                    if (current.getDayOfWeek()\n                            .equals(zonedDateTime.getDayOfWeek())) {\n                        hits++;\n                    }\n                    current = current.plusDays(1);\n                } while (current.toLocalDate().isBefore(localDate));\n                WeekDayList weekdays = new WeekDayList();\n                switch (zonedDateTime.getDayOfWeek()) {\n                    case FRIDAY:\n                        weekdays.add(new WeekDay(WeekDay.FR, hits));\n                        break;\n                    case MONDAY:\n                        weekdays.add(new WeekDay(WeekDay.MO, hits));\n                        break;\n                    case SATURDAY:\n                        weekdays.add(new WeekDay(WeekDay.SA, hits));\n                        break;\n                    case SUNDAY:\n                        weekdays.add(new WeekDay(WeekDay.SU, hits));\n                        break;\n                    case THURSDAY:\n                        weekdays.add(new WeekDay(WeekDay.TH, hits));\n                        break;\n                    case TUESDAY:\n                        weekdays.add(new WeekDay(WeekDay.TU, hits));\n                        break;\n                    case WEDNESDAY:\n                        weekdays.add(new WeekDay(WeekDay.WE, hits));\n                        break;\n                    default:\n                        break;\n                }\n                rBuilder.dayList(weekdays);\n            }\n        }\n        if (frequencyBox.getValue() == Frequency.WEEKLY) {\n           \n            WeekDayList weekdays = new WeekDayList();\n            maybeAddWeekday(weekdays, WeekDay.MO,\n                    weekDayMondayButton);\n            maybeAddWeekday(weekdays, WeekDay.TU,\n                    weekDayTuesdayButton);\n            maybeAddWeekday(weekdays, WeekDay.WE,\n                    weekDayWednesdayButton);\n            maybeAddWeekday(weekdays, WeekDay.TH,\n                    weekDayThursdayButton);\n            maybeAddWeekday(weekdays, WeekDay.FR,\n                    weekDayFridayButton);\n            maybeAddWeekday(weekdays, WeekDay.SA,\n                    weekDaySaturdayButton);\n            maybeAddWeekday(weekdays, WeekDay.SU,\n                    weekDaySundayButton);\n            rBuilder.dayList(weekdays);\n        }\n        Recur<LocalDate> rule = rBuilder.build();\n        getSkinnable().setRecurrenceRule(rule.toString());\n        if (LoggingDomain.RECURRENCE.isLoggable(Level.FINE)) {\n            LoggingDomain.RECURRENCE.fine(\n                    \"test dumping 10 recurrences starting with today's date\");\n            LocalDate today = LocalDate.of(2015, 8, 18);\n            List<LocalDate> dates = rule.getDates(today, today, LocalDate.MAX, 10);\n            for (LocalDate repeatingDate : dates) {\n                LoggingDomain.RECURRENCE.fine(repeatingDate.toString());\n            }\n        }\n    }","cleancode":"private void updaterule() { recur.builder<localdate> rbuilder = new recur.builder<>(); switch (frequencybox.getvalue()) { case daily: rbuilder.frequency(net.fortuna.ical4j.model.recur.frequency.daily); break; case monthly: rbuilder.frequency(net.fortuna.ical4j.model.recur.frequency.monthly); break; case weekly: rbuilder.frequency(net.fortuna.ical4j.model.recur.frequency.weekly); break; case yearly: rbuilder.frequency(net.fortuna.ical4j.model.recur.frequency.yearly); break; default: break; } int interval = repeatcountspinner.getvalue(); if (interval > 1) { rbuilder.interval(interval); } else { rbuilder.interval(0); } if (endsonbutton.isselected()) { localdate date = endsondatepicker.getvalue(); rbuilder.until(date); } if (endsafterbutton.isselected()) { rbuilder.count(endsaftercounterspinner.getvalue()); } if (frequencybox.getvalue() == frequency.monthly) { if (repeatbydayofthemonth.isselected()) { int value = getskinnable().getstartdate().getdayofmonth(); rbuilder.monthlist(new numberlist(value, value, false)); } else { localdate localdate = getskinnable().getstartdate(); zoneddatetime zoneddatetime = zoneddatetime.of(localdate, localtime.now(), zoneid.systemdefault()); int hits = 1; zoneddatetime current = zoneddatetime.withdayofmonth(1); do { if (current.getdayofweek() .equals(zoneddatetime.getdayofweek())) { hits++; } current = current.plusdays(1); } while (current.tolocaldate().isbefore(localdate)); weekdaylist weekdays = new weekdaylist(); switch (zoneddatetime.getdayofweek()) { case friday: weekdays.add(new weekday(weekday.fr, hits)); break; case monday: weekdays.add(new weekday(weekday.mo, hits)); break; case saturday: weekdays.add(new weekday(weekday.sa, hits)); break; case sunday: weekdays.add(new weekday(weekday.su, hits)); break; case thursday: weekdays.add(new weekday(weekday.th, hits)); break; case tuesday: weekdays.add(new weekday(weekday.tu, hits)); break; case wednesday: weekdays.add(new weekday(weekday.we, hits)); break; default: break; } rbuilder.daylist(weekdays); } } if (frequencybox.getvalue() == frequency.weekly) { weekdaylist weekdays = new weekdaylist(); maybeaddweekday(weekdays, weekday.mo, weekdaymondaybutton); maybeaddweekday(weekdays, weekday.tu, weekdaytuesdaybutton); maybeaddweekday(weekdays, weekday.we, weekdaywednesdaybutton); maybeaddweekday(weekdays, weekday.th, weekdaythursdaybutton); maybeaddweekday(weekdays, weekday.fr, weekdayfridaybutton); maybeaddweekday(weekdays, weekday.sa, weekdaysaturdaybutton); maybeaddweekday(weekdays, weekday.su, weekdaysundaybutton); rbuilder.daylist(weekdays); } recur<localdate> rule = rbuilder.build(); getskinnable().setrecurrencerule(rule.tostring()); if (loggingdomain.recurrence.isloggable(level.fine)) { loggingdomain.recurrence.fine( \"test dumping 10 recurrences starting with today's date\"); localdate today = localdate.of(2015, 8, 18); list<localdate> dates = rule.getdates(today, today, localdate.max, 10); for (localdate repeatingdate : dates) { loggingdomain.recurrence.fine(repeatingdate.tostring()); } } }","repo":"mwkroening\/CalendarFX","label":[0,1,0,0]}
{"id":18334,"original_code":"private boolean checkDoorIsSealed(World world, BlockPosition pos, int meta)\n    {\n        \/\/TODO: door corners\n        return ((meta & 8) == 8\n                ||\n                ((meta & 4) >> 2 == (meta & 1) && checkDoorSeal(world, pos.getPositionAtOffset(0, 0, 1), meta)\n                        && checkDoorSeal(world, pos.getPositionAtOffset(0, 0, -1), meta))\n                ||\n                (meta & 4) >> 2 != (meta & 1) && checkDoorSeal(world, pos.getPositionAtOffset(1, 0, 0), meta)\n                        && checkDoorSeal(world, pos.getPositionAtOffset(-1, 0, 0), meta));\n    }","code_wo_comment":"private boolean checkDoorIsSealed(World world, BlockPosition pos, int meta)\n    {\n       \n        return ((meta & 8) == 8\n                ||\n                ((meta & 4) >> 2 == (meta & 1) && checkDoorSeal(world, pos.getPositionAtOffset(0, 0, 1), meta)\n                        && checkDoorSeal(world, pos.getPositionAtOffset(0, 0, -1), meta))\n                ||\n                (meta & 4) >> 2 != (meta & 1) && checkDoorSeal(world, pos.getPositionAtOffset(1, 0, 0), meta)\n                        && checkDoorSeal(world, pos.getPositionAtOffset(-1, 0, 0), meta));\n    }","cleancode":"private boolean checkdoorissealed(world world, blockposition pos, int meta) { return ((meta & 8) == 8 || ((meta & 4) >> 2 == (meta & 1) && checkdoorseal(world, pos.getpositionatoffset(0, 0, 1), meta) && checkdoorseal(world, pos.getpositionatoffset(0, 0, -1), meta)) || (meta & 4) >> 2 != (meta & 1) && checkdoorseal(world, pos.getpositionatoffset(1, 0, 0), meta) && checkdoorseal(world, pos.getpositionatoffset(-1, 0, 0), meta)); }","repo":"phit\/AdvancedRocketry","label":[1,0,0,0]}
{"id":18335,"original_code":"private boolean checkDoorSeal(World world, BlockPosition pos, int meta)\n    {\n        Block otherBlock = world.getBlock(pos.x, pos.y, pos.z);\n        int otherMeta = world.getBlockMetadata(pos.x, pos.y, pos.z);\n        return (otherBlock == AdvancedRocketryBlocks.blockAirLock && (otherMeta & 1) == (meta & 1)) ||\n                (otherBlock != AdvancedRocketryBlocks.blockAirLock && isBlockSealed(world, pos));\n    }","code_wo_comment":"private boolean checkDoorSeal(World world, BlockPosition pos, int meta)\n    {\n        Block otherBlock = world.getBlock(pos.x, pos.y, pos.z);\n        int otherMeta = world.getBlockMetadata(pos.x, pos.y, pos.z);\n        return (otherBlock == AdvancedRocketryBlocks.blockAirLock && (otherMeta & 1) == (meta & 1)) ||\n                (otherBlock != AdvancedRocketryBlocks.blockAirLock && isBlockSealed(world, pos));\n    }","cleancode":"private boolean checkdoorseal(world world, blockposition pos, int meta) { block otherblock = world.getblock(pos.x, pos.y, pos.z); int othermeta = world.getblockmetadata(pos.x, pos.y, pos.z); return (otherblock == advancedrocketryblocks.blockairlock && (othermeta & 1) == (meta & 1)) || (otherblock != advancedrocketryblocks.blockairlock && isblocksealed(world, pos)); }","repo":"phit\/AdvancedRocketry","label":[0,0,0,0]}
{"id":34826,"original_code":"@Test(enabled=false)\n    public void testGetFutureConfigWhenReady() throws Exception {\n        MyPolicy policy = new MyPolicy(MutableMap.builder()\n                .put(TestEntity.CONF_NAME, DependentConfiguration.whenDone(Callables.returning(\"aval\")))\n                .build());\n        app.policies().add(policy);\n        assertEquals(policy.getConfig(TestEntity.CONF_NAME), \"aval\");\n    }","code_wo_comment":"@Test(enabled=false)\n    public void testGetFutureConfigWhenReady() throws Exception {\n        MyPolicy policy = new MyPolicy(MutableMap.builder()\n                .put(TestEntity.CONF_NAME, DependentConfiguration.whenDone(Callables.returning(\"aval\")))\n                .build());\n        app.policies().add(policy);\n        assertEquals(policy.getConfig(TestEntity.CONF_NAME), \"aval\");\n    }","cleancode":"@test(enabled=false) public void testgetfutureconfigwhenready() throws exception { mypolicy policy = new mypolicy(mutablemap.builder() .put(testentity.conf_name, dependentconfiguration.whendone(callables.returning(\"aval\"))) .build()); app.policies().add(policy); assertequals(policy.getconfig(testentity.conf_name), \"aval\"); }","repo":"nakomis\/incubator-brooklyn","label":[1,0,0,0]}
{"id":34827,"original_code":"@Test(enabled=false)\n    public void testGetFutureConfigBlocksUntilReady() throws Exception {\n        final CountDownLatch latch = new CountDownLatch(1);\n        MyPolicy policy = new MyPolicy(MutableMap.builder()\n                .put(TestEntity.CONF_NAME, DependentConfiguration.whenDone(new Callable<String>() {\n                        public String call() {\n                            try {\n                                latch.await(); return \"aval\";\n                            } catch (InterruptedException e) {\n                                throw Exceptions.propagate(e);\n                            }\n                        }}))\n                .build());\n        app.policies().add(policy);\n        Thread t = new Thread(new Runnable() {\n                public void run() {\n                    try {\n                        Thread.sleep(10+EARLY_RETURN_GRACE); latch.countDown();\n                    } catch (InterruptedException e) {\n                        throw Exceptions.propagate(e);\n                    }\n                }});\n        try {\n            long starttime = System.currentTimeMillis();\n            t.start();\n            assertEquals(policy.getConfig(TestEntity.CONF_NAME), \"aval\");\n            long endtime = System.currentTimeMillis();\n            assertTrue((endtime - starttime) >= 10, \"starttime=\"+starttime+\"; endtime=\"+endtime);\n        } finally {\n            t.interrupt();\n        }\n    }","code_wo_comment":"@Test(enabled=false)\n    public void testGetFutureConfigBlocksUntilReady() throws Exception {\n        final CountDownLatch latch = new CountDownLatch(1);\n        MyPolicy policy = new MyPolicy(MutableMap.builder()\n                .put(TestEntity.CONF_NAME, DependentConfiguration.whenDone(new Callable<String>() {\n                        public String call() {\n                            try {\n                                latch.await(); return \"aval\";\n                            } catch (InterruptedException e) {\n                                throw Exceptions.propagate(e);\n                            }\n                        }}))\n                .build());\n        app.policies().add(policy);\n        Thread t = new Thread(new Runnable() {\n                public void run() {\n                    try {\n                        Thread.sleep(10+EARLY_RETURN_GRACE); latch.countDown();\n                    } catch (InterruptedException e) {\n                        throw Exceptions.propagate(e);\n                    }\n                }});\n        try {\n            long starttime = System.currentTimeMillis();\n            t.start();\n            assertEquals(policy.getConfig(TestEntity.CONF_NAME), \"aval\");\n            long endtime = System.currentTimeMillis();\n            assertTrue((endtime - starttime) >= 10, \"starttime=\"+starttime+\"; endtime=\"+endtime);\n        } finally {\n            t.interrupt();\n        }\n    }","cleancode":"@test(enabled=false) public void testgetfutureconfigblocksuntilready() throws exception { final countdownlatch latch = new countdownlatch(1); mypolicy policy = new mypolicy(mutablemap.builder() .put(testentity.conf_name, dependentconfiguration.whendone(new callable<string>() { public string call() { try { latch.await(); return \"aval\"; } catch (interruptedexception e) { throw exceptions.propagate(e); } }})) .build()); app.policies().add(policy); thread t = new thread(new runnable() { public void run() { try { thread.sleep(10+early_return_grace); latch.countdown(); } catch (interruptedexception e) { throw exceptions.propagate(e); } }}); try { long starttime = system.currenttimemillis(); t.start(); assertequals(policy.getconfig(testentity.conf_name), \"aval\"); long endtime = system.currenttimemillis(); asserttrue((endtime - starttime) >= 10, \"starttime=\"+starttime+\"; endtime=\"+endtime); } finally { t.interrupt(); } }","repo":"nakomis\/incubator-brooklyn","label":[1,0,0,0]}
{"id":18502,"original_code":"public void testUpdate() {\n        \/\/ Note: painting code, cannot test\n    }","code_wo_comment":"public void testUpdate() {\n       \n    }","cleancode":"public void testupdate() { }","repo":"qinFamily\/freeVM","label":[0,0,0,1]}
{"id":18503,"original_code":"public void testPaint() {\n        \/\/ Note: painting code, cannot test\n    }","code_wo_comment":"public void testPaint() {\n       \n    }","cleancode":"public void testpaint() { }","repo":"qinFamily\/freeVM","label":[0,0,0,1]}
{"id":18504,"original_code":"public void testPaintContentBorderBottomEdge() {\n        \/\/ Note: painting code, cannot test\n    }","code_wo_comment":"public void testPaintContentBorderBottomEdge() {\n       \n    }","cleancode":"public void testpaintcontentborderbottomedge() { }","repo":"qinFamily\/freeVM","label":[0,0,0,1]}
{"id":18505,"original_code":"public void testPaintContentBorderLeftEdge() {\n        \/\/ Note: painting code, cannot test\n    }","code_wo_comment":"public void testPaintContentBorderLeftEdge() {\n       \n    }","cleancode":"public void testpaintcontentborderleftedge() { }","repo":"qinFamily\/freeVM","label":[0,0,0,1]}
{"id":18506,"original_code":"public void testPaintContentBorderRightEdge() {\n        \/\/ Note: painting code, cannot test\n    }","code_wo_comment":"public void testPaintContentBorderRightEdge() {\n       \n    }","cleancode":"public void testpaintcontentborderrightedge() { }","repo":"qinFamily\/freeVM","label":[0,0,0,1]}
{"id":18507,"original_code":"public void testPaintContentBorderTopEdge() {\n        \/\/ Note: painting code, cannot test\n    }","code_wo_comment":"public void testPaintContentBorderTopEdge() {\n       \n    }","cleancode":"public void testpaintcontentbordertopedge() { }","repo":"qinFamily\/freeVM","label":[0,0,0,1]}
{"id":18508,"original_code":"public void testPaintFocusIndicator() {\n        \/\/ Note: painting code, cannot test\n    }","code_wo_comment":"public void testPaintFocusIndicator() {\n       \n    }","cleancode":"public void testpaintfocusindicator() { }","repo":"qinFamily\/freeVM","label":[0,0,0,1]}
{"id":18509,"original_code":"public void testPaintTabBackground() {\n        \/\/ Note: painting code, cannot test\n    }","code_wo_comment":"public void testPaintTabBackground() {\n       \n    }","cleancode":"public void testpainttabbackground() { }","repo":"qinFamily\/freeVM","label":[0,0,0,1]}
{"id":18510,"original_code":"public void testPaintTabBorder() {\n        \/\/ Note: painting code, cannot test\n    }","code_wo_comment":"public void testPaintTabBorder() {\n       \n    }","cleancode":"public void testpainttabborder() { }","repo":"qinFamily\/freeVM","label":[0,0,0,1]}
{"id":18511,"original_code":"public void testPaintHighlightBelowTab() {\n        \/\/ Note: painting code, cannot test\n    }","code_wo_comment":"public void testPaintHighlightBelowTab() {\n       \n    }","cleancode":"public void testpainthighlightbelowtab() { }","repo":"qinFamily\/freeVM","label":[0,0,0,1]}
{"id":18512,"original_code":"public void testPaintBottomTabBorder() {\n        \/\/ Note: painting code, cannot test\n    }","code_wo_comment":"public void testPaintBottomTabBorder() {\n       \n    }","cleancode":"public void testpaintbottomtabborder() { }","repo":"qinFamily\/freeVM","label":[0,0,0,1]}
{"id":18513,"original_code":"public void testPaintLeftTabBorder() {\n        \/\/ Note: painting code, cannot test\n    }","code_wo_comment":"public void testPaintLeftTabBorder() {\n       \n    }","cleancode":"public void testpaintlefttabborder() { }","repo":"qinFamily\/freeVM","label":[0,0,0,1]}
{"id":18514,"original_code":"public void testPaintRightTabBorder() {\n        \/\/ Note: painting code, cannot test\n    }","code_wo_comment":"public void testPaintRightTabBorder() {\n       \n    }","cleancode":"public void testpaintrighttabborder() { }","repo":"qinFamily\/freeVM","label":[0,0,0,1]}
{"id":18515,"original_code":"public void testPaintTopTabBorder() {\n        \/\/ Note: painting code, cannot test\n    }","code_wo_comment":"public void testPaintTopTabBorder() {\n       \n    }","cleancode":"public void testpainttoptabborder() { }","repo":"qinFamily\/freeVM","label":[0,0,0,1]}
{"id":18636,"original_code":"@Override\n    public Set<JavaPlatform> instantiate() throws IOException {\n        \/\/TODO: Download (in background?)\n        String downloadedFolder = (String) wizard.getProperty(DiscoPlatformIt.PROP_DOWNLOAD);\n        if (downloadedFolder != null) {\n            File f = new File(downloadedFolder);\n            if (!f.isDirectory()) {\n                \/\/open the file manager for the parent folder\n                Desktop.getDesktop().open(f.getParentFile());\n                return Collections.EMPTY_SET;\n            }\n            String name = state.selection.getJavaPlatformDisplayName();\n            return Collections.singleton(J2SEPlatformUtils.register(new File(downloadedFolder), name));\n        } else {\n            \/\/TODO: notifcation?\n            return Collections.EMPTY_SET;\n        }\n    }","code_wo_comment":"@Override\n    public Set<JavaPlatform> instantiate() throws IOException {\n       \n        String downloadedFolder = (String) wizard.getProperty(DiscoPlatformIt.PROP_DOWNLOAD);\n        if (downloadedFolder != null) {\n            File f = new File(downloadedFolder);\n            if (!f.isDirectory()) {\n               \n                Desktop.getDesktop().open(f.getParentFile());\n                return Collections.EMPTY_SET;\n            }\n            String name = state.selection.getJavaPlatformDisplayName();\n            return Collections.singleton(J2SEPlatformUtils.register(new File(downloadedFolder), name));\n        } else {\n           \n            return Collections.EMPTY_SET;\n        }\n    }","cleancode":"@override public set<javaplatform> instantiate() throws ioexception { string downloadedfolder = (string) wizard.getproperty(discoplatformit.prop_download); if (downloadedfolder != null) { file f = new file(downloadedfolder); if (!f.isdirectory()) { desktop.getdesktop().open(f.getparentfile()); return collections.empty_set; } string name = state.selection.getjavaplatformdisplayname(); return collections.singleton(j2seplatformutils.register(new file(downloadedfolder), name)); } else { return collections.empty_set; } }","repo":"oyarzun\/incubator-netbeans","label":[1,1,0,0]}
{"id":2277,"original_code":"@SuppressWarnings(\"unused\")\n\tprivate void receive() {\n\t\t\/\/ TODO 7: [Optional] Fill with your own implementation for handling\n\t\t\/\/ asynchronous data from the driver layer to the device service\n\t\tModbusDevice device = null;\n\t\tString result = \"\";\n\t\tResourceOperation operation = null;\n\t\tobjectCache.putReadings(device, operation, result);\n\t}","code_wo_comment":"@SuppressWarnings(\"unused\")\n\tprivate void receive() {\n\t\n\t\n\t\tModbusDevice device = null;\n\t\tString result = \"\";\n\t\tResourceOperation operation = null;\n\t\tobjectCache.putReadings(device, operation, result);\n\t}","cleancode":"@suppresswarnings(\"unused\") private void receive() { modbusdevice device = null; string result = \"\"; resourceoperation operation = null; objectcache.putreadings(device, operation, result); }","repo":"pk-80\/device-modbus","label":[0,1,0,0]}
{"id":18772,"original_code":"private void initState(){\n        \/\/TODO Switch s and w\n        this.s = BigDecimal.ONE; \/\/new BigDecimal(this.cloudsNum); \/\/ @todo ERRO? (x = BigDecimal.ONE)\n        this.w = super.getInitValue();\n        \/\/Clear message received buffer\n        this.msgRcvBuffer = new HashMap<String, Message<?>>();\n    }","code_wo_comment":"private void initState(){\n       \n        this.s = BigDecimal.ONE;\n        this.w = super.getInitValue();\n       \n        this.msgRcvBuffer = new HashMap<String, Message<?>>();\n    }","cleancode":"private void initstate(){ this.s = bigdecimal.one; this.w = super.getinitvalue(); this.msgrcvbuffer = new hashmap<string, message<?>>(); }","repo":"pcjesus\/NetworkSimulator","label":[1,1,0,0]}
{"id":10767,"original_code":"@Override\n\tpublic void shutdown() throws Exception {\n\t\tsynchronized (shutDownLock) {\n\t\t\t\/\/ This is problematic as the user code class loader is not\n\t\t\t\/\/ available at this point.\n\t\t\tfor (Savepoint savepoint : savepoints.values()) {\n\t\t\t\ttry {\n\t\t\t\t\tsavepoint.dispose();\n\t\t\t\t} catch (Throwable t) {\n\t\t\t\t\tLOG.warn(\"Failed to dispose savepoint \" + savepoint.getCheckpointId(), t);\n\t\t\t\t}\n\t\t\t}\n\t\t\tsavepoints.clear();\n\t\t\t\/\/ Remove shutdown hook to prevent resource leaks, unless this is\n\t\t\t\/\/ invoked by the shutdown hook itself.\n\t\t\tif (shutdownHook != null && shutdownHook != Thread.currentThread()) {\n\t\t\t\ttry {\n\t\t\t\t\tRuntime.getRuntime().removeShutdownHook(shutdownHook);\n\t\t\t\t} catch (IllegalStateException ignored) {\n\t\t\t\t\t\/\/ Race, JVM is in shutdown already, we can safely ignore this\n\t\t\t\t} catch (Throwable t) {\n\t\t\t\t\tLOG.warn(\"Failed to unregister shut down hook.\");\n\t\t\t\t}\n\t\t\t}\n\t\t\tshutDown = true;\n\t\t}\n\t}","code_wo_comment":"@Override\n\tpublic void shutdown() throws Exception {\n\t\tsynchronized (shutDownLock) {\n\t\t\n\t\t\n\t\t\tfor (Savepoint savepoint : savepoints.values()) {\n\t\t\t\ttry {\n\t\t\t\t\tsavepoint.dispose();\n\t\t\t\t} catch (Throwable t) {\n\t\t\t\t\tLOG.warn(\"Failed to dispose savepoint \" + savepoint.getCheckpointId(), t);\n\t\t\t\t}\n\t\t\t}\n\t\t\tsavepoints.clear();\n\t\t\n\t\t\n\t\t\tif (shutdownHook != null && shutdownHook != Thread.currentThread()) {\n\t\t\t\ttry {\n\t\t\t\t\tRuntime.getRuntime().removeShutdownHook(shutdownHook);\n\t\t\t\t} catch (IllegalStateException ignored) {\n\t\t\t\t\n\t\t\t\t} catch (Throwable t) {\n\t\t\t\t\tLOG.warn(\"Failed to unregister shut down hook.\");\n\t\t\t\t}\n\t\t\t}\n\t\t\tshutDown = true;\n\t\t}\n\t}","cleancode":"@override public void shutdown() throws exception { synchronized (shutdownlock) { for (savepoint savepoint : savepoints.values()) { try { savepoint.dispose(); } catch (throwable t) { log.warn(\"failed to dispose savepoint \" + savepoint.getcheckpointid(), t); } } savepoints.clear(); if (shutdownhook != null && shutdownhook != thread.currentthread()) { try { runtime.getruntime().removeshutdownhook(shutdownhook); } catch (illegalstateexception ignored) { } catch (throwable t) { log.warn(\"failed to unregister shut down hook.\"); } } shutdown = true; } }","repo":"qingdao81\/flink","label":[0,0,1,0]}
{"id":2671,"original_code":"public void beginStep() {\n        \/\/ TODO: probably, we don't need to synchronize data here,\n        \/\/ because this method is always called from the same thread\n        \/\/ Synchronize all cached data\n        synchronized (readData) {\n            synchronized (writeData) {\n                super.beginStep();\n            }\n        }\n    }","code_wo_comment":"public void beginStep() {\n       \n       \n       \n        synchronized (readData) {\n            synchronized (writeData) {\n                super.beginStep();\n            }\n        }\n    }","cleancode":"public void beginstep() { synchronized (readdata) { synchronized (writedata) { super.beginstep(); } } }","repo":"monadius\/spark-abm","label":[1,0,0,0]}
{"id":2740,"original_code":"public static String jsDtobasestr(int base, double dParam) {\n        if (!(2 <= base && base <= 36)) {\n            throw new IllegalArgumentException(\"Bad base: \" + base);\n        }\n        double d = dParam;\n        \/* Check for Infinity and NaN *\/\n        if (Double.isNaN(d)) {\n            return \"NaN\";\n        } else if (Double.isInfinite(d)) {\n            return (d > 0.0) ? \"Infinity\" : \"-Infinity\";\n        } else if (d == 0) {\n            \/\/ ALERT: should it distinguish -0.0 from +0.0 ?\n            return \"0\";\n        }\n        boolean negative;\n        if (d >= 0.0) {\n            negative = false;\n        } else {\n            negative = true;\n            d = -d;\n        }\n        \/* Get the integer part of d including '-' sign. *\/\n        String intDigits;\n        double dfloor = Math.floor(d);\n        long lfloor = (long) dfloor;\n        if (lfloor == dfloor) {\n            \/\/ int part fits long\n            if (lfloor == 0 && negative) {\n                intDigits = \"-0\"; \/\/ CWirth fix\n            } else {\n                intDigits = Long.toString((negative) ? -lfloor : lfloor, base);\n            }\n        } else {\n            \/\/ BigInteger should be used\n            long floorBits = Double.doubleToLongBits(dfloor);\n            int exp = (int) (floorBits >> Exp_shiftL) & Exp_mask_shifted;\n            long mantissa;\n            if (exp == 0) {\n                mantissa = (floorBits & Frac_maskL) << 1;\n            } else {\n                mantissa = (floorBits & Frac_maskL) | Exp_msk1L;\n            }\n            if (negative) {\n                mantissa = -mantissa;\n            }\n            exp -= 1075;\n            BigInteger x = BigInteger.valueOf(mantissa);\n            if (exp > 0) {\n                x = x.shiftLeft(exp);\n            } else if (exp < 0) {\n                x = x.shiftRight(-exp);\n            }\n            intDigits = x.toString(base);\n        }\n        if (d == dfloor) {\n            \/\/ No fraction part\n            return intDigits;\n        } else {\n            \/* We have a fraction. *\/\n            StringBuilder buffer; \/* The output string *\/\n            int digit;\n            double df; \/* The fractional part of d *\/\n            BigInteger b;\n            buffer = new StringBuilder();\n            buffer.append(intDigits).append('.');\n            df = d - dfloor;\n            long dBits = Double.doubleToLongBits(d);\n            int word0 = (int) (dBits >> 32);\n            int word1 = (int) (dBits);\n            int[] e = new int[1];\n            int[] bbits = new int[1];\n            b = d2b(df, e, bbits);\n            \/* At this point df = b * 2^e. e must be less than zero because 0 < df < 1. *\/\n            int s2 = -(word0 >>> Exp_shift1 & Exp_mask >> Exp_shift1);\n            if (s2 == 0) {\n                s2 = -1;\n            }\n            s2 += Bias + P;\n            \/* 1\/2^s2 = (nextDouble(d) - d)\/2 *\/\n            BigInteger mlo = BigInteger.ONE;\n            BigInteger mhi = mlo;\n            if ((word1 == 0) && ((word0 & Bndry_mask) == 0) && ((word0 & (Exp_mask & Exp_mask << 1)) != 0)) {\n                \/*\n                 * The special case. Here we want to be within a quarter of the last input\n                 * significant digit instead of one half of it when the output string's value is\n                 * less than d.\n                 *\/\n                s2 += Log2P;\n                mhi = BigInteger.valueOf(1 << Log2P);\n            }\n            b = b.shiftLeft(e[0] + s2);\n            BigInteger s = BigInteger.ONE;\n            s = s.shiftLeft(s2);\n            \/*\n             * @formatter:off\n             * At this point we have the following:\n             * s = 2^s2;\n             * 1 > df = b\/2^s2 > 0;\n             * (d - prevDouble(d))\/2 = mlo\/2^s2;\n             * (nextDouble(d) - d)\/2 = mhi\/2^s2.\n             * @formatter:on\n             *\/\n            BigInteger bigBase = BigInteger.valueOf(base);\n            boolean done = false;\n            do {\n                b = b.multiply(bigBase);\n                BigInteger[] divResult = b.divideAndRemainder(s);\n                b = divResult[1];\n                digit = (char) (divResult[0].intValue());\n                if (mlo == mhi) {\n                    mlo = mhi = mlo.multiply(bigBase);\n                } else {\n                    mlo = mlo.multiply(bigBase);\n                    mhi = mhi.multiply(bigBase);\n                }\n                \/* Do we yet have the shortest string that will round to d? *\/\n                int j = b.compareTo(mlo);\n                \/* j is b\/2^s2 compared with mlo\/2^s2. *\/\n                BigInteger delta = s.subtract(mhi);\n                int j1 = (delta.signum() <= 0) ? 1 : b.compareTo(delta);\n                \/* j1 is b\/2^s2 compared with 1 - mhi\/2^s2. *\/\n                if (j1 == 0 && ((word1 & 1) == 0)) {\n                    if (j > 0) {\n                        digit++;\n                    }\n                    done = true;\n                } else if (j < 0 || (j == 0 && ((word1 & 1) == 0))) {\n                    if (j1 > 0) {\n                        \/*\n                         * Either dig or dig+1 would work here as the least significant digit. Use\n                         * whichever would produce an output value closer to d.\n                         *\/\n                        b = b.shiftLeft(1);\n                        j1 = b.compareTo(s);\n                        if (j1 > 0) {\n                            \/*\n                             * The even test (|| (j1 == 0 && (digit & 1))) is not here because it\n                             * messes up odd base output such as 3.5 in base 3.\n                             *\/\n                            digit++;\n                        }\n                    }\n                    done = true;\n                } else if (j1 > 0) {\n                    digit++;\n                    done = true;\n                }\n                buffer.append(basedigit(digit));\n            } while (!done);\n            return buffer.toString();\n        }\n    }","code_wo_comment":"public static String jsDtobasestr(int base, double dParam) {\n        if (!(2 <= base && base <= 36)) {\n            throw new IllegalArgumentException(\"Bad base: \" + base);\n        }\n        double d = dParam;\n       \n        if (Double.isNaN(d)) {\n            return \"NaN\";\n        } else if (Double.isInfinite(d)) {\n            return (d > 0.0) ? \"Infinity\" : \"-Infinity\";\n        } else if (d == 0) {\n           \n            return \"0\";\n        }\n        boolean negative;\n        if (d >= 0.0) {\n            negative = false;\n        } else {\n            negative = true;\n            d = -d;\n        }\n       \n        String intDigits;\n        double dfloor = Math.floor(d);\n        long lfloor = (long) dfloor;\n        if (lfloor == dfloor) {\n           \n            if (lfloor == 0 && negative) {\n                intDigits = \"-0\";\n            } else {\n                intDigits = Long.toString((negative) ? -lfloor : lfloor, base);\n            }\n        } else {\n           \n            long floorBits = Double.doubleToLongBits(dfloor);\n            int exp = (int) (floorBits >> Exp_shiftL) & Exp_mask_shifted;\n            long mantissa;\n            if (exp == 0) {\n                mantissa = (floorBits & Frac_maskL) << 1;\n            } else {\n                mantissa = (floorBits & Frac_maskL) | Exp_msk1L;\n            }\n            if (negative) {\n                mantissa = -mantissa;\n            }\n            exp -= 1075;\n            BigInteger x = BigInteger.valueOf(mantissa);\n            if (exp > 0) {\n                x = x.shiftLeft(exp);\n            } else if (exp < 0) {\n                x = x.shiftRight(-exp);\n            }\n            intDigits = x.toString(base);\n        }\n        if (d == dfloor) {\n           \n            return intDigits;\n        } else {\n           \n            StringBuilder buffer;\n            int digit;\n            double df;\n            BigInteger b;\n            buffer = new StringBuilder();\n            buffer.append(intDigits).append('.');\n            df = d - dfloor;\n            long dBits = Double.doubleToLongBits(d);\n            int word0 = (int) (dBits >> 32);\n            int word1 = (int) (dBits);\n            int[] e = new int[1];\n            int[] bbits = new int[1];\n            b = d2b(df, e, bbits);\n           \n            int s2 = -(word0 >>> Exp_shift1 & Exp_mask >> Exp_shift1);\n            if (s2 == 0) {\n                s2 = -1;\n            }\n            s2 += Bias + P;\n           \n            BigInteger mlo = BigInteger.ONE;\n            BigInteger mhi = mlo;\n            if ((word1 == 0) && ((word0 & Bndry_mask) == 0) && ((word0 & (Exp_mask & Exp_mask << 1)) != 0)) {\n               \n                s2 += Log2P;\n                mhi = BigInteger.valueOf(1 << Log2P);\n            }\n            b = b.shiftLeft(e[0] + s2);\n            BigInteger s = BigInteger.ONE;\n            s = s.shiftLeft(s2);\n           \n            BigInteger bigBase = BigInteger.valueOf(base);\n            boolean done = false;\n            do {\n                b = b.multiply(bigBase);\n                BigInteger[] divResult = b.divideAndRemainder(s);\n                b = divResult[1];\n                digit = (char) (divResult[0].intValue());\n                if (mlo == mhi) {\n                    mlo = mhi = mlo.multiply(bigBase);\n                } else {\n                    mlo = mlo.multiply(bigBase);\n                    mhi = mhi.multiply(bigBase);\n                }\n               \n                int j = b.compareTo(mlo);\n               \n                BigInteger delta = s.subtract(mhi);\n                int j1 = (delta.signum() <= 0) ? 1 : b.compareTo(delta);\n               \n                if (j1 == 0 && ((word1 & 1) == 0)) {\n                    if (j > 0) {\n                        digit++;\n                    }\n                    done = true;\n                } else if (j < 0 || (j == 0 && ((word1 & 1) == 0))) {\n                    if (j1 > 0) {\n                       \n                        b = b.shiftLeft(1);\n                        j1 = b.compareTo(s);\n                        if (j1 > 0) {\n                           \n                            digit++;\n                        }\n                    }\n                    done = true;\n                } else if (j1 > 0) {\n                    digit++;\n                    done = true;\n                }\n                buffer.append(basedigit(digit));\n            } while (!done);\n            return buffer.toString();\n        }\n    }","cleancode":"public static string jsdtobasestr(int base, double dparam) { if (!(2 <= base && base <= 36)) { throw new illegalargumentexception(\"bad base: \" + base); } double d = dparam; if (double.isnan(d)) { return \"nan\"; } else if (double.isinfinite(d)) { return (d > 0.0) ? \"infinity\" : \"-infinity\"; } else if (d == 0) { return \"0\"; } boolean negative; if (d >= 0.0) { negative = false; } else { negative = true; d = -d; } string intdigits; double dfloor = math.floor(d); long lfloor = (long) dfloor; if (lfloor == dfloor) { if (lfloor == 0 && negative) { intdigits = \"-0\"; } else { intdigits = long.tostring((negative) ? -lfloor : lfloor, base); } } else { long floorbits = double.doubletolongbits(dfloor); int exp = (int) (floorbits >> exp_shiftl) & exp_mask_shifted; long mantissa; if (exp == 0) { mantissa = (floorbits & frac_maskl) << 1; } else { mantissa = (floorbits & frac_maskl) | exp_msk1l; } if (negative) { mantissa = -mantissa; } exp -= 1075; biginteger x = biginteger.valueof(mantissa); if (exp > 0) { x = x.shiftleft(exp); } else if (exp < 0) { x = x.shiftright(-exp); } intdigits = x.tostring(base); } if (d == dfloor) { return intdigits; } else { stringbuilder buffer; int digit; double df; biginteger b; buffer = new stringbuilder(); buffer.append(intdigits).append('.'); df = d - dfloor; long dbits = double.doubletolongbits(d); int word0 = (int) (dbits >> 32); int word1 = (int) (dbits); int[] e = new int[1]; int[] bbits = new int[1]; b = d2b(df, e, bbits); int s2 = -(word0 >>> exp_shift1 & exp_mask >> exp_shift1); if (s2 == 0) { s2 = -1; } s2 += bias + p; biginteger mlo = biginteger.one; biginteger mhi = mlo; if ((word1 == 0) && ((word0 & bndry_mask) == 0) && ((word0 & (exp_mask & exp_mask << 1)) != 0)) { s2 += log2p; mhi = biginteger.valueof(1 << log2p); } b = b.shiftleft(e[0] + s2); biginteger s = biginteger.one; s = s.shiftleft(s2); biginteger bigbase = biginteger.valueof(base); boolean done = false; do { b = b.multiply(bigbase); biginteger[] divresult = b.divideandremainder(s); b = divresult[1]; digit = (char) (divresult[0].intvalue()); if (mlo == mhi) { mlo = mhi = mlo.multiply(bigbase); } else { mlo = mlo.multiply(bigbase); mhi = mhi.multiply(bigbase); } int j = b.compareto(mlo); biginteger delta = s.subtract(mhi); int j1 = (delta.signum() <= 0) ? 1 : b.compareto(delta); if (j1 == 0 && ((word1 & 1) == 0)) { if (j > 0) { digit++; } done = true; } else if (j < 0 || (j == 0 && ((word1 & 1) == 0))) { if (j1 > 0) { b = b.shiftleft(1); j1 = b.compareto(s); if (j1 > 0) { digit++; } } done = true; } else if (j1 > 0) { digit++; done = true; } buffer.append(basedigit(digit)); } while (!done); return buffer.tostring(); } }","repo":"pitbox46\/graaljs-forge","label":[1,0,0,0]}
{"id":11112,"original_code":"@Override\n  public final boolean equals(final Object other) {\n    if (!(other instanceof Production)) {\n      return false;\n    }\n    \/\/ XXX NOTE: this assumes that the reference of the generator value does not change!\n    final Production otherProduction = (Production) other;\n    return this.id == otherProduction.id\n        && this.ownClass.equals(otherProduction.ownClass)\n        && this.generatorValue == otherProduction.generatorValue;\n  }","code_wo_comment":"@Override\n  public final boolean equals(final Object other) {\n    if (!(other instanceof Production)) {\n      return false;\n    }\n   \n    final Production otherProduction = (Production) other;\n    return this.id == otherProduction.id\n        && this.ownClass.equals(otherProduction.ownClass)\n        && this.generatorValue == otherProduction.generatorValue;\n  }","cleancode":"@override public final boolean equals(final object other) { if (!(other instanceof production)) { return false; } final production otherproduction = (production) other; return this.id == otherproduction.id && this.ownclass.equals(otherproduction.ownclass) && this.generatorvalue == otherproduction.generatorvalue; }","repo":"mskamp\/StarSmith","label":[1,0,0,0]}
{"id":2951,"original_code":"private boolean shouldRollToNewFile() {\n      \/\/ TODO: ORC file now not support target file size before closed\n      return !format.equals(FileFormat.ORC) &&\n          currentRows % ROWS_DIVISOR == 0 && length(currentWriter) >= targetFileSize;\n    }","code_wo_comment":"private boolean shouldRollToNewFile() {\n     \n      return !format.equals(FileFormat.ORC) &&\n          currentRows % ROWS_DIVISOR == 0 && length(currentWriter) >= targetFileSize;\n    }","cleancode":"private boolean shouldrolltonewfile() { return !format.equals(fileformat.orc) && currentrows % rows_divisor == 0 && length(currentwriter) >= targetfilesize; }","repo":"rajarshisarkar\/iceberg","label":[0,1,0,0]}
{"id":19374,"original_code":"boolean isAlreadyLogged(StackTraceElement[] stack)\n\t{\n\t\tHashStackTraceElement hse = new HashStackTraceElement(stack);\n\t\t\/\/ Ok, it's block the code, but for a small period\n\t\tsynchronized (this)\n\t\t{\n\t\t\t\/\/ Detect with the precalculated hash value\n\t\t\treturn !logged.add(hse);\n\t\t}\n\t}","code_wo_comment":"boolean isAlreadyLogged(StackTraceElement[] stack)\n\t{\n\t\tHashStackTraceElement hse = new HashStackTraceElement(stack);\n\t\n\t\tsynchronized (this)\n\t\t{\n\t\t\n\t\t\treturn !logged.add(hse);\n\t\t}\n\t}","cleancode":"boolean isalreadylogged(stacktraceelement[] stack) { hashstacktraceelement hse = new hashstacktraceelement(stack); synchronized (this) { return !logged.add(hse); } }","repo":"octo-online\/reactive-aud","label":[1,0,0,0]}
{"id":2992,"original_code":"public int doEndTag()\n        throws JspTagException\n    {\n        HttpServletRequest request = (HttpServletRequest)super.pageContext.getRequest();\n        RequestProperties reqState = (RequestProperties)request.getAttribute(SECTION_REQUESTPROPS);\n        PrivateLabel     privLabel = (reqState != null)? reqState.getPrivateLabel() : RequestProperties.NullPrivateLabel;\n        JspWriter              out = super.pageContext.getOut();\n        String                   s = this.getSection().toLowerCase();\n        \/* ignore blank section definitions *\/\n        if (StringTools.isBlank(s)) {\n            \/\/ -- ignore\n            return EVAL_PAGE;\n        }\n        \/* not a match? *\/\n        if (!this.isMatch()) {\n            \/\/ -- ignore\n            return EVAL_PAGE;\n        }\n        \/\/ --------------------------------------------------------------------\n        \/* \"onload='...'\" *\/\n        if (s.equalsIgnoreCase(SECTION_BODY_ONLOAD)) {\n            String bodyOnLoad = (String)request.getAttribute(SECTION_BODY_ONLOAD);\n            if (!StringTools.isBlank(bodyOnLoad)) {\n                try {\n                    out.print(bodyOnLoad);\n                } catch (IOException ioe) {\n                    throw new JspTagException(ioe.toString());\n                }\n            }\n            return EVAL_PAGE;\n        }\n        \/* \"onunload='...'\" *\/\n        if (s.equalsIgnoreCase(SECTION_BODY_ONUNLOAD)) {\n            String bodyOnUnload = (String)request.getAttribute(SECTION_BODY_ONUNLOAD);\n            if (!StringTools.isBlank(bodyOnUnload)) {\n                try {\n                    out.print(bodyOnUnload);\n                } catch (IOException ioe) {\n                    throw new JspTagException(ioe.toString());\n                }\n            }\n            return EVAL_PAGE;\n        }\n        \/\/ --------------------------------------------------------------------\n        \/* expandMenu style *\/\n        if (s.equalsIgnoreCase(SECTION_MENU_STYLE)) {\n            try {\n                ExpandMenu.writeStyle(out, reqState);\n            } catch (IOException ioe) {\n                throw new JspTagException(ioe.toString());\n            }\n            return EVAL_PAGE;\n        }\n        \/* expandMenu javascript *\/\n        if (s.equalsIgnoreCase(SECTION_MENU_JAVASCRIPT)) {\n            try {\n                ExpandMenu.writeJavaScript(out, reqState);\n            } catch (IOException ioe) {\n                throw new JspTagException(ioe.toString());\n            }\n            return EVAL_PAGE;\n        }\n        \/* expandMenu *\/\n        if (s.equalsIgnoreCase(SECTION_MENU)) {\n            try {\n                ExpandMenu.writeMenu(out, reqState, \n                    null\/*menuID*\/, true\/*expandableMenu*\/, \n                    false\/*showIcon*\/, ExpandMenu.DESC_LONG, false\/*showMenuHelp*\/);\n            } catch (IOException ioe) {\n                throw new JspTagException(ioe.toString());\n            }\n            return EVAL_PAGE;\n        }\n        \/\/ --------------------------------------------------------------------\n        \/* content table class *\/\n        if (s.equalsIgnoreCase(SECTION_CONTENT_CLASS_TABLE)) {\n            HTMLOutput content = (HTMLOutput)request.getAttribute(SECTION_CONTENT_BODY);\n            if (content != null) {\n                try {\n                    String tableClass = content.getTableClass();\n                    out.write(!StringTools.isBlank(tableClass)? tableClass : \"contentTableClass\");\n                } catch (IOException ioe) {\n                    throw new JspTagException(ioe.toString());\n                }\n            }\n            return EVAL_PAGE;\n        }\n        \/* content cell class *\/\n        if (s.equalsIgnoreCase(SECTION_CONTENT_CLASS_CELL)) {\n            HTMLOutput content = (HTMLOutput)request.getAttribute(SECTION_CONTENT_BODY);\n            if (content != null) {\n                try {\n                    String cellClass = content.getCellClass();\n                    out.write(!StringTools.isBlank(cellClass)? cellClass : \"contentCellClass\");\n                } catch (IOException ioe) {\n                    throw new JspTagException(ioe.toString());\n                }\n            }\n            return EVAL_PAGE;\n        }\n        \/* content message id *\/\n        if (s.equalsIgnoreCase(SECTION_CONTENT_ID_MESSAGE)) {\n            try {\n                out.write(CommonServlet.ID_CONTENT_MESSAGE);\n            } catch (IOException ioe) {\n                throw new JspTagException(ioe.toString());\n            }\n            return EVAL_PAGE;\n        }\n        \/* content message class *\/\n        if (s.equalsIgnoreCase(SECTION_CONTENT_CLASS_MESSAGE)) {\n            try {\n                out.write(CommonServlet.CSS_CONTENT_MESSAGE);\n            } catch (IOException ioe) {\n                throw new JspTagException(ioe.toString());\n            }\n            return EVAL_PAGE;\n        }\n        \/* content menubar *\/\n        if (s.equalsIgnoreCase(SECTION_CONTENT_MENUBAR)) {\n            HTMLOutput content = (HTMLOutput)request.getAttribute(SECTION_CONTENT_BODY);\n            if (content != null) {\n                String contentClass = content.getTableClass();\n                try {\n                    if (ListTools.contains(CommonServlet.CSS_MENUBAR_OK,contentClass)) {\n                        MenuBar.writeTableRow(out, reqState.getPageName(), reqState);\n                    } else {\n                        out.write(\"<!-- no menubar ['\"+contentClass+\"'] -->\");\n                    }\n                } catch (IOException ioe) {\n                    throw new JspTagException(ioe.toString());\n                }\n            }\n            return EVAL_PAGE;\n        }\n        \/* content message *\/\n        if (s.equalsIgnoreCase(SECTION_CONTENT_MESSAGE)) {\n            HTMLOutput content = (HTMLOutput)request.getAttribute(SECTION_CONTENT_BODY);\n            String msg = (content != null)? StringTools.trim(content.getTableMessage()) : \"\";\n            try {\n                out.write(msg); \/\/ TODO: HTML encode?\n            } catch (IOException ioe) {\n                throw new JspTagException(ioe.toString());\n            }\n            return EVAL_PAGE;\n        }\n        \/\/ --------------------------------------------------------------------\n        \/* request context path *\/\n        if (s.equalsIgnoreCase(SECTION_REQUEST_CONTEXT)) {\n            try {\n                out.write(request.getContextPath());\n            } catch (IOException ioe) {\n                throw new JspTagException(ioe.toString());\n            }\n            return EVAL_PAGE;\n        }\n        \/\/ --------------------------------------------------------------------\n        \/* CSS file *\/\n        if (s.equalsIgnoreCase(SECTION_CSSFILE)) {\n            String cssFilePath = this.getArg();\n            if (!StringTools.isBlank(cssFilePath)) {\n                try {\n                    PrintWriter pw = new PrintWriter(out, out.isAutoFlush());\n                    WebPageAdaptor.writeCssLink(pw, reqState, cssFilePath, null);\n                } catch (IOException ioe) {\n                    throw new JspTagException(ioe.toString());\n                }\n            }\n            return EVAL_PAGE;\n        }\n        \/\/ --------------------------------------------------------------------\n        \/* Banner Image Height *\/\n        if (s.equalsIgnoreCase(SECTION_BANNER_WIDTH)) {\n            \/\/ key suffix\n            String kSfx = StringTools.trim(this.getArg());\n            \/\/ property values\n            String bannerWidth = privLabel.getStringProperty(PrivateLabel.PROP_Banner_width   + kSfx, null);\n            if (StringTools.isBlank(bannerWidth)) {\n                bannerWidth = privLabel.getStringProperty(PrivateLabel.PROP_Banner_imageWidth + kSfx, null);\n            }\n            \/\/ minimum valie\n            if (StringTools.isBlank(bannerWidth)) {\n                bannerWidth = this.hasDefault()? this.getDefault() : \"100%\";\n            } else\n            if (!bannerWidth.endsWith(\"%\")) {\n                int W = StringTools.parseInt(bannerWidth, 0);\n                bannerWidth = String.valueOf((W < MIN_BANNER_WIDTH)? MIN_BANNER_WIDTH : W);\n            }\n            \/\/ generate html\n            try {\n                out.write(bannerWidth);\n            } catch (IOException ioe) {\n                throw new JspTagException(ioe.toString());\n            }\n            return EVAL_PAGE;\n        }\n        \/* Banner Style *\/\n        if (s.equalsIgnoreCase(SECTION_BANNER_STYLE)) {\n            \/\/ key suffix\n            String kSfx = StringTools.trim(this.getArg());\n            \/\/ property values\n            String bannerStyle = privLabel.getStringProperty(PrivateLabel.PROP_Banner_style + kSfx, null);\n            \/\/ generate html\n            if (!StringTools.isBlank(bannerStyle)) {\n                try {\n                    out.write(bannerStyle);\n                } catch (IOException ioe) {\n                    throw new JspTagException(ioe.toString());\n                }\n            } else\n            if (this.hasDefault()) {\n                try {\n                    out.write(this.getDefault());\n                } catch (IOException ioe) {\n                    throw new JspTagException(ioe.toString());\n                }\n            }\n            return EVAL_PAGE;\n        }\n        \/* Banner Image *\/\n        if (s.equalsIgnoreCase(SECTION_BANNER_IMAGE)) {\n            \/\/ key suffix\n            String kSfx      = StringTools.trim(this.getArg());\n            \/\/ property values\n            String imgLink   = privLabel.getStringProperty(PrivateLabel.PROP_Banner_imageLink   + kSfx, null);\n            String imgSrc    = privLabel.getStringProperty(PrivateLabel.PROP_Banner_imageSource + kSfx, null);\n            String imgWidth  = privLabel.getStringProperty(PrivateLabel.PROP_Banner_imageWidth  + kSfx, null);\n            String imgHeight = privLabel.getStringProperty(PrivateLabel.PROP_Banner_imageHeight + kSfx, null);\n            \/\/ generate html\n            if (!StringTools.isBlank(imgSrc)) {\n                StringBuffer sb = new StringBuffer();\n                if (!StringTools.isBlank(imgLink)) { \n                    sb.append(\"<a href='\").append(imgLink).append(\"' target='_blank'>\"); \n                }\n                sb.append(\"<img src='\").append(imgSrc).append(\"' border='0'\");\n                if (!StringTools.isBlank(imgWidth)) {\n                    sb.append(\" width='\").append(imgWidth).append(\"'\");\n                }\n                if (!StringTools.isBlank(imgHeight)) {\n                    sb.append(\" height='\").append(imgHeight).append(\"'\");\n                }\n                sb.append(\">\");\n                if (!StringTools.isBlank(imgLink)) {\n                    sb.append(\"<\/a>\");\n                }\n                try {\n                    out.write(sb.toString());\n                } catch (IOException ioe) {\n                    throw new JspTagException(ioe.toString());\n                }\n            } else\n            if (this.hasDefault()) {\n                try {\n                    out.write(this.getDefault());\n                } catch (IOException ioe) {\n                    throw new JspTagException(ioe.toString());\n                }\n            }\n            return EVAL_PAGE;\n        }\n        \/* Banner Image *\/\n        if (s.equalsIgnoreCase(SECTION_BANNER_IMAGE_SOURCE)) {\n            \/\/ key suffix\n            String kSfx      = StringTools.trim(this.getArg());\n            \/\/ property values\n            String imgSrc    = privLabel.getStringProperty(PrivateLabel.PROP_Banner_imageSource + kSfx, null);\n            \/\/ generate html\n            if (!StringTools.isBlank(imgSrc)) {\n                \/\/Print.sysPrintln(\"Property Image Source: \" + imgSrc);\n                try {\n                    out.write(imgSrc);\n                } catch (IOException ioe) {\n                    throw new JspTagException(ioe.toString());\n                }\n            } else\n            if (this.hasDefault()) {\n                \/\/Print.sysPrintln(\"Default Image Source: \" + this.getDefault());\n                try {\n                    out.write(this.getDefault());\n                } catch (IOException ioe) {\n                    throw new JspTagException(ioe.toString());\n                }\n            }\n            return EVAL_PAGE;\n        }\n        \/* Banner Image Height *\/\n        if (s.equalsIgnoreCase(SECTION_BANNER_IMAGE_WIDTH)) {\n            \/\/ key suffix\n            String kSfx      = StringTools.trim(this.getArg());\n            \/\/ property values\n            String imgWidth  = privLabel.getStringProperty(PrivateLabel.PROP_Banner_imageWidth  + kSfx, null);\n            \/\/ generate html\n            if (!StringTools.isBlank(imgWidth)) {\n                try {\n                    out.write(imgWidth);\n                } catch (IOException ioe) {\n                    throw new JspTagException(ioe.toString());\n                }\n            } else\n            if (this.hasDefault()) {\n                try {\n                    out.write(this.getDefault());\n                } catch (IOException ioe) {\n                    throw new JspTagException(ioe.toString());\n                }\n            }\n            return EVAL_PAGE;\n        }\n        \/* Banner Image Height *\/\n        if (s.equalsIgnoreCase(SECTION_BANNER_IMAGE_HEIGHT)) {\n            \/\/ key suffix\n            String kSfx      = StringTools.trim(this.getArg());\n            \/\/ property values\n            String imgHeight = privLabel.getStringProperty(PrivateLabel.PROP_Banner_imageHeight + kSfx, null);\n            \/\/ generate html\n            if (!StringTools.isBlank(imgHeight)) {\n                try {\n                    out.write(imgHeight);\n                } catch (IOException ioe) {\n                    throw new JspTagException(ioe.toString());\n                }\n            } else\n            if (this.hasDefault()) {\n                try {\n                    out.write(this.getDefault());\n                } catch (IOException ioe) {\n                    throw new JspTagException(ioe.toString());\n                }\n            }\n            return EVAL_PAGE;\n        }\n        \/\/ --------------------------------------------------------------------\n        \/* JavaScript *\/\n        if (s.equalsIgnoreCase(SECTION_JAVASCRIPT)) {\n            try {\n                \/\/ always write \"utils.js\"\n                JavaScriptTools.writeUtilsJS(out, request);\n                \/\/ check for other javascript \n                Object obj = request.getAttribute(SECTION_JAVASCRIPT);\n                if (obj instanceof HTMLOutput) {\n                    ((HTMLOutput)obj).write(out); \n                } else {\n                    out.write(\"<!-- Unexpected section type '\" + s + \"' [\" + StringTools.className(obj) + \"] -->\"); \n                }\n            } catch (IOException ioe) {\n                throw new JspTagException(ioe.toString());\n            }\n            return EVAL_PAGE;\n        }\n        \/\/ --------------------------------------------------------------------\n        \/* current page name *\/\n        if (s.equalsIgnoreCase(SECTION_PAGE_NAME)) { \/\/ \"pagename\"\n            String pageName = reqState.getPageName();\n            if (!StringTools.isBlank(pageName)) {\n                try {\n                    out.write(pageName);\n                } catch (IOException ioe) {\n                    throw new JspTagException(ioe.toString());\n                }\n            }\n            return EVAL_PAGE;\n        }\n        \/\/ --------------------------------------------------------------------\n        \/* Page URL *\/\n        if (s.equalsIgnoreCase(SECTION_PAGE_URL)) { \/\/ \"pageurl\"\n            String pageName = this.getArg();\n            String cmd      = null;\n            String cmdArg   = null;\n            WebPage wp = privLabel.getWebPage(pageName);\n            String url = (wp != null)? wp.encodePageURL(reqState,cmd,cmdArg) : null;\n            if (!StringTools.isBlank(url)) {\n                try {\n                    out.write(url);\n                } catch (IOException ioe) {\n                    throw new JspTagException(ioe.toString());\n                }\n            }\n            return EVAL_PAGE;\n        }\n        \/\/ --------------------------------------------------------------------\n        \/* HTMLOutput *\/\n        try {\n            Object obj = request.getAttribute(s);\n            if (obj == null) {\n                out.write(\"<!-- Undefined section '\" + s + \"' -->\"); \n            } else\n            if (obj instanceof HTMLOutput) {\n                ((HTMLOutput)obj).write(out); \n            } else {\n                out.write(\"<!-- Unexpected section type '\" + s + \"' [\" + StringTools.className(obj) + \"] -->\"); \n            }\n        } catch (IOException ioe) {\n            throw new JspTagException(ioe.toString());\n        }\n        return EVAL_PAGE;\n    }","code_wo_comment":"public int doEndTag()\n        throws JspTagException\n    {\n        HttpServletRequest request = (HttpServletRequest)super.pageContext.getRequest();\n        RequestProperties reqState = (RequestProperties)request.getAttribute(SECTION_REQUESTPROPS);\n        PrivateLabel     privLabel = (reqState != null)? reqState.getPrivateLabel() : RequestProperties.NullPrivateLabel;\n        JspWriter              out = super.pageContext.getOut();\n        String                   s = this.getSection().toLowerCase();\n       \n        if (StringTools.isBlank(s)) {\n           \n            return EVAL_PAGE;\n        }\n       \n        if (!this.isMatch()) {\n           \n            return EVAL_PAGE;\n        }\n       \n       \n        if (s.equalsIgnoreCase(SECTION_BODY_ONLOAD)) {\n            String bodyOnLoad = (String)request.getAttribute(SECTION_BODY_ONLOAD);\n            if (!StringTools.isBlank(bodyOnLoad)) {\n                try {\n                    out.print(bodyOnLoad);\n                } catch (IOException ioe) {\n                    throw new JspTagException(ioe.toString());\n                }\n            }\n            return EVAL_PAGE;\n        }\n       \n        if (s.equalsIgnoreCase(SECTION_BODY_ONUNLOAD)) {\n            String bodyOnUnload = (String)request.getAttribute(SECTION_BODY_ONUNLOAD);\n            if (!StringTools.isBlank(bodyOnUnload)) {\n                try {\n                    out.print(bodyOnUnload);\n                } catch (IOException ioe) {\n                    throw new JspTagException(ioe.toString());\n                }\n            }\n            return EVAL_PAGE;\n        }\n       \n       \n        if (s.equalsIgnoreCase(SECTION_MENU_STYLE)) {\n            try {\n                ExpandMenu.writeStyle(out, reqState);\n            } catch (IOException ioe) {\n                throw new JspTagException(ioe.toString());\n            }\n            return EVAL_PAGE;\n        }\n       \n        if (s.equalsIgnoreCase(SECTION_MENU_JAVASCRIPT)) {\n            try {\n                ExpandMenu.writeJavaScript(out, reqState);\n            } catch (IOException ioe) {\n                throw new JspTagException(ioe.toString());\n            }\n            return EVAL_PAGE;\n        }\n       \n        if (s.equalsIgnoreCase(SECTION_MENU)) {\n            try {\n                ExpandMenu.writeMenu(out, reqState, \n                    nul, tru, \n                    fals, ExpandMenu.DESC_LONG, fals);\n            } catch (IOException ioe) {\n                throw new JspTagException(ioe.toString());\n            }\n            return EVAL_PAGE;\n        }\n       \n       \n        if (s.equalsIgnoreCase(SECTION_CONTENT_CLASS_TABLE)) {\n            HTMLOutput content = (HTMLOutput)request.getAttribute(SECTION_CONTENT_BODY);\n            if (content != null) {\n                try {\n                    String tableClass = content.getTableClass();\n                    out.write(!StringTools.isBlank(tableClass)? tableClass : \"contentTableClass\");\n                } catch (IOException ioe) {\n                    throw new JspTagException(ioe.toString());\n                }\n            }\n            return EVAL_PAGE;\n        }\n       \n        if (s.equalsIgnoreCase(SECTION_CONTENT_CLASS_CELL)) {\n            HTMLOutput content = (HTMLOutput)request.getAttribute(SECTION_CONTENT_BODY);\n            if (content != null) {\n                try {\n                    String cellClass = content.getCellClass();\n                    out.write(!StringTools.isBlank(cellClass)? cellClass : \"contentCellClass\");\n                } catch (IOException ioe) {\n                    throw new JspTagException(ioe.toString());\n                }\n            }\n            return EVAL_PAGE;\n        }\n       \n        if (s.equalsIgnoreCase(SECTION_CONTENT_ID_MESSAGE)) {\n            try {\n                out.write(CommonServlet.ID_CONTENT_MESSAGE);\n            } catch (IOException ioe) {\n                throw new JspTagException(ioe.toString());\n            }\n            return EVAL_PAGE;\n        }\n       \n        if (s.equalsIgnoreCase(SECTION_CONTENT_CLASS_MESSAGE)) {\n            try {\n                out.write(CommonServlet.CSS_CONTENT_MESSAGE);\n            } catch (IOException ioe) {\n                throw new JspTagException(ioe.toString());\n            }\n            return EVAL_PAGE;\n        }\n       \n        if (s.equalsIgnoreCase(SECTION_CONTENT_MENUBAR)) {\n            HTMLOutput content = (HTMLOutput)request.getAttribute(SECTION_CONTENT_BODY);\n            if (content != null) {\n                String contentClass = content.getTableClass();\n                try {\n                    if (ListTools.contains(CommonServlet.CSS_MENUBAR_OK,contentClass)) {\n                        MenuBar.writeTableRow(out, reqState.getPageName(), reqState);\n                    } else {\n                        out.write(\"<!-- no menubar ['\"+contentClass+\"'] -->\");\n                    }\n                } catch (IOException ioe) {\n                    throw new JspTagException(ioe.toString());\n                }\n            }\n            return EVAL_PAGE;\n        }\n       \n        if (s.equalsIgnoreCase(SECTION_CONTENT_MESSAGE)) {\n            HTMLOutput content = (HTMLOutput)request.getAttribute(SECTION_CONTENT_BODY);\n            String msg = (content != null)? StringTools.trim(content.getTableMessage()) : \"\";\n            try {\n                out.write(msg);\n            } catch (IOException ioe) {\n                throw new JspTagException(ioe.toString());\n            }\n            return EVAL_PAGE;\n        }\n       \n       \n        if (s.equalsIgnoreCase(SECTION_REQUEST_CONTEXT)) {\n            try {\n                out.write(request.getContextPath());\n            } catch (IOException ioe) {\n                throw new JspTagException(ioe.toString());\n            }\n            return EVAL_PAGE;\n        }\n       \n       \n        if (s.equalsIgnoreCase(SECTION_CSSFILE)) {\n            String cssFilePath = this.getArg();\n            if (!StringTools.isBlank(cssFilePath)) {\n                try {\n                    PrintWriter pw = new PrintWriter(out, out.isAutoFlush());\n                    WebPageAdaptor.writeCssLink(pw, reqState, cssFilePath, null);\n                } catch (IOException ioe) {\n                    throw new JspTagException(ioe.toString());\n                }\n            }\n            return EVAL_PAGE;\n        }\n       \n       \n        if (s.equalsIgnoreCase(SECTION_BANNER_WIDTH)) {\n           \n            String kSfx = StringTools.trim(this.getArg());\n           \n            String bannerWidth = privLabel.getStringProperty(PrivateLabel.PROP_Banner_width   + kSfx, null);\n            if (StringTools.isBlank(bannerWidth)) {\n                bannerWidth = privLabel.getStringProperty(PrivateLabel.PROP_Banner_imageWidth + kSfx, null);\n            }\n           \n            if (StringTools.isBlank(bannerWidth)) {\n                bannerWidth = this.hasDefault()? this.getDefault() : \"100%\";\n            } else\n            if (!bannerWidth.endsWith(\"%\")) {\n                int W = StringTools.parseInt(bannerWidth, 0);\n                bannerWidth = String.valueOf((W < MIN_BANNER_WIDTH)? MIN_BANNER_WIDTH : W);\n            }\n           \n            try {\n                out.write(bannerWidth);\n            } catch (IOException ioe) {\n                throw new JspTagException(ioe.toString());\n            }\n            return EVAL_PAGE;\n        }\n       \n        if (s.equalsIgnoreCase(SECTION_BANNER_STYLE)) {\n           \n            String kSfx = StringTools.trim(this.getArg());\n           \n            String bannerStyle = privLabel.getStringProperty(PrivateLabel.PROP_Banner_style + kSfx, null);\n           \n            if (!StringTools.isBlank(bannerStyle)) {\n                try {\n                    out.write(bannerStyle);\n                } catch (IOException ioe) {\n                    throw new JspTagException(ioe.toString());\n                }\n            } else\n            if (this.hasDefault()) {\n                try {\n                    out.write(this.getDefault());\n                } catch (IOException ioe) {\n                    throw new JspTagException(ioe.toString());\n                }\n            }\n            return EVAL_PAGE;\n        }\n       \n        if (s.equalsIgnoreCase(SECTION_BANNER_IMAGE)) {\n           \n            String kSfx      = StringTools.trim(this.getArg());\n           \n            String imgLink   = privLabel.getStringProperty(PrivateLabel.PROP_Banner_imageLink   + kSfx, null);\n            String imgSrc    = privLabel.getStringProperty(PrivateLabel.PROP_Banner_imageSource + kSfx, null);\n            String imgWidth  = privLabel.getStringProperty(PrivateLabel.PROP_Banner_imageWidth  + kSfx, null);\n            String imgHeight = privLabel.getStringProperty(PrivateLabel.PROP_Banner_imageHeight + kSfx, null);\n           \n            if (!StringTools.isBlank(imgSrc)) {\n                StringBuffer sb = new StringBuffer();\n                if (!StringTools.isBlank(imgLink)) { \n                    sb.append(\"<a href='\").append(imgLink).append(\"' target='_blank'>\"); \n                }\n                sb.append(\"<img src='\").append(imgSrc).append(\"' border='0'\");\n                if (!StringTools.isBlank(imgWidth)) {\n                    sb.append(\" width='\").append(imgWidth).append(\"'\");\n                }\n                if (!StringTools.isBlank(imgHeight)) {\n                    sb.append(\" height='\").append(imgHeight).append(\"'\");\n                }\n                sb.append(\">\");\n                if (!StringTools.isBlank(imgLink)) {\n                    sb.append(\"<\/a>\");\n                }\n                try {\n                    out.write(sb.toString());\n                } catch (IOException ioe) {\n                    throw new JspTagException(ioe.toString());\n                }\n            } else\n            if (this.hasDefault()) {\n                try {\n                    out.write(this.getDefault());\n                } catch (IOException ioe) {\n                    throw new JspTagException(ioe.toString());\n                }\n            }\n            return EVAL_PAGE;\n        }\n       \n        if (s.equalsIgnoreCase(SECTION_BANNER_IMAGE_SOURCE)) {\n           \n            String kSfx      = StringTools.trim(this.getArg());\n           \n            String imgSrc    = privLabel.getStringProperty(PrivateLabel.PROP_Banner_imageSource + kSfx, null);\n           \n            if (!StringTools.isBlank(imgSrc)) {\n               \n                try {\n                    out.write(imgSrc);\n                } catch (IOException ioe) {\n                    throw new JspTagException(ioe.toString());\n                }\n            } else\n            if (this.hasDefault()) {\n               \n                try {\n                    out.write(this.getDefault());\n                } catch (IOException ioe) {\n                    throw new JspTagException(ioe.toString());\n                }\n            }\n            return EVAL_PAGE;\n        }\n       \n        if (s.equalsIgnoreCase(SECTION_BANNER_IMAGE_WIDTH)) {\n           \n            String kSfx      = StringTools.trim(this.getArg());\n           \n            String imgWidth  = privLabel.getStringProperty(PrivateLabel.PROP_Banner_imageWidth  + kSfx, null);\n           \n            if (!StringTools.isBlank(imgWidth)) {\n                try {\n                    out.write(imgWidth);\n                } catch (IOException ioe) {\n                    throw new JspTagException(ioe.toString());\n                }\n            } else\n            if (this.hasDefault()) {\n                try {\n                    out.write(this.getDefault());\n                } catch (IOException ioe) {\n                    throw new JspTagException(ioe.toString());\n                }\n            }\n            return EVAL_PAGE;\n        }\n       \n        if (s.equalsIgnoreCase(SECTION_BANNER_IMAGE_HEIGHT)) {\n           \n            String kSfx      = StringTools.trim(this.getArg());\n           \n            String imgHeight = privLabel.getStringProperty(PrivateLabel.PROP_Banner_imageHeight + kSfx, null);\n           \n            if (!StringTools.isBlank(imgHeight)) {\n                try {\n                    out.write(imgHeight);\n                } catch (IOException ioe) {\n                    throw new JspTagException(ioe.toString());\n                }\n            } else\n            if (this.hasDefault()) {\n                try {\n                    out.write(this.getDefault());\n                } catch (IOException ioe) {\n                    throw new JspTagException(ioe.toString());\n                }\n            }\n            return EVAL_PAGE;\n        }\n       \n       \n        if (s.equalsIgnoreCase(SECTION_JAVASCRIPT)) {\n            try {\n               \n                JavaScriptTools.writeUtilsJS(out, request);\n               \n                Object obj = request.getAttribute(SECTION_JAVASCRIPT);\n                if (obj instanceof HTMLOutput) {\n                    ((HTMLOutput)obj).write(out); \n                } else {\n                    out.write(\"<!-- Unexpected section type '\" + s + \"' [\" + StringTools.className(obj) + \"] -->\"); \n                }\n            } catch (IOException ioe) {\n                throw new JspTagException(ioe.toString());\n            }\n            return EVAL_PAGE;\n        }\n       \n       \n        if (s.equalsIgnoreCase(SECTION_PAGE_NAME)) {\n            String pageName = reqState.getPageName();\n            if (!StringTools.isBlank(pageName)) {\n                try {\n                    out.write(pageName);\n                } catch (IOException ioe) {\n                    throw new JspTagException(ioe.toString());\n                }\n            }\n            return EVAL_PAGE;\n        }\n       \n       \n        if (s.equalsIgnoreCase(SECTION_PAGE_URL)) {\n            String pageName = this.getArg();\n            String cmd      = null;\n            String cmdArg   = null;\n            WebPage wp = privLabel.getWebPage(pageName);\n            String url = (wp != null)? wp.encodePageURL(reqState,cmd,cmdArg) : null;\n            if (!StringTools.isBlank(url)) {\n                try {\n                    out.write(url);\n                } catch (IOException ioe) {\n                    throw new JspTagException(ioe.toString());\n                }\n            }\n            return EVAL_PAGE;\n        }\n       \n       \n        try {\n            Object obj = request.getAttribute(s);\n            if (obj == null) {\n                out.write(\"<!-- Undefined section '\" + s + \"' -->\"); \n            } else\n            if (obj instanceof HTMLOutput) {\n                ((HTMLOutput)obj).write(out); \n            } else {\n                out.write(\"<!-- Unexpected section type '\" + s + \"' [\" + StringTools.className(obj) + \"] -->\"); \n            }\n        } catch (IOException ioe) {\n            throw new JspTagException(ioe.toString());\n        }\n        return EVAL_PAGE;\n    }","cleancode":"public int doendtag() throws jsptagexception { httpservletrequest request = (httpservletrequest)super.pagecontext.getrequest(); requestproperties reqstate = (requestproperties)request.getattribute(section_requestprops); privatelabel privlabel = (reqstate != null)? reqstate.getprivatelabel() : requestproperties.nullprivatelabel; jspwriter out = super.pagecontext.getout(); string s = this.getsection().tolowercase(); if (stringtools.isblank(s)) { return eval_page; } if (!this.ismatch()) { return eval_page; } if (s.equalsignorecase(section_body_onload)) { string bodyonload = (string)request.getattribute(section_body_onload); if (!stringtools.isblank(bodyonload)) { try { out.print(bodyonload); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } } return eval_page; } if (s.equalsignorecase(section_body_onunload)) { string bodyonunload = (string)request.getattribute(section_body_onunload); if (!stringtools.isblank(bodyonunload)) { try { out.print(bodyonunload); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } } return eval_page; } if (s.equalsignorecase(section_menu_style)) { try { expandmenu.writestyle(out, reqstate); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } return eval_page; } if (s.equalsignorecase(section_menu_javascript)) { try { expandmenu.writejavascript(out, reqstate); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } return eval_page; } if (s.equalsignorecase(section_menu)) { try { expandmenu.writemenu(out, reqstate, nul, tru, fals, expandmenu.desc_long, fals); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } return eval_page; } if (s.equalsignorecase(section_content_class_table)) { htmloutput content = (htmloutput)request.getattribute(section_content_body); if (content != null) { try { string tableclass = content.gettableclass(); out.write(!stringtools.isblank(tableclass)? tableclass : \"contenttableclass\"); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } } return eval_page; } if (s.equalsignorecase(section_content_class_cell)) { htmloutput content = (htmloutput)request.getattribute(section_content_body); if (content != null) { try { string cellclass = content.getcellclass(); out.write(!stringtools.isblank(cellclass)? cellclass : \"contentcellclass\"); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } } return eval_page; } if (s.equalsignorecase(section_content_id_message)) { try { out.write(commonservlet.id_content_message); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } return eval_page; } if (s.equalsignorecase(section_content_class_message)) { try { out.write(commonservlet.css_content_message); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } return eval_page; } if (s.equalsignorecase(section_content_menubar)) { htmloutput content = (htmloutput)request.getattribute(section_content_body); if (content != null) { string contentclass = content.gettableclass(); try { if (listtools.contains(commonservlet.css_menubar_ok,contentclass)) { menubar.writetablerow(out, reqstate.getpagename(), reqstate); } else { out.write(\"<!-- no menubar ['\"+contentclass+\"'] -->\"); } } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } } return eval_page; } if (s.equalsignorecase(section_content_message)) { htmloutput content = (htmloutput)request.getattribute(section_content_body); string msg = (content != null)? stringtools.trim(content.gettablemessage()) : \"\"; try { out.write(msg); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } return eval_page; } if (s.equalsignorecase(section_request_context)) { try { out.write(request.getcontextpath()); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } return eval_page; } if (s.equalsignorecase(section_cssfile)) { string cssfilepath = this.getarg(); if (!stringtools.isblank(cssfilepath)) { try { printwriter pw = new printwriter(out, out.isautoflush()); webpageadaptor.writecsslink(pw, reqstate, cssfilepath, null); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } } return eval_page; } if (s.equalsignorecase(section_banner_width)) { string ksfx = stringtools.trim(this.getarg()); string bannerwidth = privlabel.getstringproperty(privatelabel.prop_banner_width + ksfx, null); if (stringtools.isblank(bannerwidth)) { bannerwidth = privlabel.getstringproperty(privatelabel.prop_banner_imagewidth + ksfx, null); } if (stringtools.isblank(bannerwidth)) { bannerwidth = this.hasdefault()? this.getdefault() : \"100%\"; } else if (!bannerwidth.endswith(\"%\")) { int w = stringtools.parseint(bannerwidth, 0); bannerwidth = string.valueof((w < min_banner_width)? min_banner_width : w); } try { out.write(bannerwidth); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } return eval_page; } if (s.equalsignorecase(section_banner_style)) { string ksfx = stringtools.trim(this.getarg()); string bannerstyle = privlabel.getstringproperty(privatelabel.prop_banner_style + ksfx, null); if (!stringtools.isblank(bannerstyle)) { try { out.write(bannerstyle); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } } else if (this.hasdefault()) { try { out.write(this.getdefault()); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } } return eval_page; } if (s.equalsignorecase(section_banner_image)) { string ksfx = stringtools.trim(this.getarg()); string imglink = privlabel.getstringproperty(privatelabel.prop_banner_imagelink + ksfx, null); string imgsrc = privlabel.getstringproperty(privatelabel.prop_banner_imagesource + ksfx, null); string imgwidth = privlabel.getstringproperty(privatelabel.prop_banner_imagewidth + ksfx, null); string imgheight = privlabel.getstringproperty(privatelabel.prop_banner_imageheight + ksfx, null); if (!stringtools.isblank(imgsrc)) { stringbuffer sb = new stringbuffer(); if (!stringtools.isblank(imglink)) { sb.append(\"<a href='\").append(imglink).append(\"' target='_blank'>\"); } sb.append(\"<img src='\").append(imgsrc).append(\"' border='0'\"); if (!stringtools.isblank(imgwidth)) { sb.append(\" width='\").append(imgwidth).append(\"'\"); } if (!stringtools.isblank(imgheight)) { sb.append(\" height='\").append(imgheight).append(\"'\"); } sb.append(\">\"); if (!stringtools.isblank(imglink)) { sb.append(\"<\/a>\"); } try { out.write(sb.tostring()); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } } else if (this.hasdefault()) { try { out.write(this.getdefault()); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } } return eval_page; } if (s.equalsignorecase(section_banner_image_source)) { string ksfx = stringtools.trim(this.getarg()); string imgsrc = privlabel.getstringproperty(privatelabel.prop_banner_imagesource + ksfx, null); if (!stringtools.isblank(imgsrc)) { try { out.write(imgsrc); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } } else if (this.hasdefault()) { try { out.write(this.getdefault()); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } } return eval_page; } if (s.equalsignorecase(section_banner_image_width)) { string ksfx = stringtools.trim(this.getarg()); string imgwidth = privlabel.getstringproperty(privatelabel.prop_banner_imagewidth + ksfx, null); if (!stringtools.isblank(imgwidth)) { try { out.write(imgwidth); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } } else if (this.hasdefault()) { try { out.write(this.getdefault()); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } } return eval_page; } if (s.equalsignorecase(section_banner_image_height)) { string ksfx = stringtools.trim(this.getarg()); string imgheight = privlabel.getstringproperty(privatelabel.prop_banner_imageheight + ksfx, null); if (!stringtools.isblank(imgheight)) { try { out.write(imgheight); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } } else if (this.hasdefault()) { try { out.write(this.getdefault()); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } } return eval_page; } if (s.equalsignorecase(section_javascript)) { try { javascripttools.writeutilsjs(out, request); object obj = request.getattribute(section_javascript); if (obj instanceof htmloutput) { ((htmloutput)obj).write(out); } else { out.write(\"<!-- unexpected section type '\" + s + \"' [\" + stringtools.classname(obj) + \"] -->\"); } } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } return eval_page; } if (s.equalsignorecase(section_page_name)) { string pagename = reqstate.getpagename(); if (!stringtools.isblank(pagename)) { try { out.write(pagename); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } } return eval_page; } if (s.equalsignorecase(section_page_url)) { string pagename = this.getarg(); string cmd = null; string cmdarg = null; webpage wp = privlabel.getwebpage(pagename); string url = (wp != null)? wp.encodepageurl(reqstate,cmd,cmdarg) : null; if (!stringtools.isblank(url)) { try { out.write(url); } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } } return eval_page; } try { object obj = request.getattribute(s); if (obj == null) { out.write(\"<!-- undefined section '\" + s + \"' -->\"); } else if (obj instanceof htmloutput) { ((htmloutput)obj).write(out); } else { out.write(\"<!-- unexpected section type '\" + s + \"' [\" + stringtools.classname(obj) + \"] -->\"); } } catch (ioexception ioe) { throw new jsptagexception(ioe.tostring()); } return eval_page; }","repo":"paragp\/GTS-PreUAT","label":[1,0,0,0]}
{"id":19480,"original_code":"synchronized boolean acceptFrame(\n        @NotNull VP8Frame frame,\n        int incomingIndex,\n        int externalTargetIndex, long receivedMs)\n    {\n        \/\/ We make local copies of the externalTemporalLayerIdTarget and the\n        \/\/ externalEncodingTarget (as they may be updated by some other\n        \/\/ thread).\n        int externalTemporalLayerIdTarget\n            = RtpLayerDesc.getTidFromIndex(externalTargetIndex);\n        int externalEncodingIdTarget\n            = RtpLayerDesc.getEidFromIndex(externalTargetIndex);\n        if (externalEncodingIdTarget != internalEncodingIdTarget)\n        {\n            \/\/ The externalEncodingIdTarget has changed since accept last\n            \/\/ run; perhaps we should request a keyframe.\n            internalEncodingIdTarget = externalEncodingIdTarget;\n            if (externalEncodingIdTarget > SUSPENDED_ENCODING_ID)\n            {\n                needsKeyframe = true;\n            }\n        }\n        if (externalEncodingIdTarget < 0\n            || externalTemporalLayerIdTarget < 0)\n        {\n            \/\/ We stop forwarding immediately. We will need a keyframe in order\n            \/\/ to resume.\n            currentEncodingId = SUSPENDED_ENCODING_ID;\n            return false;\n        }\n        int temporalLayerIdOfFrame = frame.getTemporalLayer();\n        if (temporalLayerIdOfFrame < 0)\n        {\n            \/\/ temporal scalability is not enabled. Pretend that\n            \/\/ this is the base temporal layer.\n            temporalLayerIdOfFrame = 0;\n        }\n        int encodingId = RtpLayerDesc.getEidFromIndex(incomingIndex);\n        if (frame.isKeyframe())\n        {\n            logger.debug(() -> \"Quality filter got keyframe for stream \"\n                    + frame.getSsrc());\n            return acceptKeyframe(encodingId, receivedMs);\n        }\n        else if (currentEncodingId > SUSPENDED_ENCODING_ID)\n        {\n            if (isOutOfSwitchingPhase(receivedMs) && isPossibleToSwitch(encodingId))\n            {\n                \/\/ XXX(george) i've noticed some \"rogue\" base layer keyframes\n                \/\/ that trigger this. what happens is the client sends a base\n                \/\/ layer key frame, the bridge switches to that layer because\n                \/\/ for all it knows it may be the only keyframe sent by the\n                \/\/ client engine. then the bridge notices that packets from the\n                \/\/ higher quality streams are flowing and execution ends-up\n                \/\/ here. it is a mystery why the engine is \"leaking\" base layer\n                \/\/ key frames\n                needsKeyframe = true;\n            }\n            if (encodingId != currentEncodingId)\n            {\n                \/\/ for non-keyframes, we can't route anything but the current encoding\n                return false;\n            }\n            \/\/ This branch reads the {@link #currentEncodingId} and it\n            \/\/ filters packets based on their temporal layer.\n            if (currentEncodingId > externalEncodingIdTarget)\n            {\n                \/\/ pending downscale, decrease the frame rate until we\n                \/\/ downscale.\n                return temporalLayerIdOfFrame < 1;\n            }\n            else if (currentEncodingId < externalEncodingIdTarget)\n            {\n                \/\/ pending upscale, increase the frame rate until we upscale.\n                return true;\n            }\n            else\n            {\n                \/\/ The currentSpatialLayerId matches exactly the target\n                \/\/ currentSpatialLayerId.\n                return temporalLayerIdOfFrame <= externalTemporalLayerIdTarget;\n            }\n        }\n        else\n        {\n            \/\/ In this branch we're not processing a keyframe and the\n            \/\/ currentSpatialLayerId is in suspended state, which means we need\n            \/\/ a keyframe to start streaming again. Reaching this point also\n            \/\/ means that we want to forward something (because both\n            \/\/ externalEncodingIdTarget and externalTemporalLayerIdTarget\n            \/\/ are greater than 0) so we set the request keyframe flag.\n            \/\/ assert needsKeyframe == true;\n            return false;\n        }\n    }","code_wo_comment":"synchronized boolean acceptFrame(\n        @NotNull VP8Frame frame,\n        int incomingIndex,\n        int externalTargetIndex, long receivedMs)\n    {\n       \n       \n       \n        int externalTemporalLayerIdTarget\n            = RtpLayerDesc.getTidFromIndex(externalTargetIndex);\n        int externalEncodingIdTarget\n            = RtpLayerDesc.getEidFromIndex(externalTargetIndex);\n        if (externalEncodingIdTarget != internalEncodingIdTarget)\n        {\n           \n           \n            internalEncodingIdTarget = externalEncodingIdTarget;\n            if (externalEncodingIdTarget > SUSPENDED_ENCODING_ID)\n            {\n                needsKeyframe = true;\n            }\n        }\n        if (externalEncodingIdTarget < 0\n            || externalTemporalLayerIdTarget < 0)\n        {\n           \n           \n            currentEncodingId = SUSPENDED_ENCODING_ID;\n            return false;\n        }\n        int temporalLayerIdOfFrame = frame.getTemporalLayer();\n        if (temporalLayerIdOfFrame < 0)\n        {\n           \n           \n            temporalLayerIdOfFrame = 0;\n        }\n        int encodingId = RtpLayerDesc.getEidFromIndex(incomingIndex);\n        if (frame.isKeyframe())\n        {\n            logger.debug(() -> \"Quality filter got keyframe for stream \"\n                    + frame.getSsrc());\n            return acceptKeyframe(encodingId, receivedMs);\n        }\n        else if (currentEncodingId > SUSPENDED_ENCODING_ID)\n        {\n            if (isOutOfSwitchingPhase(receivedMs) && isPossibleToSwitch(encodingId))\n            {\n               \n               \n               \n               \n               \n               \n               \n               \n                needsKeyframe = true;\n            }\n            if (encodingId != currentEncodingId)\n            {\n               \n                return false;\n            }\n           \n           \n            if (currentEncodingId > externalEncodingIdTarget)\n            {\n               \n               \n                return temporalLayerIdOfFrame < 1;\n            }\n            else if (currentEncodingId < externalEncodingIdTarget)\n            {\n               \n                return true;\n            }\n            else\n            {\n               \n               \n                return temporalLayerIdOfFrame <= externalTemporalLayerIdTarget;\n            }\n        }\n        else\n        {\n           \n           \n           \n           \n           \n           \n           \n            return false;\n        }\n    }","cleancode":"synchronized boolean acceptframe( @notnull vp8frame frame, int incomingindex, int externaltargetindex, long receivedms) { int externaltemporallayeridtarget = rtplayerdesc.gettidfromindex(externaltargetindex); int externalencodingidtarget = rtplayerdesc.geteidfromindex(externaltargetindex); if (externalencodingidtarget != internalencodingidtarget) { internalencodingidtarget = externalencodingidtarget; if (externalencodingidtarget > suspended_encoding_id) { needskeyframe = true; } } if (externalencodingidtarget < 0 || externaltemporallayeridtarget < 0) { currentencodingid = suspended_encoding_id; return false; } int temporallayeridofframe = frame.gettemporallayer(); if (temporallayeridofframe < 0) { temporallayeridofframe = 0; } int encodingid = rtplayerdesc.geteidfromindex(incomingindex); if (frame.iskeyframe()) { logger.debug(() -> \"quality filter got keyframe for stream \" + frame.getssrc()); return acceptkeyframe(encodingid, receivedms); } else if (currentencodingid > suspended_encoding_id) { if (isoutofswitchingphase(receivedms) && ispossibletoswitch(encodingid)) { needskeyframe = true; } if (encodingid != currentencodingid) { return false; } if (currentencodingid > externalencodingidtarget) { return temporallayeridofframe < 1; } else if (currentencodingid < externalencodingidtarget) { return true; } else { return temporallayeridofframe <= externaltemporallayeridtarget; } } else { return false; } }","repo":"ngi-nix\/jitsi-videobridge","label":[1,0,0,0]}
{"id":19563,"original_code":"public static List getCRLs(X509Extension cert) {\n        \/\/ What follows is a poor man's CRL extractor, for those lacking\n        \/\/ a BouncyCastle \"bcprov.jar\" in their classpath.\n        \/\/ It's a very basic state-machine:  look for a standard URL scheme\n        \/\/ (such as http), and then start looking for a terminator.  After\n        \/\/ running hexdump a few times on these things, it looks to me like\n        \/\/ the UTF-8 value \"65533\" seems to happen near where these things\n        \/\/ terminate.  (Of course this stuff is ASN.1 and not UTF-8, but\n        \/\/ I happen to like some of the functions available to the String\n        \/\/ object).    - juliusdavies@cucbc.com, May 10th, 2006\n        byte[] bytes = cert.getExtensionValue(CRL_EXTENSION);\n        LinkedList httpCRLS = new LinkedList();\n        LinkedList ftpCRLS = new LinkedList();\n        LinkedList otherCRLS = new LinkedList();\n        if (bytes == null) {\n            \/\/ just return empty list\n            return httpCRLS;\n        } else {\n            String s;\n            try {\n                s = new String(bytes, \"UTF-8\");\n            }\n            catch (UnsupportedEncodingException uee) {\n                \/\/ We're screwed if this thing has more than one CRL, because\n                \/\/ the \"indeOf( (char) 65533 )\" below isn't going to work.\n                s = new String(bytes);\n            }\n            int pos = 0;\n            while (pos >= 0) {\n                int x = -1, y;\n                int[] indexes = new int[4];\n                indexes[0] = s.indexOf(\"http\", pos);\n                indexes[1] = s.indexOf(\"ldap\", pos);\n                indexes[2] = s.indexOf(\"file\", pos);\n                indexes[3] = s.indexOf(\"ftp\", pos);\n                Arrays.sort(indexes);\n                for (int i = 0; i < indexes.length; i++) {\n                    if (indexes[i] >= 0) {\n                        x = indexes[i];\n                        break;\n                    }\n                }\n                if (x >= 0) {\n                    y = s.indexOf((char) 65533, x);\n                    String crl = y > x ? s.substring(x, y - 1) : s.substring(x);\n                    if (y > x && crl.endsWith(\"0\")) {\n                        crl = crl.substring(0, crl.length() - 1);\n                    }\n                    String crlTest = crl.trim().toLowerCase();\n                    if (crlTest.startsWith(\"http\")) {\n                        httpCRLS.add(crl);\n                    } else if (crlTest.startsWith(\"ftp\")) {\n                        ftpCRLS.add(crl);\n                    } else {\n                        otherCRLS.add(crl);\n                    }\n                    pos = y;\n                } else {\n                    pos = -1;\n                }\n            }\n        }\n        httpCRLS.addAll(ftpCRLS);\n        httpCRLS.addAll(otherCRLS);\n        return httpCRLS;\n    }","code_wo_comment":"public static List getCRLs(X509Extension cert) {\n       \n       \n       \n       \n       \n       \n       \n       \n       \n        byte[] bytes = cert.getExtensionValue(CRL_EXTENSION);\n        LinkedList httpCRLS = new LinkedList();\n        LinkedList ftpCRLS = new LinkedList();\n        LinkedList otherCRLS = new LinkedList();\n        if (bytes == null) {\n           \n            return httpCRLS;\n        } else {\n            String s;\n            try {\n                s = new String(bytes, \"UTF-8\");\n            }\n            catch (UnsupportedEncodingException uee) {\n               \n               \n                s = new String(bytes);\n            }\n            int pos = 0;\n            while (pos >= 0) {\n                int x = -1, y;\n                int[] indexes = new int[4];\n                indexes[0] = s.indexOf(\"http\", pos);\n                indexes[1] = s.indexOf(\"ldap\", pos);\n                indexes[2] = s.indexOf(\"file\", pos);\n                indexes[3] = s.indexOf(\"ftp\", pos);\n                Arrays.sort(indexes);\n                for (int i = 0; i < indexes.length; i++) {\n                    if (indexes[i] >= 0) {\n                        x = indexes[i];\n                        break;\n                    }\n                }\n                if (x >= 0) {\n                    y = s.indexOf((char) 65533, x);\n                    String crl = y > x ? s.substring(x, y - 1) : s.substring(x);\n                    if (y > x && crl.endsWith(\"0\")) {\n                        crl = crl.substring(0, crl.length() - 1);\n                    }\n                    String crlTest = crl.trim().toLowerCase();\n                    if (crlTest.startsWith(\"http\")) {\n                        httpCRLS.add(crl);\n                    } else if (crlTest.startsWith(\"ftp\")) {\n                        ftpCRLS.add(crl);\n                    } else {\n                        otherCRLS.add(crl);\n                    }\n                    pos = y;\n                } else {\n                    pos = -1;\n                }\n            }\n        }\n        httpCRLS.addAll(ftpCRLS);\n        httpCRLS.addAll(otherCRLS);\n        return httpCRLS;\n    }","cleancode":"public static list getcrls(x509extension cert) { byte[] bytes = cert.getextensionvalue(crl_extension); linkedlist httpcrls = new linkedlist(); linkedlist ftpcrls = new linkedlist(); linkedlist othercrls = new linkedlist(); if (bytes == null) { return httpcrls; } else { string s; try { s = new string(bytes, \"utf-8\"); } catch (unsupportedencodingexception uee) { s = new string(bytes); } int pos = 0; while (pos >= 0) { int x = -1, y; int[] indexes = new int[4]; indexes[0] = s.indexof(\"http\", pos); indexes[1] = s.indexof(\"ldap\", pos); indexes[2] = s.indexof(\"file\", pos); indexes[3] = s.indexof(\"ftp\", pos); arrays.sort(indexes); for (int i = 0; i < indexes.length; i++) { if (indexes[i] >= 0) { x = indexes[i]; break; } } if (x >= 0) { y = s.indexof((char) 65533, x); string crl = y > x ? s.substring(x, y - 1) : s.substring(x); if (y > x && crl.endswith(\"0\")) { crl = crl.substring(0, crl.length() - 1); } string crltest = crl.trim().tolowercase(); if (crltest.startswith(\"http\")) { httpcrls.add(crl); } else if (crltest.startswith(\"ftp\")) { ftpcrls.add(crl); } else { othercrls.add(crl); } pos = y; } else { pos = -1; } } } httpcrls.addall(ftpcrls); httpcrls.addall(othercrls); return httpcrls; }","repo":"rcbj\/apigee-jwt-aad-timeapi-proxy","label":[0,0,1,0]}
{"id":11379,"original_code":"public static int XColorByName(String nm) {\n\t\tfor (int i=0; i<data.length; i++) {\n\t\t\tSetting d = data[i];\n\t\t\t\/\/ System.out.println(\"Looking for \" + nm + \"; trying \" + d.name);\n\t\t\tif (nm.equalsIgnoreCase(d.name)) {\n\t\t\t\treturn d.value;\n\t\t\t}\n\t\t}\n\t\t\/\/ How sad... none of the 752 color names matched...\n\t\tthrow new IllegalArgumentException(\"Unknown color \" + nm);\n\t}","code_wo_comment":"public static int XColorByName(String nm) {\n\t\tfor (int i=0; i<data.length; i++) {\n\t\t\tSetting d = data[i];\n\t\t\n\t\t\tif (nm.equalsIgnoreCase(d.name)) {\n\t\t\t\treturn d.value;\n\t\t\t}\n\t\t}\n\t\n\t\tthrow new IllegalArgumentException(\"Unknown color \" + nm);\n\t}","cleancode":"public static int xcolorbyname(string nm) { for (int i=0; i<data.length; i++) { setting d = data[i]; if (nm.equalsignorecase(d.name)) { return d.value; } } throw new illegalargumentexception(\"unknown color \" + nm); }","repo":"oritelad\/libro-de-actividades","label":[0,0,0,0]}
{"id":11380,"original_code":"public static String XColorByValue(int val) {\n\t\tfor (int i=0; i<data.length; i++) {\n\t\t\tSetting d = data[i];\n\t\t\t\/\/ System.out.println(\"Looking for \" + nm + \"; trying \" + d.name);\n\t\t\tif (val == d.value) {\n\t\t\t\treturn d.name;\n\t\t\t}\n\t\t}\n\t\t\/\/ How sad... none of the 752 color names matched...\n\t\treturn \"XColor(\" + val + \")\";\n\t}","code_wo_comment":"public static String XColorByValue(int val) {\n\t\tfor (int i=0; i<data.length; i++) {\n\t\t\tSetting d = data[i];\n\t\t\n\t\t\tif (val == d.value) {\n\t\t\t\treturn d.name;\n\t\t\t}\n\t\t}\n\t\n\t\treturn \"XColor(\" + val + \")\";\n\t}","cleancode":"public static string xcolorbyvalue(int val) { for (int i=0; i<data.length; i++) { setting d = data[i]; if (val == d.value) { return d.name; } } return \"xcolor(\" + val + \")\"; }","repo":"oritelad\/libro-de-actividades","label":[0,0,0,0]}
{"id":11618,"original_code":"private static final boolean isHalfUlp (final double x) {\n    \/\/ TODO: do we need to check for NaN and infinity?\n    return (0.0 != x) && (0L == Doubles.significand(x)); }","code_wo_comment":"private static final boolean isHalfUlp (final double x) {\n   \n    return (0.0 != x) && (0L == Doubles.significand(x)); }","cleancode":"private static final boolean ishalfulp (final double x) { return (0.0 != x) && (0l == doubles.significand(x)); }","repo":"palisades-lakes\/xfp-jmh","label":[1,0,0,0]}
{"id":11619,"original_code":"private static final double halfUlp (final double x) {\n    \/\/ TODO: do we need to check for NaN and infinity?\n    \/\/ TODO: compare to c++ implementation\n    \/\/ TODO: return zero when x is zero?\n    if (0.0 == x) { return 0.0; }\n    return 0.5 * Math.ulp(x); }","code_wo_comment":"private static final double halfUlp (final double x) {\n   \n   \n   \n    if (0.0 == x) { return 0.0; }\n    return 0.5 * Math.ulp(x); }","cleancode":"private static final double halfulp (final double x) { if (0.0 == x) { return 0.0; } return 0.5 * math.ulp(x); }","repo":"palisades-lakes\/xfp-jmh","label":[1,0,0,0]}
{"id":11774,"original_code":"@Override\n    protected void parseSynchronusly() throws IOException {\n        final Optional<RDFFormat> formatByMimeType = getContentType().flatMap(Rio::getParserFormatForMIMEType);\n        final String base = getBase().map(IRI::getIRIString).orElse(null);\n        final ParserConfig parserConfig = getParserConfig();\n        \/\/ TODO: Should we need to set anything?\n        final RDFLoader loader = new RDFLoader(parserConfig, rdf4jTermFactory.getValueFactory());\n        final RDFHandler rdfHandler = makeRDFHandler();\n        if (getSourceFile().isPresent()) {\n            \/\/ NOTE: While we could have used\n            \/\/ loader.load(sourcePath.toFile()\n            \/\/ if the path fs provider == FileSystems.getDefault(),\n            \/\/ that RDFLoader method does not use absolute path\n            \/\/ as the base URI, so to be consistent\n            \/\/ we'll always do it with our own input stream\n            \/\/\n            \/\/ That means we may have to guess format by extensions:\n            final Optional<RDFFormat> formatByFilename = getSourceFile().map(Path::getFileName).map(Path::toString)\n                    .flatMap(Rio::getParserFormatForFileName);\n            \/\/ TODO: for the excited.. what about the extension after following\n            \/\/ symlinks?\n            final RDFFormat format = formatByMimeType.orElse(formatByFilename.orElse(null));\n            try (InputStream in = Files.newInputStream(getSourceFile().get())) {\n                loader.load(in, base, format, rdfHandler);\n            }\n        } else if (getSourceIri().isPresent()) {\n            try {\n                \/\/ TODO: Handle international IRIs properly\n                \/\/ (Unicode support for for hostname, path and query)\n                final URL url = new URL(getSourceIri().get().getIRIString());\n                \/\/ TODO: This probably does not support https:\/\/ -> http:\/\/\n                \/\/ redirections\n                loader.load(url, base, formatByMimeType.orElse(null), makeRDFHandler());\n            } catch (final MalformedURLException ex) {\n                throw new IOException(\"Can't handle source URL: \" + getSourceIri().get(), ex);\n            }\n        }\n        \/\/ must be getSourceInputStream then, this is guaranteed by\n        \/\/ super.checkSource();\n        loader.load(getSourceInputStream().get(), base, formatByMimeType.orElse(null), rdfHandler);\n    }","code_wo_comment":"@Override\n    protected void parseSynchronusly() throws IOException {\n        final Optional<RDFFormat> formatByMimeType = getContentType().flatMap(Rio::getParserFormatForMIMEType);\n        final String base = getBase().map(IRI::getIRIString).orElse(null);\n        final ParserConfig parserConfig = getParserConfig();\n       \n        final RDFLoader loader = new RDFLoader(parserConfig, rdf4jTermFactory.getValueFactory());\n        final RDFHandler rdfHandler = makeRDFHandler();\n        if (getSourceFile().isPresent()) {\n           \n           \n           \n           \n           \n           \n           \n           \n            final Optional<RDFFormat> formatByFilename = getSourceFile().map(Path::getFileName).map(Path::toString)\n                    .flatMap(Rio::getParserFormatForFileName);\n           \n           \n            final RDFFormat format = formatByMimeType.orElse(formatByFilename.orElse(null));\n            try (InputStream in = Files.newInputStream(getSourceFile().get())) {\n                loader.load(in, base, format, rdfHandler);\n            }\n        } else if (getSourceIri().isPresent()) {\n            try {\n               \n               \n                final URL url = new URL(getSourceIri().get().getIRIString());\n               \n               \n                loader.load(url, base, formatByMimeType.orElse(null), makeRDFHandler());\n            } catch (final MalformedURLException ex) {\n                throw new IOException(\"Can't handle source URL: \" + getSourceIri().get(), ex);\n            }\n        }\n       \n       \n        loader.load(getSourceInputStream().get(), base, formatByMimeType.orElse(null), rdfHandler);\n    }","cleancode":"@override protected void parsesynchronusly() throws ioexception { final optional<rdfformat> formatbymimetype = getcontenttype().flatmap(rio::getparserformatformimetype); final string base = getbase().map(iri::getiristring).orelse(null); final parserconfig parserconfig = getparserconfig(); final rdfloader loader = new rdfloader(parserconfig, rdf4jtermfactory.getvaluefactory()); final rdfhandler rdfhandler = makerdfhandler(); if (getsourcefile().ispresent()) { final optional<rdfformat> formatbyfilename = getsourcefile().map(path::getfilename).map(path::tostring) .flatmap(rio::getparserformatforfilename); final rdfformat format = formatbymimetype.orelse(formatbyfilename.orelse(null)); try (inputstream in = files.newinputstream(getsourcefile().get())) { loader.load(in, base, format, rdfhandler); } } else if (getsourceiri().ispresent()) { try { final url url = new url(getsourceiri().get().getiristring()); loader.load(url, base, formatbymimetype.orelse(null), makerdfhandler()); } catch (final malformedurlexception ex) { throw new ioexception(\"can't handle source url: \" + getsourceiri().get(), ex); } } loader.load(getsourceinputstream().get(), base, formatbymimetype.orelse(null), rdfhandler); }","repo":"nikosnikolaidis\/commons-rdf","label":[1,1,0,0]}
{"id":20076,"original_code":"int denybble(byte[] data, int pos)\n        {\n        \/\/ The spec is wrong: it's LSB, then MSB\n        \/\/ int v = (data[pos] << 4) | data[pos+1];\n        int v = (data[pos + 1] << 4) | data[pos];\n        \/\/ Some of the dark star stuff is 8-bit, so we have to make sure we're positive\n        if (v < 0) v += 256;\n        return v;\n        }","code_wo_comment":"int denybble(byte[] data, int pos)\n        {\n       \n       \n        int v = (data[pos + 1] << 4) | data[pos];\n       \n        if (v < 0) v += 256;\n        return v;\n        }","cleancode":"int denybble(byte[] data, int pos) { int v = (data[pos + 1] << 4) | data[pos]; if (v < 0) v += 256; return v; }","repo":"oco27\/edisyn","label":[0,0,1,0]}
{"id":20077,"original_code":"void addData(byte[] data, int pos, int val)\n        {\n        \/\/ The spec is wrong: it's LSB, then MSB\n        data[pos] = (byte)((val >> 0) & 0x0F);\n        data[pos + 1] = (byte)((val >> 4) & 0x0F);\n        \/\/data[pos + 1] = (byte)((val >> 0) & 0x0F);\n        \/\/data[pos] = (byte)((val >> 4) & 0x0F);\n        }","code_wo_comment":"void addData(byte[] data, int pos, int val)\n        {\n       \n        data[pos] = (byte)((val >> 0) & 0x0F);\n        data[pos + 1] = (byte)((val >> 4) & 0x0F);\n       \n       \n        }","cleancode":"void adddata(byte[] data, int pos, int val) { data[pos] = (byte)((val >> 0) & 0x0f); data[pos + 1] = (byte)((val >> 4) & 0x0f); }","repo":"oco27\/edisyn","label":[0,0,1,0]}
{"id":11963,"original_code":"protected void paint(GraphicsContext gc) {\n        \/\/ Get a sorted copy of the series data.  Once we have this we can release locks.\n        Rectangle2D rectViewport = viewport;\n        HashMap<Series, LinkedList<T>> data = new HashMap<>();\n        for(Series<T> series : this.series) {\n            LinkedList<T> seriesData = new LinkedList<>(series.getData());\n            seriesData.sort((o1, o2) -> fnXValue.apply(o1).compareTo(fnXValue.apply(o2)));\n            data.put(series, seriesData);\n        }\n        \/\/Make sure we have data before continuing.\n        if(data.size() == 0) {\n            return;\n        }\n        if(data.values().stream().flatMap(LinkedList::stream).count() == 0) {\n            return;\n        }\n        \/\/ Calculate the range on each axis.\n        Range<TX> axisX;\n        Range<TY> axisY;\n        \/\/TODO: Since we just sorted by X, we can optimize this a bit.\n        if(rangeX != null) {\n            axisX = new Range<>(\n                    rangeX.min == null ? data.values().stream().flatMap(LinkedList::stream).map(fnXValue).min(TX::compareTo).get() : rangeX.min,\n                    rangeX.max == null ? data.values().stream().flatMap(LinkedList::stream).map(fnXValue).max(TX::compareTo).get() : rangeX.max\n            );\n        } else {\n            axisX = new Range<>(\n                    data.values().stream().flatMap(LinkedList::stream).map(fnXValue).min(TX::compareTo).get(),\n                    data.values().stream().flatMap(LinkedList::stream).map(fnXValue).max(TX::compareTo).get()\n            );\n        }\n        if(rangeY != null) {\n            axisY = new Range<>(\n                    rangeY.min == null ? data.values().stream().flatMap(LinkedList::stream).map(fnYValue).min(TY::compareTo).get() : rangeY.min,\n                    rangeY.max == null ? data.values().stream().flatMap(LinkedList::stream).map(fnYValue).max(TY::compareTo).get() : rangeY.max\n            );\n        } else {\n            axisY = new Range<>(\n                    data.values().stream().flatMap(LinkedList::stream).map(fnYValue).min(TY::compareTo).get(),\n                    data.values().stream().flatMap(LinkedList::stream).map(fnYValue).max(TY::compareTo).get()\n            );\n        }\n        final List<TX> ticksX = fnTicksX.generateTicks(axisX, viewport.getMinX(), viewport.getMaxX());\n        \/\/axisX = new Range<>(ticksX.get(0), ticksX.get(ticksX.size() - 1));\n        \/\/rangeXRendered = axisX;\n        final List<TY> ticksY = fnTicksY.generateTicks(axisY, viewport.getMinY(), viewport.getMaxY());\n        \/\/axisY = new Range<>(ticksY.get(0), ticksY.get(ticksY.size() - 1));\n        \/\/ Calculate the width of the widest Y-axis label and the height of the tallest X-axis label.\n        double maxWidth = 0.0;\n        double pxMinSpacingBetweenTicks = 0.0;\n        for(TY tickY : ticksY) {\n            textForMeasuring.setText(fnFormatY.apply(tickY));\n            maxWidth = Math.max(maxWidth, textForMeasuring.getLayoutBounds().getWidth());\n            pxMinSpacingBetweenTicks = Math.max(pxMinSpacingBetweenTicks, 2.0 * textForMeasuring.getLayoutBounds().getHeight());\n        }\n        double maxHeight = 0.0;\n        for(TX tickX : ticksX) {\n            \/\/X-labels are displayed at a 30-degree incline.\n            \/\/The approximate width of the rotated text is 0.87*{width}\n            \/\/The distance from the top of the bounding to the origin from which text should be drawn is 0.5*{length} + 0.87*{height}\n            textForMeasuring.setText(fnFormatX.apply(tickX));\n            final Bounds boundsText = textForMeasuring.getLayoutBounds();\n            maxHeight = Math.max(maxHeight, 0.5 * boundsText.getWidth() + 0.87 * boundsText.getHeight());\n            \/\/TODO: Also check maxWidth against the amount by which this would underflow the X=0 line\n        }\n        final Rectangle2D sizeAxisLabel = new Rectangle2D(0.0, 0.0, maxWidth, maxHeight);\n        if(getWidth() <= sizeAxisLabel.getWidth() || getHeight() <= sizeAxisLabel.getHeight()) {\n            return;\n        }\n        rectChart = new Rectangle2D(sizeAxisLabel.getWidth() + pxTickLength, 0.0, getWidth() - sizeAxisLabel.getWidth() - pxTickLength, getHeight() - sizeAxisLabel.getHeight() - pxTickLength);\n        \/\/ Render series data, build tooltip cache\n        renderedPoints.clear();\n        for(Map.Entry<Series, LinkedList<T>> entry : data.entrySet()) {\n            Point2D ptPrev = null;\n            gc.setStroke(entry.getKey().getColor());\n            \/\/TODO: Make this customizable\n            gc.setLineWidth(2.0);\n            for(T value : entry.getValue()) {\n                TX x = fnXValue.apply(value);\n                TY y = fnYValue.apply(value);\n                \/\/ Add rectViewport.getMinY() instead of subtracting because we're mirroring the Y coordinate around the X-axis.\n                Point2D ptNew = new Point2D(\n                        chartXFromDataX(axisX, x),\n                        chartYFromDataY(axisY, y));\n                Point<T, TX, TY> pt = new Point<>(\n                        value,\n                        x,\n                        y,\n                        ptNew,\n                        entry.getKey().getColor()\n                );\n                renderedPoints.add(pt);\n                if(ptPrev != null) {\n                    gc.strokeLine(ptPrev.getX(), ptPrev.getY(), ptNew.getX(), ptNew.getY());\n                }\n                gc.strokeOval(ptNew.getX() - pointRadius, ptNew.getY() - pointRadius, pointRadius * 2, pointRadius * 2);\n                ptPrev = ptNew;\n            }\n        }\n        \/\/ Render axes (last so it overwrites any values near an axis)\n        \/\/Clear the axis area\n        gc.clearRect(0.0, 0.0, sizeAxisLabel.getWidth() + pxTickLength, getHeight());\n        gc.clearRect(0.0, getHeight() - sizeAxisLabel.getHeight() - pxTickLength, getWidth(), sizeAxisLabel.getHeight());\n        \/\/Draw the axes\n        gc.setStroke(Color.BLACK);\n        gc.setLineWidth(0.5);\n        gc.strokeLine(rectChart.getMinX(), 0.0, rectChart.getMinX(), rectChart.getMaxY());\n        gc.strokeLine(rectChart.getMinX(), rectChart.getMaxY(), rectChart.getMaxX(), rectChart.getMaxY());\n        Font font = Font.font(\"MONOSPACE\", 12.0);\n        gc.setFont(font);\n        \/\/ticksX and ticksY are lists of the corresponding values; they need to be handed of to the corresponding fnNormalize and then scaled for display.\n        double pxLast = -pxMinSpacingBetweenTicks;\n        for(TX tickX : ticksX) {\n            final double pxX = chartXFromDataX(axisX, tickX);\n            if(pxLast + pxMinSpacingBetweenTicks > pxX) {\n                continue;\n            }\n            pxLast = pxX;\n            gc.strokeLine(pxX, rectChart.getMaxY(), pxX, rectChart.getMaxY() + pxTickLength);\n            final String textLabel = fnFormatX.apply(tickX);\n            textForMeasuring.setText(textLabel);\n            final Bounds boundsText = textForMeasuring.getLayoutBounds();\n            double offsetY = 0.5 * boundsText.getWidth() + 0.87 * boundsText.getHeight();\n            double offsetX = -0.87 * boundsText.getWidth();\n            gc.save();\n            \/\/ Translate then rotate to rotate text around local origin rather than rotating around the canvas origin.\n            \/\/ Rotating and drawing at an offset results in a rotation around the origin.\n            gc.translate(pxX + offsetX, rectChart.getMaxY() + offsetY);\n            gc.rotate(-30.0);\n            gc.strokeText(textLabel, 0.0, 0.0);\n            gc.restore();\n        }\n        for(TY tickY : ticksY) {\n            final double pxY = chartYFromDataY(axisY, tickY);\n            gc.strokeLine(rectChart.getMinX() - pxTickLength, pxY, rectChart.getMinX(), pxY);\n            final String textLabel = fnFormatY.apply(tickY);\n            textForMeasuring.setText(textLabel);\n            gc.strokeText(fnFormatY.apply(tickY), 0.0, pxY + textForMeasuring.getLayoutBounds().getHeight());\n        }\n    }","code_wo_comment":"protected void paint(GraphicsContext gc) {\n       \n        Rectangle2D rectViewport = viewport;\n        HashMap<Series, LinkedList<T>> data = new HashMap<>();\n        for(Series<T> series : this.series) {\n            LinkedList<T> seriesData = new LinkedList<>(series.getData());\n            seriesData.sort((o1, o2) -> fnXValue.apply(o1).compareTo(fnXValue.apply(o2)));\n            data.put(series, seriesData);\n        }\n       \n        if(data.size() == 0) {\n            return;\n        }\n        if(data.values().stream().flatMap(LinkedList::stream).count() == 0) {\n            return;\n        }\n       \n        Range<TX> axisX;\n        Range<TY> axisY;\n       \n        if(rangeX != null) {\n            axisX = new Range<>(\n                    rangeX.min == null ? data.values().stream().flatMap(LinkedList::stream).map(fnXValue).min(TX::compareTo).get() : rangeX.min,\n                    rangeX.max == null ? data.values().stream().flatMap(LinkedList::stream).map(fnXValue).max(TX::compareTo).get() : rangeX.max\n            );\n        } else {\n            axisX = new Range<>(\n                    data.values().stream().flatMap(LinkedList::stream).map(fnXValue).min(TX::compareTo).get(),\n                    data.values().stream().flatMap(LinkedList::stream).map(fnXValue).max(TX::compareTo).get()\n            );\n        }\n        if(rangeY != null) {\n            axisY = new Range<>(\n                    rangeY.min == null ? data.values().stream().flatMap(LinkedList::stream).map(fnYValue).min(TY::compareTo).get() : rangeY.min,\n                    rangeY.max == null ? data.values().stream().flatMap(LinkedList::stream).map(fnYValue).max(TY::compareTo).get() : rangeY.max\n            );\n        } else {\n            axisY = new Range<>(\n                    data.values().stream().flatMap(LinkedList::stream).map(fnYValue).min(TY::compareTo).get(),\n                    data.values().stream().flatMap(LinkedList::stream).map(fnYValue).max(TY::compareTo).get()\n            );\n        }\n        final List<TX> ticksX = fnTicksX.generateTicks(axisX, viewport.getMinX(), viewport.getMaxX());\n       \n       \n        final List<TY> ticksY = fnTicksY.generateTicks(axisY, viewport.getMinY(), viewport.getMaxY());\n       \n       \n        double maxWidth = 0.0;\n        double pxMinSpacingBetweenTicks = 0.0;\n        for(TY tickY : ticksY) {\n            textForMeasuring.setText(fnFormatY.apply(tickY));\n            maxWidth = Math.max(maxWidth, textForMeasuring.getLayoutBounds().getWidth());\n            pxMinSpacingBetweenTicks = Math.max(pxMinSpacingBetweenTicks, 2.0 * textForMeasuring.getLayoutBounds().getHeight());\n        }\n        double maxHeight = 0.0;\n        for(TX tickX : ticksX) {\n           \n           \n           \n            textForMeasuring.setText(fnFormatX.apply(tickX));\n            final Bounds boundsText = textForMeasuring.getLayoutBounds();\n            maxHeight = Math.max(maxHeight, 0.5 * boundsText.getWidth() + 0.87 * boundsText.getHeight());\n           \n        }\n        final Rectangle2D sizeAxisLabel = new Rectangle2D(0.0, 0.0, maxWidth, maxHeight);\n        if(getWidth() <= sizeAxisLabel.getWidth() || getHeight() <= sizeAxisLabel.getHeight()) {\n            return;\n        }\n        rectChart = new Rectangle2D(sizeAxisLabel.getWidth() + pxTickLength, 0.0, getWidth() - sizeAxisLabel.getWidth() - pxTickLength, getHeight() - sizeAxisLabel.getHeight() - pxTickLength);\n       \n        renderedPoints.clear();\n        for(Map.Entry<Series, LinkedList<T>> entry : data.entrySet()) {\n            Point2D ptPrev = null;\n            gc.setStroke(entry.getKey().getColor());\n           \n            gc.setLineWidth(2.0);\n            for(T value : entry.getValue()) {\n                TX x = fnXValue.apply(value);\n                TY y = fnYValue.apply(value);\n               \n                Point2D ptNew = new Point2D(\n                        chartXFromDataX(axisX, x),\n                        chartYFromDataY(axisY, y));\n                Point<T, TX, TY> pt = new Point<>(\n                        value,\n                        x,\n                        y,\n                        ptNew,\n                        entry.getKey().getColor()\n                );\n                renderedPoints.add(pt);\n                if(ptPrev != null) {\n                    gc.strokeLine(ptPrev.getX(), ptPrev.getY(), ptNew.getX(), ptNew.getY());\n                }\n                gc.strokeOval(ptNew.getX() - pointRadius, ptNew.getY() - pointRadius, pointRadius * 2, pointRadius * 2);\n                ptPrev = ptNew;\n            }\n        }\n       \n       \n        gc.clearRect(0.0, 0.0, sizeAxisLabel.getWidth() + pxTickLength, getHeight());\n        gc.clearRect(0.0, getHeight() - sizeAxisLabel.getHeight() - pxTickLength, getWidth(), sizeAxisLabel.getHeight());\n       \n        gc.setStroke(Color.BLACK);\n        gc.setLineWidth(0.5);\n        gc.strokeLine(rectChart.getMinX(), 0.0, rectChart.getMinX(), rectChart.getMaxY());\n        gc.strokeLine(rectChart.getMinX(), rectChart.getMaxY(), rectChart.getMaxX(), rectChart.getMaxY());\n        Font font = Font.font(\"MONOSPACE\", 12.0);\n        gc.setFont(font);\n       \n        double pxLast = -pxMinSpacingBetweenTicks;\n        for(TX tickX : ticksX) {\n            final double pxX = chartXFromDataX(axisX, tickX);\n            if(pxLast + pxMinSpacingBetweenTicks > pxX) {\n                continue;\n            }\n            pxLast = pxX;\n            gc.strokeLine(pxX, rectChart.getMaxY(), pxX, rectChart.getMaxY() + pxTickLength);\n            final String textLabel = fnFormatX.apply(tickX);\n            textForMeasuring.setText(textLabel);\n            final Bounds boundsText = textForMeasuring.getLayoutBounds();\n            double offsetY = 0.5 * boundsText.getWidth() + 0.87 * boundsText.getHeight();\n            double offsetX = -0.87 * boundsText.getWidth();\n            gc.save();\n           \n           \n            gc.translate(pxX + offsetX, rectChart.getMaxY() + offsetY);\n            gc.rotate(-30.0);\n            gc.strokeText(textLabel, 0.0, 0.0);\n            gc.restore();\n        }\n        for(TY tickY : ticksY) {\n            final double pxY = chartYFromDataY(axisY, tickY);\n            gc.strokeLine(rectChart.getMinX() - pxTickLength, pxY, rectChart.getMinX(), pxY);\n            final String textLabel = fnFormatY.apply(tickY);\n            textForMeasuring.setText(textLabel);\n            gc.strokeText(fnFormatY.apply(tickY), 0.0, pxY + textForMeasuring.getLayoutBounds().getHeight());\n        }\n    }","cleancode":"protected void paint(graphicscontext gc) { rectangle2d rectviewport = viewport; hashmap<series, linkedlist<t>> data = new hashmap<>(); for(series<t> series : this.series) { linkedlist<t> seriesdata = new linkedlist<>(series.getdata()); seriesdata.sort((o1, o2) -> fnxvalue.apply(o1).compareto(fnxvalue.apply(o2))); data.put(series, seriesdata); } if(data.size() == 0) { return; } if(data.values().stream().flatmap(linkedlist::stream).count() == 0) { return; } range<tx> axisx; range<ty> axisy; if(rangex != null) { axisx = new range<>( rangex.min == null ? data.values().stream().flatmap(linkedlist::stream).map(fnxvalue).min(tx::compareto).get() : rangex.min, rangex.max == null ? data.values().stream().flatmap(linkedlist::stream).map(fnxvalue).max(tx::compareto).get() : rangex.max ); } else { axisx = new range<>( data.values().stream().flatmap(linkedlist::stream).map(fnxvalue).min(tx::compareto).get(), data.values().stream().flatmap(linkedlist::stream).map(fnxvalue).max(tx::compareto).get() ); } if(rangey != null) { axisy = new range<>( rangey.min == null ? data.values().stream().flatmap(linkedlist::stream).map(fnyvalue).min(ty::compareto).get() : rangey.min, rangey.max == null ? data.values().stream().flatmap(linkedlist::stream).map(fnyvalue).max(ty::compareto).get() : rangey.max ); } else { axisy = new range<>( data.values().stream().flatmap(linkedlist::stream).map(fnyvalue).min(ty::compareto).get(), data.values().stream().flatmap(linkedlist::stream).map(fnyvalue).max(ty::compareto).get() ); } final list<tx> ticksx = fnticksx.generateticks(axisx, viewport.getminx(), viewport.getmaxx()); final list<ty> ticksy = fnticksy.generateticks(axisy, viewport.getminy(), viewport.getmaxy()); double maxwidth = 0.0; double pxminspacingbetweenticks = 0.0; for(ty ticky : ticksy) { textformeasuring.settext(fnformaty.apply(ticky)); maxwidth = math.max(maxwidth, textformeasuring.getlayoutbounds().getwidth()); pxminspacingbetweenticks = math.max(pxminspacingbetweenticks, 2.0 * textformeasuring.getlayoutbounds().getheight()); } double maxheight = 0.0; for(tx tickx : ticksx) { textformeasuring.settext(fnformatx.apply(tickx)); final bounds boundstext = textformeasuring.getlayoutbounds(); maxheight = math.max(maxheight, 0.5 * boundstext.getwidth() + 0.87 * boundstext.getheight()); } final rectangle2d sizeaxislabel = new rectangle2d(0.0, 0.0, maxwidth, maxheight); if(getwidth() <= sizeaxislabel.getwidth() || getheight() <= sizeaxislabel.getheight()) { return; } rectchart = new rectangle2d(sizeaxislabel.getwidth() + pxticklength, 0.0, getwidth() - sizeaxislabel.getwidth() - pxticklength, getheight() - sizeaxislabel.getheight() - pxticklength); renderedpoints.clear(); for(map.entry<series, linkedlist<t>> entry : data.entryset()) { point2d ptprev = null; gc.setstroke(entry.getkey().getcolor()); gc.setlinewidth(2.0); for(t value : entry.getvalue()) { tx x = fnxvalue.apply(value); ty y = fnyvalue.apply(value); point2d ptnew = new point2d( chartxfromdatax(axisx, x), chartyfromdatay(axisy, y)); point<t, tx, ty> pt = new point<>( value, x, y, ptnew, entry.getkey().getcolor() ); renderedpoints.add(pt); if(ptprev != null) { gc.strokeline(ptprev.getx(), ptprev.gety(), ptnew.getx(), ptnew.gety()); } gc.strokeoval(ptnew.getx() - pointradius, ptnew.gety() - pointradius, pointradius * 2, pointradius * 2); ptprev = ptnew; } } gc.clearrect(0.0, 0.0, sizeaxislabel.getwidth() + pxticklength, getheight()); gc.clearrect(0.0, getheight() - sizeaxislabel.getheight() - pxticklength, getwidth(), sizeaxislabel.getheight()); gc.setstroke(color.black); gc.setlinewidth(0.5); gc.strokeline(rectchart.getminx(), 0.0, rectchart.getminx(), rectchart.getmaxy()); gc.strokeline(rectchart.getminx(), rectchart.getmaxy(), rectchart.getmaxx(), rectchart.getmaxy()); font font = font.font(\"monospace\", 12.0); gc.setfont(font); double pxlast = -pxminspacingbetweenticks; for(tx tickx : ticksx) { final double pxx = chartxfromdatax(axisx, tickx); if(pxlast + pxminspacingbetweenticks > pxx) { continue; } pxlast = pxx; gc.strokeline(pxx, rectchart.getmaxy(), pxx, rectchart.getmaxy() + pxticklength); final string textlabel = fnformatx.apply(tickx); textformeasuring.settext(textlabel); final bounds boundstext = textformeasuring.getlayoutbounds(); double offsety = 0.5 * boundstext.getwidth() + 0.87 * boundstext.getheight(); double offsetx = -0.87 * boundstext.getwidth(); gc.save(); gc.translate(pxx + offsetx, rectchart.getmaxy() + offsety); gc.rotate(-30.0); gc.stroketext(textlabel, 0.0, 0.0); gc.restore(); } for(ty ticky : ticksy) { final double pxy = chartyfromdatay(axisy, ticky); gc.strokeline(rectchart.getminx() - pxticklength, pxy, rectchart.getminx(), pxy); final string textlabel = fnformaty.apply(ticky); textformeasuring.settext(textlabel); gc.stroketext(fnformaty.apply(ticky), 0.0, pxy + textformeasuring.getlayoutbounds().getheight()); } }","repo":"nathanawmk\/ICS-Security-Tools","label":[1,1,0,0]}
{"id":12044,"original_code":"private void createView() {\n        FontIcon closeBtn = Controls.fontIcon(Material2AL.CLOSE, \"close-icon\");\n        closeBtn.setCursor(Cursor.HAND);\n        closeBtn.setOnMouseClicked(e -> close());\n        GridPane.setValignment(closeBtn, VPos.TOP);\n        GridPane.setHalignment(closeBtn, HPos.RIGHT);\n        TextFlow textFlow = Containers.create(TextFlow::new, \"text\");\n        \/\/ sadly setMaxHeight() isn't working with TextFlow\n        \/\/ so, we have to clip notification text manually\n        Text text = new Text(notification.getClippedText(Toast.MAX_MESSAGE_LEN));\n        textFlow.getChildren().addAll(text);\n        Hyperlink expandBtn = new Hyperlink(t(ACTION_MORE));\n        expandBtn.setOnAction(e -> expand());\n        if (expandHandler == null) { expandBtn.setManaged(false); }\n        add(textFlow, 0, 0);\n        add(closeBtn, 1, 0);\n        add(expandBtn, 0, 2, REMAINING, 1);\n        getColumnConstraints().addAll(HGROW_ALWAYS, HGROW_NEVER);\n        getRowConstraints().addAll(VGROW_ALWAYS, VGROW_NEVER);\n        VBox.setVgrow(this, Priority.NEVER);\n        getStyleClass().addAll(\"toast\", notification.getType().name().toLowerCase());\n    }","code_wo_comment":"private void createView() {\n        FontIcon closeBtn = Controls.fontIcon(Material2AL.CLOSE, \"close-icon\");\n        closeBtn.setCursor(Cursor.HAND);\n        closeBtn.setOnMouseClicked(e -> close());\n        GridPane.setValignment(closeBtn, VPos.TOP);\n        GridPane.setHalignment(closeBtn, HPos.RIGHT);\n        TextFlow textFlow = Containers.create(TextFlow::new, \"text\");\n       \n       \n        Text text = new Text(notification.getClippedText(Toast.MAX_MESSAGE_LEN));\n        textFlow.getChildren().addAll(text);\n        Hyperlink expandBtn = new Hyperlink(t(ACTION_MORE));\n        expandBtn.setOnAction(e -> expand());\n        if (expandHandler == null) { expandBtn.setManaged(false); }\n        add(textFlow, 0, 0);\n        add(closeBtn, 1, 0);\n        add(expandBtn, 0, 2, REMAINING, 1);\n        getColumnConstraints().addAll(HGROW_ALWAYS, HGROW_NEVER);\n        getRowConstraints().addAll(VGROW_ALWAYS, VGROW_NEVER);\n        VBox.setVgrow(this, Priority.NEVER);\n        getStyleClass().addAll(\"toast\", notification.getType().name().toLowerCase());\n    }","cleancode":"private void createview() { fonticon closebtn = controls.fonticon(material2al.close, \"close-icon\"); closebtn.setcursor(cursor.hand); closebtn.setonmouseclicked(e -> close()); gridpane.setvalignment(closebtn, vpos.top); gridpane.sethalignment(closebtn, hpos.right); textflow textflow = containers.create(textflow::new, \"text\"); text text = new text(notification.getclippedtext(toast.max_message_len)); textflow.getchildren().addall(text); hyperlink expandbtn = new hyperlink(t(action_more)); expandbtn.setonaction(e -> expand()); if (expandhandler == null) { expandbtn.setmanaged(false); } add(textflow, 0, 0); add(closebtn, 1, 0); add(expandbtn, 0, 2, remaining, 1); getcolumnconstraints().addall(hgrow_always, hgrow_never); getrowconstraints().addall(vgrow_always, vgrow_never); vbox.setvgrow(this, priority.never); getstyleclass().addall(\"toast\", notification.gettype().name().tolowercase()); }","repo":"mkpaz\/telek","label":[0,0,0,0]}
{"id":12086,"original_code":"public static void main(String[] args) {\n        \/\/ TODO code application logic here\n        \/\/ cria o objeto Scanner\n        Scanner input = new Scanner(System.in);\n        \/\/ entrada de dados\n        System.out.print(\"Digite tr\u00eas n\u00fameros de ponto-flutuante: \");\n        double numero1 = input.nextDouble(); \/\/ primeiro n\u00famero\n        double numero2 = input.nextDouble(); \/\/ segundo n\u00famero\n        double numero3 = input.nextDouble(); \/\/ terceiro n\u00famero\n        \/\/ detremina o maior valor\n        double resultado = maiorValor( numero1, numero2, numero3 );\n        \/\/ imprime resultado\n        System.out.printf(\"O maior valor \u00e9 %.2f%n\", resultado );\n    }","code_wo_comment":"public static void main(String[] args) {\n       \n       \n        Scanner input = new Scanner(System.in);\n       \n        System.out.print(\"Digite tr\u00eas n\u00fameros de ponto-flutuante: \");\n        double numero1 = input.nextDouble();        double numero2 = input.nextDouble();        double numero3 = input.nextDouble();       \n        double resultado = maiorValor( numero1, numero2, numero3 );\n       \n        System.out.printf(\"O maior valor \u00e9 %.2f%n\", resultado );\n    }","cleancode":"public static void main(string[] args) { scanner input = new scanner(system.in); system.out.print(\"digite tr\u00eas n\u00fameros de ponto-flutuante: \"); double numero1 = input.nextdouble(); double numero2 = input.nextdouble(); double numero3 = input.nextdouble(); double resultado = maiorvalor( numero1, numero2, numero3 ); system.out.printf(\"o maior valor \u00e9 %.2f%n\", resultado ); }","repo":"pedro-filho-81\/LivrosDeJava","label":[0,1,0,0]}
{"id":20687,"original_code":"@Test\n    public void fetchExistingAggregateById_populatesValues()\n    {\n        try(PhotonTransaction transaction = photon.beginTransaction())\n        {\n            PhotonTestTable photonTestTable = transaction.query(PhotonTestTable.class).fetchById(1);\n            \/\/ The database does not store a time zone, so we assume the date is in the system's time zone. But to make these tests\n            \/\/ compare epoch times but still work with any system time zone, we have to offset the epoch to the system's time zone.\n            int currentUtcOffset = TimeZone.getDefault().getOffset(new Date().getTime());\n            assertNotNull(photonTestTable);\n            assertEquals(1, photonTestTable.getId());\n            assertEquals(UUID.fromString(\"8ED1E1BD-253E-4469-B4CB-71E1217825B7\"), photonTestTable.getUuidColumn());\n            assertEquals(ZonedDateTime.ofInstant(Instant.ofEpochMilli(1489915698000L - currentUtcOffset), ZoneId.systemDefault()), photonTestTable.getDateColumn());\n            assertEquals(\"Test String\", photonTestTable.getVarcharColumn());\n        }\n    }","code_wo_comment":"@Test\n    public void fetchExistingAggregateById_populatesValues()\n    {\n        try(PhotonTransaction transaction = photon.beginTransaction())\n        {\n            PhotonTestTable photonTestTable = transaction.query(PhotonTestTable.class).fetchById(1);\n           \n           \n            int currentUtcOffset = TimeZone.getDefault().getOffset(new Date().getTime());\n            assertNotNull(photonTestTable);\n            assertEquals(1, photonTestTable.getId());\n            assertEquals(UUID.fromString(\"8ED1E1BD-253E-4469-B4CB-71E1217825B7\"), photonTestTable.getUuidColumn());\n            assertEquals(ZonedDateTime.ofInstant(Instant.ofEpochMilli(1489915698000L - currentUtcOffset), ZoneId.systemDefault()), photonTestTable.getDateColumn());\n            assertEquals(\"Test String\", photonTestTable.getVarcharColumn());\n        }\n    }","cleancode":"@test public void fetchexistingaggregatebyid_populatesvalues() { try(photontransaction transaction = photon.begintransaction()) { photontesttable photontesttable = transaction.query(photontesttable.class).fetchbyid(1); int currentutcoffset = timezone.getdefault().getoffset(new date().gettime()); assertnotnull(photontesttable); assertequals(1, photontesttable.getid()); assertequals(uuid.fromstring(\"8ed1e1bd-253e-4469-b4cb-71e1217825b7\"), photontesttable.getuuidcolumn()); assertequals(zoneddatetime.ofinstant(instant.ofepochmilli(1489915698000l - currentutcoffset), zoneid.systemdefault()), photontesttable.getdatecolumn()); assertequals(\"test string\", photontesttable.getvarcharcolumn()); } }","repo":"molcikas\/photon","label":[0,0,1,0]}
{"id":12596,"original_code":"public static BufferedImage boofCVBinarization(BufferedImage image, int threshold) {\n\t\tGrayU8 input8 = ConvertBufferedImage.convertFrom(image,(GrayU8)null);\n\t\tGrayF32 input32 = ConvertBufferedImage.convertFromSingle(image, null, GrayF32.class);\n\t\tGrayU8 binary8 = new GrayU8(input8.getWidth(), input8.getHeight());\n\/\/\t\tGrayF32 binary32 = new GrayF32(input8.getWidth(), input8.getHeight());\n\t\tboolean down = false;\n\t\tThresholdImageOps.threshold(input8, binary8, threshold, down);\n\/\/\t\tGThresholdImageOps.threshold(input32, binary8, threshold, down);\n\t\tBufferedImage outputImage = null;\n\/\/\t\toutputImage =\tConvertBufferedImage.convertTo(binary8, null);\n\t\tboolean invert = false;\n\t\toutputImage = VisualizeBinaryData.renderBinary(binary8, invert, null);\n\t\t\/\/ \n\/\/\t\toutputImage = ImageUtil.removeAlpha(outputImage);\n\/\/\t\toutputImage = ImageUtil.convertRGB(outputImage, \n\/\/\t\t\t\tnew int[] {0x0d0d0d}, new int[] {0xffffff});\n\t\treturn outputImage;\n\t}","code_wo_comment":"public static BufferedImage boofCVBinarization(BufferedImage image, int threshold) {\n\t\tGrayU8 input8 = ConvertBufferedImage.convertFrom(image,(GrayU8)null);\n\t\tGrayF32 input32 = ConvertBufferedImage.convertFromSingle(image, null, GrayF32.class);\n\t\tGrayU8 binary8 = new GrayU8(input8.getWidth(), input8.getHeight());\n\t\tboolean down = false;\n\t\tThresholdImageOps.threshold(input8, binary8, threshold, down);\n\t\tBufferedImage outputImage = null;\n\t\tboolean invert = false;\n\t\toutputImage = VisualizeBinaryData.renderBinary(binary8, invert, null);\n\t\n\t\treturn outputImage;\n\t}","cleancode":"public static bufferedimage boofcvbinarization(bufferedimage image, int threshold) { grayu8 input8 = convertbufferedimage.convertfrom(image,(grayu8)null); grayf32 input32 = convertbufferedimage.convertfromsingle(image, null, grayf32.class); grayu8 binary8 = new grayu8(input8.getwidth(), input8.getheight()); boolean down = false; thresholdimageops.threshold(input8, binary8, threshold, down); bufferedimage outputimage = null; boolean invert = false; outputimage = visualizebinarydata.renderbinary(binary8, invert, null); return outputimage; }","repo":"nuest\/ami3","label":[0,0,1,0]}
{"id":20812,"original_code":"static int examineVar(final int var, final ArrayList<Read> list, final IntList collection, final int[] rvector, LinkedHashMap<Integer, ArrayList<Read>> map){\n\t\tcollection.clear();\n\t\tfor(Read r : list){\n\t\t\tfinal ReadKey rk=(ReadKey) r.obj;\n\t\t\tfinal IntList vars=rk.vars;\n\t\t\tfor(int i=0; i<vars.size; i++){\n\t\t\t\tfinal int v2=vars.get(i);\n\t\t\t\tif(v2!=var){\n\t\t\t\t\tcollection.add(v2);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcollection.sort();\n\t\tfinal int varCount=list.size();\n\t\tint lastVar2=-1, bestVar2=-1;\n\t\tint sharedCount=0, bestSharedCount=0, bestDifferent=999;\n\t\tfor(int i=0; i<collection.size; i++){\/\/TODO: Note that not all reads actually cover a given var\n\t\t\tint currentVar2=collection.get(i);\n\t\t\tif(currentVar2==lastVar2){sharedCount++;}\n\t\t\telse{\n\t\t\t\tif(sharedCount>bestSharedCount){\n\t\t\t\t\tfinal int different1=(sharedCount==varCount ? 0 : countDifferentAlleles(lastVar2, list));\n\t\t\t\t\tif(different1*8<varCount){\n\t\t\t\t\t\tArrayList<Read> list2=map.get(lastVar2);\n\t\t\t\t\t\tfinal int varCount2=(list2==null ? 0 : list2.size());\n\t\t\t\t\t\tfinal int different2=(sharedCount==varCount2 ? 0 : countDifferentAlleles(var, list2));\n\t\t\t\t\t\tif(different2*8<varCount2){\n\t\t\t\t\t\t\tbestVar2=lastVar2;\n\t\t\t\t\t\t\tbestSharedCount=sharedCount;\n\t\t\t\t\t\t\tbestDifferent=Tools.max(different1, different2);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tsharedCount=1;\n\t\t\t}\n\t\t\tlastVar2=currentVar2;\n\t\t}\n\t\tif(sharedCount>bestSharedCount){\n\t\t\tfinal int different1=(sharedCount==varCount ? 0 : countDifferentAlleles(lastVar2, list));\n\t\t\tif(different1*8<varCount){\n\t\t\t\tArrayList<Read> list2=map.get(lastVar2);\n\t\t\t\tfinal int varCount2=(list2==null ? 0 : list2.size());\n\t\t\t\tfinal int different2=(sharedCount==varCount2 ? 0 : countDifferentAlleles(var, list2));\n\t\t\t\tif(different2*8<varCount2){\n\t\t\t\t\tbestVar2=lastVar2;\n\t\t\t\t\tbestSharedCount=sharedCount;\n\t\t\t\t\tbestDifferent=Tools.max(different1, different2);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\trvector[0]=var;\n\t\trvector[1]=list.size();\n\t\trvector[2]=bestVar2;\n\t\trvector[3]=sharedCount;\n\t\trvector[4]=bestDifferent;\n\t\treturn bestVar2;\n\t}","code_wo_comment":"static int examineVar(final int var, final ArrayList<Read> list, final IntList collection, final int[] rvector, LinkedHashMap<Integer, ArrayList<Read>> map){\n\t\tcollection.clear();\n\t\tfor(Read r : list){\n\t\t\tfinal ReadKey rk=(ReadKey) r.obj;\n\t\t\tfinal IntList vars=rk.vars;\n\t\t\tfor(int i=0; i<vars.size; i++){\n\t\t\t\tfinal int v2=vars.get(i);\n\t\t\t\tif(v2!=var){\n\t\t\t\t\tcollection.add(v2);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcollection.sort();\n\t\tfinal int varCount=list.size();\n\t\tint lastVar2=-1, bestVar2=-1;\n\t\tint sharedCount=0, bestSharedCount=0, bestDifferent=999;\n\t\tfor(int i=0; i<collection.size; i++)\n\t\t\tint currentVar2=collection.get(i);\n\t\t\tif(currentVar2==lastVar2){sharedCount++;}\n\t\t\telse{\n\t\t\t\tif(sharedCount>bestSharedCount){\n\t\t\t\t\tfinal int different1=(sharedCount==varCount ? 0 : countDifferentAlleles(lastVar2, list));\n\t\t\t\t\tif(different1*8<varCount){\n\t\t\t\t\t\tArrayList<Read> list2=map.get(lastVar2);\n\t\t\t\t\t\tfinal int varCount2=(list2==null ? 0 : list2.size());\n\t\t\t\t\t\tfinal int different2=(sharedCount==varCount2 ? 0 : countDifferentAlleles(var, list2));\n\t\t\t\t\t\tif(different2*8<varCount2){\n\t\t\t\t\t\t\tbestVar2=lastVar2;\n\t\t\t\t\t\t\tbestSharedCount=sharedCount;\n\t\t\t\t\t\t\tbestDifferent=Tools.max(different1, different2);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tsharedCount=1;\n\t\t\t}\n\t\t\tlastVar2=currentVar2;\n\t\t}\n\t\tif(sharedCount>bestSharedCount){\n\t\t\tfinal int different1=(sharedCount==varCount ? 0 : countDifferentAlleles(lastVar2, list));\n\t\t\tif(different1*8<varCount){\n\t\t\t\tArrayList<Read> list2=map.get(lastVar2);\n\t\t\t\tfinal int varCount2=(list2==null ? 0 : list2.size());\n\t\t\t\tfinal int different2=(sharedCount==varCount2 ? 0 : countDifferentAlleles(var, list2));\n\t\t\t\tif(different2*8<varCount2){\n\t\t\t\t\tbestVar2=lastVar2;\n\t\t\t\t\tbestSharedCount=sharedCount;\n\t\t\t\t\tbestDifferent=Tools.max(different1, different2);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\trvector[0]=var;\n\t\trvector[1]=list.size();\n\t\trvector[2]=bestVar2;\n\t\trvector[3]=sharedCount;\n\t\trvector[4]=bestDifferent;\n\t\treturn bestVar2;\n\t}","cleancode":"static int examinevar(final int var, final arraylist<read> list, final intlist collection, final int[] rvector, linkedhashmap<integer, arraylist<read>> map){ collection.clear(); for(read r : list){ final readkey rk=(readkey) r.obj; final intlist vars=rk.vars; for(int i=0; i<vars.size; i++){ final int v2=vars.get(i); if(v2!=var){ collection.add(v2); } } } collection.sort(); final int varcount=list.size(); int lastvar2=-1, bestvar2=-1; int sharedcount=0, bestsharedcount=0, bestdifferent=999; for(int i=0; i<collection.size; i++) int currentvar2=collection.get(i); if(currentvar2==lastvar2){sharedcount++;} else{ if(sharedcount>bestsharedcount){ final int different1=(sharedcount==varcount ? 0 : countdifferentalleles(lastvar2, list)); if(different1*8<varcount){ arraylist<read> list2=map.get(lastvar2); final int varcount2=(list2==null ? 0 : list2.size()); final int different2=(sharedcount==varcount2 ? 0 : countdifferentalleles(var, list2)); if(different2*8<varcount2){ bestvar2=lastvar2; bestsharedcount=sharedcount; bestdifferent=tools.max(different1, different2); } } } sharedcount=1; } lastvar2=currentvar2; } if(sharedcount>bestsharedcount){ final int different1=(sharedcount==varcount ? 0 : countdifferentalleles(lastvar2, list)); if(different1*8<varcount){ arraylist<read> list2=map.get(lastvar2); final int varcount2=(list2==null ? 0 : list2.size()); final int different2=(sharedcount==varcount2 ? 0 : countdifferentalleles(var, list2)); if(different2*8<varcount2){ bestvar2=lastvar2; bestsharedcount=sharedcount; bestdifferent=tools.max(different1, different2); } } } rvector[0]=var; rvector[1]=list.size(); rvector[2]=bestvar2; rvector[3]=sharedcount; rvector[4]=bestdifferent; return bestvar2; }","repo":"nedru004\/LibraryAnalysis2","label":[1,0,0,0]}
{"id":12626,"original_code":"@RequestMapping(path = \"\/0\/admin\/applications\/{appId}\/block\", method = RequestMethod.POST)\n\tpublic ResponseEntity<Boolean> updateDeveloperApplication(\n\t\t\t@PathVariable String appId\n\t) {\n\t\t\/\/ Let's get the user from principal and validate the userId against it.\n\t\tUser user = userService.findAuthenticatedUser();\n\t\tif (user == null)\n\t\t\treturn new ResponseEntity<>(HttpStatus.FORBIDDEN);\n\t\t\/\/ TODO check and ensure user is Moderator role\n\t\tApplication application = applicationService.findApplication(appId);\n\t\tif (application == null){\n\t\t\tlogger.debug(\"Application not found pre condition failed\");\n\t\t\treturn new ResponseEntity<>(HttpStatus.PRECONDITION_FAILED);\n\t\t}\t\n\t\t\/\/ TODO what if Application was already blocked?\n\t\tBoolean result = applicationService.blockApplication(application);\n\t\treturn new ResponseEntity<>(result, HttpStatus.OK);\n\t}","code_wo_comment":"@RequestMapping(path = \"\/0\/admin\/applications\/{appId}\/block\", method = RequestMethod.POST)\n\tpublic ResponseEntity<Boolean> updateDeveloperApplication(\n\t\t\t@PathVariable String appId\n\t) {\n\t\n\t\tUser user = userService.findAuthenticatedUser();\n\t\tif (user == null)\n\t\t\treturn new ResponseEntity<>(HttpStatus.FORBIDDEN);\n\t\n\t\tApplication application = applicationService.findApplication(appId);\n\t\tif (application == null){\n\t\t\tlogger.debug(\"Application not found pre condition failed\");\n\t\t\treturn new ResponseEntity<>(HttpStatus.PRECONDITION_FAILED);\n\t\t}\t\n\t\n\t\tBoolean result = applicationService.blockApplication(application);\n\t\treturn new ResponseEntity<>(result, HttpStatus.OK);\n\t}","cleancode":"@requestmapping(path = \"\/0\/admin\/applications\/{appid}\/block\", method = requestmethod.post) public responseentity<boolean> updatedeveloperapplication( @pathvariable string appid ) { user user = userservice.findauthenticateduser(); if (user == null) return new responseentity<>(httpstatus.forbidden); application application = applicationservice.findapplication(appid); if (application == null){ logger.debug(\"application not found pre condition failed\"); return new responseentity<>(httpstatus.precondition_failed); } boolean result = applicationservice.blockapplication(application); return new responseentity<>(result, httpstatus.ok); }","repo":"niuyiming\/alpha-umi","label":[1,1,0,0]}
{"id":13141,"original_code":"private boolean useSwitchingProvider() {\n    if (!isFastInit) {\n      return false;\n    }\n    switch (binding.kind()) {\n      case BOUND_INSTANCE:\n      case COMPONENT:\n      case COMPONENT_DEPENDENCY:\n      case DELEGATE:\n      case MEMBERS_INJECTOR: \/\/ TODO(b\/199889259): Consider optimizing this for fastInit mode.\n        \/\/ These binding kinds avoid SwitchingProvider when the backing instance already exists,\n        \/\/ e.g. a component provider can use FactoryInstance.create(this).\n        return false;\n      case MULTIBOUND_SET:\n      case MULTIBOUND_MAP:\n      case OPTIONAL:\n        \/\/ These binding kinds avoid SwitchingProvider when their are no dependencies,\n        \/\/ e.g. a multibound set with no dependency can use a singleton, SetFactory.empty().\n        return !binding.dependencies().isEmpty();\n      case INJECTION:\n      case PROVISION:\n      case ASSISTED_INJECTION:\n      case ASSISTED_FACTORY:\n      case COMPONENT_PROVISION:\n      case SUBCOMPONENT_CREATOR:\n      case PRODUCTION:\n      case COMPONENT_PRODUCTION:\n      case MEMBERS_INJECTION:\n        return true;\n    }\n    throw new AssertionError(String.format(\"No such binding kind: %s\", binding.kind()));\n  }","code_wo_comment":"private boolean useSwitchingProvider() {\n    if (!isFastInit) {\n      return false;\n    }\n    switch (binding.kind()) {\n      case BOUND_INSTANCE:\n      case COMPONENT:\n      case COMPONENT_DEPENDENCY:\n      case DELEGATE:\n      case MEMBERS_INJECTOR:\n       \n       \n        return false;\n      case MULTIBOUND_SET:\n      case MULTIBOUND_MAP:\n      case OPTIONAL:\n       \n       \n        return !binding.dependencies().isEmpty();\n      case INJECTION:\n      case PROVISION:\n      case ASSISTED_INJECTION:\n      case ASSISTED_FACTORY:\n      case COMPONENT_PROVISION:\n      case SUBCOMPONENT_CREATOR:\n      case PRODUCTION:\n      case COMPONENT_PRODUCTION:\n      case MEMBERS_INJECTION:\n        return true;\n    }\n    throw new AssertionError(String.format(\"No such binding kind: %s\", binding.kind()));\n  }","cleancode":"private boolean useswitchingprovider() { if (!isfastinit) { return false; } switch (binding.kind()) { case bound_instance: case component: case component_dependency: case delegate: case members_injector: return false; case multibound_set: case multibound_map: case optional: return !binding.dependencies().isempty(); case injection: case provision: case assisted_injection: case assisted_factory: case component_provision: case subcomponent_creator: case production: case component_production: case members_injection: return true; } throw new assertionerror(string.format(\"no such binding kind: %s\", binding.kind())); }","repo":"priamm\/dagger","label":[1,0,0,0]}
{"id":13305,"original_code":"@Test\n\tpublic void openPrivateRepository() {\n\t\t\/\/TODO : need to implement. first need to figure out a way to hide the credentials dialog.\n\t}","code_wo_comment":"@Test\n\tpublic void openPrivateRepository() {\n\t\n\t}","cleancode":"@test public void openprivaterepository() { }","repo":"mvm-sap\/ADT_Frontend","label":[0,1,0,0]}
{"id":13339,"original_code":"@Override\n    public void validateDataOnEntry()\n            throws DataModelException {\n        \/\/ TODO auto-generated method stub, to be implemented by parser\n    }","code_wo_comment":"@Override\n    public void validateDataOnEntry()\n            throws DataModelException {\n       \n    }","cleancode":"@override public void validatedataonentry() throws datamodelexception { }","repo":"onekeynet\/OConf","label":[0,1,0,0]}
{"id":13382,"original_code":"private boolean writeResponseBodyToDisk(ResponseBody body) {\n        try {\n            \/\/ todo change the file location\/name according to your needs\n            File futureStudioIconFile = new File(mOtaSaveFilePath);\n            InputStream inputStream = null;\n            OutputStream outputStream = null;\n            try {\n                byte[] fileReader = new byte[1024];\n                long fileSize = body.contentLength();\n                long fileSizeDownloaded = 0;\n                inputStream = body.byteStream();\n                outputStream = new FileOutputStream(futureStudioIconFile);\n                while (true) {\n                    int read = inputStream.read(fileReader);\n                    if (read == -1) {\n                        break;\n                    }\n                    outputStream.write(fileReader, 0, read);\n                    fileSizeDownloaded += read;\n                }\n                outputStream.flush();\n                return true;\n            } catch (IOException e) {\n                return false;\n            } finally {\n                if (inputStream != null) {\n                    inputStream.close();\n                }\n                if (outputStream != null) {\n                    outputStream.close();\n                }\n            }\n        } catch (IOException e) {\n            return false;\n        }\n    }","code_wo_comment":"private boolean writeResponseBodyToDisk(ResponseBody body) {\n        try {\n           \n            File futureStudioIconFile = new File(mOtaSaveFilePath);\n            InputStream inputStream = null;\n            OutputStream outputStream = null;\n            try {\n                byte[] fileReader = new byte[1024];\n                long fileSize = body.contentLength();\n                long fileSizeDownloaded = 0;\n                inputStream = body.byteStream();\n                outputStream = new FileOutputStream(futureStudioIconFile);\n                while (true) {\n                    int read = inputStream.read(fileReader);\n                    if (read == -1) {\n                        break;\n                    }\n                    outputStream.write(fileReader, 0, read);\n                    fileSizeDownloaded += read;\n                }\n                outputStream.flush();\n                return true;\n            } catch (IOException e) {\n                return false;\n            } finally {\n                if (inputStream != null) {\n                    inputStream.close();\n                }\n                if (outputStream != null) {\n                    outputStream.close();\n                }\n            }\n        } catch (IOException e) {\n            return false;\n        }\n    }","cleancode":"private boolean writeresponsebodytodisk(responsebody body) { try { file futurestudioiconfile = new file(motasavefilepath); inputstream inputstream = null; outputstream outputstream = null; try { byte[] filereader = new byte[1024]; long filesize = body.contentlength(); long filesizedownloaded = 0; inputstream = body.bytestream(); outputstream = new fileoutputstream(futurestudioiconfile); while (true) { int read = inputstream.read(filereader); if (read == -1) { break; } outputstream.write(filereader, 0, read); filesizedownloaded += read; } outputstream.flush(); return true; } catch (ioexception e) { return false; } finally { if (inputstream != null) { inputstream.close(); } if (outputstream != null) { outputstream.close(); } } } catch (ioexception e) { return false; } }","repo":"qiaolw\/AndroidTest","label":[1,0,0,0]}
{"id":21838,"original_code":"@Override\n\tpublic void operate(OpContext context) throws ProcessingException {\n\t\tfinal TableDataSource table = (TableDataSource)context.get(tableInput);\n\t\tint ipaTidx = super.getColumnIndex(table, SystemTierType.IPATarget.getName());\n\t\tif(ipaTidx < 0) {\n\t\t\tthrow new ProcessingException(null, \"Table has no \" + SystemTierType.IPATarget.getName() + \" column.\");\n\t\t}\n\t\tint ipaAidx = super.getColumnIndex(table, SystemTierType.IPAActual.getName());\n\t\tif(ipaAidx < 0) {\n\t\t\tthrow new ProcessingException(null, \"Table has no \" + SystemTierType.IPAActual.getName() + \" column.\");\n\t\t}\n\t\t\/\/ group by session if info is available\n\t\t\/\/ TODO make this an option\n\t\tint sessionIdx = super.getColumnIndex(table, \"Session\");\n\t\tboolean ignoreDiacritics = isIgnoreDiacritics();\n\t\tif(context.containsKey(\"ignoreDiacritics\")) {\n\t\t\tignoreDiacritics = (boolean)context.get(\"ignoreDiacritics\");\n\t\t}\n\t\tfinal Map<GroupKey, IpaTernaryTree<List<IPATranscript>>> tokenCounts =\n\t\t\t\tnew LinkedHashMap<>();\n\t\tfor(int row = 0; row < table.getRowCount(); row++) {\n\t\t\tcheckCanceled();\n\t\t\tfinal Object groupVal =\n\t\t\t\t\t(sessionIdx >= 0 ? table.getValueAt(row, sessionIdx) : \"*\");\n\t\t\tfinal GroupKey groupKey = new GroupKey(groupVal, ignoreDiacritics);\n\t\t\tIpaTernaryTree<List<IPATranscript>> tokenCount =\n\t\t\t\t\ttokenCounts.get(groupKey);\n\t\t\tif(tokenCount == null) {\n\t\t\t\ttokenCount = new IpaTernaryTree<>();\n\t\t\t\ttokenCounts.put(groupKey, tokenCount);\n\t\t\t}\n\t\t\tIPATranscript ipaT =\n\t\t\t\t\tIPATranscript.class.cast(table.getValueAt(row, ipaTidx));\n\t\t\tIPATranscript ipaA =\n\t\t\t\t\tIPATranscript.class.cast(table.getValueAt(row, ipaAidx));\n\t\t\tif(ignoreDiacritics) {\n\t\t\t\tipaT = ipaT.removePunctuation().stripDiacritics();\n\t\t\t\tipaA = ipaA.removePunctuation().stripDiacritics();\n\t\t\t}\n\t\t\tList<IPATranscript> productions = tokenCount.get(ipaT);\n\t\t\tif(productions == null) {\n\t\t\t\tproductions = new ArrayList<>();\n\t\t\t\ttokenCount.put(ipaT, productions);\n\t\t\t}\n\t\t\tproductions.add(ipaA);\n\t\t}\n\t\tfinal DefaultTableDataSource outputTable = new DefaultTableDataSource();\n\t\tfor(GroupKey groupKey:tokenCounts.keySet()) {\n\t\t\tfinal Object[] rowData = new Object[7];\n\t\t\t\/\/ produce table\n\t\t\tint numRepatedWords = 0;\n\t\t\tint numAllCorrect = 0;\n\t\t\tint numOneOrMoreCorrect = 0;\n\t\t\tint numSameError = 0;\n\t\t\tint numDifferentErrors = 0;\n\t\t\tfloat sumOfAvgDistances = 0;\n\t\t\tfinal IpaTernaryTree<List<IPATranscript>> tokenCount = tokenCounts.get(groupKey);\n\t\t\tfinal List<IPATranscript> repeatedTokens =\n\t\t\t\t\ttokenCount.keySet().stream()\n\t\t\t\t\t\t.filter( (ipa) -> tokenCount.get(ipa).size() > 1 )\n\t\t\t\t\t\t.collect(Collectors.toList());\n\t\t\tnumRepatedWords = repeatedTokens.size();\n\t\t\tfor(IPATranscript ipa:repeatedTokens) {\n\t\t\t\tcheckCanceled();\n\t\t\t\tint numCorrect = 0;\n\t\t\t\tfinal List<IPATranscript> productions = tokenCount.get(ipa);\n\t\t\t\tfinal Set<IPATranscript> distinctProductions = new LinkedHashSet<>(productions);\n\t\t\t\tfor(IPATranscript production:tokenCount.get(ipa)) {\n\t\t\t\t\tif(TableUtils.checkEquals(ipa, production, false, ignoreDiacritics)) {\n\t\t\t\t\t\t++numCorrect;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif(numCorrect == productions.size()) {\n\t\t\t\t\t++numAllCorrect;\n\t\t\t\t} else {\n\t\t\t\t\tif(numCorrect > 0 && numCorrect < productions.size()) {\n\t\t\t\t\t\t++numOneOrMoreCorrect;\n\t\t\t\t\t}\n\t\t\t\t\tdistinctProductions.remove(ipa);\n\t\t\t\t\tif(distinctProductions.size() == 1) {\n\t\t\t\t\t\t++numSameError;\n\t\t\t\t\t} else {\n\t\t\t\t\t\t++numDifferentErrors;\n\t\t\t\t\t}\n\t\t\t\t\tint totalDistance = 0;\n\t\t\t\t\tfor(IPATranscript production:productions) {\n\t\t\t\t\t\ttotalDistance += LevenshteinDistance.distance(ipa, production);\n\t\t\t\t\t}\n\t\t\t\t\tfloat avg = ((float)totalDistance)\/((float)productions.size());\n\t\t\t\t\tsumOfAvgDistances += avg;\n\t\t\t\t}\n\t\t\t}\n\t\t\t\/\/ append row to table\n\t\t\trowData[0] = groupKey.key;\n\t\t\trowData[1] = numRepatedWords;\n\t\t\trowData[2] = numAllCorrect;\n\t\t\trowData[3] = numOneOrMoreCorrect;\n\t\t\trowData[4] = numSameError;\n\t\t\trowData[5] = numDifferentErrors;\n\t\t\trowData[6] = sumOfAvgDistances \/ numRepatedWords;\n\t\t\toutputTable.addRow(rowData);\n\t\t}\n\t\toutputTable.setColumnTitle(0, \"Session\");\n\t\toutputTable.setColumnTitle(1, \"# Repeated IPA Target\");\n\t\toutputTable.setColumnTitle(2, \"# All Correct\");\n\t\toutputTable.setColumnTitle(3, \"# One or More Correct\");\n\t\toutputTable.setColumnTitle(4, \"# Same Error\");\n\t\toutputTable.setColumnTitle(5, \"# Different Errors\");\n\t\toutputTable.setColumnTitle(6, \"Avg Distance\");\n\t\tcontext.put(tableOutput, outputTable);\n\t}","code_wo_comment":"@Override\n\tpublic void operate(OpContext context) throws ProcessingException {\n\t\tfinal TableDataSource table = (TableDataSource)context.get(tableInput);\n\t\tint ipaTidx = super.getColumnIndex(table, SystemTierType.IPATarget.getName());\n\t\tif(ipaTidx < 0) {\n\t\t\tthrow new ProcessingException(null, \"Table has no \" + SystemTierType.IPATarget.getName() + \" column.\");\n\t\t}\n\t\tint ipaAidx = super.getColumnIndex(table, SystemTierType.IPAActual.getName());\n\t\tif(ipaAidx < 0) {\n\t\t\tthrow new ProcessingException(null, \"Table has no \" + SystemTierType.IPAActual.getName() + \" column.\");\n\t\t}\n\t\n\t\n\t\tint sessionIdx = super.getColumnIndex(table, \"Session\");\n\t\tboolean ignoreDiacritics = isIgnoreDiacritics();\n\t\tif(context.containsKey(\"ignoreDiacritics\")) {\n\t\t\tignoreDiacritics = (boolean)context.get(\"ignoreDiacritics\");\n\t\t}\n\t\tfinal Map<GroupKey, IpaTernaryTree<List<IPATranscript>>> tokenCounts =\n\t\t\t\tnew LinkedHashMap<>();\n\t\tfor(int row = 0; row < table.getRowCount(); row++) {\n\t\t\tcheckCanceled();\n\t\t\tfinal Object groupVal =\n\t\t\t\t\t(sessionIdx >= 0 ? table.getValueAt(row, sessionIdx) : \"*\");\n\t\t\tfinal GroupKey groupKey = new GroupKey(groupVal, ignoreDiacritics);\n\t\t\tIpaTernaryTree<List<IPATranscript>> tokenCount =\n\t\t\t\t\ttokenCounts.get(groupKey);\n\t\t\tif(tokenCount == null) {\n\t\t\t\ttokenCount = new IpaTernaryTree<>();\n\t\t\t\ttokenCounts.put(groupKey, tokenCount);\n\t\t\t}\n\t\t\tIPATranscript ipaT =\n\t\t\t\t\tIPATranscript.class.cast(table.getValueAt(row, ipaTidx));\n\t\t\tIPATranscript ipaA =\n\t\t\t\t\tIPATranscript.class.cast(table.getValueAt(row, ipaAidx));\n\t\t\tif(ignoreDiacritics) {\n\t\t\t\tipaT = ipaT.removePunctuation().stripDiacritics();\n\t\t\t\tipaA = ipaA.removePunctuation().stripDiacritics();\n\t\t\t}\n\t\t\tList<IPATranscript> productions = tokenCount.get(ipaT);\n\t\t\tif(productions == null) {\n\t\t\t\tproductions = new ArrayList<>();\n\t\t\t\ttokenCount.put(ipaT, productions);\n\t\t\t}\n\t\t\tproductions.add(ipaA);\n\t\t}\n\t\tfinal DefaultTableDataSource outputTable = new DefaultTableDataSource();\n\t\tfor(GroupKey groupKey:tokenCounts.keySet()) {\n\t\t\tfinal Object[] rowData = new Object[7];\n\t\t\n\t\t\tint numRepatedWords = 0;\n\t\t\tint numAllCorrect = 0;\n\t\t\tint numOneOrMoreCorrect = 0;\n\t\t\tint numSameError = 0;\n\t\t\tint numDifferentErrors = 0;\n\t\t\tfloat sumOfAvgDistances = 0;\n\t\t\tfinal IpaTernaryTree<List<IPATranscript>> tokenCount = tokenCounts.get(groupKey);\n\t\t\tfinal List<IPATranscript> repeatedTokens =\n\t\t\t\t\ttokenCount.keySet().stream()\n\t\t\t\t\t\t.filter( (ipa) -> tokenCount.get(ipa).size() > 1 )\n\t\t\t\t\t\t.collect(Collectors.toList());\n\t\t\tnumRepatedWords = repeatedTokens.size();\n\t\t\tfor(IPATranscript ipa:repeatedTokens) {\n\t\t\t\tcheckCanceled();\n\t\t\t\tint numCorrect = 0;\n\t\t\t\tfinal List<IPATranscript> productions = tokenCount.get(ipa);\n\t\t\t\tfinal Set<IPATranscript> distinctProductions = new LinkedHashSet<>(productions);\n\t\t\t\tfor(IPATranscript production:tokenCount.get(ipa)) {\n\t\t\t\t\tif(TableUtils.checkEquals(ipa, production, false, ignoreDiacritics)) {\n\t\t\t\t\t\t++numCorrect;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif(numCorrect == productions.size()) {\n\t\t\t\t\t++numAllCorrect;\n\t\t\t\t} else {\n\t\t\t\t\tif(numCorrect > 0 && numCorrect < productions.size()) {\n\t\t\t\t\t\t++numOneOrMoreCorrect;\n\t\t\t\t\t}\n\t\t\t\t\tdistinctProductions.remove(ipa);\n\t\t\t\t\tif(distinctProductions.size() == 1) {\n\t\t\t\t\t\t++numSameError;\n\t\t\t\t\t} else {\n\t\t\t\t\t\t++numDifferentErrors;\n\t\t\t\t\t}\n\t\t\t\t\tint totalDistance = 0;\n\t\t\t\t\tfor(IPATranscript production:productions) {\n\t\t\t\t\t\ttotalDistance += LevenshteinDistance.distance(ipa, production);\n\t\t\t\t\t}\n\t\t\t\t\tfloat avg = ((float)totalDistance)\/((float)productions.size());\n\t\t\t\t\tsumOfAvgDistances += avg;\n\t\t\t\t}\n\t\t\t}\n\t\t\n\t\t\trowData[0] = groupKey.key;\n\t\t\trowData[1] = numRepatedWords;\n\t\t\trowData[2] = numAllCorrect;\n\t\t\trowData[3] = numOneOrMoreCorrect;\n\t\t\trowData[4] = numSameError;\n\t\t\trowData[5] = numDifferentErrors;\n\t\t\trowData[6] = sumOfAvgDistances \/ numRepatedWords;\n\t\t\toutputTable.addRow(rowData);\n\t\t}\n\t\toutputTable.setColumnTitle(0, \"Session\");\n\t\toutputTable.setColumnTitle(1, \"# Repeated IPA Target\");\n\t\toutputTable.setColumnTitle(2, \"# All Correct\");\n\t\toutputTable.setColumnTitle(3, \"# One or More Correct\");\n\t\toutputTable.setColumnTitle(4, \"# Same Error\");\n\t\toutputTable.setColumnTitle(5, \"# Different Errors\");\n\t\toutputTable.setColumnTitle(6, \"Avg Distance\");\n\t\tcontext.put(tableOutput, outputTable);\n\t}","cleancode":"@override public void operate(opcontext context) throws processingexception { final tabledatasource table = (tabledatasource)context.get(tableinput); int ipatidx = super.getcolumnindex(table, systemtiertype.ipatarget.getname()); if(ipatidx < 0) { throw new processingexception(null, \"table has no \" + systemtiertype.ipatarget.getname() + \" column.\"); } int ipaaidx = super.getcolumnindex(table, systemtiertype.ipaactual.getname()); if(ipaaidx < 0) { throw new processingexception(null, \"table has no \" + systemtiertype.ipaactual.getname() + \" column.\"); } int sessionidx = super.getcolumnindex(table, \"session\"); boolean ignorediacritics = isignorediacritics(); if(context.containskey(\"ignorediacritics\")) { ignorediacritics = (boolean)context.get(\"ignorediacritics\"); } final map<groupkey, ipaternarytree<list<ipatranscript>>> tokencounts = new linkedhashmap<>(); for(int row = 0; row < table.getrowcount(); row++) { checkcanceled(); final object groupval = (sessionidx >= 0 ? table.getvalueat(row, sessionidx) : \"*\"); final groupkey groupkey = new groupkey(groupval, ignorediacritics); ipaternarytree<list<ipatranscript>> tokencount = tokencounts.get(groupkey); if(tokencount == null) { tokencount = new ipaternarytree<>(); tokencounts.put(groupkey, tokencount); } ipatranscript ipat = ipatranscript.class.cast(table.getvalueat(row, ipatidx)); ipatranscript ipaa = ipatranscript.class.cast(table.getvalueat(row, ipaaidx)); if(ignorediacritics) { ipat = ipat.removepunctuation().stripdiacritics(); ipaa = ipaa.removepunctuation().stripdiacritics(); } list<ipatranscript> productions = tokencount.get(ipat); if(productions == null) { productions = new arraylist<>(); tokencount.put(ipat, productions); } productions.add(ipaa); } final defaulttabledatasource outputtable = new defaulttabledatasource(); for(groupkey groupkey:tokencounts.keyset()) { final object[] rowdata = new object[7]; int numrepatedwords = 0; int numallcorrect = 0; int numoneormorecorrect = 0; int numsameerror = 0; int numdifferenterrors = 0; float sumofavgdistances = 0; final ipaternarytree<list<ipatranscript>> tokencount = tokencounts.get(groupkey); final list<ipatranscript> repeatedtokens = tokencount.keyset().stream() .filter( (ipa) -> tokencount.get(ipa).size() > 1 ) .collect(collectors.tolist()); numrepatedwords = repeatedtokens.size(); for(ipatranscript ipa:repeatedtokens) { checkcanceled(); int numcorrect = 0; final list<ipatranscript> productions = tokencount.get(ipa); final set<ipatranscript> distinctproductions = new linkedhashset<>(productions); for(ipatranscript production:tokencount.get(ipa)) { if(tableutils.checkequals(ipa, production, false, ignorediacritics)) { ++numcorrect; } } if(numcorrect == productions.size()) { ++numallcorrect; } else { if(numcorrect > 0 && numcorrect < productions.size()) { ++numoneormorecorrect; } distinctproductions.remove(ipa); if(distinctproductions.size() == 1) { ++numsameerror; } else { ++numdifferenterrors; } int totaldistance = 0; for(ipatranscript production:productions) { totaldistance += levenshteindistance.distance(ipa, production); } float avg = ((float)totaldistance)\/((float)productions.size()); sumofavgdistances += avg; } } rowdata[0] = groupkey.key; rowdata[1] = numrepatedwords; rowdata[2] = numallcorrect; rowdata[3] = numoneormorecorrect; rowdata[4] = numsameerror; rowdata[5] = numdifferenterrors; rowdata[6] = sumofavgdistances \/ numrepatedwords; outputtable.addrow(rowdata); } outputtable.setcolumntitle(0, \"session\"); outputtable.setcolumntitle(1, \"# repeated ipa target\"); outputtable.setcolumntitle(2, \"# all correct\"); outputtable.setcolumntitle(3, \"# one or more correct\"); outputtable.setcolumntitle(4, \"# same error\"); outputtable.setcolumntitle(5, \"# different errors\"); outputtable.setcolumntitle(6, \"avg distance\"); context.put(tableoutput, outputtable); }","repo":"phon-ca\/phon","label":[1,0,0,0]}
{"id":30178,"original_code":"public static String[] split( String value, Font font, int firstLineWidth, int lineWidth ) {\n\t\treturn wrap(value, font, firstLineWidth, lineWidth);\n\t}","code_wo_comment":"public static String[] split( String value, Font font, int firstLineWidth, int lineWidth ) {\n\t\treturn wrap(value, font, firstLineWidth, lineWidth);\n\t}","cleancode":"public static string[] split( string value, font font, int firstlinewidth, int linewidth ) { return wrap(value, font, firstlinewidth, linewidth); }","repo":"mobabel\/MoMeGo","label":[0,0,0,0]}
{"id":13831,"original_code":"private void removeDanglingTransitions(AbstractWorkflow workflow) {\n    if (workflow.getTransitions() == null || workflow.getTransitions().isEmpty()) {\n      return;\n    }\n    Set<String> activityIds = new HashSet<>();\n    for (Activity activity : workflow.getActivities()) {\n      activityIds.add(activity.getId());\n      \/\/ Transitions from Boundary event timers should be included as well\n      \/\/ todo: make generic\n      List<Timer> activityTimers = activity.getTimers();\n      if (activityTimers != null) {\n        for (Timer timer : activityTimers) {\n          if (timer instanceof BoundaryEventTimer) {\n            BoundaryEvent boundaryEvent = ((BoundaryEventTimer) timer).boundaryEvent;\n            activityIds.add(boundaryEvent.getBoundaryId());\n            activityIds.addAll(boundaryEvent.getToTransitionIds());\n          }\n        }\n      }\n    }\n    ListIterator<Transition> transitionIterator = workflow.getTransitions().listIterator();\n    while(transitionIterator.hasNext()){\n      Transition transition = transitionIterator.next();\n      if (!activityIds.contains(transition.getFromId()) || !activityIds.contains(transition.getToId())) {\n        transitionIterator.remove();\n      }\n    }\n  }","code_wo_comment":"private void removeDanglingTransitions(AbstractWorkflow workflow) {\n    if (workflow.getTransitions() == null || workflow.getTransitions().isEmpty()) {\n      return;\n    }\n    Set<String> activityIds = new HashSet<>();\n    for (Activity activity : workflow.getActivities()) {\n      activityIds.add(activity.getId());\n     \n     \n      List<Timer> activityTimers = activity.getTimers();\n      if (activityTimers != null) {\n        for (Timer timer : activityTimers) {\n          if (timer instanceof BoundaryEventTimer) {\n            BoundaryEvent boundaryEvent = ((BoundaryEventTimer) timer).boundaryEvent;\n            activityIds.add(boundaryEvent.getBoundaryId());\n            activityIds.addAll(boundaryEvent.getToTransitionIds());\n          }\n        }\n      }\n    }\n    ListIterator<Transition> transitionIterator = workflow.getTransitions().listIterator();\n    while(transitionIterator.hasNext()){\n      Transition transition = transitionIterator.next();\n      if (!activityIds.contains(transition.getFromId()) || !activityIds.contains(transition.getToId())) {\n        transitionIterator.remove();\n      }\n    }\n  }","cleancode":"private void removedanglingtransitions(abstractworkflow workflow) { if (workflow.gettransitions() == null || workflow.gettransitions().isempty()) { return; } set<string> activityids = new hashset<>(); for (activity activity : workflow.getactivities()) { activityids.add(activity.getid()); list<timer> activitytimers = activity.gettimers(); if (activitytimers != null) { for (timer timer : activitytimers) { if (timer instanceof boundaryeventtimer) { boundaryevent boundaryevent = ((boundaryeventtimer) timer).boundaryevent; activityids.add(boundaryevent.getboundaryid()); activityids.addall(boundaryevent.gettotransitionids()); } } } } listiterator<transition> transitioniterator = workflow.gettransitions().listiterator(); while(transitioniterator.hasnext()){ transition transition = transitioniterator.next(); if (!activityids.contains(transition.getfromid()) || !activityids.contains(transition.gettoid())) { transitioniterator.remove(); } } }","repo":"pharod\/effektif","label":[1,0,0,0]}
{"id":14220,"original_code":"@Override\n  public void startElement (String uri, String name, String qName, Attributes atts) throws SAXException {\n    try {\n    \/\/log.debug(\"S: '\" + uri + \"' \" + qName);\n    \/\/ ----- <xfml> -----------------------------------------------------------\n    if (EL_XFML.equals(qName)) {\n      String version = atts.getValue(\"version\");\n      if (version == null)\n        log.warn(\"No version attribute on 'xfml' element\");\n      if (!\"1.0\".equals(version))\n        log.warn(\"Unsupported XFML version: \" + version);\n      String mapurl = atts.getValue(\"url\");\n      if (mapurl == null)\n        log.warn(\"No url attribute on 'xfml' element\");\n      else {\n        try {\n          map_uri = new URILocator(mapurl);\n          TopicMapStoreIF store = topicmap.getStore();\n          if (store instanceof AbstractTopicMapStore && store.getBaseAddress() == null)\n            ((AbstractTopicMapStore) store).setBaseAddress(map_uri);\n          doc_address = map_uri;\n          \/\/ Add this document to the list of processed documents.\n          processed_documents_accumulated.add(getBaseAddress());\n        } catch (MalformedURLException e) {\n          log.warn(\"Invalid xfml base URL: \" + mapurl);\n        }\n      }\n      \/\/ FIXME: what to do about language?\n    }\n    \/\/ ----- <facet> ----------------------------------------------------------\n    else if (EL_FACET.equals(qName)) {\n      String id = atts.getValue(\"id\");\n      \/\/ FIXME: complain if no id\n      current_topic = builder.makeTopic();\n      registerSourceLocator(current_topic, id);\n      keep_content = true;\n    }\n    \/\/ ----- <topic> ----------------------------------------------------------\n    else if (EL_TOPIC.equals(qName)) {\n      String id = atts.getValue(\"id\");\n      \/\/ FIXME: complain if no id\n      current_topic = builder.makeTopic();\n      registerSourceLocator(current_topic, id);\n      String parentid = atts.getValue(\"parentTopicid\");\n      if (parentid == null)\n        parentid = atts.getValue(\"facetid\");\n      \/\/ FIXME: complain if no refs\n      TopicIF parent = resolveTopicRef(\"#\" + parentid);\n      parentBuilder.makeAssociation(parent, current_topic);\n    }\n    \/\/ ----- <page> -----------------------------------------------------------\n    else if (EL_PAGE.equals(qName)) {\n      String url = atts.getValue(\"url\");\n      \/\/ FIXME: complain if no url\n      current_topic = builder.makeTopic();\n      current_topic.addSubjectLocator(createLocator(url));\n    }\n    \/\/ ----- <occurrence>------------------------------------------------------\n    else if (EL_OCCURRENCE.equals(qName)) {\n      String topicid = atts.getValue(\"topicid\");\n      \/\/ FIXME: complain if none\n      TopicIF subject = resolveTopicRef(\"#\" + topicid);\n      occursBuilder.makeAssociation(subject, current_topic);\n    }\n    \/\/ ----- <name> -----------------------------------------------------------\n    \/\/ ----- <psi> ------------------------------------------------------------\n    \/\/ ----- <description> ----------------------------------------------------\n    \/\/ ----- <title> ----------------------------------------------------------\n    \/\/ ----- <connect> --------------------------------------------------------\n    else if (EL_NAME.equals(qName) || EL_PSI.equals(qName) || EL_DESCRIPTION.equals(qName) ||\n            EL_TITLE.equals(qName) || EL_CONNECT.equals(qName)) \n      keep_content = true;   \n    } catch (RuntimeException e) {\n      e.printStackTrace();\n      throw e;\n    }\n  }","code_wo_comment":"@Override\n  public void startElement (String uri, String name, String qName, Attributes atts) throws SAXException {\n    try {\n   \n   \n    if (EL_XFML.equals(qName)) {\n      String version = atts.getValue(\"version\");\n      if (version == null)\n        log.warn(\"No version attribute on 'xfml' element\");\n      if (!\"1.0\".equals(version))\n        log.warn(\"Unsupported XFML version: \" + version);\n      String mapurl = atts.getValue(\"url\");\n      if (mapurl == null)\n        log.warn(\"No url attribute on 'xfml' element\");\n      else {\n        try {\n          map_uri = new URILocator(mapurl);\n          TopicMapStoreIF store = topicmap.getStore();\n          if (store instanceof AbstractTopicMapStore && store.getBaseAddress() == null)\n            ((AbstractTopicMapStore) store).setBaseAddress(map_uri);\n          doc_address = map_uri;\n         \n          processed_documents_accumulated.add(getBaseAddress());\n        } catch (MalformedURLException e) {\n          log.warn(\"Invalid xfml base URL: \" + mapurl);\n        }\n      }\n     \n    }\n   \n    else if (EL_FACET.equals(qName)) {\n      String id = atts.getValue(\"id\");\n     \n      current_topic = builder.makeTopic();\n      registerSourceLocator(current_topic, id);\n      keep_content = true;\n    }\n   \n    else if (EL_TOPIC.equals(qName)) {\n      String id = atts.getValue(\"id\");\n     \n      current_topic = builder.makeTopic();\n      registerSourceLocator(current_topic, id);\n      String parentid = atts.getValue(\"parentTopicid\");\n      if (parentid == null)\n        parentid = atts.getValue(\"facetid\");\n     \n      TopicIF parent = resolveTopicRef(\"#\" + parentid);\n      parentBuilder.makeAssociation(parent, current_topic);\n    }\n   \n    else if (EL_PAGE.equals(qName)) {\n      String url = atts.getValue(\"url\");\n     \n      current_topic = builder.makeTopic();\n      current_topic.addSubjectLocator(createLocator(url));\n    }\n   \n    else if (EL_OCCURRENCE.equals(qName)) {\n      String topicid = atts.getValue(\"topicid\");\n     \n      TopicIF subject = resolveTopicRef(\"#\" + topicid);\n      occursBuilder.makeAssociation(subject, current_topic);\n    }\n   \n   \n   \n   \n   \n    else if (EL_NAME.equals(qName) || EL_PSI.equals(qName) || EL_DESCRIPTION.equals(qName) ||\n            EL_TITLE.equals(qName) || EL_CONNECT.equals(qName)) \n      keep_content = true;   \n    } catch (RuntimeException e) {\n      e.printStackTrace();\n      throw e;\n    }\n  }","cleancode":"@override public void startelement (string uri, string name, string qname, attributes atts) throws saxexception { try { if (el_xfml.equals(qname)) { string version = atts.getvalue(\"version\"); if (version == null) log.warn(\"no version attribute on 'xfml' element\"); if (!\"1.0\".equals(version)) log.warn(\"unsupported xfml version: \" + version); string mapurl = atts.getvalue(\"url\"); if (mapurl == null) log.warn(\"no url attribute on 'xfml' element\"); else { try { map_uri = new urilocator(mapurl); topicmapstoreif store = topicmap.getstore(); if (store instanceof abstracttopicmapstore && store.getbaseaddress() == null) ((abstracttopicmapstore) store).setbaseaddress(map_uri); doc_address = map_uri; processed_documents_accumulated.add(getbaseaddress()); } catch (malformedurlexception e) { log.warn(\"invalid xfml base url: \" + mapurl); } } } else if (el_facet.equals(qname)) { string id = atts.getvalue(\"id\"); current_topic = builder.maketopic(); registersourcelocator(current_topic, id); keep_content = true; } else if (el_topic.equals(qname)) { string id = atts.getvalue(\"id\"); current_topic = builder.maketopic(); registersourcelocator(current_topic, id); string parentid = atts.getvalue(\"parenttopicid\"); if (parentid == null) parentid = atts.getvalue(\"facetid\"); topicif parent = resolvetopicref(\"#\" + parentid); parentbuilder.makeassociation(parent, current_topic); } else if (el_page.equals(qname)) { string url = atts.getvalue(\"url\"); current_topic = builder.maketopic(); current_topic.addsubjectlocator(createlocator(url)); } else if (el_occurrence.equals(qname)) { string topicid = atts.getvalue(\"topicid\"); topicif subject = resolvetopicref(\"#\" + topicid); occursbuilder.makeassociation(subject, current_topic); } else if (el_name.equals(qname) || el_psi.equals(qname) || el_description.equals(qname) || el_title.equals(qname) || el_connect.equals(qname)) keep_content = true; } catch (runtimeexception e) { e.printstacktrace(); throw e; } }","repo":"ontopia\/ontopia","label":[1,0,1,0]}
{"id":22550,"original_code":"public T dequeue(){\n\t\t\/\/TODO resolve queue with single element\n\t\tT result = current.get();\n\t\tcurrent = current.next();\n\t\treturn result;\n\t}","code_wo_comment":"public T dequeue(){\n\t\n\t\tT result = current.get();\n\t\tcurrent = current.next();\n\t\treturn result;\n\t}","cleancode":"public t dequeue(){ t result = current.get(); current = current.next(); return result; }","repo":"pcordemans\/exampleAlgorithms","label":[0,1,0,0]}
{"id":22632,"original_code":"public void copyResourcesToCacheIfRequired1(Activity activity){\n        if( ContextCompat.checkSelfPermission(activity, Manifest.permission.WRITE_EXTERNAL_STORAGE)\n                != PackageManager.PERMISSION_GRANTED )\n            return;\n        String sigFilePath = resFolderPath + \"\/sarvamoola\/aitareya.txt\";\n        File sigFile = new File(sigFilePath);\n        if(!sigFile.exists())\n        {\n            for (Pair<String, String> item : mFilesToCopy) {\n                String fileName ;\n                if(item.first.indexOf('\/')!= -1)\n                    fileName = item.first.substring(item.first.lastIndexOf(\"\/\")+1);\n                else\n                    fileName = item.first;\n                String destUrl = resFolderPath;\n                if(!item.second.isEmpty()) {\n\/\/                  if(new File(item.second).isAbsolute()){\n                    if(File.separator.equals(item.second.substring(0,1))){ \/\/ Shortcut to check isAbsolute()\n                        \/\/ Its an absolute url. set the destUrl to empty so that item.second is taken as is\n                        destUrl = \"\";\n                    }\n                    destUrl = destUrl + item.second + '\/';\n                }\n                destUrl = destUrl + fileName;\n                copyFile(item.first, destUrl);\n            }\n        }\n    }","code_wo_comment":"public void copyResourcesToCacheIfRequired1(Activity activity){\n        if( ContextCompat.checkSelfPermission(activity, Manifest.permission.WRITE_EXTERNAL_STORAGE)\n                != PackageManager.PERMISSION_GRANTED )\n            return;\n        String sigFilePath = resFolderPath + \"\/sarvamoola\/aitareya.txt\";\n        File sigFile = new File(sigFilePath);\n        if(!sigFile.exists())\n        {\n            for (Pair<String, String> item : mFilesToCopy) {\n                String fileName ;\n                if(item.first.indexOf('\/')!= -1)\n                    fileName = item.first.substring(item.first.lastIndexOf(\"\/\")+1);\n                else\n                    fileName = item.first;\n                String destUrl = resFolderPath;\n                if(!item.second.isEmpty()) {\n                    if(File.separator.equals(item.second.substring(0,1))){\n                       \n                        destUrl = \"\";\n                    }\n                    destUrl = destUrl + item.second + '\/';\n                }\n                destUrl = destUrl + fileName;\n                copyFile(item.first, destUrl);\n            }\n        }\n    }","cleancode":"public void copyresourcestocacheifrequired1(activity activity){ if( contextcompat.checkselfpermission(activity, manifest.permission.write_external_storage) != packagemanager.permission_granted ) return; string sigfilepath = resfolderpath + \"\/sarvamoola\/aitareya.txt\"; file sigfile = new file(sigfilepath); if(!sigfile.exists()) { for (pair<string, string> item : mfilestocopy) { string filename ; if(item.first.indexof('\/')!= -1) filename = item.first.substring(item.first.lastindexof(\"\/\")+1); else filename = item.first; string desturl = resfolderpath; if(!item.second.isempty()) { if(file.separator.equals(item.second.substring(0,1))){ desturl = \"\"; } desturl = desturl + item.second + '\/'; } desturl = desturl + filename; copyfile(item.first, desturl); } } }","repo":"openmuthu\/jaya","label":[0,1,0,0]}
{"id":14534,"original_code":"public RawMessage handleCborRequest(ChannelId channelId, byte[] payload) {\n\t\tif (payload.length == 0) {\n\t\t\treturn RawMessage.error(channelId, HidError.INVALID_LEN);\n\t\t}\n\t\tCtap2Method method = Ctap2Method.from(payload[0]);\n\t\tbyte[] params = new byte[payload.length - 1];\n\t\tSystem.arraycopy(payload, 1, params, 0, payload.length - 1);\n\t\ttry {\n\t\t\tlog.debug(\"Received CBOR request with method {} and body {}\", method, CborDecoder.decode(params));\n\t\t} catch (CborException e) {\n\t\t\tlog.error(\"Unable to deserialize CBOR parameters\", e);\n\t\t\treturn failure(channelId, Ctap2ResponseCode.INVALID_CBOR);\n\t\t}\n\t\ttry {\n\t\t\tswitch (method) {\n\t\t\tcase GET_ASSERTION:\n\t\t\t\tGetAssertionRequest gar = GetAssertionRequest.fromBytes(params);\n\t\t\t\tbyte[] assertion = authenticator.getAssertion(gar)\n\t\t\t\t\t\t.handleError(err -> asPayload(err, Collections.emptyList()))\n\t\t\t\t\t\t.elseGet(value -> asPayload(Ctap2ResponseCode.OK, value.asCborMap()));\n\t\t\t\treturn ImmutableRawMessage.builder()\n\t\t\t\t\t\t.channelId(channelId)\n\t\t\t\t\t\t.command(HidCommand.CBOR)\n\t\t\t\t\t\t.payload(assertion)\n\t\t\t\t\t\t.build();\n\t\t\tcase GET_INFO:\n\t\t\t\tGetInfoResponse response = authenticator.getInfo();\n\t\t\t\tlog.trace(\"Authenticator supports options {}\", response);\n\t\t\t\tbyte[] info = asPayload(Ctap2ResponseCode.OK, response.asCborMap());\n\t\t\t\treturn ImmutableRawMessage.builder()\n\t\t\t\t\t\t.channelId(channelId)\n\t\t\t\t\t\t.command(HidCommand.CBOR)\n\t\t\t\t\t\t.payload(info)\n\t\t\t\t\t\t.build();\n\t\t\tcase MAKE_CREDENTIAL:\n\t\t\t\tMakeCredentialRequest request = MakeCredentialRequest.fromBytes(params);\n\t\t\t\tResult<MakeCredentialResponse, Ctap2ResponseCode> result = authenticator.makeCredential(request.clientDataHash(),\n\t\t\t\t\t\trequest.relayingPartyId(), request.userId(), request.supportedAlgorithmIds(), request.pinAuth());\n\t\t\t\tbyte[] credential = result\n\t\t\t\t\t\t.handleError(err -> asPayload(err, Collections.emptyList()))\n\t\t\t\t\t\t.elseGet(value -> asPayload(Ctap2ResponseCode.OK, value.asCborMap()));\n\t\t\t\treturn ImmutableRawMessage.builder()\n\t\t\t\t\t\t.channelId(channelId)\n\t\t\t\t\t\t.command(HidCommand.CBOR)\n\t\t\t\t\t\t.payload(credential)\n\t\t\t\t\t\t.build();\n\t\t\tcase CLIENT_PIN:\n\t\t\t\tMap pinParams = (Map) CborDecoder.decode(params).get(0);\n\t\t\t\tUnsignedInteger pinProtocol = (UnsignedInteger) pinParams.get(new UnsignedInteger(0x01));\n\t\t\t\t\/\/ TODO: handle pinProtocol != 1 somehow\n\t\t\t\tUnsignedInteger subCommand = (UnsignedInteger) pinParams.get(new UnsignedInteger(0x02));\n\t\t\t\tswitch(subCommand.getValue().intValue()) {\n\t\t\t\tcase 0x01: \/\/ get retries\n\t\t\t\t\tList<DataItem> retries = pinRequestHandler.getRetries();\n\t\t\t\t\treturn ImmutableRawMessage.builder()\n\t\t\t\t\t\t\t.channelId(channelId)\n\t\t\t\t\t\t\t.command(HidCommand.CBOR)\n\t\t\t\t\t\t\t.payload(asPayload(Ctap2ResponseCode.OK, retries))\n\t\t\t\t\t\t\t.build();\n\t\t\t\tcase 0x02: \/\/ get key\n\t\t\t\t\tList<DataItem> key = pinRequestHandler.getKeyAgreementKey();\n\t\t\t\t\treturn ImmutableRawMessage.builder()\n\t\t\t\t\t\t\t.channelId(channelId)\n\t\t\t\t\t\t\t.command(HidCommand.CBOR)\n\t\t\t\t\t\t\t.payload(asPayload(Ctap2ResponseCode.OK, key))\n\t\t\t\t\t\t\t.build();\n\t\t\t\tcase 0x03: \/\/ set pin\n\t\t\t\t\tMap hostCoseKey = (Map) pinParams.get(new UnsignedInteger(0x03));\n\t\t\t\t\tByteString pinAuth = (ByteString) pinParams.get(new UnsignedInteger(0x04));\n\t\t\t\t\tByteString newPinEnc = (ByteString) pinParams.get(new UnsignedInteger(0x05));\n\t\t\t\t\tCtap2ResponseCode code = pinRequestHandler.setPin(hostCoseKey, newPinEnc.getBytes(), pinAuth.getBytes());\n\t\t\t\t\treturn ImmutableRawMessage.builder()\n\t\t\t\t\t\t\t.channelId(channelId)\n\t\t\t\t\t\t\t.command(HidCommand.CBOR)\n\t\t\t\t\t\t\t.payload(asPayload(code, Collections.emptyList()))\n\t\t\t\t\t\t\t.build();\n\t\t\t\tcase 0x04: \/\/ change pin\n\t\t\t\t\tMap hostCoseKey2 = (Map) pinParams.get(new UnsignedInteger(0x03));\n\t\t\t\t\tByteString pinAuth2 = (ByteString) pinParams.get(new UnsignedInteger(0x04));\n\t\t\t\t\tByteString newPinEnc2 = (ByteString) pinParams.get(new UnsignedInteger(0x05));\n\t\t\t\t\tByteString PinHashEnc = (ByteString) pinParams.get(new UnsignedInteger(0x06));\n\t\t\t\t\tCtap2ResponseCode code2 = pinRequestHandler.changePin(hostCoseKey2, PinHashEnc.getBytes(), newPinEnc2.getBytes(), pinAuth2.getBytes());\n\t\t\t\t\treturn ImmutableRawMessage.builder()\n\t\t\t\t\t\t\t.channelId(channelId)\n\t\t\t\t\t\t\t.command(HidCommand.CBOR)\n\t\t\t\t\t\t\t.payload(asPayload(code2, Collections.emptyList()))\n\t\t\t\t\t\t\t.build();\n\t\t\t\tcase 0x05: \/\/ get pin token\n\t\t\t\t\tMap hostCoseKey3 = (Map) pinParams.get(new UnsignedInteger(0x03));\n\t\t\t\t\tByteString pinHashEnc2 = (ByteString) pinParams.get(new UnsignedInteger(0x06));\n\t\t\t\t\tResult<List<DataItem>, Ctap2ResponseCode> pinToken = pinRequestHandler.getPinToken(hostCoseKey3, pinHashEnc2.getBytes());\n\t\t\t\t\tbyte[] pinTokenPayload = pinToken.handleError(err -> asPayload(err, Collections.emptyList()))\n\t\t\t\t\t\t\t.elseGet(val -> asPayload(Ctap2ResponseCode.OK, val));\n\t\t\t\t\treturn ImmutableRawMessage.builder()\n\t\t\t\t\t\t\t.channelId(channelId)\n\t\t\t\t\t\t\t.command(HidCommand.CBOR)\n\t\t\t\t\t\t\t.payload(pinTokenPayload)\n\t\t\t\t\t\t\t.build();\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase RESET:\n\t\t\tcase GET_NEXT_ASSERTION:\n\t\t\tdefault:\n\t\t\t\treturn RawMessage.error(channelId, HidError.INVALID_CMD);\n\t\t\t}\n\t\t} catch (CborException e) {\n\t\t\tlog.error(\"Unable to deserialize CBOR\", e);\n\t\t}\n\t\treturn failure(channelId, Ctap2ResponseCode.INVALID_CBOR);\n\t}","code_wo_comment":"public RawMessage handleCborRequest(ChannelId channelId, byte[] payload) {\n\t\tif (payload.length == 0) {\n\t\t\treturn RawMessage.error(channelId, HidError.INVALID_LEN);\n\t\t}\n\t\tCtap2Method method = Ctap2Method.from(payload[0]);\n\t\tbyte[] params = new byte[payload.length - 1];\n\t\tSystem.arraycopy(payload, 1, params, 0, payload.length - 1);\n\t\ttry {\n\t\t\tlog.debug(\"Received CBOR request with method {} and body {}\", method, CborDecoder.decode(params));\n\t\t} catch (CborException e) {\n\t\t\tlog.error(\"Unable to deserialize CBOR parameters\", e);\n\t\t\treturn failure(channelId, Ctap2ResponseCode.INVALID_CBOR);\n\t\t}\n\t\ttry {\n\t\t\tswitch (method) {\n\t\t\tcase GET_ASSERTION:\n\t\t\t\tGetAssertionRequest gar = GetAssertionRequest.fromBytes(params);\n\t\t\t\tbyte[] assertion = authenticator.getAssertion(gar)\n\t\t\t\t\t\t.handleError(err -> asPayload(err, Collections.emptyList()))\n\t\t\t\t\t\t.elseGet(value -> asPayload(Ctap2ResponseCode.OK, value.asCborMap()));\n\t\t\t\treturn ImmutableRawMessage.builder()\n\t\t\t\t\t\t.channelId(channelId)\n\t\t\t\t\t\t.command(HidCommand.CBOR)\n\t\t\t\t\t\t.payload(assertion)\n\t\t\t\t\t\t.build();\n\t\t\tcase GET_INFO:\n\t\t\t\tGetInfoResponse response = authenticator.getInfo();\n\t\t\t\tlog.trace(\"Authenticator supports options {}\", response);\n\t\t\t\tbyte[] info = asPayload(Ctap2ResponseCode.OK, response.asCborMap());\n\t\t\t\treturn ImmutableRawMessage.builder()\n\t\t\t\t\t\t.channelId(channelId)\n\t\t\t\t\t\t.command(HidCommand.CBOR)\n\t\t\t\t\t\t.payload(info)\n\t\t\t\t\t\t.build();\n\t\t\tcase MAKE_CREDENTIAL:\n\t\t\t\tMakeCredentialRequest request = MakeCredentialRequest.fromBytes(params);\n\t\t\t\tResult<MakeCredentialResponse, Ctap2ResponseCode> result = authenticator.makeCredential(request.clientDataHash(),\n\t\t\t\t\t\trequest.relayingPartyId(), request.userId(), request.supportedAlgorithmIds(), request.pinAuth());\n\t\t\t\tbyte[] credential = result\n\t\t\t\t\t\t.handleError(err -> asPayload(err, Collections.emptyList()))\n\t\t\t\t\t\t.elseGet(value -> asPayload(Ctap2ResponseCode.OK, value.asCborMap()));\n\t\t\t\treturn ImmutableRawMessage.builder()\n\t\t\t\t\t\t.channelId(channelId)\n\t\t\t\t\t\t.command(HidCommand.CBOR)\n\t\t\t\t\t\t.payload(credential)\n\t\t\t\t\t\t.build();\n\t\t\tcase CLIENT_PIN:\n\t\t\t\tMap pinParams = (Map) CborDecoder.decode(params).get(0);\n\t\t\t\tUnsignedInteger pinProtocol = (UnsignedInteger) pinParams.get(new UnsignedInteger(0x01));\n\t\t\t\n\t\t\t\tUnsignedInteger subCommand = (UnsignedInteger) pinParams.get(new UnsignedInteger(0x02));\n\t\t\t\tswitch(subCommand.getValue().intValue()) {\n\t\t\t\tcase 0x01:\n\t\t\t\t\tList<DataItem> retries = pinRequestHandler.getRetries();\n\t\t\t\t\treturn ImmutableRawMessage.builder()\n\t\t\t\t\t\t\t.channelId(channelId)\n\t\t\t\t\t\t\t.command(HidCommand.CBOR)\n\t\t\t\t\t\t\t.payload(asPayload(Ctap2ResponseCode.OK, retries))\n\t\t\t\t\t\t\t.build();\n\t\t\t\tcase 0x02:\n\t\t\t\t\tList<DataItem> key = pinRequestHandler.getKeyAgreementKey();\n\t\t\t\t\treturn ImmutableRawMessage.builder()\n\t\t\t\t\t\t\t.channelId(channelId)\n\t\t\t\t\t\t\t.command(HidCommand.CBOR)\n\t\t\t\t\t\t\t.payload(asPayload(Ctap2ResponseCode.OK, key))\n\t\t\t\t\t\t\t.build();\n\t\t\t\tcase 0x03:\n\t\t\t\t\tMap hostCoseKey = (Map) pinParams.get(new UnsignedInteger(0x03));\n\t\t\t\t\tByteString pinAuth = (ByteString) pinParams.get(new UnsignedInteger(0x04));\n\t\t\t\t\tByteString newPinEnc = (ByteString) pinParams.get(new UnsignedInteger(0x05));\n\t\t\t\t\tCtap2ResponseCode code = pinRequestHandler.setPin(hostCoseKey, newPinEnc.getBytes(), pinAuth.getBytes());\n\t\t\t\t\treturn ImmutableRawMessage.builder()\n\t\t\t\t\t\t\t.channelId(channelId)\n\t\t\t\t\t\t\t.command(HidCommand.CBOR)\n\t\t\t\t\t\t\t.payload(asPayload(code, Collections.emptyList()))\n\t\t\t\t\t\t\t.build();\n\t\t\t\tcase 0x04:\n\t\t\t\t\tMap hostCoseKey2 = (Map) pinParams.get(new UnsignedInteger(0x03));\n\t\t\t\t\tByteString pinAuth2 = (ByteString) pinParams.get(new UnsignedInteger(0x04));\n\t\t\t\t\tByteString newPinEnc2 = (ByteString) pinParams.get(new UnsignedInteger(0x05));\n\t\t\t\t\tByteString PinHashEnc = (ByteString) pinParams.get(new UnsignedInteger(0x06));\n\t\t\t\t\tCtap2ResponseCode code2 = pinRequestHandler.changePin(hostCoseKey2, PinHashEnc.getBytes(), newPinEnc2.getBytes(), pinAuth2.getBytes());\n\t\t\t\t\treturn ImmutableRawMessage.builder()\n\t\t\t\t\t\t\t.channelId(channelId)\n\t\t\t\t\t\t\t.command(HidCommand.CBOR)\n\t\t\t\t\t\t\t.payload(asPayload(code2, Collections.emptyList()))\n\t\t\t\t\t\t\t.build();\n\t\t\t\tcase 0x05:\n\t\t\t\t\tMap hostCoseKey3 = (Map) pinParams.get(new UnsignedInteger(0x03));\n\t\t\t\t\tByteString pinHashEnc2 = (ByteString) pinParams.get(new UnsignedInteger(0x06));\n\t\t\t\t\tResult<List<DataItem>, Ctap2ResponseCode> pinToken = pinRequestHandler.getPinToken(hostCoseKey3, pinHashEnc2.getBytes());\n\t\t\t\t\tbyte[] pinTokenPayload = pinToken.handleError(err -> asPayload(err, Collections.emptyList()))\n\t\t\t\t\t\t\t.elseGet(val -> asPayload(Ctap2ResponseCode.OK, val));\n\t\t\t\t\treturn ImmutableRawMessage.builder()\n\t\t\t\t\t\t\t.channelId(channelId)\n\t\t\t\t\t\t\t.command(HidCommand.CBOR)\n\t\t\t\t\t\t\t.payload(pinTokenPayload)\n\t\t\t\t\t\t\t.build();\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase RESET:\n\t\t\tcase GET_NEXT_ASSERTION:\n\t\t\tdefault:\n\t\t\t\treturn RawMessage.error(channelId, HidError.INVALID_CMD);\n\t\t\t}\n\t\t} catch (CborException e) {\n\t\t\tlog.error(\"Unable to deserialize CBOR\", e);\n\t\t}\n\t\treturn failure(channelId, Ctap2ResponseCode.INVALID_CBOR);\n\t}","cleancode":"public rawmessage handlecborrequest(channelid channelid, byte[] payload) { if (payload.length == 0) { return rawmessage.error(channelid, hiderror.invalid_len); } ctap2method method = ctap2method.from(payload[0]); byte[] params = new byte[payload.length - 1]; system.arraycopy(payload, 1, params, 0, payload.length - 1); try { log.debug(\"received cbor request with method {} and body {}\", method, cbordecoder.decode(params)); } catch (cborexception e) { log.error(\"unable to deserialize cbor parameters\", e); return failure(channelid, ctap2responsecode.invalid_cbor); } try { switch (method) { case get_assertion: getassertionrequest gar = getassertionrequest.frombytes(params); byte[] assertion = authenticator.getassertion(gar) .handleerror(err -> aspayload(err, collections.emptylist())) .elseget(value -> aspayload(ctap2responsecode.ok, value.ascbormap())); return immutablerawmessage.builder() .channelid(channelid) .command(hidcommand.cbor) .payload(assertion) .build(); case get_info: getinforesponse response = authenticator.getinfo(); log.trace(\"authenticator supports options {}\", response); byte[] info = aspayload(ctap2responsecode.ok, response.ascbormap()); return immutablerawmessage.builder() .channelid(channelid) .command(hidcommand.cbor) .payload(info) .build(); case make_credential: makecredentialrequest request = makecredentialrequest.frombytes(params); result<makecredentialresponse, ctap2responsecode> result = authenticator.makecredential(request.clientdatahash(), request.relayingpartyid(), request.userid(), request.supportedalgorithmids(), request.pinauth()); byte[] credential = result .handleerror(err -> aspayload(err, collections.emptylist())) .elseget(value -> aspayload(ctap2responsecode.ok, value.ascbormap())); return immutablerawmessage.builder() .channelid(channelid) .command(hidcommand.cbor) .payload(credential) .build(); case client_pin: map pinparams = (map) cbordecoder.decode(params).get(0); unsignedinteger pinprotocol = (unsignedinteger) pinparams.get(new unsignedinteger(0x01)); unsignedinteger subcommand = (unsignedinteger) pinparams.get(new unsignedinteger(0x02)); switch(subcommand.getvalue().intvalue()) { case 0x01: list<dataitem> retries = pinrequesthandler.getretries(); return immutablerawmessage.builder() .channelid(channelid) .command(hidcommand.cbor) .payload(aspayload(ctap2responsecode.ok, retries)) .build(); case 0x02: list<dataitem> key = pinrequesthandler.getkeyagreementkey(); return immutablerawmessage.builder() .channelid(channelid) .command(hidcommand.cbor) .payload(aspayload(ctap2responsecode.ok, key)) .build(); case 0x03: map hostcosekey = (map) pinparams.get(new unsignedinteger(0x03)); bytestring pinauth = (bytestring) pinparams.get(new unsignedinteger(0x04)); bytestring newpinenc = (bytestring) pinparams.get(new unsignedinteger(0x05)); ctap2responsecode code = pinrequesthandler.setpin(hostcosekey, newpinenc.getbytes(), pinauth.getbytes()); return immutablerawmessage.builder() .channelid(channelid) .command(hidcommand.cbor) .payload(aspayload(code, collections.emptylist())) .build(); case 0x04: map hostcosekey2 = (map) pinparams.get(new unsignedinteger(0x03)); bytestring pinauth2 = (bytestring) pinparams.get(new unsignedinteger(0x04)); bytestring newpinenc2 = (bytestring) pinparams.get(new unsignedinteger(0x05)); bytestring pinhashenc = (bytestring) pinparams.get(new unsignedinteger(0x06)); ctap2responsecode code2 = pinrequesthandler.changepin(hostcosekey2, pinhashenc.getbytes(), newpinenc2.getbytes(), pinauth2.getbytes()); return immutablerawmessage.builder() .channelid(channelid) .command(hidcommand.cbor) .payload(aspayload(code2, collections.emptylist())) .build(); case 0x05: map hostcosekey3 = (map) pinparams.get(new unsignedinteger(0x03)); bytestring pinhashenc2 = (bytestring) pinparams.get(new unsignedinteger(0x06)); result<list<dataitem>, ctap2responsecode> pintoken = pinrequesthandler.getpintoken(hostcosekey3, pinhashenc2.getbytes()); byte[] pintokenpayload = pintoken.handleerror(err -> aspayload(err, collections.emptylist())) .elseget(val -> aspayload(ctap2responsecode.ok, val)); return immutablerawmessage.builder() .channelid(channelid) .command(hidcommand.cbor) .payload(pintokenpayload) .build(); } break; case reset: case get_next_assertion: default: return rawmessage.error(channelid, hiderror.invalid_cmd); } } catch (cborexception e) { log.error(\"unable to deserialize cbor\", e); } return failure(channelid, ctap2responsecode.invalid_cbor); }","repo":"mphi-rc\/pi-zero-security-key","label":[1,0,0,0]}
{"id":22750,"original_code":"@Test\n\tpublic void acceptedRequestIsFullyApplied() throws EngineException\n\t{\n\t\tRegistrationContext defContext = new RegistrationContext(false, TriggeringMode.manualAtLogin);\n\t\tinitAndCreateForm(false, null);\n\t\tRegistrationRequest request = getRequest();\n\t\tString id3 = registrationsMan.submitRegistrationRequest(request, defContext);\n\t\tregistrationsMan.processRegistrationRequest(id3, null, \n\t\t\t\tRegistrationRequestAction.accept, \"a2\", \"p2\");\n\t\tRegistrationRequestState fromDb = registrationsMan.getRegistrationRequests().get(0);\n\t\tassertEquals(request, fromDb.getRequest());\n\t\tassertEquals(2, fromDb.getAdminComments().size());\n\t\tassertEquals(\"p2\", fromDb.getAdminComments().get(1).getContents());\n\t\tassertEquals(\"a2\", fromDb.getAdminComments().get(0).getContents());\n\t\tassertEquals(RegistrationRequestStatus.accepted, fromDb.getStatus());\n\t\tassertEquals(id3, fromDb.getRequestId());\n\t\tassertNotNull(fromDb.getTimestamp());\n\t\tEntity added = idsMan.getEntity(new EntityParam(new IdentityTaV(X500Identity.ID, \"CN=registration test\")));\n\t\tassertEquals(EntityState.valid, added.getState());\n\t\tassertEquals(EngineInitialization.DEFAULT_CREDENTIAL_REQUIREMENT,\n\t\t\t\tadded.getCredentialInfo().getCredentialRequirementId());\n\t\tassertThat(fromDb.getCreatedEntityId(), is(added.getId()));\n\t\tCredentialPublicInformation cpi = added.getCredentialInfo().getCredentialsState().get(\n\t\t\t\tEngineInitialization.DEFAULT_CREDENTIAL);\n\t\tassertEquals(LocalCredentialState.correct, cpi.getState());\n\t\tEntityParam addedP = new EntityParam(added.getId());\n\t\tCollection<String> groups = idsMan.getGroups(addedP).keySet();\n\t\tassertTrue(groups.contains(\"\/\"));\n\t\tassertTrue(groups.contains(\"\/A\"));\n\t\tassertTrue(groups.contains(\"\/B\"));\n\t\tCollection<AttributesClass> acs = acMan.getEntityAttributeClasses(addedP, \"\/\");\n\t\tassertEquals(1, acs.size());\n\t\tassertEquals(InitializerCommon.NAMING_AC, acs.iterator().next().getName());\n\t\tCollection<AttributeExt> attrs = attrsMan.getAttributes(addedP, \"\/\", \"cn\");\n\t\tassertEquals(1, attrs.size());\n\t\tassertEquals(\"val\", attrs.iterator().next().getValues().get(0));\n\t\tattrs = attrsMan.getAttributes(addedP, \"\/\", \"email\");\n\t\tassertEquals(1, attrs.size());\n\t\tString value = attrs.iterator().next().getValues().get(0);\n\t\tVerifiableEmail ve = new VerifiableEmail(JsonUtil.parse(value)); \/\/FIXME - this is likely wrong\n\t\tassertEquals(\"foo@example.com\", ve.getValue());\n\t\tassertEquals(false, ve.getConfirmationInfo().isConfirmed());\n\t}","code_wo_comment":"@Test\n\tpublic void acceptedRequestIsFullyApplied() throws EngineException\n\t{\n\t\tRegistrationContext defContext = new RegistrationContext(false, TriggeringMode.manualAtLogin);\n\t\tinitAndCreateForm(false, null);\n\t\tRegistrationRequest request = getRequest();\n\t\tString id3 = registrationsMan.submitRegistrationRequest(request, defContext);\n\t\tregistrationsMan.processRegistrationRequest(id3, null, \n\t\t\t\tRegistrationRequestAction.accept, \"a2\", \"p2\");\n\t\tRegistrationRequestState fromDb = registrationsMan.getRegistrationRequests().get(0);\n\t\tassertEquals(request, fromDb.getRequest());\n\t\tassertEquals(2, fromDb.getAdminComments().size());\n\t\tassertEquals(\"p2\", fromDb.getAdminComments().get(1).getContents());\n\t\tassertEquals(\"a2\", fromDb.getAdminComments().get(0).getContents());\n\t\tassertEquals(RegistrationRequestStatus.accepted, fromDb.getStatus());\n\t\tassertEquals(id3, fromDb.getRequestId());\n\t\tassertNotNull(fromDb.getTimestamp());\n\t\tEntity added = idsMan.getEntity(new EntityParam(new IdentityTaV(X500Identity.ID, \"CN=registration test\")));\n\t\tassertEquals(EntityState.valid, added.getState());\n\t\tassertEquals(EngineInitialization.DEFAULT_CREDENTIAL_REQUIREMENT,\n\t\t\t\tadded.getCredentialInfo().getCredentialRequirementId());\n\t\tassertThat(fromDb.getCreatedEntityId(), is(added.getId()));\n\t\tCredentialPublicInformation cpi = added.getCredentialInfo().getCredentialsState().get(\n\t\t\t\tEngineInitialization.DEFAULT_CREDENTIAL);\n\t\tassertEquals(LocalCredentialState.correct, cpi.getState());\n\t\tEntityParam addedP = new EntityParam(added.getId());\n\t\tCollection<String> groups = idsMan.getGroups(addedP).keySet();\n\t\tassertTrue(groups.contains(\"\/\"));\n\t\tassertTrue(groups.contains(\"\/A\"));\n\t\tassertTrue(groups.contains(\"\/B\"));\n\t\tCollection<AttributesClass> acs = acMan.getEntityAttributeClasses(addedP, \"\/\");\n\t\tassertEquals(1, acs.size());\n\t\tassertEquals(InitializerCommon.NAMING_AC, acs.iterator().next().getName());\n\t\tCollection<AttributeExt> attrs = attrsMan.getAttributes(addedP, \"\/\", \"cn\");\n\t\tassertEquals(1, attrs.size());\n\t\tassertEquals(\"val\", attrs.iterator().next().getValues().get(0));\n\t\tattrs = attrsMan.getAttributes(addedP, \"\/\", \"email\");\n\t\tassertEquals(1, attrs.size());\n\t\tString value = attrs.iterator().next().getValues().get(0);\n\t\tVerifiableEmail ve = new VerifiableEmail(JsonUtil.parse(value));\n\t\tassertEquals(\"foo@example.com\", ve.getValue());\n\t\tassertEquals(false, ve.getConfirmationInfo().isConfirmed());\n\t}","cleancode":"@test public void acceptedrequestisfullyapplied() throws engineexception { registrationcontext defcontext = new registrationcontext(false, triggeringmode.manualatlogin); initandcreateform(false, null); registrationrequest request = getrequest(); string id3 = registrationsman.submitregistrationrequest(request, defcontext); registrationsman.processregistrationrequest(id3, null, registrationrequestaction.accept, \"a2\", \"p2\"); registrationrequeststate fromdb = registrationsman.getregistrationrequests().get(0); assertequals(request, fromdb.getrequest()); assertequals(2, fromdb.getadmincomments().size()); assertequals(\"p2\", fromdb.getadmincomments().get(1).getcontents()); assertequals(\"a2\", fromdb.getadmincomments().get(0).getcontents()); assertequals(registrationrequeststatus.accepted, fromdb.getstatus()); assertequals(id3, fromdb.getrequestid()); assertnotnull(fromdb.gettimestamp()); entity added = idsman.getentity(new entityparam(new identitytav(x500identity.id, \"cn=registration test\"))); assertequals(entitystate.valid, added.getstate()); assertequals(engineinitialization.default_credential_requirement, added.getcredentialinfo().getcredentialrequirementid()); assertthat(fromdb.getcreatedentityid(), is(added.getid())); credentialpublicinformation cpi = added.getcredentialinfo().getcredentialsstate().get( engineinitialization.default_credential); assertequals(localcredentialstate.correct, cpi.getstate()); entityparam addedp = new entityparam(added.getid()); collection<string> groups = idsman.getgroups(addedp).keyset(); asserttrue(groups.contains(\"\/\")); asserttrue(groups.contains(\"\/a\")); asserttrue(groups.contains(\"\/b\")); collection<attributesclass> acs = acman.getentityattributeclasses(addedp, \"\/\"); assertequals(1, acs.size()); assertequals(initializercommon.naming_ac, acs.iterator().next().getname()); collection<attributeext> attrs = attrsman.getattributes(addedp, \"\/\", \"cn\"); assertequals(1, attrs.size()); assertequals(\"val\", attrs.iterator().next().getvalues().get(0)); attrs = attrsman.getattributes(addedp, \"\/\", \"email\"); assertequals(1, attrs.size()); string value = attrs.iterator().next().getvalues().get(0); verifiableemail ve = new verifiableemail(jsonutil.parse(value)); assertequals(\"foo@example.com\", ve.getvalue()); assertequals(false, ve.getconfirmationinfo().isconfirmed()); }","repo":"olivier-maury\/unity","label":[0,0,1,0]}
{"id":23007,"original_code":"public static boolean isAlreadySubtitled( Downloadable videoDownloadable, Language subtitlesLanguage ) throws IOException, InterruptedException {\n\t\tList<DownloadableFile> allFiles = DownloadableManager.getInstance().getAllFiles( videoDownloadable.getId() );\n\t\tPath mainVideoFilePath;\n\t\tString filename;\n\t\tOptional<Path> optPath = selectMainVideoFile( allFiles );\n\t\tif (optPath.isPresent()) {\n\t\t\tmainVideoFilePath = optPath.get();\n\t\t\tfilename = mainVideoFilePath.getFileName().toString();\n\t\t} else {\n\t\t\tErrorManager.getInstance().reportError(String.format(\"No video file found for %s\", videoDownloadable.toString()));\n\t\t\treturn false;\n\t\t}\n\t\tif (subtitlesLanguage == null) {\n\t\t\treturn true;\n\t\t}\n\t\tif (subtitlesLanguage.getSubTokens() != null) {\n\t\t\t\/\/ Test if the filename contains an indication of the subtitles (VOSTFR, ...)\n\t\t\tfor (String subToken : subtitlesLanguage.getSubTokens()) {\n\t\t\t\tif ( StringUtils.containsIgnoreCase( filename, subToken) ) {\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tVideoMetaData metaData = getInstance().getMetaData(videoDownloadable, mainVideoFilePath);\n\t\tif (metaData.getSubtitleLanguages() != null) {\n\t\t\tfor (Locale locale : metaData.getSubtitleLanguages()) {\n\t\t\t\tif (locale.getLanguage().equals( subtitlesLanguage.getLocale().getLanguage() )) {\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tList<DownloadableFile> subtitleFiles =\n\t\t\t\tallFiles.stream()\n\t\t\t\t.filter( file -> SubtitlesFileFilter.getInstance().accept( file.getFilePath() ) )\n\t\t\t\t.collect( Collectors.toList() );\n\t\tString filenameWithoutExtension = filename; \n\t\tif ( filenameWithoutExtension.lastIndexOf('.') > 0 ) {\n\t\t\tfilenameWithoutExtension = filenameWithoutExtension.substring( 0, filenameWithoutExtension.lastIndexOf('.'));\n\t\t}\n\t\tString targetFileNameRegExp = filenameWithoutExtension + \".\" + subtitlesLanguage.getShortName() + \"\\\\.srt\";\n\t\tfor (DownloadableFile subTitleFile : subtitleFiles) {\n\t\t\tString subtitleFileName = subTitleFile.getFilePath().getFileName().toString();\n\t\t\tif (RegExp.matches(subtitleFileName, targetFileNameRegExp )) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t\t\/\/ FIXME : this last test will accept any subtitle file without checking the language\n\t\tif (!subtitleFiles.isEmpty()) {\n\t\t\treturn true;\n\t\t}\n\t\treturn false;\n\t}","code_wo_comment":"public static boolean isAlreadySubtitled( Downloadable videoDownloadable, Language subtitlesLanguage ) throws IOException, InterruptedException {\n\t\tList<DownloadableFile> allFiles = DownloadableManager.getInstance().getAllFiles( videoDownloadable.getId() );\n\t\tPath mainVideoFilePath;\n\t\tString filename;\n\t\tOptional<Path> optPath = selectMainVideoFile( allFiles );\n\t\tif (optPath.isPresent()) {\n\t\t\tmainVideoFilePath = optPath.get();\n\t\t\tfilename = mainVideoFilePath.getFileName().toString();\n\t\t} else {\n\t\t\tErrorManager.getInstance().reportError(String.format(\"No video file found for %s\", videoDownloadable.toString()));\n\t\t\treturn false;\n\t\t}\n\t\tif (subtitlesLanguage == null) {\n\t\t\treturn true;\n\t\t}\n\t\tif (subtitlesLanguage.getSubTokens() != null) {\n\t\t\n\t\t\tfor (String subToken : subtitlesLanguage.getSubTokens()) {\n\t\t\t\tif ( StringUtils.containsIgnoreCase( filename, subToken) ) {\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tVideoMetaData metaData = getInstance().getMetaData(videoDownloadable, mainVideoFilePath);\n\t\tif (metaData.getSubtitleLanguages() != null) {\n\t\t\tfor (Locale locale : metaData.getSubtitleLanguages()) {\n\t\t\t\tif (locale.getLanguage().equals( subtitlesLanguage.getLocale().getLanguage() )) {\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tList<DownloadableFile> subtitleFiles =\n\t\t\t\tallFiles.stream()\n\t\t\t\t.filter( file -> SubtitlesFileFilter.getInstance().accept( file.getFilePath() ) )\n\t\t\t\t.collect( Collectors.toList() );\n\t\tString filenameWithoutExtension = filename; \n\t\tif ( filenameWithoutExtension.lastIndexOf('.') > 0 ) {\n\t\t\tfilenameWithoutExtension = filenameWithoutExtension.substring( 0, filenameWithoutExtension.lastIndexOf('.'));\n\t\t}\n\t\tString targetFileNameRegExp = filenameWithoutExtension + \".\" + subtitlesLanguage.getShortName() + \"\\\\.srt\";\n\t\tfor (DownloadableFile subTitleFile : subtitleFiles) {\n\t\t\tString subtitleFileName = subTitleFile.getFilePath().getFileName().toString();\n\t\t\tif (RegExp.matches(subtitleFileName, targetFileNameRegExp )) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t\n\t\tif (!subtitleFiles.isEmpty()) {\n\t\t\treturn true;\n\t\t}\n\t\treturn false;\n\t}","cleancode":"public static boolean isalreadysubtitled( downloadable videodownloadable, language subtitleslanguage ) throws ioexception, interruptedexception { list<downloadablefile> allfiles = downloadablemanager.getinstance().getallfiles( videodownloadable.getid() ); path mainvideofilepath; string filename; optional<path> optpath = selectmainvideofile( allfiles ); if (optpath.ispresent()) { mainvideofilepath = optpath.get(); filename = mainvideofilepath.getfilename().tostring(); } else { errormanager.getinstance().reporterror(string.format(\"no video file found for %s\", videodownloadable.tostring())); return false; } if (subtitleslanguage == null) { return true; } if (subtitleslanguage.getsubtokens() != null) { for (string subtoken : subtitleslanguage.getsubtokens()) { if ( stringutils.containsignorecase( filename, subtoken) ) { return true; } } } videometadata metadata = getinstance().getmetadata(videodownloadable, mainvideofilepath); if (metadata.getsubtitlelanguages() != null) { for (locale locale : metadata.getsubtitlelanguages()) { if (locale.getlanguage().equals( subtitleslanguage.getlocale().getlanguage() )) { return true; } } } list<downloadablefile> subtitlefiles = allfiles.stream() .filter( file -> subtitlesfilefilter.getinstance().accept( file.getfilepath() ) ) .collect( collectors.tolist() ); string filenamewithoutextension = filename; if ( filenamewithoutextension.lastindexof('.') > 0 ) { filenamewithoutextension = filenamewithoutextension.substring( 0, filenamewithoutextension.lastindexof('.')); } string targetfilenameregexp = filenamewithoutextension + \".\" + subtitleslanguage.getshortname() + \"\\\\.srt\"; for (downloadablefile subtitlefile : subtitlefiles) { string subtitlefilename = subtitlefile.getfilepath().getfilename().tostring(); if (regexp.matches(subtitlefilename, targetfilenameregexp )) { return true; } } if (!subtitlefiles.isempty()) { return true; } return false; }","repo":"mozvip\/dynamo","label":[0,0,1,0]}
{"id":14893,"original_code":"public void addBlock(Set<CFANode> nodes, CFANode blockHead) {\n    Set<ReferencedVariable> referencedVariables = collectReferencedVariables(nodes);\n    Set<CFANode> callNodes = collectCallNodes(nodes);\n    Set<CFANode> returnNodes = collectReturnNodes(nodes);\n    Set<FunctionEntryNode> innerFunctionCalls = collectInnerFunctionCalls(nodes);\n    if (callNodes.isEmpty()) {\n     \/* What shall we do with function, which is not called from anywhere?\n      * There are problems with them at partitioning building stage\n      *\/\n      return;\n    }\n    CFANode registerNode = null;\n    for (CFANode node : callNodes) {\n      registerNode = node;\n      if (node instanceof FunctionEntryNode) {\n        break;\n      }\n    }\n    if (registerNode == null) {\n      \/\/It means, that there is no entry in this block. Don't add it\n      return;\n    }\n    referencedVariablesMap.put(registerNode, referencedVariables);\n    callNodesMap.put(registerNode, callNodes);\n    returnNodesMap.put(registerNode, returnNodes);\n    innerFunctionCallsMap.put(registerNode, innerFunctionCalls);\n    blockNodesMap.put(registerNode, nodes);\n  }","code_wo_comment":"public void addBlock(Set<CFANode> nodes, CFANode blockHead) {\n    Set<ReferencedVariable> referencedVariables = collectReferencedVariables(nodes);\n    Set<CFANode> callNodes = collectCallNodes(nodes);\n    Set<CFANode> returnNodes = collectReturnNodes(nodes);\n    Set<FunctionEntryNode> innerFunctionCalls = collectInnerFunctionCalls(nodes);\n    if (callNodes.isEmpty()) {\n    \n      return;\n    }\n    CFANode registerNode = null;\n    for (CFANode node : callNodes) {\n      registerNode = node;\n      if (node instanceof FunctionEntryNode) {\n        break;\n      }\n    }\n    if (registerNode == null) {\n     \n      return;\n    }\n    referencedVariablesMap.put(registerNode, referencedVariables);\n    callNodesMap.put(registerNode, callNodes);\n    returnNodesMap.put(registerNode, returnNodes);\n    innerFunctionCallsMap.put(registerNode, innerFunctionCalls);\n    blockNodesMap.put(registerNode, nodes);\n  }","cleancode":"public void addblock(set<cfanode> nodes, cfanode blockhead) { set<referencedvariable> referencedvariables = collectreferencedvariables(nodes); set<cfanode> callnodes = collectcallnodes(nodes); set<cfanode> returnnodes = collectreturnnodes(nodes); set<functionentrynode> innerfunctioncalls = collectinnerfunctioncalls(nodes); if (callnodes.isempty()) { return; } cfanode registernode = null; for (cfanode node : callnodes) { registernode = node; if (node instanceof functionentrynode) { break; } } if (registernode == null) { return; } referencedvariablesmap.put(registernode, referencedvariables); callnodesmap.put(registernode, callnodes); returnnodesmap.put(registernode, returnnodes); innerfunctioncallsmap.put(registernode, innerfunctioncalls); blocknodesmap.put(registernode, nodes); }","repo":"prokopk1n\/cpachecker-1","label":[0,1,0,0]}
{"id":23121,"original_code":"@Test\n  public void isJson_shouldReturnTrue_whenStringIsJsonArray() throws JSONException {\n    assertTrue(validateTor.isJSON(\"[]\"));\n    assertTrue(validateTor.isJSON(\"[{\\\"id\\\":1}]\"));\n  }","code_wo_comment":"@Test\n  public void isJson_shouldReturnTrue_whenStringIsJsonArray() throws JSONException {\n    assertTrue(validateTor.isJSON(\"[]\"));\n    assertTrue(validateTor.isJSON(\"[{\\\"id\\\":1}]\"));\n  }","cleancode":"@test public void isjson_shouldreturntrue_whenstringisjsonarray() throws jsonexception { asserttrue(validatetor.isjson(\"[]\")); asserttrue(validatetor.isjson(\"[{\\\"id\\\":1}]\")); }","repo":"nisrulz\/validatetor","label":[0,0,1,0]}
{"id":23144,"original_code":"private static FieldImpl makePointObs(FlatField timeStep, DateTime dt)\n            throws VisADException, RemoteException {\n        if (timeStep == null) {\n            return null;\n        }\n        SampledSet domain    = getSpatialDomain(timeStep);\n        int        numPoints = domain.getLength();\n        Integer1DSet points = new Integer1DSet(RealType.getRealType(\"index\"),\n                numPoints);\n        TupleType tt = getParamType(timeStep);\n        TupleType rangeType = new TupleType(new MathType[] {\n                RealTupleType.LatitudeLongitudeAltitude,\n                RealType.Time,\n                tt });\n        FieldImpl ff = new FieldImpl(\n                new FunctionType(\n                        ((SetType) points.getType()).getDomain(),\n                        rangeType), points);\n        float[][] samples  = timeStep.getFloats(false);\n        float[][] geoVals  = getEarthLocationPoints((GriddedSet) domain);\n        boolean   isLatLon = isLatLonOrder(domain);\n        int       latIndex = isLatLon\n                ? 0\n                : 1;\n        int       lonIndex = isLatLon\n                ? 1\n                : 0;\n        boolean   haveAlt  = geoVals.length > 2;\n        for (int i = 0; i < numPoints; i++) {\n            float lat = geoVals[latIndex][i];\n            float lon = geoVals[lonIndex][i];\n            float alt = haveAlt\n                    ? geoVals[2][i]\n                    : 0;\n            if ((lat == lat) && (lon == lon)) {\n                if ( !(alt == alt)) {\n                    alt = 0;\n                }\n                EarthLocation el = new EarthLocationLite(lat, lon, alt);\n                \/\/ TODO:  make this  more efficient\n                PointObTuple pot = new PointObTuple(el, dt,\n                        timeStep.getSample(i), rangeType);\n                ff.setSample(i, pot, false, false);\n            }\n        }\n        return ff;\n    }","code_wo_comment":"private static FieldImpl makePointObs(FlatField timeStep, DateTime dt)\n            throws VisADException, RemoteException {\n        if (timeStep == null) {\n            return null;\n        }\n        SampledSet domain    = getSpatialDomain(timeStep);\n        int        numPoints = domain.getLength();\n        Integer1DSet points = new Integer1DSet(RealType.getRealType(\"index\"),\n                numPoints);\n        TupleType tt = getParamType(timeStep);\n        TupleType rangeType = new TupleType(new MathType[] {\n                RealTupleType.LatitudeLongitudeAltitude,\n                RealType.Time,\n                tt });\n        FieldImpl ff = new FieldImpl(\n                new FunctionType(\n                        ((SetType) points.getType()).getDomain(),\n                        rangeType), points);\n        float[][] samples  = timeStep.getFloats(false);\n        float[][] geoVals  = getEarthLocationPoints((GriddedSet) domain);\n        boolean   isLatLon = isLatLonOrder(domain);\n        int       latIndex = isLatLon\n                ? 0\n                : 1;\n        int       lonIndex = isLatLon\n                ? 1\n                : 0;\n        boolean   haveAlt  = geoVals.length > 2;\n        for (int i = 0; i < numPoints; i++) {\n            float lat = geoVals[latIndex][i];\n            float lon = geoVals[lonIndex][i];\n            float alt = haveAlt\n                    ? geoVals[2][i]\n                    : 0;\n            if ((lat == lat) && (lon == lon)) {\n                if ( !(alt == alt)) {\n                    alt = 0;\n                }\n                EarthLocation el = new EarthLocationLite(lat, lon, alt);\n               \n                PointObTuple pot = new PointObTuple(el, dt,\n                        timeStep.getSample(i), rangeType);\n                ff.setSample(i, pot, false, false);\n            }\n        }\n        return ff;\n    }","cleancode":"private static fieldimpl makepointobs(flatfield timestep, datetime dt) throws visadexception, remoteexception { if (timestep == null) { return null; } sampledset domain = getspatialdomain(timestep); int numpoints = domain.getlength(); integer1dset points = new integer1dset(realtype.getrealtype(\"index\"), numpoints); tupletype tt = getparamtype(timestep); tupletype rangetype = new tupletype(new mathtype[] { realtupletype.latitudelongitudealtitude, realtype.time, tt }); fieldimpl ff = new fieldimpl( new functiontype( ((settype) points.gettype()).getdomain(), rangetype), points); float[][] samples = timestep.getfloats(false); float[][] geovals = getearthlocationpoints((griddedset) domain); boolean islatlon = islatlonorder(domain); int latindex = islatlon ? 0 : 1; int lonindex = islatlon ? 1 : 0; boolean havealt = geovals.length > 2; for (int i = 0; i < numpoints; i++) { float lat = geovals[latindex][i]; float lon = geovals[lonindex][i]; float alt = havealt ? geovals[2][i] : 0; if ((lat == lat) && (lon == lon)) { if ( !(alt == alt)) { alt = 0; } earthlocation el = new earthlocationlite(lat, lon, alt); pointobtuple pot = new pointobtuple(el, dt, timestep.getsample(i), rangetype); ff.setsample(i, pot, false, false); } } return ff; }","repo":"oxelson\/IDV","label":[1,0,0,0]}
{"id":23145,"original_code":"private static FieldImpl makePointObs(FlatField timeStep, DateTime dt, String function)\n            throws VisADException, RemoteException {\n        final boolean doMax = function.equals(FUNC_MAX);\n        final boolean doMin = function.equals(FUNC_MIN);\n        if (timeStep == null) {\n            return null;\n        }\n        SampledSet domain    = getSpatialDomain(timeStep);\n        int        numPoints = domain.getLength();\n        Integer1DSet points = new Integer1DSet(RealType.getRealType(\"index\"),\n                numPoints);\n        TupleType tt = getParamType(timeStep);\n        TupleType rangeType = new TupleType(new MathType[] {\n                RealTupleType.LatitudeLongitudeAltitude,\n                RealType.Time,\n                tt });\n        FieldImpl ff = new FieldImpl(\n                new FunctionType(\n                        ((SetType) points.getType()).getDomain(),\n                        rangeType), points);\n        float[][] samples  = timeStep.getFloats(false);\n        float[][] geoVals  = getEarthLocationPoints((GriddedSet) domain);\n        boolean   isLatLon = isLatLonOrder(domain);\n        int       latIndex = isLatLon\n                ? 0\n                : 1;\n        int       lonIndex = isLatLon\n                ? 1\n                : 0;\n        boolean   haveAlt  = geoVals.length > 2;\n        float   pMin   = Float.POSITIVE_INFINITY;\n        float   pMax   = Float.NEGATIVE_INFINITY;\n        int index = 0;\n        for (int i = 0; i < numPoints; i++) {\n            float lat = geoVals[latIndex][i];\n            float lon = geoVals[lonIndex][i];\n            float alt = haveAlt\n                    ? geoVals[2][i]\n                    : 0;\n            if ((lat == lat) && (lon == lon)) {\n                if ( !(alt == alt)) {\n                    alt = 0;\n                }\n                if(doMax && (float)timeStep.getValues(i)[0] >= pMax){\n                    pMax = (float)timeStep.getValues(i)[0];\n                    index = i;\n                } else if(doMin && (float)timeStep.getValues(i)[0] < pMin){\n                    pMin = (float)timeStep.getValues(i)[0];\n                    index = i;\n                }\n            }\n        }\n        float alt0  = haveAlt\n                ? geoVals[2][index]\n                : 0;\n        EarthLocation el0 = new EarthLocationLite(geoVals[latIndex][index], geoVals[lonIndex][index], alt0);\n        \/\/ TODO:  make this  more efficient\n        PointObTuple pot = new PointObTuple(el0, dt,\n                timeStep.getSample(index), rangeType);\n        ff.setSample(0, pot, false, false);\n        return ff;\n    }","code_wo_comment":"private static FieldImpl makePointObs(FlatField timeStep, DateTime dt, String function)\n            throws VisADException, RemoteException {\n        final boolean doMax = function.equals(FUNC_MAX);\n        final boolean doMin = function.equals(FUNC_MIN);\n        if (timeStep == null) {\n            return null;\n        }\n        SampledSet domain    = getSpatialDomain(timeStep);\n        int        numPoints = domain.getLength();\n        Integer1DSet points = new Integer1DSet(RealType.getRealType(\"index\"),\n                numPoints);\n        TupleType tt = getParamType(timeStep);\n        TupleType rangeType = new TupleType(new MathType[] {\n                RealTupleType.LatitudeLongitudeAltitude,\n                RealType.Time,\n                tt });\n        FieldImpl ff = new FieldImpl(\n                new FunctionType(\n                        ((SetType) points.getType()).getDomain(),\n                        rangeType), points);\n        float[][] samples  = timeStep.getFloats(false);\n        float[][] geoVals  = getEarthLocationPoints((GriddedSet) domain);\n        boolean   isLatLon = isLatLonOrder(domain);\n        int       latIndex = isLatLon\n                ? 0\n                : 1;\n        int       lonIndex = isLatLon\n                ? 1\n                : 0;\n        boolean   haveAlt  = geoVals.length > 2;\n        float   pMin   = Float.POSITIVE_INFINITY;\n        float   pMax   = Float.NEGATIVE_INFINITY;\n        int index = 0;\n        for (int i = 0; i < numPoints; i++) {\n            float lat = geoVals[latIndex][i];\n            float lon = geoVals[lonIndex][i];\n            float alt = haveAlt\n                    ? geoVals[2][i]\n                    : 0;\n            if ((lat == lat) && (lon == lon)) {\n                if ( !(alt == alt)) {\n                    alt = 0;\n                }\n                if(doMax && (float)timeStep.getValues(i)[0] >= pMax){\n                    pMax = (float)timeStep.getValues(i)[0];\n                    index = i;\n                } else if(doMin && (float)timeStep.getValues(i)[0] < pMin){\n                    pMin = (float)timeStep.getValues(i)[0];\n                    index = i;\n                }\n            }\n        }\n        float alt0  = haveAlt\n                ? geoVals[2][index]\n                : 0;\n        EarthLocation el0 = new EarthLocationLite(geoVals[latIndex][index], geoVals[lonIndex][index], alt0);\n       \n        PointObTuple pot = new PointObTuple(el0, dt,\n                timeStep.getSample(index), rangeType);\n        ff.setSample(0, pot, false, false);\n        return ff;\n    }","cleancode":"private static fieldimpl makepointobs(flatfield timestep, datetime dt, string function) throws visadexception, remoteexception { final boolean domax = function.equals(func_max); final boolean domin = function.equals(func_min); if (timestep == null) { return null; } sampledset domain = getspatialdomain(timestep); int numpoints = domain.getlength(); integer1dset points = new integer1dset(realtype.getrealtype(\"index\"), numpoints); tupletype tt = getparamtype(timestep); tupletype rangetype = new tupletype(new mathtype[] { realtupletype.latitudelongitudealtitude, realtype.time, tt }); fieldimpl ff = new fieldimpl( new functiontype( ((settype) points.gettype()).getdomain(), rangetype), points); float[][] samples = timestep.getfloats(false); float[][] geovals = getearthlocationpoints((griddedset) domain); boolean islatlon = islatlonorder(domain); int latindex = islatlon ? 0 : 1; int lonindex = islatlon ? 1 : 0; boolean havealt = geovals.length > 2; float pmin = float.positive_infinity; float pmax = float.negative_infinity; int index = 0; for (int i = 0; i < numpoints; i++) { float lat = geovals[latindex][i]; float lon = geovals[lonindex][i]; float alt = havealt ? geovals[2][i] : 0; if ((lat == lat) && (lon == lon)) { if ( !(alt == alt)) { alt = 0; } if(domax && (float)timestep.getvalues(i)[0] >= pmax){ pmax = (float)timestep.getvalues(i)[0]; index = i; } else if(domin && (float)timestep.getvalues(i)[0] < pmin){ pmin = (float)timestep.getvalues(i)[0]; index = i; } } } float alt0 = havealt ? geovals[2][index] : 0; earthlocation el0 = new earthlocationlite(geovals[latindex][index], geovals[lonindex][index], alt0); pointobtuple pot = new pointobtuple(el0, dt, timestep.getsample(index), rangetype); ff.setsample(0, pot, false, false); return ff; }","repo":"oxelson\/IDV","label":[1,0,0,0]}
{"id":23146,"original_code":"private static FieldImpl makePointObs(FlatField timeStep, DateTime dt, double min, double max)\n            throws VisADException, RemoteException {\n        if (timeStep == null) {\n            return null;\n        }\n        SampledSet domain    = getSpatialDomain(timeStep);\n        int        numPoints = domain.getLength();\n        Integer1DSet points = new Integer1DSet(RealType.getRealType(\"index\"),\n                numPoints);\n        TupleType tt = getParamType(timeStep);\n        TupleType rangeType = new TupleType(new MathType[] {\n                RealTupleType.LatitudeLongitudeAltitude,\n                RealType.Time,\n                tt });\n        FieldImpl ff = new FieldImpl(\n                new FunctionType(\n                        ((SetType) points.getType()).getDomain(),\n                        rangeType), points);\n        float[][] samples  = timeStep.getFloats(false);\n        float[][] geoVals  = getEarthLocationPoints((GriddedSet) domain);\n        boolean   isLatLon = isLatLonOrder(domain);\n        int       latIndex = isLatLon\n                ? 0\n                : 1;\n        int       lonIndex = isLatLon\n                ? 1\n                : 0;\n        boolean   haveAlt  = geoVals.length > 2;\n        for (int i = 0; i < numPoints; i++) {\n            float lat = geoVals[latIndex][i];\n            float lon = geoVals[lonIndex][i];\n            float alt = haveAlt\n                    ? geoVals[2][i]\n                    : 0;\n            if ((lat == lat) && (lon == lon)) {\n                if ( !(alt == alt)) {\n                    alt = 0;\n                }\n                if(timeStep.getValues(i)[0] >= min && timeStep.getValues(i)[0] < max) {\n                    EarthLocation el = new EarthLocationLite(lat, lon, alt);\n                    \/\/ TODO:  make this  more efficient\n                    PointObTuple pot = new PointObTuple(el, dt,\n                            timeStep.getSample(i), rangeType);\n                    ff.setSample(i, pot, false, false);\n                }\n            }\n        }\n        return ff;\n    }","code_wo_comment":"private static FieldImpl makePointObs(FlatField timeStep, DateTime dt, double min, double max)\n            throws VisADException, RemoteException {\n        if (timeStep == null) {\n            return null;\n        }\n        SampledSet domain    = getSpatialDomain(timeStep);\n        int        numPoints = domain.getLength();\n        Integer1DSet points = new Integer1DSet(RealType.getRealType(\"index\"),\n                numPoints);\n        TupleType tt = getParamType(timeStep);\n        TupleType rangeType = new TupleType(new MathType[] {\n                RealTupleType.LatitudeLongitudeAltitude,\n                RealType.Time,\n                tt });\n        FieldImpl ff = new FieldImpl(\n                new FunctionType(\n                        ((SetType) points.getType()).getDomain(),\n                        rangeType), points);\n        float[][] samples  = timeStep.getFloats(false);\n        float[][] geoVals  = getEarthLocationPoints((GriddedSet) domain);\n        boolean   isLatLon = isLatLonOrder(domain);\n        int       latIndex = isLatLon\n                ? 0\n                : 1;\n        int       lonIndex = isLatLon\n                ? 1\n                : 0;\n        boolean   haveAlt  = geoVals.length > 2;\n        for (int i = 0; i < numPoints; i++) {\n            float lat = geoVals[latIndex][i];\n            float lon = geoVals[lonIndex][i];\n            float alt = haveAlt\n                    ? geoVals[2][i]\n                    : 0;\n            if ((lat == lat) && (lon == lon)) {\n                if ( !(alt == alt)) {\n                    alt = 0;\n                }\n                if(timeStep.getValues(i)[0] >= min && timeStep.getValues(i)[0] < max) {\n                    EarthLocation el = new EarthLocationLite(lat, lon, alt);\n                   \n                    PointObTuple pot = new PointObTuple(el, dt,\n                            timeStep.getSample(i), rangeType);\n                    ff.setSample(i, pot, false, false);\n                }\n            }\n        }\n        return ff;\n    }","cleancode":"private static fieldimpl makepointobs(flatfield timestep, datetime dt, double min, double max) throws visadexception, remoteexception { if (timestep == null) { return null; } sampledset domain = getspatialdomain(timestep); int numpoints = domain.getlength(); integer1dset points = new integer1dset(realtype.getrealtype(\"index\"), numpoints); tupletype tt = getparamtype(timestep); tupletype rangetype = new tupletype(new mathtype[] { realtupletype.latitudelongitudealtitude, realtype.time, tt }); fieldimpl ff = new fieldimpl( new functiontype( ((settype) points.gettype()).getdomain(), rangetype), points); float[][] samples = timestep.getfloats(false); float[][] geovals = getearthlocationpoints((griddedset) domain); boolean islatlon = islatlonorder(domain); int latindex = islatlon ? 0 : 1; int lonindex = islatlon ? 1 : 0; boolean havealt = geovals.length > 2; for (int i = 0; i < numpoints; i++) { float lat = geovals[latindex][i]; float lon = geovals[lonindex][i]; float alt = havealt ? geovals[2][i] : 0; if ((lat == lat) && (lon == lon)) { if ( !(alt == alt)) { alt = 0; } if(timestep.getvalues(i)[0] >= min && timestep.getvalues(i)[0] < max) { earthlocation el = new earthlocationlite(lat, lon, alt); pointobtuple pot = new pointobtuple(el, dt, timestep.getsample(i), rangetype); ff.setsample(i, pot, false, false); } } } return ff; }","repo":"oxelson\/IDV","label":[1,0,0,0]}
{"id":14974,"original_code":"@Nullable\n    @Deprecated\n    public static Character max(@Nullable CharSequence charSequence) {\n        return maxOrNull(charSequence);\n    }","code_wo_comment":"@Nullable\n    @Deprecated\n    public static Character max(@Nullable CharSequence charSequence) {\n        return maxOrNull(charSequence);\n    }","cleancode":"@nullable @deprecated public static character max(@nullable charsequence charsequence) { return maxornull(charsequence); }","repo":"panpf\/tools4j","label":[0,0,0,0]}
{"id":14975,"original_code":"@Nullable\n    @Deprecated\n    public static <R extends Comparable<R>> Character maxBy(@Nullable CharSequence charSequence, @NotNull Transformer<Character, R> selector) {\n        return maxByOrNull(charSequence, selector);\n    }","code_wo_comment":"@Nullable\n    @Deprecated\n    public static <R extends Comparable<R>> Character maxBy(@Nullable CharSequence charSequence, @NotNull Transformer<Character, R> selector) {\n        return maxByOrNull(charSequence, selector);\n    }","cleancode":"@nullable @deprecated public static <r extends comparable<r>> character maxby(@nullable charsequence charsequence, @notnull transformer<character, r> selector) { return maxbyornull(charsequence, selector); }","repo":"panpf\/tools4j","label":[0,0,0,0]}
{"id":14976,"original_code":"@Nullable\n    @Deprecated\n    public static Character min(@Nullable CharSequence charSequence) {\n        return minOrNull(charSequence);\n    }","code_wo_comment":"@Nullable\n    @Deprecated\n    public static Character min(@Nullable CharSequence charSequence) {\n        return minOrNull(charSequence);\n    }","cleancode":"@nullable @deprecated public static character min(@nullable charsequence charsequence) { return minornull(charsequence); }","repo":"panpf\/tools4j","label":[0,0,0,0]}
{"id":14977,"original_code":"@Nullable\n    @Deprecated\n    public static <R extends Comparable<R>> Character minBy(@Nullable CharSequence charSequence, @NotNull Transformer<Character, R> selector) {\n        return minByOrNull(charSequence, selector);\n    }","code_wo_comment":"@Nullable\n    @Deprecated\n    public static <R extends Comparable<R>> Character minBy(@Nullable CharSequence charSequence, @NotNull Transformer<Character, R> selector) {\n        return minByOrNull(charSequence, selector);\n    }","cleancode":"@nullable @deprecated public static <r extends comparable<r>> character minby(@nullable charsequence charsequence, @notnull transformer<character, r> selector) { return minbyornull(charsequence, selector); }","repo":"panpf\/tools4j","label":[0,0,0,0]}
{"id":23182,"original_code":"public static void main(String[] args) {\n        \/\/ TODO code application logic her\n        \/\/ Hola Onasis\n        int num = 0;\n        \/\/ Holaaaaa\n        \/\/ QQUE ONDASS\n        switch(num){\n            case 1:\n            case 2:\n            default:\n        }\n        \/\/\n    }","code_wo_comment":"public static void main(String[] args) {\n       \n       \n        int num = 0;\n       \n       \n        switch(num){\n            case 1:\n            case 2:\n            default:\n        }\n       \n    }","cleancode":"public static void main(string[] args) { int num = 0; switch(num){ case 1: case 2: default: } }","repo":"monicastle\/Prueba","label":[0,1,0,0]}
{"id":31571,"original_code":"private Object convertNullValue(RdsTableColumnDetails theColumnDetail) {\n        if (theColumnDetail.isNullable()) {\n            return null;\n        }\n        \/\/ For integral number type things, need to convert \"null\" into 0.\n        if (theColumnDetail.isIntegralType()) {\n            return new Integer(0);\n        }\n        \/\/ For decimal number type things, need to convert \"null\" into 0.0.\n        if (theColumnDetail.isDecimalType()) {\n            return new Double(0.0);\n        }\n        return null; \/\/ What can we do in this case :(\n    }","code_wo_comment":"private Object convertNullValue(RdsTableColumnDetails theColumnDetail) {\n        if (theColumnDetail.isNullable()) {\n            return null;\n        }\n       \n        if (theColumnDetail.isIntegralType()) {\n            return new Integer(0);\n        }\n       \n        if (theColumnDetail.isDecimalType()) {\n            return new Double(0.0);\n        }\n        return null;\n    }","cleancode":"private object convertnullvalue(rdstablecolumndetails thecolumndetail) { if (thecolumndetail.isnullable()) { return null; } if (thecolumndetail.isintegraltype()) { return new integer(0); } if (thecolumndetail.isdecimaltype()) { return new double(0.0); } return null; }","repo":"ogreflow\/ogre","label":[1,0,0,0]}
{"id":23738,"original_code":"@Override\n    public void validateStatusOnUpdate(Post post) {\n        \/\/ TODO Implement a method\n    }","code_wo_comment":"@Override\n    public void validateStatusOnUpdate(Post post) {\n       \n    }","cleancode":"@override public void validatestatusonupdate(post post) { }","repo":"reckue\/note-api","label":[0,1,0,0]}
{"id":32092,"original_code":"private boolean validParameters(List<String> parameters) {\n        \/\/ TODO: throw a parsing error exception on the YAML parser when params size is less than 2.\n        return CollectionUtils.isNotEmpty(parameters) && parameters.size() >= 2;\n    }","code_wo_comment":"private boolean validParameters(List<String> parameters) {\n       \n        return CollectionUtils.isNotEmpty(parameters) && parameters.size() >= 2;\n    }","cleancode":"private boolean validparameters(list<string> parameters) { return collectionutils.isnotempty(parameters) && parameters.size() >= 2; }","repo":"ngouagna\/alien4cloud-cloudify2-provider","label":[0,1,0,0]}
{"id":15833,"original_code":"private String get_location ()\n    {\n        final StackTraceElement[] stackTrace = new Throwable ().getStackTrace ();\n        for (int i = 2 \/* skip this+serviceChanged *\/; i < stackTrace.length; i++)\n        {\n            StackTraceElement ste = stackTrace [i];\n            String class_name = ste.getClassName ();\n            if (!class_name.startsWith (\"org.apache.felix.framework.\")      \/\/ Skip framework (todo: add more fws)\n                    && !class_name.equals (this.getClass ().getName ()))    \/\/ Skip ourselves\n            {\n                return (ste.toString ());\n            }\n        }\n        return (\"StackTraceElement:Unknown\");\n    }","code_wo_comment":"private String get_location ()\n    {\n        final StackTraceElement[] stackTrace = new Throwable ().getStackTrace ();\n        for (int i = 2; i < stackTrace.length; i++)\n        {\n            StackTraceElement ste = stackTrace [i];\n            String class_name = ste.getClassName ();\n            if (!class_name.startsWith (\"org.apache.felix.framework.\")     \n                    && !class_name.equals (this.getClass ().getName ()))   \n            {\n                return (ste.toString ());\n            }\n        }\n        return (\"StackTraceElement:Unknown\");\n    }","cleancode":"private string get_location () { final stacktraceelement[] stacktrace = new throwable ().getstacktrace (); for (int i = 2; i < stacktrace.length; i++) { stacktraceelement ste = stacktrace [i]; string class_name = ste.getclassname (); if (!class_name.startswith (\"org.apache.felix.framework.\") && !class_name.equals (this.getclass ().getname ())) { return (ste.tostring ()); } } return (\"stacktraceelement:unknown\"); }","repo":"neoautus\/lucidj-core","label":[1,0,0,0]}
{"id":7735,"original_code":"public static void main(String[] args) {\n    \/\/ TODO(pdex): why are we making our own threadpool?\n    final List<ListeningExecutorService> l =\n        Spez.ServicePoolGenerator(THREAD_POOL, \"Spanner Tailer Event Worker\");\n    final SpannerTailer tailer = new SpannerTailer(THREAD_POOL, 200000000);\n    \/\/ final EventPublisher publisher = new EventPublisher(PROJECT_NAME, TOPIC_NAME);\n    final ThreadLocal<EventPublisher> publisher =\n        ThreadLocal.withInitial(\n            () -> {\n              return new EventPublisher(PROJECT_NAME, TOPIC_NAME);\n            });\n    final ExecutorService workStealingPool = Executors.newWorkStealingPool();\n    final ListeningExecutorService forkJoinPool =\n        MoreExecutors.listeningDecorator(workStealingPool);\n    final Map<String, String> metadata = new HashMap<>();\n    final CountDownLatch doneSignal = new CountDownLatch(1);\n    final ScheduledExecutorService scheduler = Executors.newScheduledThreadPool(1);\n    \/\/ Populate CDC Metadata\n    metadata.put(\"SrcDatabase\", DB_NAME);\n    metadata.put(\"SrcTablename\", TABLE_NAME);\n    metadata.put(\"DstTopic\", TOPIC_NAME);\n    final ListenableFuture<SchemaSet> schemaSetFuture =\n        tailer.getSchema(PROJECT_NAME, INSTANCE_NAME, DB_NAME, TABLE_NAME);\n    Futures.addCallback(\n        schemaSetFuture,\n        new FutureCallback<SchemaSet>() {\n          @Override\n          public void onSuccess(SchemaSet schemaSet) {\n            log.info(\"Successfully Processed the Table Schema. Starting the poller now ...\");\n            if (DISRUPTOR) {\n              DisruptorHandler handler =\n                  new DisruptorHandler(schemaSet, publisher, metadata, l.get(0));\n              handler.start();\n              tailer.setRingBuffer(handler.getRingBuffer());\n              ScheduledFuture<?> result =\n                  tailer.start(\n                      2,\n                      500,\n                      PROJECT_NAME,\n                      INSTANCE_NAME,\n                      DB_NAME,\n                      TABLE_NAME,\n                      \"lpts_table\",\n                      schemaSet.tsColName(),\n                      \"2000\");\n              doneSignal.countDown();\n            } else {\n              WorkStealingHandler handler =\n                  new WorkStealingHandler(scheduler, schemaSet, publisher, metadata);\n              tailer.start(\n                  handler,\n                  schemaSet.tsColName(),\n                  l.size(),\n                  THREAD_POOL,\n                  500,\n                  PROJECT_NAME,\n                  INSTANCE_NAME,\n                  DB_NAME,\n                  TABLE_NAME,\n                  \"lpts_table\",\n                  \"2000\",\n                  500,\n                  500);\n              scheduler.scheduleAtFixedRate(\n                  () -> {\n                    handler.logStats();\n                    tailer.logStats();\n                  },\n                  30,\n                  30,\n                  TimeUnit.SECONDS);\n              doneSignal.countDown();\n            }\n          }\n          @Override\n          public void onFailure(Throwable t) {\n            log.error(\"Unable to process schema\", t);\n            System.exit(-1);\n          }\n        },\n        l.get(l.size() % THREAD_POOL));\n    try {\n      log.debug(\"Dumping all known Loggers\");\n      LoggerContext lc = (LoggerContext) LoggerFactory.getILoggerFactory();\n      java.util.Iterator<ch.qos.logback.classic.Logger> it = lc.getLoggerList().iterator();\n      while (it.hasNext()) {\n        ch.qos.logback.classic.Logger thisLog = it.next();\n        log.debug(\"name: {} status: {}\", thisLog.getName(), thisLog.getLevel());\n      }\n      log.info(\"waiting for doneSignal\");\n      doneSignal.await();\n    } catch (InterruptedException e) {\n      e.printStackTrace();\n    }\n  }","code_wo_comment":"public static void main(String[] args) {\n   \n    final List<ListeningExecutorService> l =\n        Spez.ServicePoolGenerator(THREAD_POOL, \"Spanner Tailer Event Worker\");\n    final SpannerTailer tailer = new SpannerTailer(THREAD_POOL, 200000000);\n   \n    final ThreadLocal<EventPublisher> publisher =\n        ThreadLocal.withInitial(\n            () -> {\n              return new EventPublisher(PROJECT_NAME, TOPIC_NAME);\n            });\n    final ExecutorService workStealingPool = Executors.newWorkStealingPool();\n    final ListeningExecutorService forkJoinPool =\n        MoreExecutors.listeningDecorator(workStealingPool);\n    final Map<String, String> metadata = new HashMap<>();\n    final CountDownLatch doneSignal = new CountDownLatch(1);\n    final ScheduledExecutorService scheduler = Executors.newScheduledThreadPool(1);\n   \n    metadata.put(\"SrcDatabase\", DB_NAME);\n    metadata.put(\"SrcTablename\", TABLE_NAME);\n    metadata.put(\"DstTopic\", TOPIC_NAME);\n    final ListenableFuture<SchemaSet> schemaSetFuture =\n        tailer.getSchema(PROJECT_NAME, INSTANCE_NAME, DB_NAME, TABLE_NAME);\n    Futures.addCallback(\n        schemaSetFuture,\n        new FutureCallback<SchemaSet>() {\n          @Override\n          public void onSuccess(SchemaSet schemaSet) {\n            log.info(\"Successfully Processed the Table Schema. Starting the poller now ...\");\n            if (DISRUPTOR) {\n              DisruptorHandler handler =\n                  new DisruptorHandler(schemaSet, publisher, metadata, l.get(0));\n              handler.start();\n              tailer.setRingBuffer(handler.getRingBuffer());\n              ScheduledFuture<?> result =\n                  tailer.start(\n                      2,\n                      500,\n                      PROJECT_NAME,\n                      INSTANCE_NAME,\n                      DB_NAME,\n                      TABLE_NAME,\n                      \"lpts_table\",\n                      schemaSet.tsColName(),\n                      \"2000\");\n              doneSignal.countDown();\n            } else {\n              WorkStealingHandler handler =\n                  new WorkStealingHandler(scheduler, schemaSet, publisher, metadata);\n              tailer.start(\n                  handler,\n                  schemaSet.tsColName(),\n                  l.size(),\n                  THREAD_POOL,\n                  500,\n                  PROJECT_NAME,\n                  INSTANCE_NAME,\n                  DB_NAME,\n                  TABLE_NAME,\n                  \"lpts_table\",\n                  \"2000\",\n                  500,\n                  500);\n              scheduler.scheduleAtFixedRate(\n                  () -> {\n                    handler.logStats();\n                    tailer.logStats();\n                  },\n                  30,\n                  30,\n                  TimeUnit.SECONDS);\n              doneSignal.countDown();\n            }\n          }\n          @Override\n          public void onFailure(Throwable t) {\n            log.error(\"Unable to process schema\", t);\n            System.exit(-1);\n          }\n        },\n        l.get(l.size() % THREAD_POOL));\n    try {\n      log.debug(\"Dumping all known Loggers\");\n      LoggerContext lc = (LoggerContext) LoggerFactory.getILoggerFactory();\n      java.util.Iterator<ch.qos.logback.classic.Logger> it = lc.getLoggerList().iterator();\n      while (it.hasNext()) {\n        ch.qos.logback.classic.Logger thisLog = it.next();\n        log.debug(\"name: {} status: {}\", thisLog.getName(), thisLog.getLevel());\n      }\n      log.info(\"waiting for doneSignal\");\n      doneSignal.await();\n    } catch (InterruptedException e) {\n      e.printStackTrace();\n    }\n  }","cleancode":"public static void main(string[] args) { final list<listeningexecutorservice> l = spez.servicepoolgenerator(thread_pool, \"spanner tailer event worker\"); final spannertailer tailer = new spannertailer(thread_pool, 200000000); final threadlocal<eventpublisher> publisher = threadlocal.withinitial( () -> { return new eventpublisher(project_name, topic_name); }); final executorservice workstealingpool = executors.newworkstealingpool(); final listeningexecutorservice forkjoinpool = moreexecutors.listeningdecorator(workstealingpool); final map<string, string> metadata = new hashmap<>(); final countdownlatch donesignal = new countdownlatch(1); final scheduledexecutorservice scheduler = executors.newscheduledthreadpool(1); metadata.put(\"srcdatabase\", db_name); metadata.put(\"srctablename\", table_name); metadata.put(\"dsttopic\", topic_name); final listenablefuture<schemaset> schemasetfuture = tailer.getschema(project_name, instance_name, db_name, table_name); futures.addcallback( schemasetfuture, new futurecallback<schemaset>() { @override public void onsuccess(schemaset schemaset) { log.info(\"successfully processed the table schema. starting the poller now ...\"); if (disruptor) { disruptorhandler handler = new disruptorhandler(schemaset, publisher, metadata, l.get(0)); handler.start(); tailer.setringbuffer(handler.getringbuffer()); scheduledfuture<?> result = tailer.start( 2, 500, project_name, instance_name, db_name, table_name, \"lpts_table\", schemaset.tscolname(), \"2000\"); donesignal.countdown(); } else { workstealinghandler handler = new workstealinghandler(scheduler, schemaset, publisher, metadata); tailer.start( handler, schemaset.tscolname(), l.size(), thread_pool, 500, project_name, instance_name, db_name, table_name, \"lpts_table\", \"2000\", 500, 500); scheduler.scheduleatfixedrate( () -> { handler.logstats(); tailer.logstats(); }, 30, 30, timeunit.seconds); donesignal.countdown(); } } @override public void onfailure(throwable t) { log.error(\"unable to process schema\", t); system.exit(-1); } }, l.get(l.size() % thread_pool)); try { log.debug(\"dumping all known loggers\"); loggercontext lc = (loggercontext) loggerfactory.getiloggerfactory(); java.util.iterator<ch.qos.logback.classic.logger> it = lc.getloggerlist().iterator(); while (it.hasnext()) { ch.qos.logback.classic.logger thislog = it.next(); log.debug(\"name: {} status: {}\", thislog.getname(), thislog.getlevel()); } log.info(\"waiting for donesignal\"); donesignal.await(); } catch (interruptedexception e) { e.printstacktrace(); } }","repo":"olavloite\/spez2","label":[1,0,0,0]}
{"id":24154,"original_code":"@Test\n    public void trouble_maker() {\n        Mono<String> trouble = null; \/\/todo: change this line\n        StepVerifier.create(trouble)\n                    .expectError(IllegalStateException.class)\n                    .verify();\n    }","code_wo_comment":"@Test\n    public void trouble_maker() {\n        Mono<String> trouble = null;\n        StepVerifier.create(trouble)\n                    .expectError(IllegalStateException.class)\n                    .verify();\n    }","cleancode":"@test public void trouble_maker() { mono<string> trouble = null; stepverifier.create(trouble) .expecterror(illegalstateexception.class) .verify(); }","repo":"nicolasbelfis\/practical-reactor","label":[1,0,0,0]}
{"id":24160,"original_code":"@Test\n    public void repeat() {\n        AtomicInteger counter = new AtomicInteger(0);\n        Flux<Integer> repeated = null; \/\/todo: change this line\n        System.out.println(\"Repeat: \");\n        StepVerifier.create(repeated.doOnNext(System.out::println))\n                    .expectNext(1, 2, 3, 4, 5, 6, 7, 8, 9, 10)\n                    .verifyComplete();\n    }","code_wo_comment":"@Test\n    public void repeat() {\n        AtomicInteger counter = new AtomicInteger(0);\n        Flux<Integer> repeated = null;\n        System.out.println(\"Repeat: \");\n        StepVerifier.create(repeated.doOnNext(System.out::println))\n                    .expectNext(1, 2, 3, 4, 5, 6, 7, 8, 9, 10)\n                    .verifyComplete();\n    }","cleancode":"@test public void repeat() { atomicinteger counter = new atomicinteger(0); flux<integer> repeated = null; system.out.println(\"repeat: \"); stepverifier.create(repeated.doonnext(system.out::println)) .expectnext(1, 2, 3, 4, 5, 6, 7, 8, 9, 10) .verifycomplete(); }","repo":"nicolasbelfis\/practical-reactor","label":[1,0,0,0]}
{"id":7823,"original_code":"private static double EvalSegmentedFn(final cmsToneCurve g, double R)\n\t{\n\t    int i;\n\t    for (i = g.nSegments-1; i >= 0 ; --i)\n\t    {\n\t        \/\/ Check for domain\n\t        if ((R > g.Segments[i].x0) && (R <= g.Segments[i].x1))\n\t        {\n\t            \/\/ Type == 0 means segment is sampled\n\t            if (g.Segments[i].Type == 0)\n\t            {\n\t                float R1 = (float)(R - g.Segments[i].x0);\n\t                float[] Out = new float[1];\n\t                \/\/ Setup the table (TODO: clean that)\n\t                g.SegInterp[i].Table = g.Segments[i].SampledPoints;\n\t                g.SegInterp[i].Interpolation.getFloat().run(new float[]{R1}, Out, g.SegInterp[i]);\n\t                return Out[0];\n\t            }\n\t            else\n\t            {\n\t            \treturn g.Evals[i].run(g.Segments[i].Type, g.Segments[i].Params, R);\n\t            }\n\t        }\n\t    }\n\t    return MINUS_INF;\n\t}","code_wo_comment":"private static double EvalSegmentedFn(final cmsToneCurve g, double R)\n\t{\n\t    int i;\n\t    for (i = g.nSegments-1; i >= 0 ; --i)\n\t    {\n\t       \n\t        if ((R > g.Segments[i].x0) && (R <= g.Segments[i].x1))\n\t        {\n\t           \n\t            if (g.Segments[i].Type == 0)\n\t            {\n\t                float R1 = (float)(R - g.Segments[i].x0);\n\t                float[] Out = new float[1];\n\t               \n\t                g.SegInterp[i].Table = g.Segments[i].SampledPoints;\n\t                g.SegInterp[i].Interpolation.getFloat().run(new float[]{R1}, Out, g.SegInterp[i]);\n\t                return Out[0];\n\t            }\n\t            else\n\t            {\n\t            \treturn g.Evals[i].run(g.Segments[i].Type, g.Segments[i].Params, R);\n\t            }\n\t        }\n\t    }\n\t    return MINUS_INF;\n\t}","cleancode":"private static double evalsegmentedfn(final cmstonecurve g, double r) { int i; for (i = g.nsegments-1; i >= 0 ; --i) { if ((r > g.segments[i].x0) && (r <= g.segments[i].x1)) { if (g.segments[i].type == 0) { float r1 = (float)(r - g.segments[i].x0); float[] out = new float[1]; g.seginterp[i].table = g.segments[i].sampledpoints; g.seginterp[i].interpolation.getfloat().run(new float[]{r1}, out, g.seginterp[i]); return out[0]; } else { return g.evals[i].run(g.segments[i].type, g.segments[i].params, r); } } } return minus_inf; }","repo":"rcmaniac25\/little-cms-for-blackberry","label":[1,0,0,0]}
{"id":16061,"original_code":"@Override\n    protected BufferedDataTable[] execute(final BufferedDataTable[] inData,\n            final ExecutionContext exec) throws Exception {\n    \tDataColumnSpec[] allColSpecs = new DataColumnSpec[1];\n        allColSpecs[0] = \n                new DataColumnSpecCreator(\"url\", StringCell.TYPE).createSpec();\n        DataTableSpec outputSpec = new DataTableSpec(allColSpecs);\n     \/\/   System.out.println(\"calling execute\"+resultUrl.getStringValue());\n        \/\/ the execution context will provide us with storage capacity, in this\n        \/\/ case a data container to which we will add rows sequentially\n        \/\/ Note, this container can also handle arbitrary big data tables, it\n        \/\/ will buffer to disc if necessary.\n        BufferedDataContainer container = exec.createDataContainer(outputSpec);\n        DataCell[] cells = new DataCell[1];\n\tString urlTemplate = resultUrl.getStringValue();\n\tIterator<DataRow> varIt = inData[0].iterator();\n\tDataTableSpec dts = inData[0].getDataTableSpec();\n\tString[] colNames = dts.getColumnNames();\n\tif(varIt.hasNext()){\n\t\/\/while(varIt.hasNext()){\n\t\tDataRow current = varIt.next();\n\t\tIterator<DataCell> cellIt = current.iterator();\n\t\tint colCount = 0;\n\t\twhile(cellIt.hasNext()){\n\t\t\tDataCell currentCell= cellIt.next();\n\t\t\tString curVar =  colNames[colCount];\n\t\t\tString curVal = currentCell.toString();\n\t\t\t\/\/System.out.println(\"curvar:\"+curVar+\", curval:\"+curVal+\", urlTemplate:\"+urlTemplate);\n\t\t\t\tif(urlTemplate.indexOf(curVar)==-1){\n\t\t\t\t\tSystem.out.println(\"1curvar:\"+curVar+\", curval:\"+curVal+\", urlTemplate:\"+urlTemplate);\n\t\t\t\t\turlTemplate = urlTemplate+\"&\"+curVar+\"=\"+URLEncoder.encode(currentCell.toString(),\"UTF-8\");\n\t\t\t\t\tSystem.out.println(\"2curvar:\"+curVar+\", curval:\"+curVal+\", urlTemplate:\"+urlTemplate);\n\t\t\t\t}else{\n\t\t\t\t\tSystem.out.println(\"3curvar:\"+curVar+\", curval:\"+curVal+\", urlTemplate:\"+urlTemplate);\n\t\t\t\t\tString configValue = \"\";\n\t\t\t\t\tif(urlTemplate.indexOf(\"&\"+curVar)!=-1){\n\t\t\t\t\t\tconfigValue = urlTemplate.substring(urlTemplate.indexOf(\"&\"+curVar)+curVar.length()+2,urlTemplate.indexOf(\"]\",urlTemplate.indexOf(curVar)));\n\t\t\t\t\t}else if(urlTemplate.indexOf(\"?\"+curVar)!=-1){\n\t\t\t\t\t\tconfigValue = urlTemplate.substring(urlTemplate.indexOf(\"?\"+curVar)+curVar.length()+2,urlTemplate.indexOf(\"]\",urlTemplate.indexOf(curVar)));\n\t\t\t\t\t}\n\t\t\t\t\tSystem.out.println(\"4curvar:\"+curVar+\", curval:\"+curVal+\", urlTemplate:\"+urlTemplate);\n\t\t\t\t\tif(configValue.endsWith(\"&\")){\n\t\t\t\t\t\tconfigValue = configValue.substring(0,configValue.length()-1); \/\/get rid of the &\n\t\t\t\t\t}\n\t\t\t\t\tif(colCount==0){\n\t\t\t\t\t\turlTemplate +=\"&\";\n\t\t\t\t\t}\n\t\t\t\t\tSystem.out.println(\"5curvar:\"+curVar+\", curval:\"+curVal+\", urlTemplate:\"+urlTemplate);\n\t\t\t\t\tif(!configValue.equals(\"\")){\n\t\t\t\t\t\tSystem.out.println(\"6curvar:\"+curVar+\", curval:\"+curVal+\", urlTemplate:\"+urlTemplate);\n\t\t\t\t\t\tSystem.out.println(\"config var: \"+curVar+\" with configValue:\"+ configValue+ \", is overwritten with value: \"+currentCell.toString()  );\n\t\t\t\t\t\turlTemplate = urlTemplate.replaceAll(Pattern.quote(\"[\"+curVar+\"=\"+configValue+\"&]\"), curVar+\"=\"+URLEncoder.encode(currentCell.toString(),\"UTF-8\")+\"&\");\n\t\t\t\t\t\turlTemplate = urlTemplate.replaceAll(Pattern.quote(\"[\"+curVar+\"=\"+configValue+\"]\"), curVar+\"=\"+URLEncoder.encode(currentCell.toString(),\"UTF-8\"));\n\t\t\t\t\t}else{\n\t\t\t\t\t\t\/\/System.out.println(\"now we are here\");\n\t\t\t\t\t\tSystem.out.println(\"7curvar:\"+curVar+\", curval:\"+curVal+\", urlTemplate:\"+urlTemplate);\n\t\t\t\t\t\tif(urlTemplate.endsWith(\"&\")||urlTemplate.endsWith(\"?\")){\n\t\t\t\t\t\t\t\/\/urlTemplate = urlTemplate.substring(0,urlTemplate.length()-1);\n\t\t\t\t\t\t\turlTemplate = urlTemplate+curVar+\"=\"+URLEncoder.encode(curVal,\"UTF-8\");\n\t\t\t\t\t\t}else{\n\t\t\t\t\t\t\turlTemplate = \"&\"+urlTemplate+curVar+\"=\"+URLEncoder.encode(curVal,\"UTF-8\");\n\t\t\t\t\t\t}\n\t\t\t\t\t\t\/\/urlTemplate = urlTemplate.replaceAll(Pattern.quote(\"[\"+curVar+\"=\"+configValue+\"&]\"), curVar+\"=\"+URLEncoder.encode(currentCell.toString(),\"UTF-8\")+\"&\");\n\t\t\t\t\t\t\/\/urlTemplate = urlTemplate.replaceAll(Pattern.quote(\"[\"+curVar+\"=\"+configValue+\"]\"), curVar+\"=\"+URLEncoder.encode(currentCell.toString(),\"UTF-8\"));\n\t\t\t\t\t\t\/\/System.out.println(\"urlTemplate before:\"+doubleStr+\",  and after:\"+urlTemplate);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\tcolCount++;\n\t\t}\n\t}\n\tSystem.out.println(\"yy:\"+urlTemplate);\n\t\/\/urlTemplate =urlTemplate.replaceAll(\"\\\\[.*?\\\\]\", \"\");\n\turlTemplate =urlTemplate.replaceAll(\"\\\\[\", \"\");\n\turlTemplate =urlTemplate.replaceAll(\"\\\\]\", \"\");\n\turlTemplate =urlTemplate.replaceAll(\"%28\", \"(\");\n\turlTemplate =urlTemplate.replaceAll(\"%29\", \")\");\n\t\/\/urlTemplate =urlTemplate.replaceAll(\"%5B\", \"[\"); \/\/strange that this is needed....API issue?\n\t\/\/urlTemplate =urlTemplate.replaceAll(\"%5D\", \"]\");\n\tSystem.out.println(\"yy:\"+urlTemplate);\n\tif(urlTemplate.endsWith(\"&\")){\n\t\turlTemplate = urlTemplate.substring(0,urlTemplate.length()-1);\n\t}\n\t\/\/urlTemplate = urlTemplate.substring(0, urlTemplate.length()-1);\n\t\/\/System.out.println(\"urlTemplate became \"+urlTemplate);\n\tcells[0] = new StringCell(urlTemplate);\n\t  DataRow row = new DefaultRow(\"aboutCell\", cells);\n        container.addRowToTable(row);\n        container.close();\n        BufferedDataTable out = container.getTable();\n    \/\/ TODO: Return a BufferedDataTable for each output port \n    return new BufferedDataTable[]{out};\n    }","code_wo_comment":"@Override\n    protected BufferedDataTable[] execute(final BufferedDataTable[] inData,\n            final ExecutionContext exec) throws Exception {\n    \tDataColumnSpec[] allColSpecs = new DataColumnSpec[1];\n        allColSpecs[0] = \n                new DataColumnSpecCreator(\"url\", StringCell.TYPE).createSpec();\n        DataTableSpec outputSpec = new DataTableSpec(allColSpecs);\n    \n       \n       \n       \n       \n        BufferedDataContainer container = exec.createDataContainer(outputSpec);\n        DataCell[] cells = new DataCell[1];\n\tString urlTemplate = resultUrl.getStringValue();\n\tIterator<DataRow> varIt = inData[0].iterator();\n\tDataTableSpec dts = inData[0].getDataTableSpec();\n\tString[] colNames = dts.getColumnNames();\n\tif(varIt.hasNext()){\n\n\t\tDataRow current = varIt.next();\n\t\tIterator<DataCell> cellIt = current.iterator();\n\t\tint colCount = 0;\n\t\twhile(cellIt.hasNext()){\n\t\t\tDataCell currentCell= cellIt.next();\n\t\t\tString curVar =  colNames[colCount];\n\t\t\tString curVal = currentCell.toString();\n\t\t\n\t\t\t\tif(urlTemplate.indexOf(curVar)==-1){\n\t\t\t\t\tSystem.out.println(\"1curvar:\"+curVar+\", curval:\"+curVal+\", urlTemplate:\"+urlTemplate);\n\t\t\t\t\turlTemplate = urlTemplate+\"&\"+curVar+\"=\"+URLEncoder.encode(currentCell.toString(),\"UTF-8\");\n\t\t\t\t\tSystem.out.println(\"2curvar:\"+curVar+\", curval:\"+curVal+\", urlTemplate:\"+urlTemplate);\n\t\t\t\t}else{\n\t\t\t\t\tSystem.out.println(\"3curvar:\"+curVar+\", curval:\"+curVal+\", urlTemplate:\"+urlTemplate);\n\t\t\t\t\tString configValue = \"\";\n\t\t\t\t\tif(urlTemplate.indexOf(\"&\"+curVar)!=-1){\n\t\t\t\t\t\tconfigValue = urlTemplate.substring(urlTemplate.indexOf(\"&\"+curVar)+curVar.length()+2,urlTemplate.indexOf(\"]\",urlTemplate.indexOf(curVar)));\n\t\t\t\t\t}else if(urlTemplate.indexOf(\"?\"+curVar)!=-1){\n\t\t\t\t\t\tconfigValue = urlTemplate.substring(urlTemplate.indexOf(\"?\"+curVar)+curVar.length()+2,urlTemplate.indexOf(\"]\",urlTemplate.indexOf(curVar)));\n\t\t\t\t\t}\n\t\t\t\t\tSystem.out.println(\"4curvar:\"+curVar+\", curval:\"+curVal+\", urlTemplate:\"+urlTemplate);\n\t\t\t\t\tif(configValue.endsWith(\"&\")){\n\t\t\t\t\t\tconfigValue = configValue.substring(0,configValue.length()-1);\n\t\t\t\t\t}\n\t\t\t\t\tif(colCount==0){\n\t\t\t\t\t\turlTemplate +=\"&\";\n\t\t\t\t\t}\n\t\t\t\t\tSystem.out.println(\"5curvar:\"+curVar+\", curval:\"+curVal+\", urlTemplate:\"+urlTemplate);\n\t\t\t\t\tif(!configValue.equals(\"\")){\n\t\t\t\t\t\tSystem.out.println(\"6curvar:\"+curVar+\", curval:\"+curVal+\", urlTemplate:\"+urlTemplate);\n\t\t\t\t\t\tSystem.out.println(\"config var: \"+curVar+\" with configValue:\"+ configValue+ \", is overwritten with value: \"+currentCell.toString()  );\n\t\t\t\t\t\turlTemplate = urlTemplate.replaceAll(Pattern.quote(\"[\"+curVar+\"=\"+configValue+\"&]\"), curVar+\"=\"+URLEncoder.encode(currentCell.toString(),\"UTF-8\")+\"&\");\n\t\t\t\t\t\turlTemplate = urlTemplate.replaceAll(Pattern.quote(\"[\"+curVar+\"=\"+configValue+\"]\"), curVar+\"=\"+URLEncoder.encode(currentCell.toString(),\"UTF-8\"));\n\t\t\t\t\t}else{\n\t\t\t\t\t\n\t\t\t\t\t\tSystem.out.println(\"7curvar:\"+curVar+\", curval:\"+curVal+\", urlTemplate:\"+urlTemplate);\n\t\t\t\t\t\tif(urlTemplate.endsWith(\"&\")||urlTemplate.endsWith(\"?\")){\n\t\t\t\t\t\t\n\t\t\t\t\t\t\turlTemplate = urlTemplate+curVar+\"=\"+URLEncoder.encode(curVal,\"UTF-8\");\n\t\t\t\t\t\t}else{\n\t\t\t\t\t\t\turlTemplate = \"&\"+urlTemplate+curVar+\"=\"+URLEncoder.encode(curVal,\"UTF-8\");\n\t\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\t\n\t\t\t\t\t\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\tcolCount++;\n\t\t}\n\t}\n\tSystem.out.println(\"yy:\"+urlTemplate);\n\n\turlTemplate =urlTemplate.replaceAll(\"\\\\[\", \"\");\n\turlTemplate =urlTemplate.replaceAll(\"\\\\]\", \"\");\n\turlTemplate =urlTemplate.replaceAll(\"%28\", \"(\");\n\turlTemplate =urlTemplate.replaceAll(\"%29\", \")\");\n\n\n\tSystem.out.println(\"yy:\"+urlTemplate);\n\tif(urlTemplate.endsWith(\"&\")){\n\t\turlTemplate = urlTemplate.substring(0,urlTemplate.length()-1);\n\t}\n\n\n\tcells[0] = new StringCell(urlTemplate);\n\t  DataRow row = new DefaultRow(\"aboutCell\", cells);\n        container.addRowToTable(row);\n        container.close();\n        BufferedDataTable out = container.getTable();\n   \n    return new BufferedDataTable[]{out};\n    }","cleancode":"@override protected buffereddatatable[] execute(final buffereddatatable[] indata, final executioncontext exec) throws exception { datacolumnspec[] allcolspecs = new datacolumnspec[1]; allcolspecs[0] = new datacolumnspeccreator(\"url\", stringcell.type).createspec(); datatablespec outputspec = new datatablespec(allcolspecs); buffereddatacontainer container = exec.createdatacontainer(outputspec); datacell[] cells = new datacell[1]; string urltemplate = resulturl.getstringvalue(); iterator<datarow> varit = indata[0].iterator(); datatablespec dts = indata[0].getdatatablespec(); string[] colnames = dts.getcolumnnames(); if(varit.hasnext()){ datarow current = varit.next(); iterator<datacell> cellit = current.iterator(); int colcount = 0; while(cellit.hasnext()){ datacell currentcell= cellit.next(); string curvar = colnames[colcount]; string curval = currentcell.tostring(); if(urltemplate.indexof(curvar)==-1){ system.out.println(\"1curvar:\"+curvar+\", curval:\"+curval+\", urltemplate:\"+urltemplate); urltemplate = urltemplate+\"&\"+curvar+\"=\"+urlencoder.encode(currentcell.tostring(),\"utf-8\"); system.out.println(\"2curvar:\"+curvar+\", curval:\"+curval+\", urltemplate:\"+urltemplate); }else{ system.out.println(\"3curvar:\"+curvar+\", curval:\"+curval+\", urltemplate:\"+urltemplate); string configvalue = \"\"; if(urltemplate.indexof(\"&\"+curvar)!=-1){ configvalue = urltemplate.substring(urltemplate.indexof(\"&\"+curvar)+curvar.length()+2,urltemplate.indexof(\"]\",urltemplate.indexof(curvar))); }else if(urltemplate.indexof(\"?\"+curvar)!=-1){ configvalue = urltemplate.substring(urltemplate.indexof(\"?\"+curvar)+curvar.length()+2,urltemplate.indexof(\"]\",urltemplate.indexof(curvar))); } system.out.println(\"4curvar:\"+curvar+\", curval:\"+curval+\", urltemplate:\"+urltemplate); if(configvalue.endswith(\"&\")){ configvalue = configvalue.substring(0,configvalue.length()-1); } if(colcount==0){ urltemplate +=\"&\"; } system.out.println(\"5curvar:\"+curvar+\", curval:\"+curval+\", urltemplate:\"+urltemplate); if(!configvalue.equals(\"\")){ system.out.println(\"6curvar:\"+curvar+\", curval:\"+curval+\", urltemplate:\"+urltemplate); system.out.println(\"config var: \"+curvar+\" with configvalue:\"+ configvalue+ \", is overwritten with value: \"+currentcell.tostring() ); urltemplate = urltemplate.replaceall(pattern.quote(\"[\"+curvar+\"=\"+configvalue+\"&]\"), curvar+\"=\"+urlencoder.encode(currentcell.tostring(),\"utf-8\")+\"&\"); urltemplate = urltemplate.replaceall(pattern.quote(\"[\"+curvar+\"=\"+configvalue+\"]\"), curvar+\"=\"+urlencoder.encode(currentcell.tostring(),\"utf-8\")); }else{ system.out.println(\"7curvar:\"+curvar+\", curval:\"+curval+\", urltemplate:\"+urltemplate); if(urltemplate.endswith(\"&\")||urltemplate.endswith(\"?\")){ urltemplate = urltemplate+curvar+\"=\"+urlencoder.encode(curval,\"utf-8\"); }else{ urltemplate = \"&\"+urltemplate+curvar+\"=\"+urlencoder.encode(curval,\"utf-8\"); } } } colcount++; } } system.out.println(\"yy:\"+urltemplate); urltemplate =urltemplate.replaceall(\"\\\\[\", \"\"); urltemplate =urltemplate.replaceall(\"\\\\]\", \"\"); urltemplate =urltemplate.replaceall(\"%28\", \"(\"); urltemplate =urltemplate.replaceall(\"%29\", \")\"); system.out.println(\"yy:\"+urltemplate); if(urltemplate.endswith(\"&\")){ urltemplate = urltemplate.substring(0,urltemplate.length()-1); } cells[0] = new stringcell(urltemplate); datarow row = new defaultrow(\"aboutcell\", cells); container.addrowtotable(row); container.close(); buffereddatatable out = container.gettable(); return new buffereddatatable[]{out}; }","repo":"openphacts\/OPS-Knime","label":[0,1,1,0]}
{"id":16088,"original_code":"private void parseNamespaceOrTypes() throws FeatureNotSupportedException {\n        while (!curtok.equals(EOF)) {\n            \/\/ todo: account for assembly attributes\n            parsePossibleAttributes(true);\n            if (curAttributes.size() > 0) {\n                for (AttributeNode an : curAttributes) {\n                    cu.attributes.add(an);\n                }\n                curAttributes.clear();\n            }\n            \/\/ can be usingDirectives, globalAttribs, or NamespaceMembersDecls\n            \/\/ NamespaceMembersDecls include namespaces, class, struct, interface, enum, delegate\n            switch (curtok.id) {\n                case TokenID.Using:\n                    \/\/ using directive\n                    parseUsingDirectives();\n                    break;\n                case TokenID.New:\n                case TokenID.Public:\n                case TokenID.Protected:\n                case TokenID.Partial:\n                case TokenID.Static:\n                case TokenID.Internal:\n                case TokenID.Private:\n                case TokenID.Abstract:\n                case TokenID.Sealed:\n                    \/\/parseTypeModifier();\n                    curmods |= modMap.get(curtok.id);\n                    advance();\n                    break;\n                case TokenID.Namespace:\n                    parseNamespace();\n                    break;\n                case TokenID.Class:\n                    parseClass();\n                    break;\n                case TokenID.Struct:\n                    parseStruct();\n                    break;\n                case TokenID.Interface:\n                    parseInterface();\n                    break;\n                case TokenID.Enum:\n                    parseEnum();\n                    break;\n                case TokenID.Delegate:\n                    parseDelegate();\n                    break;\n                case TokenID.Semi:\n                    advance();\n                    break;\n                default:\n                    return;\n            }\n        }\n    }","code_wo_comment":"private void parseNamespaceOrTypes() throws FeatureNotSupportedException {\n        while (!curtok.equals(EOF)) {\n           \n            parsePossibleAttributes(true);\n            if (curAttributes.size() > 0) {\n                for (AttributeNode an : curAttributes) {\n                    cu.attributes.add(an);\n                }\n                curAttributes.clear();\n            }\n           \n           \n            switch (curtok.id) {\n                case TokenID.Using:\n                   \n                    parseUsingDirectives();\n                    break;\n                case TokenID.New:\n                case TokenID.Public:\n                case TokenID.Protected:\n                case TokenID.Partial:\n                case TokenID.Static:\n                case TokenID.Internal:\n                case TokenID.Private:\n                case TokenID.Abstract:\n                case TokenID.Sealed:\n                   \n                    curmods |= modMap.get(curtok.id);\n                    advance();\n                    break;\n                case TokenID.Namespace:\n                    parseNamespace();\n                    break;\n                case TokenID.Class:\n                    parseClass();\n                    break;\n                case TokenID.Struct:\n                    parseStruct();\n                    break;\n                case TokenID.Interface:\n                    parseInterface();\n                    break;\n                case TokenID.Enum:\n                    parseEnum();\n                    break;\n                case TokenID.Delegate:\n                    parseDelegate();\n                    break;\n                case TokenID.Semi:\n                    advance();\n                    break;\n                default:\n                    return;\n            }\n        }\n    }","cleancode":"private void parsenamespaceortypes() throws featurenotsupportedexception { while (!curtok.equals(eof)) { parsepossibleattributes(true); if (curattributes.size() > 0) { for (attributenode an : curattributes) { cu.attributes.add(an); } curattributes.clear(); } switch (curtok.id) { case tokenid.using: parseusingdirectives(); break; case tokenid.new: case tokenid.public: case tokenid.protected: case tokenid.partial: case tokenid.static: case tokenid.internal: case tokenid.private: case tokenid.abstract: case tokenid.sealed: curmods |= modmap.get(curtok.id); advance(); break; case tokenid.namespace: parsenamespace(); break; case tokenid.class: parseclass(); break; case tokenid.struct: parsestruct(); break; case tokenid.interface: parseinterface(); break; case tokenid.enum: parseenum(); break; case tokenid.delegate: parsedelegate(); break; case tokenid.semi: advance(); break; default: return; } } }","repo":"osoco\/comprendiendo-software-creando-herramientas","label":[0,1,0,0]}
{"id":16089,"original_code":"private PPNode parsePreprocessorDirective() throws FeatureNotSupportedException {\n        PPNode result = null;\n        int startLine = lineCount;\n        inPPDirective = true;\n        advance(); \/\/ over hash\n        IdentifierExpression ie = parseIdentifierOrKeyword();\n        String ppKind = ie.Identifier[0];\n        byte id = PreprocessorID.Empty;\n        if (preprocessor.containsKey(ppKind)) {\n            id = preprocessor.get(ppKind);\n        } else {\n            ReportError(\"Preprocessor directive must be valid identifier, rather than \\\"\" + ppKind + \"\\\".\");\n        }\n        switch (id) {\n            case PreprocessorID.Define:\n                \/\/ conditional-symbol pp-newline\n                IdentifierExpression def = parseIdentifierOrKeyword();\n                if (!ppDefs.containsKey(def.Identifier[0])) {\n                    ppDefs.put(def.Identifier[0], PreprocessorID.Empty);\n                }\n                result = new PPDefineNode(def);\n                break;\n            case PreprocessorID.Undef:\n                \/\/ conditional-symbol pp-newline\n                IdentifierExpression undef = parseIdentifierOrKeyword();\n                if (ppDefs.containsKey(undef.Identifier[0])) {\n                    ppDefs.remove(undef.Identifier[0]);\n                }\n                result = new PPDefineNode(undef);\n                break;\n            case PreprocessorID.If:\n                \/\/ pp-expression pp-newline conditional-section(opt)\n                if (curtok.id == TokenID.LParen) {\n                    advance();\n                }\n                int startCount = lineCount;\n                ppCondition = false;\n                \/\/ todo: account for true, false, ||, &&, ==, !=, !\n                IdentifierExpression ifexpr = parseIdentifierOrKeyword();\n                if (ppDefs.containsKey(ifexpr.Identifier[0])) {\n                    ppCondition = true;\n                }\n                \/\/result = new PPIfNode(ParseExpressionToNewline());\n                if (curtok.id == TokenID.RParen) {\n                    advance();\n                }\n                if (ppCondition == false) {\n                    \/\/ skip this block\n                    SkipToElseOrEndIf();\n                }\n                break;\n            case PreprocessorID.Elif:\n                \/\/ pp-expression pp-newline conditional-section(opt)\n                SkipToEOL(startLine);\n                break;\n            case PreprocessorID.Else:\n                \/\/ pp-newline conditional-section(opt)\n                if (ppCondition == true) {\n                    \/\/ skip this block\n                    SkipToElseOrEndIf();\n                }\n                break;\n            case PreprocessorID.Endif:\n                \/\/ pp-newline\n                result = new PPEndIfNode();\n                ppCondition = false;\n                break;\n            case PreprocessorID.Line:\n                \/\/ line-indicator pp-newline\n                SkipToEOL(startLine);\n                break;\n            case PreprocessorID.Error:\n                \/\/ pp-message\n                SkipToEOL(startLine);\n                break;\n            case PreprocessorID.Warning:\n                \/\/ pp-message\n                SkipToEOL(startLine);\n                break;\n            case PreprocessorID.Region:\n                \/\/ pp-message\n                SkipToEOL(startLine);\n                break;\n            case PreprocessorID.Endregion:\n                \/\/ pp-message\n                SkipToEOL(startLine);\n                break;\n            case PreprocessorID.Pragma:\n                \/\/ pp-message\n                SkipToEOL(startLine);\n                break;\n            default:\n                break;\n        }\n        inPPDirective = false;\n        return result;\n    }","code_wo_comment":"private PPNode parsePreprocessorDirective() throws FeatureNotSupportedException {\n        PPNode result = null;\n        int startLine = lineCount;\n        inPPDirective = true;\n        advance();\n        IdentifierExpression ie = parseIdentifierOrKeyword();\n        String ppKind = ie.Identifier[0];\n        byte id = PreprocessorID.Empty;\n        if (preprocessor.containsKey(ppKind)) {\n            id = preprocessor.get(ppKind);\n        } else {\n            ReportError(\"Preprocessor directive must be valid identifier, rather than \\\"\" + ppKind + \"\\\".\");\n        }\n        switch (id) {\n            case PreprocessorID.Define:\n               \n                IdentifierExpression def = parseIdentifierOrKeyword();\n                if (!ppDefs.containsKey(def.Identifier[0])) {\n                    ppDefs.put(def.Identifier[0], PreprocessorID.Empty);\n                }\n                result = new PPDefineNode(def);\n                break;\n            case PreprocessorID.Undef:\n               \n                IdentifierExpression undef = parseIdentifierOrKeyword();\n                if (ppDefs.containsKey(undef.Identifier[0])) {\n                    ppDefs.remove(undef.Identifier[0]);\n                }\n                result = new PPDefineNode(undef);\n                break;\n            case PreprocessorID.If:\n               \n                if (curtok.id == TokenID.LParen) {\n                    advance();\n                }\n                int startCount = lineCount;\n                ppCondition = false;\n               \n                IdentifierExpression ifexpr = parseIdentifierOrKeyword();\n                if (ppDefs.containsKey(ifexpr.Identifier[0])) {\n                    ppCondition = true;\n                }\n               \n                if (curtok.id == TokenID.RParen) {\n                    advance();\n                }\n                if (ppCondition == false) {\n                   \n                    SkipToElseOrEndIf();\n                }\n                break;\n            case PreprocessorID.Elif:\n               \n                SkipToEOL(startLine);\n                break;\n            case PreprocessorID.Else:\n               \n                if (ppCondition == true) {\n                   \n                    SkipToElseOrEndIf();\n                }\n                break;\n            case PreprocessorID.Endif:\n               \n                result = new PPEndIfNode();\n                ppCondition = false;\n                break;\n            case PreprocessorID.Line:\n               \n                SkipToEOL(startLine);\n                break;\n            case PreprocessorID.Error:\n               \n                SkipToEOL(startLine);\n                break;\n            case PreprocessorID.Warning:\n               \n                SkipToEOL(startLine);\n                break;\n            case PreprocessorID.Region:\n               \n                SkipToEOL(startLine);\n                break;\n            case PreprocessorID.Endregion:\n               \n                SkipToEOL(startLine);\n                break;\n            case PreprocessorID.Pragma:\n               \n                SkipToEOL(startLine);\n                break;\n            default:\n                break;\n        }\n        inPPDirective = false;\n        return result;\n    }","cleancode":"private ppnode parsepreprocessordirective() throws featurenotsupportedexception { ppnode result = null; int startline = linecount; inppdirective = true; advance(); identifierexpression ie = parseidentifierorkeyword(); string ppkind = ie.identifier[0]; byte id = preprocessorid.empty; if (preprocessor.containskey(ppkind)) { id = preprocessor.get(ppkind); } else { reporterror(\"preprocessor directive must be valid identifier, rather than \\\"\" + ppkind + \"\\\".\"); } switch (id) { case preprocessorid.define: identifierexpression def = parseidentifierorkeyword(); if (!ppdefs.containskey(def.identifier[0])) { ppdefs.put(def.identifier[0], preprocessorid.empty); } result = new ppdefinenode(def); break; case preprocessorid.undef: identifierexpression undef = parseidentifierorkeyword(); if (ppdefs.containskey(undef.identifier[0])) { ppdefs.remove(undef.identifier[0]); } result = new ppdefinenode(undef); break; case preprocessorid.if: if (curtok.id == tokenid.lparen) { advance(); } int startcount = linecount; ppcondition = false; identifierexpression ifexpr = parseidentifierorkeyword(); if (ppdefs.containskey(ifexpr.identifier[0])) { ppcondition = true; } if (curtok.id == tokenid.rparen) { advance(); } if (ppcondition == false) { skiptoelseorendif(); } break; case preprocessorid.elif: skiptoeol(startline); break; case preprocessorid.else: if (ppcondition == true) { skiptoelseorendif(); } break; case preprocessorid.endif: result = new ppendifnode(); ppcondition = false; break; case preprocessorid.line: skiptoeol(startline); break; case preprocessorid.error: skiptoeol(startline); break; case preprocessorid.warning: skiptoeol(startline); break; case preprocessorid.region: skiptoeol(startline); break; case preprocessorid.endregion: skiptoeol(startline); break; case preprocessorid.pragma: skiptoeol(startline); break; default: break; } inppdirective = false; return result; }","repo":"osoco\/comprendiendo-software-creando-herramientas","label":[0,1,0,0]}
{"id":16146,"original_code":"public void create(File dstFolder, List<ExcelTable> tables, ExcelSproutOptions options) {\n        Random rnd = new Random(options.getRandomSeed());\n        \/\/there are many tables\n        \/\/we have to decide: what table to what sheet, and what sheet to what workbook\n        \/\/we should not repeat tables about the same class, so there are possible groups\n        \/\/maybe a workbook should be full to have the best expected.ttl from the original model\n        \/\/here we calculate: what table to what workbook\n        List<List<ExcelTable>> workbookClusters = getWorkbookClusters(tables, rnd);\n        \/\/now we have to decide which table will be in which sheet\n        \/\/the cleanest way is to have a table per sheet\n        \/\/TODO make this variable so more messy version are possible\n        List<List<List<ExcelTable>>> workbookSheetTables = new ArrayList<>();\n        for (List<ExcelTable> workbookTables : workbookClusters) {\n            List<List<ExcelTable>> sheetTables = new ArrayList<>();\n            for (ExcelTable tbl : workbookTables) {\n                List<ExcelTable> sheet = Arrays.asList(tbl);\n                sheetTables.add(sheet);\n            }\n            workbookSheetTables.add(sheetTables);\n        }\n        int maxDigits = String.valueOf(workbookSheetTables.size() - 1).length();\n        Map<List<ExcelTable>, ExcelGeneratorSheetConfig> sheetConfigMap = new HashMap<>();\n        \/\/now we use the ExcelGenerator to generate the workbooks\n        ExcelGenerator excelGenerator = new ExcelGenerator();\n        for (int i = 0; i < workbookSheetTables.size(); i++) {\n            List<List<ExcelTable>> sheets = workbookSheetTables.get(i);\n            \/\/create a config for this workbook\n            ExcelGeneratorWorkbookConfig workbookConf = new ExcelGeneratorWorkbookConfig();\n            \/\/TODO configurable\n            workbookConf.setFileName(\"workbook.xlsx\");\n            for (List<ExcelTable> sheet : sheets) {\n                ExcelGeneratorSheetConfig sheetConf = new ExcelGeneratorSheetConfig();\n                sheetConfigMap.put(sheet, sheetConf);\n                StringBuilder sheetNameSB = new StringBuilder();\n                \/\/TODO a second table in the sheet means we maybe have to move the offset\n                \/\/      so that it will not overlap\n                for (int k = 0; k < sheet.size(); k++) {\n                    ExcelTable excelTable = sheet.get(k);\n                    ExcelGeneratorTableConfig tableConf = new ExcelGeneratorTableConfig();\n                    \/\/TODO maybe make a getSingleOrDefault method\n                    Point offset = (Point) excelTable.getSetup().getOrDefault(\"offset\", new Point(0, 0));\n                    tableConf.setOffset(offset);\n                    \/\/draw the ExcelCell matrix from ExcelTable\n                    tableConf.setStaticCellDrawer(d -> {\n                        \/\/it uses the tableConf offset\n                        d.exceltable(excelTable, options);\n                    });\n                    sheetConf.getTableConfigs().add(tableConf);\n                    \/\/TODO if only one table with one class: add provenance sheetname -> insts a class. (for all insts)\n                    ClassConfig classConfig = excelTable.getSetup().getOrThrow(\"classes\", ClassConfig.class);\n                    if (classConfig.hasLabel()) {\n                        sheetNameSB.append(classConfig.getLabel());\n                    } else {\n                        throw new RuntimeException(\"ClassConfig should give a label to name the sheet\");\n                    }\n                    \/\/in one sheet multiple tables could be existing\n                    if (k != sheet.size() - 1) {\n                        sheetNameSB.append(\" & \");\n                    }\n                }\n                \/\/sheet name comes from table content\n                sheetConf.setSheetName(sheetNameSB.toString());\n                workbookConf.getSheetConfigs().add(sheetConf);\n            }\/\/per sheet\n            ExcelGeneratorResult result = excelGenerator.generate(null, workbookConf);\n            \/\/System.out.println(\"save workbook \" + i);\n            \/\/no extra folder when only one workbook\n            File workbookFolder = workbookSheetTables.size() == 1 ? dstFolder : new File(dstFolder, String.format(\"%0\" + maxDigits + \"d\", i));\n            result.saveExcel(workbookFolder);\n            \/\/write provenance =================================================\n            Model expectedModel = null;\n            Model provenanceModel = null;\n            CSVPrinter provenanceCSV = null;\n            if (options.isWriteExpectedModel()) {\n                expectedModel = ModelFactory.createDefaultModel();\n                expectedModel.setNsPrefixes(options.getPrefixMapping());\n                expectedModel.setNsPrefixes(PrefixMapping.Standard);\n            }\n            if (options.isWriteProvenanceModel()) {\n                provenanceModel = ModelFactory.createDefaultModel();\n                provenanceModel.setNsPrefixes(options.getPrefixMapping());\n                provenanceModel.setNsPrefix(\"prov\", PROV.NS);\n                provenanceModel.setNsPrefix(\"csvw\", CSVW.NS);\n                provenanceModel.setNsPrefix(\"ss\", SS.NS);\n                provenanceModel.setNsPrefixes(PrefixMapping.Standard);\n            }\n            if (options.isWriteProvenanceCSV()) {\n                try {\n                    provenanceCSV = CSVFormat.DEFAULT.print(\n                            new OutputStreamWriter(\n                                    new GZIPOutputStream(\n                                            new FileOutputStream(\n                                                    new File(workbookFolder, \"provenance.csv.gz\")\n                                            ))));\n                    csvProvenanceHeader(provenanceCSV);\n                } catch (IOException ex) {\n                    throw new RuntimeException(ex);\n                }\n            }\n            \/\/used in rdfProvenance for fast lookup reified statements\n            Map<Statement, Resource> stmt2res = new HashMap<>();\n            \/\/need here sheetname for provenance\n            for (List<ExcelTable> sheet : sheets) {\n                ExcelGeneratorSheetConfig sheetConfig = sheetConfigMap.get(sheet);\n                for (ExcelTable table : sheet) {\n                    for (Entry<ExcelCell, Provenance> cell2prov : table.getCellProvMap().entrySet()) {\n                        ExcelCell cell = cell2prov.getKey();\n                        Provenance prov = cell2prov.getValue();\n                        if (cell.getAddress() == null) {\n                            \/\/this was a temporary cell created for a merge \n                            \/\/in TableGenerator putMultipleObjects method\n                            continue;\n                        }\n                        if (prov.getStatements().isEmpty()) {\n                            \/\/no provenance information for this cell\n                            continue;\n                        }\n                        if (options.isWriteExpectedModel()) {\n                            expectedModel.add(prov.getStatements());\n                        }\n                        if (options.isWriteProvenanceModel()) {\n                            rdfProvenance(cell, sheetConfig.getSheetName(), prov, stmt2res, provenanceModel);\n                        }\n                        if (options.isWriteProvenanceCSV()) {\n                            csvProvenance(cell, sheetConfig.getSheetName(), prov, provenanceCSV, provenanceModel);\n                        }\n                    }\n                }\n            }\n            \/\/write to files\n            if (options.isWriteExpectedModel()) {\n                File file = new File(workbookFolder, \"expected.ttl.gz\");\n                try (OutputStream os = file.getName().endsWith(\"gz\") ? new GZIPOutputStream(new FileOutputStream(file)) : new FileOutputStream(file)) {\n                    expectedModel.write(os, \"TTL\");\n                } catch (IOException ex) {\n                    throw new RuntimeException(ex);\n                }\n            }\n            if (options.isWriteProvenanceModel()) {\n                File file = new File(workbookFolder, \"provenance.ttl.gz\");\n                try (OutputStream os = file.getName().endsWith(\"gz\") ? new GZIPOutputStream(new FileOutputStream(file)) : new FileOutputStream(file)) {\n                    provenanceModel.write(os, \"TTL\");\n                } catch (IOException ex) {\n                    throw new RuntimeException(ex);\n                }\n            }\n            if (options.isWriteProvenanceCSV()) {\n                try {\n                    provenanceCSV.close();\n                } catch (IOException ex) {\n                    throw new RuntimeException(ex);\n                }\n            }\n            if (options.isWriteGenerationSummaryJson()) {\n                \/\/key is sheet name\n                JSONObject perSheetPatternUsage = new JSONObject();\n                JsonUtility.forceLinkedHashMap(perSheetPatternUsage);\n                for (List<ExcelTable> sheet : sheets) {\n                    ExcelGeneratorSheetConfig sheetConfig = sheetConfigMap.get(sheet);\n                    \/\/count how often\n                    Map<String, Map<Object, Integer>> pattern2value2count = new HashMap<>();\n                    for (ExcelTable tbl : sheet) {\n                        for (Entry<ExcelCell, Provenance> entry : tbl.getCellProvMap().entrySet()) {\n                            \/\/skip the ones with no prov and no address (temp cells)\n                            if (entry.getKey().getAddress() == null || entry.getValue().getStatements().isEmpty()) {\n                                continue;\n                            }\n                            for (Entry<String, Object> e : entry.getValue().getUsedPatterns().entrySet()) {\n                                Object val = e.getValue();\n                                if(val instanceof JSONArray) {\n                                    \/\/because json array hash is always different\n                                    val = val.toString();\n                                }\n                                Map<Object, Integer> value2count = pattern2value2count.computeIfAbsent(e.getKey(), k -> new HashMap<>());\n                                value2count.put(val, value2count.getOrDefault(val, 0) + 1);\n                            }\n                        }\n                    }\n                    JSONObject patternUsage = new JSONObject();\n                    JsonUtility.forceLinkedHashMap(patternUsage);\n                    List<Entry<String, Map<Object, Integer>>> pattern2value2countList = new ArrayList<>(pattern2value2count.entrySet());\n                    pattern2value2countList.sort((a,b) -> a.getKey().compareTo(b.getKey()));\n                    for (Entry<String, Map<Object, Integer>> pattern2value2countEntry : pattern2value2countList) {\n                        JSONArray array = new JSONArray();\n                        for (Entry<Object, Integer> e : pattern2value2countEntry.getValue().entrySet()) {\n                            JSONObject v2c = new JSONObject();\n                            JsonUtility.forceLinkedHashMap(v2c);\n                            v2c.put(\"value\", e.getKey());\n                            v2c.put(\"count\", e.getValue());\n                            array.put(v2c);\n                        }\n                        patternUsage.put(pattern2value2countEntry.getKey(), array);\n                    }\n                    perSheetPatternUsage.put(sheetConfig.getSheetName(), patternUsage);\n                }\n                options.getGenerationSummary().put(\"patternUsagePerSheet\", perSheetPatternUsage);\n                File file = new File(workbookFolder, \"summary.json\");\n                try {\n                    FileUtils.writeStringToFile(file, options.getGenerationSummary().toString(2), StandardCharsets.UTF_8);\n                } catch (IOException ex) {\n                    throw new RuntimeException(ex);\n                }\n            }\n        }\/\/per workbook\n    }","code_wo_comment":"public void create(File dstFolder, List<ExcelTable> tables, ExcelSproutOptions options) {\n        Random rnd = new Random(options.getRandomSeed());\n       \n       \n       \n       \n       \n        List<List<ExcelTable>> workbookClusters = getWorkbookClusters(tables, rnd);\n       \n       \n       \n        List<List<List<ExcelTable>>> workbookSheetTables = new ArrayList<>();\n        for (List<ExcelTable> workbookTables : workbookClusters) {\n            List<List<ExcelTable>> sheetTables = new ArrayList<>();\n            for (ExcelTable tbl : workbookTables) {\n                List<ExcelTable> sheet = Arrays.asList(tbl);\n                sheetTables.add(sheet);\n            }\n            workbookSheetTables.add(sheetTables);\n        }\n        int maxDigits = String.valueOf(workbookSheetTables.size() - 1).length();\n        Map<List<ExcelTable>, ExcelGeneratorSheetConfig> sheetConfigMap = new HashMap<>();\n       \n        ExcelGenerator excelGenerator = new ExcelGenerator();\n        for (int i = 0; i < workbookSheetTables.size(); i++) {\n            List<List<ExcelTable>> sheets = workbookSheetTables.get(i);\n           \n            ExcelGeneratorWorkbookConfig workbookConf = new ExcelGeneratorWorkbookConfig();\n           \n            workbookConf.setFileName(\"workbook.xlsx\");\n            for (List<ExcelTable> sheet : sheets) {\n                ExcelGeneratorSheetConfig sheetConf = new ExcelGeneratorSheetConfig();\n                sheetConfigMap.put(sheet, sheetConf);\n                StringBuilder sheetNameSB = new StringBuilder();\n               \n               \n                for (int k = 0; k < sheet.size(); k++) {\n                    ExcelTable excelTable = sheet.get(k);\n                    ExcelGeneratorTableConfig tableConf = new ExcelGeneratorTableConfig();\n                   \n                    Point offset = (Point) excelTable.getSetup().getOrDefault(\"offset\", new Point(0, 0));\n                    tableConf.setOffset(offset);\n                   \n                    tableConf.setStaticCellDrawer(d -> {\n                       \n                        d.exceltable(excelTable, options);\n                    });\n                    sheetConf.getTableConfigs().add(tableConf);\n                   \n                    ClassConfig classConfig = excelTable.getSetup().getOrThrow(\"classes\", ClassConfig.class);\n                    if (classConfig.hasLabel()) {\n                        sheetNameSB.append(classConfig.getLabel());\n                    } else {\n                        throw new RuntimeException(\"ClassConfig should give a label to name the sheet\");\n                    }\n                   \n                    if (k != sheet.size() - 1) {\n                        sheetNameSB.append(\" & \");\n                    }\n                }\n               \n                sheetConf.setSheetName(sheetNameSB.toString());\n                workbookConf.getSheetConfigs().add(sheetConf);\n            \n            ExcelGeneratorResult result = excelGenerator.generate(null, workbookConf);\n           \n           \n            File workbookFolder = workbookSheetTables.size() == 1 ? dstFolder : new File(dstFolder, String.format(\"%0\" + maxDigits + \"d\", i));\n            result.saveExcel(workbookFolder);\n           \n            Model expectedModel = null;\n            Model provenanceModel = null;\n            CSVPrinter provenanceCSV = null;\n            if (options.isWriteExpectedModel()) {\n                expectedModel = ModelFactory.createDefaultModel();\n                expectedModel.setNsPrefixes(options.getPrefixMapping());\n                expectedModel.setNsPrefixes(PrefixMapping.Standard);\n            }\n            if (options.isWriteProvenanceModel()) {\n                provenanceModel = ModelFactory.createDefaultModel();\n                provenanceModel.setNsPrefixes(options.getPrefixMapping());\n                provenanceModel.setNsPrefix(\"prov\", PROV.NS);\n                provenanceModel.setNsPrefix(\"csvw\", CSVW.NS);\n                provenanceModel.setNsPrefix(\"ss\", SS.NS);\n                provenanceModel.setNsPrefixes(PrefixMapping.Standard);\n            }\n            if (options.isWriteProvenanceCSV()) {\n                try {\n                    provenanceCSV = CSVFormat.DEFAULT.print(\n                            new OutputStreamWriter(\n                                    new GZIPOutputStream(\n                                            new FileOutputStream(\n                                                    new File(workbookFolder, \"provenance.csv.gz\")\n                                            ))));\n                    csvProvenanceHeader(provenanceCSV);\n                } catch (IOException ex) {\n                    throw new RuntimeException(ex);\n                }\n            }\n           \n            Map<Statement, Resource> stmt2res = new HashMap<>();\n           \n            for (List<ExcelTable> sheet : sheets) {\n                ExcelGeneratorSheetConfig sheetConfig = sheetConfigMap.get(sheet);\n                for (ExcelTable table : sheet) {\n                    for (Entry<ExcelCell, Provenance> cell2prov : table.getCellProvMap().entrySet()) {\n                        ExcelCell cell = cell2prov.getKey();\n                        Provenance prov = cell2prov.getValue();\n                        if (cell.getAddress() == null) {\n                           \n                           \n                            continue;\n                        }\n                        if (prov.getStatements().isEmpty()) {\n                           \n                            continue;\n                        }\n                        if (options.isWriteExpectedModel()) {\n                            expectedModel.add(prov.getStatements());\n                        }\n                        if (options.isWriteProvenanceModel()) {\n                            rdfProvenance(cell, sheetConfig.getSheetName(), prov, stmt2res, provenanceModel);\n                        }\n                        if (options.isWriteProvenanceCSV()) {\n                            csvProvenance(cell, sheetConfig.getSheetName(), prov, provenanceCSV, provenanceModel);\n                        }\n                    }\n                }\n            }\n           \n            if (options.isWriteExpectedModel()) {\n                File file = new File(workbookFolder, \"expected.ttl.gz\");\n                try (OutputStream os = file.getName().endsWith(\"gz\") ? new GZIPOutputStream(new FileOutputStream(file)) : new FileOutputStream(file)) {\n                    expectedModel.write(os, \"TTL\");\n                } catch (IOException ex) {\n                    throw new RuntimeException(ex);\n                }\n            }\n            if (options.isWriteProvenanceModel()) {\n                File file = new File(workbookFolder, \"provenance.ttl.gz\");\n                try (OutputStream os = file.getName().endsWith(\"gz\") ? new GZIPOutputStream(new FileOutputStream(file)) : new FileOutputStream(file)) {\n                    provenanceModel.write(os, \"TTL\");\n                } catch (IOException ex) {\n                    throw new RuntimeException(ex);\n                }\n            }\n            if (options.isWriteProvenanceCSV()) {\n                try {\n                    provenanceCSV.close();\n                } catch (IOException ex) {\n                    throw new RuntimeException(ex);\n                }\n            }\n            if (options.isWriteGenerationSummaryJson()) {\n               \n                JSONObject perSheetPatternUsage = new JSONObject();\n                JsonUtility.forceLinkedHashMap(perSheetPatternUsage);\n                for (List<ExcelTable> sheet : sheets) {\n                    ExcelGeneratorSheetConfig sheetConfig = sheetConfigMap.get(sheet);\n                   \n                    Map<String, Map<Object, Integer>> pattern2value2count = new HashMap<>();\n                    for (ExcelTable tbl : sheet) {\n                        for (Entry<ExcelCell, Provenance> entry : tbl.getCellProvMap().entrySet()) {\n                           \n                            if (entry.getKey().getAddress() == null || entry.getValue().getStatements().isEmpty()) {\n                                continue;\n                            }\n                            for (Entry<String, Object> e : entry.getValue().getUsedPatterns().entrySet()) {\n                                Object val = e.getValue();\n                                if(val instanceof JSONArray) {\n                                   \n                                    val = val.toString();\n                                }\n                                Map<Object, Integer> value2count = pattern2value2count.computeIfAbsent(e.getKey(), k -> new HashMap<>());\n                                value2count.put(val, value2count.getOrDefault(val, 0) + 1);\n                            }\n                        }\n                    }\n                    JSONObject patternUsage = new JSONObject();\n                    JsonUtility.forceLinkedHashMap(patternUsage);\n                    List<Entry<String, Map<Object, Integer>>> pattern2value2countList = new ArrayList<>(pattern2value2count.entrySet());\n                    pattern2value2countList.sort((a,b) -> a.getKey().compareTo(b.getKey()));\n                    for (Entry<String, Map<Object, Integer>> pattern2value2countEntry : pattern2value2countList) {\n                        JSONArray array = new JSONArray();\n                        for (Entry<Object, Integer> e : pattern2value2countEntry.getValue().entrySet()) {\n                            JSONObject v2c = new JSONObject();\n                            JsonUtility.forceLinkedHashMap(v2c);\n                            v2c.put(\"value\", e.getKey());\n                            v2c.put(\"count\", e.getValue());\n                            array.put(v2c);\n                        }\n                        patternUsage.put(pattern2value2countEntry.getKey(), array);\n                    }\n                    perSheetPatternUsage.put(sheetConfig.getSheetName(), patternUsage);\n                }\n                options.getGenerationSummary().put(\"patternUsagePerSheet\", perSheetPatternUsage);\n                File file = new File(workbookFolder, \"summary.json\");\n                try {\n                    FileUtils.writeStringToFile(file, options.getGenerationSummary().toString(2), StandardCharsets.UTF_8);\n                } catch (IOException ex) {\n                    throw new RuntimeException(ex);\n                }\n            }\n        \n    }","cleancode":"public void create(file dstfolder, list<exceltable> tables, excelsproutoptions options) { random rnd = new random(options.getrandomseed()); list<list<exceltable>> workbookclusters = getworkbookclusters(tables, rnd); list<list<list<exceltable>>> workbooksheettables = new arraylist<>(); for (list<exceltable> workbooktables : workbookclusters) { list<list<exceltable>> sheettables = new arraylist<>(); for (exceltable tbl : workbooktables) { list<exceltable> sheet = arrays.aslist(tbl); sheettables.add(sheet); } workbooksheettables.add(sheettables); } int maxdigits = string.valueof(workbooksheettables.size() - 1).length(); map<list<exceltable>, excelgeneratorsheetconfig> sheetconfigmap = new hashmap<>(); excelgenerator excelgenerator = new excelgenerator(); for (int i = 0; i < workbooksheettables.size(); i++) { list<list<exceltable>> sheets = workbooksheettables.get(i); excelgeneratorworkbookconfig workbookconf = new excelgeneratorworkbookconfig(); workbookconf.setfilename(\"workbook.xlsx\"); for (list<exceltable> sheet : sheets) { excelgeneratorsheetconfig sheetconf = new excelgeneratorsheetconfig(); sheetconfigmap.put(sheet, sheetconf); stringbuilder sheetnamesb = new stringbuilder(); for (int k = 0; k < sheet.size(); k++) { exceltable exceltable = sheet.get(k); excelgeneratortableconfig tableconf = new excelgeneratortableconfig(); point offset = (point) exceltable.getsetup().getordefault(\"offset\", new point(0, 0)); tableconf.setoffset(offset); tableconf.setstaticcelldrawer(d -> { d.exceltable(exceltable, options); }); sheetconf.gettableconfigs().add(tableconf); classconfig classconfig = exceltable.getsetup().getorthrow(\"classes\", classconfig.class); if (classconfig.haslabel()) { sheetnamesb.append(classconfig.getlabel()); } else { throw new runtimeexception(\"classconfig should give a label to name the sheet\"); } if (k != sheet.size() - 1) { sheetnamesb.append(\" & \"); } } sheetconf.setsheetname(sheetnamesb.tostring()); workbookconf.getsheetconfigs().add(sheetconf); excelgeneratorresult result = excelgenerator.generate(null, workbookconf); file workbookfolder = workbooksheettables.size() == 1 ? dstfolder : new file(dstfolder, string.format(\"%0\" + maxdigits + \"d\", i)); result.saveexcel(workbookfolder); model expectedmodel = null; model provenancemodel = null; csvprinter provenancecsv = null; if (options.iswriteexpectedmodel()) { expectedmodel = modelfactory.createdefaultmodel(); expectedmodel.setnsprefixes(options.getprefixmapping()); expectedmodel.setnsprefixes(prefixmapping.standard); } if (options.iswriteprovenancemodel()) { provenancemodel = modelfactory.createdefaultmodel(); provenancemodel.setnsprefixes(options.getprefixmapping()); provenancemodel.setnsprefix(\"prov\", prov.ns); provenancemodel.setnsprefix(\"csvw\", csvw.ns); provenancemodel.setnsprefix(\"ss\", ss.ns); provenancemodel.setnsprefixes(prefixmapping.standard); } if (options.iswriteprovenancecsv()) { try { provenancecsv = csvformat.default.print( new outputstreamwriter( new gzipoutputstream( new fileoutputstream( new file(workbookfolder, \"provenance.csv.gz\") )))); csvprovenanceheader(provenancecsv); } catch (ioexception ex) { throw new runtimeexception(ex); } } map<statement, resource> stmt2res = new hashmap<>(); for (list<exceltable> sheet : sheets) { excelgeneratorsheetconfig sheetconfig = sheetconfigmap.get(sheet); for (exceltable table : sheet) { for (entry<excelcell, provenance> cell2prov : table.getcellprovmap().entryset()) { excelcell cell = cell2prov.getkey(); provenance prov = cell2prov.getvalue(); if (cell.getaddress() == null) { continue; } if (prov.getstatements().isempty()) { continue; } if (options.iswriteexpectedmodel()) { expectedmodel.add(prov.getstatements()); } if (options.iswriteprovenancemodel()) { rdfprovenance(cell, sheetconfig.getsheetname(), prov, stmt2res, provenancemodel); } if (options.iswriteprovenancecsv()) { csvprovenance(cell, sheetconfig.getsheetname(), prov, provenancecsv, provenancemodel); } } } } if (options.iswriteexpectedmodel()) { file file = new file(workbookfolder, \"expected.ttl.gz\"); try (outputstream os = file.getname().endswith(\"gz\") ? new gzipoutputstream(new fileoutputstream(file)) : new fileoutputstream(file)) { expectedmodel.write(os, \"ttl\"); } catch (ioexception ex) { throw new runtimeexception(ex); } } if (options.iswriteprovenancemodel()) { file file = new file(workbookfolder, \"provenance.ttl.gz\"); try (outputstream os = file.getname().endswith(\"gz\") ? new gzipoutputstream(new fileoutputstream(file)) : new fileoutputstream(file)) { provenancemodel.write(os, \"ttl\"); } catch (ioexception ex) { throw new runtimeexception(ex); } } if (options.iswriteprovenancecsv()) { try { provenancecsv.close(); } catch (ioexception ex) { throw new runtimeexception(ex); } } if (options.iswritegenerationsummaryjson()) { jsonobject persheetpatternusage = new jsonobject(); jsonutility.forcelinkedhashmap(persheetpatternusage); for (list<exceltable> sheet : sheets) { excelgeneratorsheetconfig sheetconfig = sheetconfigmap.get(sheet); map<string, map<object, integer>> pattern2value2count = new hashmap<>(); for (exceltable tbl : sheet) { for (entry<excelcell, provenance> entry : tbl.getcellprovmap().entryset()) { if (entry.getkey().getaddress() == null || entry.getvalue().getstatements().isempty()) { continue; } for (entry<string, object> e : entry.getvalue().getusedpatterns().entryset()) { object val = e.getvalue(); if(val instanceof jsonarray) { val = val.tostring(); } map<object, integer> value2count = pattern2value2count.computeifabsent(e.getkey(), k -> new hashmap<>()); value2count.put(val, value2count.getordefault(val, 0) + 1); } } } jsonobject patternusage = new jsonobject(); jsonutility.forcelinkedhashmap(patternusage); list<entry<string, map<object, integer>>> pattern2value2countlist = new arraylist<>(pattern2value2count.entryset()); pattern2value2countlist.sort((a,b) -> a.getkey().compareto(b.getkey())); for (entry<string, map<object, integer>> pattern2value2countentry : pattern2value2countlist) { jsonarray array = new jsonarray(); for (entry<object, integer> e : pattern2value2countentry.getvalue().entryset()) { jsonobject v2c = new jsonobject(); jsonutility.forcelinkedhashmap(v2c); v2c.put(\"value\", e.getkey()); v2c.put(\"count\", e.getvalue()); array.put(v2c); } patternusage.put(pattern2value2countentry.getkey(), array); } persheetpatternusage.put(sheetconfig.getsheetname(), patternusage); } options.getgenerationsummary().put(\"patternusagepersheet\", persheetpatternusage); file file = new file(workbookfolder, \"summary.json\"); try { fileutils.writestringtofile(file, options.getgenerationsummary().tostring(2), standardcharsets.utf_8); } catch (ioexception ex) { throw new runtimeexception(ex); } } }","repo":"mschroeder-github\/datasprout","label":[1,1,0,0]}
{"id":16159,"original_code":"@Override\n    public boolean equals(Object o) {\n        if (this == o) return true;\n        if (o == null || getClass() != o.getClass()) return false;\n        ParameterizedTypeImpl that = (ParameterizedTypeImpl) o;\n        \/\/ Probably incorrect - comparing Object[] arrays with Arrays.equals\n        if (!Arrays.equals(actualTypeArguments, that.actualTypeArguments)) return false;\n        if (ownerType != null ? !ownerType.equals(that.ownerType) : that.ownerType != null) return false;\n        return rawType != null ? rawType.equals(that.rawType) : that.rawType == null;\n    }","code_wo_comment":"@Override\n    public boolean equals(Object o) {\n        if (this == o) return true;\n        if (o == null || getClass() != o.getClass()) return false;\n        ParameterizedTypeImpl that = (ParameterizedTypeImpl) o;\n       \n        if (!Arrays.equals(actualTypeArguments, that.actualTypeArguments)) return false;\n        if (ownerType != null ? !ownerType.equals(that.ownerType) : that.ownerType != null) return false;\n        return rawType != null ? rawType.equals(that.rawType) : that.rawType == null;\n    }","cleancode":"@override public boolean equals(object o) { if (this == o) return true; if (o == null || getclass() != o.getclass()) return false; parameterizedtypeimpl that = (parameterizedtypeimpl) o; if (!arrays.equals(actualtypearguments, that.actualtypearguments)) return false; if (ownertype != null ? !ownertype.equals(that.ownertype) : that.ownertype != null) return false; return rawtype != null ? rawtype.equals(that.rawtype) : that.rawtype == null; }","repo":"osglworks\/java-di","label":[0,0,1,0]}
{"id":8062,"original_code":"@Override \/\/ ObjectEventListener\n    public Object addingObject (Object obj, int index)\n    {\n        ObjectRenderer renderer = rendererFactory.newRenderer (obj);\n        \/\/ TODO: VAADIN SESSION HANDLING\n        layout.addComponent (renderer, index);\n        active_renderers.put (get_object_hash (obj), renderer);\n        log.info (\"<<RENDERER>> addingObject() layout height = {} {}\", layout.getHeight (), layout.getHeightUnits ().toString ());\n        log.info (\"Add new renderer {}: obj={} or={} \/\/\/ active_renderers={}\", this, get_object_hash (obj), renderer, active_renderers);\n        return (obj);\n    }","code_wo_comment":"@Override     public Object addingObject (Object obj, int index)\n    {\n        ObjectRenderer renderer = rendererFactory.newRenderer (obj);\n       \n        layout.addComponent (renderer, index);\n        active_renderers.put (get_object_hash (obj), renderer);\n        log.info (\"<<RENDERER>> addingObject() layout height = {} {}\", layout.getHeight (), layout.getHeightUnits ().toString ());\n        log.info (\"Add new renderer {}: obj={} or={} \/\/\/ active_renderers={}\", this, get_object_hash (obj), renderer, active_renderers);\n        return (obj);\n    }","cleancode":"@override public object addingobject (object obj, int index) { objectrenderer renderer = rendererfactory.newrenderer (obj); layout.addcomponent (renderer, index); active_renderers.put (get_object_hash (obj), renderer); log.info (\"<<renderer>> addingobject() layout height = {} {}\", layout.getheight (), layout.getheightunits ().tostring ()); log.info (\"add new renderer {}: obj={} or={} \/\/\/ active_renderers={}\", this, get_object_hash (obj), renderer, active_renderers); return (obj); }","repo":"neoautus\/lucidj","label":[0,1,0,0]}
{"id":8063,"original_code":"@Override \/\/ ObjectEventListener\n    public void removingObject (Object obj, int index)\n    {\n        String hash = get_object_hash (obj);\n        ObjectRenderer renderer = active_renderers.get (hash);\n        log.info (\"removingObject: obj={} or={} layout={} \/\/\/ active_renderers={}\", hash, renderer, layout, active_renderers);\n        \/\/ Only deal with valid renderers\n        if (renderer != null)\n        {\n            \/\/ TODO: VAADIN SESSION HANDLING\n            layout.removeComponent (renderer);\n            log.info (\"<<RENDERER>> removingObject() layout height = {} {}\", layout.getHeight (), layout.getHeightUnits ().toString ());\n        }\n        active_renderers.remove (hash);\n    }","code_wo_comment":"@Override     public void removingObject (Object obj, int index)\n    {\n        String hash = get_object_hash (obj);\n        ObjectRenderer renderer = active_renderers.get (hash);\n        log.info (\"removingObject: obj={} or={} layout={} \/\/\/ active_renderers={}\", hash, renderer, layout, active_renderers);\n       \n        if (renderer != null)\n        {\n           \n            layout.removeComponent (renderer);\n            log.info (\"<<RENDERER>> removingObject() layout height = {} {}\", layout.getHeight (), layout.getHeightUnits ().toString ());\n        }\n        active_renderers.remove (hash);\n    }","cleancode":"@override public void removingobject (object obj, int index) { string hash = get_object_hash (obj); objectrenderer renderer = active_renderers.get (hash); log.info (\"removingobject: obj={} or={} layout={} \/\/\/ active_renderers={}\", hash, renderer, layout, active_renderers); if (renderer != null) { layout.removecomponent (renderer); log.info (\"<<renderer>> removingobject() layout height = {} {}\", layout.getheight (), layout.getheightunits ().tostring ()); } active_renderers.remove (hash); }","repo":"neoautus\/lucidj","label":[0,1,0,0]}
